{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY0MjcwODQ2", "number": 60851, "title": "Implement distance_feature for runtime dates", "bodyText": "This implements the distance_feature for date valued runtime_scripts. This produces the same numbers running against an indexed date, but it doesn't have the same performance characteristics at all. Which is normal for runtime_scripts. But distance_feature` against an indexes fields does a lot of work to refine the query as it goes, limiting the number of documents that it has to visit. We can't do that because we don't have an index. So we just spit out the same numbers and hope it is good enough.", "createdAt": "2020-08-06T21:23:02Z", "url": "https://github.com/elastic/elasticsearch/pull/60851", "merged": true, "mergeCommit": {"oid": "f3b65eb32c2a3d95572913d478af2168e2f763fb"}, "closed": true, "closedAt": "2020-08-17T14:14:50Z", "author": {"login": "nik9000"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc8WfcuAH2gAyNDY0MjcwODQ2OjJhMWM0YjFmZjQ1YTg3MWNhNWI0ZTY1MDRiMDBmOTNhMzY0NTg1YjY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc-xI5PgFqTQ2NzQzNDAxNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "2a1c4b1ff45a871ca5b4e6504b00f93a364585b6", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/2a1c4b1ff45a871ca5b4e6504b00f93a364585b6", "committedDate": "2020-08-06T21:13:48Z", "message": "WIP"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "05d5c5a147ec7501d6ff524d88fdf00ef403d85c", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/05d5c5a147ec7501d6ff524d88fdf00ef403d85c", "committedDate": "2020-08-06T21:17:07Z", "message": "Merge branch 'feature/runtime_fields' into runtime_fields_distance_feature"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f788941140488bb51c7950ac11797ab8a606b6b9", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/f788941140488bb51c7950ac11797ab8a606b6b9", "committedDate": "2020-08-06T21:34:57Z", "message": "Finish test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTE2NTQw", "url": "https://github.com/elastic/elasticsearch/pull/60851#pullrequestreview-466916540", "createdAt": "2020-08-13T16:18:01Z", "commit": {"oid": "f788941140488bb51c7950ac11797ab8a606b6b9"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNjoxODowMlrOHASxmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNjo1Nzo1NVrOHAUPxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA2OTY1OQ==", "bodyText": "Should a potential max score be:  weight instead of boost?\nThis method and several other methods  don't seem to throw IOException", "url": "https://github.com/elastic/elasticsearch/pull/60851#discussion_r470069659", "createdAt": "2020-08-13T16:18:02Z", "author": {"login": "mayya-sharipova"}, "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/query/LongScriptFieldDistanceFeatureQuery.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.runtimefields.query;\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.DocIdSetIterator;\n+import org.apache.lucene.search.Explanation;\n+import org.apache.lucene.search.IndexSearcher;\n+import org.apache.lucene.search.QueryVisitor;\n+import org.apache.lucene.search.ScoreMode;\n+import org.apache.lucene.search.Scorer;\n+import org.apache.lucene.search.TwoPhaseIterator;\n+import org.apache.lucene.search.Weight;\n+import org.elasticsearch.common.CheckedFunction;\n+import org.elasticsearch.script.Script;\n+import org.elasticsearch.xpack.runtimefields.AbstractLongScriptFieldScript;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+public final class LongScriptFieldDistanceFeatureQuery extends AbstractScriptFieldQuery {\n+    private final CheckedFunction<LeafReaderContext, AbstractLongScriptFieldScript, IOException> leafFactory;\n+    private final long origin;\n+    private final long pivot;\n+    private final float boost;\n+\n+    public LongScriptFieldDistanceFeatureQuery(\n+        Script script,\n+        CheckedFunction<LeafReaderContext, AbstractLongScriptFieldScript, IOException> leafFactory,\n+        String fieldName,\n+        long origin,\n+        long pivot,\n+        float boost\n+    ) {\n+        super(script, fieldName);\n+        this.leafFactory = leafFactory;\n+        this.origin = origin;\n+        this.pivot = pivot;\n+        this.boost = boost;\n+    }\n+\n+    @Override\n+    public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n+        return new Weight(this) {\n+            @Override\n+            public boolean isCacheable(LeafReaderContext ctx) {\n+                return false;\n+            }\n+\n+            @Override\n+            public void extractTerms(Set<Term> terms) {}\n+\n+            @Override\n+            public Scorer scorer(LeafReaderContext context) throws IOException {\n+                return new DistanceScorer(this, leafFactory.apply(context), context.reader().maxDoc(), boost);\n+            }\n+\n+            @Override\n+            public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n+                AbstractLongScriptFieldScript script = leafFactory.apply(context);\n+                script.runForDoc(doc);\n+                long value = valueWithMinAbsoluteDistance(script);\n+                float weight = LongScriptFieldDistanceFeatureQuery.this.boost * boost;\n+                float score = score(weight, distanceFor(value));\n+                return Explanation.match(\n+                    score,\n+                    \"Distance score, computed as weight * pivot / (pivot + abs(value - origin)) from:\",\n+                    Explanation.match(weight, \"weight\"),\n+                    Explanation.match(pivot, \"pivot\"),\n+                    Explanation.match(origin, \"origin\"),\n+                    Explanation.match(value, \"current value\")\n+                );\n+            }\n+        };\n+    }\n+\n+    private class DistanceScorer extends Scorer {\n+        private final AbstractLongScriptFieldScript script;\n+        private final TwoPhaseIterator twoPhase;\n+        private final DocIdSetIterator disi;\n+        private final float weight;\n+\n+        protected DistanceScorer(Weight weight, AbstractLongScriptFieldScript script, int maxDoc, float boost) {\n+            super(weight);\n+            this.script = script;\n+            twoPhase = new TwoPhaseIterator(DocIdSetIterator.all(maxDoc)) {\n+                @Override\n+                public boolean matches() throws IOException {\n+                    script.runForDoc(approximation().docID());\n+                    return script.count() > 0;\n+                }\n+\n+                @Override\n+                public float matchCost() {\n+                    return MATCH_COST;\n+                }\n+            };\n+            disi = TwoPhaseIterator.asDocIdSetIterator(twoPhase);\n+            this.weight = LongScriptFieldDistanceFeatureQuery.this.boost * boost;\n+        }\n+\n+        @Override\n+        public int docID() {\n+            return disi.docID();\n+        }\n+\n+        @Override\n+        public DocIdSetIterator iterator() {\n+            return disi;\n+        }\n+\n+        @Override\n+        public TwoPhaseIterator twoPhaseIterator() {\n+            return twoPhase;\n+        }\n+\n+        @Override\n+        public float getMaxScore(int upTo) throws IOException {\n+            return boost;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f788941140488bb51c7950ac11797ab8a606b6b9"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA3OTU2OQ==", "bodyText": "should we incorporate the initial boost to hashCode, equals, toString ?", "url": "https://github.com/elastic/elasticsearch/pull/60851#discussion_r470079569", "createdAt": "2020-08-13T16:34:04Z", "author": {"login": "mayya-sharipova"}, "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/query/LongScriptFieldDistanceFeatureQuery.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.runtimefields.query;\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.DocIdSetIterator;\n+import org.apache.lucene.search.Explanation;\n+import org.apache.lucene.search.IndexSearcher;\n+import org.apache.lucene.search.QueryVisitor;\n+import org.apache.lucene.search.ScoreMode;\n+import org.apache.lucene.search.Scorer;\n+import org.apache.lucene.search.TwoPhaseIterator;\n+import org.apache.lucene.search.Weight;\n+import org.elasticsearch.common.CheckedFunction;\n+import org.elasticsearch.script.Script;\n+import org.elasticsearch.xpack.runtimefields.AbstractLongScriptFieldScript;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+public final class LongScriptFieldDistanceFeatureQuery extends AbstractScriptFieldQuery {\n+    private final CheckedFunction<LeafReaderContext, AbstractLongScriptFieldScript, IOException> leafFactory;\n+    private final long origin;\n+    private final long pivot;\n+    private final float boost;\n+\n+    public LongScriptFieldDistanceFeatureQuery(\n+        Script script,\n+        CheckedFunction<LeafReaderContext, AbstractLongScriptFieldScript, IOException> leafFactory,\n+        String fieldName,\n+        long origin,\n+        long pivot,\n+        float boost\n+    ) {\n+        super(script, fieldName);\n+        this.leafFactory = leafFactory;\n+        this.origin = origin;\n+        this.pivot = pivot;\n+        this.boost = boost;\n+    }\n+\n+    @Override\n+    public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n+        return new Weight(this) {\n+            @Override\n+            public boolean isCacheable(LeafReaderContext ctx) {\n+                return false;\n+            }\n+\n+            @Override\n+            public void extractTerms(Set<Term> terms) {}\n+\n+            @Override\n+            public Scorer scorer(LeafReaderContext context) throws IOException {\n+                return new DistanceScorer(this, leafFactory.apply(context), context.reader().maxDoc(), boost);\n+            }\n+\n+            @Override\n+            public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n+                AbstractLongScriptFieldScript script = leafFactory.apply(context);\n+                script.runForDoc(doc);\n+                long value = valueWithMinAbsoluteDistance(script);\n+                float weight = LongScriptFieldDistanceFeatureQuery.this.boost * boost;\n+                float score = score(weight, distanceFor(value));\n+                return Explanation.match(\n+                    score,\n+                    \"Distance score, computed as weight * pivot / (pivot + abs(value - origin)) from:\",\n+                    Explanation.match(weight, \"weight\"),\n+                    Explanation.match(pivot, \"pivot\"),\n+                    Explanation.match(origin, \"origin\"),\n+                    Explanation.match(value, \"current value\")\n+                );\n+            }\n+        };\n+    }\n+\n+    private class DistanceScorer extends Scorer {\n+        private final AbstractLongScriptFieldScript script;\n+        private final TwoPhaseIterator twoPhase;\n+        private final DocIdSetIterator disi;\n+        private final float weight;\n+\n+        protected DistanceScorer(Weight weight, AbstractLongScriptFieldScript script, int maxDoc, float boost) {\n+            super(weight);\n+            this.script = script;\n+            twoPhase = new TwoPhaseIterator(DocIdSetIterator.all(maxDoc)) {\n+                @Override\n+                public boolean matches() throws IOException {\n+                    script.runForDoc(approximation().docID());\n+                    return script.count() > 0;\n+                }\n+\n+                @Override\n+                public float matchCost() {\n+                    return MATCH_COST;\n+                }\n+            };\n+            disi = TwoPhaseIterator.asDocIdSetIterator(twoPhase);\n+            this.weight = LongScriptFieldDistanceFeatureQuery.this.boost * boost;\n+        }\n+\n+        @Override\n+        public int docID() {\n+            return disi.docID();\n+        }\n+\n+        @Override\n+        public DocIdSetIterator iterator() {\n+            return disi;\n+        }\n+\n+        @Override\n+        public TwoPhaseIterator twoPhaseIterator() {\n+            return twoPhase;\n+        }\n+\n+        @Override\n+        public float getMaxScore(int upTo) throws IOException {\n+            return boost;\n+        }\n+\n+        @Override\n+        public float score() throws IOException {\n+            if (script.count() == 0) {\n+                return 0;\n+            }\n+            return LongScriptFieldDistanceFeatureQuery.this.score(weight, (double) minAbsoluteDistance(script));\n+        }\n+    }\n+\n+    long minAbsoluteDistance(AbstractLongScriptFieldScript script) {\n+        long minDistance = Long.MAX_VALUE;\n+        for (int i = 0; i < script.count(); i++) {\n+            minDistance = Math.min(minDistance, distanceFor(script.values()[i]));\n+        }\n+        return minDistance;\n+    }\n+\n+    long valueWithMinAbsoluteDistance(AbstractLongScriptFieldScript script) {\n+        long minDistance = Long.MAX_VALUE;\n+        long minDistanceValue = Long.MAX_VALUE;\n+        for (int i = 0; i < script.count(); i++) {\n+            long distance = distanceFor(script.values()[i]);\n+            if (distance < minDistance) {\n+                minDistance = distance;\n+                minDistanceValue = script.values()[i];\n+            }\n+        }\n+        return minDistanceValue;\n+    }\n+\n+    long distanceFor(long value) {\n+        long distance = Math.max(value, origin) - Math.min(value, origin);\n+        if (distance < 0) {\n+            // The distance doesn't fit into signed long so clamp it to MAX_VALUE\n+            return Long.MAX_VALUE;\n+        }\n+        return distance;\n+    }\n+\n+    float score(float weight, double distance) {\n+        return (float) (weight * (pivot / (pivot + distance)));\n+    }\n+\n+    @Override\n+    public String toString(String field) {\n+        StringBuilder b = new StringBuilder();\n+        if (false == fieldName().equals(field)) {\n+            b.append(fieldName()).append(\":\");\n+        }\n+        b.append(getClass().getSimpleName()).append(\"(origin=\").append(origin).append(\",pivot=\").append(pivot).append(\")\");\n+        return b.toString();\n+\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(super.hashCode(), origin, pivot);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f788941140488bb51c7950ac11797ab8a606b6b9"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA5Mzc2Ng==", "bodyText": "I am not familiar with runtime fields, but I am wondering if we intend always to create an iterator across all documents? Do we plan to add support to limit number of docs (e.g. only docs returned by a top filter)?", "url": "https://github.com/elastic/elasticsearch/pull/60851#discussion_r470093766", "createdAt": "2020-08-13T16:57:55Z", "author": {"login": "mayya-sharipova"}, "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/query/LongScriptFieldDistanceFeatureQuery.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.runtimefields.query;\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.DocIdSetIterator;\n+import org.apache.lucene.search.Explanation;\n+import org.apache.lucene.search.IndexSearcher;\n+import org.apache.lucene.search.QueryVisitor;\n+import org.apache.lucene.search.ScoreMode;\n+import org.apache.lucene.search.Scorer;\n+import org.apache.lucene.search.TwoPhaseIterator;\n+import org.apache.lucene.search.Weight;\n+import org.elasticsearch.common.CheckedFunction;\n+import org.elasticsearch.script.Script;\n+import org.elasticsearch.xpack.runtimefields.AbstractLongScriptFieldScript;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+public final class LongScriptFieldDistanceFeatureQuery extends AbstractScriptFieldQuery {\n+    private final CheckedFunction<LeafReaderContext, AbstractLongScriptFieldScript, IOException> leafFactory;\n+    private final long origin;\n+    private final long pivot;\n+    private final float boost;\n+\n+    public LongScriptFieldDistanceFeatureQuery(\n+        Script script,\n+        CheckedFunction<LeafReaderContext, AbstractLongScriptFieldScript, IOException> leafFactory,\n+        String fieldName,\n+        long origin,\n+        long pivot,\n+        float boost\n+    ) {\n+        super(script, fieldName);\n+        this.leafFactory = leafFactory;\n+        this.origin = origin;\n+        this.pivot = pivot;\n+        this.boost = boost;\n+    }\n+\n+    @Override\n+    public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n+        return new Weight(this) {\n+            @Override\n+            public boolean isCacheable(LeafReaderContext ctx) {\n+                return false;\n+            }\n+\n+            @Override\n+            public void extractTerms(Set<Term> terms) {}\n+\n+            @Override\n+            public Scorer scorer(LeafReaderContext context) throws IOException {\n+                return new DistanceScorer(this, leafFactory.apply(context), context.reader().maxDoc(), boost);\n+            }\n+\n+            @Override\n+            public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n+                AbstractLongScriptFieldScript script = leafFactory.apply(context);\n+                script.runForDoc(doc);\n+                long value = valueWithMinAbsoluteDistance(script);\n+                float weight = LongScriptFieldDistanceFeatureQuery.this.boost * boost;\n+                float score = score(weight, distanceFor(value));\n+                return Explanation.match(\n+                    score,\n+                    \"Distance score, computed as weight * pivot / (pivot + abs(value - origin)) from:\",\n+                    Explanation.match(weight, \"weight\"),\n+                    Explanation.match(pivot, \"pivot\"),\n+                    Explanation.match(origin, \"origin\"),\n+                    Explanation.match(value, \"current value\")\n+                );\n+            }\n+        };\n+    }\n+\n+    private class DistanceScorer extends Scorer {\n+        private final AbstractLongScriptFieldScript script;\n+        private final TwoPhaseIterator twoPhase;\n+        private final DocIdSetIterator disi;\n+        private final float weight;\n+\n+        protected DistanceScorer(Weight weight, AbstractLongScriptFieldScript script, int maxDoc, float boost) {\n+            super(weight);\n+            this.script = script;\n+            twoPhase = new TwoPhaseIterator(DocIdSetIterator.all(maxDoc)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f788941140488bb51c7950ac11797ab8a606b6b9"}, "originalPosition": 92}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MDI2MjY5", "url": "https://github.com/elastic/elasticsearch/pull/60851#pullrequestreview-467026269", "createdAt": "2020-08-13T18:28:23Z", "commit": {"oid": "f788941140488bb51c7950ac11797ab8a606b6b9"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxODoyODoyM1rOHAYUdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxODozMTo1MVrOHAYcTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE2MDUwMg==", "bodyText": "Yes! good catch.", "url": "https://github.com/elastic/elasticsearch/pull/60851#discussion_r470160502", "createdAt": "2020-08-13T18:28:23Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/query/LongScriptFieldDistanceFeatureQuery.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.runtimefields.query;\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.DocIdSetIterator;\n+import org.apache.lucene.search.Explanation;\n+import org.apache.lucene.search.IndexSearcher;\n+import org.apache.lucene.search.QueryVisitor;\n+import org.apache.lucene.search.ScoreMode;\n+import org.apache.lucene.search.Scorer;\n+import org.apache.lucene.search.TwoPhaseIterator;\n+import org.apache.lucene.search.Weight;\n+import org.elasticsearch.common.CheckedFunction;\n+import org.elasticsearch.script.Script;\n+import org.elasticsearch.xpack.runtimefields.AbstractLongScriptFieldScript;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+public final class LongScriptFieldDistanceFeatureQuery extends AbstractScriptFieldQuery {\n+    private final CheckedFunction<LeafReaderContext, AbstractLongScriptFieldScript, IOException> leafFactory;\n+    private final long origin;\n+    private final long pivot;\n+    private final float boost;\n+\n+    public LongScriptFieldDistanceFeatureQuery(\n+        Script script,\n+        CheckedFunction<LeafReaderContext, AbstractLongScriptFieldScript, IOException> leafFactory,\n+        String fieldName,\n+        long origin,\n+        long pivot,\n+        float boost\n+    ) {\n+        super(script, fieldName);\n+        this.leafFactory = leafFactory;\n+        this.origin = origin;\n+        this.pivot = pivot;\n+        this.boost = boost;\n+    }\n+\n+    @Override\n+    public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n+        return new Weight(this) {\n+            @Override\n+            public boolean isCacheable(LeafReaderContext ctx) {\n+                return false;\n+            }\n+\n+            @Override\n+            public void extractTerms(Set<Term> terms) {}\n+\n+            @Override\n+            public Scorer scorer(LeafReaderContext context) throws IOException {\n+                return new DistanceScorer(this, leafFactory.apply(context), context.reader().maxDoc(), boost);\n+            }\n+\n+            @Override\n+            public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n+                AbstractLongScriptFieldScript script = leafFactory.apply(context);\n+                script.runForDoc(doc);\n+                long value = valueWithMinAbsoluteDistance(script);\n+                float weight = LongScriptFieldDistanceFeatureQuery.this.boost * boost;\n+                float score = score(weight, distanceFor(value));\n+                return Explanation.match(\n+                    score,\n+                    \"Distance score, computed as weight * pivot / (pivot + abs(value - origin)) from:\",\n+                    Explanation.match(weight, \"weight\"),\n+                    Explanation.match(pivot, \"pivot\"),\n+                    Explanation.match(origin, \"origin\"),\n+                    Explanation.match(value, \"current value\")\n+                );\n+            }\n+        };\n+    }\n+\n+    private class DistanceScorer extends Scorer {\n+        private final AbstractLongScriptFieldScript script;\n+        private final TwoPhaseIterator twoPhase;\n+        private final DocIdSetIterator disi;\n+        private final float weight;\n+\n+        protected DistanceScorer(Weight weight, AbstractLongScriptFieldScript script, int maxDoc, float boost) {\n+            super(weight);\n+            this.script = script;\n+            twoPhase = new TwoPhaseIterator(DocIdSetIterator.all(maxDoc)) {\n+                @Override\n+                public boolean matches() throws IOException {\n+                    script.runForDoc(approximation().docID());\n+                    return script.count() > 0;\n+                }\n+\n+                @Override\n+                public float matchCost() {\n+                    return MATCH_COST;\n+                }\n+            };\n+            disi = TwoPhaseIterator.asDocIdSetIterator(twoPhase);\n+            this.weight = LongScriptFieldDistanceFeatureQuery.this.boost * boost;\n+        }\n+\n+        @Override\n+        public int docID() {\n+            return disi.docID();\n+        }\n+\n+        @Override\n+        public DocIdSetIterator iterator() {\n+            return disi;\n+        }\n+\n+        @Override\n+        public TwoPhaseIterator twoPhaseIterator() {\n+            return twoPhase;\n+        }\n+\n+        @Override\n+        public float getMaxScore(int upTo) throws IOException {\n+            return boost;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA2OTY1OQ=="}, "originalCommit": {"oid": "f788941140488bb51c7950ac11797ab8a606b6b9"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE2MDYzNQ==", "bodyText": "Yes.", "url": "https://github.com/elastic/elasticsearch/pull/60851#discussion_r470160635", "createdAt": "2020-08-13T18:28:36Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/query/LongScriptFieldDistanceFeatureQuery.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.runtimefields.query;\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.DocIdSetIterator;\n+import org.apache.lucene.search.Explanation;\n+import org.apache.lucene.search.IndexSearcher;\n+import org.apache.lucene.search.QueryVisitor;\n+import org.apache.lucene.search.ScoreMode;\n+import org.apache.lucene.search.Scorer;\n+import org.apache.lucene.search.TwoPhaseIterator;\n+import org.apache.lucene.search.Weight;\n+import org.elasticsearch.common.CheckedFunction;\n+import org.elasticsearch.script.Script;\n+import org.elasticsearch.xpack.runtimefields.AbstractLongScriptFieldScript;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+public final class LongScriptFieldDistanceFeatureQuery extends AbstractScriptFieldQuery {\n+    private final CheckedFunction<LeafReaderContext, AbstractLongScriptFieldScript, IOException> leafFactory;\n+    private final long origin;\n+    private final long pivot;\n+    private final float boost;\n+\n+    public LongScriptFieldDistanceFeatureQuery(\n+        Script script,\n+        CheckedFunction<LeafReaderContext, AbstractLongScriptFieldScript, IOException> leafFactory,\n+        String fieldName,\n+        long origin,\n+        long pivot,\n+        float boost\n+    ) {\n+        super(script, fieldName);\n+        this.leafFactory = leafFactory;\n+        this.origin = origin;\n+        this.pivot = pivot;\n+        this.boost = boost;\n+    }\n+\n+    @Override\n+    public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n+        return new Weight(this) {\n+            @Override\n+            public boolean isCacheable(LeafReaderContext ctx) {\n+                return false;\n+            }\n+\n+            @Override\n+            public void extractTerms(Set<Term> terms) {}\n+\n+            @Override\n+            public Scorer scorer(LeafReaderContext context) throws IOException {\n+                return new DistanceScorer(this, leafFactory.apply(context), context.reader().maxDoc(), boost);\n+            }\n+\n+            @Override\n+            public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n+                AbstractLongScriptFieldScript script = leafFactory.apply(context);\n+                script.runForDoc(doc);\n+                long value = valueWithMinAbsoluteDistance(script);\n+                float weight = LongScriptFieldDistanceFeatureQuery.this.boost * boost;\n+                float score = score(weight, distanceFor(value));\n+                return Explanation.match(\n+                    score,\n+                    \"Distance score, computed as weight * pivot / (pivot + abs(value - origin)) from:\",\n+                    Explanation.match(weight, \"weight\"),\n+                    Explanation.match(pivot, \"pivot\"),\n+                    Explanation.match(origin, \"origin\"),\n+                    Explanation.match(value, \"current value\")\n+                );\n+            }\n+        };\n+    }\n+\n+    private class DistanceScorer extends Scorer {\n+        private final AbstractLongScriptFieldScript script;\n+        private final TwoPhaseIterator twoPhase;\n+        private final DocIdSetIterator disi;\n+        private final float weight;\n+\n+        protected DistanceScorer(Weight weight, AbstractLongScriptFieldScript script, int maxDoc, float boost) {\n+            super(weight);\n+            this.script = script;\n+            twoPhase = new TwoPhaseIterator(DocIdSetIterator.all(maxDoc)) {\n+                @Override\n+                public boolean matches() throws IOException {\n+                    script.runForDoc(approximation().docID());\n+                    return script.count() > 0;\n+                }\n+\n+                @Override\n+                public float matchCost() {\n+                    return MATCH_COST;\n+                }\n+            };\n+            disi = TwoPhaseIterator.asDocIdSetIterator(twoPhase);\n+            this.weight = LongScriptFieldDistanceFeatureQuery.this.boost * boost;\n+        }\n+\n+        @Override\n+        public int docID() {\n+            return disi.docID();\n+        }\n+\n+        @Override\n+        public DocIdSetIterator iterator() {\n+            return disi;\n+        }\n+\n+        @Override\n+        public TwoPhaseIterator twoPhaseIterator() {\n+            return twoPhase;\n+        }\n+\n+        @Override\n+        public float getMaxScore(int upTo) throws IOException {\n+            return boost;\n+        }\n+\n+        @Override\n+        public float score() throws IOException {\n+            if (script.count() == 0) {\n+                return 0;\n+            }\n+            return LongScriptFieldDistanceFeatureQuery.this.score(weight, (double) minAbsoluteDistance(script));\n+        }\n+    }\n+\n+    long minAbsoluteDistance(AbstractLongScriptFieldScript script) {\n+        long minDistance = Long.MAX_VALUE;\n+        for (int i = 0; i < script.count(); i++) {\n+            minDistance = Math.min(minDistance, distanceFor(script.values()[i]));\n+        }\n+        return minDistance;\n+    }\n+\n+    long valueWithMinAbsoluteDistance(AbstractLongScriptFieldScript script) {\n+        long minDistance = Long.MAX_VALUE;\n+        long minDistanceValue = Long.MAX_VALUE;\n+        for (int i = 0; i < script.count(); i++) {\n+            long distance = distanceFor(script.values()[i]);\n+            if (distance < minDistance) {\n+                minDistance = distance;\n+                minDistanceValue = script.values()[i];\n+            }\n+        }\n+        return minDistanceValue;\n+    }\n+\n+    long distanceFor(long value) {\n+        long distance = Math.max(value, origin) - Math.min(value, origin);\n+        if (distance < 0) {\n+            // The distance doesn't fit into signed long so clamp it to MAX_VALUE\n+            return Long.MAX_VALUE;\n+        }\n+        return distance;\n+    }\n+\n+    float score(float weight, double distance) {\n+        return (float) (weight * (pivot / (pivot + distance)));\n+    }\n+\n+    @Override\n+    public String toString(String field) {\n+        StringBuilder b = new StringBuilder();\n+        if (false == fieldName().equals(field)) {\n+            b.append(fieldName()).append(\":\");\n+        }\n+        b.append(getClass().getSimpleName()).append(\"(origin=\").append(origin).append(\",pivot=\").append(pivot).append(\")\");\n+        return b.toString();\n+\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(super.hashCode(), origin, pivot);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA3OTU2OQ=="}, "originalCommit": {"oid": "f788941140488bb51c7950ac11797ab8a606b6b9"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE2MjUxMA==", "bodyText": "I believe we're hoping for bool queries to AND together a \"normal\" query and a runtime field query. I've experimented with this for our term and match style queries and it seems to work pretty well. If the \"normal\" query is selective then the runtime query won't be asked if it matches most documents. On the flip side, if the runtime field query non-selective then we'll quickly fill up the 10,000 hits and terminate early.", "url": "https://github.com/elastic/elasticsearch/pull/60851#discussion_r470162510", "createdAt": "2020-08-13T18:31:51Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/query/LongScriptFieldDistanceFeatureQuery.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.runtimefields.query;\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.DocIdSetIterator;\n+import org.apache.lucene.search.Explanation;\n+import org.apache.lucene.search.IndexSearcher;\n+import org.apache.lucene.search.QueryVisitor;\n+import org.apache.lucene.search.ScoreMode;\n+import org.apache.lucene.search.Scorer;\n+import org.apache.lucene.search.TwoPhaseIterator;\n+import org.apache.lucene.search.Weight;\n+import org.elasticsearch.common.CheckedFunction;\n+import org.elasticsearch.script.Script;\n+import org.elasticsearch.xpack.runtimefields.AbstractLongScriptFieldScript;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+public final class LongScriptFieldDistanceFeatureQuery extends AbstractScriptFieldQuery {\n+    private final CheckedFunction<LeafReaderContext, AbstractLongScriptFieldScript, IOException> leafFactory;\n+    private final long origin;\n+    private final long pivot;\n+    private final float boost;\n+\n+    public LongScriptFieldDistanceFeatureQuery(\n+        Script script,\n+        CheckedFunction<LeafReaderContext, AbstractLongScriptFieldScript, IOException> leafFactory,\n+        String fieldName,\n+        long origin,\n+        long pivot,\n+        float boost\n+    ) {\n+        super(script, fieldName);\n+        this.leafFactory = leafFactory;\n+        this.origin = origin;\n+        this.pivot = pivot;\n+        this.boost = boost;\n+    }\n+\n+    @Override\n+    public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n+        return new Weight(this) {\n+            @Override\n+            public boolean isCacheable(LeafReaderContext ctx) {\n+                return false;\n+            }\n+\n+            @Override\n+            public void extractTerms(Set<Term> terms) {}\n+\n+            @Override\n+            public Scorer scorer(LeafReaderContext context) throws IOException {\n+                return new DistanceScorer(this, leafFactory.apply(context), context.reader().maxDoc(), boost);\n+            }\n+\n+            @Override\n+            public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n+                AbstractLongScriptFieldScript script = leafFactory.apply(context);\n+                script.runForDoc(doc);\n+                long value = valueWithMinAbsoluteDistance(script);\n+                float weight = LongScriptFieldDistanceFeatureQuery.this.boost * boost;\n+                float score = score(weight, distanceFor(value));\n+                return Explanation.match(\n+                    score,\n+                    \"Distance score, computed as weight * pivot / (pivot + abs(value - origin)) from:\",\n+                    Explanation.match(weight, \"weight\"),\n+                    Explanation.match(pivot, \"pivot\"),\n+                    Explanation.match(origin, \"origin\"),\n+                    Explanation.match(value, \"current value\")\n+                );\n+            }\n+        };\n+    }\n+\n+    private class DistanceScorer extends Scorer {\n+        private final AbstractLongScriptFieldScript script;\n+        private final TwoPhaseIterator twoPhase;\n+        private final DocIdSetIterator disi;\n+        private final float weight;\n+\n+        protected DistanceScorer(Weight weight, AbstractLongScriptFieldScript script, int maxDoc, float boost) {\n+            super(weight);\n+            this.script = script;\n+            twoPhase = new TwoPhaseIterator(DocIdSetIterator.all(maxDoc)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA5Mzc2Ng=="}, "originalCommit": {"oid": "f788941140488bb51c7950ac11797ab8a606b6b9"}, "originalPosition": 92}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dfd27ff5640fc29eca1673d076c6ffbfc82506c9", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/dfd27ff5640fc29eca1673d076c6ffbfc82506c9", "committedDate": "2020-08-13T19:10:10Z", "message": "Merge branch 'feature/runtime_fields' into runtime_fields_distance_feature"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9739a0c95eae2c0cd98c46d71dd93133026df4ac", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/9739a0c95eae2c0cd98c46d71dd93133026df4ac", "committedDate": "2020-08-13T19:43:41Z", "message": "Update tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3NDI4MDc3", "url": "https://github.com/elastic/elasticsearch/pull/60851#pullrequestreview-467428077", "createdAt": "2020-08-14T09:14:57Z", "commit": {"oid": "9739a0c95eae2c0cd98c46d71dd93133026df4ac"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQwOToxNDo1N1rOHAtk9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQwOToxNDo1N1rOHAtk9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDUwODc4OA==", "bodyText": "I wonder what the plan is for the instanceof checks in DistanceFeatureQueryBuilder#doToQuery . Are we ok with keeping those?", "url": "https://github.com/elastic/elasticsearch/pull/60851#discussion_r470508788", "createdAt": "2020-08-14T09:14:57Z", "author": {"login": "javanna"}, "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/mapper/ScriptDateMappedFieldType.java", "diffHunk": "@@ -86,6 +88,30 @@ public DocValueFormat docValueFormat(@Nullable String format, ZoneId timeZone) {\n         return scriptFactory.newFactory(script.getParams(), lookup);\n     }\n \n+    @Override\n+    public Query distanceFeatureQuery(Object origin, String pivot, float boost, QueryShardContext context) {\n+        checkAllowExpensiveQueries(context);\n+        return DateFieldType.handleNow(context, now -> {\n+            long originLong = DateFieldType.parseToLong(\n+                origin,\n+                true,\n+                null,\n+                dateTimeFormatter.toDateMathParser(),\n+                now,\n+                DateFieldMapper.Resolution.MILLISECONDS\n+            );\n+            TimeValue pivotTime = TimeValue.parseTimeValue(pivot, \"distance_feature.pivot\");\n+            return new LongScriptFieldDistanceFeatureQuery(\n+                script,\n+                leafFactory(context.lookup())::newInstance,\n+                name(),\n+                originLong,\n+                pivotTime.getMillis(),\n+                boost\n+            );\n+        });\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9739a0c95eae2c0cd98c46d71dd93133026df4ac"}, "originalPosition": 42}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3NDM0MDE2", "url": "https://github.com/elastic/elasticsearch/pull/60851#pullrequestreview-467434016", "createdAt": "2020-08-14T09:24:27Z", "commit": {"oid": "9739a0c95eae2c0cd98c46d71dd93133026df4ac"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3455, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}