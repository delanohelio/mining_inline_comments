{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc3NDk3Mzc5", "number": 52548, "title": "Consolidate docker availability build logic", "bodyText": "This pull request consolidates and standardizes the mechanisms by which we determine the availability of a compatible Docker installation on the build host, as well as conditionally avoid certain tasks based on that availability. The latter has been refactored such that it is always deferred to task execution or graph calculation time so that in the majority case, when a build does not request any docker-related tasks, we don't make any such attempt to determine if Docker exists on the system.\nPrior to this refactoring we have 3 main sources of docker availability logic:\n\nThe logic in DockerUtils which is quite robust and actually checks that Docker exists, can be executed with privileged commands and meets a minimum version requirement. This was used only for the purpose of determining whether we could build the Docker distributions.\nSome logic in BuildPlugin for throwing an exception if any task declared it required a Docker installation meeting the requirements defined in (1). Again, only the :distribution:docker project leveraged this.\nLogic in DistroTestPlugin to determine whether or not Docker distribution tests could be executed. This used a different, and more simple implementation than DockerUtils, only assuming Windows never works, Mac always works, and Linux works, unless it's a variant that has been explicitly blacklisted in CI.\nThe last bit existed in TestFixturesPlugins for the purposes of determining whether docker-compose exists on the system. This was another relatively simple implementation, simply looking for the executable from a known list of locations.\n\nThis pull request solves some of the inconsistencies listed above via:\n\nThe introduction of a single DockerSupportService that is used in all instances where a determination on whether a compatible Docker installation is needed. This includes building our Docker images, testing them and spinning up Docker-based test fixtures.\nSome changes to ElasticsearchDistribution such that we can depend on a \"lenient\" distribution. If a distribution sets required = false and Docker is unavailable we simply skip building it. This allows testing that uses a locally build Docker distribution to be gracefully skipped in the absence of a Docker installation. This was previously done by checking for Docker availability at configuration time and omitting task dependencies (or entire tasks altogether) to avoid trying to build the Docker images.\nRefactoring of any direct dependencies on Docker build tasks to use the DistributionDownloadPlugin and lenient distributions described in (2).", "createdAt": "2020-02-20T01:04:40Z", "url": "https://github.com/elastic/elasticsearch/pull/52548", "merged": true, "mergeCommit": {"oid": "c1a1047e421d7810535d203ecb516510e408e7f4"}, "closed": true, "closedAt": "2020-02-21T16:11:51Z", "author": {"login": "mark-vieira"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcGAQpwgH2gAyMzc3NDk3Mzc5OmYzMmQ0MTU4ZDEzNmNhZTVkYmJkOTRkZTYwMGRiZWQ5NmZjZTg4YWQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcGSKc0AH2gAyMzc3NDk3Mzc5OmQxYjI2MGQ1YzIxYWQ1MGNhNmZmZjFiM2ZlMTM4M2FiNDNmZmIwYzA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "f32d4158d136cae5dbbd94de600dbed96fce88ad", "author": {"user": {"login": "mark-vieira", "name": "Mark Vieira"}}, "url": "https://github.com/elastic/elasticsearch/commit/f32d4158d136cae5dbbd94de600dbed96fce88ad", "committedDate": "2020-02-20T00:47:49Z", "message": "Consolidate docker availability build logic\n\nSigned-off-by: Mark Vieira <portugee@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxNzUyOTgz", "url": "https://github.com/elastic/elasticsearch/pull/52548#pullrequestreview-361752983", "createdAt": "2020-02-20T09:36:37Z", "commit": {"oid": "f32d4158d136cae5dbbd94de600dbed96fce88ad"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwOTozNjozN1rOFsMSIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwOTozNjozN1rOFsMSIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg4MjkxNA==", "bodyText": "We should stay away from terms like \"blacklist\" and \"whitelist\".\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private boolean isBlacklistedOs() {\n          \n          \n            \n                private boolean isExcludedOs() {", "url": "https://github.com/elastic/elasticsearch/pull/52548#discussion_r381882914", "createdAt": "2020-02-20T09:36:37Z", "author": {"login": "pugnascotia"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/docker/DockerSupportService.java", "diffHunk": "@@ -0,0 +1,375 @@\n+package org.elasticsearch.gradle.docker;\n+\n+import org.elasticsearch.gradle.Version;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.logging.Logger;\n+import org.gradle.api.logging.Logging;\n+import org.gradle.api.services.BuildService;\n+import org.gradle.api.services.BuildServiceParameters;\n+import org.gradle.process.ExecOperations;\n+import org.gradle.process.ExecResult;\n+\n+import javax.inject.Inject;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Build service for detecting available Docker installation and checking for compatibility with Elasticsearch Docker image build\n+ * requirements. This includes a minimum version requirement, as well as the ability to run privileged commands.\n+ */\n+public abstract class DockerSupportService implements BuildService<DockerSupportService.Parameters> {\n+\n+    private static Logger LOGGER = Logging.getLogger(DockerSupportService.class);\n+    // Defines the possible locations of the Docker CLI. These will be searched in order.\n+    private static String[] DOCKER_BINARIES = { \"/usr/bin/docker\", \"/usr/local/bin/docker\" };\n+    private static String[] DOCKER_COMPOSE_BINARIES = { \"/usr/local/bin/docker-compose\", \"/usr/bin/docker-compose\" };\n+    private static final Version MINIMUM_DOCKER_VERSION = Version.fromString(\"17.05.0\");\n+\n+    private final ExecOperations execOperations;\n+    private DockerAvailability dockerAvailability;\n+\n+    @Inject\n+    public DockerSupportService(ExecOperations execOperations) {\n+        this.execOperations = execOperations;\n+    }\n+\n+    /**\n+     * Searches for a functional Docker installation, and returns information about the search.\n+     *\n+     * @return the results of the search.\n+     */\n+    public DockerAvailability getDockerAvailability() {\n+        if (this.dockerAvailability == null) {\n+            String dockerPath = null;\n+            Result lastResult = null;\n+            Version version = null;\n+            boolean isVersionHighEnough = false;\n+            boolean isComposeAvailable = false;\n+\n+            // Check if the Docker binary exists\n+            final Optional<String> dockerBinary = getDockerPath();\n+            if (isBlacklistedOs() == false && dockerBinary.isPresent()) {\n+                dockerPath = dockerBinary.get();\n+\n+                // Since we use a multi-stage Docker build, check the Docker version meets minimum requirement\n+                lastResult = runCommand(dockerPath, \"version\", \"--format\", \"{{.Server.Version}}\");\n+\n+                if (lastResult.isSuccess()) {\n+                    version = Version.fromString(lastResult.stdout.trim(), Version.Mode.RELAXED);\n+\n+                    isVersionHighEnough = version.onOrAfter(MINIMUM_DOCKER_VERSION);\n+\n+                    if (isVersionHighEnough) {\n+                        // Check that we can execute a privileged command\n+                        lastResult = runCommand(dockerPath, \"images\");\n+\n+                        // If docker all checks out, see if docker-compose is available and working\n+                        Optional<String> composePath = getDockerComposePath();\n+                        if (lastResult.isSuccess() && composePath.isPresent()) {\n+                            isComposeAvailable = runCommand(composePath.get(), \"version\").isSuccess();\n+                        }\n+                    }\n+                }\n+            }\n+\n+            boolean isAvailable = isVersionHighEnough && lastResult != null && lastResult.isSuccess();\n+\n+            this.dockerAvailability = new DockerAvailability(\n+                isAvailable,\n+                isComposeAvailable,\n+                isVersionHighEnough,\n+                dockerPath,\n+                version,\n+                lastResult\n+            );\n+        }\n+\n+        return this.dockerAvailability;\n+    }\n+\n+    /**\n+     * Given a list of tasks that requires Docker, check whether Docker is available, otherwise throw an exception.\n+     *\n+     * @throws GradleException if Docker is not available. The exception message gives the reason.\n+     */\n+    void assertDockerIsAvailable(List<String> tasks) {\n+        DockerAvailability availability = getDockerAvailability();\n+\n+        // Docker installation is available and compatible\n+        if (availability.isAvailable) {\n+            return;\n+        }\n+\n+        // No Docker binary was located\n+        if (availability.path == null) {\n+            final String message = String.format(\n+                Locale.ROOT,\n+                \"Docker (checked [%s]) is required to run the following task%s: \\n%s\",\n+                String.join(\", \", DOCKER_BINARIES),\n+                tasks.size() > 1 ? \"s\" : \"\",\n+                String.join(\"\\n\", tasks)\n+            );\n+            throwDockerRequiredException(message);\n+        }\n+\n+        // Docker binaries were located, but did not meet the minimum version requirement\n+        if (availability.lastCommand.isSuccess() && availability.isVersionHighEnough == false) {\n+            final String message = String.format(\n+                Locale.ROOT,\n+                \"building Docker images requires minimum Docker version of %s due to use of multi-stage builds yet was [%s]\",\n+                MINIMUM_DOCKER_VERSION,\n+                availability.version\n+            );\n+            throwDockerRequiredException(message);\n+        }\n+\n+        // Some other problem, print the error\n+        final String message = String.format(\n+            Locale.ROOT,\n+            \"a problem occurred while using Docker from [%s]%s yet it is required to run the following task%s: \\n%s\\n\"\n+                + \"the problem is that Docker exited with exit code [%d] with standard error output:\\n%s\",\n+            availability.path,\n+            availability.version == null ? \"\" : \" v\" + availability.version,\n+            tasks.size() > 1 ? \"s\" : \"\",\n+            String.join(\"\\n\", tasks),\n+            availability.lastCommand.exitCode,\n+            availability.lastCommand.stderr.trim()\n+        );\n+        throwDockerRequiredException(message);\n+    }\n+\n+    private boolean isBlacklistedOs() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f32d4158d136cae5dbbd94de600dbed96fce88ad"}, "originalPosition": 153}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxNzU5MTk3", "url": "https://github.com/elastic/elasticsearch/pull/52548#pullrequestreview-361759197", "createdAt": "2020-02-20T09:45:17Z", "commit": {"oid": "f32d4158d136cae5dbbd94de600dbed96fce88ad"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwOTo0NToxN1rOFsMlCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwOTo0NToxN1rOFsMlCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg4Nzc1Mw==", "bodyText": "Does this only skip testing? Docker is required for a successful overall build on supported OSs, no?", "url": "https://github.com/elastic/elasticsearch/pull/52548#discussion_r381887753", "createdAt": "2020-02-20T09:45:17Z", "author": {"login": "pugnascotia"}, "path": "distribution/docker/build.gradle", "diffHunk": "@@ -105,10 +106,19 @@ task copyKeystore(type: Sync) {\n   }\n }\n \n-preProcessFixture {\n-  if (TestFixturesPlugin.dockerComposeSupported()) {\n-    dependsOn assemble\n+elasticsearch_distributions {\n+  Flavor.values().each { distroFlavor ->\n+    \"docker_$distroFlavor\" {\n+      flavor = distroFlavor\n+      type = 'docker'\n+      version = VersionProperties.getElasticsearch()\n+      required = false // This ensures we skip this testing if Docker is unavailable", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f32d4158d136cae5dbbd94de600dbed96fce88ad"}, "originalPosition": 27}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxNzYwNTI2", "url": "https://github.com/elastic/elasticsearch/pull/52548#pullrequestreview-361760526", "createdAt": "2020-02-20T09:47:02Z", "commit": {"oid": "f32d4158d136cae5dbbd94de600dbed96fce88ad"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "08c44c7b6afb8268cfabfa9e128494ab83bc4cab", "author": {"user": {"login": "mark-vieira", "name": "Mark Vieira"}}, "url": "https://github.com/elastic/elasticsearch/commit/08c44c7b6afb8268cfabfa9e128494ab83bc4cab", "committedDate": "2020-02-20T18:03:10Z", "message": "Address feedback\n\nSigned-off-by: Mark Vieira <portugee@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxNjQ1NTY3", "url": "https://github.com/elastic/elasticsearch/pull/52548#pullrequestreview-361645567", "createdAt": "2020-02-20T05:45:39Z", "commit": {"oid": "f32d4158d136cae5dbbd94de600dbed96fce88ad"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwNTo0NTozOVrOFsF2sA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwNjowNToxMFrOFsGdlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc3NzU4NA==", "bodyText": "nit: This shouldn't start with <p>, as the first line of a javadoc is the short description.", "url": "https://github.com/elastic/elasticsearch/pull/52548#discussion_r381777584", "createdAt": "2020-02-20T05:45:39Z", "author": {"login": "rjernst"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/docker/DockerSupportPlugin.java", "diffHunk": "@@ -0,0 +1,61 @@\n+package org.elasticsearch.gradle.docker;\n+\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.Task;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n+import org.gradle.api.provider.Provider;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * <p>Plugin providing {@link DockerSupportService} for detecting Docker installations and determining requirements for Docker-based", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f32d4158d136cae5dbbd94de600dbed96fce88ad"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc3ODY3MA==", "bodyText": "I know it is whacky, but <p> should basically be used as a paragraph break, without a closing tag, in javadocs. From oracle docs (https://www.oracle.com/technetwork/articles/java/index-137868.html):\n\nIf you have more than one paragraph in the doc comment, separate the paragraphs with a  paragraph tag", "url": "https://github.com/elastic/elasticsearch/pull/52548#discussion_r381778670", "createdAt": "2020-02-20T05:47:48Z", "author": {"login": "rjernst"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/docker/DockerSupportPlugin.java", "diffHunk": "@@ -0,0 +1,61 @@\n+package org.elasticsearch.gradle.docker;\n+\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.Task;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n+import org.gradle.api.provider.Provider;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * <p>Plugin providing {@link DockerSupportService} for detecting Docker installations and determining requirements for Docker-based\n+ * Elasticsearch build tasks.</p>\n+ *\n+ * <p>Additionally registers a task graph listener used to assert a compatible Docker installation exists when task requiring Docker are", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f32d4158d136cae5dbbd94de600dbed96fce88ad"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc4MDMyNw==", "bodyText": "Why are we setting the property to a boolean string instead of an actual boolean?", "url": "https://github.com/elastic/elasticsearch/pull/52548#discussion_r381780327", "createdAt": "2020-02-20T05:51:05Z", "author": {"login": "rjernst"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/docker/DockerSupportPlugin.java", "diffHunk": "@@ -0,0 +1,61 @@\n+package org.elasticsearch.gradle.docker;\n+\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.Task;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n+import org.gradle.api.provider.Provider;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * <p>Plugin providing {@link DockerSupportService} for detecting Docker installations and determining requirements for Docker-based\n+ * Elasticsearch build tasks.</p>\n+ *\n+ * <p>Additionally registers a task graph listener used to assert a compatible Docker installation exists when task requiring Docker are\n+ * scheduled for execution. Tasks may declare a Docker requirement via an extra property. If a compatible Docker installation is not\n+ * available on the build system an exception will be thrown prior to task execution.</p>\n+ *\n+ * <pre>\n+ *     task myDockerTask {\n+ *         ext.requiresDocker = true\n+ *     }\n+ * </pre>\n+ */\n+public class DockerSupportPlugin implements Plugin<Project> {\n+    public static final String DOCKER_SUPPORT_SERVICE_NAME = \"dockerSupportService\";\n+    public static final String DOCKER_ON_LINUX_EXCLUSIONS_FILE = \".ci/dockerOnLinuxExclusions\";\n+    public static final String REQUIRES_DOCKER_ATTRIBUTE = \"requiresDocker\";\n+\n+    @Override\n+    public void apply(Project project) {\n+        if (project != project.getRootProject()) {\n+            throw new IllegalStateException(this.getClass().getName() + \" can only be applied to the root project.\");\n+        }\n+\n+        Provider<DockerSupportService> dockerSupportServiceProvider = project.getGradle()\n+            .getSharedServices()\n+            .registerIfAbsent(\n+                DOCKER_SUPPORT_SERVICE_NAME,\n+                DockerSupportService.class,\n+                spec -> spec.parameters(\n+                    params -> { params.setExclusionsFile(new File(project.getRootDir(), DOCKER_ON_LINUX_EXCLUSIONS_FILE)); }\n+                )\n+            );\n+\n+        // Ensure that if any tasks declare they require docker, we assert an available Docker installation exists\n+        project.getGradle().getTaskGraph().whenReady(graph -> {\n+            List<String> dockerTasks = graph.getAllTasks().stream().filter(task -> {\n+                ExtraPropertiesExtension ext = task.getExtensions().getExtraProperties();\n+                return ext.has(REQUIRES_DOCKER_ATTRIBUTE) && ext.get(REQUIRES_DOCKER_ATTRIBUTE).equals(\"true\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f32d4158d136cae5dbbd94de600dbed96fce88ad"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc4MjgyMA==", "bodyText": "nit: since we are using asserts, maybe call use check or ensure terminology?", "url": "https://github.com/elastic/elasticsearch/pull/52548#discussion_r381782820", "createdAt": "2020-02-20T05:55:52Z", "author": {"login": "rjernst"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/docker/DockerSupportService.java", "diffHunk": "@@ -0,0 +1,375 @@\n+package org.elasticsearch.gradle.docker;\n+\n+import org.elasticsearch.gradle.Version;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.logging.Logger;\n+import org.gradle.api.logging.Logging;\n+import org.gradle.api.services.BuildService;\n+import org.gradle.api.services.BuildServiceParameters;\n+import org.gradle.process.ExecOperations;\n+import org.gradle.process.ExecResult;\n+\n+import javax.inject.Inject;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Build service for detecting available Docker installation and checking for compatibility with Elasticsearch Docker image build\n+ * requirements. This includes a minimum version requirement, as well as the ability to run privileged commands.\n+ */\n+public abstract class DockerSupportService implements BuildService<DockerSupportService.Parameters> {\n+\n+    private static Logger LOGGER = Logging.getLogger(DockerSupportService.class);\n+    // Defines the possible locations of the Docker CLI. These will be searched in order.\n+    private static String[] DOCKER_BINARIES = { \"/usr/bin/docker\", \"/usr/local/bin/docker\" };\n+    private static String[] DOCKER_COMPOSE_BINARIES = { \"/usr/local/bin/docker-compose\", \"/usr/bin/docker-compose\" };\n+    private static final Version MINIMUM_DOCKER_VERSION = Version.fromString(\"17.05.0\");\n+\n+    private final ExecOperations execOperations;\n+    private DockerAvailability dockerAvailability;\n+\n+    @Inject\n+    public DockerSupportService(ExecOperations execOperations) {\n+        this.execOperations = execOperations;\n+    }\n+\n+    /**\n+     * Searches for a functional Docker installation, and returns information about the search.\n+     *\n+     * @return the results of the search.\n+     */\n+    public DockerAvailability getDockerAvailability() {\n+        if (this.dockerAvailability == null) {\n+            String dockerPath = null;\n+            Result lastResult = null;\n+            Version version = null;\n+            boolean isVersionHighEnough = false;\n+            boolean isComposeAvailable = false;\n+\n+            // Check if the Docker binary exists\n+            final Optional<String> dockerBinary = getDockerPath();\n+            if (isBlacklistedOs() == false && dockerBinary.isPresent()) {\n+                dockerPath = dockerBinary.get();\n+\n+                // Since we use a multi-stage Docker build, check the Docker version meets minimum requirement\n+                lastResult = runCommand(dockerPath, \"version\", \"--format\", \"{{.Server.Version}}\");\n+\n+                if (lastResult.isSuccess()) {\n+                    version = Version.fromString(lastResult.stdout.trim(), Version.Mode.RELAXED);\n+\n+                    isVersionHighEnough = version.onOrAfter(MINIMUM_DOCKER_VERSION);\n+\n+                    if (isVersionHighEnough) {\n+                        // Check that we can execute a privileged command\n+                        lastResult = runCommand(dockerPath, \"images\");\n+\n+                        // If docker all checks out, see if docker-compose is available and working\n+                        Optional<String> composePath = getDockerComposePath();\n+                        if (lastResult.isSuccess() && composePath.isPresent()) {\n+                            isComposeAvailable = runCommand(composePath.get(), \"version\").isSuccess();\n+                        }\n+                    }\n+                }\n+            }\n+\n+            boolean isAvailable = isVersionHighEnough && lastResult != null && lastResult.isSuccess();\n+\n+            this.dockerAvailability = new DockerAvailability(\n+                isAvailable,\n+                isComposeAvailable,\n+                isVersionHighEnough,\n+                dockerPath,\n+                version,\n+                lastResult\n+            );\n+        }\n+\n+        return this.dockerAvailability;\n+    }\n+\n+    /**\n+     * Given a list of tasks that requires Docker, check whether Docker is available, otherwise throw an exception.\n+     *\n+     * @throws GradleException if Docker is not available. The exception message gives the reason.\n+     */\n+    void assertDockerIsAvailable(List<String> tasks) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f32d4158d136cae5dbbd94de600dbed96fce88ad"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc4NTg0MQ==", "bodyText": "removing -> or removing?", "url": "https://github.com/elastic/elasticsearch/pull/52548#discussion_r381785841", "createdAt": "2020-02-20T06:02:01Z", "author": {"login": "rjernst"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/docker/DockerSupportService.java", "diffHunk": "@@ -0,0 +1,375 @@\n+package org.elasticsearch.gradle.docker;\n+\n+import org.elasticsearch.gradle.Version;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.logging.Logger;\n+import org.gradle.api.logging.Logging;\n+import org.gradle.api.services.BuildService;\n+import org.gradle.api.services.BuildServiceParameters;\n+import org.gradle.process.ExecOperations;\n+import org.gradle.process.ExecResult;\n+\n+import javax.inject.Inject;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Build service for detecting available Docker installation and checking for compatibility with Elasticsearch Docker image build\n+ * requirements. This includes a minimum version requirement, as well as the ability to run privileged commands.\n+ */\n+public abstract class DockerSupportService implements BuildService<DockerSupportService.Parameters> {\n+\n+    private static Logger LOGGER = Logging.getLogger(DockerSupportService.class);\n+    // Defines the possible locations of the Docker CLI. These will be searched in order.\n+    private static String[] DOCKER_BINARIES = { \"/usr/bin/docker\", \"/usr/local/bin/docker\" };\n+    private static String[] DOCKER_COMPOSE_BINARIES = { \"/usr/local/bin/docker-compose\", \"/usr/bin/docker-compose\" };\n+    private static final Version MINIMUM_DOCKER_VERSION = Version.fromString(\"17.05.0\");\n+\n+    private final ExecOperations execOperations;\n+    private DockerAvailability dockerAvailability;\n+\n+    @Inject\n+    public DockerSupportService(ExecOperations execOperations) {\n+        this.execOperations = execOperations;\n+    }\n+\n+    /**\n+     * Searches for a functional Docker installation, and returns information about the search.\n+     *\n+     * @return the results of the search.\n+     */\n+    public DockerAvailability getDockerAvailability() {\n+        if (this.dockerAvailability == null) {\n+            String dockerPath = null;\n+            Result lastResult = null;\n+            Version version = null;\n+            boolean isVersionHighEnough = false;\n+            boolean isComposeAvailable = false;\n+\n+            // Check if the Docker binary exists\n+            final Optional<String> dockerBinary = getDockerPath();\n+            if (isBlacklistedOs() == false && dockerBinary.isPresent()) {\n+                dockerPath = dockerBinary.get();\n+\n+                // Since we use a multi-stage Docker build, check the Docker version meets minimum requirement\n+                lastResult = runCommand(dockerPath, \"version\", \"--format\", \"{{.Server.Version}}\");\n+\n+                if (lastResult.isSuccess()) {\n+                    version = Version.fromString(lastResult.stdout.trim(), Version.Mode.RELAXED);\n+\n+                    isVersionHighEnough = version.onOrAfter(MINIMUM_DOCKER_VERSION);\n+\n+                    if (isVersionHighEnough) {\n+                        // Check that we can execute a privileged command\n+                        lastResult = runCommand(dockerPath, \"images\");\n+\n+                        // If docker all checks out, see if docker-compose is available and working\n+                        Optional<String> composePath = getDockerComposePath();\n+                        if (lastResult.isSuccess() && composePath.isPresent()) {\n+                            isComposeAvailable = runCommand(composePath.get(), \"version\").isSuccess();\n+                        }\n+                    }\n+                }\n+            }\n+\n+            boolean isAvailable = isVersionHighEnough && lastResult != null && lastResult.isSuccess();\n+\n+            this.dockerAvailability = new DockerAvailability(\n+                isAvailable,\n+                isComposeAvailable,\n+                isVersionHighEnough,\n+                dockerPath,\n+                version,\n+                lastResult\n+            );\n+        }\n+\n+        return this.dockerAvailability;\n+    }\n+\n+    /**\n+     * Given a list of tasks that requires Docker, check whether Docker is available, otherwise throw an exception.\n+     *\n+     * @throws GradleException if Docker is not available. The exception message gives the reason.\n+     */\n+    void assertDockerIsAvailable(List<String> tasks) {\n+        DockerAvailability availability = getDockerAvailability();\n+\n+        // Docker installation is available and compatible\n+        if (availability.isAvailable) {\n+            return;\n+        }\n+\n+        // No Docker binary was located\n+        if (availability.path == null) {\n+            final String message = String.format(\n+                Locale.ROOT,\n+                \"Docker (checked [%s]) is required to run the following task%s: \\n%s\",\n+                String.join(\", \", DOCKER_BINARIES),\n+                tasks.size() > 1 ? \"s\" : \"\",\n+                String.join(\"\\n\", tasks)\n+            );\n+            throwDockerRequiredException(message);\n+        }\n+\n+        // Docker binaries were located, but did not meet the minimum version requirement\n+        if (availability.lastCommand.isSuccess() && availability.isVersionHighEnough == false) {\n+            final String message = String.format(\n+                Locale.ROOT,\n+                \"building Docker images requires minimum Docker version of %s due to use of multi-stage builds yet was [%s]\",\n+                MINIMUM_DOCKER_VERSION,\n+                availability.version\n+            );\n+            throwDockerRequiredException(message);\n+        }\n+\n+        // Some other problem, print the error\n+        final String message = String.format(\n+            Locale.ROOT,\n+            \"a problem occurred while using Docker from [%s]%s yet it is required to run the following task%s: \\n%s\\n\"\n+                + \"the problem is that Docker exited with exit code [%d] with standard error output:\\n%s\",\n+            availability.path,\n+            availability.version == null ? \"\" : \" v\" + availability.version,\n+            tasks.size() > 1 ? \"s\" : \"\",\n+            String.join(\"\\n\", tasks),\n+            availability.lastCommand.exitCode,\n+            availability.lastCommand.stderr.trim()\n+        );\n+        throwDockerRequiredException(message);\n+    }\n+\n+    private boolean isBlacklistedOs() {\n+        // We don't attempt to check the current flavor and version of Linux unless we're\n+        // running in CI, because we don't want to stop people running the Docker tests in\n+        // their own environments if they really want to.\n+        if (BuildParams.isCi() == false) {\n+            return false;\n+        }\n+\n+        // Only some hosts in CI are configured with Docker. We attempt to work out the OS\n+        // and version, so that we know whether to expect to find Docker. We don't attempt\n+        // to probe for whether Docker is available, because that doesn't tell us whether\n+        // Docker is unavailable when it should be.\n+        final Path osRelease = Paths.get(\"/etc/os-release\");\n+\n+        if (Files.exists(osRelease)) {\n+            Map<String, String> values;\n+\n+            try {\n+                final List<String> osReleaseLines = Files.readAllLines(osRelease);\n+                values = parseOsRelease(osReleaseLines);\n+            } catch (IOException e) {\n+                throw new GradleException(\"Failed to read /etc/os-release\", e);\n+            }\n+\n+            final String id = deriveId(values);\n+            final boolean blacklisted = getLinuxExclusionList().contains(id);\n+\n+            if (blacklisted) {\n+                LOGGER.warn(\"Linux OS id [{}] is present in the Docker exclude list. Tasks requiring Docker will be disabled.\", id);\n+            }\n+\n+            return blacklisted;\n+        }\n+\n+        return false;\n+    }\n+\n+    private List<String> getLinuxExclusionList() {\n+        File exclusionsFile = getParameters().getExclusionsFile();\n+\n+        if (exclusionsFile.exists()) {\n+            try {\n+                return Files.readAllLines(exclusionsFile.toPath())\n+                    .stream()\n+                    .map(String::trim)\n+                    .filter(line -> (line.isEmpty() || line.startsWith(\"#\")) == false)\n+                    .collect(Collectors.toList());\n+            } catch (IOException e) {\n+                throw new GradleException(\"Failed to read \" + exclusionsFile.getAbsolutePath(), e);\n+            }\n+        } else {\n+            return Collections.emptyList();\n+        }\n+    }\n+\n+    // visible for testing\n+    static String deriveId(Map<String, String> values) {\n+        return values.get(\"ID\") + \"-\" + values.get(\"VERSION_ID\");\n+    }\n+\n+    // visible for testing\n+    static Map<String, String> parseOsRelease(final List<String> osReleaseLines) {\n+        final Map<String, String> values = new HashMap<>();\n+\n+        osReleaseLines.stream().map(String::trim).filter(line -> (line.isEmpty() || line.startsWith(\"#\")) == false).forEach(line -> {\n+            final String[] parts = line.split(\"=\", 2);\n+            final String key = parts[0];\n+            // remove optional leading and trailing quotes and whitespace\n+            final String value = parts[1].replaceAll(\"^['\\\"]?\\\\s*\", \"\").replaceAll(\"\\\\s*['\\\"]?$\", \"\");\n+\n+            values.put(key, value);\n+        });\n+\n+        return values;\n+    }\n+\n+    /**\n+     * Searches the entries in {@link #DOCKER_BINARIES} for the Docker CLI. This method does\n+     * not check whether the Docker installation appears usable, see {@link #getDockerAvailability()}\n+     * instead.\n+     *\n+     * @return the path to a CLI, if available.\n+     */\n+    private Optional<String> getDockerPath() {\n+        // Check if the Docker binary exists\n+        return List.of(DOCKER_BINARIES).stream().filter(path -> new File(path).exists()).findFirst();\n+    }\n+\n+    /**\n+     * Searches the entries in {@link #DOCKER_COMPOSE_BINARIES} for the Docker Compose CLI. This method does\n+     * not check whether the installation appears usable, see {@link #getDockerAvailability()} instead.\n+     *\n+     * @return the path to a CLI, if available.\n+     */\n+    private Optional<String> getDockerComposePath() {\n+        // Check if the Docker binary exists\n+        return List.of(DOCKER_COMPOSE_BINARIES).stream().filter(path -> new File(path).exists()).findFirst();\n+    }\n+\n+    private void throwDockerRequiredException(final String message) {\n+        throwDockerRequiredException(message, null);\n+    }\n+\n+    private void throwDockerRequiredException(final String message, Exception e) {\n+        throw new GradleException(\n+            message + \"\\nyou can address this by attending to the reported issue, \" + \"removing the offending tasks from being executed.\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f32d4158d136cae5dbbd94de600dbed96fce88ad"}, "originalPosition": 258}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc4NzU0MQ==", "bodyText": "Why onlyIf here instead of using the requiresDocker property?", "url": "https://github.com/elastic/elasticsearch/pull/52548#discussion_r381787541", "createdAt": "2020-02-20T06:05:10Z", "author": {"login": "rjernst"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/test/DistroTestPlugin.java", "diffHunk": "@@ -324,8 +322,14 @@ public String toString() {\n         });\n     }\n \n-    private static TaskProvider<?> configureDistroTest(Project project, ElasticsearchDistribution distribution) {\n+    private static TaskProvider<?> configureDistroTest(\n+        Project project,\n+        ElasticsearchDistribution distribution,\n+        Provider<DockerSupportService> dockerSupport\n+    ) {\n         return project.getTasks().register(destructiveDistroTestTaskName(distribution), Test.class, t -> {\n+            // Disable Docker distribution tests unless a Docker installation is available\n+            t.onlyIf(t2 -> distribution.getType() != Type.DOCKER || dockerSupport.get().getDockerAvailability().isAvailable);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f32d4158d136cae5dbbd94de600dbed96fce88ad"}, "originalPosition": 94}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4a3cf2d451fa1c485393616db11de37b787afe66", "author": {"user": {"login": "mark-vieira", "name": "Mark Vieira"}}, "url": "https://github.com/elastic/elasticsearch/commit/4a3cf2d451fa1c485393616db11de37b787afe66", "committedDate": "2020-02-20T18:54:06Z", "message": "Address feedback\n\nSigned-off-by: Mark Vieira <portugee@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f5fc6b7cf012a84fe8ffa00318eb2198c73e154c", "author": {"user": {"login": "mark-vieira", "name": "Mark Vieira"}}, "url": "https://github.com/elastic/elasticsearch/commit/f5fc6b7cf012a84fe8ffa00318eb2198c73e154c", "committedDate": "2020-02-20T19:01:51Z", "message": "Fix code style violations\n\nSigned-off-by: Mark Vieira <portugee@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMjIzODcx", "url": "https://github.com/elastic/elasticsearch/pull/52548#pullrequestreview-362223871", "createdAt": "2020-02-20T20:51:31Z", "commit": {"oid": "4a3cf2d451fa1c485393616db11de37b787afe66"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQyMDo1MTozMVrOFsit4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQyMDo1MjowOFrOFsivRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI1MDQ2NQ==", "bodyText": "bundledJdk setting?", "url": "https://github.com/elastic/elasticsearch/pull/52548#discussion_r382250465", "createdAt": "2020-02-20T20:51:31Z", "author": {"login": "rjernst"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/ElasticsearchDistribution.java", "diffHunk": "@@ -270,6 +276,11 @@ void finalizeValues() {\n                     \"platform not allowed for elasticsearch distribution [\" + name + \"] of type [\" + getType() + \"]\"\n                 );\n             }\n+            if (getType() == Type.DOCKER && bundledJdk.isPresent()) {\n+                throw new IllegalArgumentException(\n+                    \"bundledJdk not allowed for elasticsearch distribution [\" + name + \"] of type [docker]\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a3cf2d451fa1c485393616db11de37b787afe66"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI1MDgyMg==", "bodyText": "or property or something like that? as it is written it sounds like docker can't use the bundledJdk, when in face it only uses it.", "url": "https://github.com/elastic/elasticsearch/pull/52548#discussion_r382250822", "createdAt": "2020-02-20T20:52:08Z", "author": {"login": "rjernst"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/ElasticsearchDistribution.java", "diffHunk": "@@ -270,6 +276,11 @@ void finalizeValues() {\n                     \"platform not allowed for elasticsearch distribution [\" + name + \"] of type [\" + getType() + \"]\"\n                 );\n             }\n+            if (getType() == Type.DOCKER && bundledJdk.isPresent()) {\n+                throw new IllegalArgumentException(\n+                    \"bundledJdk not allowed for elasticsearch distribution [\" + name + \"] of type [docker]\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI1MDQ2NQ=="}, "originalCommit": {"oid": "4a3cf2d451fa1c485393616db11de37b787afe66"}, "originalPosition": 63}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5f24188537132bb992e48770c22a4b93163a7b08", "author": {"user": {"login": "mark-vieira", "name": "Mark Vieira"}}, "url": "https://github.com/elastic/elasticsearch/commit/5f24188537132bb992e48770c22a4b93163a7b08", "committedDate": "2020-02-20T20:57:42Z", "message": "Reword validation error messages\n\nSigned-off-by: Mark Vieira <portugee@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d1b260d5c21ad50ca6fff1b3fe1383ab43ffb0c0", "author": {"user": {"login": "mark-vieira", "name": "Mark Vieira"}}, "url": "https://github.com/elastic/elasticsearch/commit/d1b260d5c21ad50ca6fff1b3fe1383ab43ffb0c0", "committedDate": "2020-02-20T21:39:20Z", "message": "Fix unit test\n\nSigned-off-by: Mark Vieira <portugee@gmail.com>"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2204, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}