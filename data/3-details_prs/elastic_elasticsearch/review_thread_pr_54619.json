{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk3MjY4MDUz", "number": 54619, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQyMjo0NTowOFrODtu5bw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwODo0NzowN1rODuR4YA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MjgwODc5OnYy", "diffSide": "LEFT", "path": "x-pack/plugin/async-search/src/main/java/org/elasticsearch/xpack/search/AsyncSearchIndexService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQyMjo0NTowOFrOF_VSwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwODoyNDozMFrOGAKmZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk1MzQ3NA==", "bodyText": "I tried to make this logic more readable. I found the boolean flag hard to reason about especially as it was provided true only once. I moved the listener wrapping to the callers, where each caller needs to do something different.", "url": "https://github.com/elastic/elasticsearch/pull/54619#discussion_r401953474", "createdAt": "2020-04-01T22:45:08Z", "author": {"login": "javanna"}, "path": "x-pack/plugin/async-search/src/main/java/org/elasticsearch/xpack/search/AsyncSearchIndexService.java", "diffHunk": "@@ -194,31 +192,16 @@ void updateExpirationTime(String docId,\n         UpdateRequest request = new UpdateRequest().index(INDEX)\n             .id(docId)\n             .doc(source, XContentType.JSON);\n-        createIndexIfNecessary(ActionListener.wrap(v -> client.update(request, listener), listener::onFailure));\n+        client.update(request, listener);\n     }\n \n     /**\n      * Deletes the provided <code>searchId</code> from the index if present.\n      */\n     void deleteResponse(AsyncSearchId searchId,\n-                        boolean failIfNotFound,\n-                        ActionListener<AcknowledgedResponse> listener) {\n+                        ActionListener<DeleteResponse> listener) {\n         DeleteRequest request = new DeleteRequest(INDEX).id(searchId.getDocId());\n-        createIndexIfNecessary(\n-            ActionListener.wrap(v -> client.delete(request,\n-                ActionListener.wrap(\n-                    resp -> {\n-                        if (resp.status() == RestStatus.NOT_FOUND && failIfNotFound) {\n-                            listener.onFailure(new ResourceNotFoundException(searchId.getEncoded()));\n-                        } else {\n-                            listener.onResponse(new AcknowledgedResponse(true));\n-                        }\n-                    },\n-                    exc -> {\n-                        logger.error(() -> new ParameterizedMessage(\"failed to clean async-search [{}]\", searchId.getEncoded()), exc);\n-                        listener.onFailure(exc);\n-                    })),\n-                listener::onFailure));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd2cd8740a9de7cb4948f03ade945885a15d3f4f"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgyNjg1NQ==", "bodyText": "++", "url": "https://github.com/elastic/elasticsearch/pull/54619#discussion_r402826855", "createdAt": "2020-04-03T08:24:30Z", "author": {"login": "jimczi"}, "path": "x-pack/plugin/async-search/src/main/java/org/elasticsearch/xpack/search/AsyncSearchIndexService.java", "diffHunk": "@@ -194,31 +192,16 @@ void updateExpirationTime(String docId,\n         UpdateRequest request = new UpdateRequest().index(INDEX)\n             .id(docId)\n             .doc(source, XContentType.JSON);\n-        createIndexIfNecessary(ActionListener.wrap(v -> client.update(request, listener), listener::onFailure));\n+        client.update(request, listener);\n     }\n \n     /**\n      * Deletes the provided <code>searchId</code> from the index if present.\n      */\n     void deleteResponse(AsyncSearchId searchId,\n-                        boolean failIfNotFound,\n-                        ActionListener<AcknowledgedResponse> listener) {\n+                        ActionListener<DeleteResponse> listener) {\n         DeleteRequest request = new DeleteRequest(INDEX).id(searchId.getDocId());\n-        createIndexIfNecessary(\n-            ActionListener.wrap(v -> client.delete(request,\n-                ActionListener.wrap(\n-                    resp -> {\n-                        if (resp.status() == RestStatus.NOT_FOUND && failIfNotFound) {\n-                            listener.onFailure(new ResourceNotFoundException(searchId.getEncoded()));\n-                        } else {\n-                            listener.onResponse(new AcknowledgedResponse(true));\n-                        }\n-                    },\n-                    exc -> {\n-                        logger.error(() -> new ParameterizedMessage(\"failed to clean async-search [{}]\", searchId.getEncoded()), exc);\n-                        listener.onFailure(exc);\n-                    })),\n-                listener::onFailure));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk1MzQ3NA=="}, "originalCommit": {"oid": "cd2cd8740a9de7cb4948f03ade945885a15d3f4f"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MjgxMDMzOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/async-search/src/main/java/org/elasticsearch/xpack/search/TransportGetAsyncSearchAction.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQyMjo0NTo1MVrOF_VTtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxMzoyNzoyNFrOGD6dNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk1MzcxOQ==", "bodyText": "I was wondering if we are sure about exc.getCause here. What's the top level exception?", "url": "https://github.com/elastic/elasticsearch/pull/54619#discussion_r401953719", "createdAt": "2020-04-01T22:45:51Z", "author": {"login": "javanna"}, "path": "x-pack/plugin/async-search/src/main/java/org/elasticsearch/xpack/search/TransportGetAsyncSearchAction.java", "diffHunk": "@@ -57,8 +59,12 @@ protected void doExecute(Task task, GetAsyncSearchAction.Request request, Action\n                         ActionListener.wrap(\n                             p -> getSearchResponseFromTask(searchId, request, nowInMillis, expirationTime, listener),\n                             exc -> {\n-                                if (exc.getCause() instanceof DocumentMissingException == false) {\n-                                    logger.error(\"failed to retrieve \" + searchId.getEncoded(), exc);\n+                                //don't even log when: the async search document or its index is not found. That can happen if an invalid\n+                                //search id is provided and no async search initial response has been stored yet.\n+                                if (exc.getCause() instanceof DocumentMissingException == false\n+                                    && exc.getCause() instanceof IndexNotFoundException == false) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd2cd8740a9de7cb4948f03ade945885a15d3f4f"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg0MzQ1MQ==", "bodyText": "A RemoteTransportException.  Maybe we can replace the instanceof with ExceptionsHelper.status(exc) != RestStatus.NOT_FOUND ?", "url": "https://github.com/elastic/elasticsearch/pull/54619#discussion_r402843451", "createdAt": "2020-04-03T08:43:42Z", "author": {"login": "jimczi"}, "path": "x-pack/plugin/async-search/src/main/java/org/elasticsearch/xpack/search/TransportGetAsyncSearchAction.java", "diffHunk": "@@ -57,8 +59,12 @@ protected void doExecute(Task task, GetAsyncSearchAction.Request request, Action\n                         ActionListener.wrap(\n                             p -> getSearchResponseFromTask(searchId, request, nowInMillis, expirationTime, listener),\n                             exc -> {\n-                                if (exc.getCause() instanceof DocumentMissingException == false) {\n-                                    logger.error(\"failed to retrieve \" + searchId.getEncoded(), exc);\n+                                //don't even log when: the async search document or its index is not found. That can happen if an invalid\n+                                //search id is provided and no async search initial response has been stored yet.\n+                                if (exc.getCause() instanceof DocumentMissingException == false\n+                                    && exc.getCause() instanceof IndexNotFoundException == false) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk1MzcxOQ=="}, "originalCommit": {"oid": "cd2cd8740a9de7cb4948f03ade945885a15d3f4f"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcyOTUwMw==", "bodyText": "the problem I have with ExceptionsHelper.status(exc) is that it does not look at the cause at all and it gives 500 if it does not know any better. How about ExceptionsHelper.status(ExceptionsHelper.unwrapCause(exc)) ?", "url": "https://github.com/elastic/elasticsearch/pull/54619#discussion_r406729503", "createdAt": "2020-04-10T12:08:38Z", "author": {"login": "javanna"}, "path": "x-pack/plugin/async-search/src/main/java/org/elasticsearch/xpack/search/TransportGetAsyncSearchAction.java", "diffHunk": "@@ -57,8 +59,12 @@ protected void doExecute(Task task, GetAsyncSearchAction.Request request, Action\n                         ActionListener.wrap(\n                             p -> getSearchResponseFromTask(searchId, request, nowInMillis, expirationTime, listener),\n                             exc -> {\n-                                if (exc.getCause() instanceof DocumentMissingException == false) {\n-                                    logger.error(\"failed to retrieve \" + searchId.getEncoded(), exc);\n+                                //don't even log when: the async search document or its index is not found. That can happen if an invalid\n+                                //search id is provided and no async search initial response has been stored yet.\n+                                if (exc.getCause() instanceof DocumentMissingException == false\n+                                    && exc.getCause() instanceof IndexNotFoundException == false) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk1MzcxOQ=="}, "originalCommit": {"oid": "cd2cd8740a9de7cb4948f03ade945885a15d3f4f"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc1NjY2Mw==", "bodyText": "+1", "url": "https://github.com/elastic/elasticsearch/pull/54619#discussion_r406756663", "createdAt": "2020-04-10T13:27:24Z", "author": {"login": "jimczi"}, "path": "x-pack/plugin/async-search/src/main/java/org/elasticsearch/xpack/search/TransportGetAsyncSearchAction.java", "diffHunk": "@@ -57,8 +59,12 @@ protected void doExecute(Task task, GetAsyncSearchAction.Request request, Action\n                         ActionListener.wrap(\n                             p -> getSearchResponseFromTask(searchId, request, nowInMillis, expirationTime, listener),\n                             exc -> {\n-                                if (exc.getCause() instanceof DocumentMissingException == false) {\n-                                    logger.error(\"failed to retrieve \" + searchId.getEncoded(), exc);\n+                                //don't even log when: the async search document or its index is not found. That can happen if an invalid\n+                                //search id is provided and no async search initial response has been stored yet.\n+                                if (exc.getCause() instanceof DocumentMissingException == false\n+                                    && exc.getCause() instanceof IndexNotFoundException == false) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk1MzcxOQ=="}, "originalCommit": {"oid": "cd2cd8740a9de7cb4948f03ade945885a15d3f4f"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5ODU0MDQ4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/async-search/src/main/java/org/elasticsearch/xpack/search/TransportDeleteAsyncSearchAction.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwODo0NzowN1rOGALzJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxMzoyNzo1MVrOGD6d7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg0NjUwMA==", "bodyText": "We shouldn't fail If the document is missing:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    if (exc.getCause() instanceof IndexNotFoundException) {\n          \n          \n            \n                                    if (ExceptionsHelper.status(exc) == RestStatus.NOT_FOUND) {", "url": "https://github.com/elastic/elasticsearch/pull/54619#discussion_r402846500", "createdAt": "2020-04-03T08:47:07Z", "author": {"login": "jimczi"}, "path": "x-pack/plugin/async-search/src/main/java/org/elasticsearch/xpack/search/TransportDeleteAsyncSearchAction.java", "diffHunk": "@@ -58,15 +67,40 @@ protected void doExecute(Task task, DeleteAsyncSearchAction.Request request, Act\n         }\n     }\n \n-    private void cancelTaskAndDeleteResult(AsyncSearchId searchId, ActionListener<AcknowledgedResponse> listener) throws IOException {\n+    void cancelTaskAndDeleteResult(AsyncSearchId searchId, ActionListener<AcknowledgedResponse> listener) throws IOException {\n         AsyncSearchTask task = store.getTask(taskManager, searchId);\n         if (task != null) {\n-            task.cancelTask(() -> store.deleteResponse(searchId, false, listener));\n+            //the task was found and gets cancelled. The response may or may not be found, but we will return 200 anyways.\n+            task.cancelTask(() -> store.deleteResponse(searchId,\n+                ActionListener.wrap(\n+                    r -> listener.onResponse(new AcknowledgedResponse(true)),\n+                    exc -> {\n+                        //the index may not be there (no initial async search response stored yet?): we still want to return 200\n+                        if (exc.getCause() instanceof IndexNotFoundException) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e087dbde9a6bbba40d0d30d032e91ca2d6b9090"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcyNTkxNA==", "bodyText": "we don't, document missing does not come back as a failure. Yet, I agree on changing the condition as exc.getCause() instanceof IndexNotFoundException is not great", "url": "https://github.com/elastic/elasticsearch/pull/54619#discussion_r406725914", "createdAt": "2020-04-10T11:57:20Z", "author": {"login": "javanna"}, "path": "x-pack/plugin/async-search/src/main/java/org/elasticsearch/xpack/search/TransportDeleteAsyncSearchAction.java", "diffHunk": "@@ -58,15 +67,40 @@ protected void doExecute(Task task, DeleteAsyncSearchAction.Request request, Act\n         }\n     }\n \n-    private void cancelTaskAndDeleteResult(AsyncSearchId searchId, ActionListener<AcknowledgedResponse> listener) throws IOException {\n+    void cancelTaskAndDeleteResult(AsyncSearchId searchId, ActionListener<AcknowledgedResponse> listener) throws IOException {\n         AsyncSearchTask task = store.getTask(taskManager, searchId);\n         if (task != null) {\n-            task.cancelTask(() -> store.deleteResponse(searchId, false, listener));\n+            //the task was found and gets cancelled. The response may or may not be found, but we will return 200 anyways.\n+            task.cancelTask(() -> store.deleteResponse(searchId,\n+                ActionListener.wrap(\n+                    r -> listener.onResponse(new AcknowledgedResponse(true)),\n+                    exc -> {\n+                        //the index may not be there (no initial async search response stored yet?): we still want to return 200\n+                        if (exc.getCause() instanceof IndexNotFoundException) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg0NjUwMA=="}, "originalCommit": {"oid": "1e087dbde9a6bbba40d0d30d032e91ca2d6b9090"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc1Njg0Ng==", "bodyText": "++, thanks", "url": "https://github.com/elastic/elasticsearch/pull/54619#discussion_r406756846", "createdAt": "2020-04-10T13:27:51Z", "author": {"login": "jimczi"}, "path": "x-pack/plugin/async-search/src/main/java/org/elasticsearch/xpack/search/TransportDeleteAsyncSearchAction.java", "diffHunk": "@@ -58,15 +67,40 @@ protected void doExecute(Task task, DeleteAsyncSearchAction.Request request, Act\n         }\n     }\n \n-    private void cancelTaskAndDeleteResult(AsyncSearchId searchId, ActionListener<AcknowledgedResponse> listener) throws IOException {\n+    void cancelTaskAndDeleteResult(AsyncSearchId searchId, ActionListener<AcknowledgedResponse> listener) throws IOException {\n         AsyncSearchTask task = store.getTask(taskManager, searchId);\n         if (task != null) {\n-            task.cancelTask(() -> store.deleteResponse(searchId, false, listener));\n+            //the task was found and gets cancelled. The response may or may not be found, but we will return 200 anyways.\n+            task.cancelTask(() -> store.deleteResponse(searchId,\n+                ActionListener.wrap(\n+                    r -> listener.onResponse(new AcknowledgedResponse(true)),\n+                    exc -> {\n+                        //the index may not be there (no initial async search response stored yet?): we still want to return 200\n+                        if (exc.getCause() instanceof IndexNotFoundException) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg0NjUwMA=="}, "originalCommit": {"oid": "1e087dbde9a6bbba40d0d30d032e91ca2d6b9090"}, "originalPosition": 47}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3948, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}