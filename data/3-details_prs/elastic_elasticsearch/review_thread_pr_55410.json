{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA1MjI0NTMz", "number": 55410, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwNjo0OToyN1rODzkmvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMzozMzoyNFrODzuqyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NDAzNzExOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/IndexAbstraction.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwNjo0OToyN1rOGIFoPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMjoxNjoxNlrOGIRi_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTEzNDAxMw==", "bodyText": "Can the return type be IndexAbstraction instead of DataStream (the data stream impl for IndexAbstraction)?\nCurrently DataStream doesn't have any methods that IndexAbstraction doesn't have and would be good to not rely on anything implementation specific.", "url": "https://github.com/elastic/elasticsearch/pull/55410#discussion_r411134013", "createdAt": "2020-04-20T06:49:27Z", "author": {"login": "martijnvg"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/IndexAbstraction.java", "diffHunk": "@@ -67,6 +67,12 @@\n     @Nullable\n     IndexMetadata getWriteIndex();\n \n+    /**\n+     * @return the data stream to which this index belongs or <code>null</code> if this is not a concrete index or\n+     * if it is a concrete index that does not belong to a data stream.\n+     */\n+    @Nullable DataStream getParentDataStream();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8053209eb05e4d1b058a7b748073ffba57b1926c"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTMxOTc1MQ==", "bodyText": "I chose the return type of IndexAbstraction.DataStream for two reasons -- the parent data stream could never be an IndexAbstraction.Index or IndexAbstraction.Alias and when implementing data stream rollover in the next PR, I added a getDataStream method to IndexAbstraction.DataStream which is convenient to call from getParentDataStream without casting.", "url": "https://github.com/elastic/elasticsearch/pull/55410#discussion_r411319751", "createdAt": "2020-04-20T11:59:36Z", "author": {"login": "danhermann"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/IndexAbstraction.java", "diffHunk": "@@ -67,6 +67,12 @@\n     @Nullable\n     IndexMetadata getWriteIndex();\n \n+    /**\n+     * @return the data stream to which this index belongs or <code>null</code> if this is not a concrete index or\n+     * if it is a concrete index that does not belong to a data stream.\n+     */\n+    @Nullable DataStream getParentDataStream();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTEzNDAxMw=="}, "originalCommit": {"oid": "8053209eb05e4d1b058a7b748073ffba57b1926c"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTMyOTI3Nw==", "bodyText": "Ok, that makes sense. I just prefer that other code isn't going to rely on data stream specific methods (like is today with the alias impl). Otherwise the abstraction is going to be leaky.", "url": "https://github.com/elastic/elasticsearch/pull/55410#discussion_r411329277", "createdAt": "2020-04-20T12:16:16Z", "author": {"login": "martijnvg"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/IndexAbstraction.java", "diffHunk": "@@ -67,6 +67,12 @@\n     @Nullable\n     IndexMetadata getWriteIndex();\n \n+    /**\n+     * @return the data stream to which this index belongs or <code>null</code> if this is not a concrete index or\n+     * if it is a concrete index that does not belong to a data stream.\n+     */\n+    @Nullable DataStream getParentDataStream();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTEzNDAxMw=="}, "originalCommit": {"oid": "8053209eb05e4d1b058a7b748073ffba57b1926c"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NDA4NTcyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/Metadata.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwNzowMzoxNVrOGIGDsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMzozNToyN1rOGIUvrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE0MTA0Mg==", "bodyText": "Can we reuse the IndexAbstraction.DataStream created here in the logic below here that adds data streams to the indices lookup? I think it would nice that if a data stream is lookup directly or via a backing index that the same instance is returned.\nI think we can do this if we add the data streams to the indicesLookup map before we add the indices to the indicesLookup map?", "url": "https://github.com/elastic/elasticsearch/pull/55410#discussion_r411141042", "createdAt": "2020-04-20T07:03:15Z", "author": {"login": "martijnvg"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/Metadata.java", "diffHunk": "@@ -1349,10 +1349,30 @@ public Metadata build() {\n \n         private SortedMap<String, IndexAbstraction> buildIndicesLookup() {\n             SortedMap<String, IndexAbstraction> indicesLookup = new TreeMap<>();\n+            Map<String, DataStream> indexToDataStreamLookup = new HashMap<>();\n+            DataStreamMetadata dataStreamMetadata = (DataStreamMetadata) this.customs.get(DataStreamMetadata.TYPE);\n+            if (dataStreamMetadata != null) {\n+                for (DataStream ds : dataStreamMetadata.dataStreams().values()) {\n+                    for (Index i : ds.getIndices()) {\n+                        indexToDataStreamLookup.put(i.getName(), ds);\n+                    }\n+                }\n+            }\n+\n             for (ObjectCursor<IndexMetadata> cursor : indices.values()) {\n                 IndexMetadata indexMetadata = cursor.value;\n-                IndexAbstraction existing =\n-                    indicesLookup.put(indexMetadata.getIndex().getName(), new IndexAbstraction.Index(indexMetadata));\n+\n+                IndexAbstraction.Index index;\n+                DataStream parent = indexToDataStreamLookup.get(indexMetadata.getIndex().getName());\n+                if (parent != null) {\n+                    List<IndexMetadata> backingIndices = parent.getIndices().stream()\n+                        .map(imd -> indices.get(imd.getName())).collect(Collectors.toList());\n+                    index = new IndexAbstraction.Index(indexMetadata, new IndexAbstraction.DataStream(parent, backingIndices));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8053209eb05e4d1b058a7b748073ffba57b1926c"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTMzNDUyMQ==", "bodyText": "@martijnvg, I agree that would be nice. Adding data streams to indicesLookup before indices means that name conflicts will be reported as Index [foo] conflicts with existing data stream [foo]... rather than Data stream [foo] conflicts with existing index [foo].... If you are ok with that, I'll make the change.", "url": "https://github.com/elastic/elasticsearch/pull/55410#discussion_r411334521", "createdAt": "2020-04-20T12:24:59Z", "author": {"login": "danhermann"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/Metadata.java", "diffHunk": "@@ -1349,10 +1349,30 @@ public Metadata build() {\n \n         private SortedMap<String, IndexAbstraction> buildIndicesLookup() {\n             SortedMap<String, IndexAbstraction> indicesLookup = new TreeMap<>();\n+            Map<String, DataStream> indexToDataStreamLookup = new HashMap<>();\n+            DataStreamMetadata dataStreamMetadata = (DataStreamMetadata) this.customs.get(DataStreamMetadata.TYPE);\n+            if (dataStreamMetadata != null) {\n+                for (DataStream ds : dataStreamMetadata.dataStreams().values()) {\n+                    for (Index i : ds.getIndices()) {\n+                        indexToDataStreamLookup.put(i.getName(), ds);\n+                    }\n+                }\n+            }\n+\n             for (ObjectCursor<IndexMetadata> cursor : indices.values()) {\n                 IndexMetadata indexMetadata = cursor.value;\n-                IndexAbstraction existing =\n-                    indicesLookup.put(indexMetadata.getIndex().getName(), new IndexAbstraction.Index(indexMetadata));\n+\n+                IndexAbstraction.Index index;\n+                DataStream parent = indexToDataStreamLookup.get(indexMetadata.getIndex().getName());\n+                if (parent != null) {\n+                    List<IndexMetadata> backingIndices = parent.getIndices().stream()\n+                        .map(imd -> indices.get(imd.getName())).collect(Collectors.toList());\n+                    index = new IndexAbstraction.Index(indexMetadata, new IndexAbstraction.DataStream(parent, backingIndices));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE0MTA0Mg=="}, "originalCommit": {"oid": "8053209eb05e4d1b058a7b748073ffba57b1926c"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTMzNzU5NQ==", "bodyText": "I think that is ok.\nMaybe rename the exception to: index [foo] and data stream [foo] have the same name\nor something like that, so the name conflict is bad regardless which one was added first.", "url": "https://github.com/elastic/elasticsearch/pull/55410#discussion_r411337595", "createdAt": "2020-04-20T12:30:03Z", "author": {"login": "martijnvg"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/Metadata.java", "diffHunk": "@@ -1349,10 +1349,30 @@ public Metadata build() {\n \n         private SortedMap<String, IndexAbstraction> buildIndicesLookup() {\n             SortedMap<String, IndexAbstraction> indicesLookup = new TreeMap<>();\n+            Map<String, DataStream> indexToDataStreamLookup = new HashMap<>();\n+            DataStreamMetadata dataStreamMetadata = (DataStreamMetadata) this.customs.get(DataStreamMetadata.TYPE);\n+            if (dataStreamMetadata != null) {\n+                for (DataStream ds : dataStreamMetadata.dataStreams().values()) {\n+                    for (Index i : ds.getIndices()) {\n+                        indexToDataStreamLookup.put(i.getName(), ds);\n+                    }\n+                }\n+            }\n+\n             for (ObjectCursor<IndexMetadata> cursor : indices.values()) {\n                 IndexMetadata indexMetadata = cursor.value;\n-                IndexAbstraction existing =\n-                    indicesLookup.put(indexMetadata.getIndex().getName(), new IndexAbstraction.Index(indexMetadata));\n+\n+                IndexAbstraction.Index index;\n+                DataStream parent = indexToDataStreamLookup.get(indexMetadata.getIndex().getName());\n+                if (parent != null) {\n+                    List<IndexMetadata> backingIndices = parent.getIndices().stream()\n+                        .map(imd -> indices.get(imd.getName())).collect(Collectors.toList());\n+                    index = new IndexAbstraction.Index(indexMetadata, new IndexAbstraction.DataStream(parent, backingIndices));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE0MTA0Mg=="}, "originalCommit": {"oid": "8053209eb05e4d1b058a7b748073ffba57b1926c"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTMzODc0NA==", "bodyText": "Actually, for consistency and simplicity, I should probably add data streams to the duplicate name check for aliases and indices that occurs before the call to buildIndicesLookup.", "url": "https://github.com/elastic/elasticsearch/pull/55410#discussion_r411338744", "createdAt": "2020-04-20T12:31:48Z", "author": {"login": "danhermann"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/Metadata.java", "diffHunk": "@@ -1349,10 +1349,30 @@ public Metadata build() {\n \n         private SortedMap<String, IndexAbstraction> buildIndicesLookup() {\n             SortedMap<String, IndexAbstraction> indicesLookup = new TreeMap<>();\n+            Map<String, DataStream> indexToDataStreamLookup = new HashMap<>();\n+            DataStreamMetadata dataStreamMetadata = (DataStreamMetadata) this.customs.get(DataStreamMetadata.TYPE);\n+            if (dataStreamMetadata != null) {\n+                for (DataStream ds : dataStreamMetadata.dataStreams().values()) {\n+                    for (Index i : ds.getIndices()) {\n+                        indexToDataStreamLookup.put(i.getName(), ds);\n+                    }\n+                }\n+            }\n+\n             for (ObjectCursor<IndexMetadata> cursor : indices.values()) {\n                 IndexMetadata indexMetadata = cursor.value;\n-                IndexAbstraction existing =\n-                    indicesLookup.put(indexMetadata.getIndex().getName(), new IndexAbstraction.Index(indexMetadata));\n+\n+                IndexAbstraction.Index index;\n+                DataStream parent = indexToDataStreamLookup.get(indexMetadata.getIndex().getName());\n+                if (parent != null) {\n+                    List<IndexMetadata> backingIndices = parent.getIndices().stream()\n+                        .map(imd -> indices.get(imd.getName())).collect(Collectors.toList());\n+                    index = new IndexAbstraction.Index(indexMetadata, new IndexAbstraction.DataStream(parent, backingIndices));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE0MTA0Mg=="}, "originalCommit": {"oid": "8053209eb05e4d1b058a7b748073ffba57b1926c"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM0MjAxOQ==", "bodyText": "I should probably add data streams to the duplicate name check for aliases and indices that occurs before the call to buildIndicesLookup.\n\n\ud83d\udc4d", "url": "https://github.com/elastic/elasticsearch/pull/55410#discussion_r411342019", "createdAt": "2020-04-20T12:37:21Z", "author": {"login": "martijnvg"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/Metadata.java", "diffHunk": "@@ -1349,10 +1349,30 @@ public Metadata build() {\n \n         private SortedMap<String, IndexAbstraction> buildIndicesLookup() {\n             SortedMap<String, IndexAbstraction> indicesLookup = new TreeMap<>();\n+            Map<String, DataStream> indexToDataStreamLookup = new HashMap<>();\n+            DataStreamMetadata dataStreamMetadata = (DataStreamMetadata) this.customs.get(DataStreamMetadata.TYPE);\n+            if (dataStreamMetadata != null) {\n+                for (DataStream ds : dataStreamMetadata.dataStreams().values()) {\n+                    for (Index i : ds.getIndices()) {\n+                        indexToDataStreamLookup.put(i.getName(), ds);\n+                    }\n+                }\n+            }\n+\n             for (ObjectCursor<IndexMetadata> cursor : indices.values()) {\n                 IndexMetadata indexMetadata = cursor.value;\n-                IndexAbstraction existing =\n-                    indicesLookup.put(indexMetadata.getIndex().getName(), new IndexAbstraction.Index(indexMetadata));\n+\n+                IndexAbstraction.Index index;\n+                DataStream parent = indexToDataStreamLookup.get(indexMetadata.getIndex().getName());\n+                if (parent != null) {\n+                    List<IndexMetadata> backingIndices = parent.getIndices().stream()\n+                        .map(imd -> indices.get(imd.getName())).collect(Collectors.toList());\n+                    index = new IndexAbstraction.Index(indexMetadata, new IndexAbstraction.DataStream(parent, backingIndices));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE0MTA0Mg=="}, "originalCommit": {"oid": "8053209eb05e4d1b058a7b748073ffba57b1926c"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM4MTY3OQ==", "bodyText": "I think it is a requirement that we reuse the same instances, since equals is not overridden.", "url": "https://github.com/elastic/elasticsearch/pull/55410#discussion_r411381679", "createdAt": "2020-04-20T13:35:27Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/Metadata.java", "diffHunk": "@@ -1349,10 +1349,30 @@ public Metadata build() {\n \n         private SortedMap<String, IndexAbstraction> buildIndicesLookup() {\n             SortedMap<String, IndexAbstraction> indicesLookup = new TreeMap<>();\n+            Map<String, DataStream> indexToDataStreamLookup = new HashMap<>();\n+            DataStreamMetadata dataStreamMetadata = (DataStreamMetadata) this.customs.get(DataStreamMetadata.TYPE);\n+            if (dataStreamMetadata != null) {\n+                for (DataStream ds : dataStreamMetadata.dataStreams().values()) {\n+                    for (Index i : ds.getIndices()) {\n+                        indexToDataStreamLookup.put(i.getName(), ds);\n+                    }\n+                }\n+            }\n+\n             for (ObjectCursor<IndexMetadata> cursor : indices.values()) {\n                 IndexMetadata indexMetadata = cursor.value;\n-                IndexAbstraction existing =\n-                    indicesLookup.put(indexMetadata.getIndex().getName(), new IndexAbstraction.Index(indexMetadata));\n+\n+                IndexAbstraction.Index index;\n+                DataStream parent = indexToDataStreamLookup.get(indexMetadata.getIndex().getName());\n+                if (parent != null) {\n+                    List<IndexMetadata> backingIndices = parent.getIndices().stream()\n+                        .map(imd -> indices.get(imd.getName())).collect(Collectors.toList());\n+                    index = new IndexAbstraction.Index(indexMetadata, new IndexAbstraction.DataStream(parent, backingIndices));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE0MTA0Mg=="}, "originalCommit": {"oid": "8053209eb05e4d1b058a7b748073ffba57b1926c"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NTY4NTg3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/Metadata.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMzozMzoyNFrOGIUpzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMzozMzoyNFrOGIUpzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM4MDE3Mw==", "bodyText": "Can we add:\nassert parent.getIndices().contains(indexMetadata.getIndex())\n\nthat would  validate that uuid and name from data-stream indices is the same as the index we are looking at.", "url": "https://github.com/elastic/elasticsearch/pull/55410#discussion_r411380173", "createdAt": "2020-04-20T13:33:24Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/Metadata.java", "diffHunk": "@@ -1349,10 +1349,30 @@ public Metadata build() {\n \n         private SortedMap<String, IndexAbstraction> buildIndicesLookup() {\n             SortedMap<String, IndexAbstraction> indicesLookup = new TreeMap<>();\n+            Map<String, DataStream> indexToDataStreamLookup = new HashMap<>();\n+            DataStreamMetadata dataStreamMetadata = (DataStreamMetadata) this.customs.get(DataStreamMetadata.TYPE);\n+            if (dataStreamMetadata != null) {\n+                for (DataStream ds : dataStreamMetadata.dataStreams().values()) {\n+                    for (Index i : ds.getIndices()) {\n+                        indexToDataStreamLookup.put(i.getName(), ds);\n+                    }\n+                }\n+            }\n+\n             for (ObjectCursor<IndexMetadata> cursor : indices.values()) {\n                 IndexMetadata indexMetadata = cursor.value;\n-                IndexAbstraction existing =\n-                    indicesLookup.put(indexMetadata.getIndex().getName(), new IndexAbstraction.Index(indexMetadata));\n+\n+                IndexAbstraction.Index index;\n+                DataStream parent = indexToDataStreamLookup.get(indexMetadata.getIndex().getName());\n+                if (parent != null) {\n+                    List<IndexMetadata> backingIndices = parent.getIndices().stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8053209eb05e4d1b058a7b748073ffba57b1926c"}, "originalPosition": 22}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1000, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}