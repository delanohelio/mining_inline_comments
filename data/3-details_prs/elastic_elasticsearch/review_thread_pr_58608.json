{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQwNjA4ODM4", "number": 58608, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwNjo0MDozNVrOEMWeag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QwODo1Mzo0OFrOENuPRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMzg2NjAyOnYy", "diffSide": "RIGHT", "path": "benchmarks/src/main/java/org/elasticsearch/benchmark/search/aggregations/bucket/terms/LongKeyedBucketOrdsBenchmark.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwNjo0MDozNVrOGuaJDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwNjo0MDozNVrOGuaJDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTMxNTk4Mw==", "bodyText": "This benchmark is prone to an optimization called dead code elimination because you neither return anything nor you feed anything into JMH's Blackhole.", "url": "https://github.com/elastic/elasticsearch/pull/58608#discussion_r451315983", "createdAt": "2020-07-08T06:40:35Z", "author": {"login": "danielmitterdorfer"}, "path": "benchmarks/src/main/java/org/elasticsearch/benchmark/search/aggregations/bucket/terms/LongKeyedBucketOrdsBenchmark.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.benchmark.search.aggregations.bucket.terms;\n+\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.BigArrays;\n+import org.elasticsearch.common.util.PageCacheRecycler;\n+import org.elasticsearch.search.aggregations.bucket.histogram.AutoDateHistogramAggregationBuilder;\n+import org.elasticsearch.search.aggregations.bucket.terms.LongKeyedBucketOrds;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Fork(2)\n+@Warmup(iterations = 10)\n+@Measurement(iterations = 5)\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@OperationsPerInvocation(1_000_000)\n+@State(Scope.Benchmark)\n+public class LongKeyedBucketOrdsBenchmark {\n+    private static final long LIMIT = 1_000_000;\n+    /**\n+     * The number of distinct values to add to the buckets.\n+     */\n+    private static final long DISTINCT_VALUES = 10;\n+    /**\n+     * The number of buckets to create in the {@link #multiBucket()} case.\n+     * <p>\n+     * If this is not relatively prime to {@link #DISTINCT_VALUES} then the\n+     * values won't be scattered evenly across the buckets.\n+     */\n+    private static final long DISTINCT_BUCKETS = 21;\n+\n+    PageCacheRecycler recycler = new PageCacheRecycler(Settings.EMPTY);\n+    BigArrays bigArrays = new BigArrays(recycler, null, \"REQUEST\");\n+\n+    /**\n+     * Emulates a way that we do <strong>not</strong> use {@link LongKeyedBucketOrds}\n+     * because it is not needed.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoSingleImmutableMonmorphicInvocation() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80ba140322035157349bb2a694c1a78301210a4d"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMzg2NjIyOnYy", "diffSide": "RIGHT", "path": "benchmarks/src/main/java/org/elasticsearch/benchmark/search/aggregations/bucket/terms/LongKeyedBucketOrdsBenchmark.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwNjo0MDo0MFrOGuaJKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwNjo0MDo0MFrOGuaJKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTMxNjAxMQ==", "bodyText": "This benchmark is prone to an optimization called dead code elimination because you neither return anything nor you feed anything into JMH's Blackhole.", "url": "https://github.com/elastic/elasticsearch/pull/58608#discussion_r451316011", "createdAt": "2020-07-08T06:40:40Z", "author": {"login": "danielmitterdorfer"}, "path": "benchmarks/src/main/java/org/elasticsearch/benchmark/search/aggregations/bucket/terms/LongKeyedBucketOrdsBenchmark.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.benchmark.search.aggregations.bucket.terms;\n+\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.BigArrays;\n+import org.elasticsearch.common.util.PageCacheRecycler;\n+import org.elasticsearch.search.aggregations.bucket.histogram.AutoDateHistogramAggregationBuilder;\n+import org.elasticsearch.search.aggregations.bucket.terms.LongKeyedBucketOrds;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Fork(2)\n+@Warmup(iterations = 10)\n+@Measurement(iterations = 5)\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@OperationsPerInvocation(1_000_000)\n+@State(Scope.Benchmark)\n+public class LongKeyedBucketOrdsBenchmark {\n+    private static final long LIMIT = 1_000_000;\n+    /**\n+     * The number of distinct values to add to the buckets.\n+     */\n+    private static final long DISTINCT_VALUES = 10;\n+    /**\n+     * The number of buckets to create in the {@link #multiBucket()} case.\n+     * <p>\n+     * If this is not relatively prime to {@link #DISTINCT_VALUES} then the\n+     * values won't be scattered evenly across the buckets.\n+     */\n+    private static final long DISTINCT_BUCKETS = 21;\n+\n+    PageCacheRecycler recycler = new PageCacheRecycler(Settings.EMPTY);\n+    BigArrays bigArrays = new BigArrays(recycler, null, \"REQUEST\");\n+\n+    /**\n+     * Emulates a way that we do <strong>not</strong> use {@link LongKeyedBucketOrds}\n+     * because it is not needed.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoSingleImmutableMonmorphicInvocation() {\n+        try (LongKeyedBucketOrds.FromSingle ords = new LongKeyedBucketOrds.FromSingle(bigArrays)) {\n+            for (long i = 0; i < LIMIT; i++) {\n+                ords.add(0, i % DISTINCT_VALUES);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Emulates the way that most aggregations use {@link LongKeyedBucketOrds}.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoSingleImmutableBimorphicInvocation() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80ba140322035157349bb2a694c1a78301210a4d"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMzg2NjYyOnYy", "diffSide": "RIGHT", "path": "benchmarks/src/main/java/org/elasticsearch/benchmark/search/aggregations/bucket/terms/LongKeyedBucketOrdsBenchmark.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwNjo0MDo0NVrOGuaJWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwNjo0MDo0NVrOGuaJWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTMxNjA1OQ==", "bodyText": "This benchmark is prone to an optimization called dead code elimination because you neither return anything nor you feed anything into JMH's Blackhole.", "url": "https://github.com/elastic/elasticsearch/pull/58608#discussion_r451316059", "createdAt": "2020-07-08T06:40:45Z", "author": {"login": "danielmitterdorfer"}, "path": "benchmarks/src/main/java/org/elasticsearch/benchmark/search/aggregations/bucket/terms/LongKeyedBucketOrdsBenchmark.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.benchmark.search.aggregations.bucket.terms;\n+\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.BigArrays;\n+import org.elasticsearch.common.util.PageCacheRecycler;\n+import org.elasticsearch.search.aggregations.bucket.histogram.AutoDateHistogramAggregationBuilder;\n+import org.elasticsearch.search.aggregations.bucket.terms.LongKeyedBucketOrds;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Fork(2)\n+@Warmup(iterations = 10)\n+@Measurement(iterations = 5)\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@OperationsPerInvocation(1_000_000)\n+@State(Scope.Benchmark)\n+public class LongKeyedBucketOrdsBenchmark {\n+    private static final long LIMIT = 1_000_000;\n+    /**\n+     * The number of distinct values to add to the buckets.\n+     */\n+    private static final long DISTINCT_VALUES = 10;\n+    /**\n+     * The number of buckets to create in the {@link #multiBucket()} case.\n+     * <p>\n+     * If this is not relatively prime to {@link #DISTINCT_VALUES} then the\n+     * values won't be scattered evenly across the buckets.\n+     */\n+    private static final long DISTINCT_BUCKETS = 21;\n+\n+    PageCacheRecycler recycler = new PageCacheRecycler(Settings.EMPTY);\n+    BigArrays bigArrays = new BigArrays(recycler, null, \"REQUEST\");\n+\n+    /**\n+     * Emulates a way that we do <strong>not</strong> use {@link LongKeyedBucketOrds}\n+     * because it is not needed.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoSingleImmutableMonmorphicInvocation() {\n+        try (LongKeyedBucketOrds.FromSingle ords = new LongKeyedBucketOrds.FromSingle(bigArrays)) {\n+            for (long i = 0; i < LIMIT; i++) {\n+                ords.add(0, i % DISTINCT_VALUES);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Emulates the way that most aggregations use {@link LongKeyedBucketOrds}.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoSingleImmutableBimorphicInvocation() {\n+        try (LongKeyedBucketOrds ords = LongKeyedBucketOrds.build(bigArrays, true)) {\n+            for (long i = 0; i < LIMIT; i++) {\n+                ords.add(0, i % DISTINCT_VALUES);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Emulates the way that {@link AutoDateHistogramAggregationBuilder} uses {@link LongKeyedBucketOrds}.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoSingleMutableMonmorphicInvocation() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80ba140322035157349bb2a694c1a78301210a4d"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMzg2Njg1OnYy", "diffSide": "RIGHT", "path": "benchmarks/src/main/java/org/elasticsearch/benchmark/search/aggregations/bucket/terms/LongKeyedBucketOrdsBenchmark.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwNjo0MDo1M1rOGuaJfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwNjo0MDo1M1rOGuaJfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTMxNjA5NQ==", "bodyText": "This benchmark is prone to an optimization called dead code elimination because you neither return anything nor you feed anything into JMH's Blackhole.", "url": "https://github.com/elastic/elasticsearch/pull/58608#discussion_r451316095", "createdAt": "2020-07-08T06:40:53Z", "author": {"login": "danielmitterdorfer"}, "path": "benchmarks/src/main/java/org/elasticsearch/benchmark/search/aggregations/bucket/terms/LongKeyedBucketOrdsBenchmark.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.benchmark.search.aggregations.bucket.terms;\n+\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.BigArrays;\n+import org.elasticsearch.common.util.PageCacheRecycler;\n+import org.elasticsearch.search.aggregations.bucket.histogram.AutoDateHistogramAggregationBuilder;\n+import org.elasticsearch.search.aggregations.bucket.terms.LongKeyedBucketOrds;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Fork(2)\n+@Warmup(iterations = 10)\n+@Measurement(iterations = 5)\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@OperationsPerInvocation(1_000_000)\n+@State(Scope.Benchmark)\n+public class LongKeyedBucketOrdsBenchmark {\n+    private static final long LIMIT = 1_000_000;\n+    /**\n+     * The number of distinct values to add to the buckets.\n+     */\n+    private static final long DISTINCT_VALUES = 10;\n+    /**\n+     * The number of buckets to create in the {@link #multiBucket()} case.\n+     * <p>\n+     * If this is not relatively prime to {@link #DISTINCT_VALUES} then the\n+     * values won't be scattered evenly across the buckets.\n+     */\n+    private static final long DISTINCT_BUCKETS = 21;\n+\n+    PageCacheRecycler recycler = new PageCacheRecycler(Settings.EMPTY);\n+    BigArrays bigArrays = new BigArrays(recycler, null, \"REQUEST\");\n+\n+    /**\n+     * Emulates a way that we do <strong>not</strong> use {@link LongKeyedBucketOrds}\n+     * because it is not needed.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoSingleImmutableMonmorphicInvocation() {\n+        try (LongKeyedBucketOrds.FromSingle ords = new LongKeyedBucketOrds.FromSingle(bigArrays)) {\n+            for (long i = 0; i < LIMIT; i++) {\n+                ords.add(0, i % DISTINCT_VALUES);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Emulates the way that most aggregations use {@link LongKeyedBucketOrds}.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoSingleImmutableBimorphicInvocation() {\n+        try (LongKeyedBucketOrds ords = LongKeyedBucketOrds.build(bigArrays, true)) {\n+            for (long i = 0; i < LIMIT; i++) {\n+                ords.add(0, i % DISTINCT_VALUES);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Emulates the way that {@link AutoDateHistogramAggregationBuilder} uses {@link LongKeyedBucketOrds}.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoSingleMutableMonmorphicInvocation() {\n+        LongKeyedBucketOrds.FromSingle ords = new LongKeyedBucketOrds.FromSingle(bigArrays);\n+        for (long i = 0; i < LIMIT; i++) {\n+            if (i % 100_000 == 0) {\n+                ords.close();\n+                ords = new LongKeyedBucketOrds.FromSingle(bigArrays);\n+            }\n+            ords.add(0, i % DISTINCT_VALUES);\n+        }\n+        ords.close();\n+    }\n+\n+    /**\n+     * Emulates a way that we do <strong>not</strong> use {@link LongKeyedBucketOrds}\n+     * because it is significantly slower than the\n+     * {@link #singleBucketIntoSingleMutableMonmorphicInvocation() monomorphic invocation}.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoSingleMutableBimorphicInvocation() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80ba140322035157349bb2a694c1a78301210a4d"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMzg2NzAzOnYy", "diffSide": "RIGHT", "path": "benchmarks/src/main/java/org/elasticsearch/benchmark/search/aggregations/bucket/terms/LongKeyedBucketOrdsBenchmark.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwNjo0MDo1OFrOGuaJng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwNjo0MDo1OFrOGuaJng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTMxNjEyNg==", "bodyText": "This benchmark is prone to an optimization called dead code elimination because you neither return anything nor you feed anything into JMH's Blackhole.", "url": "https://github.com/elastic/elasticsearch/pull/58608#discussion_r451316126", "createdAt": "2020-07-08T06:40:58Z", "author": {"login": "danielmitterdorfer"}, "path": "benchmarks/src/main/java/org/elasticsearch/benchmark/search/aggregations/bucket/terms/LongKeyedBucketOrdsBenchmark.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.benchmark.search.aggregations.bucket.terms;\n+\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.BigArrays;\n+import org.elasticsearch.common.util.PageCacheRecycler;\n+import org.elasticsearch.search.aggregations.bucket.histogram.AutoDateHistogramAggregationBuilder;\n+import org.elasticsearch.search.aggregations.bucket.terms.LongKeyedBucketOrds;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Fork(2)\n+@Warmup(iterations = 10)\n+@Measurement(iterations = 5)\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@OperationsPerInvocation(1_000_000)\n+@State(Scope.Benchmark)\n+public class LongKeyedBucketOrdsBenchmark {\n+    private static final long LIMIT = 1_000_000;\n+    /**\n+     * The number of distinct values to add to the buckets.\n+     */\n+    private static final long DISTINCT_VALUES = 10;\n+    /**\n+     * The number of buckets to create in the {@link #multiBucket()} case.\n+     * <p>\n+     * If this is not relatively prime to {@link #DISTINCT_VALUES} then the\n+     * values won't be scattered evenly across the buckets.\n+     */\n+    private static final long DISTINCT_BUCKETS = 21;\n+\n+    PageCacheRecycler recycler = new PageCacheRecycler(Settings.EMPTY);\n+    BigArrays bigArrays = new BigArrays(recycler, null, \"REQUEST\");\n+\n+    /**\n+     * Emulates a way that we do <strong>not</strong> use {@link LongKeyedBucketOrds}\n+     * because it is not needed.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoSingleImmutableMonmorphicInvocation() {\n+        try (LongKeyedBucketOrds.FromSingle ords = new LongKeyedBucketOrds.FromSingle(bigArrays)) {\n+            for (long i = 0; i < LIMIT; i++) {\n+                ords.add(0, i % DISTINCT_VALUES);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Emulates the way that most aggregations use {@link LongKeyedBucketOrds}.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoSingleImmutableBimorphicInvocation() {\n+        try (LongKeyedBucketOrds ords = LongKeyedBucketOrds.build(bigArrays, true)) {\n+            for (long i = 0; i < LIMIT; i++) {\n+                ords.add(0, i % DISTINCT_VALUES);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Emulates the way that {@link AutoDateHistogramAggregationBuilder} uses {@link LongKeyedBucketOrds}.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoSingleMutableMonmorphicInvocation() {\n+        LongKeyedBucketOrds.FromSingle ords = new LongKeyedBucketOrds.FromSingle(bigArrays);\n+        for (long i = 0; i < LIMIT; i++) {\n+            if (i % 100_000 == 0) {\n+                ords.close();\n+                ords = new LongKeyedBucketOrds.FromSingle(bigArrays);\n+            }\n+            ords.add(0, i % DISTINCT_VALUES);\n+        }\n+        ords.close();\n+    }\n+\n+    /**\n+     * Emulates a way that we do <strong>not</strong> use {@link LongKeyedBucketOrds}\n+     * because it is significantly slower than the\n+     * {@link #singleBucketIntoSingleMutableMonmorphicInvocation() monomorphic invocation}.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoSingleMutableBimorphicInvocation() {\n+        LongKeyedBucketOrds ords = LongKeyedBucketOrds.build(bigArrays, true);\n+        for (long i = 0; i < LIMIT; i++) {\n+            if (i % 100_000 == 0) {\n+                ords.close();\n+                ords = LongKeyedBucketOrds.build(bigArrays, true);\n+            }\n+            ords.add(0, i % DISTINCT_VALUES);\n+\n+        }\n+        ords.close();\n+    }\n+\n+    /**\n+     * Emulates an aggregation that collects from a single bucket \"by accident\".\n+     * This can happen if an aggregation is under, say, a {@code terms}\n+     * aggregation and there is only a single value for that term in the index.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoMulti() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80ba140322035157349bb2a694c1a78301210a4d"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMzg2NzE1OnYy", "diffSide": "RIGHT", "path": "benchmarks/src/main/java/org/elasticsearch/benchmark/search/aggregations/bucket/terms/LongKeyedBucketOrdsBenchmark.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwNjo0MTowMlrOGuaJtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwNjo0MTowMlrOGuaJtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTMxNjE1MA==", "bodyText": "This benchmark is prone to an optimization called dead code elimination because you neither return anything nor you feed anything into JMH's Blackhole.", "url": "https://github.com/elastic/elasticsearch/pull/58608#discussion_r451316150", "createdAt": "2020-07-08T06:41:02Z", "author": {"login": "danielmitterdorfer"}, "path": "benchmarks/src/main/java/org/elasticsearch/benchmark/search/aggregations/bucket/terms/LongKeyedBucketOrdsBenchmark.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.benchmark.search.aggregations.bucket.terms;\n+\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.BigArrays;\n+import org.elasticsearch.common.util.PageCacheRecycler;\n+import org.elasticsearch.search.aggregations.bucket.histogram.AutoDateHistogramAggregationBuilder;\n+import org.elasticsearch.search.aggregations.bucket.terms.LongKeyedBucketOrds;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Fork(2)\n+@Warmup(iterations = 10)\n+@Measurement(iterations = 5)\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@OperationsPerInvocation(1_000_000)\n+@State(Scope.Benchmark)\n+public class LongKeyedBucketOrdsBenchmark {\n+    private static final long LIMIT = 1_000_000;\n+    /**\n+     * The number of distinct values to add to the buckets.\n+     */\n+    private static final long DISTINCT_VALUES = 10;\n+    /**\n+     * The number of buckets to create in the {@link #multiBucket()} case.\n+     * <p>\n+     * If this is not relatively prime to {@link #DISTINCT_VALUES} then the\n+     * values won't be scattered evenly across the buckets.\n+     */\n+    private static final long DISTINCT_BUCKETS = 21;\n+\n+    PageCacheRecycler recycler = new PageCacheRecycler(Settings.EMPTY);\n+    BigArrays bigArrays = new BigArrays(recycler, null, \"REQUEST\");\n+\n+    /**\n+     * Emulates a way that we do <strong>not</strong> use {@link LongKeyedBucketOrds}\n+     * because it is not needed.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoSingleImmutableMonmorphicInvocation() {\n+        try (LongKeyedBucketOrds.FromSingle ords = new LongKeyedBucketOrds.FromSingle(bigArrays)) {\n+            for (long i = 0; i < LIMIT; i++) {\n+                ords.add(0, i % DISTINCT_VALUES);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Emulates the way that most aggregations use {@link LongKeyedBucketOrds}.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoSingleImmutableBimorphicInvocation() {\n+        try (LongKeyedBucketOrds ords = LongKeyedBucketOrds.build(bigArrays, true)) {\n+            for (long i = 0; i < LIMIT; i++) {\n+                ords.add(0, i % DISTINCT_VALUES);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Emulates the way that {@link AutoDateHistogramAggregationBuilder} uses {@link LongKeyedBucketOrds}.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoSingleMutableMonmorphicInvocation() {\n+        LongKeyedBucketOrds.FromSingle ords = new LongKeyedBucketOrds.FromSingle(bigArrays);\n+        for (long i = 0; i < LIMIT; i++) {\n+            if (i % 100_000 == 0) {\n+                ords.close();\n+                ords = new LongKeyedBucketOrds.FromSingle(bigArrays);\n+            }\n+            ords.add(0, i % DISTINCT_VALUES);\n+        }\n+        ords.close();\n+    }\n+\n+    /**\n+     * Emulates a way that we do <strong>not</strong> use {@link LongKeyedBucketOrds}\n+     * because it is significantly slower than the\n+     * {@link #singleBucketIntoSingleMutableMonmorphicInvocation() monomorphic invocation}.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoSingleMutableBimorphicInvocation() {\n+        LongKeyedBucketOrds ords = LongKeyedBucketOrds.build(bigArrays, true);\n+        for (long i = 0; i < LIMIT; i++) {\n+            if (i % 100_000 == 0) {\n+                ords.close();\n+                ords = LongKeyedBucketOrds.build(bigArrays, true);\n+            }\n+            ords.add(0, i % DISTINCT_VALUES);\n+\n+        }\n+        ords.close();\n+    }\n+\n+    /**\n+     * Emulates an aggregation that collects from a single bucket \"by accident\".\n+     * This can happen if an aggregation is under, say, a {@code terms}\n+     * aggregation and there is only a single value for that term in the index.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoMulti() {\n+        try (LongKeyedBucketOrds ords = LongKeyedBucketOrds.build(bigArrays, false)) {\n+            for (long i = 0; i < LIMIT; i++) {\n+                ords.add(0, i % DISTINCT_VALUES);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Emulates an aggregation that collects from many buckets.\n+     */\n+    @Benchmark\n+    public void multiBucket() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80ba140322035157349bb2a694c1a78301210a4d"}, "originalPosition": 142}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyODI0NTE3OnYy", "diffSide": "RIGHT", "path": "benchmarks/src/main/java/org/elasticsearch/benchmark/search/aggregations/bucket/terms/LongKeyedBucketOrdsBenchmark.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QwODo1Mzo0OFrOGwfLjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxODo0MzozN1rOGw1Ksg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQ5NTY5Mw==", "bodyText": "I assume you're not interested in measuring class loading so you can move this code out of the measurement loop and into a separate setup method:\n    @Setup\n    public void setUp(Blackhole bh) {\n        // you can also inline this method now that there is only one call site\n        forceLoadClasses(bh);\n    }", "url": "https://github.com/elastic/elasticsearch/pull/58608#discussion_r453495693", "createdAt": "2020-07-13T08:53:48Z", "author": {"login": "danielmitterdorfer"}, "path": "benchmarks/src/main/java/org/elasticsearch/benchmark/search/aggregations/bucket/terms/LongKeyedBucketOrdsBenchmark.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.benchmark.search.aggregations.bucket.terms;\n+\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.BigArrays;\n+import org.elasticsearch.common.util.PageCacheRecycler;\n+import org.elasticsearch.search.aggregations.CardinalityUpperBound;\n+import org.elasticsearch.search.aggregations.bucket.histogram.AutoDateHistogramAggregationBuilder;\n+import org.elasticsearch.search.aggregations.bucket.terms.LongKeyedBucketOrds;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Fork(2)\n+@Warmup(iterations = 10)\n+@Measurement(iterations = 5)\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@OperationsPerInvocation(1_000_000)\n+@State(Scope.Benchmark)\n+public class LongKeyedBucketOrdsBenchmark {\n+    private static final long LIMIT = 1_000_000;\n+    /**\n+     * The number of distinct values to add to the buckets.\n+     */\n+    private static final long DISTINCT_VALUES = 10;\n+    /**\n+     * The number of buckets to create in the {@link #multiBucket} case.\n+     * <p>\n+     * If this is not relatively prime to {@link #DISTINCT_VALUES} then the\n+     * values won't be scattered evenly across the buckets.\n+     */\n+    private static final long DISTINCT_BUCKETS = 21;\n+\n+    PageCacheRecycler recycler = new PageCacheRecycler(Settings.EMPTY);\n+    BigArrays bigArrays = new BigArrays(recycler, null, \"REQUEST\");\n+\n+    /**\n+     * Emulates a way that we do <strong>not</strong> use {@link LongKeyedBucketOrds}\n+     * because it is not needed.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoSingleImmutableMonmorphicInvocation(Blackhole bh) {\n+        forceLoadClasses(bh);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67b57dba147bc70ff40c5b0c0ccd794247f45164"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg1NTkyMg==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/elastic/elasticsearch/pull/58608#discussion_r453855922", "createdAt": "2020-07-13T18:43:37Z", "author": {"login": "nik9000"}, "path": "benchmarks/src/main/java/org/elasticsearch/benchmark/search/aggregations/bucket/terms/LongKeyedBucketOrdsBenchmark.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.benchmark.search.aggregations.bucket.terms;\n+\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.BigArrays;\n+import org.elasticsearch.common.util.PageCacheRecycler;\n+import org.elasticsearch.search.aggregations.CardinalityUpperBound;\n+import org.elasticsearch.search.aggregations.bucket.histogram.AutoDateHistogramAggregationBuilder;\n+import org.elasticsearch.search.aggregations.bucket.terms.LongKeyedBucketOrds;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Fork(2)\n+@Warmup(iterations = 10)\n+@Measurement(iterations = 5)\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@OperationsPerInvocation(1_000_000)\n+@State(Scope.Benchmark)\n+public class LongKeyedBucketOrdsBenchmark {\n+    private static final long LIMIT = 1_000_000;\n+    /**\n+     * The number of distinct values to add to the buckets.\n+     */\n+    private static final long DISTINCT_VALUES = 10;\n+    /**\n+     * The number of buckets to create in the {@link #multiBucket} case.\n+     * <p>\n+     * If this is not relatively prime to {@link #DISTINCT_VALUES} then the\n+     * values won't be scattered evenly across the buckets.\n+     */\n+    private static final long DISTINCT_BUCKETS = 21;\n+\n+    PageCacheRecycler recycler = new PageCacheRecycler(Settings.EMPTY);\n+    BigArrays bigArrays = new BigArrays(recycler, null, \"REQUEST\");\n+\n+    /**\n+     * Emulates a way that we do <strong>not</strong> use {@link LongKeyedBucketOrds}\n+     * because it is not needed.\n+     */\n+    @Benchmark\n+    public void singleBucketIntoSingleImmutableMonmorphicInvocation(Blackhole bh) {\n+        forceLoadClasses(bh);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQ5NTY5Mw=="}, "originalCommit": {"oid": "67b57dba147bc70ff40c5b0c0ccd794247f45164"}, "originalPosition": 72}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2338, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}