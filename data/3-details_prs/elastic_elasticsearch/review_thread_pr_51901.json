{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcxMTI4MzQ4", "number": 51901, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxMDoyMjowOFrODdR8KQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxOToxODo0N1rODlK5cQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMDI5MjI1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/analysis/Analyzer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxMDoyMjowOFrOFlyn2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxMDoyMjowOFrOFlyn2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE3MTAzMw==", "bodyText": "Can a wildcard appear in any type of string? e.g. some*glob?\nI wonder whether the parser could detect it so instead of having Literal that might a string, it could have its own expression rule.", "url": "https://github.com/elastic/elasticsearch/pull/51901#discussion_r375171033", "createdAt": "2020-02-05T10:22:08Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/analysis/Analyzer.java", "diffHunk": "@@ -42,4 +60,110 @@ private LogicalPlan verify(LogicalPlan plan) {\n         }\n         return plan;\n     }\n+\n+    private static class ReplaceWildcards extends AnalyzeRule<Filter> {\n+\n+        private static boolean isWildcard(Expression expr) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61da57cc693b0a9f3b90ba55d7e021a9f3654140"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMDMwODM4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/analysis/Analyzer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxMDoyNzoxOVrOFlyyDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxMDoyNzoxOVrOFlyyDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE3MzY0Ng==", "bodyText": "A potential improvement is to check whether an expression is foldable instead of being a literal.\nThus if string concatenation were to be added, the rule would still be applied:\nif (e.foldable() && e.fold() instanceof String) {\n    return e.fold().toString().contains(\"*\");\n}\nwhich can be transformed into a one-liner:\nreturn e.foldable() && e.fold() instanceof String && e.fold().toString().contains(\"*\");", "url": "https://github.com/elastic/elasticsearch/pull/51901#discussion_r375173646", "createdAt": "2020-02-05T10:27:19Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/analysis/Analyzer.java", "diffHunk": "@@ -42,4 +60,110 @@ private LogicalPlan verify(LogicalPlan plan) {\n         }\n         return plan;\n     }\n+\n+    private static class ReplaceWildcards extends AnalyzeRule<Filter> {\n+\n+        private static boolean isWildcard(Expression expr) {\n+            if (expr instanceof Literal) {\n+                Literal l = (Literal) expr;\n+                if (l.value() instanceof String) {\n+                    String s = (String) l.value();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61da57cc693b0a9f3b90ba55d7e021a9f3654140"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMDMxNzY4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/analysis/Analyzer.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxMDozMDowN1rOFly31g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QxNDowNjoyOFrOFm-ChA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE3NTEyNg==", "bodyText": "what about foo > \"wild*card\" or other value comparisons?\nIf that's valid grammar, the verifier should pick the pattern and fail the query.", "url": "https://github.com/elastic/elasticsearch/pull/51901#discussion_r375175126", "createdAt": "2020-02-05T10:30:07Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/analysis/Analyzer.java", "diffHunk": "@@ -42,4 +60,110 @@ private LogicalPlan verify(LogicalPlan plan) {\n         }\n         return plan;\n     }\n+\n+    private static class ReplaceWildcards extends AnalyzeRule<Filter> {\n+\n+        private static boolean isWildcard(Expression expr) {\n+            if (expr instanceof Literal) {\n+                Literal l = (Literal) expr;\n+                if (l.value() instanceof String) {\n+                    String s = (String) l.value();\n+                    return s.contains(\"*\");\n+                }\n+            }\n+\n+            return false;\n+        }\n+\n+        private static LikePattern toLikePattern(String s) {\n+            // pick a character that is guaranteed not to be in the string, because it isn't allowed to escape itself\n+            char escape = 1;\n+\n+            // replace wildcards with % and escape special characters\n+            String likeString = s.replace(\"%\", escape + \"%\")\n+                                 .replace(\"_\", escape + \"_\")\n+                                 .replace(\"*\", \"%\");\n+\n+            return new LikePattern(likeString, escape);\n+        }\n+\n+        @Override\n+        protected LogicalPlan rule(Filter filter) {\n+            return filter.transformExpressionsUp(e -> {\n+                // expr == \"wildcard*phrase\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61da57cc693b0a9f3b90ba55d7e021a9f3654140"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM1OTcwMw==", "bodyText": "yeah, it is valid grammar, but since it's not == or !=, this will just be a lexicographical comparison", "url": "https://github.com/elastic/elasticsearch/pull/51901#discussion_r375359703", "createdAt": "2020-02-05T16:20:49Z", "author": {"login": "rw-access"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/analysis/Analyzer.java", "diffHunk": "@@ -42,4 +60,110 @@ private LogicalPlan verify(LogicalPlan plan) {\n         }\n         return plan;\n     }\n+\n+    private static class ReplaceWildcards extends AnalyzeRule<Filter> {\n+\n+        private static boolean isWildcard(Expression expr) {\n+            if (expr instanceof Literal) {\n+                Literal l = (Literal) expr;\n+                if (l.value() instanceof String) {\n+                    String s = (String) l.value();\n+                    return s.contains(\"*\");\n+                }\n+            }\n+\n+            return false;\n+        }\n+\n+        private static LikePattern toLikePattern(String s) {\n+            // pick a character that is guaranteed not to be in the string, because it isn't allowed to escape itself\n+            char escape = 1;\n+\n+            // replace wildcards with % and escape special characters\n+            String likeString = s.replace(\"%\", escape + \"%\")\n+                                 .replace(\"_\", escape + \"_\")\n+                                 .replace(\"*\", \"%\");\n+\n+            return new LikePattern(likeString, escape);\n+        }\n+\n+        @Override\n+        protected LogicalPlan rule(Filter filter) {\n+            return filter.transformExpressionsUp(e -> {\n+                // expr == \"wildcard*phrase\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE3NTEyNg=="}, "originalCommit": {"oid": "61da57cc693b0a9f3b90ba55d7e021a9f3654140"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQwNjY2MA==", "bodyText": "That would mean the operators are not consistent since == would expand the wildcard while > & co would compare against it...", "url": "https://github.com/elastic/elasticsearch/pull/51901#discussion_r376406660", "createdAt": "2020-02-07T14:06:28Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/analysis/Analyzer.java", "diffHunk": "@@ -42,4 +60,110 @@ private LogicalPlan verify(LogicalPlan plan) {\n         }\n         return plan;\n     }\n+\n+    private static class ReplaceWildcards extends AnalyzeRule<Filter> {\n+\n+        private static boolean isWildcard(Expression expr) {\n+            if (expr instanceof Literal) {\n+                Literal l = (Literal) expr;\n+                if (l.value() instanceof String) {\n+                    String s = (String) l.value();\n+                    return s.contains(\"*\");\n+                }\n+            }\n+\n+            return false;\n+        }\n+\n+        private static LikePattern toLikePattern(String s) {\n+            // pick a character that is guaranteed not to be in the string, because it isn't allowed to escape itself\n+            char escape = 1;\n+\n+            // replace wildcards with % and escape special characters\n+            String likeString = s.replace(\"%\", escape + \"%\")\n+                                 .replace(\"_\", escape + \"_\")\n+                                 .replace(\"*\", \"%\");\n+\n+            return new LikePattern(likeString, escape);\n+        }\n+\n+        @Override\n+        protected LogicalPlan rule(Filter filter) {\n+            return filter.transformExpressionsUp(e -> {\n+                // expr == \"wildcard*phrase\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE3NTEyNg=="}, "originalCommit": {"oid": "61da57cc693b0a9f3b90ba55d7e021a9f3654140"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMDMxOTI2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/analysis/Analyzer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxMDozMDozOVrOFly42g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxMDozMDozOVrOFly42g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE3NTM4Ng==", "bodyText": "isWildcard already does the checks so simply do: eq.fold().toString()", "url": "https://github.com/elastic/elasticsearch/pull/51901#discussion_r375175386", "createdAt": "2020-02-05T10:30:39Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/analysis/Analyzer.java", "diffHunk": "@@ -42,4 +60,110 @@ private LogicalPlan verify(LogicalPlan plan) {\n         }\n         return plan;\n     }\n+\n+    private static class ReplaceWildcards extends AnalyzeRule<Filter> {\n+\n+        private static boolean isWildcard(Expression expr) {\n+            if (expr instanceof Literal) {\n+                Literal l = (Literal) expr;\n+                if (l.value() instanceof String) {\n+                    String s = (String) l.value();\n+                    return s.contains(\"*\");\n+                }\n+            }\n+\n+            return false;\n+        }\n+\n+        private static LikePattern toLikePattern(String s) {\n+            // pick a character that is guaranteed not to be in the string, because it isn't allowed to escape itself\n+            char escape = 1;\n+\n+            // replace wildcards with % and escape special characters\n+            String likeString = s.replace(\"%\", escape + \"%\")\n+                                 .replace(\"_\", escape + \"_\")\n+                                 .replace(\"*\", \"%\");\n+\n+            return new LikePattern(likeString, escape);\n+        }\n+\n+        @Override\n+        protected LogicalPlan rule(Filter filter) {\n+            return filter.transformExpressionsUp(e -> {\n+                // expr == \"wildcard*phrase\"\n+                if (e instanceof Equals) {\n+                    Equals eq = (Equals) e;\n+\n+                    if (isWildcard(eq.right())) {\n+                        String wcString = (String) ((Literal) eq.right()).value();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61da57cc693b0a9f3b90ba55d7e021a9f3654140"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMDMyNDQ5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/analysis/Analyzer.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxMDozMjoxN1rOFly8Eg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QxNDowODo1MlrOFm-G5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE3NjIxMA==", "bodyText": "the rule makes the assumption that the literal is always on the right hand side which not always the case: \"wildcard*phrase\" != expr is also valid.\nThus the rule is better inside the optimizer, which will also handle folding and move the literals to right (#51929).", "url": "https://github.com/elastic/elasticsearch/pull/51901#discussion_r375176210", "createdAt": "2020-02-05T10:32:17Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/analysis/Analyzer.java", "diffHunk": "@@ -42,4 +60,110 @@ private LogicalPlan verify(LogicalPlan plan) {\n         }\n         return plan;\n     }\n+\n+    private static class ReplaceWildcards extends AnalyzeRule<Filter> {\n+\n+        private static boolean isWildcard(Expression expr) {\n+            if (expr instanceof Literal) {\n+                Literal l = (Literal) expr;\n+                if (l.value() instanceof String) {\n+                    String s = (String) l.value();\n+                    return s.contains(\"*\");\n+                }\n+            }\n+\n+            return false;\n+        }\n+\n+        private static LikePattern toLikePattern(String s) {\n+            // pick a character that is guaranteed not to be in the string, because it isn't allowed to escape itself\n+            char escape = 1;\n+\n+            // replace wildcards with % and escape special characters\n+            String likeString = s.replace(\"%\", escape + \"%\")\n+                                 .replace(\"_\", escape + \"_\")\n+                                 .replace(\"*\", \"%\");\n+\n+            return new LikePattern(likeString, escape);\n+        }\n+\n+        @Override\n+        protected LogicalPlan rule(Filter filter) {\n+            return filter.transformExpressionsUp(e -> {\n+                // expr == \"wildcard*phrase\"\n+                if (e instanceof Equals) {\n+                    Equals eq = (Equals) e;\n+\n+                    if (isWildcard(eq.right())) {\n+                        String wcString = (String) ((Literal) eq.right()).value();\n+                        e = new Like(e.source(), eq.left(), toLikePattern(wcString));\n+                    }\n+                }\n+\n+                // expr != \"wildcard*phrase\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61da57cc693b0a9f3b90ba55d7e021a9f3654140"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM2MDkyMA==", "bodyText": "I doubt that the functionality has been leveraged by many users, but if a wildcard string is on the left instead of the right, then it's just a normal, non-wildcard comparison and will check for equality or inequality depending on the operator.", "url": "https://github.com/elastic/elasticsearch/pull/51901#discussion_r375360920", "createdAt": "2020-02-05T16:22:41Z", "author": {"login": "rw-access"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/analysis/Analyzer.java", "diffHunk": "@@ -42,4 +60,110 @@ private LogicalPlan verify(LogicalPlan plan) {\n         }\n         return plan;\n     }\n+\n+    private static class ReplaceWildcards extends AnalyzeRule<Filter> {\n+\n+        private static boolean isWildcard(Expression expr) {\n+            if (expr instanceof Literal) {\n+                Literal l = (Literal) expr;\n+                if (l.value() instanceof String) {\n+                    String s = (String) l.value();\n+                    return s.contains(\"*\");\n+                }\n+            }\n+\n+            return false;\n+        }\n+\n+        private static LikePattern toLikePattern(String s) {\n+            // pick a character that is guaranteed not to be in the string, because it isn't allowed to escape itself\n+            char escape = 1;\n+\n+            // replace wildcards with % and escape special characters\n+            String likeString = s.replace(\"%\", escape + \"%\")\n+                                 .replace(\"_\", escape + \"_\")\n+                                 .replace(\"*\", \"%\");\n+\n+            return new LikePattern(likeString, escape);\n+        }\n+\n+        @Override\n+        protected LogicalPlan rule(Filter filter) {\n+            return filter.transformExpressionsUp(e -> {\n+                // expr == \"wildcard*phrase\"\n+                if (e instanceof Equals) {\n+                    Equals eq = (Equals) e;\n+\n+                    if (isWildcard(eq.right())) {\n+                        String wcString = (String) ((Literal) eq.right()).value();\n+                        e = new Like(e.source(), eq.left(), toLikePattern(wcString));\n+                    }\n+                }\n+\n+                // expr != \"wildcard*phrase\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE3NjIxMA=="}, "originalCommit": {"oid": "61da57cc693b0a9f3b90ba55d7e021a9f3654140"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM5MjU2Nw==", "bodyText": "That seems a bit strange to me. I'd find it more intuitive if == and != would work in the same way regardless of right/left positioning of the args.", "url": "https://github.com/elastic/elasticsearch/pull/51901#discussion_r375392567", "createdAt": "2020-02-05T17:15:02Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/analysis/Analyzer.java", "diffHunk": "@@ -42,4 +60,110 @@ private LogicalPlan verify(LogicalPlan plan) {\n         }\n         return plan;\n     }\n+\n+    private static class ReplaceWildcards extends AnalyzeRule<Filter> {\n+\n+        private static boolean isWildcard(Expression expr) {\n+            if (expr instanceof Literal) {\n+                Literal l = (Literal) expr;\n+                if (l.value() instanceof String) {\n+                    String s = (String) l.value();\n+                    return s.contains(\"*\");\n+                }\n+            }\n+\n+            return false;\n+        }\n+\n+        private static LikePattern toLikePattern(String s) {\n+            // pick a character that is guaranteed not to be in the string, because it isn't allowed to escape itself\n+            char escape = 1;\n+\n+            // replace wildcards with % and escape special characters\n+            String likeString = s.replace(\"%\", escape + \"%\")\n+                                 .replace(\"_\", escape + \"_\")\n+                                 .replace(\"*\", \"%\");\n+\n+            return new LikePattern(likeString, escape);\n+        }\n+\n+        @Override\n+        protected LogicalPlan rule(Filter filter) {\n+            return filter.transformExpressionsUp(e -> {\n+                // expr == \"wildcard*phrase\"\n+                if (e instanceof Equals) {\n+                    Equals eq = (Equals) e;\n+\n+                    if (isWildcard(eq.right())) {\n+                        String wcString = (String) ((Literal) eq.right()).value();\n+                        e = new Like(e.source(), eq.left(), toLikePattern(wcString));\n+                    }\n+                }\n+\n+                // expr != \"wildcard*phrase\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE3NjIxMA=="}, "originalCommit": {"oid": "61da57cc693b0a9f3b90ba55d7e021a9f3654140"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQwNzc4MQ==", "bodyText": "if a wildcard string is on the left instead of the right, then it's just a normal, non-wildcard comparison and will check for equality or inequality depending on the operator.\n\nWhich would make == and != non commutative which is a bug.", "url": "https://github.com/elastic/elasticsearch/pull/51901#discussion_r376407781", "createdAt": "2020-02-07T14:08:52Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/analysis/Analyzer.java", "diffHunk": "@@ -42,4 +60,110 @@ private LogicalPlan verify(LogicalPlan plan) {\n         }\n         return plan;\n     }\n+\n+    private static class ReplaceWildcards extends AnalyzeRule<Filter> {\n+\n+        private static boolean isWildcard(Expression expr) {\n+            if (expr instanceof Literal) {\n+                Literal l = (Literal) expr;\n+                if (l.value() instanceof String) {\n+                    String s = (String) l.value();\n+                    return s.contains(\"*\");\n+                }\n+            }\n+\n+            return false;\n+        }\n+\n+        private static LikePattern toLikePattern(String s) {\n+            // pick a character that is guaranteed not to be in the string, because it isn't allowed to escape itself\n+            char escape = 1;\n+\n+            // replace wildcards with % and escape special characters\n+            String likeString = s.replace(\"%\", escape + \"%\")\n+                                 .replace(\"_\", escape + \"_\")\n+                                 .replace(\"*\", \"%\");\n+\n+            return new LikePattern(likeString, escape);\n+        }\n+\n+        @Override\n+        protected LogicalPlan rule(Filter filter) {\n+            return filter.transformExpressionsUp(e -> {\n+                // expr == \"wildcard*phrase\"\n+                if (e instanceof Equals) {\n+                    Equals eq = (Equals) e;\n+\n+                    if (isWildcard(eq.right())) {\n+                        String wcString = (String) ((Literal) eq.right()).value();\n+                        e = new Like(e.source(), eq.left(), toLikePattern(wcString));\n+                    }\n+                }\n+\n+                // expr != \"wildcard*phrase\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE3NjIxMA=="}, "originalCommit": {"oid": "61da57cc693b0a9f3b90ba55d7e021a9f3654140"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMDc1NDA1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/analysis/Analyzer.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxMzowNzowNVrOFl3Cbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxMDo0MzoyNlrOFmWphQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTI0MzM3NA==", "bodyText": "Would be possible to add more tests that also look at scenarios involving escape characters and all types of string that eql supports?\nCan the * be escaped? If so, we should have a test covering this case.", "url": "https://github.com/elastic/elasticsearch/pull/51901#discussion_r375243374", "createdAt": "2020-02-05T13:07:05Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/analysis/Analyzer.java", "diffHunk": "@@ -51,6 +61,60 @@ private LogicalPlan verify(LogicalPlan plan) {\n         return plan;\n     }\n \n+    private static class ReplaceWildcards extends AnalyzeRule<Filter> {\n+\n+        private static boolean isWildcard(Expression expr) {\n+            if (expr instanceof Literal) {\n+                Literal l = (Literal) expr;\n+                if (l.value() instanceof String) {\n+                    String s = (String) l.value();\n+                    return s.contains(\"*\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61da57cc693b0a9f3b90ba55d7e021a9f3654140"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM2MjU4MA==", "bodyText": "yeah, I can add more tests. And there's no escape for *. But if you want to perform an exact (+/- case sensitivity) comparison, you can put the wildcard on the left (#51901 (comment)). Whether this functionality is good or not is a fair question, and I think it's fair to change this because I doubt any users are aware of the workaround.\nfield == \"*wildcard*\" <==> field LIKE \"%wildcard%\"\n\"*wildcard*\" == field <==> field == '*wildcard*'", "url": "https://github.com/elastic/elasticsearch/pull/51901#discussion_r375362580", "createdAt": "2020-02-05T16:25:17Z", "author": {"login": "rw-access"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/analysis/Analyzer.java", "diffHunk": "@@ -51,6 +61,60 @@ private LogicalPlan verify(LogicalPlan plan) {\n         return plan;\n     }\n \n+    private static class ReplaceWildcards extends AnalyzeRule<Filter> {\n+\n+        private static boolean isWildcard(Expression expr) {\n+            if (expr instanceof Literal) {\n+                Literal l = (Literal) expr;\n+                if (l.value() instanceof String) {\n+                    String s = (String) l.value();\n+                    return s.contains(\"*\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTI0MzM3NA=="}, "originalCommit": {"oid": "61da57cc693b0a9f3b90ba55d7e021a9f3654140"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc2MTI4NQ==", "bodyText": "To be honest, I find this more like a bug, rather than feature (that implies an workaround).\nA == B and B == A should be equivalent imo. Equality is not a predicate (like LIKE) where a certain element sits on the right and another one sits on the left and they are not interchangeable.", "url": "https://github.com/elastic/elasticsearch/pull/51901#discussion_r375761285", "createdAt": "2020-02-06T10:43:26Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/analysis/Analyzer.java", "diffHunk": "@@ -51,6 +61,60 @@ private LogicalPlan verify(LogicalPlan plan) {\n         return plan;\n     }\n \n+    private static class ReplaceWildcards extends AnalyzeRule<Filter> {\n+\n+        private static boolean isWildcard(Expression expr) {\n+            if (expr instanceof Literal) {\n+                Literal l = (Literal) expr;\n+                if (l.value() instanceof String) {\n+                    String s = (String) l.value();\n+                    return s.contains(\"*\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTI0MzM3NA=="}, "originalCommit": {"oid": "61da57cc693b0a9f3b90ba55d7e021a9f3654140"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMzAxOTAzOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/optimizer/Optimizer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxOToxNzowN1rOFx6Odg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQyMTo1Njo0NFrOFx_HLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg3ODUxOA==", "bodyText": "The comment seems incorrect as it referred to PropagateEquals", "url": "https://github.com/elastic/elasticsearch/pull/51901#discussion_r387878518", "createdAt": "2020-03-04T19:17:07Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/optimizer/Optimizer.java", "diffHunk": "@@ -33,6 +43,7 @@ public LogicalPlan optimize(LogicalPlan verified) {\n                 new BooleanSimplification(),\n                 new BooleanLiteralsOnTheRight(),\n                 // needs to occur before BinaryComparison combinations", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6f8c397acd2bf199d929d3b54104d6f36140772"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk1ODU3Mw==", "bodyText": "where should ReplaceWildcards() be moved to?", "url": "https://github.com/elastic/elasticsearch/pull/51901#discussion_r387958573", "createdAt": "2020-03-04T21:56:44Z", "author": {"login": "rw-access"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/optimizer/Optimizer.java", "diffHunk": "@@ -33,6 +43,7 @@ public LogicalPlan optimize(LogicalPlan verified) {\n                 new BooleanSimplification(),\n                 new BooleanLiteralsOnTheRight(),\n                 // needs to occur before BinaryComparison combinations", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg3ODUxOA=="}, "originalCommit": {"oid": "d6f8c397acd2bf199d929d3b54104d6f36140772"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMzAyNDQ5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/optimizer/Optimizer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxOToxODo0N1rOFx6SIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQyMTo1NzoxNFrOFx_H-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg3OTQ1OQ==", "bodyText": "Why not 0?", "url": "https://github.com/elastic/elasticsearch/pull/51901#discussion_r387879459", "createdAt": "2020-03-04T19:18:47Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/optimizer/Optimizer.java", "diffHunk": "@@ -45,4 +56,51 @@ public LogicalPlan optimize(LogicalPlan verified) {\n \n         return Arrays.asList(operators, label);\n     }\n+\n+\n+    private static class ReplaceWildcards extends OptimizerRule<Filter> {\n+\n+        private static boolean isWildcard(Expression expr) {\n+            if (expr.foldable()) {\n+                Object value = expr.fold();\n+                return value instanceof String && value.toString().contains(\"*\");\n+            }\n+            return false;\n+        }\n+\n+        private static LikePattern toLikePattern(String s) {\n+            // pick a character that is guaranteed not to be in the string, because it isn't allowed to escape itself\n+            char escape = 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6f8c397acd2bf199d929d3b54104d6f36140772"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk1ODc3Ng==", "bodyText": "Looks like there's explicit handling for \\0\n\n  \n    \n      elasticsearch/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/util/StringUtils.java\n    \n    \n         Line 104\n      in\n      bf317e8\n    \n    \n    \n    \n\n        \n          \n           if (!escaped && (curr == escape) && escape != 0) {", "url": "https://github.com/elastic/elasticsearch/pull/51901#discussion_r387958776", "createdAt": "2020-03-04T21:57:14Z", "author": {"login": "rw-access"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/optimizer/Optimizer.java", "diffHunk": "@@ -45,4 +56,51 @@ public LogicalPlan optimize(LogicalPlan verified) {\n \n         return Arrays.asList(operators, label);\n     }\n+\n+\n+    private static class ReplaceWildcards extends OptimizerRule<Filter> {\n+\n+        private static boolean isWildcard(Expression expr) {\n+            if (expr.foldable()) {\n+                Object value = expr.fold();\n+                return value instanceof String && value.toString().contains(\"*\");\n+            }\n+            return false;\n+        }\n+\n+        private static LikePattern toLikePattern(String s) {\n+            // pick a character that is guaranteed not to be in the string, because it isn't allowed to escape itself\n+            char escape = 1;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg3OTQ1OQ=="}, "originalCommit": {"oid": "d6f8c397acd2bf199d929d3b54104d6f36140772"}, "originalPosition": 51}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4918, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}