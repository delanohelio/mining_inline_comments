{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA3Mzk3NDA0", "number": 55607, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxNjozODo1MlrOD02oXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxNjozODo1MlrOD02oXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NzQ3NjE0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataCreateIndexService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxNjozODo1M1rOGJ_-9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxNjo0OToyN1rOGKAiFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzEzODY3OQ==", "bodyText": "innerTemplateMapping is only used to initialize innerTemplateNonProperties\nWould it make sense for these statements to be executed in reversed order to avoid over allocating innerTemplateNonProperties just to immediately remove \"properties\" ?\nie.\nMap<String, Object> maybeProperties = (Map<String, Object>) innerTemplateMapping.remove(\"properties\");\nMap<String, Object> innerTemplateNonProperties = new HashMap<>(innerTemplateMapping);", "url": "https://github.com/elastic/elasticsearch/pull/55607#discussion_r413138679", "createdAt": "2020-04-22T16:38:53Z", "author": {"login": "andreidan"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataCreateIndexService.java", "diffHunk": "@@ -529,13 +537,76 @@ private ClusterState applyCreateIndexRequestWithExistingMetadata(final ClusterSt\n     }\n \n     /**\n-     * Parses the provided mappings json and the inheritable mappings from the templates (if any) into a map.\n+     * Parses the provided mappings json and the inheritable mappings from the templates (if any)\n+     * into a map.\n      *\n-     * The template mappings are applied in the order they are encountered in the list (clients should make sure the lower index, closer\n-     * to the head of the list, templates have the highest {@link IndexTemplateMetadata#order()})\n+     * The template mappings are applied in the order they are encountered in the list, with the\n+     * caveat that mapping fields are only merged at the top-level, meaning that field settings are\n+     * not merged, instead they replace any previous field definition.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    static Map<String, Object> parseV2Mappings(String mappingsJson, List<CompressedXContent> templateMappings,\n+                                               NamedXContentRegistry xContentRegistry) throws Exception {\n+        Map<String, Object> requestMappings = MapperService.parseMapping(xContentRegistry, mappingsJson);\n+        // apply templates, merging the mappings into the request mapping if exists\n+        Map<String, Object> properties = new HashMap<>();\n+        Map<String, Object> nonProperties = new HashMap<>();\n+        for (CompressedXContent mapping : templateMappings) {\n+            if (mapping != null) {\n+                Map<String, Object> templateMapping = MapperService.parseMapping(xContentRegistry, mapping.string());\n+                if (templateMapping.isEmpty()) {\n+                    // Someone provided an empty '{}' for mappings, which is okay, but to avoid\n+                    // tripping the below assertion, we can safely ignore it\n+                    continue;\n+                }\n+                assert templateMapping.size() == 1 : \"expected exactly one mapping value, got: \" + templateMapping;\n+                if (templateMapping.get(MapperService.SINGLE_MAPPING_NAME) instanceof Map == false) {\n+                    throw new IllegalStateException(\"invalid mapping definition, expected a single map underneath [\" +\n+                        MapperService.SINGLE_MAPPING_NAME + \"] but it was: [\" + templateMapping + \"]\");\n+                }\n+\n+                Map<String, Object> innerTemplateMapping = (Map<String, Object>) templateMapping.get(MapperService.SINGLE_MAPPING_NAME);\n+                Map<String, Object> innerTemplateNonProperties = new HashMap<>(innerTemplateMapping);\n+                Map<String, Object> maybeProperties = (Map<String, Object>) innerTemplateNonProperties.remove(\"properties\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "890db88d04254e8de43a515d7efdb0e02b19f7e4"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE0NzY2OA==", "bodyText": "Ah, ignore this actually, as we'd be modifying a map we didn't create. It's fine as it is", "url": "https://github.com/elastic/elasticsearch/pull/55607#discussion_r413147668", "createdAt": "2020-04-22T16:49:27Z", "author": {"login": "andreidan"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataCreateIndexService.java", "diffHunk": "@@ -529,13 +537,76 @@ private ClusterState applyCreateIndexRequestWithExistingMetadata(final ClusterSt\n     }\n \n     /**\n-     * Parses the provided mappings json and the inheritable mappings from the templates (if any) into a map.\n+     * Parses the provided mappings json and the inheritable mappings from the templates (if any)\n+     * into a map.\n      *\n-     * The template mappings are applied in the order they are encountered in the list (clients should make sure the lower index, closer\n-     * to the head of the list, templates have the highest {@link IndexTemplateMetadata#order()})\n+     * The template mappings are applied in the order they are encountered in the list, with the\n+     * caveat that mapping fields are only merged at the top-level, meaning that field settings are\n+     * not merged, instead they replace any previous field definition.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    static Map<String, Object> parseV2Mappings(String mappingsJson, List<CompressedXContent> templateMappings,\n+                                               NamedXContentRegistry xContentRegistry) throws Exception {\n+        Map<String, Object> requestMappings = MapperService.parseMapping(xContentRegistry, mappingsJson);\n+        // apply templates, merging the mappings into the request mapping if exists\n+        Map<String, Object> properties = new HashMap<>();\n+        Map<String, Object> nonProperties = new HashMap<>();\n+        for (CompressedXContent mapping : templateMappings) {\n+            if (mapping != null) {\n+                Map<String, Object> templateMapping = MapperService.parseMapping(xContentRegistry, mapping.string());\n+                if (templateMapping.isEmpty()) {\n+                    // Someone provided an empty '{}' for mappings, which is okay, but to avoid\n+                    // tripping the below assertion, we can safely ignore it\n+                    continue;\n+                }\n+                assert templateMapping.size() == 1 : \"expected exactly one mapping value, got: \" + templateMapping;\n+                if (templateMapping.get(MapperService.SINGLE_MAPPING_NAME) instanceof Map == false) {\n+                    throw new IllegalStateException(\"invalid mapping definition, expected a single map underneath [\" +\n+                        MapperService.SINGLE_MAPPING_NAME + \"] but it was: [\" + templateMapping + \"]\");\n+                }\n+\n+                Map<String, Object> innerTemplateMapping = (Map<String, Object>) templateMapping.get(MapperService.SINGLE_MAPPING_NAME);\n+                Map<String, Object> innerTemplateNonProperties = new HashMap<>(innerTemplateMapping);\n+                Map<String, Object> maybeProperties = (Map<String, Object>) innerTemplateNonProperties.remove(\"properties\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzEzODY3OQ=="}, "originalCommit": {"oid": "890db88d04254e8de43a515d7efdb0e02b19f7e4"}, "originalPosition": 72}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2815, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}