{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg1NDUyNzYz", "number": 62275, "title": "Make some Allocation Decider Code a Little More JIT Aware", "bodyText": "When investigating our code cache usage for another issue I ran into this. This PR just fixes a few spots and there's many more. The current way we compute the decisions often creates much larger than necessary methods because the compiler has no efficient way of optimizing away things like using CLUSTER_ROUTING_ALLOCATION_AWARENESS_ATTRIBUTE_SETTING.getKey() as an explain parameter that do allocations (but whose results are thrown away immediately if debug is off).\nAs a result e.g.  the max retry allocation decider's canAllocate compiles into an 18kb method before and into a 2kb method after this change (at C1 L3). I think if we're a little more mindful of the JIT here we can get some measurable speedups out of the allocation deciders logic. Plus, this kind of change saves quite a few in allocations in isolation as well which is always nice on a hot CS thread I suppose.", "createdAt": "2020-09-11T20:56:34Z", "url": "https://github.com/elastic/elasticsearch/pull/62275", "merged": true, "mergeCommit": {"oid": "0ed5174cb870c4d6be23c7820513cbdb3cf0ecb8"}, "closed": true, "closedAt": "2020-10-30T17:30:42Z", "author": {"login": "original-brownbear"}, "timelineItems": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdH7RYEgH2gAyNDg1NDUyNzYzOmU1M2ZiZjBhZmFkZjFjMjhkM2MwODM5ZTZlZmY3YjU4NTg1YmM0YjE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdXpF-wAH2gAyNDg1NDUyNzYzOjc2NTg1MGMzYmVkNmZiZGI3ZTg4NDhkZTk2ZjYwNDY1NzBiOWQxMjY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "e53fbf0afadf1c28d3c0839e6eff7b58585bc4b1", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/e53fbf0afadf1c28d3c0839e6eff7b58585bc4b1", "committedDate": "2020-09-11T20:18:05Z", "message": "much nicer"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ad98bd5c5d4c7d16de416fa4b79a0a6cb6b24421", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/ad98bd5c5d4c7d16de416fa4b79a0a6cb6b24421", "committedDate": "2020-09-13T19:47:01Z", "message": "Merge remote-tracking branch 'elastic/master' into fix-some-expensive-stuff"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "99019b353fa4bc462a92a5b1cdc1b834c469319b", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/99019b353fa4bc462a92a5b1cdc1b834c469319b", "committedDate": "2020-09-14T08:09:22Z", "message": "Merge remote-tracking branch 'elastic/master' into fix-some-expensive-stuff"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3NjM5NjIx", "url": "https://github.com/elastic/elasticsearch/pull/62275#pullrequestreview-487639621", "createdAt": "2020-09-14T10:55:38Z", "commit": {"oid": "99019b353fa4bc462a92a5b1cdc1b834c469319b"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMDo1NTozOFrOHRObDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMTo1MToyNFrOHRQIKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzgyNDE0Mg==", "bodyText": "Is there a reason we cannot just always return NO_UNASSIGNED_PRIMARIES? Looks like we can avoid the dependency on debug in this method.", "url": "https://github.com/elastic/elasticsearch/pull/62275#discussion_r487824142", "createdAt": "2020-09-14T10:55:38Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/ClusterRebalanceAllocationDecider.java", "diffHunk": "@@ -109,40 +110,53 @@ public Decision canRebalance(ShardRouting shardRouting, RoutingAllocation alloca\n         return canRebalance(allocation);\n     }\n \n+    private static final Decision YES_ALL_PRIMARIES_ACTIVE = Decision.single(Decision.Type.YES, NAME, \"all primary shards are active\");\n+\n+    private static final Decision YES_ALL_SHARDS_ACTIVE = Decision.single(Decision.Type.YES, NAME, \"all shards are active\");\n+\n+    private static final Decision NO_UNASSIGNED_PRIMARIES = Decision.single(Decision.Type.NO, NAME,\n+            \"the cluster has unassigned primary shards and cluster setting [\"\n+                    + CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE + \"] is set to [\" + ClusterRebalanceType.INDICES_PRIMARIES_ACTIVE + \"]\");\n+\n+    private static final Decision NO_INACTIVE_PRIMARIES = Decision.single(Decision.Type.NO, NAME,\n+            \"the cluster has inactive primary shards and cluster setting [\" + CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE +\n+                    \"] is set to [\" + ClusterRebalanceType.INDICES_PRIMARIES_ACTIVE + \"]\");\n+\n+    private static final Decision NO_UNASSIGNED_SHARDS = Decision.single(Decision.Type.NO, NAME,\n+            \"the cluster has unassigned shards and cluster setting [\" + CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE +\n+                    \"] is set to [\" + ClusterRebalanceType.INDICES_ALL_ACTIVE + \"]\");\n+\n+    private static final Decision NO_INACTIVE_SHARDS = Decision.single(Decision.Type.NO, NAME,\n+            \"the cluster has inactive shards and cluster setting [\" + CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE +\n+                    \"] is set to [\" + ClusterRebalanceType.INDICES_ALL_ACTIVE + \"]\");\n+\n     @Override\n     public Decision canRebalance(RoutingAllocation allocation) {\n-        if (type == ClusterRebalanceType.INDICES_PRIMARIES_ACTIVE) {\n-            // check if there are unassigned primaries.\n-            if ( allocation.routingNodes().hasUnassignedPrimaries() ) {\n-                return allocation.decision(Decision.NO, NAME,\n-                        \"the cluster has unassigned primary shards and cluster setting [%s] is set to [%s]\",\n-                        CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE, type);\n-            }\n-            // check if there are initializing primaries that don't have a relocatingNodeId entry.\n-            if ( allocation.routingNodes().hasInactivePrimaries() ) {\n-                return allocation.decision(Decision.NO, NAME,\n-                        \"the cluster has inactive primary shards and cluster setting [%s] is set to [%s]\",\n-                        CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE, type);\n-            }\n-\n-            return allocation.decision(Decision.YES, NAME, \"all primary shards are active\");\n-        }\n-        if (type == ClusterRebalanceType.INDICES_ALL_ACTIVE) {\n-            // check if there are unassigned shards.\n-            if (allocation.routingNodes().hasUnassignedShards() ) {\n-                return allocation.decision(Decision.NO, NAME,\n-                        \"the cluster has unassigned shards and cluster setting [%s] is set to [%s]\",\n-                        CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE, type);\n-            }\n-            // in case all indices are assigned, are there initializing shards which\n-            // are not relocating?\n-            if ( allocation.routingNodes().hasInactiveShards() ) {\n-                return allocation.decision(Decision.NO, NAME,\n-                        \"the cluster has inactive shards and cluster setting [%s] is set to [%s]\",\n-                        CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE, type);\n-            }\n+        final boolean debug = allocation.debugDecision();\n+        final RoutingNodes routingNodes = allocation.routingNodes();\n+        switch (type) {\n+            case INDICES_PRIMARIES_ACTIVE:\n+                // check if there are unassigned primaries.\n+                if (routingNodes.hasUnassignedPrimaries()) {\n+                    return debug ? NO_UNASSIGNED_PRIMARIES : Decision.NO;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99019b353fa4bc462a92a5b1cdc1b834c469319b"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzgyNTM4MQ==", "bodyText": "Add\n// fall-through\nto signal that fall through is intended.", "url": "https://github.com/elastic/elasticsearch/pull/62275#discussion_r487825381", "createdAt": "2020-09-14T10:58:07Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/ClusterRebalanceAllocationDecider.java", "diffHunk": "@@ -109,40 +110,53 @@ public Decision canRebalance(ShardRouting shardRouting, RoutingAllocation alloca\n         return canRebalance(allocation);\n     }\n \n+    private static final Decision YES_ALL_PRIMARIES_ACTIVE = Decision.single(Decision.Type.YES, NAME, \"all primary shards are active\");\n+\n+    private static final Decision YES_ALL_SHARDS_ACTIVE = Decision.single(Decision.Type.YES, NAME, \"all shards are active\");\n+\n+    private static final Decision NO_UNASSIGNED_PRIMARIES = Decision.single(Decision.Type.NO, NAME,\n+            \"the cluster has unassigned primary shards and cluster setting [\"\n+                    + CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE + \"] is set to [\" + ClusterRebalanceType.INDICES_PRIMARIES_ACTIVE + \"]\");\n+\n+    private static final Decision NO_INACTIVE_PRIMARIES = Decision.single(Decision.Type.NO, NAME,\n+            \"the cluster has inactive primary shards and cluster setting [\" + CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE +\n+                    \"] is set to [\" + ClusterRebalanceType.INDICES_PRIMARIES_ACTIVE + \"]\");\n+\n+    private static final Decision NO_UNASSIGNED_SHARDS = Decision.single(Decision.Type.NO, NAME,\n+            \"the cluster has unassigned shards and cluster setting [\" + CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE +\n+                    \"] is set to [\" + ClusterRebalanceType.INDICES_ALL_ACTIVE + \"]\");\n+\n+    private static final Decision NO_INACTIVE_SHARDS = Decision.single(Decision.Type.NO, NAME,\n+            \"the cluster has inactive shards and cluster setting [\" + CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE +\n+                    \"] is set to [\" + ClusterRebalanceType.INDICES_ALL_ACTIVE + \"]\");\n+\n     @Override\n     public Decision canRebalance(RoutingAllocation allocation) {\n-        if (type == ClusterRebalanceType.INDICES_PRIMARIES_ACTIVE) {\n-            // check if there are unassigned primaries.\n-            if ( allocation.routingNodes().hasUnassignedPrimaries() ) {\n-                return allocation.decision(Decision.NO, NAME,\n-                        \"the cluster has unassigned primary shards and cluster setting [%s] is set to [%s]\",\n-                        CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE, type);\n-            }\n-            // check if there are initializing primaries that don't have a relocatingNodeId entry.\n-            if ( allocation.routingNodes().hasInactivePrimaries() ) {\n-                return allocation.decision(Decision.NO, NAME,\n-                        \"the cluster has inactive primary shards and cluster setting [%s] is set to [%s]\",\n-                        CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE, type);\n-            }\n-\n-            return allocation.decision(Decision.YES, NAME, \"all primary shards are active\");\n-        }\n-        if (type == ClusterRebalanceType.INDICES_ALL_ACTIVE) {\n-            // check if there are unassigned shards.\n-            if (allocation.routingNodes().hasUnassignedShards() ) {\n-                return allocation.decision(Decision.NO, NAME,\n-                        \"the cluster has unassigned shards and cluster setting [%s] is set to [%s]\",\n-                        CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE, type);\n-            }\n-            // in case all indices are assigned, are there initializing shards which\n-            // are not relocating?\n-            if ( allocation.routingNodes().hasInactiveShards() ) {\n-                return allocation.decision(Decision.NO, NAME,\n-                        \"the cluster has inactive shards and cluster setting [%s] is set to [%s]\",\n-                        CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE, type);\n-            }\n+        final boolean debug = allocation.debugDecision();\n+        final RoutingNodes routingNodes = allocation.routingNodes();\n+        switch (type) {\n+            case INDICES_PRIMARIES_ACTIVE:\n+                // check if there are unassigned primaries.\n+                if (routingNodes.hasUnassignedPrimaries()) {\n+                    return debug ? NO_UNASSIGNED_PRIMARIES : Decision.NO;\n+                }\n+                // check if there are initializing primaries that don't have a relocatingNodeId entry.\n+                if (routingNodes.hasInactivePrimaries()) {\n+                    return debug ? NO_INACTIVE_PRIMARIES : Decision.NO;\n+                }\n+                return debug ? YES_ALL_PRIMARIES_ACTIVE : Decision.YES;\n+            case INDICES_ALL_ACTIVE:\n+                // check if there are unassigned shards.\n+                if (routingNodes.hasUnassignedShards()) {\n+                    return debug ? NO_UNASSIGNED_SHARDS : Decision.NO;\n+                }\n+                // in case all indices are assigned, are there initializing shards which\n+                // are not relocating?\n+                if (routingNodes.hasInactiveShards()) {\n+                    return debug ? NO_INACTIVE_SHARDS : Decision.NO;\n+                }\n         }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99019b353fa4bc462a92a5b1cdc1b834c469319b"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzgyNTcyNw==", "bodyText": "I wonder if this fits better into the switch now in a default block?", "url": "https://github.com/elastic/elasticsearch/pull/62275#discussion_r487825727", "createdAt": "2020-09-14T10:58:46Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/ClusterRebalanceAllocationDecider.java", "diffHunk": "@@ -109,40 +110,53 @@ public Decision canRebalance(ShardRouting shardRouting, RoutingAllocation alloca\n         return canRebalance(allocation);\n     }\n \n+    private static final Decision YES_ALL_PRIMARIES_ACTIVE = Decision.single(Decision.Type.YES, NAME, \"all primary shards are active\");\n+\n+    private static final Decision YES_ALL_SHARDS_ACTIVE = Decision.single(Decision.Type.YES, NAME, \"all shards are active\");\n+\n+    private static final Decision NO_UNASSIGNED_PRIMARIES = Decision.single(Decision.Type.NO, NAME,\n+            \"the cluster has unassigned primary shards and cluster setting [\"\n+                    + CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE + \"] is set to [\" + ClusterRebalanceType.INDICES_PRIMARIES_ACTIVE + \"]\");\n+\n+    private static final Decision NO_INACTIVE_PRIMARIES = Decision.single(Decision.Type.NO, NAME,\n+            \"the cluster has inactive primary shards and cluster setting [\" + CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE +\n+                    \"] is set to [\" + ClusterRebalanceType.INDICES_PRIMARIES_ACTIVE + \"]\");\n+\n+    private static final Decision NO_UNASSIGNED_SHARDS = Decision.single(Decision.Type.NO, NAME,\n+            \"the cluster has unassigned shards and cluster setting [\" + CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE +\n+                    \"] is set to [\" + ClusterRebalanceType.INDICES_ALL_ACTIVE + \"]\");\n+\n+    private static final Decision NO_INACTIVE_SHARDS = Decision.single(Decision.Type.NO, NAME,\n+            \"the cluster has inactive shards and cluster setting [\" + CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE +\n+                    \"] is set to [\" + ClusterRebalanceType.INDICES_ALL_ACTIVE + \"]\");\n+\n     @Override\n     public Decision canRebalance(RoutingAllocation allocation) {\n-        if (type == ClusterRebalanceType.INDICES_PRIMARIES_ACTIVE) {\n-            // check if there are unassigned primaries.\n-            if ( allocation.routingNodes().hasUnassignedPrimaries() ) {\n-                return allocation.decision(Decision.NO, NAME,\n-                        \"the cluster has unassigned primary shards and cluster setting [%s] is set to [%s]\",\n-                        CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE, type);\n-            }\n-            // check if there are initializing primaries that don't have a relocatingNodeId entry.\n-            if ( allocation.routingNodes().hasInactivePrimaries() ) {\n-                return allocation.decision(Decision.NO, NAME,\n-                        \"the cluster has inactive primary shards and cluster setting [%s] is set to [%s]\",\n-                        CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE, type);\n-            }\n-\n-            return allocation.decision(Decision.YES, NAME, \"all primary shards are active\");\n-        }\n-        if (type == ClusterRebalanceType.INDICES_ALL_ACTIVE) {\n-            // check if there are unassigned shards.\n-            if (allocation.routingNodes().hasUnassignedShards() ) {\n-                return allocation.decision(Decision.NO, NAME,\n-                        \"the cluster has unassigned shards and cluster setting [%s] is set to [%s]\",\n-                        CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE, type);\n-            }\n-            // in case all indices are assigned, are there initializing shards which\n-            // are not relocating?\n-            if ( allocation.routingNodes().hasInactiveShards() ) {\n-                return allocation.decision(Decision.NO, NAME,\n-                        \"the cluster has inactive shards and cluster setting [%s] is set to [%s]\",\n-                        CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE, type);\n-            }\n+        final boolean debug = allocation.debugDecision();\n+        final RoutingNodes routingNodes = allocation.routingNodes();\n+        switch (type) {\n+            case INDICES_PRIMARIES_ACTIVE:\n+                // check if there are unassigned primaries.\n+                if (routingNodes.hasUnassignedPrimaries()) {\n+                    return debug ? NO_UNASSIGNED_PRIMARIES : Decision.NO;\n+                }\n+                // check if there are initializing primaries that don't have a relocatingNodeId entry.\n+                if (routingNodes.hasInactivePrimaries()) {\n+                    return debug ? NO_INACTIVE_PRIMARIES : Decision.NO;\n+                }\n+                return debug ? YES_ALL_PRIMARIES_ACTIVE : Decision.YES;\n+            case INDICES_ALL_ACTIVE:\n+                // check if there are unassigned shards.\n+                if (routingNodes.hasUnassignedShards()) {\n+                    return debug ? NO_UNASSIGNED_SHARDS : Decision.NO;\n+                }\n+                // in case all indices are assigned, are there initializing shards which\n+                // are not relocating?\n+                if (routingNodes.hasInactiveShards()) {\n+                    return debug ? NO_INACTIVE_SHARDS : Decision.NO;\n+                }\n         }\n-        // type == Type.ALWAYS\n-        return allocation.decision(Decision.YES, NAME, \"all shards are active\");\n+        // all shards active from above or type == Type.ALWAYS", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99019b353fa4bc462a92a5b1cdc1b834c469319b"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg1MTI3MQ==", "bodyText": "Rather than inline the debug flag switch, would it be possible to use a supplier-style (perhaps a function, depending on input) just like is done for logging? So that it would be either:\nallocation.decision(Decision.NO, NAME, \"......[%d]...[%s]\", a -> a.args(maxRetry, unassignedInfo.toString()))\n\nor\nallocation.decision(Decision.NO, NAME, res -> debugDecision(res, unassignedInfo, numFailedAllcations, maxRetry))", "url": "https://github.com/elastic/elasticsearch/pull/62275#discussion_r487851271", "createdAt": "2020-09-14T11:49:52Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/MaxRetryAllocationDecider.java", "diffHunk": "@@ -41,27 +41,36 @@\n \n     public static final String NAME = \"max_retry\";\n \n+    private static final Decision YES_NO_FAILURES = Decision.single(Decision.Type.YES, NAME, \"shard has no previous failures\");\n+\n     @Override\n     public Decision canAllocate(ShardRouting shardRouting, RoutingAllocation allocation) {\n         final UnassignedInfo unassignedInfo = shardRouting.unassignedInfo();\n         final Decision decision;\n-        if (unassignedInfo != null && unassignedInfo.getNumFailedAllocations() > 0) {\n+        final boolean debug = allocation.debugDecision();\n+        final int numFailedAllocations = unassignedInfo == null ? 0 : unassignedInfo.getNumFailedAllocations();\n+        if (numFailedAllocations > 0) {\n             final IndexMetadata indexMetadata = allocation.metadata().getIndexSafe(shardRouting.index());\n             final int maxRetry = SETTING_ALLOCATION_MAX_RETRY.get(indexMetadata.getSettings());\n-            if (unassignedInfo.getNumFailedAllocations() >= maxRetry) {\n-                decision = allocation.decision(Decision.NO, NAME, \"shard has exceeded the maximum number of retries [%d] on \" +\n-                    \"failed allocation attempts - manually call [/_cluster/reroute?retry_failed=true] to retry, [%s]\",\n-                    maxRetry, unassignedInfo.toString());\n-            } else {\n-                decision = allocation.decision(Decision.YES, NAME, \"shard has failed allocating [%d] times but [%d] retries are allowed\",\n-                    unassignedInfo.getNumFailedAllocations(), maxRetry);\n-            }\n+            final Decision res = numFailedAllocations >= maxRetry ? Decision.NO : Decision.YES;\n+            decision = debug ? debugDecision(res, unassignedInfo, numFailedAllocations, maxRetry) : res;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99019b353fa4bc462a92a5b1cdc1b834c469319b"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg1MTc0Mg==", "bodyText": "I wonder if it was just as good (or better) to just extract the non-happy path here out into a method of its own?", "url": "https://github.com/elastic/elasticsearch/pull/62275#discussion_r487851742", "createdAt": "2020-09-14T11:50:44Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/MaxRetryAllocationDecider.java", "diffHunk": "@@ -41,27 +41,36 @@\n \n     public static final String NAME = \"max_retry\";\n \n+    private static final Decision YES_NO_FAILURES = Decision.single(Decision.Type.YES, NAME, \"shard has no previous failures\");\n+\n     @Override\n     public Decision canAllocate(ShardRouting shardRouting, RoutingAllocation allocation) {\n         final UnassignedInfo unassignedInfo = shardRouting.unassignedInfo();\n         final Decision decision;\n-        if (unassignedInfo != null && unassignedInfo.getNumFailedAllocations() > 0) {\n+        final boolean debug = allocation.debugDecision();\n+        final int numFailedAllocations = unassignedInfo == null ? 0 : unassignedInfo.getNumFailedAllocations();\n+        if (numFailedAllocations > 0) {\n             final IndexMetadata indexMetadata = allocation.metadata().getIndexSafe(shardRouting.index());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99019b353fa4bc462a92a5b1cdc1b834c469319b"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg1MjA3NQ==", "bodyText": "I am not sure we need to switch on debug for purely constant decisions?", "url": "https://github.com/elastic/elasticsearch/pull/62275#discussion_r487852075", "createdAt": "2020-09-14T11:51:24Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/MaxRetryAllocationDecider.java", "diffHunk": "@@ -41,27 +41,36 @@\n \n     public static final String NAME = \"max_retry\";\n \n+    private static final Decision YES_NO_FAILURES = Decision.single(Decision.Type.YES, NAME, \"shard has no previous failures\");\n+\n     @Override\n     public Decision canAllocate(ShardRouting shardRouting, RoutingAllocation allocation) {\n         final UnassignedInfo unassignedInfo = shardRouting.unassignedInfo();\n         final Decision decision;\n-        if (unassignedInfo != null && unassignedInfo.getNumFailedAllocations() > 0) {\n+        final boolean debug = allocation.debugDecision();\n+        final int numFailedAllocations = unassignedInfo == null ? 0 : unassignedInfo.getNumFailedAllocations();\n+        if (numFailedAllocations > 0) {\n             final IndexMetadata indexMetadata = allocation.metadata().getIndexSafe(shardRouting.index());\n             final int maxRetry = SETTING_ALLOCATION_MAX_RETRY.get(indexMetadata.getSettings());\n-            if (unassignedInfo.getNumFailedAllocations() >= maxRetry) {\n-                decision = allocation.decision(Decision.NO, NAME, \"shard has exceeded the maximum number of retries [%d] on \" +\n-                    \"failed allocation attempts - manually call [/_cluster/reroute?retry_failed=true] to retry, [%s]\",\n-                    maxRetry, unassignedInfo.toString());\n-            } else {\n-                decision = allocation.decision(Decision.YES, NAME, \"shard has failed allocating [%d] times but [%d] retries are allowed\",\n-                    unassignedInfo.getNumFailedAllocations(), maxRetry);\n-            }\n+            final Decision res = numFailedAllocations >= maxRetry ? Decision.NO : Decision.YES;\n+            decision = debug ? debugDecision(res, unassignedInfo, numFailedAllocations, maxRetry) : res;\n         } else {\n-            decision = allocation.decision(Decision.YES, NAME, \"shard has no previous failures\");\n+            decision = debug ? YES_NO_FAILURES : Decision.YES;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99019b353fa4bc462a92a5b1cdc1b834c469319b"}, "originalPosition": 28}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6e772a0327072fff62e7fb11b212d18b86b0b7db", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/6e772a0327072fff62e7fb11b212d18b86b0b7db", "committedDate": "2020-09-14T13:25:37Z", "message": "CR comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkxNDc2NDMx", "url": "https://github.com/elastic/elasticsearch/pull/62275#pullrequestreview-491476431", "createdAt": "2020-09-18T13:42:46Z", "commit": {"oid": "6e772a0327072fff62e7fb11b212d18b86b0b7db"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxMzo0Mjo0N1rOHUNspQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxNDowNDowNFrOHUOkLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk1Nzk4OQ==", "bodyText": "I think it would be nice to add Decision.constant that still uses Decision.Single but avoids the trap of being able to specify parameters (or eagerly resolves the string if anyone do specify them).", "url": "https://github.com/elastic/elasticsearch/pull/62275#discussion_r490957989", "createdAt": "2020-09-18T13:42:47Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/ClusterRebalanceAllocationDecider.java", "diffHunk": "@@ -109,40 +110,55 @@ public Decision canRebalance(ShardRouting shardRouting, RoutingAllocation alloca\n         return canRebalance(allocation);\n     }\n \n+    private static final Decision YES_ALL_PRIMARIES_ACTIVE = Decision.single(Decision.Type.YES, NAME, \"all primary shards are active\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e772a0327072fff62e7fb11b212d18b86b0b7db"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk1OTU1Nw==", "bodyText": "Maybe remove this variable that it is only used once?", "url": "https://github.com/elastic/elasticsearch/pull/62275#discussion_r490959557", "createdAt": "2020-09-18T13:45:07Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/SameShardAllocationDecider.java", "diffHunk": "@@ -75,6 +78,7 @@ public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, Routing\n             return decision;\n         }\n         if (node.node() != null) {\n+            final boolean debug = allocation.debugDecision();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e772a0327072fff62e7fb11b212d18b86b0b7db"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk3MjIwNA==", "bodyText": "In AllocationDeciders we choose to early terminate no decisions, but only if the object is Decision.NO. I think we need to change that to check the underlying type if we return constants here.", "url": "https://github.com/elastic/elasticsearch/pull/62275#discussion_r490972204", "createdAt": "2020-09-18T14:04:04Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/ClusterRebalanceAllocationDecider.java", "diffHunk": "@@ -109,40 +110,55 @@ public Decision canRebalance(ShardRouting shardRouting, RoutingAllocation alloca\n         return canRebalance(allocation);\n     }\n \n+    private static final Decision YES_ALL_PRIMARIES_ACTIVE = Decision.single(Decision.Type.YES, NAME, \"all primary shards are active\");\n+\n+    private static final Decision YES_ALL_SHARDS_ACTIVE = Decision.single(Decision.Type.YES, NAME, \"all shards are active\");\n+\n+    private static final Decision NO_UNASSIGNED_PRIMARIES = Decision.single(Decision.Type.NO, NAME,\n+            \"the cluster has unassigned primary shards and cluster setting [\"\n+                    + CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE + \"] is set to [\" + ClusterRebalanceType.INDICES_PRIMARIES_ACTIVE + \"]\");\n+\n+    private static final Decision NO_INACTIVE_PRIMARIES = Decision.single(Decision.Type.NO, NAME,\n+            \"the cluster has inactive primary shards and cluster setting [\" + CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE +\n+                    \"] is set to [\" + ClusterRebalanceType.INDICES_PRIMARIES_ACTIVE + \"]\");\n+\n+    private static final Decision NO_UNASSIGNED_SHARDS = Decision.single(Decision.Type.NO, NAME,\n+            \"the cluster has unassigned shards and cluster setting [\" + CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE +\n+                    \"] is set to [\" + ClusterRebalanceType.INDICES_ALL_ACTIVE + \"]\");\n+\n+    private static final Decision NO_INACTIVE_SHARDS = Decision.single(Decision.Type.NO, NAME,\n+            \"the cluster has inactive shards and cluster setting [\" + CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE +\n+                    \"] is set to [\" + ClusterRebalanceType.INDICES_ALL_ACTIVE + \"]\");\n+\n+    @SuppressWarnings(\"fallthrough\")\n     @Override\n     public Decision canRebalance(RoutingAllocation allocation) {\n-        if (type == ClusterRebalanceType.INDICES_PRIMARIES_ACTIVE) {\n-            // check if there are unassigned primaries.\n-            if ( allocation.routingNodes().hasUnassignedPrimaries() ) {\n-                return allocation.decision(Decision.NO, NAME,\n-                        \"the cluster has unassigned primary shards and cluster setting [%s] is set to [%s]\",\n-                        CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE, type);\n-            }\n-            // check if there are initializing primaries that don't have a relocatingNodeId entry.\n-            if ( allocation.routingNodes().hasInactivePrimaries() ) {\n-                return allocation.decision(Decision.NO, NAME,\n-                        \"the cluster has inactive primary shards and cluster setting [%s] is set to [%s]\",\n-                        CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE, type);\n-            }\n-\n-            return allocation.decision(Decision.YES, NAME, \"all primary shards are active\");\n-        }\n-        if (type == ClusterRebalanceType.INDICES_ALL_ACTIVE) {\n-            // check if there are unassigned shards.\n-            if (allocation.routingNodes().hasUnassignedShards() ) {\n-                return allocation.decision(Decision.NO, NAME,\n-                        \"the cluster has unassigned shards and cluster setting [%s] is set to [%s]\",\n-                        CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE, type);\n-            }\n-            // in case all indices are assigned, are there initializing shards which\n-            // are not relocating?\n-            if ( allocation.routingNodes().hasInactiveShards() ) {\n-                return allocation.decision(Decision.NO, NAME,\n-                        \"the cluster has inactive shards and cluster setting [%s] is set to [%s]\",\n-                        CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE, type);\n-            }\n+        final RoutingNodes routingNodes = allocation.routingNodes();\n+        switch (type) {\n+            case INDICES_PRIMARIES_ACTIVE:\n+                // check if there are unassigned primaries.\n+                if (routingNodes.hasUnassignedPrimaries()) {\n+                    return NO_UNASSIGNED_PRIMARIES;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e772a0327072fff62e7fb11b212d18b86b0b7db"}, "originalPosition": 70}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7ef2fc712f9e7328df723d766aba14a5a8db5179", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/7ef2fc712f9e7328df723d766aba14a5a8db5179", "committedDate": "2020-09-18T15:03:03Z", "message": "Merge remote-tracking branch 'elastic/master' into fix-some-expensive-stuff"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1f811c81d764fb9f916ae48dd144367cf6c1de75", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/1f811c81d764fb9f916ae48dd144367cf6c1de75", "committedDate": "2020-09-18T15:39:02Z", "message": "remove redundant var + improve no check"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6bd66082f5121ca32025b2fd465b8064a0daa804", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/6bd66082f5121ca32025b2fd465b8064a0daa804", "committedDate": "2020-09-18T16:01:10Z", "message": "no more layy explain string"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8a59791711df64248ce2d2dc153fc5ab2d98479a", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/8a59791711df64248ce2d2dc153fc5ab2d98479a", "committedDate": "2020-10-29T08:57:57Z", "message": "Merge remote-tracking branch 'elastic/master' into fix-some-expensive-stuff"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwNTg2NzY0", "url": "https://github.com/elastic/elasticsearch/pull/62275#pullrequestreview-520586764", "createdAt": "2020-10-30T11:35:58Z", "commit": {"oid": "8a59791711df64248ce2d2dc153fc5ab2d98479a"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMTozNTo1OFrOHrLSDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMTo0MToyMlrOHrLdTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAzNTY2MQ==", "bodyText": "Is there a reason for not using [%s] for the settings key?", "url": "https://github.com/elastic/elasticsearch/pull/62275#discussion_r515035661", "createdAt": "2020-10-30T11:35:58Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/AwarenessAllocationDecider.java", "diffHunk": "@@ -185,18 +188,31 @@ private Decision underCapacity(ShardRouting shardRouting, RoutingNode node, Rout\n             final int currentNodeCount = shardPerAttribute.get(node.node().getAttributes().get(awarenessAttribute));\n             final int maximumNodeCount = (shardCount + numberOfAttributes - 1) / numberOfAttributes; // ceil(shardCount/numberOfAttributes)\n             if (currentNodeCount > maximumNodeCount) {\n-                return allocation.decision(Decision.NO, NAME,\n-                        \"there are too many copies of the shard allocated to nodes with attribute [%s], there are [%d] total configured \" +\n-                        \"shard copies for this shard id and [%d] total attribute values, expected the allocated shard count per \" +\n-                        \"attribute [%d] to be less than or equal to the upper bound of the required number of shards per attribute [%d]\",\n-                        awarenessAttribute,\n-                        shardCount,\n-                        numberOfAttributes,\n-                        currentNodeCount,\n-                        maximumNodeCount);\n+                return debug ? debugNoTooManyCopies(shardCount, awarenessAttribute, numberOfAttributes, currentNodeCount, maximumNodeCount)\n+                        : Decision.NO;\n             }\n         }\n \n-        return allocation.decision(Decision.YES, NAME, \"node meets all awareness attribute requirements\");\n+        return YES_ALL_MET;\n+    }\n+\n+    private static Decision debugNoTooManyCopies(int shardCount, String awarenessAttribute, int numberOfAttributes, int currentNodeCount,\n+                                                 int maximumNodeCount) {\n+        return Decision.single(Decision.Type.NO, NAME,\n+                \"there are too many copies of the shard allocated to nodes with attribute [%s], there are [%d] total configured \" +\n+                        \"shard copies for this shard id and [%d] total attribute values, expected the allocated shard count per \" +\n+                        \"attribute [%d] to be less than or equal to the upper bound of the required number of shards per attribute [%d]\",\n+                awarenessAttribute,\n+                shardCount,\n+                numberOfAttributes,\n+                currentNodeCount,\n+                maximumNodeCount);\n+    }\n+\n+    private static Decision debugNoMissingAttribute(String awarenessAttribute, List<String> awarenessAttributes) {\n+        return Decision.single(Decision.Type.NO, NAME,\n+                \"node does not contain the awareness attribute [%s]; required attributes cluster setting [\"\n+                        + CLUSTER_ROUTING_ALLOCATION_AWARENESS_ATTRIBUTE_SETTING.getKey() + \"=%s]\", awarenessAttribute,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a59791711df64248ce2d2dc153fc5ab2d98479a"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAzODU0Mg==", "bodyText": "I wonder if we can add a test that the early termination works in AllocationDeciders? At least one specific test with one specific example if making something that randomly exercises all decider NO decisions is too complicated.", "url": "https://github.com/elastic/elasticsearch/pull/62275#discussion_r515038542", "createdAt": "2020-10-30T11:41:22Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/ClusterRebalanceAllocationDecider.java", "diffHunk": "@@ -109,40 +110,55 @@ public Decision canRebalance(ShardRouting shardRouting, RoutingAllocation alloca\n         return canRebalance(allocation);\n     }\n \n+    private static final Decision YES_ALL_PRIMARIES_ACTIVE = Decision.single(Decision.Type.YES, NAME, \"all primary shards are active\");\n+\n+    private static final Decision YES_ALL_SHARDS_ACTIVE = Decision.single(Decision.Type.YES, NAME, \"all shards are active\");\n+\n+    private static final Decision NO_UNASSIGNED_PRIMARIES = Decision.single(Decision.Type.NO, NAME,\n+            \"the cluster has unassigned primary shards and cluster setting [\"\n+                    + CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE + \"] is set to [\" + ClusterRebalanceType.INDICES_PRIMARIES_ACTIVE + \"]\");\n+\n+    private static final Decision NO_INACTIVE_PRIMARIES = Decision.single(Decision.Type.NO, NAME,\n+            \"the cluster has inactive primary shards and cluster setting [\" + CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE +\n+                    \"] is set to [\" + ClusterRebalanceType.INDICES_PRIMARIES_ACTIVE + \"]\");\n+\n+    private static final Decision NO_UNASSIGNED_SHARDS = Decision.single(Decision.Type.NO, NAME,\n+            \"the cluster has unassigned shards and cluster setting [\" + CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE +\n+                    \"] is set to [\" + ClusterRebalanceType.INDICES_ALL_ACTIVE + \"]\");\n+\n+    private static final Decision NO_INACTIVE_SHARDS = Decision.single(Decision.Type.NO, NAME,\n+            \"the cluster has inactive shards and cluster setting [\" + CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE +\n+                    \"] is set to [\" + ClusterRebalanceType.INDICES_ALL_ACTIVE + \"]\");\n+\n+    @SuppressWarnings(\"fallthrough\")\n     @Override\n     public Decision canRebalance(RoutingAllocation allocation) {\n-        if (type == ClusterRebalanceType.INDICES_PRIMARIES_ACTIVE) {\n-            // check if there are unassigned primaries.\n-            if ( allocation.routingNodes().hasUnassignedPrimaries() ) {\n-                return allocation.decision(Decision.NO, NAME,\n-                        \"the cluster has unassigned primary shards and cluster setting [%s] is set to [%s]\",\n-                        CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE, type);\n-            }\n-            // check if there are initializing primaries that don't have a relocatingNodeId entry.\n-            if ( allocation.routingNodes().hasInactivePrimaries() ) {\n-                return allocation.decision(Decision.NO, NAME,\n-                        \"the cluster has inactive primary shards and cluster setting [%s] is set to [%s]\",\n-                        CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE, type);\n-            }\n-\n-            return allocation.decision(Decision.YES, NAME, \"all primary shards are active\");\n-        }\n-        if (type == ClusterRebalanceType.INDICES_ALL_ACTIVE) {\n-            // check if there are unassigned shards.\n-            if (allocation.routingNodes().hasUnassignedShards() ) {\n-                return allocation.decision(Decision.NO, NAME,\n-                        \"the cluster has unassigned shards and cluster setting [%s] is set to [%s]\",\n-                        CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE, type);\n-            }\n-            // in case all indices are assigned, are there initializing shards which\n-            // are not relocating?\n-            if ( allocation.routingNodes().hasInactiveShards() ) {\n-                return allocation.decision(Decision.NO, NAME,\n-                        \"the cluster has inactive shards and cluster setting [%s] is set to [%s]\",\n-                        CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE, type);\n-            }\n+        final RoutingNodes routingNodes = allocation.routingNodes();\n+        switch (type) {\n+            case INDICES_PRIMARIES_ACTIVE:\n+                // check if there are unassigned primaries.\n+                if (routingNodes.hasUnassignedPrimaries()) {\n+                    return NO_UNASSIGNED_PRIMARIES;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk3MjIwNA=="}, "originalCommit": {"oid": "6e772a0327072fff62e7fb11b212d18b86b0b7db"}, "originalPosition": 70}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "89bc2c68713dc0e91e4f253e36a58d60bd29c672", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/89bc2c68713dc0e91e4f253e36a58d60bd29c672", "committedDate": "2020-10-30T13:17:50Z", "message": "Merge branch 'master' of github.com:elastic/elasticsearch into fix-some-expensive-stuff"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7813daf82880f4b1964fa3093a1976d5348fddb9", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/7813daf82880f4b1964fa3093a1976d5348fddb9", "committedDate": "2020-10-30T14:30:00Z", "message": "CR: add test for short-circuit"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwNzMwOTYx", "url": "https://github.com/elastic/elasticsearch/pull/62275#pullrequestreview-520730961", "createdAt": "2020-10-30T14:38:34Z", "commit": {"oid": "7813daf82880f4b1964fa3093a1976d5348fddb9"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "765850c3bed6fbdb7e8848de96f6046570b9d126", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/765850c3bed6fbdb7e8848de96f6046570b9d126", "committedDate": "2020-10-30T16:10:08Z", "message": "replace all the way"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4545, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}