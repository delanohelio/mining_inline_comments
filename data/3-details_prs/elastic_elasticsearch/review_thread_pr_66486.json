{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQxNjUxODg2", "number": 66486, "reviewThreads": {"totalCount": 64, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwNjo1ODozN1rOFGjfLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMFQyMDoxODo1M1rOFRDaxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyNDE3MTk4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/qa/server/src/main/resources/command.csv-spec", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwNjo1ODozN1rOIHnRiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxNjowMzozNlrOIH8weA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg1NDQwOQ==", "bodyText": "Missed these ones, will revert the whitespace changes in this file.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r544854409", "createdAt": "2020-12-17T06:58:37Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/sql/qa/server/src/main/resources/command.csv-spec", "diffHunk": "@@ -9,15 +9,15 @@ showFunctions\n SHOW FUNCTIONS;\n \n     name:s       |    type:s\n-AVG              |AGGREGATE      \n+AVG              |AGGREGATE", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32bbe9facef7d6a7b434a421966cfd342522abdf"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTEyMDg1OA==", "bodyText": "Please do so.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545120858", "createdAt": "2020-12-17T14:14:07Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/qa/server/src/main/resources/command.csv-spec", "diffHunk": "@@ -9,15 +9,15 @@ showFunctions\n SHOW FUNCTIONS;\n \n     name:s       |    type:s\n-AVG              |AGGREGATE      \n+AVG              |AGGREGATE", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg1NDQwOQ=="}, "originalCommit": {"oid": "32bbe9facef7d6a7b434a421966cfd342522abdf"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTIwNjM5Mg==", "bodyText": "Done.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545206392", "createdAt": "2020-12-17T16:03:36Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/sql/qa/server/src/main/resources/command.csv-spec", "diffHunk": "@@ -9,15 +9,15 @@ showFunctions\n SHOW FUNCTIONS;\n \n     name:s       |    type:s\n-AVG              |AGGREGATE      \n+AVG              |AGGREGATE", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg1NDQwOQ=="}, "originalCommit": {"oid": "32bbe9facef7d6a7b434a421966cfd342522abdf"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyNDE3ODM0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeFormatProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwNzowMToxM1rOIHnVEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxNzo0OTo0OFrOIIBemA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg1NTMxNQ==", "bodyText": "Will move this out into a separate file.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r544855315", "createdAt": "2020-12-17T07:01:13Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeFormatProcessor.java", "diffHunk": "@@ -36,22 +49,379 @@\n         {\"F\", \"S\"},\n         {\"z\", \"X\"}\n     };\n-    private final Formatter formatter;\n+    \n+    private static class ToCharFormatter {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32bbe9facef7d6a7b434a421966cfd342522abdf"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI4MzczNg==", "bodyText": "Since it sounds like the PR is not finished, you can mark it as draft until you get all the changes in and make it final once you are done with it so folks can actually start reviewing it.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545283736", "createdAt": "2020-12-17T17:49:48Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeFormatProcessor.java", "diffHunk": "@@ -36,22 +49,379 @@\n         {\"F\", \"S\"},\n         {\"z\", \"X\"}\n     };\n-    private final Formatter formatter;\n+    \n+    private static class ToCharFormatter {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg1NTMxNQ=="}, "originalCommit": {"oid": "32bbe9facef7d6a7b434a421966cfd342522abdf"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyNDE4MzQ1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwNzowMjo0MlrOIHnXvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxNjozNzozOVrOIH-Uvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg1NTk5Nw==", "bodyText": "I think our tests don't run in parallel in the same JVM, so this should be safe, but if you have a better idea how to do this, I am all ears.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r544855997", "createdAt": "2020-12-17T07:02:42Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.junit.After;\n+import org.junit.Before;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    public static class TestCase {\n+        private static final AtomicInteger COUNTER = new AtomicInteger(0);\n+\n+        private final int id;\n+        private final BigDecimal secondsAndFractionsSinceEpoch;\n+        private final String formatString;\n+        private final String zoneId;\n+        \n+        TestCase(BigDecimal secondsAndFractionsSinceEpoch, String formatString) {\n+            this.id = COUNTER.incrementAndGet();\n+            this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+            this.formatString = formatString;\n+            this.zoneId = TestGenerator.randomFromCollection(ZoneId.getAvailableZoneIds().stream().filter(\n+                z -> z.startsWith(\"America\") || z.startsWith(\"Europe\") || z.startsWith(\"Asia\") || z.startsWith(\"Africa\") \n+                    || Set.of(\"UTC\", \"GMT\", \"Z\").contains(z)\n+            ).collect(Collectors.toList()));\n+        }\n+\n+    }\n+\n+    private static class TestGenerator {\n+        \n+        private static final long SECONDS_IN_YEAR = 365 * 24 * 60 * 60L;\n+        private static final String DELIMITER = \"|\";\n+        private static final String PATTERN_DELIMITER = \" @ \";\n+        // these patterns are hard to sync up between PostgreSQL and Elasticsearch, so we just warn, but actually\n+        // accept the output of Elasticsearch as is\n+        private static final Set<String> NOT_FULLY_MATCHABLE_PATTERNS = Set.of(\"TZ\", \"tz\", \"TZH\", \"tzh\", \"TZM\", \"tzm\");\n+        private static final Set<String> UNSUPPORTED_PATTERN_MODIFIERS = Set.of(\"FX\", \"TM\", \"SP\");\n+        private static final String[] PATTERNS = new String[] {\n+            \"HH\", \"HH12\", \"HH24\", \"MI\", \"SS\", \"MS\", \"US\", \"FF1\", \"FF2\", \"FF3\", \"FF4\", \"FF5\", \"FF6\", \"SSSS\", \"SSSSS\", \"AM\", \"am\", \"PM\",\n+            \"pm\", \"A.M.\", \"a.m.\", \"P.M.\", \"p.m.\", \"Y,YYY\", \"YYYY\", \"YYY\", \"YY\", \"Y\", \"IYYY\", \"IYY\", \"IY\", \"I\", \"BC\", \"bc\", \"AD\", \"ad\",\n+            \"B.C.\", \"b.c.\", \"A.D.\", \"a.d.\", \"MONTH\", \"Month\", \"month\", \"MON\", \"Mon\", \"mon\", \"MM\", \"DAY\", \"Day\", \"day\", \"DY\", \"Dy\",\n+            \"dy\", \"DDD\", \"IDDD\", \"DD\", \"D\", \"ID\", \"W\", \"WW\", \"IW\", \"CC\", \"J\", \"Q\", \"RM\", \"rm\", \"TZ\", \"tz\", \"TZH\", \"TZM\", \"OF\"\n+        };\n+        private static final Set<String> PATTERNS_WITHOUT_MODIFIER_TEST = NOT_FULLY_MATCHABLE_PATTERNS;\n+        private static final List<String> FILL_MODIFIERS = List.of(\"FM\", \"fm\", \"\");\n+        private static final List<String> ORDINAL_SUFFIX_MODIFIERS = List.of(\"TH\", \"th\", \"\");\n+\n+        @SuppressForbidden(reason = \"It is ok to use ThreadLocalRandom outside of an actual test\")\n+        private static Random rnd() {\n+            return ThreadLocalRandom.current();\n+        }\n+\n+        private static BigDecimal randomSecondsWithFractions(int minYear, int maxYear) {\n+            BigDecimal seconds = new BigDecimal(RandomNumbers.randomLongBetween(rnd(), \n+                (minYear - 1970) * SECONDS_IN_YEAR, (maxYear - 1970) * SECONDS_IN_YEAR));\n+            BigDecimal fractions = new BigDecimal(RandomNumbers.randomIntBetween(rnd(), 0, 999_999)).movePointLeft(6);\n+            return seconds.add(fractions);\n+        }\n+\n+        private static <T> T randomFromCollection(Collection<T> list) {\n+            List<T> l = new ArrayList<>(list);\n+            return l.get(rnd().nextInt(l.size()));\n+        }\n+        \n+        private static String patternWithRandomModifiers(String pattern) {\n+            if (PATTERNS_WITHOUT_MODIFIER_TEST.contains(pattern)) {\n+                return pattern;\n+            }\n+            return randomFromCollection(FILL_MODIFIERS) + pattern + randomFromCollection(ORDINAL_SUFFIX_MODIFIERS);\n+        }\n+    \n+        private static List<TestCase> generateTestCases() {\n+            \n+            final List<BigDecimal> testEpochSeconds = new LinkedList<>();\n+            for (int i = 0; i < 50; i++) {\n+                testEpochSeconds.add(randomSecondsWithFractions(-1200, 2500));\n+            }\n+            for (int i = 0; i < 5; i++) {\n+                testEpochSeconds.add(randomSecondsWithFractions(-1, 1));\n+            }\n+    \n+            List<TestCase> testCases = new ArrayList<>();\n+    \n+            // check each format string alone\n+            for (String pattern : PATTERNS) {\n+                testCases.add(new TestCase(randomFromCollection(testEpochSeconds), PATTERNS_WITHOUT_MODIFIER_TEST.contains(pattern) \n+                    ? pattern \n+                    : String.join(PATTERN_DELIMITER, pattern, FILL_MODIFIERS.get(0) + pattern + ORDINAL_SUFFIX_MODIFIERS.get(0))));\n+            }\n+            \n+            // let's check all of the format strings with a non-ambiguous format string\n+            for (BigDecimal es : testEpochSeconds) {\n+                testCases.add(new TestCase(es, IntStream.range(0, PATTERNS.length)\n+                    .mapToObj(idx -> idx + \":\" + patternWithRandomModifiers(PATTERNS[idx]))\n+                    .collect(Collectors.joining(PATTERN_DELIMITER))));\n+            }\n+    \n+            // check the lowercase versions of the format strings\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), IntStream.range(0, PATTERNS.length)\n+                .mapToObj(idx -> (idx + \":\" + patternWithRandomModifiers(PATTERNS[idx])).toLowerCase(Locale.ROOT))\n+                .collect(Collectors.joining(PATTERN_DELIMITER))));\n+    \n+            // potentially ambiguous format string test cases, to check if our format string parsing is in-sync with PostgreSQL\n+            // greedy and prefers the longer format strings\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"YYYYYYYYYYYYYYY,YYYYYYYYY\"));\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"SSSSSSSSSSSSSSSS\"));\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"DDDDDDDD\"));\n+    \n+            // Roman numbers\n+            for (int i = 1; i <= 12; i++) {\n+                testCases.add(new TestCase(\n+                    new BigDecimal(dateTime(0).withMonth(i).toEpochSecond()), rnd().nextBoolean() ? \"RM\" : \"rm\"));\n+            }\n+            \n+            // random strings made out of template patterns and random characters\n+            final String randomCharacters = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYabcdefghijklmnopqrstuvwxy _-.:;\";\n+            final List<String> formatStringsToRandomTest = Arrays.stream(PATTERNS)\n+                .filter(s -> NOT_FULLY_MATCHABLE_PATTERNS.contains(s) == false)\n+                .collect(Collectors.toList());\n+            \n+            for (int i = 0; i < 20; i++) {\n+                String patternWithLiterals = IntStream.rangeClosed(1, 30).mapToObj(idx -> \n+                    rnd().nextInt(100) < 80 \n+                        ? randomCharacters.substring(rnd().nextInt(randomCharacters.length())).substring(0, 1) \n+                        : (randomFromCollection(FILL_MODIFIERS) \n+                            + randomFromCollection(formatStringsToRandomTest) \n+                            + randomFromCollection(ORDINAL_SUFFIX_MODIFIERS)))\n+                    .collect(Collectors.joining());\n+                \n+                // clean up the random string from the unsupported modifiers\n+                for (String unsupportedPatternModifier : UNSUPPORTED_PATTERN_MODIFIERS) {\n+                    patternWithLiterals = patternWithLiterals\n+                        .replace(unsupportedPatternModifier, \"\")\n+                        .replace(unsupportedPatternModifier.toLowerCase(Locale.ROOT), \"\");\n+                }\n+                testCases.add(new TestCase(randomFromCollection(testEpochSeconds), patternWithLiterals));\n+            }\n+    \n+            return testCases;\n+        }\n+        \n+        /**\n+         * Generates an SQL file that can be used to create the test dataset for the unit test of the <code>TO_CHAR</code>\n+         * implementation. In case the <code>TO_CHAR</code> implementation needs an upgrade, add the list of the new format\n+         * strings to the list of the format string, regenerate the SQL, run it against the PostgreSQL version you are targeting\n+         * and update the test CSV file.\n+         */\n+        private static String unitTestExporterScript() {\n+            return generateTestCases().stream().map(tc -> {\n+                long seconds = tc.secondsAndFractionsSinceEpoch.longValue();\n+                BigDecimal fractions = tc.secondsAndFractionsSinceEpoch.remainder(BigDecimal.ONE).movePointRight(6);\n+                return String.format(Locale.ROOT,\n+                    \"SET TIME ZONE '%6$s';\\n\" +\n+                    \"\\\\copy (SELECT %1$d as id, %2$s as epoch_seconds_and_microsends, '%6$s' as zone_id, '%5$s' as format_string, \" +\n+                        \"TO_CHAR((TO_TIMESTAMP(%3$d) + INTERVAL '%4$d microseconds'), '%5$s') as to_char_result) to stdout \" +\n+                        \"with DELIMITER as '\" + DELIMITER + \"' NULL as '' csv \\n\",\n+                    tc.id, tc.secondsAndFractionsSinceEpoch.toPlainString(), seconds, fractions.intValue(), tc.formatString, tc.zoneId\n+                );\n+            }).collect(Collectors.joining(\"\\n\"));\n+        }\n+    \n+        /**\n+         * Saves the generated test script into the file specified as the first and only argument.\n+         *\n+         * Once the file is generated, you can execute the following command to generate the output dataset with:\n+         *\n+         * <p>\n+         *  <code>\n+         *  PGPASSWORD=\"mysecretpassword\" psql --quiet -h localhost -p 5432 -U postgres -f /tmp/postgresql-tochar-test.sql &gt; /tochar.csv\n+         *  </code>\n+         * </p>\n+         */\n+        public static void main(String[] args) throws Exception {\n+            String scriptFilename = args.length < 1 ? \"/tmp/postgresql-tochar-test.sql\" : args[0];\n+            Files.writeString(Path.of(scriptFilename), unitTestExporterScript(), StandardCharsets.UTF_8);\n+        }\n+    }\n+\n+    @ParametersFactory(argumentFormatting = \"%1$s: timestamp=%2$s, zone=%3$s, format=%4$s\")\n+    public static List<Object[]> readCsv() throws Exception {\n+        Path testFilePath = Path.of(DateTimeToCharProcessorTests.class.getResource(\"tochar.csv\").toURI());\n+        return Files.readAllLines(testFilePath).stream().map(line -> {\n+            String[] cols = line.split(Pattern.quote(TestGenerator.DELIMITER));\n+            return new Object[]{ cols[0], cols[1], cols[2], cols[3], cols[4] };\n+        }).collect(Collectors.toList());\n+    }\n+\n+    private final String id;\n+    private final String secondsAndFractionsSinceEpoch;\n+    private final String zone;\n+    private final String formatString;\n+    private final String expectedResult;\n+    \n+    private Locale defaultLocale = null;\n+\n+    public DateTimeToCharProcessorTests(String id, String secondsAndFractionsSinceEpoch, String zone, String formatString, \n+        String expectedResult) {\n+        this.id = id;\n+        this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+        this.zone = zone;\n+        this.formatString = formatString;\n+        this.expectedResult = expectedResult;\n+    }\n+\n+    private static ZonedDateTime dateTimeWithFractions(String secondAndFractionsSinceEpoch) {\n+        BigDecimal b = new BigDecimal(secondAndFractionsSinceEpoch);\n+        long seconds = b.longValue();\n+        int fractions = b.remainder(BigDecimal.ONE).movePointRight(9).intValueExact();\n+        int adjustment = 0;\n+        if (fractions < 0) {\n+            fractions += 1e9;\n+            adjustment = -1;\n+        }\n+        return dateTime((seconds + adjustment) * 1000).withNano(fractions);\n+    }\n+\n+    /**\n+     * Since the test dataset was exported from PostgreSQL using en_US locale, \n+     * let's stick with to that Locale during the testing of this function.\n+     */\n+    @Before\n+    public void changeLocaleToUS() {\n+        this.defaultLocale = Locale.getDefault();\n+        Locale.setDefault(Locale.US);\n+    }\n+    \n+    @After\n+    public void revertLocale() {\n+        Locale.setDefault(this.defaultLocale);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32bbe9facef7d6a7b434a421966cfd342522abdf"}, "originalPosition": 264}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTIzMjA2Mg==", "bodyText": "After adding the Locale.ROOT to the String.format and String.to{Lower,Upper}Case, this can be removed. Yay!", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545232062", "createdAt": "2020-12-17T16:37:39Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.junit.After;\n+import org.junit.Before;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    public static class TestCase {\n+        private static final AtomicInteger COUNTER = new AtomicInteger(0);\n+\n+        private final int id;\n+        private final BigDecimal secondsAndFractionsSinceEpoch;\n+        private final String formatString;\n+        private final String zoneId;\n+        \n+        TestCase(BigDecimal secondsAndFractionsSinceEpoch, String formatString) {\n+            this.id = COUNTER.incrementAndGet();\n+            this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+            this.formatString = formatString;\n+            this.zoneId = TestGenerator.randomFromCollection(ZoneId.getAvailableZoneIds().stream().filter(\n+                z -> z.startsWith(\"America\") || z.startsWith(\"Europe\") || z.startsWith(\"Asia\") || z.startsWith(\"Africa\") \n+                    || Set.of(\"UTC\", \"GMT\", \"Z\").contains(z)\n+            ).collect(Collectors.toList()));\n+        }\n+\n+    }\n+\n+    private static class TestGenerator {\n+        \n+        private static final long SECONDS_IN_YEAR = 365 * 24 * 60 * 60L;\n+        private static final String DELIMITER = \"|\";\n+        private static final String PATTERN_DELIMITER = \" @ \";\n+        // these patterns are hard to sync up between PostgreSQL and Elasticsearch, so we just warn, but actually\n+        // accept the output of Elasticsearch as is\n+        private static final Set<String> NOT_FULLY_MATCHABLE_PATTERNS = Set.of(\"TZ\", \"tz\", \"TZH\", \"tzh\", \"TZM\", \"tzm\");\n+        private static final Set<String> UNSUPPORTED_PATTERN_MODIFIERS = Set.of(\"FX\", \"TM\", \"SP\");\n+        private static final String[] PATTERNS = new String[] {\n+            \"HH\", \"HH12\", \"HH24\", \"MI\", \"SS\", \"MS\", \"US\", \"FF1\", \"FF2\", \"FF3\", \"FF4\", \"FF5\", \"FF6\", \"SSSS\", \"SSSSS\", \"AM\", \"am\", \"PM\",\n+            \"pm\", \"A.M.\", \"a.m.\", \"P.M.\", \"p.m.\", \"Y,YYY\", \"YYYY\", \"YYY\", \"YY\", \"Y\", \"IYYY\", \"IYY\", \"IY\", \"I\", \"BC\", \"bc\", \"AD\", \"ad\",\n+            \"B.C.\", \"b.c.\", \"A.D.\", \"a.d.\", \"MONTH\", \"Month\", \"month\", \"MON\", \"Mon\", \"mon\", \"MM\", \"DAY\", \"Day\", \"day\", \"DY\", \"Dy\",\n+            \"dy\", \"DDD\", \"IDDD\", \"DD\", \"D\", \"ID\", \"W\", \"WW\", \"IW\", \"CC\", \"J\", \"Q\", \"RM\", \"rm\", \"TZ\", \"tz\", \"TZH\", \"TZM\", \"OF\"\n+        };\n+        private static final Set<String> PATTERNS_WITHOUT_MODIFIER_TEST = NOT_FULLY_MATCHABLE_PATTERNS;\n+        private static final List<String> FILL_MODIFIERS = List.of(\"FM\", \"fm\", \"\");\n+        private static final List<String> ORDINAL_SUFFIX_MODIFIERS = List.of(\"TH\", \"th\", \"\");\n+\n+        @SuppressForbidden(reason = \"It is ok to use ThreadLocalRandom outside of an actual test\")\n+        private static Random rnd() {\n+            return ThreadLocalRandom.current();\n+        }\n+\n+        private static BigDecimal randomSecondsWithFractions(int minYear, int maxYear) {\n+            BigDecimal seconds = new BigDecimal(RandomNumbers.randomLongBetween(rnd(), \n+                (minYear - 1970) * SECONDS_IN_YEAR, (maxYear - 1970) * SECONDS_IN_YEAR));\n+            BigDecimal fractions = new BigDecimal(RandomNumbers.randomIntBetween(rnd(), 0, 999_999)).movePointLeft(6);\n+            return seconds.add(fractions);\n+        }\n+\n+        private static <T> T randomFromCollection(Collection<T> list) {\n+            List<T> l = new ArrayList<>(list);\n+            return l.get(rnd().nextInt(l.size()));\n+        }\n+        \n+        private static String patternWithRandomModifiers(String pattern) {\n+            if (PATTERNS_WITHOUT_MODIFIER_TEST.contains(pattern)) {\n+                return pattern;\n+            }\n+            return randomFromCollection(FILL_MODIFIERS) + pattern + randomFromCollection(ORDINAL_SUFFIX_MODIFIERS);\n+        }\n+    \n+        private static List<TestCase> generateTestCases() {\n+            \n+            final List<BigDecimal> testEpochSeconds = new LinkedList<>();\n+            for (int i = 0; i < 50; i++) {\n+                testEpochSeconds.add(randomSecondsWithFractions(-1200, 2500));\n+            }\n+            for (int i = 0; i < 5; i++) {\n+                testEpochSeconds.add(randomSecondsWithFractions(-1, 1));\n+            }\n+    \n+            List<TestCase> testCases = new ArrayList<>();\n+    \n+            // check each format string alone\n+            for (String pattern : PATTERNS) {\n+                testCases.add(new TestCase(randomFromCollection(testEpochSeconds), PATTERNS_WITHOUT_MODIFIER_TEST.contains(pattern) \n+                    ? pattern \n+                    : String.join(PATTERN_DELIMITER, pattern, FILL_MODIFIERS.get(0) + pattern + ORDINAL_SUFFIX_MODIFIERS.get(0))));\n+            }\n+            \n+            // let's check all of the format strings with a non-ambiguous format string\n+            for (BigDecimal es : testEpochSeconds) {\n+                testCases.add(new TestCase(es, IntStream.range(0, PATTERNS.length)\n+                    .mapToObj(idx -> idx + \":\" + patternWithRandomModifiers(PATTERNS[idx]))\n+                    .collect(Collectors.joining(PATTERN_DELIMITER))));\n+            }\n+    \n+            // check the lowercase versions of the format strings\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), IntStream.range(0, PATTERNS.length)\n+                .mapToObj(idx -> (idx + \":\" + patternWithRandomModifiers(PATTERNS[idx])).toLowerCase(Locale.ROOT))\n+                .collect(Collectors.joining(PATTERN_DELIMITER))));\n+    \n+            // potentially ambiguous format string test cases, to check if our format string parsing is in-sync with PostgreSQL\n+            // greedy and prefers the longer format strings\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"YYYYYYYYYYYYYYY,YYYYYYYYY\"));\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"SSSSSSSSSSSSSSSS\"));\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"DDDDDDDD\"));\n+    \n+            // Roman numbers\n+            for (int i = 1; i <= 12; i++) {\n+                testCases.add(new TestCase(\n+                    new BigDecimal(dateTime(0).withMonth(i).toEpochSecond()), rnd().nextBoolean() ? \"RM\" : \"rm\"));\n+            }\n+            \n+            // random strings made out of template patterns and random characters\n+            final String randomCharacters = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYabcdefghijklmnopqrstuvwxy _-.:;\";\n+            final List<String> formatStringsToRandomTest = Arrays.stream(PATTERNS)\n+                .filter(s -> NOT_FULLY_MATCHABLE_PATTERNS.contains(s) == false)\n+                .collect(Collectors.toList());\n+            \n+            for (int i = 0; i < 20; i++) {\n+                String patternWithLiterals = IntStream.rangeClosed(1, 30).mapToObj(idx -> \n+                    rnd().nextInt(100) < 80 \n+                        ? randomCharacters.substring(rnd().nextInt(randomCharacters.length())).substring(0, 1) \n+                        : (randomFromCollection(FILL_MODIFIERS) \n+                            + randomFromCollection(formatStringsToRandomTest) \n+                            + randomFromCollection(ORDINAL_SUFFIX_MODIFIERS)))\n+                    .collect(Collectors.joining());\n+                \n+                // clean up the random string from the unsupported modifiers\n+                for (String unsupportedPatternModifier : UNSUPPORTED_PATTERN_MODIFIERS) {\n+                    patternWithLiterals = patternWithLiterals\n+                        .replace(unsupportedPatternModifier, \"\")\n+                        .replace(unsupportedPatternModifier.toLowerCase(Locale.ROOT), \"\");\n+                }\n+                testCases.add(new TestCase(randomFromCollection(testEpochSeconds), patternWithLiterals));\n+            }\n+    \n+            return testCases;\n+        }\n+        \n+        /**\n+         * Generates an SQL file that can be used to create the test dataset for the unit test of the <code>TO_CHAR</code>\n+         * implementation. In case the <code>TO_CHAR</code> implementation needs an upgrade, add the list of the new format\n+         * strings to the list of the format string, regenerate the SQL, run it against the PostgreSQL version you are targeting\n+         * and update the test CSV file.\n+         */\n+        private static String unitTestExporterScript() {\n+            return generateTestCases().stream().map(tc -> {\n+                long seconds = tc.secondsAndFractionsSinceEpoch.longValue();\n+                BigDecimal fractions = tc.secondsAndFractionsSinceEpoch.remainder(BigDecimal.ONE).movePointRight(6);\n+                return String.format(Locale.ROOT,\n+                    \"SET TIME ZONE '%6$s';\\n\" +\n+                    \"\\\\copy (SELECT %1$d as id, %2$s as epoch_seconds_and_microsends, '%6$s' as zone_id, '%5$s' as format_string, \" +\n+                        \"TO_CHAR((TO_TIMESTAMP(%3$d) + INTERVAL '%4$d microseconds'), '%5$s') as to_char_result) to stdout \" +\n+                        \"with DELIMITER as '\" + DELIMITER + \"' NULL as '' csv \\n\",\n+                    tc.id, tc.secondsAndFractionsSinceEpoch.toPlainString(), seconds, fractions.intValue(), tc.formatString, tc.zoneId\n+                );\n+            }).collect(Collectors.joining(\"\\n\"));\n+        }\n+    \n+        /**\n+         * Saves the generated test script into the file specified as the first and only argument.\n+         *\n+         * Once the file is generated, you can execute the following command to generate the output dataset with:\n+         *\n+         * <p>\n+         *  <code>\n+         *  PGPASSWORD=\"mysecretpassword\" psql --quiet -h localhost -p 5432 -U postgres -f /tmp/postgresql-tochar-test.sql &gt; /tochar.csv\n+         *  </code>\n+         * </p>\n+         */\n+        public static void main(String[] args) throws Exception {\n+            String scriptFilename = args.length < 1 ? \"/tmp/postgresql-tochar-test.sql\" : args[0];\n+            Files.writeString(Path.of(scriptFilename), unitTestExporterScript(), StandardCharsets.UTF_8);\n+        }\n+    }\n+\n+    @ParametersFactory(argumentFormatting = \"%1$s: timestamp=%2$s, zone=%3$s, format=%4$s\")\n+    public static List<Object[]> readCsv() throws Exception {\n+        Path testFilePath = Path.of(DateTimeToCharProcessorTests.class.getResource(\"tochar.csv\").toURI());\n+        return Files.readAllLines(testFilePath).stream().map(line -> {\n+            String[] cols = line.split(Pattern.quote(TestGenerator.DELIMITER));\n+            return new Object[]{ cols[0], cols[1], cols[2], cols[3], cols[4] };\n+        }).collect(Collectors.toList());\n+    }\n+\n+    private final String id;\n+    private final String secondsAndFractionsSinceEpoch;\n+    private final String zone;\n+    private final String formatString;\n+    private final String expectedResult;\n+    \n+    private Locale defaultLocale = null;\n+\n+    public DateTimeToCharProcessorTests(String id, String secondsAndFractionsSinceEpoch, String zone, String formatString, \n+        String expectedResult) {\n+        this.id = id;\n+        this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+        this.zone = zone;\n+        this.formatString = formatString;\n+        this.expectedResult = expectedResult;\n+    }\n+\n+    private static ZonedDateTime dateTimeWithFractions(String secondAndFractionsSinceEpoch) {\n+        BigDecimal b = new BigDecimal(secondAndFractionsSinceEpoch);\n+        long seconds = b.longValue();\n+        int fractions = b.remainder(BigDecimal.ONE).movePointRight(9).intValueExact();\n+        int adjustment = 0;\n+        if (fractions < 0) {\n+            fractions += 1e9;\n+            adjustment = -1;\n+        }\n+        return dateTime((seconds + adjustment) * 1000).withNano(fractions);\n+    }\n+\n+    /**\n+     * Since the test dataset was exported from PostgreSQL using en_US locale, \n+     * let's stick with to that Locale during the testing of this function.\n+     */\n+    @Before\n+    public void changeLocaleToUS() {\n+        this.defaultLocale = Locale.getDefault();\n+        Locale.setDefault(Locale.US);\n+    }\n+    \n+    @After\n+    public void revertLocale() {\n+        Locale.setDefault(this.defaultLocale);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg1NTk5Nw=="}, "originalCommit": {"oid": "32bbe9facef7d6a7b434a421966cfd342522abdf"}, "originalPosition": 264}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyNjcxNTc1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxNjozNjozMVrOIH-RFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxNjozNjozMVrOIH-RFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTIzMTEyNA==", "bodyText": "Switching this to use offset instead of the zone names (so it will work on the CI server and with other Java versions too).", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545231124", "createdAt": "2020-12-17T16:36:31Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.junit.After;\n+import org.junit.Before;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    public static class TestCase {\n+        private static final AtomicInteger COUNTER = new AtomicInteger(0);\n+\n+        private final int id;\n+        private final BigDecimal secondsAndFractionsSinceEpoch;\n+        private final String formatString;\n+        private final String zoneId;\n+        \n+        TestCase(BigDecimal secondsAndFractionsSinceEpoch, String formatString) {\n+            this.id = COUNTER.incrementAndGet();\n+            this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+            this.formatString = formatString;\n+            this.zoneId = TestGenerator.randomFromCollection(ZoneId.getAvailableZoneIds().stream().filter(\n+                z -> z.startsWith(\"America\") || z.startsWith(\"Europe\") || z.startsWith(\"Asia\") || z.startsWith(\"Africa\") \n+                    || Set.of(\"UTC\", \"GMT\", \"Z\").contains(z)\n+            ).collect(Collectors.toList()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95d32c3446b72b895ce424ee37ea901cbb21ff4e"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMDE5MzcyOnYy", "diffSide": "RIGHT", "path": "docs/reference/sql/functions/date-time.asciidoc", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMDozNTo0MVrOIIdoJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxNTo0MjowMlrOIIoKpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc0NDkzNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            - The result of the pattern `TZ`, `tz` and `OF` patterns is equivalent with, but differs from the results returned by the PostgreSQL implementation.\n          \n          \n            \n            - The result of the pattern `TZ`, `tz` and `OF` is equivalent with, but differs from the results returned by the PostgreSQL implementation.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545744934", "createdAt": "2020-12-18T10:35:41Z", "author": {"login": "bpintea"}, "path": "docs/reference/sql/functions/date-time.asciidoc", "diffHunk": "@@ -818,6 +818,54 @@ include-tagged::{sql-specs}/docs/docs.csv-spec[formatDateTime]\n include-tagged::{sql-specs}/docs/docs.csv-spec[formatTime]\n --------------------------------------------------\n \n+\n+[[sql-functions-datetime-to_char]]\n+==== `TO_CHAR`\n+\n+.Synopsis:\n+[source, sql]\n+--------------------------------------------------\n+TO_CHAR(\n+    date_exp/datetime_exp/time_exp, <1>\n+    string_exp) <2>\n+--------------------------------------------------\n+\n+*Input*:\n+\n+<1> date/datetime/time expression\n+<2> format pattern\n+\n+*Output*: string\n+\n+*Description*: Returns the date/datetime/time as a string using the format specified in the 2nd argument. The formatting\n+pattern conforms to\n+https://www.postgresql.org/docs/13/functions-formatting.html[PostgreSQL Template Patterns for Date/Time Formatting].\n+If any of the two arguments is `null` or the pattern is an empty string `null` is returned.\n+\n+[NOTE]\n+If the 1st argument is of type `time`, then the pattern specified by the 2nd argument cannot contain date related units\n+(e.g. 'dd', 'MM', 'YYYY', etc.). If it contains such units an error is returned.\n+\n+*Special Cases*\n+\n+- The result of the pattern `TZ`, `tz` and `OF` patterns is equivalent with, but differs from the results returned by the PostgreSQL implementation.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5babe13ca152b6d4b2cd38bc2c435fa0c50060b9"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc1ODI1Mg==", "bodyText": "Do we want to briefly explain the difference? Would this be too long? The tests don't seem to exemplify either.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545758252", "createdAt": "2020-12-18T11:00:43Z", "author": {"login": "bpintea"}, "path": "docs/reference/sql/functions/date-time.asciidoc", "diffHunk": "@@ -818,6 +818,54 @@ include-tagged::{sql-specs}/docs/docs.csv-spec[formatDateTime]\n include-tagged::{sql-specs}/docs/docs.csv-spec[formatTime]\n --------------------------------------------------\n \n+\n+[[sql-functions-datetime-to_char]]\n+==== `TO_CHAR`\n+\n+.Synopsis:\n+[source, sql]\n+--------------------------------------------------\n+TO_CHAR(\n+    date_exp/datetime_exp/time_exp, <1>\n+    string_exp) <2>\n+--------------------------------------------------\n+\n+*Input*:\n+\n+<1> date/datetime/time expression\n+<2> format pattern\n+\n+*Output*: string\n+\n+*Description*: Returns the date/datetime/time as a string using the format specified in the 2nd argument. The formatting\n+pattern conforms to\n+https://www.postgresql.org/docs/13/functions-formatting.html[PostgreSQL Template Patterns for Date/Time Formatting].\n+If any of the two arguments is `null` or the pattern is an empty string `null` is returned.\n+\n+[NOTE]\n+If the 1st argument is of type `time`, then the pattern specified by the 2nd argument cannot contain date related units\n+(e.g. 'dd', 'MM', 'YYYY', etc.). If it contains such units an error is returned.\n+\n+*Special Cases*\n+\n+- The result of the pattern `TZ`, `tz` and `OF` patterns is equivalent with, but differs from the results returned by the PostgreSQL implementation.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc0NDkzNA=="}, "originalCommit": {"oid": "5babe13ca152b6d4b2cd38bc2c435fa0c50060b9"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTkxNzYwNw==", "bodyText": "TZ and tz (mostly) the short name of the timezone. PostgreSQL and Java has slightly different names for the different timezones. Sadly, I cannot just simply add a static mapping between the two, since the name of timezones  can also change over time. Did not seem to worth the effort. I can add more details explain this in the docs.\nAlso: I will remove the OF from this callout, because I was able to match it between Postgres and ES.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545917607", "createdAt": "2020-12-18T15:42:02Z", "author": {"login": "palesz"}, "path": "docs/reference/sql/functions/date-time.asciidoc", "diffHunk": "@@ -818,6 +818,54 @@ include-tagged::{sql-specs}/docs/docs.csv-spec[formatDateTime]\n include-tagged::{sql-specs}/docs/docs.csv-spec[formatTime]\n --------------------------------------------------\n \n+\n+[[sql-functions-datetime-to_char]]\n+==== `TO_CHAR`\n+\n+.Synopsis:\n+[source, sql]\n+--------------------------------------------------\n+TO_CHAR(\n+    date_exp/datetime_exp/time_exp, <1>\n+    string_exp) <2>\n+--------------------------------------------------\n+\n+*Input*:\n+\n+<1> date/datetime/time expression\n+<2> format pattern\n+\n+*Output*: string\n+\n+*Description*: Returns the date/datetime/time as a string using the format specified in the 2nd argument. The formatting\n+pattern conforms to\n+https://www.postgresql.org/docs/13/functions-formatting.html[PostgreSQL Template Patterns for Date/Time Formatting].\n+If any of the two arguments is `null` or the pattern is an empty string `null` is returned.\n+\n+[NOTE]\n+If the 1st argument is of type `time`, then the pattern specified by the 2nd argument cannot contain date related units\n+(e.g. 'dd', 'MM', 'YYYY', etc.). If it contains such units an error is returned.\n+\n+*Special Cases*\n+\n+- The result of the pattern `TZ`, `tz` and `OF` patterns is equivalent with, but differs from the results returned by the PostgreSQL implementation.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc0NDkzNA=="}, "originalCommit": {"oid": "5babe13ca152b6d4b2cd38bc2c435fa0c50060b9"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMDI4MjUwOnYy", "diffSide": "RIGHT", "path": "docs/reference/sql/functions/date-time.asciidoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMTowMToxOVrOIIedWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMTowMToxOVrOIIedWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc1ODU1Mw==", "bodyText": "...and not FX, TM, SP, you mean?", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545758553", "createdAt": "2020-12-18T11:01:19Z", "author": {"login": "bpintea"}, "path": "docs/reference/sql/functions/date-time.asciidoc", "diffHunk": "@@ -818,6 +818,54 @@ include-tagged::{sql-specs}/docs/docs.csv-spec[formatDateTime]\n include-tagged::{sql-specs}/docs/docs.csv-spec[formatTime]\n --------------------------------------------------\n \n+\n+[[sql-functions-datetime-to_char]]\n+==== `TO_CHAR`\n+\n+.Synopsis:\n+[source, sql]\n+--------------------------------------------------\n+TO_CHAR(\n+    date_exp/datetime_exp/time_exp, <1>\n+    string_exp) <2>\n+--------------------------------------------------\n+\n+*Input*:\n+\n+<1> date/datetime/time expression\n+<2> format pattern\n+\n+*Output*: string\n+\n+*Description*: Returns the date/datetime/time as a string using the format specified in the 2nd argument. The formatting\n+pattern conforms to\n+https://www.postgresql.org/docs/13/functions-formatting.html[PostgreSQL Template Patterns for Date/Time Formatting].\n+If any of the two arguments is `null` or the pattern is an empty string `null` is returned.\n+\n+[NOTE]\n+If the 1st argument is of type `time`, then the pattern specified by the 2nd argument cannot contain date related units\n+(e.g. 'dd', 'MM', 'YYYY', etc.). If it contains such units an error is returned.\n+\n+*Special Cases*\n+\n+- The result of the pattern `TZ`, `tz` and `OF` patterns is equivalent with, but differs from the results returned by the PostgreSQL implementation.\n+- Only the `FM`, `TH` and `th` pattern modifiers implemented.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5babe13ca152b6d4b2cd38bc2c435fa0c50060b9"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMDMzMTYxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/qa/server/src/main/resources/datetime.csv-spec", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMToxNTo0NlrOIIe6fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxNTo0NDowMlrOIIoPgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc2NjAxNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            SELECT birth_date, TO_CHAR(birth_date, 'MM/DD/YYYY') AS df_birth_date1, TO_CHAR(birth_date, concat(gender, 'M/DD')) AS df_birth_date2\n          \n          \n            \n            SELECT birth_date, TO_CHAR(birth_date, 'MM/DD/YYYY') AS df_birth_date1, TO_CHAR(birth_date, CONCAT(gender, 'M/DD')) AS df_birth_date2\n          \n      \n    \n    \n  \n\nNice. A funky outcome would also be without the 'M' filtering and / separation (for the FM to work).", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545766015", "createdAt": "2020-12-18T11:15:46Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/sql/qa/server/src/main/resources/datetime.csv-spec", "diffHunk": "@@ -601,6 +601,110 @@ HAVING DATETIME_FORMAT(MAX(birth_date), 'dd')::integer > 20  ORDER BY 1 DESC;\n 1961-02-26 00:00:00.000Z | 02\n ;\n \n+selectToChar\n+schema::df_date:s|df_datetime:s|df_time:s\n+SELECT TO_CHAR('2020-04-05T11:22:33.123Z'::date, 'DD/MM/YYYY HH24:MI:SS.FF3') AS df_date,\n+TO_CHAR('2020-04-05T11:22:33.123Z'::datetime, 'DD/MM/YYYY HH24:MI:SS.FF2') AS df_datetime,\n+TO_CHAR('11:22:33.123456789Z'::time, 'HH24:MI:SS.FF2') AS df_time;\n+\n+       df_date          |    df_datetime         |   df_time\n+------------------------+------------------------+----------------\n+05/04/2020 00:00:00.000 | 05/04/2020 11:22:33.12 | 11:22:33.12\n+;\n+\n+selectToCharWithField\n+schema::birth_date:ts|df_birth_date1:s|df_birth_date2:s\n+SELECT birth_date, TO_CHAR(birth_date, 'MM/DD/YYYY') AS df_birth_date1, TO_CHAR(birth_date, concat(gender, 'M/DD')) AS df_birth_date2", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5babe13ca152b6d4b2cd38bc2c435fa0c50060b9"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTkxODg0OA==", "bodyText": "Kudos for the person who created the dateTimeFormat version of this test (just stole it). +1 on the FM testing, will add it.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545918848", "createdAt": "2020-12-18T15:44:02Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/sql/qa/server/src/main/resources/datetime.csv-spec", "diffHunk": "@@ -601,6 +601,110 @@ HAVING DATETIME_FORMAT(MAX(birth_date), 'dd')::integer > 20  ORDER BY 1 DESC;\n 1961-02-26 00:00:00.000Z | 02\n ;\n \n+selectToChar\n+schema::df_date:s|df_datetime:s|df_time:s\n+SELECT TO_CHAR('2020-04-05T11:22:33.123Z'::date, 'DD/MM/YYYY HH24:MI:SS.FF3') AS df_date,\n+TO_CHAR('2020-04-05T11:22:33.123Z'::datetime, 'DD/MM/YYYY HH24:MI:SS.FF2') AS df_datetime,\n+TO_CHAR('11:22:33.123456789Z'::time, 'HH24:MI:SS.FF2') AS df_time;\n+\n+       df_date          |    df_datetime         |   df_time\n+------------------------+------------------------+----------------\n+05/04/2020 00:00:00.000 | 05/04/2020 11:22:33.12 | 11:22:33.12\n+;\n+\n+selectToCharWithField\n+schema::birth_date:ts|df_birth_date1:s|df_birth_date2:s\n+SELECT birth_date, TO_CHAR(birth_date, 'MM/DD/YYYY') AS df_birth_date1, TO_CHAR(birth_date, concat(gender, 'M/DD')) AS df_birth_date2", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc2NjAxNQ=="}, "originalCommit": {"oid": "5babe13ca152b6d4b2cd38bc2c435fa0c50060b9"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMDM1NDA0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/qa/server/src/main/resources/docs/docs.csv-spec", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMToyMzowNlrOIIfHpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMToyMzowNlrOIIfHpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc2OTM4MA==", "bodyText": "Maybe\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            SELECT TO_CHAR(CAST('11:22:33.987' AS TIME), 'HH24 MI SS.FF1') AS \"time\";\n          \n          \n            \n            SELECT TO_CHAR(CAST('23:22:33.987' AS TIME), 'HH12 MI SS.FF1') AS \"time\";\n          \n      \n    \n    \n  \n\nfor a change, HH24 appeared a few times already.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545769380", "createdAt": "2020-12-18T11:23:06Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/sql/qa/server/src/main/resources/docs/docs.csv-spec", "diffHunk": "@@ -2876,6 +2877,36 @@ SELECT DATETIME_FORMAT(CAST('11:22:33.987' AS TIME), 'HH mm ss.S') AS \"time\";\n // end::dateTimeFormatTime\n ;\n \n+toCharDate\n+// tag::toCharDate\n+SELECT TO_CHAR(CAST('2020-04-05' AS DATE), 'DD/MM/YYYY') AS \"date\";\n+\n+      date\n+------------------\n+05/04/2020\n+// end::toCharDate\n+;\n+\n+toCharDateTime\n+// tag::toCharDateTime\n+SELECT TO_CHAR(CAST('2020-04-05T11:22:33.987654' AS DATETIME), 'DD/MM/YYYY HH24:MI:SS.FF2') AS \"datetime\";\n+\n+      datetime\n+------------------\n+05/04/2020 11:22:33.98\n+// end::toCharDateTime\n+;\n+\n+toCharTime\n+// tag::toCharTime\n+SELECT TO_CHAR(CAST('11:22:33.987' AS TIME), 'HH24 MI SS.FF1') AS \"time\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5babe13ca152b6d4b2cd38bc2c435fa0c50060b9"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMDQyMDczOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMTo0NDozMFrOIIfu3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMTo0NDozMFrOIIfu3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc3OTQyMA==", "bodyText": "was this line breaking intentional?", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545779420", "createdAt": "2020-12-18T11:44:30Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::fillOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int\n+        MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().getAsInt();\n+\n+    private final String pattern;\n+    private final boolean lowercaseAccepted;\n+    private final Function<String, String> fillMode;\n+    private final boolean hasOrdinalSuffix;\n+    private final Function<TemporalAccessor, String> formatFn;\n+\n+    private ToCharFormatter(\n+        String pattern,\n+        boolean lowercaseAccepted,\n+        Function<String, String> fillMode,\n+        boolean hasOrdinalSuffix,\n+        Function<TemporalAccessor, String> formatFn) {\n+\n+        this.pattern = pattern;\n+        this.lowercaseAccepted = lowercaseAccepted;\n+        this.fillMode = fillMode;\n+        this.hasOrdinalSuffix = hasOrdinalSuffix;\n+        this.formatFn = formatFn;\n+    }\n+\n+    private static Builder of(String pattern) {\n+        return new Builder(pattern);\n+    }\n+\n+    private String format(TemporalAccessor temporalAccessor) {\n+        return formatFn.apply(temporalAccessor);\n+    }\n+\n+    private ToCharFormatter withModifier(Function<String, String> modifierFn) {\n+        return new ToCharFormatter(pattern, lowercaseAccepted, fillMode, hasOrdinalSuffix, formatFn.andThen(modifierFn));\n+    }\n+\n+    private static List<ToCharFormatter> parsePattern(String toCharPattern) {\n+        LinkedList<ToCharFormatter> formatters = new LinkedList<>();\n+\n+        boolean fillModeModifierActive = false;\n+\n+        while (toCharPattern.isEmpty() == false) {\n+            boolean foundPattern = false;\n+            for (int length = Math.min(MAX_TO_CHAR_FORMAT_STRING_LENGTH, toCharPattern.length()); length >= 1; length--) {\n+                final String potentialPattern = toCharPattern.substring(0, length);\n+                if (\"FM\".equals(potentialPattern) || \"fm\".equals(potentialPattern)) {\n+                    // try to apply the fill mode modifier to the next formatter\n+                    fillModeModifierActive = true;\n+                    foundPattern = true;\n+                } else if (\"TH\".equals(potentialPattern) || \"th\".equals(potentialPattern)) {\n+                    // try to apply the ordinal suffix modifier to the last formatter\n+                    ToCharFormatter lastFormatter = formatters.removeLast();\n+                    if (lastFormatter == null) {\n+                        lastFormatter = literal(potentialPattern);\n+                    } else if (lastFormatter.hasOrdinalSuffix) {\n+                        // if there was no previous pattern, simply prints the ordinal suffix pattern\n+                        final boolean upperCase = \"TH\".equals(potentialPattern);\n+                        lastFormatter = lastFormatter.withModifier(s -> appendOrdinalSuffix(potentialPattern, upperCase, s));\n+                    }\n+                    formatters.addLast(lastFormatter);\n+                    foundPattern = true;\n+                } else {\n+                    ToCharFormatter formatter = FORMATTER_MAP.get(potentialPattern);\n+                    // check if it is a known pattern string, if so apply it, with any modifier\n+                    if (formatter != null) {\n+                        if (fillModeModifierActive && formatter.fillMode != null) {\n+                            formatter = formatter.withModifier(formatter.fillMode);\n+                        }\n+                        formatters.addLast(formatter);\n+                        fillModeModifierActive = false;\n+                        foundPattern = true;\n+                    }\n+                }\n+                if (foundPattern) {\n+                    toCharPattern = toCharPattern.substring(length);\n+                    break;\n+                }\n+            }\n+            if (foundPattern == false) {\n+                // the fill mode modifier does not apply in case of literals\n+                formatters.addLast(literal(toCharPattern.substring(0, 1)));\n+                toCharPattern = toCharPattern.substring(1);\n+                fillModeModifierActive = false;\n+            }\n+        }\n+        return formatters;\n+    }\n+\n+    public static Function<TemporalAccessor, String> ofPattern(String pattern) {\n+        if (Strings.isEmpty(pattern)) {\n+            return timestamp -> \"\";\n+        }\n+        final List<ToCharFormatter> toCharFormatters = parsePattern(pattern);\n+        return timestamp -> toCharFormatters.stream().map(p -> p.format(timestamp)).collect(Collectors.joining());\n+    }\n+\n+    private static ToCharFormatter literal(String literal) {\n+        return new ToCharFormatter(literal, false, null, true, t -> literal);\n+    }\n+\n+    private static String ordinalSuffix(int i) {\n+        if (i < 0) {\n+            i = -i;\n+        }\n+        int mod100 = i % 100;\n+        int mod10 = i % 10;\n+        if (mod10 == 1 && mod100 != 11) {\n+            return \"st\";\n+        } else if (mod10 == 2 && mod100 != 12) {\n+            return \"nd\";\n+        } else if (mod10 == 3 && mod100 != 13) {\n+            return \"rd\";\n+        } else {\n+            return \"th\";\n+        }\n+    }\n+\n+    private static String appendOrdinalSuffix(String defaultSuffix, boolean upperCase, String s) {\n+        try {\n+            // the Y,YYY pattern might can cause problems with the parsing, but thankfully the last 3\n+            // characters is enough to calculate the suffix\n+            int i = Integer.parseInt(lastNCharacter(s, 3));\n+            return s + (upperCase ? ordinalSuffix(i).toUpperCase(Locale.ROOT) : ordinalSuffix(i));\n+        } catch (NumberFormatException ex) {\n+            return s + defaultSuffix;\n+        }\n+    }\n+\n+    private static String fillNumeric(String paddedNumber) {\n+        return String.valueOf(Integer.parseInt(paddedNumber));\n+    }\n+\n+    private static String fillText(String paddedText) {\n+        return paddedText.replaceAll(\" +$\", \"\");\n+    }\n+\n+    private static String formatOffset(String offset) {\n+        if (offset.equals(\"Z\")) {\n+            return \"+00\";\n+        }\n+        if (offset.matches(\"^[+-][0-9][0-9]00$\")) {\n+            offset = offset.substring(0, offset.length() - 2);\n+        } else if (offset.matches(\"^[+-][0-9]{3,4}$\")) {\n+            offset = offset.substring(0, offset.length() - 2) + \":\" + offset.substring(offset.length() - 2);\n+        } else if (offset.matches(\"^[+-][0-9][0-9]:00$\")) {\n+            offset = offset.substring(0, offset.length() - 3);\n+        }\n+        return offset.substring(0, Math.min(offset.length(), 6));\n+    }\n+\n+    private static String fillOffset(String offset) {\n+        //offset = offset.replace(\":{0,1}00$\", \"\");\n+        if (offset.matches(\"[+-]0{1,2}\")) {\n+            return offset.substring(0, 2);\n+        } else {\n+            if (offset.startsWith(\"+0\")) {\n+                return \"+\" + offset.substring(2);\n+            } else if (offset.startsWith(\"-0\")) {\n+                return \"-\" + offset.substring(2);\n+            } else {\n+                return offset;\n+            }\n+        }\n+    }\n+\n+    private static String absoluteWeekBasedYear(TemporalAccessor t) {\n+        int year = t.get(IsoFields.WEEK_BASED_YEAR);\n+        year = year > 0 ? year : -(year - 1);\n+        return String.format(Locale.ROOT, \"%04d\", year);\n+    }\n+\n+    private static String firstDigitsOfNanos(String nano, int digits) {\n+        return String.format(Locale.ROOT, \"%09d\", Integer.parseInt(nano)).substring(0, digits);\n+    }\n+\n+    private static String lastNCharacter(String s, int n) {\n+        return s.substring(Math.max(0, s.length() - n));\n+    }\n+\n+    private static String zoneAbbreviationOf(TemporalAccessor temporalAccessor) {\n+        String zone = ZoneId.from(temporalAccessor).getDisplayName(TextStyle.SHORT, Locale.ROOT);\n+        return \"Z\".equals(zone) ? \"UTC\" : zone;\n+    }\n+\n+    private static class Builder {\n+\n+        private final String pattern;\n+        private boolean lowercaseAccepted = true;\n+        private Function<String, String> fillMode = ToCharFormatter::fillNumeric;\n+        private boolean hasOrdinalSuffix = true;\n+        private Function<TemporalAccessor, String> formatFn;\n+\n+        Builder(String pattern) {\n+            this.pattern = pattern;\n+        }\n+\n+        public Builder formatFn(final String javaPatterm) {\n+            return formatFn(javaPatterm, null);\n+        }\n+\n+        public Builder formatFn(final String javaPattern, final Function<String, String> additionalMapper) {\n+            this.formatFn = temporalAccessor -> {\n+                String\n+                    formatted =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5babe13ca152b6d4b2cd38bc2c435fa0c50060b9"}, "originalPosition": 334}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMDc5ODQ4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMzozNjozMVrOIIjHCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMzozNjozMVrOIIjHCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTgzNDc2Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    public Builder formatFn(final String javaPatterm) {\n          \n          \n            \n                    public Builder formatFn(final String javaPattern) {", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545834762", "createdAt": "2020-12-18T13:36:31Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::fillOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int\n+        MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().getAsInt();\n+\n+    private final String pattern;\n+    private final boolean lowercaseAccepted;\n+    private final Function<String, String> fillMode;\n+    private final boolean hasOrdinalSuffix;\n+    private final Function<TemporalAccessor, String> formatFn;\n+\n+    private ToCharFormatter(\n+        String pattern,\n+        boolean lowercaseAccepted,\n+        Function<String, String> fillMode,\n+        boolean hasOrdinalSuffix,\n+        Function<TemporalAccessor, String> formatFn) {\n+\n+        this.pattern = pattern;\n+        this.lowercaseAccepted = lowercaseAccepted;\n+        this.fillMode = fillMode;\n+        this.hasOrdinalSuffix = hasOrdinalSuffix;\n+        this.formatFn = formatFn;\n+    }\n+\n+    private static Builder of(String pattern) {\n+        return new Builder(pattern);\n+    }\n+\n+    private String format(TemporalAccessor temporalAccessor) {\n+        return formatFn.apply(temporalAccessor);\n+    }\n+\n+    private ToCharFormatter withModifier(Function<String, String> modifierFn) {\n+        return new ToCharFormatter(pattern, lowercaseAccepted, fillMode, hasOrdinalSuffix, formatFn.andThen(modifierFn));\n+    }\n+\n+    private static List<ToCharFormatter> parsePattern(String toCharPattern) {\n+        LinkedList<ToCharFormatter> formatters = new LinkedList<>();\n+\n+        boolean fillModeModifierActive = false;\n+\n+        while (toCharPattern.isEmpty() == false) {\n+            boolean foundPattern = false;\n+            for (int length = Math.min(MAX_TO_CHAR_FORMAT_STRING_LENGTH, toCharPattern.length()); length >= 1; length--) {\n+                final String potentialPattern = toCharPattern.substring(0, length);\n+                if (\"FM\".equals(potentialPattern) || \"fm\".equals(potentialPattern)) {\n+                    // try to apply the fill mode modifier to the next formatter\n+                    fillModeModifierActive = true;\n+                    foundPattern = true;\n+                } else if (\"TH\".equals(potentialPattern) || \"th\".equals(potentialPattern)) {\n+                    // try to apply the ordinal suffix modifier to the last formatter\n+                    ToCharFormatter lastFormatter = formatters.removeLast();\n+                    if (lastFormatter == null) {\n+                        lastFormatter = literal(potentialPattern);\n+                    } else if (lastFormatter.hasOrdinalSuffix) {\n+                        // if there was no previous pattern, simply prints the ordinal suffix pattern\n+                        final boolean upperCase = \"TH\".equals(potentialPattern);\n+                        lastFormatter = lastFormatter.withModifier(s -> appendOrdinalSuffix(potentialPattern, upperCase, s));\n+                    }\n+                    formatters.addLast(lastFormatter);\n+                    foundPattern = true;\n+                } else {\n+                    ToCharFormatter formatter = FORMATTER_MAP.get(potentialPattern);\n+                    // check if it is a known pattern string, if so apply it, with any modifier\n+                    if (formatter != null) {\n+                        if (fillModeModifierActive && formatter.fillMode != null) {\n+                            formatter = formatter.withModifier(formatter.fillMode);\n+                        }\n+                        formatters.addLast(formatter);\n+                        fillModeModifierActive = false;\n+                        foundPattern = true;\n+                    }\n+                }\n+                if (foundPattern) {\n+                    toCharPattern = toCharPattern.substring(length);\n+                    break;\n+                }\n+            }\n+            if (foundPattern == false) {\n+                // the fill mode modifier does not apply in case of literals\n+                formatters.addLast(literal(toCharPattern.substring(0, 1)));\n+                toCharPattern = toCharPattern.substring(1);\n+                fillModeModifierActive = false;\n+            }\n+        }\n+        return formatters;\n+    }\n+\n+    public static Function<TemporalAccessor, String> ofPattern(String pattern) {\n+        if (Strings.isEmpty(pattern)) {\n+            return timestamp -> \"\";\n+        }\n+        final List<ToCharFormatter> toCharFormatters = parsePattern(pattern);\n+        return timestamp -> toCharFormatters.stream().map(p -> p.format(timestamp)).collect(Collectors.joining());\n+    }\n+\n+    private static ToCharFormatter literal(String literal) {\n+        return new ToCharFormatter(literal, false, null, true, t -> literal);\n+    }\n+\n+    private static String ordinalSuffix(int i) {\n+        if (i < 0) {\n+            i = -i;\n+        }\n+        int mod100 = i % 100;\n+        int mod10 = i % 10;\n+        if (mod10 == 1 && mod100 != 11) {\n+            return \"st\";\n+        } else if (mod10 == 2 && mod100 != 12) {\n+            return \"nd\";\n+        } else if (mod10 == 3 && mod100 != 13) {\n+            return \"rd\";\n+        } else {\n+            return \"th\";\n+        }\n+    }\n+\n+    private static String appendOrdinalSuffix(String defaultSuffix, boolean upperCase, String s) {\n+        try {\n+            // the Y,YYY pattern might can cause problems with the parsing, but thankfully the last 3\n+            // characters is enough to calculate the suffix\n+            int i = Integer.parseInt(lastNCharacter(s, 3));\n+            return s + (upperCase ? ordinalSuffix(i).toUpperCase(Locale.ROOT) : ordinalSuffix(i));\n+        } catch (NumberFormatException ex) {\n+            return s + defaultSuffix;\n+        }\n+    }\n+\n+    private static String fillNumeric(String paddedNumber) {\n+        return String.valueOf(Integer.parseInt(paddedNumber));\n+    }\n+\n+    private static String fillText(String paddedText) {\n+        return paddedText.replaceAll(\" +$\", \"\");\n+    }\n+\n+    private static String formatOffset(String offset) {\n+        if (offset.equals(\"Z\")) {\n+            return \"+00\";\n+        }\n+        if (offset.matches(\"^[+-][0-9][0-9]00$\")) {\n+            offset = offset.substring(0, offset.length() - 2);\n+        } else if (offset.matches(\"^[+-][0-9]{3,4}$\")) {\n+            offset = offset.substring(0, offset.length() - 2) + \":\" + offset.substring(offset.length() - 2);\n+        } else if (offset.matches(\"^[+-][0-9][0-9]:00$\")) {\n+            offset = offset.substring(0, offset.length() - 3);\n+        }\n+        return offset.substring(0, Math.min(offset.length(), 6));\n+    }\n+\n+    private static String fillOffset(String offset) {\n+        //offset = offset.replace(\":{0,1}00$\", \"\");\n+        if (offset.matches(\"[+-]0{1,2}\")) {\n+            return offset.substring(0, 2);\n+        } else {\n+            if (offset.startsWith(\"+0\")) {\n+                return \"+\" + offset.substring(2);\n+            } else if (offset.startsWith(\"-0\")) {\n+                return \"-\" + offset.substring(2);\n+            } else {\n+                return offset;\n+            }\n+        }\n+    }\n+\n+    private static String absoluteWeekBasedYear(TemporalAccessor t) {\n+        int year = t.get(IsoFields.WEEK_BASED_YEAR);\n+        year = year > 0 ? year : -(year - 1);\n+        return String.format(Locale.ROOT, \"%04d\", year);\n+    }\n+\n+    private static String firstDigitsOfNanos(String nano, int digits) {\n+        return String.format(Locale.ROOT, \"%09d\", Integer.parseInt(nano)).substring(0, digits);\n+    }\n+\n+    private static String lastNCharacter(String s, int n) {\n+        return s.substring(Math.max(0, s.length() - n));\n+    }\n+\n+    private static String zoneAbbreviationOf(TemporalAccessor temporalAccessor) {\n+        String zone = ZoneId.from(temporalAccessor).getDisplayName(TextStyle.SHORT, Locale.ROOT);\n+        return \"Z\".equals(zone) ? \"UTC\" : zone;\n+    }\n+\n+    private static class Builder {\n+\n+        private final String pattern;\n+        private boolean lowercaseAccepted = true;\n+        private Function<String, String> fillMode = ToCharFormatter::fillNumeric;\n+        private boolean hasOrdinalSuffix = true;\n+        private Function<TemporalAccessor, String> formatFn;\n+\n+        Builder(String pattern) {\n+            this.pattern = pattern;\n+        }\n+\n+        public Builder formatFn(final String javaPatterm) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5babe13ca152b6d4b2cd38bc2c435fa0c50060b9"}, "originalPosition": 327}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMDgzMjE4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMzo0NTo0MFrOIIjajg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxNzozNTo1OFrOIIsOBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTgzOTc1OA==", "bodyText": "I guess the function naming is inspired from Posgres' docs (FM being the \"fill mode\"), but I still find it a tad misleading, since they actually strip (padding, like leading zeros or trailing spaces). Anyways, half a concern, maybe a quick comment would \"fill in\" the next reader. :-)", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545839758", "createdAt": "2020-12-18T13:45:40Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::fillOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int\n+        MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().getAsInt();\n+\n+    private final String pattern;\n+    private final boolean lowercaseAccepted;\n+    private final Function<String, String> fillMode;\n+    private final boolean hasOrdinalSuffix;\n+    private final Function<TemporalAccessor, String> formatFn;\n+\n+    private ToCharFormatter(\n+        String pattern,\n+        boolean lowercaseAccepted,\n+        Function<String, String> fillMode,\n+        boolean hasOrdinalSuffix,\n+        Function<TemporalAccessor, String> formatFn) {\n+\n+        this.pattern = pattern;\n+        this.lowercaseAccepted = lowercaseAccepted;\n+        this.fillMode = fillMode;\n+        this.hasOrdinalSuffix = hasOrdinalSuffix;\n+        this.formatFn = formatFn;\n+    }\n+\n+    private static Builder of(String pattern) {\n+        return new Builder(pattern);\n+    }\n+\n+    private String format(TemporalAccessor temporalAccessor) {\n+        return formatFn.apply(temporalAccessor);\n+    }\n+\n+    private ToCharFormatter withModifier(Function<String, String> modifierFn) {\n+        return new ToCharFormatter(pattern, lowercaseAccepted, fillMode, hasOrdinalSuffix, formatFn.andThen(modifierFn));\n+    }\n+\n+    private static List<ToCharFormatter> parsePattern(String toCharPattern) {\n+        LinkedList<ToCharFormatter> formatters = new LinkedList<>();\n+\n+        boolean fillModeModifierActive = false;\n+\n+        while (toCharPattern.isEmpty() == false) {\n+            boolean foundPattern = false;\n+            for (int length = Math.min(MAX_TO_CHAR_FORMAT_STRING_LENGTH, toCharPattern.length()); length >= 1; length--) {\n+                final String potentialPattern = toCharPattern.substring(0, length);\n+                if (\"FM\".equals(potentialPattern) || \"fm\".equals(potentialPattern)) {\n+                    // try to apply the fill mode modifier to the next formatter\n+                    fillModeModifierActive = true;\n+                    foundPattern = true;\n+                } else if (\"TH\".equals(potentialPattern) || \"th\".equals(potentialPattern)) {\n+                    // try to apply the ordinal suffix modifier to the last formatter\n+                    ToCharFormatter lastFormatter = formatters.removeLast();\n+                    if (lastFormatter == null) {\n+                        lastFormatter = literal(potentialPattern);\n+                    } else if (lastFormatter.hasOrdinalSuffix) {\n+                        // if there was no previous pattern, simply prints the ordinal suffix pattern\n+                        final boolean upperCase = \"TH\".equals(potentialPattern);\n+                        lastFormatter = lastFormatter.withModifier(s -> appendOrdinalSuffix(potentialPattern, upperCase, s));\n+                    }\n+                    formatters.addLast(lastFormatter);\n+                    foundPattern = true;\n+                } else {\n+                    ToCharFormatter formatter = FORMATTER_MAP.get(potentialPattern);\n+                    // check if it is a known pattern string, if so apply it, with any modifier\n+                    if (formatter != null) {\n+                        if (fillModeModifierActive && formatter.fillMode != null) {\n+                            formatter = formatter.withModifier(formatter.fillMode);\n+                        }\n+                        formatters.addLast(formatter);\n+                        fillModeModifierActive = false;\n+                        foundPattern = true;\n+                    }\n+                }\n+                if (foundPattern) {\n+                    toCharPattern = toCharPattern.substring(length);\n+                    break;\n+                }\n+            }\n+            if (foundPattern == false) {\n+                // the fill mode modifier does not apply in case of literals\n+                formatters.addLast(literal(toCharPattern.substring(0, 1)));\n+                toCharPattern = toCharPattern.substring(1);\n+                fillModeModifierActive = false;\n+            }\n+        }\n+        return formatters;\n+    }\n+\n+    public static Function<TemporalAccessor, String> ofPattern(String pattern) {\n+        if (Strings.isEmpty(pattern)) {\n+            return timestamp -> \"\";\n+        }\n+        final List<ToCharFormatter> toCharFormatters = parsePattern(pattern);\n+        return timestamp -> toCharFormatters.stream().map(p -> p.format(timestamp)).collect(Collectors.joining());\n+    }\n+\n+    private static ToCharFormatter literal(String literal) {\n+        return new ToCharFormatter(literal, false, null, true, t -> literal);\n+    }\n+\n+    private static String ordinalSuffix(int i) {\n+        if (i < 0) {\n+            i = -i;\n+        }\n+        int mod100 = i % 100;\n+        int mod10 = i % 10;\n+        if (mod10 == 1 && mod100 != 11) {\n+            return \"st\";\n+        } else if (mod10 == 2 && mod100 != 12) {\n+            return \"nd\";\n+        } else if (mod10 == 3 && mod100 != 13) {\n+            return \"rd\";\n+        } else {\n+            return \"th\";\n+        }\n+    }\n+\n+    private static String appendOrdinalSuffix(String defaultSuffix, boolean upperCase, String s) {\n+        try {\n+            // the Y,YYY pattern might can cause problems with the parsing, but thankfully the last 3\n+            // characters is enough to calculate the suffix\n+            int i = Integer.parseInt(lastNCharacter(s, 3));\n+            return s + (upperCase ? ordinalSuffix(i).toUpperCase(Locale.ROOT) : ordinalSuffix(i));\n+        } catch (NumberFormatException ex) {\n+            return s + defaultSuffix;\n+        }\n+    }\n+\n+    private static String fillNumeric(String paddedNumber) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5babe13ca152b6d4b2cd38bc2c435fa0c50060b9"}, "originalPosition": 259}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTk4NDAwNQ==", "bodyText": "renamed the functions to removeLeadingZeros, removePadding", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545984005", "createdAt": "2020-12-18T17:35:58Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::fillOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int\n+        MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().getAsInt();\n+\n+    private final String pattern;\n+    private final boolean lowercaseAccepted;\n+    private final Function<String, String> fillMode;\n+    private final boolean hasOrdinalSuffix;\n+    private final Function<TemporalAccessor, String> formatFn;\n+\n+    private ToCharFormatter(\n+        String pattern,\n+        boolean lowercaseAccepted,\n+        Function<String, String> fillMode,\n+        boolean hasOrdinalSuffix,\n+        Function<TemporalAccessor, String> formatFn) {\n+\n+        this.pattern = pattern;\n+        this.lowercaseAccepted = lowercaseAccepted;\n+        this.fillMode = fillMode;\n+        this.hasOrdinalSuffix = hasOrdinalSuffix;\n+        this.formatFn = formatFn;\n+    }\n+\n+    private static Builder of(String pattern) {\n+        return new Builder(pattern);\n+    }\n+\n+    private String format(TemporalAccessor temporalAccessor) {\n+        return formatFn.apply(temporalAccessor);\n+    }\n+\n+    private ToCharFormatter withModifier(Function<String, String> modifierFn) {\n+        return new ToCharFormatter(pattern, lowercaseAccepted, fillMode, hasOrdinalSuffix, formatFn.andThen(modifierFn));\n+    }\n+\n+    private static List<ToCharFormatter> parsePattern(String toCharPattern) {\n+        LinkedList<ToCharFormatter> formatters = new LinkedList<>();\n+\n+        boolean fillModeModifierActive = false;\n+\n+        while (toCharPattern.isEmpty() == false) {\n+            boolean foundPattern = false;\n+            for (int length = Math.min(MAX_TO_CHAR_FORMAT_STRING_LENGTH, toCharPattern.length()); length >= 1; length--) {\n+                final String potentialPattern = toCharPattern.substring(0, length);\n+                if (\"FM\".equals(potentialPattern) || \"fm\".equals(potentialPattern)) {\n+                    // try to apply the fill mode modifier to the next formatter\n+                    fillModeModifierActive = true;\n+                    foundPattern = true;\n+                } else if (\"TH\".equals(potentialPattern) || \"th\".equals(potentialPattern)) {\n+                    // try to apply the ordinal suffix modifier to the last formatter\n+                    ToCharFormatter lastFormatter = formatters.removeLast();\n+                    if (lastFormatter == null) {\n+                        lastFormatter = literal(potentialPattern);\n+                    } else if (lastFormatter.hasOrdinalSuffix) {\n+                        // if there was no previous pattern, simply prints the ordinal suffix pattern\n+                        final boolean upperCase = \"TH\".equals(potentialPattern);\n+                        lastFormatter = lastFormatter.withModifier(s -> appendOrdinalSuffix(potentialPattern, upperCase, s));\n+                    }\n+                    formatters.addLast(lastFormatter);\n+                    foundPattern = true;\n+                } else {\n+                    ToCharFormatter formatter = FORMATTER_MAP.get(potentialPattern);\n+                    // check if it is a known pattern string, if so apply it, with any modifier\n+                    if (formatter != null) {\n+                        if (fillModeModifierActive && formatter.fillMode != null) {\n+                            formatter = formatter.withModifier(formatter.fillMode);\n+                        }\n+                        formatters.addLast(formatter);\n+                        fillModeModifierActive = false;\n+                        foundPattern = true;\n+                    }\n+                }\n+                if (foundPattern) {\n+                    toCharPattern = toCharPattern.substring(length);\n+                    break;\n+                }\n+            }\n+            if (foundPattern == false) {\n+                // the fill mode modifier does not apply in case of literals\n+                formatters.addLast(literal(toCharPattern.substring(0, 1)));\n+                toCharPattern = toCharPattern.substring(1);\n+                fillModeModifierActive = false;\n+            }\n+        }\n+        return formatters;\n+    }\n+\n+    public static Function<TemporalAccessor, String> ofPattern(String pattern) {\n+        if (Strings.isEmpty(pattern)) {\n+            return timestamp -> \"\";\n+        }\n+        final List<ToCharFormatter> toCharFormatters = parsePattern(pattern);\n+        return timestamp -> toCharFormatters.stream().map(p -> p.format(timestamp)).collect(Collectors.joining());\n+    }\n+\n+    private static ToCharFormatter literal(String literal) {\n+        return new ToCharFormatter(literal, false, null, true, t -> literal);\n+    }\n+\n+    private static String ordinalSuffix(int i) {\n+        if (i < 0) {\n+            i = -i;\n+        }\n+        int mod100 = i % 100;\n+        int mod10 = i % 10;\n+        if (mod10 == 1 && mod100 != 11) {\n+            return \"st\";\n+        } else if (mod10 == 2 && mod100 != 12) {\n+            return \"nd\";\n+        } else if (mod10 == 3 && mod100 != 13) {\n+            return \"rd\";\n+        } else {\n+            return \"th\";\n+        }\n+    }\n+\n+    private static String appendOrdinalSuffix(String defaultSuffix, boolean upperCase, String s) {\n+        try {\n+            // the Y,YYY pattern might can cause problems with the parsing, but thankfully the last 3\n+            // characters is enough to calculate the suffix\n+            int i = Integer.parseInt(lastNCharacter(s, 3));\n+            return s + (upperCase ? ordinalSuffix(i).toUpperCase(Locale.ROOT) : ordinalSuffix(i));\n+        } catch (NumberFormatException ex) {\n+            return s + defaultSuffix;\n+        }\n+    }\n+\n+    private static String fillNumeric(String paddedNumber) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTgzOTc1OA=="}, "originalCommit": {"oid": "5babe13ca152b6d4b2cd38bc2c435fa0c50060b9"}, "originalPosition": 259}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMDg0Njg4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMzo0OToxMlrOIIji0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxNzozNjoxOFrOIIsO6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg0MTg3Mg==", "bodyText": "I guess the comment can go.\n(Also, I thought that C++-style comments required a space after the leading slashes, I def. got some failures b/c of it.)", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545841872", "createdAt": "2020-12-18T13:49:12Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::fillOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int\n+        MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().getAsInt();\n+\n+    private final String pattern;\n+    private final boolean lowercaseAccepted;\n+    private final Function<String, String> fillMode;\n+    private final boolean hasOrdinalSuffix;\n+    private final Function<TemporalAccessor, String> formatFn;\n+\n+    private ToCharFormatter(\n+        String pattern,\n+        boolean lowercaseAccepted,\n+        Function<String, String> fillMode,\n+        boolean hasOrdinalSuffix,\n+        Function<TemporalAccessor, String> formatFn) {\n+\n+        this.pattern = pattern;\n+        this.lowercaseAccepted = lowercaseAccepted;\n+        this.fillMode = fillMode;\n+        this.hasOrdinalSuffix = hasOrdinalSuffix;\n+        this.formatFn = formatFn;\n+    }\n+\n+    private static Builder of(String pattern) {\n+        return new Builder(pattern);\n+    }\n+\n+    private String format(TemporalAccessor temporalAccessor) {\n+        return formatFn.apply(temporalAccessor);\n+    }\n+\n+    private ToCharFormatter withModifier(Function<String, String> modifierFn) {\n+        return new ToCharFormatter(pattern, lowercaseAccepted, fillMode, hasOrdinalSuffix, formatFn.andThen(modifierFn));\n+    }\n+\n+    private static List<ToCharFormatter> parsePattern(String toCharPattern) {\n+        LinkedList<ToCharFormatter> formatters = new LinkedList<>();\n+\n+        boolean fillModeModifierActive = false;\n+\n+        while (toCharPattern.isEmpty() == false) {\n+            boolean foundPattern = false;\n+            for (int length = Math.min(MAX_TO_CHAR_FORMAT_STRING_LENGTH, toCharPattern.length()); length >= 1; length--) {\n+                final String potentialPattern = toCharPattern.substring(0, length);\n+                if (\"FM\".equals(potentialPattern) || \"fm\".equals(potentialPattern)) {\n+                    // try to apply the fill mode modifier to the next formatter\n+                    fillModeModifierActive = true;\n+                    foundPattern = true;\n+                } else if (\"TH\".equals(potentialPattern) || \"th\".equals(potentialPattern)) {\n+                    // try to apply the ordinal suffix modifier to the last formatter\n+                    ToCharFormatter lastFormatter = formatters.removeLast();\n+                    if (lastFormatter == null) {\n+                        lastFormatter = literal(potentialPattern);\n+                    } else if (lastFormatter.hasOrdinalSuffix) {\n+                        // if there was no previous pattern, simply prints the ordinal suffix pattern\n+                        final boolean upperCase = \"TH\".equals(potentialPattern);\n+                        lastFormatter = lastFormatter.withModifier(s -> appendOrdinalSuffix(potentialPattern, upperCase, s));\n+                    }\n+                    formatters.addLast(lastFormatter);\n+                    foundPattern = true;\n+                } else {\n+                    ToCharFormatter formatter = FORMATTER_MAP.get(potentialPattern);\n+                    // check if it is a known pattern string, if so apply it, with any modifier\n+                    if (formatter != null) {\n+                        if (fillModeModifierActive && formatter.fillMode != null) {\n+                            formatter = formatter.withModifier(formatter.fillMode);\n+                        }\n+                        formatters.addLast(formatter);\n+                        fillModeModifierActive = false;\n+                        foundPattern = true;\n+                    }\n+                }\n+                if (foundPattern) {\n+                    toCharPattern = toCharPattern.substring(length);\n+                    break;\n+                }\n+            }\n+            if (foundPattern == false) {\n+                // the fill mode modifier does not apply in case of literals\n+                formatters.addLast(literal(toCharPattern.substring(0, 1)));\n+                toCharPattern = toCharPattern.substring(1);\n+                fillModeModifierActive = false;\n+            }\n+        }\n+        return formatters;\n+    }\n+\n+    public static Function<TemporalAccessor, String> ofPattern(String pattern) {\n+        if (Strings.isEmpty(pattern)) {\n+            return timestamp -> \"\";\n+        }\n+        final List<ToCharFormatter> toCharFormatters = parsePattern(pattern);\n+        return timestamp -> toCharFormatters.stream().map(p -> p.format(timestamp)).collect(Collectors.joining());\n+    }\n+\n+    private static ToCharFormatter literal(String literal) {\n+        return new ToCharFormatter(literal, false, null, true, t -> literal);\n+    }\n+\n+    private static String ordinalSuffix(int i) {\n+        if (i < 0) {\n+            i = -i;\n+        }\n+        int mod100 = i % 100;\n+        int mod10 = i % 10;\n+        if (mod10 == 1 && mod100 != 11) {\n+            return \"st\";\n+        } else if (mod10 == 2 && mod100 != 12) {\n+            return \"nd\";\n+        } else if (mod10 == 3 && mod100 != 13) {\n+            return \"rd\";\n+        } else {\n+            return \"th\";\n+        }\n+    }\n+\n+    private static String appendOrdinalSuffix(String defaultSuffix, boolean upperCase, String s) {\n+        try {\n+            // the Y,YYY pattern might can cause problems with the parsing, but thankfully the last 3\n+            // characters is enough to calculate the suffix\n+            int i = Integer.parseInt(lastNCharacter(s, 3));\n+            return s + (upperCase ? ordinalSuffix(i).toUpperCase(Locale.ROOT) : ordinalSuffix(i));\n+        } catch (NumberFormatException ex) {\n+            return s + defaultSuffix;\n+        }\n+    }\n+\n+    private static String fillNumeric(String paddedNumber) {\n+        return String.valueOf(Integer.parseInt(paddedNumber));\n+    }\n+\n+    private static String fillText(String paddedText) {\n+        return paddedText.replaceAll(\" +$\", \"\");\n+    }\n+\n+    private static String formatOffset(String offset) {\n+        if (offset.equals(\"Z\")) {\n+            return \"+00\";\n+        }\n+        if (offset.matches(\"^[+-][0-9][0-9]00$\")) {\n+            offset = offset.substring(0, offset.length() - 2);\n+        } else if (offset.matches(\"^[+-][0-9]{3,4}$\")) {\n+            offset = offset.substring(0, offset.length() - 2) + \":\" + offset.substring(offset.length() - 2);\n+        } else if (offset.matches(\"^[+-][0-9][0-9]:00$\")) {\n+            offset = offset.substring(0, offset.length() - 3);\n+        }\n+        return offset.substring(0, Math.min(offset.length(), 6));\n+    }\n+\n+    private static String fillOffset(String offset) {\n+        //offset = offset.replace(\":{0,1}00$\", \"\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5babe13ca152b6d4b2cd38bc2c435fa0c50060b9"}, "originalPosition": 282}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTk4NDIzNA==", "bodyText": "Removed the comment. // does not require a space.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545984234", "createdAt": "2020-12-18T17:36:18Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::fillOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int\n+        MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().getAsInt();\n+\n+    private final String pattern;\n+    private final boolean lowercaseAccepted;\n+    private final Function<String, String> fillMode;\n+    private final boolean hasOrdinalSuffix;\n+    private final Function<TemporalAccessor, String> formatFn;\n+\n+    private ToCharFormatter(\n+        String pattern,\n+        boolean lowercaseAccepted,\n+        Function<String, String> fillMode,\n+        boolean hasOrdinalSuffix,\n+        Function<TemporalAccessor, String> formatFn) {\n+\n+        this.pattern = pattern;\n+        this.lowercaseAccepted = lowercaseAccepted;\n+        this.fillMode = fillMode;\n+        this.hasOrdinalSuffix = hasOrdinalSuffix;\n+        this.formatFn = formatFn;\n+    }\n+\n+    private static Builder of(String pattern) {\n+        return new Builder(pattern);\n+    }\n+\n+    private String format(TemporalAccessor temporalAccessor) {\n+        return formatFn.apply(temporalAccessor);\n+    }\n+\n+    private ToCharFormatter withModifier(Function<String, String> modifierFn) {\n+        return new ToCharFormatter(pattern, lowercaseAccepted, fillMode, hasOrdinalSuffix, formatFn.andThen(modifierFn));\n+    }\n+\n+    private static List<ToCharFormatter> parsePattern(String toCharPattern) {\n+        LinkedList<ToCharFormatter> formatters = new LinkedList<>();\n+\n+        boolean fillModeModifierActive = false;\n+\n+        while (toCharPattern.isEmpty() == false) {\n+            boolean foundPattern = false;\n+            for (int length = Math.min(MAX_TO_CHAR_FORMAT_STRING_LENGTH, toCharPattern.length()); length >= 1; length--) {\n+                final String potentialPattern = toCharPattern.substring(0, length);\n+                if (\"FM\".equals(potentialPattern) || \"fm\".equals(potentialPattern)) {\n+                    // try to apply the fill mode modifier to the next formatter\n+                    fillModeModifierActive = true;\n+                    foundPattern = true;\n+                } else if (\"TH\".equals(potentialPattern) || \"th\".equals(potentialPattern)) {\n+                    // try to apply the ordinal suffix modifier to the last formatter\n+                    ToCharFormatter lastFormatter = formatters.removeLast();\n+                    if (lastFormatter == null) {\n+                        lastFormatter = literal(potentialPattern);\n+                    } else if (lastFormatter.hasOrdinalSuffix) {\n+                        // if there was no previous pattern, simply prints the ordinal suffix pattern\n+                        final boolean upperCase = \"TH\".equals(potentialPattern);\n+                        lastFormatter = lastFormatter.withModifier(s -> appendOrdinalSuffix(potentialPattern, upperCase, s));\n+                    }\n+                    formatters.addLast(lastFormatter);\n+                    foundPattern = true;\n+                } else {\n+                    ToCharFormatter formatter = FORMATTER_MAP.get(potentialPattern);\n+                    // check if it is a known pattern string, if so apply it, with any modifier\n+                    if (formatter != null) {\n+                        if (fillModeModifierActive && formatter.fillMode != null) {\n+                            formatter = formatter.withModifier(formatter.fillMode);\n+                        }\n+                        formatters.addLast(formatter);\n+                        fillModeModifierActive = false;\n+                        foundPattern = true;\n+                    }\n+                }\n+                if (foundPattern) {\n+                    toCharPattern = toCharPattern.substring(length);\n+                    break;\n+                }\n+            }\n+            if (foundPattern == false) {\n+                // the fill mode modifier does not apply in case of literals\n+                formatters.addLast(literal(toCharPattern.substring(0, 1)));\n+                toCharPattern = toCharPattern.substring(1);\n+                fillModeModifierActive = false;\n+            }\n+        }\n+        return formatters;\n+    }\n+\n+    public static Function<TemporalAccessor, String> ofPattern(String pattern) {\n+        if (Strings.isEmpty(pattern)) {\n+            return timestamp -> \"\";\n+        }\n+        final List<ToCharFormatter> toCharFormatters = parsePattern(pattern);\n+        return timestamp -> toCharFormatters.stream().map(p -> p.format(timestamp)).collect(Collectors.joining());\n+    }\n+\n+    private static ToCharFormatter literal(String literal) {\n+        return new ToCharFormatter(literal, false, null, true, t -> literal);\n+    }\n+\n+    private static String ordinalSuffix(int i) {\n+        if (i < 0) {\n+            i = -i;\n+        }\n+        int mod100 = i % 100;\n+        int mod10 = i % 10;\n+        if (mod10 == 1 && mod100 != 11) {\n+            return \"st\";\n+        } else if (mod10 == 2 && mod100 != 12) {\n+            return \"nd\";\n+        } else if (mod10 == 3 && mod100 != 13) {\n+            return \"rd\";\n+        } else {\n+            return \"th\";\n+        }\n+    }\n+\n+    private static String appendOrdinalSuffix(String defaultSuffix, boolean upperCase, String s) {\n+        try {\n+            // the Y,YYY pattern might can cause problems with the parsing, but thankfully the last 3\n+            // characters is enough to calculate the suffix\n+            int i = Integer.parseInt(lastNCharacter(s, 3));\n+            return s + (upperCase ? ordinalSuffix(i).toUpperCase(Locale.ROOT) : ordinalSuffix(i));\n+        } catch (NumberFormatException ex) {\n+            return s + defaultSuffix;\n+        }\n+    }\n+\n+    private static String fillNumeric(String paddedNumber) {\n+        return String.valueOf(Integer.parseInt(paddedNumber));\n+    }\n+\n+    private static String fillText(String paddedText) {\n+        return paddedText.replaceAll(\" +$\", \"\");\n+    }\n+\n+    private static String formatOffset(String offset) {\n+        if (offset.equals(\"Z\")) {\n+            return \"+00\";\n+        }\n+        if (offset.matches(\"^[+-][0-9][0-9]00$\")) {\n+            offset = offset.substring(0, offset.length() - 2);\n+        } else if (offset.matches(\"^[+-][0-9]{3,4}$\")) {\n+            offset = offset.substring(0, offset.length() - 2) + \":\" + offset.substring(offset.length() - 2);\n+        } else if (offset.matches(\"^[+-][0-9][0-9]:00$\")) {\n+            offset = offset.substring(0, offset.length() - 3);\n+        }\n+        return offset.substring(0, Math.min(offset.length(), 6));\n+    }\n+\n+    private static String fillOffset(String offset) {\n+        //offset = offset.replace(\":{0,1}00$\", \"\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg0MTg3Mg=="}, "originalCommit": {"oid": "5babe13ca152b6d4b2cd38bc2c435fa0c50060b9"}, "originalPosition": 282}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMDkzOTA0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxNDoxMzoyOFrOIIkZIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxNTo0NjoxNlrOIIoVCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg1NTc3OA==", "bodyText": "Since you're iterating over the patterns in the loops above in the static block, you could also get the max length there. Just point it out, not saying it's any better.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545855778", "createdAt": "2020-12-18T14:13:28Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::fillOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int\n+        MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().getAsInt();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5babe13ca152b6d4b2cd38bc2c435fa0c50060b9"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTkyMDI2Ng==", "bodyText": "True, but we can spare the cycles since this is a static number, can be computed once, the list of patterns does not change.\nNote: will put the annotation into a new line.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545920266", "createdAt": "2020-12-18T15:46:16Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::fillOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int\n+        MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().getAsInt();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg1NTc3OA=="}, "originalCommit": {"oid": "5babe13ca152b6d4b2cd38bc2c435fa0c50060b9"}, "originalPosition": 133}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMTAwNzkwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxNDozMDo1M1rOIIlCmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxNTo0Nzo1N1rOIIoY9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg2NjM5NA==", "bodyText": "Wondering if extracting these strings (and the ones below) into static final vars would make sense.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545866394", "createdAt": "2020-12-18T14:30:53Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::fillOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int\n+        MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().getAsInt();\n+\n+    private final String pattern;\n+    private final boolean lowercaseAccepted;\n+    private final Function<String, String> fillMode;\n+    private final boolean hasOrdinalSuffix;\n+    private final Function<TemporalAccessor, String> formatFn;\n+\n+    private ToCharFormatter(\n+        String pattern,\n+        boolean lowercaseAccepted,\n+        Function<String, String> fillMode,\n+        boolean hasOrdinalSuffix,\n+        Function<TemporalAccessor, String> formatFn) {\n+\n+        this.pattern = pattern;\n+        this.lowercaseAccepted = lowercaseAccepted;\n+        this.fillMode = fillMode;\n+        this.hasOrdinalSuffix = hasOrdinalSuffix;\n+        this.formatFn = formatFn;\n+    }\n+\n+    private static Builder of(String pattern) {\n+        return new Builder(pattern);\n+    }\n+\n+    private String format(TemporalAccessor temporalAccessor) {\n+        return formatFn.apply(temporalAccessor);\n+    }\n+\n+    private ToCharFormatter withModifier(Function<String, String> modifierFn) {\n+        return new ToCharFormatter(pattern, lowercaseAccepted, fillMode, hasOrdinalSuffix, formatFn.andThen(modifierFn));\n+    }\n+\n+    private static List<ToCharFormatter> parsePattern(String toCharPattern) {\n+        LinkedList<ToCharFormatter> formatters = new LinkedList<>();\n+\n+        boolean fillModeModifierActive = false;\n+\n+        while (toCharPattern.isEmpty() == false) {\n+            boolean foundPattern = false;\n+            for (int length = Math.min(MAX_TO_CHAR_FORMAT_STRING_LENGTH, toCharPattern.length()); length >= 1; length--) {\n+                final String potentialPattern = toCharPattern.substring(0, length);\n+                if (\"FM\".equals(potentialPattern) || \"fm\".equals(potentialPattern)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5babe13ca152b6d4b2cd38bc2c435fa0c50060b9"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTkyMTI3MA==", "bodyText": "Instead of creating static final for the strings, I can extract this check into a method with a reasonable name: isFillModeModifier(String pattern)", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545921270", "createdAt": "2020-12-18T15:47:57Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::fillOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int\n+        MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().getAsInt();\n+\n+    private final String pattern;\n+    private final boolean lowercaseAccepted;\n+    private final Function<String, String> fillMode;\n+    private final boolean hasOrdinalSuffix;\n+    private final Function<TemporalAccessor, String> formatFn;\n+\n+    private ToCharFormatter(\n+        String pattern,\n+        boolean lowercaseAccepted,\n+        Function<String, String> fillMode,\n+        boolean hasOrdinalSuffix,\n+        Function<TemporalAccessor, String> formatFn) {\n+\n+        this.pattern = pattern;\n+        this.lowercaseAccepted = lowercaseAccepted;\n+        this.fillMode = fillMode;\n+        this.hasOrdinalSuffix = hasOrdinalSuffix;\n+        this.formatFn = formatFn;\n+    }\n+\n+    private static Builder of(String pattern) {\n+        return new Builder(pattern);\n+    }\n+\n+    private String format(TemporalAccessor temporalAccessor) {\n+        return formatFn.apply(temporalAccessor);\n+    }\n+\n+    private ToCharFormatter withModifier(Function<String, String> modifierFn) {\n+        return new ToCharFormatter(pattern, lowercaseAccepted, fillMode, hasOrdinalSuffix, formatFn.andThen(modifierFn));\n+    }\n+\n+    private static List<ToCharFormatter> parsePattern(String toCharPattern) {\n+        LinkedList<ToCharFormatter> formatters = new LinkedList<>();\n+\n+        boolean fillModeModifierActive = false;\n+\n+        while (toCharPattern.isEmpty() == false) {\n+            boolean foundPattern = false;\n+            for (int length = Math.min(MAX_TO_CHAR_FORMAT_STRING_LENGTH, toCharPattern.length()); length >= 1; length--) {\n+                final String potentialPattern = toCharPattern.substring(0, length);\n+                if (\"FM\".equals(potentialPattern) || \"fm\".equals(potentialPattern)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg2NjM5NA=="}, "originalCommit": {"oid": "5babe13ca152b6d4b2cd38bc2c435fa0c50060b9"}, "originalPosition": 176}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMTEzNDc0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxNDo1NDo1MFrOIImODw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxNDoyNjozNVrOIPDwmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg4NTcxMQ==", "bodyText": "Wondering about the data type choice of a LinkedList (vs maybe just an ArrayList). I only see additions and removal from the tail. Has this remained like that after maybe a refactoring, or an explicit choice. I guess .removeLast() is more comfy than .remove(formatters.size() - 1), but just curious.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545885711", "createdAt": "2020-12-18T14:54:50Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::fillOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int\n+        MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().getAsInt();\n+\n+    private final String pattern;\n+    private final boolean lowercaseAccepted;\n+    private final Function<String, String> fillMode;\n+    private final boolean hasOrdinalSuffix;\n+    private final Function<TemporalAccessor, String> formatFn;\n+\n+    private ToCharFormatter(\n+        String pattern,\n+        boolean lowercaseAccepted,\n+        Function<String, String> fillMode,\n+        boolean hasOrdinalSuffix,\n+        Function<TemporalAccessor, String> formatFn) {\n+\n+        this.pattern = pattern;\n+        this.lowercaseAccepted = lowercaseAccepted;\n+        this.fillMode = fillMode;\n+        this.hasOrdinalSuffix = hasOrdinalSuffix;\n+        this.formatFn = formatFn;\n+    }\n+\n+    private static Builder of(String pattern) {\n+        return new Builder(pattern);\n+    }\n+\n+    private String format(TemporalAccessor temporalAccessor) {\n+        return formatFn.apply(temporalAccessor);\n+    }\n+\n+    private ToCharFormatter withModifier(Function<String, String> modifierFn) {\n+        return new ToCharFormatter(pattern, lowercaseAccepted, fillMode, hasOrdinalSuffix, formatFn.andThen(modifierFn));\n+    }\n+\n+    private static List<ToCharFormatter> parsePattern(String toCharPattern) {\n+        LinkedList<ToCharFormatter> formatters = new LinkedList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5babe13ca152b6d4b2cd38bc2c435fa0c50060b9"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTkyMzE1MA==", "bodyText": "Yes, removeLast is simpler and .remove(formatters.size() - 1) requires iteration over the list. Could use the list in reverse (add and remove from the beginning), but would have to reverse it at the end. At the same time, this is a local variable, using the exact type instead of the abstract class/interface seemed reasonable.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545923150", "createdAt": "2020-12-18T15:50:57Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::fillOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int\n+        MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().getAsInt();\n+\n+    private final String pattern;\n+    private final boolean lowercaseAccepted;\n+    private final Function<String, String> fillMode;\n+    private final boolean hasOrdinalSuffix;\n+    private final Function<TemporalAccessor, String> formatFn;\n+\n+    private ToCharFormatter(\n+        String pattern,\n+        boolean lowercaseAccepted,\n+        Function<String, String> fillMode,\n+        boolean hasOrdinalSuffix,\n+        Function<TemporalAccessor, String> formatFn) {\n+\n+        this.pattern = pattern;\n+        this.lowercaseAccepted = lowercaseAccepted;\n+        this.fillMode = fillMode;\n+        this.hasOrdinalSuffix = hasOrdinalSuffix;\n+        this.formatFn = formatFn;\n+    }\n+\n+    private static Builder of(String pattern) {\n+        return new Builder(pattern);\n+    }\n+\n+    private String format(TemporalAccessor temporalAccessor) {\n+        return formatFn.apply(temporalAccessor);\n+    }\n+\n+    private ToCharFormatter withModifier(Function<String, String> modifierFn) {\n+        return new ToCharFormatter(pattern, lowercaseAccepted, fillMode, hasOrdinalSuffix, formatFn.andThen(modifierFn));\n+    }\n+\n+    private static List<ToCharFormatter> parsePattern(String toCharPattern) {\n+        LinkedList<ToCharFormatter> formatters = new LinkedList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg4NTcxMQ=="}, "originalCommit": {"oid": "5babe13ca152b6d4b2cd38bc2c435fa0c50060b9"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjY2MTE0Nw==", "bodyText": "Thx.\n\n.remove(formatters.size() - 1) requires iteration over the list.\n\nA shift would be needed, I believe, but not when popping the last element. Just a FYI, I agree removeLast() is simpler.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552661147", "createdAt": "2021-01-06T14:26:35Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::fillOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int\n+        MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().getAsInt();\n+\n+    private final String pattern;\n+    private final boolean lowercaseAccepted;\n+    private final Function<String, String> fillMode;\n+    private final boolean hasOrdinalSuffix;\n+    private final Function<TemporalAccessor, String> formatFn;\n+\n+    private ToCharFormatter(\n+        String pattern,\n+        boolean lowercaseAccepted,\n+        Function<String, String> fillMode,\n+        boolean hasOrdinalSuffix,\n+        Function<TemporalAccessor, String> formatFn) {\n+\n+        this.pattern = pattern;\n+        this.lowercaseAccepted = lowercaseAccepted;\n+        this.fillMode = fillMode;\n+        this.hasOrdinalSuffix = hasOrdinalSuffix;\n+        this.formatFn = formatFn;\n+    }\n+\n+    private static Builder of(String pattern) {\n+        return new Builder(pattern);\n+    }\n+\n+    private String format(TemporalAccessor temporalAccessor) {\n+        return formatFn.apply(temporalAccessor);\n+    }\n+\n+    private ToCharFormatter withModifier(Function<String, String> modifierFn) {\n+        return new ToCharFormatter(pattern, lowercaseAccepted, fillMode, hasOrdinalSuffix, formatFn.andThen(modifierFn));\n+    }\n+\n+    private static List<ToCharFormatter> parsePattern(String toCharPattern) {\n+        LinkedList<ToCharFormatter> formatters = new LinkedList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg4NTcxMQ=="}, "originalCommit": {"oid": "5babe13ca152b6d4b2cd38bc2c435fa0c50060b9"}, "originalPosition": 168}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMTE4OTMzOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxNTowNDoxM1rOIImunQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxNzo0MjoyMlrOIIscGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg5NDA0NQ==", "bodyText": "Couldn't this be moved inside the while loop, reset to false on every iteration, like foundPattern? It currently seems reset whether a pattern is found or not.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545894045", "createdAt": "2020-12-18T15:04:13Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::fillOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int\n+        MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().getAsInt();\n+\n+    private final String pattern;\n+    private final boolean lowercaseAccepted;\n+    private final Function<String, String> fillMode;\n+    private final boolean hasOrdinalSuffix;\n+    private final Function<TemporalAccessor, String> formatFn;\n+\n+    private ToCharFormatter(\n+        String pattern,\n+        boolean lowercaseAccepted,\n+        Function<String, String> fillMode,\n+        boolean hasOrdinalSuffix,\n+        Function<TemporalAccessor, String> formatFn) {\n+\n+        this.pattern = pattern;\n+        this.lowercaseAccepted = lowercaseAccepted;\n+        this.fillMode = fillMode;\n+        this.hasOrdinalSuffix = hasOrdinalSuffix;\n+        this.formatFn = formatFn;\n+    }\n+\n+    private static Builder of(String pattern) {\n+        return new Builder(pattern);\n+    }\n+\n+    private String format(TemporalAccessor temporalAccessor) {\n+        return formatFn.apply(temporalAccessor);\n+    }\n+\n+    private ToCharFormatter withModifier(Function<String, String> modifierFn) {\n+        return new ToCharFormatter(pattern, lowercaseAccepted, fillMode, hasOrdinalSuffix, formatFn.andThen(modifierFn));\n+    }\n+\n+    private static List<ToCharFormatter> parsePattern(String toCharPattern) {\n+        LinkedList<ToCharFormatter> formatters = new LinkedList<>();\n+\n+        boolean fillModeModifierActive = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5babe13ca152b6d4b2cd38bc2c435fa0c50060b9"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTk4NzYwOQ==", "bodyText": "No, I cannot. If I move it into the while loop it will reset to false right after I have found the FM (the for exits and would reset this boolean to false before I find the next pattern the FM should act on).", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545987609", "createdAt": "2020-12-18T17:42:22Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::fillOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int\n+        MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().getAsInt();\n+\n+    private final String pattern;\n+    private final boolean lowercaseAccepted;\n+    private final Function<String, String> fillMode;\n+    private final boolean hasOrdinalSuffix;\n+    private final Function<TemporalAccessor, String> formatFn;\n+\n+    private ToCharFormatter(\n+        String pattern,\n+        boolean lowercaseAccepted,\n+        Function<String, String> fillMode,\n+        boolean hasOrdinalSuffix,\n+        Function<TemporalAccessor, String> formatFn) {\n+\n+        this.pattern = pattern;\n+        this.lowercaseAccepted = lowercaseAccepted;\n+        this.fillMode = fillMode;\n+        this.hasOrdinalSuffix = hasOrdinalSuffix;\n+        this.formatFn = formatFn;\n+    }\n+\n+    private static Builder of(String pattern) {\n+        return new Builder(pattern);\n+    }\n+\n+    private String format(TemporalAccessor temporalAccessor) {\n+        return formatFn.apply(temporalAccessor);\n+    }\n+\n+    private ToCharFormatter withModifier(Function<String, String> modifierFn) {\n+        return new ToCharFormatter(pattern, lowercaseAccepted, fillMode, hasOrdinalSuffix, formatFn.andThen(modifierFn));\n+    }\n+\n+    private static List<ToCharFormatter> parsePattern(String toCharPattern) {\n+        LinkedList<ToCharFormatter> formatters = new LinkedList<>();\n+\n+        boolean fillModeModifierActive = false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg5NDA0NQ=="}, "originalCommit": {"oid": "5babe13ca152b6d4b2cd38bc2c435fa0c50060b9"}, "originalPosition": 170}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMTIyMzg2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxNToxMjo0MlrOIInC4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxNTo1NDoxMVrOIIooNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg5OTIzNQ==", "bodyText": "Should this comment go two lines up?\nThen interestingly, for a FM dd pattern, the FM is just swallowed. Comparatively, the dd TH does print the TH. Not sure if so on purpose or not (I think it's not tested), but I guess it's acceptable, since Postgres behaves exactly the same.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545899235", "createdAt": "2020-12-18T15:12:42Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::fillOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int\n+        MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().getAsInt();\n+\n+    private final String pattern;\n+    private final boolean lowercaseAccepted;\n+    private final Function<String, String> fillMode;\n+    private final boolean hasOrdinalSuffix;\n+    private final Function<TemporalAccessor, String> formatFn;\n+\n+    private ToCharFormatter(\n+        String pattern,\n+        boolean lowercaseAccepted,\n+        Function<String, String> fillMode,\n+        boolean hasOrdinalSuffix,\n+        Function<TemporalAccessor, String> formatFn) {\n+\n+        this.pattern = pattern;\n+        this.lowercaseAccepted = lowercaseAccepted;\n+        this.fillMode = fillMode;\n+        this.hasOrdinalSuffix = hasOrdinalSuffix;\n+        this.formatFn = formatFn;\n+    }\n+\n+    private static Builder of(String pattern) {\n+        return new Builder(pattern);\n+    }\n+\n+    private String format(TemporalAccessor temporalAccessor) {\n+        return formatFn.apply(temporalAccessor);\n+    }\n+\n+    private ToCharFormatter withModifier(Function<String, String> modifierFn) {\n+        return new ToCharFormatter(pattern, lowercaseAccepted, fillMode, hasOrdinalSuffix, formatFn.andThen(modifierFn));\n+    }\n+\n+    private static List<ToCharFormatter> parsePattern(String toCharPattern) {\n+        LinkedList<ToCharFormatter> formatters = new LinkedList<>();\n+\n+        boolean fillModeModifierActive = false;\n+\n+        while (toCharPattern.isEmpty() == false) {\n+            boolean foundPattern = false;\n+            for (int length = Math.min(MAX_TO_CHAR_FORMAT_STRING_LENGTH, toCharPattern.length()); length >= 1; length--) {\n+                final String potentialPattern = toCharPattern.substring(0, length);\n+                if (\"FM\".equals(potentialPattern) || \"fm\".equals(potentialPattern)) {\n+                    // try to apply the fill mode modifier to the next formatter\n+                    fillModeModifierActive = true;\n+                    foundPattern = true;\n+                } else if (\"TH\".equals(potentialPattern) || \"th\".equals(potentialPattern)) {\n+                    // try to apply the ordinal suffix modifier to the last formatter\n+                    ToCharFormatter lastFormatter = formatters.removeLast();\n+                    if (lastFormatter == null) {\n+                        lastFormatter = literal(potentialPattern);\n+                    } else if (lastFormatter.hasOrdinalSuffix) {\n+                        // if there was no previous pattern, simply prints the ordinal suffix pattern", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5babe13ca152b6d4b2cd38bc2c435fa0c50060b9"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTkyNTE3NQ==", "bodyText": "The behaviour currently matches exactly the Postgres behaviour. The patterns are tested both with and without the FM and TH modifiers.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545925175", "createdAt": "2020-12-18T15:54:11Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::fillOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int\n+        MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().getAsInt();\n+\n+    private final String pattern;\n+    private final boolean lowercaseAccepted;\n+    private final Function<String, String> fillMode;\n+    private final boolean hasOrdinalSuffix;\n+    private final Function<TemporalAccessor, String> formatFn;\n+\n+    private ToCharFormatter(\n+        String pattern,\n+        boolean lowercaseAccepted,\n+        Function<String, String> fillMode,\n+        boolean hasOrdinalSuffix,\n+        Function<TemporalAccessor, String> formatFn) {\n+\n+        this.pattern = pattern;\n+        this.lowercaseAccepted = lowercaseAccepted;\n+        this.fillMode = fillMode;\n+        this.hasOrdinalSuffix = hasOrdinalSuffix;\n+        this.formatFn = formatFn;\n+    }\n+\n+    private static Builder of(String pattern) {\n+        return new Builder(pattern);\n+    }\n+\n+    private String format(TemporalAccessor temporalAccessor) {\n+        return formatFn.apply(temporalAccessor);\n+    }\n+\n+    private ToCharFormatter withModifier(Function<String, String> modifierFn) {\n+        return new ToCharFormatter(pattern, lowercaseAccepted, fillMode, hasOrdinalSuffix, formatFn.andThen(modifierFn));\n+    }\n+\n+    private static List<ToCharFormatter> parsePattern(String toCharPattern) {\n+        LinkedList<ToCharFormatter> formatters = new LinkedList<>();\n+\n+        boolean fillModeModifierActive = false;\n+\n+        while (toCharPattern.isEmpty() == false) {\n+            boolean foundPattern = false;\n+            for (int length = Math.min(MAX_TO_CHAR_FORMAT_STRING_LENGTH, toCharPattern.length()); length >= 1; length--) {\n+                final String potentialPattern = toCharPattern.substring(0, length);\n+                if (\"FM\".equals(potentialPattern) || \"fm\".equals(potentialPattern)) {\n+                    // try to apply the fill mode modifier to the next formatter\n+                    fillModeModifierActive = true;\n+                    foundPattern = true;\n+                } else if (\"TH\".equals(potentialPattern) || \"th\".equals(potentialPattern)) {\n+                    // try to apply the ordinal suffix modifier to the last formatter\n+                    ToCharFormatter lastFormatter = formatters.removeLast();\n+                    if (lastFormatter == null) {\n+                        lastFormatter = literal(potentialPattern);\n+                    } else if (lastFormatter.hasOrdinalSuffix) {\n+                        // if there was no previous pattern, simply prints the ordinal suffix pattern", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg5OTIzNQ=="}, "originalCommit": {"oid": "5babe13ca152b6d4b2cd38bc2c435fa0c50060b9"}, "originalPosition": 186}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMTQxMTQ3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/util/DateUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxNTo1Nzo0NlrOIIow3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxNTo1Nzo0NlrOIIow3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTkyNzM4OQ==", "bodyText": "A matter of taste, I guess.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return year % 100 == 0 ? year / 100 : year / 100 + 1;\n          \n          \n            \n                        return year / 100 + (year % 100 == 0 ? 0 : 1);", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545927389", "createdAt": "2020-12-18T15:57:46Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/util/DateUtils.java", "diffHunk": "@@ -216,6 +216,45 @@ public static TemporalAccessor atTimeZone(TemporalAccessor ta, ZoneId zoneId) {\n         }\n     }\n \n+    public static String toRome(int month) {\n+        switch (month) {\n+            case 1:\n+                return \"I\";\n+            case 2:\n+                return \"II\";\n+            case 3:\n+                return \"III\";\n+            case 4:\n+                return \"IV\";\n+            case 5:\n+                return \"V\";\n+            case 6:\n+                return \"VI\";\n+            case 7:\n+                return \"VII\";\n+            case 8:\n+                return \"VIII\";\n+            case 9:\n+                return \"IX\";\n+            case 10:\n+                return \"X\";\n+            case 11:\n+                return \"XI\";\n+            case 12:\n+                return \"XII\";\n+            default:\n+                throw new IllegalArgumentException(\"invalid month: \" + month);\n+        }\n+    }\n+\n+    public static int century(int year) {\n+        if (year > 0) {\n+            return year % 100 == 0 ? year / 100 : year / 100 + 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5babe13ca152b6d4b2cd38bc2c435fa0c50060b9"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMTQyNjUyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/util/DateUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxNjowMTo1MlrOIIo56g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxNjowMTo1MlrOIIo56g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTkyOTcwNg==", "bodyText": "I would have indexed an array, but this works too. (I guess this is imported from the original PR).", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545929706", "createdAt": "2020-12-18T16:01:52Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/util/DateUtils.java", "diffHunk": "@@ -216,6 +216,45 @@ public static TemporalAccessor atTimeZone(TemporalAccessor ta, ZoneId zoneId) {\n         }\n     }\n \n+    public static String toRome(int month) {\n+        switch (month) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5babe13ca152b6d4b2cd38bc2c435fa0c50060b9"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NDQzMjM4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/util/DateUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNjoyNjoxM1rOIOd--g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxNTo1OToxN1rOIPyCLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA0MjIzNA==", "bodyText": "I think you mean monthToRoman", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552042234", "createdAt": "2021-01-05T16:26:13Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/util/DateUtils.java", "diffHunk": "@@ -216,6 +216,45 @@ public static TemporalAccessor atTimeZone(TemporalAccessor ta, ZoneId zoneId) {\n         }\n     }\n \n+    public static String toRome(int month) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQxOTMwOQ==", "bodyText": "Changed.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r553419309", "createdAt": "2021-01-07T15:59:17Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/util/DateUtils.java", "diffHunk": "@@ -216,6 +216,45 @@ public static TemporalAccessor atTimeZone(TemporalAccessor ta, ZoneId zoneId) {\n         }\n     }\n \n+    public static String toRome(int month) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA0MjIzNA=="}, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NDQ0NTI2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/util/DateUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNjoyOToxMlrOIOeG1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxNTo1OTozMFrOIPyCsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA0NDI0NA==", "bodyText": "yearToCentury. Is it this method (and the one above) used across multiple classes to justify declaring it in the utils class? Their purpose seems quite narrow.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552044244", "createdAt": "2021-01-05T16:29:12Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/util/DateUtils.java", "diffHunk": "@@ -216,6 +216,45 @@ public static TemporalAccessor atTimeZone(TemporalAccessor ta, ZoneId zoneId) {\n         }\n     }\n \n+    public static String toRome(int month) {\n+        switch (month) {\n+            case 1:\n+                return \"I\";\n+            case 2:\n+                return \"II\";\n+            case 3:\n+                return \"III\";\n+            case 4:\n+                return \"IV\";\n+            case 5:\n+                return \"V\";\n+            case 6:\n+                return \"VI\";\n+            case 7:\n+                return \"VII\";\n+            case 8:\n+                return \"VIII\";\n+            case 9:\n+                return \"IX\";\n+            case 10:\n+                return \"X\";\n+            case 11:\n+                return \"XI\";\n+            case 12:\n+                return \"XII\";\n+            default:\n+                throw new IllegalArgumentException(\"invalid month: \" + month);\n+        }\n+    }\n+\n+    public static int century(int year) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQxOTQ0Mg==", "bodyText": "Renamed, moved.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r553419442", "createdAt": "2021-01-07T15:59:30Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/util/DateUtils.java", "diffHunk": "@@ -216,6 +216,45 @@ public static TemporalAccessor atTimeZone(TemporalAccessor ta, ZoneId zoneId) {\n         }\n     }\n \n+    public static String toRome(int month) {\n+        switch (month) {\n+            case 1:\n+                return \"I\";\n+            case 2:\n+                return \"II\";\n+            case 3:\n+                return \"III\";\n+            case 4:\n+                return \"IV\";\n+            case 5:\n+                return \"V\";\n+            case 6:\n+                return \"VI\";\n+            case 7:\n+                return \"VII\";\n+            case 8:\n+                return \"VIII\";\n+            case 9:\n+                return \"IX\";\n+            case 10:\n+                return \"X\";\n+            case 11:\n+                return \"XI\";\n+            case 12:\n+                return \"XII\";\n+            default:\n+                throw new IllegalArgumentException(\"invalid month: \" + month);\n+        }\n+    }\n+\n+    public static int century(int year) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA0NDI0NA=="}, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NDQ0NTk0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/util/DateUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNjoyOToyM1rOIOeHTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxNjowMDowN1rOIPyEYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA0NDM2Ng==", "bodyText": "QlIllegalArgumentException.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552044366", "createdAt": "2021-01-05T16:29:23Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/util/DateUtils.java", "diffHunk": "@@ -216,6 +216,45 @@ public static TemporalAccessor atTimeZone(TemporalAccessor ta, ZoneId zoneId) {\n         }\n     }\n \n+    public static String toRome(int month) {\n+        switch (month) {\n+            case 1:\n+                return \"I\";\n+            case 2:\n+                return \"II\";\n+            case 3:\n+                return \"III\";\n+            case 4:\n+                return \"IV\";\n+            case 5:\n+                return \"V\";\n+            case 6:\n+                return \"VI\";\n+            case 7:\n+                return \"VII\";\n+            case 8:\n+                return \"VIII\";\n+            case 9:\n+                return \"IX\";\n+            case 10:\n+                return \"X\";\n+            case 11:\n+                return \"XI\";\n+            case 12:\n+                return \"XII\";\n+            default:\n+                throw new IllegalArgumentException(\"invalid month: \" + month);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQxOTg3NA==", "bodyText": "Changed switched to lookup from array.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r553419874", "createdAt": "2021-01-07T16:00:07Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/util/DateUtils.java", "diffHunk": "@@ -216,6 +216,45 @@ public static TemporalAccessor atTimeZone(TemporalAccessor ta, ZoneId zoneId) {\n         }\n     }\n \n+    public static String toRome(int month) {\n+        switch (month) {\n+            case 1:\n+                return \"I\";\n+            case 2:\n+                return \"II\";\n+            case 3:\n+                return \"III\";\n+            case 4:\n+                return \"IV\";\n+            case 5:\n+                return \"V\";\n+            case 6:\n+                return \"VI\";\n+            case 7:\n+                return \"VII\";\n+            case 8:\n+                return \"VIII\";\n+            case 9:\n+                return \"IX\";\n+            case 10:\n+                return \"X\";\n+            case 11:\n+                return \"XI\";\n+            case 12:\n+                return \"XII\";\n+            default:\n+                throw new IllegalArgumentException(\"invalid month: \" + month);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA0NDM2Ng=="}, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NDQ1Mjk3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/test/resources/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/tochar.csv", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNjozMTowOVrOIOeLwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxNjowMDoxOFrOIPyFBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA0NTUwNQ==", "bodyText": "This file seems to be generated and it's worth noting that through a basic header such as :\n#\n# DO NOT EDIT! This file is generated, see xxxxx.java\n#", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552045505", "createdAt": "2021-01-05T16:31:09Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/test/resources/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/tochar.csv", "diffHunk": "@@ -0,0 +1,162 @@\n+1|-5888618147.561663|+00:00|HH @ FMHHTH|1783-05-25 16:44:12.438337+00|04 @ 4TH", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQyMDAzOQ==", "bodyText": "Done.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r553420039", "createdAt": "2021-01-07T16:00:18Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/sql/src/test/resources/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/tochar.csv", "diffHunk": "@@ -0,0 +1,162 @@\n+1|-5888618147.561663|+00:00|HH @ FMHHTH|1783-05-25 16:44:12.438337+00|04 @ 4TH", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA0NTUwNQ=="}, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NDQ1OTQzOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNjozMjozNlrOIOePpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNjozMjozNlrOIOePpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA0NjUwMQ==", "bodyText": "Why is this class called TestCase yet it doesn't have a test method?", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552046501", "createdAt": "2021-01-05T16:32:36Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    private static class TestCase {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NDQ2MTkyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNjozMzowOVrOIOeRMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNjozMzowOVrOIOeRMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA0Njg5Ng==", "bodyText": "Is there any concurrency for this counter?", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552046896", "createdAt": "2021-01-05T16:33:09Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    private static class TestCase {\n+        private static final AtomicInteger COUNTER = new AtomicInteger(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NDQ2MzQzOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNjozMzoyOVrOIOeSHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxNjozMToyMFrOIPzPwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA0NzEzMw==", "bodyText": "This is much better externalized to a file", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552047133", "createdAt": "2021-01-05T16:33:29Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    private static class TestCase {\n+        private static final AtomicInteger COUNTER = new AtomicInteger(0);\n+        \n+        // timezones that are valid both in Java and in Postgres\n+        public static final List<String> POSTGRES_TEST_ZONE_LIST = List.of(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQzOTE2OA==", "bodyText": "See #66486 (comment)", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r553439168", "createdAt": "2021-01-07T16:31:20Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    private static class TestCase {\n+        private static final AtomicInteger COUNTER = new AtomicInteger(0);\n+        \n+        // timezones that are valid both in Java and in Postgres\n+        public static final List<String> POSTGRES_TEST_ZONE_LIST = List.of(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA0NzEzMw=="}, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NDQ3MTcyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNjozNToyMlrOIOeXKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNjozNToyMlrOIOeXKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA0ODQyNA==", "bodyText": "This utility is better pulled out from this class since it is used manually for testing the results.  It's use can be indicated documented in the test or the result file.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552048424", "createdAt": "2021-01-05T16:35:22Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    private static class TestCase {\n+        private static final AtomicInteger COUNTER = new AtomicInteger(0);\n+        \n+        // timezones that are valid both in Java and in Postgres\n+        public static final List<String> POSTGRES_TEST_ZONE_LIST = List.of(\n+            // location-based and long-names\n+            \"US/Samoa\", \"Pacific/Honolulu\", \"Pacific/Marquesas\", \"Pacific/Gambier\", \"America/Juneau\", \"Canada/Yukon\", \"America/Vancouver\",\n+            \"Pacific/Easter\", \"US/Mountain\", \"America/Chicago\", \"US/Michigan\", \"Atlantic/Bermuda\", \"Canada/Newfoundland\",\n+            \"Atlantic/Cape_Verde\", \"Pacific/Kiritimati\", \"Pacific/Chatham\", \"Pacific/Auckland\", \"Asia/Sakhalin\", \"Australia/Tasmania\", \n+            \"Australia/North\", \"Asia/Tokyo\", \"Australia/Eucla\", \"Asia/Singapore\", \"Asia/Rangoon\", \"Indian/Chagos\", \"Asia/Calcutta\", \n+            \"Asia/Tashkent\", \"Asia/Tehran\", \"Asia/Dubai\", \"Africa/Nairobi\", \"Europe/Brussels\", \"Europe/Vienna\", \"Europe/London\", \n+            \"Etc/GMT+12\",\n+            // short names of zones\n+            \"GMT\", \"UTC\", \"CET\",\n+            // offsets\n+            \"+11:00\", \"+04:30\", \"+01:00\", \"+00:00\", \"-00:00\", \"-01:15\", \"-02:00\", \"-11:00\");\n+\n+        private final int id;\n+        private final BigDecimal secondsAndFractionsSinceEpoch;\n+        private final String formatString;\n+        private final String zoneId;\n+        \n+        TestCase(BigDecimal secondsAndFractionsSinceEpoch, String formatString) {\n+            this.id = COUNTER.incrementAndGet();\n+            this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+            this.formatString = formatString;\n+            this.zoneId = TestGenerator.randomFromCollection(POSTGRES_TEST_ZONE_LIST);\n+        }\n+\n+    }\n+\n+    /**\n+     * Generates an sql file that can be used to generate the test dataset for this unit test (to be used with the <code>psql</code> cli).\n+     *\n+     * Run the @{link {@link TestGenerator#main(String[])}} class and execute the following command to generate the output dataset with:\n+     *\n+     * <p>\n+     *  <code>\n+     *      # easy way to spin up the latest Postgres\n+     *      docker run --rm --name postgres-latest -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres:latest\n+     *\n+     *      # generate the csv for the unit test\n+     *      PGPASSWORD=\"mysecretpassword\" psql --quiet -h localhost -p 5432 -U postgres -f /tmp/postgresql-tochar-test.sql \\\n+     *          &gt; /path/to/tochar.csv\n+     *  </code>\n+     * </p>\n+     */\n+    private static class TestGenerator {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NDQ3MjMwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNjozNTozM1rOIOeXhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxNjozMjowOVrOIPzRmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA0ODUxNw==", "bodyText": "All these parameters need to be externalized (say to a Properties file).", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552048517", "createdAt": "2021-01-05T16:35:33Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    private static class TestCase {\n+        private static final AtomicInteger COUNTER = new AtomicInteger(0);\n+        \n+        // timezones that are valid both in Java and in Postgres\n+        public static final List<String> POSTGRES_TEST_ZONE_LIST = List.of(\n+            // location-based and long-names\n+            \"US/Samoa\", \"Pacific/Honolulu\", \"Pacific/Marquesas\", \"Pacific/Gambier\", \"America/Juneau\", \"Canada/Yukon\", \"America/Vancouver\",\n+            \"Pacific/Easter\", \"US/Mountain\", \"America/Chicago\", \"US/Michigan\", \"Atlantic/Bermuda\", \"Canada/Newfoundland\",\n+            \"Atlantic/Cape_Verde\", \"Pacific/Kiritimati\", \"Pacific/Chatham\", \"Pacific/Auckland\", \"Asia/Sakhalin\", \"Australia/Tasmania\", \n+            \"Australia/North\", \"Asia/Tokyo\", \"Australia/Eucla\", \"Asia/Singapore\", \"Asia/Rangoon\", \"Indian/Chagos\", \"Asia/Calcutta\", \n+            \"Asia/Tashkent\", \"Asia/Tehran\", \"Asia/Dubai\", \"Africa/Nairobi\", \"Europe/Brussels\", \"Europe/Vienna\", \"Europe/London\", \n+            \"Etc/GMT+12\",\n+            // short names of zones\n+            \"GMT\", \"UTC\", \"CET\",\n+            // offsets\n+            \"+11:00\", \"+04:30\", \"+01:00\", \"+00:00\", \"-00:00\", \"-01:15\", \"-02:00\", \"-11:00\");\n+\n+        private final int id;\n+        private final BigDecimal secondsAndFractionsSinceEpoch;\n+        private final String formatString;\n+        private final String zoneId;\n+        \n+        TestCase(BigDecimal secondsAndFractionsSinceEpoch, String formatString) {\n+            this.id = COUNTER.incrementAndGet();\n+            this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+            this.formatString = formatString;\n+            this.zoneId = TestGenerator.randomFromCollection(POSTGRES_TEST_ZONE_LIST);\n+        }\n+\n+    }\n+\n+    /**\n+     * Generates an sql file that can be used to generate the test dataset for this unit test (to be used with the <code>psql</code> cli).\n+     *\n+     * Run the @{link {@link TestGenerator#main(String[])}} class and execute the following command to generate the output dataset with:\n+     *\n+     * <p>\n+     *  <code>\n+     *      # easy way to spin up the latest Postgres\n+     *      docker run --rm --name postgres-latest -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres:latest\n+     *\n+     *      # generate the csv for the unit test\n+     *      PGPASSWORD=\"mysecretpassword\" psql --quiet -h localhost -p 5432 -U postgres -f /tmp/postgresql-tochar-test.sql \\\n+     *          &gt; /path/to/tochar.csv\n+     *  </code>\n+     * </p>\n+     */\n+    private static class TestGenerator {\n+        \n+        private static final long SECONDS_IN_YEAR = 365 * 24 * 60 * 60L;\n+        private static final String DELIMITER = \"|\";\n+        private static final String PATTERN_DELIMITER = \" @ \";\n+        // these patterns are hard to sync up between PostgreSQL and Elasticsearch, so we just warn, but actually\n+        // accept the output of Elasticsearch as is\n+        private static final Set<String> NOT_FULLY_MATCHABLE_PATTERNS = Set.of(\"TZ\", \"tz\");\n+        private static final Set<String> UNSUPPORTED_PATTERN_MODIFIERS = Set.of(\"FX\", \"TM\", \"SP\");\n+        private static final String[] PATTERNS = new String[] {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQzOTY0MQ==", "bodyText": "See #66486 (comment), now I pick these up from the FORMATTER_MAP", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r553439641", "createdAt": "2021-01-07T16:32:09Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    private static class TestCase {\n+        private static final AtomicInteger COUNTER = new AtomicInteger(0);\n+        \n+        // timezones that are valid both in Java and in Postgres\n+        public static final List<String> POSTGRES_TEST_ZONE_LIST = List.of(\n+            // location-based and long-names\n+            \"US/Samoa\", \"Pacific/Honolulu\", \"Pacific/Marquesas\", \"Pacific/Gambier\", \"America/Juneau\", \"Canada/Yukon\", \"America/Vancouver\",\n+            \"Pacific/Easter\", \"US/Mountain\", \"America/Chicago\", \"US/Michigan\", \"Atlantic/Bermuda\", \"Canada/Newfoundland\",\n+            \"Atlantic/Cape_Verde\", \"Pacific/Kiritimati\", \"Pacific/Chatham\", \"Pacific/Auckland\", \"Asia/Sakhalin\", \"Australia/Tasmania\", \n+            \"Australia/North\", \"Asia/Tokyo\", \"Australia/Eucla\", \"Asia/Singapore\", \"Asia/Rangoon\", \"Indian/Chagos\", \"Asia/Calcutta\", \n+            \"Asia/Tashkent\", \"Asia/Tehran\", \"Asia/Dubai\", \"Africa/Nairobi\", \"Europe/Brussels\", \"Europe/Vienna\", \"Europe/London\", \n+            \"Etc/GMT+12\",\n+            // short names of zones\n+            \"GMT\", \"UTC\", \"CET\",\n+            // offsets\n+            \"+11:00\", \"+04:30\", \"+01:00\", \"+00:00\", \"-00:00\", \"-01:15\", \"-02:00\", \"-11:00\");\n+\n+        private final int id;\n+        private final BigDecimal secondsAndFractionsSinceEpoch;\n+        private final String formatString;\n+        private final String zoneId;\n+        \n+        TestCase(BigDecimal secondsAndFractionsSinceEpoch, String formatString) {\n+            this.id = COUNTER.incrementAndGet();\n+            this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+            this.formatString = formatString;\n+            this.zoneId = TestGenerator.randomFromCollection(POSTGRES_TEST_ZONE_LIST);\n+        }\n+\n+    }\n+\n+    /**\n+     * Generates an sql file that can be used to generate the test dataset for this unit test (to be used with the <code>psql</code> cli).\n+     *\n+     * Run the @{link {@link TestGenerator#main(String[])}} class and execute the following command to generate the output dataset with:\n+     *\n+     * <p>\n+     *  <code>\n+     *      # easy way to spin up the latest Postgres\n+     *      docker run --rm --name postgres-latest -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres:latest\n+     *\n+     *      # generate the csv for the unit test\n+     *      PGPASSWORD=\"mysecretpassword\" psql --quiet -h localhost -p 5432 -U postgres -f /tmp/postgresql-tochar-test.sql \\\n+     *          &gt; /path/to/tochar.csv\n+     *  </code>\n+     * </p>\n+     */\n+    private static class TestGenerator {\n+        \n+        private static final long SECONDS_IN_YEAR = 365 * 24 * 60 * 60L;\n+        private static final String DELIMITER = \"|\";\n+        private static final String PATTERN_DELIMITER = \" @ \";\n+        // these patterns are hard to sync up between PostgreSQL and Elasticsearch, so we just warn, but actually\n+        // accept the output of Elasticsearch as is\n+        private static final Set<String> NOT_FULLY_MATCHABLE_PATTERNS = Set.of(\"TZ\", \"tz\");\n+        private static final Set<String> UNSUPPORTED_PATTERN_MODIFIERS = Set.of(\"FX\", \"TM\", \"SP\");\n+        private static final String[] PATTERNS = new String[] {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA0ODUxNw=="}, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NDQ4MjU0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNjozODowOFrOIOed2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QwOTo0ODozNFrOIPl17g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA1MDEzNg==", "bodyText": "You can just make the runner to be a test - otherwise this is going to be quite fragile.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552050136", "createdAt": "2021-01-05T16:38:08Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    private static class TestCase {\n+        private static final AtomicInteger COUNTER = new AtomicInteger(0);\n+        \n+        // timezones that are valid both in Java and in Postgres\n+        public static final List<String> POSTGRES_TEST_ZONE_LIST = List.of(\n+            // location-based and long-names\n+            \"US/Samoa\", \"Pacific/Honolulu\", \"Pacific/Marquesas\", \"Pacific/Gambier\", \"America/Juneau\", \"Canada/Yukon\", \"America/Vancouver\",\n+            \"Pacific/Easter\", \"US/Mountain\", \"America/Chicago\", \"US/Michigan\", \"Atlantic/Bermuda\", \"Canada/Newfoundland\",\n+            \"Atlantic/Cape_Verde\", \"Pacific/Kiritimati\", \"Pacific/Chatham\", \"Pacific/Auckland\", \"Asia/Sakhalin\", \"Australia/Tasmania\", \n+            \"Australia/North\", \"Asia/Tokyo\", \"Australia/Eucla\", \"Asia/Singapore\", \"Asia/Rangoon\", \"Indian/Chagos\", \"Asia/Calcutta\", \n+            \"Asia/Tashkent\", \"Asia/Tehran\", \"Asia/Dubai\", \"Africa/Nairobi\", \"Europe/Brussels\", \"Europe/Vienna\", \"Europe/London\", \n+            \"Etc/GMT+12\",\n+            // short names of zones\n+            \"GMT\", \"UTC\", \"CET\",\n+            // offsets\n+            \"+11:00\", \"+04:30\", \"+01:00\", \"+00:00\", \"-00:00\", \"-01:15\", \"-02:00\", \"-11:00\");\n+\n+        private final int id;\n+        private final BigDecimal secondsAndFractionsSinceEpoch;\n+        private final String formatString;\n+        private final String zoneId;\n+        \n+        TestCase(BigDecimal secondsAndFractionsSinceEpoch, String formatString) {\n+            this.id = COUNTER.incrementAndGet();\n+            this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+            this.formatString = formatString;\n+            this.zoneId = TestGenerator.randomFromCollection(POSTGRES_TEST_ZONE_LIST);\n+        }\n+\n+    }\n+\n+    /**\n+     * Generates an sql file that can be used to generate the test dataset for this unit test (to be used with the <code>psql</code> cli).\n+     *\n+     * Run the @{link {@link TestGenerator#main(String[])}} class and execute the following command to generate the output dataset with:\n+     *\n+     * <p>\n+     *  <code>\n+     *      # easy way to spin up the latest Postgres\n+     *      docker run --rm --name postgres-latest -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres:latest\n+     *\n+     *      # generate the csv for the unit test\n+     *      PGPASSWORD=\"mysecretpassword\" psql --quiet -h localhost -p 5432 -U postgres -f /tmp/postgresql-tochar-test.sql \\\n+     *          &gt; /path/to/tochar.csv\n+     *  </code>\n+     * </p>\n+     */\n+    private static class TestGenerator {\n+        \n+        private static final long SECONDS_IN_YEAR = 365 * 24 * 60 * 60L;\n+        private static final String DELIMITER = \"|\";\n+        private static final String PATTERN_DELIMITER = \" @ \";\n+        // these patterns are hard to sync up between PostgreSQL and Elasticsearch, so we just warn, but actually\n+        // accept the output of Elasticsearch as is\n+        private static final Set<String> NOT_FULLY_MATCHABLE_PATTERNS = Set.of(\"TZ\", \"tz\");\n+        private static final Set<String> UNSUPPORTED_PATTERN_MODIFIERS = Set.of(\"FX\", \"TM\", \"SP\");\n+        private static final String[] PATTERNS = new String[] {\n+            \"HH\", \"HH12\", \"HH24\", \"MI\", \"SS\", \"MS\", \"US\", \"FF1\", \"FF2\", \"FF3\", \"FF4\", \"FF5\", \"FF6\", \"SSSS\", \"SSSSS\", \"AM\", \"am\", \"PM\",\n+            \"pm\", \"A.M.\", \"a.m.\", \"P.M.\", \"p.m.\", \"Y,YYY\", \"YYYY\", \"YYY\", \"YY\", \"Y\", \"IYYY\", \"IYY\", \"IY\", \"I\", \"BC\", \"bc\", \"AD\", \"ad\",\n+            \"B.C.\", \"b.c.\", \"A.D.\", \"a.d.\", \"MONTH\", \"Month\", \"month\", \"MON\", \"Mon\", \"mon\", \"MM\", \"DAY\", \"Day\", \"day\", \"DY\", \"Dy\",\n+            \"dy\", \"DDD\", \"IDDD\", \"DD\", \"D\", \"ID\", \"W\", \"WW\", \"IW\", \"CC\", \"J\", \"Q\", \"RM\", \"rm\", \"TZ\", \"tz\", \"TZH\", \"TZM\", \"OF\"\n+        };\n+        private static final List<String> FILL_MODIFIERS = List.of(\"FM\", \"fm\", \"\");\n+        private static final List<String> ORDINAL_SUFFIX_MODIFIERS = List.of(\"TH\", \"th\", \"\");\n+\n+        @SuppressForbidden(reason = \"It is ok to use ThreadLocalRandom outside of an actual test\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjg5NDk3OA==", "bodyText": "Can you expand?", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552894978", "createdAt": "2021-01-06T18:40:22Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    private static class TestCase {\n+        private static final AtomicInteger COUNTER = new AtomicInteger(0);\n+        \n+        // timezones that are valid both in Java and in Postgres\n+        public static final List<String> POSTGRES_TEST_ZONE_LIST = List.of(\n+            // location-based and long-names\n+            \"US/Samoa\", \"Pacific/Honolulu\", \"Pacific/Marquesas\", \"Pacific/Gambier\", \"America/Juneau\", \"Canada/Yukon\", \"America/Vancouver\",\n+            \"Pacific/Easter\", \"US/Mountain\", \"America/Chicago\", \"US/Michigan\", \"Atlantic/Bermuda\", \"Canada/Newfoundland\",\n+            \"Atlantic/Cape_Verde\", \"Pacific/Kiritimati\", \"Pacific/Chatham\", \"Pacific/Auckland\", \"Asia/Sakhalin\", \"Australia/Tasmania\", \n+            \"Australia/North\", \"Asia/Tokyo\", \"Australia/Eucla\", \"Asia/Singapore\", \"Asia/Rangoon\", \"Indian/Chagos\", \"Asia/Calcutta\", \n+            \"Asia/Tashkent\", \"Asia/Tehran\", \"Asia/Dubai\", \"Africa/Nairobi\", \"Europe/Brussels\", \"Europe/Vienna\", \"Europe/London\", \n+            \"Etc/GMT+12\",\n+            // short names of zones\n+            \"GMT\", \"UTC\", \"CET\",\n+            // offsets\n+            \"+11:00\", \"+04:30\", \"+01:00\", \"+00:00\", \"-00:00\", \"-01:15\", \"-02:00\", \"-11:00\");\n+\n+        private final int id;\n+        private final BigDecimal secondsAndFractionsSinceEpoch;\n+        private final String formatString;\n+        private final String zoneId;\n+        \n+        TestCase(BigDecimal secondsAndFractionsSinceEpoch, String formatString) {\n+            this.id = COUNTER.incrementAndGet();\n+            this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+            this.formatString = formatString;\n+            this.zoneId = TestGenerator.randomFromCollection(POSTGRES_TEST_ZONE_LIST);\n+        }\n+\n+    }\n+\n+    /**\n+     * Generates an sql file that can be used to generate the test dataset for this unit test (to be used with the <code>psql</code> cli).\n+     *\n+     * Run the @{link {@link TestGenerator#main(String[])}} class and execute the following command to generate the output dataset with:\n+     *\n+     * <p>\n+     *  <code>\n+     *      # easy way to spin up the latest Postgres\n+     *      docker run --rm --name postgres-latest -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres:latest\n+     *\n+     *      # generate the csv for the unit test\n+     *      PGPASSWORD=\"mysecretpassword\" psql --quiet -h localhost -p 5432 -U postgres -f /tmp/postgresql-tochar-test.sql \\\n+     *          &gt; /path/to/tochar.csv\n+     *  </code>\n+     * </p>\n+     */\n+    private static class TestGenerator {\n+        \n+        private static final long SECONDS_IN_YEAR = 365 * 24 * 60 * 60L;\n+        private static final String DELIMITER = \"|\";\n+        private static final String PATTERN_DELIMITER = \" @ \";\n+        // these patterns are hard to sync up between PostgreSQL and Elasticsearch, so we just warn, but actually\n+        // accept the output of Elasticsearch as is\n+        private static final Set<String> NOT_FULLY_MATCHABLE_PATTERNS = Set.of(\"TZ\", \"tz\");\n+        private static final Set<String> UNSUPPORTED_PATTERN_MODIFIERS = Set.of(\"FX\", \"TM\", \"SP\");\n+        private static final String[] PATTERNS = new String[] {\n+            \"HH\", \"HH12\", \"HH24\", \"MI\", \"SS\", \"MS\", \"US\", \"FF1\", \"FF2\", \"FF3\", \"FF4\", \"FF5\", \"FF6\", \"SSSS\", \"SSSSS\", \"AM\", \"am\", \"PM\",\n+            \"pm\", \"A.M.\", \"a.m.\", \"P.M.\", \"p.m.\", \"Y,YYY\", \"YYYY\", \"YYY\", \"YY\", \"Y\", \"IYYY\", \"IYY\", \"IY\", \"I\", \"BC\", \"bc\", \"AD\", \"ad\",\n+            \"B.C.\", \"b.c.\", \"A.D.\", \"a.d.\", \"MONTH\", \"Month\", \"month\", \"MON\", \"Mon\", \"mon\", \"MM\", \"DAY\", \"Day\", \"day\", \"DY\", \"Dy\",\n+            \"dy\", \"DDD\", \"IDDD\", \"DD\", \"D\", \"ID\", \"W\", \"WW\", \"IW\", \"CC\", \"J\", \"Q\", \"RM\", \"rm\", \"TZ\", \"tz\", \"TZH\", \"TZM\", \"OF\"\n+        };\n+        private static final List<String> FILL_MODIFIERS = List.of(\"FM\", \"fm\", \"\");\n+        private static final List<String> ORDINAL_SUFFIX_MODIFIERS = List.of(\"TH\", \"th\", \"\");\n+\n+        @SuppressForbidden(reason = \"It is ok to use ThreadLocalRandom outside of an actual test\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA1MDEzNg=="}, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzIxOTU2Ng==", "bodyText": "Instead of calling the test suite Random externally, which is unsupported since there are no guarantees about its initialization, simply the ESTestCase.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r553219566", "createdAt": "2021-01-07T09:48:34Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    private static class TestCase {\n+        private static final AtomicInteger COUNTER = new AtomicInteger(0);\n+        \n+        // timezones that are valid both in Java and in Postgres\n+        public static final List<String> POSTGRES_TEST_ZONE_LIST = List.of(\n+            // location-based and long-names\n+            \"US/Samoa\", \"Pacific/Honolulu\", \"Pacific/Marquesas\", \"Pacific/Gambier\", \"America/Juneau\", \"Canada/Yukon\", \"America/Vancouver\",\n+            \"Pacific/Easter\", \"US/Mountain\", \"America/Chicago\", \"US/Michigan\", \"Atlantic/Bermuda\", \"Canada/Newfoundland\",\n+            \"Atlantic/Cape_Verde\", \"Pacific/Kiritimati\", \"Pacific/Chatham\", \"Pacific/Auckland\", \"Asia/Sakhalin\", \"Australia/Tasmania\", \n+            \"Australia/North\", \"Asia/Tokyo\", \"Australia/Eucla\", \"Asia/Singapore\", \"Asia/Rangoon\", \"Indian/Chagos\", \"Asia/Calcutta\", \n+            \"Asia/Tashkent\", \"Asia/Tehran\", \"Asia/Dubai\", \"Africa/Nairobi\", \"Europe/Brussels\", \"Europe/Vienna\", \"Europe/London\", \n+            \"Etc/GMT+12\",\n+            // short names of zones\n+            \"GMT\", \"UTC\", \"CET\",\n+            // offsets\n+            \"+11:00\", \"+04:30\", \"+01:00\", \"+00:00\", \"-00:00\", \"-01:15\", \"-02:00\", \"-11:00\");\n+\n+        private final int id;\n+        private final BigDecimal secondsAndFractionsSinceEpoch;\n+        private final String formatString;\n+        private final String zoneId;\n+        \n+        TestCase(BigDecimal secondsAndFractionsSinceEpoch, String formatString) {\n+            this.id = COUNTER.incrementAndGet();\n+            this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+            this.formatString = formatString;\n+            this.zoneId = TestGenerator.randomFromCollection(POSTGRES_TEST_ZONE_LIST);\n+        }\n+\n+    }\n+\n+    /**\n+     * Generates an sql file that can be used to generate the test dataset for this unit test (to be used with the <code>psql</code> cli).\n+     *\n+     * Run the @{link {@link TestGenerator#main(String[])}} class and execute the following command to generate the output dataset with:\n+     *\n+     * <p>\n+     *  <code>\n+     *      # easy way to spin up the latest Postgres\n+     *      docker run --rm --name postgres-latest -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres:latest\n+     *\n+     *      # generate the csv for the unit test\n+     *      PGPASSWORD=\"mysecretpassword\" psql --quiet -h localhost -p 5432 -U postgres -f /tmp/postgresql-tochar-test.sql \\\n+     *          &gt; /path/to/tochar.csv\n+     *  </code>\n+     * </p>\n+     */\n+    private static class TestGenerator {\n+        \n+        private static final long SECONDS_IN_YEAR = 365 * 24 * 60 * 60L;\n+        private static final String DELIMITER = \"|\";\n+        private static final String PATTERN_DELIMITER = \" @ \";\n+        // these patterns are hard to sync up between PostgreSQL and Elasticsearch, so we just warn, but actually\n+        // accept the output of Elasticsearch as is\n+        private static final Set<String> NOT_FULLY_MATCHABLE_PATTERNS = Set.of(\"TZ\", \"tz\");\n+        private static final Set<String> UNSUPPORTED_PATTERN_MODIFIERS = Set.of(\"FX\", \"TM\", \"SP\");\n+        private static final String[] PATTERNS = new String[] {\n+            \"HH\", \"HH12\", \"HH24\", \"MI\", \"SS\", \"MS\", \"US\", \"FF1\", \"FF2\", \"FF3\", \"FF4\", \"FF5\", \"FF6\", \"SSSS\", \"SSSSS\", \"AM\", \"am\", \"PM\",\n+            \"pm\", \"A.M.\", \"a.m.\", \"P.M.\", \"p.m.\", \"Y,YYY\", \"YYYY\", \"YYY\", \"YY\", \"Y\", \"IYYY\", \"IYY\", \"IY\", \"I\", \"BC\", \"bc\", \"AD\", \"ad\",\n+            \"B.C.\", \"b.c.\", \"A.D.\", \"a.d.\", \"MONTH\", \"Month\", \"month\", \"MON\", \"Mon\", \"mon\", \"MM\", \"DAY\", \"Day\", \"day\", \"DY\", \"Dy\",\n+            \"dy\", \"DDD\", \"IDDD\", \"DD\", \"D\", \"ID\", \"W\", \"WW\", \"IW\", \"CC\", \"J\", \"Q\", \"RM\", \"rm\", \"TZ\", \"tz\", \"TZH\", \"TZM\", \"OF\"\n+        };\n+        private static final List<String> FILL_MODIFIERS = List.of(\"FM\", \"fm\", \"\");\n+        private static final List<String> ORDINAL_SUFFIX_MODIFIERS = List.of(\"TH\", \"th\", \"\");\n+\n+        @SuppressForbidden(reason = \"It is ok to use ThreadLocalRandom outside of an actual test\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA1MDEzNg=="}, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NDQ4NzI1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNjozOToxNFrOIOegvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxNjowNjoxOVrOIPyUDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA1MDg3Nw==", "bodyText": "What the reason for this values? 50, 5, -1200?", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552050877", "createdAt": "2021-01-05T16:39:14Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    private static class TestCase {\n+        private static final AtomicInteger COUNTER = new AtomicInteger(0);\n+        \n+        // timezones that are valid both in Java and in Postgres\n+        public static final List<String> POSTGRES_TEST_ZONE_LIST = List.of(\n+            // location-based and long-names\n+            \"US/Samoa\", \"Pacific/Honolulu\", \"Pacific/Marquesas\", \"Pacific/Gambier\", \"America/Juneau\", \"Canada/Yukon\", \"America/Vancouver\",\n+            \"Pacific/Easter\", \"US/Mountain\", \"America/Chicago\", \"US/Michigan\", \"Atlantic/Bermuda\", \"Canada/Newfoundland\",\n+            \"Atlantic/Cape_Verde\", \"Pacific/Kiritimati\", \"Pacific/Chatham\", \"Pacific/Auckland\", \"Asia/Sakhalin\", \"Australia/Tasmania\", \n+            \"Australia/North\", \"Asia/Tokyo\", \"Australia/Eucla\", \"Asia/Singapore\", \"Asia/Rangoon\", \"Indian/Chagos\", \"Asia/Calcutta\", \n+            \"Asia/Tashkent\", \"Asia/Tehran\", \"Asia/Dubai\", \"Africa/Nairobi\", \"Europe/Brussels\", \"Europe/Vienna\", \"Europe/London\", \n+            \"Etc/GMT+12\",\n+            // short names of zones\n+            \"GMT\", \"UTC\", \"CET\",\n+            // offsets\n+            \"+11:00\", \"+04:30\", \"+01:00\", \"+00:00\", \"-00:00\", \"-01:15\", \"-02:00\", \"-11:00\");\n+\n+        private final int id;\n+        private final BigDecimal secondsAndFractionsSinceEpoch;\n+        private final String formatString;\n+        private final String zoneId;\n+        \n+        TestCase(BigDecimal secondsAndFractionsSinceEpoch, String formatString) {\n+            this.id = COUNTER.incrementAndGet();\n+            this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+            this.formatString = formatString;\n+            this.zoneId = TestGenerator.randomFromCollection(POSTGRES_TEST_ZONE_LIST);\n+        }\n+\n+    }\n+\n+    /**\n+     * Generates an sql file that can be used to generate the test dataset for this unit test (to be used with the <code>psql</code> cli).\n+     *\n+     * Run the @{link {@link TestGenerator#main(String[])}} class and execute the following command to generate the output dataset with:\n+     *\n+     * <p>\n+     *  <code>\n+     *      # easy way to spin up the latest Postgres\n+     *      docker run --rm --name postgres-latest -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres:latest\n+     *\n+     *      # generate the csv for the unit test\n+     *      PGPASSWORD=\"mysecretpassword\" psql --quiet -h localhost -p 5432 -U postgres -f /tmp/postgresql-tochar-test.sql \\\n+     *          &gt; /path/to/tochar.csv\n+     *  </code>\n+     * </p>\n+     */\n+    private static class TestGenerator {\n+        \n+        private static final long SECONDS_IN_YEAR = 365 * 24 * 60 * 60L;\n+        private static final String DELIMITER = \"|\";\n+        private static final String PATTERN_DELIMITER = \" @ \";\n+        // these patterns are hard to sync up between PostgreSQL and Elasticsearch, so we just warn, but actually\n+        // accept the output of Elasticsearch as is\n+        private static final Set<String> NOT_FULLY_MATCHABLE_PATTERNS = Set.of(\"TZ\", \"tz\");\n+        private static final Set<String> UNSUPPORTED_PATTERN_MODIFIERS = Set.of(\"FX\", \"TM\", \"SP\");\n+        private static final String[] PATTERNS = new String[] {\n+            \"HH\", \"HH12\", \"HH24\", \"MI\", \"SS\", \"MS\", \"US\", \"FF1\", \"FF2\", \"FF3\", \"FF4\", \"FF5\", \"FF6\", \"SSSS\", \"SSSSS\", \"AM\", \"am\", \"PM\",\n+            \"pm\", \"A.M.\", \"a.m.\", \"P.M.\", \"p.m.\", \"Y,YYY\", \"YYYY\", \"YYY\", \"YY\", \"Y\", \"IYYY\", \"IYY\", \"IY\", \"I\", \"BC\", \"bc\", \"AD\", \"ad\",\n+            \"B.C.\", \"b.c.\", \"A.D.\", \"a.d.\", \"MONTH\", \"Month\", \"month\", \"MON\", \"Mon\", \"mon\", \"MM\", \"DAY\", \"Day\", \"day\", \"DY\", \"Dy\",\n+            \"dy\", \"DDD\", \"IDDD\", \"DD\", \"D\", \"ID\", \"W\", \"WW\", \"IW\", \"CC\", \"J\", \"Q\", \"RM\", \"rm\", \"TZ\", \"tz\", \"TZH\", \"TZM\", \"OF\"\n+        };\n+        private static final List<String> FILL_MODIFIERS = List.of(\"FM\", \"fm\", \"\");\n+        private static final List<String> ORDINAL_SUFFIX_MODIFIERS = List.of(\"TH\", \"th\", \"\");\n+\n+        @SuppressForbidden(reason = \"It is ok to use ThreadLocalRandom outside of an actual test\")\n+        private static Random rnd() {\n+            return ThreadLocalRandom.current();\n+        }\n+\n+        private static BigDecimal randomSecondsWithFractions(int minYear, int maxYear) {\n+            BigDecimal seconds = new BigDecimal(RandomNumbers.randomLongBetween(rnd(), \n+                (minYear - 1970) * SECONDS_IN_YEAR, (maxYear - 1970) * SECONDS_IN_YEAR));\n+            BigDecimal fractions = new BigDecimal(RandomNumbers.randomIntBetween(rnd(), 0, 999_999)).movePointLeft(6);\n+            return seconds.add(fractions);\n+        }\n+\n+        private static <T> T randomFromCollection(Collection<T> list) {\n+            List<T> l = new ArrayList<>(list);\n+            return l.get(rnd().nextInt(l.size()));\n+        }\n+        \n+        private static String patternWithRandomModifiers(String pattern) {\n+            if (NOT_FULLY_MATCHABLE_PATTERNS.contains(pattern)) {\n+                return pattern;\n+            }\n+            return randomFromCollection(FILL_MODIFIERS) + pattern + randomFromCollection(ORDINAL_SUFFIX_MODIFIERS);\n+        }\n+    \n+        private static List<TestCase> generateTestCases() {\n+            \n+            final List<BigDecimal> testEpochSeconds = new LinkedList<>();\n+            for (int i = 0; i < 50; i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQyMzg4Ng==", "bodyText": "Extracted into variables to add some context and meaning to these constants. There is no particular reason why those numbers were picked, felt they provide \"good enough\" coverage, they can be changed/increased.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r553423886", "createdAt": "2021-01-07T16:06:19Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    private static class TestCase {\n+        private static final AtomicInteger COUNTER = new AtomicInteger(0);\n+        \n+        // timezones that are valid both in Java and in Postgres\n+        public static final List<String> POSTGRES_TEST_ZONE_LIST = List.of(\n+            // location-based and long-names\n+            \"US/Samoa\", \"Pacific/Honolulu\", \"Pacific/Marquesas\", \"Pacific/Gambier\", \"America/Juneau\", \"Canada/Yukon\", \"America/Vancouver\",\n+            \"Pacific/Easter\", \"US/Mountain\", \"America/Chicago\", \"US/Michigan\", \"Atlantic/Bermuda\", \"Canada/Newfoundland\",\n+            \"Atlantic/Cape_Verde\", \"Pacific/Kiritimati\", \"Pacific/Chatham\", \"Pacific/Auckland\", \"Asia/Sakhalin\", \"Australia/Tasmania\", \n+            \"Australia/North\", \"Asia/Tokyo\", \"Australia/Eucla\", \"Asia/Singapore\", \"Asia/Rangoon\", \"Indian/Chagos\", \"Asia/Calcutta\", \n+            \"Asia/Tashkent\", \"Asia/Tehran\", \"Asia/Dubai\", \"Africa/Nairobi\", \"Europe/Brussels\", \"Europe/Vienna\", \"Europe/London\", \n+            \"Etc/GMT+12\",\n+            // short names of zones\n+            \"GMT\", \"UTC\", \"CET\",\n+            // offsets\n+            \"+11:00\", \"+04:30\", \"+01:00\", \"+00:00\", \"-00:00\", \"-01:15\", \"-02:00\", \"-11:00\");\n+\n+        private final int id;\n+        private final BigDecimal secondsAndFractionsSinceEpoch;\n+        private final String formatString;\n+        private final String zoneId;\n+        \n+        TestCase(BigDecimal secondsAndFractionsSinceEpoch, String formatString) {\n+            this.id = COUNTER.incrementAndGet();\n+            this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+            this.formatString = formatString;\n+            this.zoneId = TestGenerator.randomFromCollection(POSTGRES_TEST_ZONE_LIST);\n+        }\n+\n+    }\n+\n+    /**\n+     * Generates an sql file that can be used to generate the test dataset for this unit test (to be used with the <code>psql</code> cli).\n+     *\n+     * Run the @{link {@link TestGenerator#main(String[])}} class and execute the following command to generate the output dataset with:\n+     *\n+     * <p>\n+     *  <code>\n+     *      # easy way to spin up the latest Postgres\n+     *      docker run --rm --name postgres-latest -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres:latest\n+     *\n+     *      # generate the csv for the unit test\n+     *      PGPASSWORD=\"mysecretpassword\" psql --quiet -h localhost -p 5432 -U postgres -f /tmp/postgresql-tochar-test.sql \\\n+     *          &gt; /path/to/tochar.csv\n+     *  </code>\n+     * </p>\n+     */\n+    private static class TestGenerator {\n+        \n+        private static final long SECONDS_IN_YEAR = 365 * 24 * 60 * 60L;\n+        private static final String DELIMITER = \"|\";\n+        private static final String PATTERN_DELIMITER = \" @ \";\n+        // these patterns are hard to sync up between PostgreSQL and Elasticsearch, so we just warn, but actually\n+        // accept the output of Elasticsearch as is\n+        private static final Set<String> NOT_FULLY_MATCHABLE_PATTERNS = Set.of(\"TZ\", \"tz\");\n+        private static final Set<String> UNSUPPORTED_PATTERN_MODIFIERS = Set.of(\"FX\", \"TM\", \"SP\");\n+        private static final String[] PATTERNS = new String[] {\n+            \"HH\", \"HH12\", \"HH24\", \"MI\", \"SS\", \"MS\", \"US\", \"FF1\", \"FF2\", \"FF3\", \"FF4\", \"FF5\", \"FF6\", \"SSSS\", \"SSSSS\", \"AM\", \"am\", \"PM\",\n+            \"pm\", \"A.M.\", \"a.m.\", \"P.M.\", \"p.m.\", \"Y,YYY\", \"YYYY\", \"YYY\", \"YY\", \"Y\", \"IYYY\", \"IYY\", \"IY\", \"I\", \"BC\", \"bc\", \"AD\", \"ad\",\n+            \"B.C.\", \"b.c.\", \"A.D.\", \"a.d.\", \"MONTH\", \"Month\", \"month\", \"MON\", \"Mon\", \"mon\", \"MM\", \"DAY\", \"Day\", \"day\", \"DY\", \"Dy\",\n+            \"dy\", \"DDD\", \"IDDD\", \"DD\", \"D\", \"ID\", \"W\", \"WW\", \"IW\", \"CC\", \"J\", \"Q\", \"RM\", \"rm\", \"TZ\", \"tz\", \"TZH\", \"TZM\", \"OF\"\n+        };\n+        private static final List<String> FILL_MODIFIERS = List.of(\"FM\", \"fm\", \"\");\n+        private static final List<String> ORDINAL_SUFFIX_MODIFIERS = List.of(\"TH\", \"th\", \"\");\n+\n+        @SuppressForbidden(reason = \"It is ok to use ThreadLocalRandom outside of an actual test\")\n+        private static Random rnd() {\n+            return ThreadLocalRandom.current();\n+        }\n+\n+        private static BigDecimal randomSecondsWithFractions(int minYear, int maxYear) {\n+            BigDecimal seconds = new BigDecimal(RandomNumbers.randomLongBetween(rnd(), \n+                (minYear - 1970) * SECONDS_IN_YEAR, (maxYear - 1970) * SECONDS_IN_YEAR));\n+            BigDecimal fractions = new BigDecimal(RandomNumbers.randomIntBetween(rnd(), 0, 999_999)).movePointLeft(6);\n+            return seconds.add(fractions);\n+        }\n+\n+        private static <T> T randomFromCollection(Collection<T> list) {\n+            List<T> l = new ArrayList<>(list);\n+            return l.get(rnd().nextInt(l.size()));\n+        }\n+        \n+        private static String patternWithRandomModifiers(String pattern) {\n+            if (NOT_FULLY_MATCHABLE_PATTERNS.contains(pattern)) {\n+                return pattern;\n+            }\n+            return randomFromCollection(FILL_MODIFIERS) + pattern + randomFromCollection(ORDINAL_SUFFIX_MODIFIERS);\n+        }\n+    \n+        private static List<TestCase> generateTestCases() {\n+            \n+            final List<BigDecimal> testEpochSeconds = new LinkedList<>();\n+            for (int i = 0; i < 50; i++) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA1MDg3Nw=="}, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 133}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NDUwNjkyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNjo0NDo0N1rOIOetSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQyMTo0NTo1MVrOIOoupw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA1NDA4OA==", "bodyText": "Alignment is off", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552054088", "createdAt": "2021-01-05T16:44:47Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    private static class TestCase {\n+        private static final AtomicInteger COUNTER = new AtomicInteger(0);\n+        \n+        // timezones that are valid both in Java and in Postgres\n+        public static final List<String> POSTGRES_TEST_ZONE_LIST = List.of(\n+            // location-based and long-names\n+            \"US/Samoa\", \"Pacific/Honolulu\", \"Pacific/Marquesas\", \"Pacific/Gambier\", \"America/Juneau\", \"Canada/Yukon\", \"America/Vancouver\",\n+            \"Pacific/Easter\", \"US/Mountain\", \"America/Chicago\", \"US/Michigan\", \"Atlantic/Bermuda\", \"Canada/Newfoundland\",\n+            \"Atlantic/Cape_Verde\", \"Pacific/Kiritimati\", \"Pacific/Chatham\", \"Pacific/Auckland\", \"Asia/Sakhalin\", \"Australia/Tasmania\", \n+            \"Australia/North\", \"Asia/Tokyo\", \"Australia/Eucla\", \"Asia/Singapore\", \"Asia/Rangoon\", \"Indian/Chagos\", \"Asia/Calcutta\", \n+            \"Asia/Tashkent\", \"Asia/Tehran\", \"Asia/Dubai\", \"Africa/Nairobi\", \"Europe/Brussels\", \"Europe/Vienna\", \"Europe/London\", \n+            \"Etc/GMT+12\",\n+            // short names of zones\n+            \"GMT\", \"UTC\", \"CET\",\n+            // offsets\n+            \"+11:00\", \"+04:30\", \"+01:00\", \"+00:00\", \"-00:00\", \"-01:15\", \"-02:00\", \"-11:00\");\n+\n+        private final int id;\n+        private final BigDecimal secondsAndFractionsSinceEpoch;\n+        private final String formatString;\n+        private final String zoneId;\n+        \n+        TestCase(BigDecimal secondsAndFractionsSinceEpoch, String formatString) {\n+            this.id = COUNTER.incrementAndGet();\n+            this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+            this.formatString = formatString;\n+            this.zoneId = TestGenerator.randomFromCollection(POSTGRES_TEST_ZONE_LIST);\n+        }\n+\n+    }\n+\n+    /**\n+     * Generates an sql file that can be used to generate the test dataset for this unit test (to be used with the <code>psql</code> cli).\n+     *\n+     * Run the @{link {@link TestGenerator#main(String[])}} class and execute the following command to generate the output dataset with:\n+     *\n+     * <p>\n+     *  <code>\n+     *      # easy way to spin up the latest Postgres\n+     *      docker run --rm --name postgres-latest -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres:latest\n+     *\n+     *      # generate the csv for the unit test\n+     *      PGPASSWORD=\"mysecretpassword\" psql --quiet -h localhost -p 5432 -U postgres -f /tmp/postgresql-tochar-test.sql \\\n+     *          &gt; /path/to/tochar.csv\n+     *  </code>\n+     * </p>\n+     */\n+    private static class TestGenerator {\n+        \n+        private static final long SECONDS_IN_YEAR = 365 * 24 * 60 * 60L;\n+        private static final String DELIMITER = \"|\";\n+        private static final String PATTERN_DELIMITER = \" @ \";\n+        // these patterns are hard to sync up between PostgreSQL and Elasticsearch, so we just warn, but actually\n+        // accept the output of Elasticsearch as is\n+        private static final Set<String> NOT_FULLY_MATCHABLE_PATTERNS = Set.of(\"TZ\", \"tz\");\n+        private static final Set<String> UNSUPPORTED_PATTERN_MODIFIERS = Set.of(\"FX\", \"TM\", \"SP\");\n+        private static final String[] PATTERNS = new String[] {\n+            \"HH\", \"HH12\", \"HH24\", \"MI\", \"SS\", \"MS\", \"US\", \"FF1\", \"FF2\", \"FF3\", \"FF4\", \"FF5\", \"FF6\", \"SSSS\", \"SSSSS\", \"AM\", \"am\", \"PM\",\n+            \"pm\", \"A.M.\", \"a.m.\", \"P.M.\", \"p.m.\", \"Y,YYY\", \"YYYY\", \"YYY\", \"YY\", \"Y\", \"IYYY\", \"IYY\", \"IY\", \"I\", \"BC\", \"bc\", \"AD\", \"ad\",\n+            \"B.C.\", \"b.c.\", \"A.D.\", \"a.d.\", \"MONTH\", \"Month\", \"month\", \"MON\", \"Mon\", \"mon\", \"MM\", \"DAY\", \"Day\", \"day\", \"DY\", \"Dy\",\n+            \"dy\", \"DDD\", \"IDDD\", \"DD\", \"D\", \"ID\", \"W\", \"WW\", \"IW\", \"CC\", \"J\", \"Q\", \"RM\", \"rm\", \"TZ\", \"tz\", \"TZH\", \"TZM\", \"OF\"\n+        };\n+        private static final List<String> FILL_MODIFIERS = List.of(\"FM\", \"fm\", \"\");\n+        private static final List<String> ORDINAL_SUFFIX_MODIFIERS = List.of(\"TH\", \"th\", \"\");\n+\n+        @SuppressForbidden(reason = \"It is ok to use ThreadLocalRandom outside of an actual test\")\n+        private static Random rnd() {\n+            return ThreadLocalRandom.current();\n+        }\n+\n+        private static BigDecimal randomSecondsWithFractions(int minYear, int maxYear) {\n+            BigDecimal seconds = new BigDecimal(RandomNumbers.randomLongBetween(rnd(), \n+                (minYear - 1970) * SECONDS_IN_YEAR, (maxYear - 1970) * SECONDS_IN_YEAR));\n+            BigDecimal fractions = new BigDecimal(RandomNumbers.randomIntBetween(rnd(), 0, 999_999)).movePointLeft(6);\n+            return seconds.add(fractions);\n+        }\n+\n+        private static <T> T randomFromCollection(Collection<T> list) {\n+            List<T> l = new ArrayList<>(list);\n+            return l.get(rnd().nextInt(l.size()));\n+        }\n+        \n+        private static String patternWithRandomModifiers(String pattern) {\n+            if (NOT_FULLY_MATCHABLE_PATTERNS.contains(pattern)) {\n+                return pattern;\n+            }\n+            return randomFromCollection(FILL_MODIFIERS) + pattern + randomFromCollection(ORDINAL_SUFFIX_MODIFIERS);\n+        }\n+    \n+        private static List<TestCase> generateTestCases() {\n+            \n+            final List<BigDecimal> testEpochSeconds = new LinkedList<>();\n+            for (int i = 0; i < 50; i++) {\n+                testEpochSeconds.add(randomSecondsWithFractions(-1200, 2500));\n+            }\n+            for (int i = 0; i < 5; i++) {\n+                testEpochSeconds.add(randomSecondsWithFractions(-1, 1));\n+            }\n+    \n+            List<TestCase> testCases = new ArrayList<>();\n+    \n+            // check each format string alone\n+            for (String pattern : PATTERNS) {\n+                testCases.add(new TestCase(randomFromCollection(testEpochSeconds), NOT_FULLY_MATCHABLE_PATTERNS.contains(pattern) \n+                    ? pattern \n+                    : String.join(PATTERN_DELIMITER, pattern, FILL_MODIFIERS.get(0) + pattern + ORDINAL_SUFFIX_MODIFIERS.get(0))));\n+            }\n+            \n+            // let's check all of the format strings with a non-ambiguous format string\n+            for (BigDecimal es : testEpochSeconds) {\n+                testCases.add(new TestCase(es, IntStream.range(0, PATTERNS.length)\n+                    .mapToObj(idx -> idx + \":\" + patternWithRandomModifiers(PATTERNS[idx]))\n+                    .collect(Collectors.joining(PATTERN_DELIMITER))));\n+            }\n+    \n+            // check the lowercase versions of the format strings\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), IntStream.range(0, PATTERNS.length)\n+                .mapToObj(idx -> (idx + \":\" + patternWithRandomModifiers(PATTERNS[idx])).toLowerCase(Locale.ROOT))\n+                .collect(Collectors.joining(PATTERN_DELIMITER))));\n+    \n+            // potentially ambiguous format string test cases, to check if our format string parsing is in-sync with PostgreSQL\n+            // greedy and prefers the longer format strings\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"YYYYYYYYYYYYYYY,YYYYYYYYY\"));\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"SSSSSSSSSSSSSSSS\"));\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"DDDDDDDD\"));\n+    \n+            // Roman numbers\n+            for (int i = 1; i <= 12; i++) {\n+                testCases.add(new TestCase(\n+                    new BigDecimal(dateTime(0).withMonth(i).toEpochSecond()), rnd().nextBoolean() ? \"RM\" : \"rm\"));\n+            }\n+            \n+            // random strings made out of template patterns and random characters\n+            final String randomCharacters = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYabcdefghijklmnopqrstuvwxy _-.:;\";\n+            final List<String> formatStringsToRandomTest = Arrays.stream(PATTERNS)\n+                .filter(s -> NOT_FULLY_MATCHABLE_PATTERNS.contains(s) == false)\n+                .collect(Collectors.toList());\n+            \n+            for (int i = 0; i < 20; i++) {\n+                String patternWithLiterals = IntStream.rangeClosed(1, 30).mapToObj(idx -> \n+                    rnd().nextInt(100) < 80 \n+                        ? randomCharacters.substring(rnd().nextInt(randomCharacters.length())).substring(0, 1) \n+                        : (randomFromCollection(FILL_MODIFIERS) \n+                            + randomFromCollection(formatStringsToRandomTest) \n+                            + randomFromCollection(ORDINAL_SUFFIX_MODIFIERS)))\n+                    .collect(Collectors.joining());\n+                \n+                // clean up the random string from the unsupported modifiers\n+                for (String unsupportedPatternModifier : UNSUPPORTED_PATTERN_MODIFIERS) {\n+                    patternWithLiterals = patternWithLiterals\n+                        .replace(unsupportedPatternModifier, \"\")\n+                        .replace(unsupportedPatternModifier.toLowerCase(Locale.ROOT), \"\");\n+                }\n+                testCases.add(new TestCase(randomFromCollection(testEpochSeconds), patternWithLiterals));\n+            }\n+    \n+            return testCases;\n+        }\n+        \n+        private static String adjustZoneIdToPostgres(String zoneId) {\n+            // when the zone is specified by the offset in Postgres, it follows the POSIX definition, so the +- signs are flipped\n+            // compared to ISO-8601, see more info at: https://www.postgresql.org/docs/current/datetime-posix-timezone-specs.html\n+            if (zoneId.startsWith(\"+\")) {\n+                zoneId = zoneId.replaceFirst(quote(\"+\"), \"-\");\n+            } else if (zoneId.startsWith(\"-\")) {\n+                zoneId = zoneId.replaceFirst(quote(\"-\"), \"+\");\n+            }\n+            return zoneId;\n+        }\n+        \n+        /**\n+         * Generates an SQL file that can be used to create the test dataset for the unit test of the <code>TO_CHAR</code>\n+         * implementation. In case the <code>TO_CHAR</code> implementation needs an upgrade, add the list of the new format\n+         * strings to the list of the format string, regenerate the SQL, run it against the PostgreSQL version you are targeting\n+         * and update the test CSV file.\n+         */\n+        private static String unitTestExporterScript() {\n+            return generateTestCases().stream().map(tc -> {\n+                long seconds = tc.secondsAndFractionsSinceEpoch.longValue();\n+                BigDecimal fractions = tc.secondsAndFractionsSinceEpoch.remainder(BigDecimal.ONE).movePointRight(6);\n+                return String.format(Locale.ROOT,\n+                    \"SET TIME ZONE '%7$s';\\n\" +\n+                    \"\\\\copy (SELECT %1$d as id, %2$s as epoch_seconds_and_microsends, '%6$s' as zone_id, '%5$s' as format_string, \" +\n+                        \"(TO_TIMESTAMP(%3$d) + INTERVAL '%4$d microseconds') as to_timestamp_result, \" +\n+                        \"TO_CHAR((TO_TIMESTAMP(%3$d) + INTERVAL '%4$d microseconds'), '%5$s') as to_char_result) to stdout \" +\n+                        \"with DELIMITER as '\" + DELIMITER + \"' NULL as '' csv \\n\",\n+                    tc.id, tc.secondsAndFractionsSinceEpoch.toPlainString(), seconds, fractions.intValue(), tc.formatString, tc.zoneId, \n+                    adjustZoneIdToPostgres(tc.zoneId)\n+                );\n+            }).collect(Collectors.joining(\"\\n\"));\n+        }\n+        \n+        public static void main(String[] args) throws Exception {\n+            String scriptFilename = args.length < 1 ? \"/tmp/postgresql-tochar-test.sql\" : args[0];\n+            Files.writeString(Path.of(scriptFilename), unitTestExporterScript(), StandardCharsets.UTF_8);\n+        }\n+    }\n+\n+    @ParametersFactory(argumentFormatting = \"%1$s: timestamp=%5$s, zone=%3$s, format=%4$s\")\n+    public static List<Object[]> readCsv() throws Exception {\n+        Path testFilePath = Path.of(DateTimeToCharProcessorTests.class.getResource(\"tochar.csv\").toURI());\n+        return Files.readAllLines(testFilePath).stream().map(line -> {\n+            String[] cols = line.split(quote(TestGenerator.DELIMITER));\n+            return new Object[]{ cols[0], cols[1], cols[2], cols[3], cols[4], cols[5] };\n+        }).collect(Collectors.toList());\n+    }\n+\n+    private final String id;\n+    private final String secondsAndFractionsSinceEpoch;\n+    private final String zone;\n+    private final String formatString;\n+    private final String posgresTimestamp;\n+    private final String expectedResult;\n+\n+    public DateTimeToCharProcessorTests(String id, String secondsAndFractionsSinceEpoch, String zone, String formatString,\n+        String postgresTimestamp, String expectedResult) {\n+        this.id = id;\n+        this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+        this.zone = zone;\n+        this.formatString = formatString;\n+        this.posgresTimestamp = postgresTimestamp;\n+        this.expectedResult = expectedResult;\n+    }\n+\n+    private static ZonedDateTime dateTimeWithFractions(String secondAndFractionsSinceEpoch) {\n+        BigDecimal b = new BigDecimal(secondAndFractionsSinceEpoch);\n+        long seconds = b.longValue();\n+        int fractions = b.remainder(BigDecimal.ONE).movePointRight(9).intValueExact();\n+        int adjustment = 0;\n+        if (fractions < 0) {\n+            fractions += 1e9;\n+            adjustment = -1;\n+        }\n+        return dateTime((seconds + adjustment) * 1000).withNano(fractions);\n+    }\n+    \n+    public void test() throws Exception {\n+        ZoneId zoneId = ZoneId.of(zone);\n+        ZonedDateTime timestamp = dateTimeWithFractions(secondsAndFractionsSinceEpoch);\n+        String actualResult =\n+            (String) new ToChar(Source.EMPTY, l(timestamp, DataTypes.DATETIME), l(formatString, DataTypes.KEYWORD), zoneId)\n+                .makePipe()\n+                .asProcessor()\n+                .process(null);\n+        List<String> expectedResultSplitted = List.of(expectedResult.split(quote(TestGenerator.PATTERN_DELIMITER)));\n+        List<String> resultSplitted = List.of(actualResult.split(quote(TestGenerator.PATTERN_DELIMITER)));\n+        List<String> formatStringSplitted = List.of(formatString.split(TestGenerator.PATTERN_DELIMITER));\n+        assertEquals(formatStringSplitted.size(), resultSplitted.size());\n+        assertEquals(formatStringSplitted.size(), expectedResultSplitted.size());\n+        for (int i = 0; i < formatStringSplitted.size(); i++) {\n+            String patternMaybeWithIndex = formatStringSplitted.get(i);\n+            String pattern = patternMaybeWithIndex.contains(\":\") \n+                ? patternMaybeWithIndex.substring(patternMaybeWithIndex.indexOf(\":\") + 1)\n+                : patternMaybeWithIndex;\n+            String expectedPart = expectedResultSplitted.get(i);\n+            String actualPart = resultSplitted.get(i);\n+            try {\n+                assertEquals(\n+                    String.format(Locale.ROOT, \n+                        \"\\nTest id:                            %s\\n\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 300}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIxODI3OQ==", "bodyText": "It is aligned, notice the \\n at the beginning (will separate that out into new line, so it's more obvious).", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552218279", "createdAt": "2021-01-05T21:45:51Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    private static class TestCase {\n+        private static final AtomicInteger COUNTER = new AtomicInteger(0);\n+        \n+        // timezones that are valid both in Java and in Postgres\n+        public static final List<String> POSTGRES_TEST_ZONE_LIST = List.of(\n+            // location-based and long-names\n+            \"US/Samoa\", \"Pacific/Honolulu\", \"Pacific/Marquesas\", \"Pacific/Gambier\", \"America/Juneau\", \"Canada/Yukon\", \"America/Vancouver\",\n+            \"Pacific/Easter\", \"US/Mountain\", \"America/Chicago\", \"US/Michigan\", \"Atlantic/Bermuda\", \"Canada/Newfoundland\",\n+            \"Atlantic/Cape_Verde\", \"Pacific/Kiritimati\", \"Pacific/Chatham\", \"Pacific/Auckland\", \"Asia/Sakhalin\", \"Australia/Tasmania\", \n+            \"Australia/North\", \"Asia/Tokyo\", \"Australia/Eucla\", \"Asia/Singapore\", \"Asia/Rangoon\", \"Indian/Chagos\", \"Asia/Calcutta\", \n+            \"Asia/Tashkent\", \"Asia/Tehran\", \"Asia/Dubai\", \"Africa/Nairobi\", \"Europe/Brussels\", \"Europe/Vienna\", \"Europe/London\", \n+            \"Etc/GMT+12\",\n+            // short names of zones\n+            \"GMT\", \"UTC\", \"CET\",\n+            // offsets\n+            \"+11:00\", \"+04:30\", \"+01:00\", \"+00:00\", \"-00:00\", \"-01:15\", \"-02:00\", \"-11:00\");\n+\n+        private final int id;\n+        private final BigDecimal secondsAndFractionsSinceEpoch;\n+        private final String formatString;\n+        private final String zoneId;\n+        \n+        TestCase(BigDecimal secondsAndFractionsSinceEpoch, String formatString) {\n+            this.id = COUNTER.incrementAndGet();\n+            this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+            this.formatString = formatString;\n+            this.zoneId = TestGenerator.randomFromCollection(POSTGRES_TEST_ZONE_LIST);\n+        }\n+\n+    }\n+\n+    /**\n+     * Generates an sql file that can be used to generate the test dataset for this unit test (to be used with the <code>psql</code> cli).\n+     *\n+     * Run the @{link {@link TestGenerator#main(String[])}} class and execute the following command to generate the output dataset with:\n+     *\n+     * <p>\n+     *  <code>\n+     *      # easy way to spin up the latest Postgres\n+     *      docker run --rm --name postgres-latest -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres:latest\n+     *\n+     *      # generate the csv for the unit test\n+     *      PGPASSWORD=\"mysecretpassword\" psql --quiet -h localhost -p 5432 -U postgres -f /tmp/postgresql-tochar-test.sql \\\n+     *          &gt; /path/to/tochar.csv\n+     *  </code>\n+     * </p>\n+     */\n+    private static class TestGenerator {\n+        \n+        private static final long SECONDS_IN_YEAR = 365 * 24 * 60 * 60L;\n+        private static final String DELIMITER = \"|\";\n+        private static final String PATTERN_DELIMITER = \" @ \";\n+        // these patterns are hard to sync up between PostgreSQL and Elasticsearch, so we just warn, but actually\n+        // accept the output of Elasticsearch as is\n+        private static final Set<String> NOT_FULLY_MATCHABLE_PATTERNS = Set.of(\"TZ\", \"tz\");\n+        private static final Set<String> UNSUPPORTED_PATTERN_MODIFIERS = Set.of(\"FX\", \"TM\", \"SP\");\n+        private static final String[] PATTERNS = new String[] {\n+            \"HH\", \"HH12\", \"HH24\", \"MI\", \"SS\", \"MS\", \"US\", \"FF1\", \"FF2\", \"FF3\", \"FF4\", \"FF5\", \"FF6\", \"SSSS\", \"SSSSS\", \"AM\", \"am\", \"PM\",\n+            \"pm\", \"A.M.\", \"a.m.\", \"P.M.\", \"p.m.\", \"Y,YYY\", \"YYYY\", \"YYY\", \"YY\", \"Y\", \"IYYY\", \"IYY\", \"IY\", \"I\", \"BC\", \"bc\", \"AD\", \"ad\",\n+            \"B.C.\", \"b.c.\", \"A.D.\", \"a.d.\", \"MONTH\", \"Month\", \"month\", \"MON\", \"Mon\", \"mon\", \"MM\", \"DAY\", \"Day\", \"day\", \"DY\", \"Dy\",\n+            \"dy\", \"DDD\", \"IDDD\", \"DD\", \"D\", \"ID\", \"W\", \"WW\", \"IW\", \"CC\", \"J\", \"Q\", \"RM\", \"rm\", \"TZ\", \"tz\", \"TZH\", \"TZM\", \"OF\"\n+        };\n+        private static final List<String> FILL_MODIFIERS = List.of(\"FM\", \"fm\", \"\");\n+        private static final List<String> ORDINAL_SUFFIX_MODIFIERS = List.of(\"TH\", \"th\", \"\");\n+\n+        @SuppressForbidden(reason = \"It is ok to use ThreadLocalRandom outside of an actual test\")\n+        private static Random rnd() {\n+            return ThreadLocalRandom.current();\n+        }\n+\n+        private static BigDecimal randomSecondsWithFractions(int minYear, int maxYear) {\n+            BigDecimal seconds = new BigDecimal(RandomNumbers.randomLongBetween(rnd(), \n+                (minYear - 1970) * SECONDS_IN_YEAR, (maxYear - 1970) * SECONDS_IN_YEAR));\n+            BigDecimal fractions = new BigDecimal(RandomNumbers.randomIntBetween(rnd(), 0, 999_999)).movePointLeft(6);\n+            return seconds.add(fractions);\n+        }\n+\n+        private static <T> T randomFromCollection(Collection<T> list) {\n+            List<T> l = new ArrayList<>(list);\n+            return l.get(rnd().nextInt(l.size()));\n+        }\n+        \n+        private static String patternWithRandomModifiers(String pattern) {\n+            if (NOT_FULLY_MATCHABLE_PATTERNS.contains(pattern)) {\n+                return pattern;\n+            }\n+            return randomFromCollection(FILL_MODIFIERS) + pattern + randomFromCollection(ORDINAL_SUFFIX_MODIFIERS);\n+        }\n+    \n+        private static List<TestCase> generateTestCases() {\n+            \n+            final List<BigDecimal> testEpochSeconds = new LinkedList<>();\n+            for (int i = 0; i < 50; i++) {\n+                testEpochSeconds.add(randomSecondsWithFractions(-1200, 2500));\n+            }\n+            for (int i = 0; i < 5; i++) {\n+                testEpochSeconds.add(randomSecondsWithFractions(-1, 1));\n+            }\n+    \n+            List<TestCase> testCases = new ArrayList<>();\n+    \n+            // check each format string alone\n+            for (String pattern : PATTERNS) {\n+                testCases.add(new TestCase(randomFromCollection(testEpochSeconds), NOT_FULLY_MATCHABLE_PATTERNS.contains(pattern) \n+                    ? pattern \n+                    : String.join(PATTERN_DELIMITER, pattern, FILL_MODIFIERS.get(0) + pattern + ORDINAL_SUFFIX_MODIFIERS.get(0))));\n+            }\n+            \n+            // let's check all of the format strings with a non-ambiguous format string\n+            for (BigDecimal es : testEpochSeconds) {\n+                testCases.add(new TestCase(es, IntStream.range(0, PATTERNS.length)\n+                    .mapToObj(idx -> idx + \":\" + patternWithRandomModifiers(PATTERNS[idx]))\n+                    .collect(Collectors.joining(PATTERN_DELIMITER))));\n+            }\n+    \n+            // check the lowercase versions of the format strings\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), IntStream.range(0, PATTERNS.length)\n+                .mapToObj(idx -> (idx + \":\" + patternWithRandomModifiers(PATTERNS[idx])).toLowerCase(Locale.ROOT))\n+                .collect(Collectors.joining(PATTERN_DELIMITER))));\n+    \n+            // potentially ambiguous format string test cases, to check if our format string parsing is in-sync with PostgreSQL\n+            // greedy and prefers the longer format strings\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"YYYYYYYYYYYYYYY,YYYYYYYYY\"));\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"SSSSSSSSSSSSSSSS\"));\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"DDDDDDDD\"));\n+    \n+            // Roman numbers\n+            for (int i = 1; i <= 12; i++) {\n+                testCases.add(new TestCase(\n+                    new BigDecimal(dateTime(0).withMonth(i).toEpochSecond()), rnd().nextBoolean() ? \"RM\" : \"rm\"));\n+            }\n+            \n+            // random strings made out of template patterns and random characters\n+            final String randomCharacters = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYabcdefghijklmnopqrstuvwxy _-.:;\";\n+            final List<String> formatStringsToRandomTest = Arrays.stream(PATTERNS)\n+                .filter(s -> NOT_FULLY_MATCHABLE_PATTERNS.contains(s) == false)\n+                .collect(Collectors.toList());\n+            \n+            for (int i = 0; i < 20; i++) {\n+                String patternWithLiterals = IntStream.rangeClosed(1, 30).mapToObj(idx -> \n+                    rnd().nextInt(100) < 80 \n+                        ? randomCharacters.substring(rnd().nextInt(randomCharacters.length())).substring(0, 1) \n+                        : (randomFromCollection(FILL_MODIFIERS) \n+                            + randomFromCollection(formatStringsToRandomTest) \n+                            + randomFromCollection(ORDINAL_SUFFIX_MODIFIERS)))\n+                    .collect(Collectors.joining());\n+                \n+                // clean up the random string from the unsupported modifiers\n+                for (String unsupportedPatternModifier : UNSUPPORTED_PATTERN_MODIFIERS) {\n+                    patternWithLiterals = patternWithLiterals\n+                        .replace(unsupportedPatternModifier, \"\")\n+                        .replace(unsupportedPatternModifier.toLowerCase(Locale.ROOT), \"\");\n+                }\n+                testCases.add(new TestCase(randomFromCollection(testEpochSeconds), patternWithLiterals));\n+            }\n+    \n+            return testCases;\n+        }\n+        \n+        private static String adjustZoneIdToPostgres(String zoneId) {\n+            // when the zone is specified by the offset in Postgres, it follows the POSIX definition, so the +- signs are flipped\n+            // compared to ISO-8601, see more info at: https://www.postgresql.org/docs/current/datetime-posix-timezone-specs.html\n+            if (zoneId.startsWith(\"+\")) {\n+                zoneId = zoneId.replaceFirst(quote(\"+\"), \"-\");\n+            } else if (zoneId.startsWith(\"-\")) {\n+                zoneId = zoneId.replaceFirst(quote(\"-\"), \"+\");\n+            }\n+            return zoneId;\n+        }\n+        \n+        /**\n+         * Generates an SQL file that can be used to create the test dataset for the unit test of the <code>TO_CHAR</code>\n+         * implementation. In case the <code>TO_CHAR</code> implementation needs an upgrade, add the list of the new format\n+         * strings to the list of the format string, regenerate the SQL, run it against the PostgreSQL version you are targeting\n+         * and update the test CSV file.\n+         */\n+        private static String unitTestExporterScript() {\n+            return generateTestCases().stream().map(tc -> {\n+                long seconds = tc.secondsAndFractionsSinceEpoch.longValue();\n+                BigDecimal fractions = tc.secondsAndFractionsSinceEpoch.remainder(BigDecimal.ONE).movePointRight(6);\n+                return String.format(Locale.ROOT,\n+                    \"SET TIME ZONE '%7$s';\\n\" +\n+                    \"\\\\copy (SELECT %1$d as id, %2$s as epoch_seconds_and_microsends, '%6$s' as zone_id, '%5$s' as format_string, \" +\n+                        \"(TO_TIMESTAMP(%3$d) + INTERVAL '%4$d microseconds') as to_timestamp_result, \" +\n+                        \"TO_CHAR((TO_TIMESTAMP(%3$d) + INTERVAL '%4$d microseconds'), '%5$s') as to_char_result) to stdout \" +\n+                        \"with DELIMITER as '\" + DELIMITER + \"' NULL as '' csv \\n\",\n+                    tc.id, tc.secondsAndFractionsSinceEpoch.toPlainString(), seconds, fractions.intValue(), tc.formatString, tc.zoneId, \n+                    adjustZoneIdToPostgres(tc.zoneId)\n+                );\n+            }).collect(Collectors.joining(\"\\n\"));\n+        }\n+        \n+        public static void main(String[] args) throws Exception {\n+            String scriptFilename = args.length < 1 ? \"/tmp/postgresql-tochar-test.sql\" : args[0];\n+            Files.writeString(Path.of(scriptFilename), unitTestExporterScript(), StandardCharsets.UTF_8);\n+        }\n+    }\n+\n+    @ParametersFactory(argumentFormatting = \"%1$s: timestamp=%5$s, zone=%3$s, format=%4$s\")\n+    public static List<Object[]> readCsv() throws Exception {\n+        Path testFilePath = Path.of(DateTimeToCharProcessorTests.class.getResource(\"tochar.csv\").toURI());\n+        return Files.readAllLines(testFilePath).stream().map(line -> {\n+            String[] cols = line.split(quote(TestGenerator.DELIMITER));\n+            return new Object[]{ cols[0], cols[1], cols[2], cols[3], cols[4], cols[5] };\n+        }).collect(Collectors.toList());\n+    }\n+\n+    private final String id;\n+    private final String secondsAndFractionsSinceEpoch;\n+    private final String zone;\n+    private final String formatString;\n+    private final String posgresTimestamp;\n+    private final String expectedResult;\n+\n+    public DateTimeToCharProcessorTests(String id, String secondsAndFractionsSinceEpoch, String zone, String formatString,\n+        String postgresTimestamp, String expectedResult) {\n+        this.id = id;\n+        this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+        this.zone = zone;\n+        this.formatString = formatString;\n+        this.posgresTimestamp = postgresTimestamp;\n+        this.expectedResult = expectedResult;\n+    }\n+\n+    private static ZonedDateTime dateTimeWithFractions(String secondAndFractionsSinceEpoch) {\n+        BigDecimal b = new BigDecimal(secondAndFractionsSinceEpoch);\n+        long seconds = b.longValue();\n+        int fractions = b.remainder(BigDecimal.ONE).movePointRight(9).intValueExact();\n+        int adjustment = 0;\n+        if (fractions < 0) {\n+            fractions += 1e9;\n+            adjustment = -1;\n+        }\n+        return dateTime((seconds + adjustment) * 1000).withNano(fractions);\n+    }\n+    \n+    public void test() throws Exception {\n+        ZoneId zoneId = ZoneId.of(zone);\n+        ZonedDateTime timestamp = dateTimeWithFractions(secondsAndFractionsSinceEpoch);\n+        String actualResult =\n+            (String) new ToChar(Source.EMPTY, l(timestamp, DataTypes.DATETIME), l(formatString, DataTypes.KEYWORD), zoneId)\n+                .makePipe()\n+                .asProcessor()\n+                .process(null);\n+        List<String> expectedResultSplitted = List.of(expectedResult.split(quote(TestGenerator.PATTERN_DELIMITER)));\n+        List<String> resultSplitted = List.of(actualResult.split(quote(TestGenerator.PATTERN_DELIMITER)));\n+        List<String> formatStringSplitted = List.of(formatString.split(TestGenerator.PATTERN_DELIMITER));\n+        assertEquals(formatStringSplitted.size(), resultSplitted.size());\n+        assertEquals(formatStringSplitted.size(), expectedResultSplitted.size());\n+        for (int i = 0; i < formatStringSplitted.size(); i++) {\n+            String patternMaybeWithIndex = formatStringSplitted.get(i);\n+            String pattern = patternMaybeWithIndex.contains(\":\") \n+                ? patternMaybeWithIndex.substring(patternMaybeWithIndex.indexOf(\":\") + 1)\n+                : patternMaybeWithIndex;\n+            String expectedPart = expectedResultSplitted.get(i);\n+            String actualPart = resultSplitted.get(i);\n+            try {\n+                assertEquals(\n+                    String.format(Locale.ROOT, \n+                        \"\\nTest id:                            %s\\n\" +", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA1NDA4OA=="}, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 300}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NDUwODA5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNjo0NTowNlrOIOeuCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQxNDozNDozNFrOISEU9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA1NDI4MQ==", "bodyText": "Use assume instead of catching the error. Further more why not check for this pattern before generating the test cases?", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552054281", "createdAt": "2021-01-05T16:45:06Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    private static class TestCase {\n+        private static final AtomicInteger COUNTER = new AtomicInteger(0);\n+        \n+        // timezones that are valid both in Java and in Postgres\n+        public static final List<String> POSTGRES_TEST_ZONE_LIST = List.of(\n+            // location-based and long-names\n+            \"US/Samoa\", \"Pacific/Honolulu\", \"Pacific/Marquesas\", \"Pacific/Gambier\", \"America/Juneau\", \"Canada/Yukon\", \"America/Vancouver\",\n+            \"Pacific/Easter\", \"US/Mountain\", \"America/Chicago\", \"US/Michigan\", \"Atlantic/Bermuda\", \"Canada/Newfoundland\",\n+            \"Atlantic/Cape_Verde\", \"Pacific/Kiritimati\", \"Pacific/Chatham\", \"Pacific/Auckland\", \"Asia/Sakhalin\", \"Australia/Tasmania\", \n+            \"Australia/North\", \"Asia/Tokyo\", \"Australia/Eucla\", \"Asia/Singapore\", \"Asia/Rangoon\", \"Indian/Chagos\", \"Asia/Calcutta\", \n+            \"Asia/Tashkent\", \"Asia/Tehran\", \"Asia/Dubai\", \"Africa/Nairobi\", \"Europe/Brussels\", \"Europe/Vienna\", \"Europe/London\", \n+            \"Etc/GMT+12\",\n+            // short names of zones\n+            \"GMT\", \"UTC\", \"CET\",\n+            // offsets\n+            \"+11:00\", \"+04:30\", \"+01:00\", \"+00:00\", \"-00:00\", \"-01:15\", \"-02:00\", \"-11:00\");\n+\n+        private final int id;\n+        private final BigDecimal secondsAndFractionsSinceEpoch;\n+        private final String formatString;\n+        private final String zoneId;\n+        \n+        TestCase(BigDecimal secondsAndFractionsSinceEpoch, String formatString) {\n+            this.id = COUNTER.incrementAndGet();\n+            this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+            this.formatString = formatString;\n+            this.zoneId = TestGenerator.randomFromCollection(POSTGRES_TEST_ZONE_LIST);\n+        }\n+\n+    }\n+\n+    /**\n+     * Generates an sql file that can be used to generate the test dataset for this unit test (to be used with the <code>psql</code> cli).\n+     *\n+     * Run the @{link {@link TestGenerator#main(String[])}} class and execute the following command to generate the output dataset with:\n+     *\n+     * <p>\n+     *  <code>\n+     *      # easy way to spin up the latest Postgres\n+     *      docker run --rm --name postgres-latest -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres:latest\n+     *\n+     *      # generate the csv for the unit test\n+     *      PGPASSWORD=\"mysecretpassword\" psql --quiet -h localhost -p 5432 -U postgres -f /tmp/postgresql-tochar-test.sql \\\n+     *          &gt; /path/to/tochar.csv\n+     *  </code>\n+     * </p>\n+     */\n+    private static class TestGenerator {\n+        \n+        private static final long SECONDS_IN_YEAR = 365 * 24 * 60 * 60L;\n+        private static final String DELIMITER = \"|\";\n+        private static final String PATTERN_DELIMITER = \" @ \";\n+        // these patterns are hard to sync up between PostgreSQL and Elasticsearch, so we just warn, but actually\n+        // accept the output of Elasticsearch as is\n+        private static final Set<String> NOT_FULLY_MATCHABLE_PATTERNS = Set.of(\"TZ\", \"tz\");\n+        private static final Set<String> UNSUPPORTED_PATTERN_MODIFIERS = Set.of(\"FX\", \"TM\", \"SP\");\n+        private static final String[] PATTERNS = new String[] {\n+            \"HH\", \"HH12\", \"HH24\", \"MI\", \"SS\", \"MS\", \"US\", \"FF1\", \"FF2\", \"FF3\", \"FF4\", \"FF5\", \"FF6\", \"SSSS\", \"SSSSS\", \"AM\", \"am\", \"PM\",\n+            \"pm\", \"A.M.\", \"a.m.\", \"P.M.\", \"p.m.\", \"Y,YYY\", \"YYYY\", \"YYY\", \"YY\", \"Y\", \"IYYY\", \"IYY\", \"IY\", \"I\", \"BC\", \"bc\", \"AD\", \"ad\",\n+            \"B.C.\", \"b.c.\", \"A.D.\", \"a.d.\", \"MONTH\", \"Month\", \"month\", \"MON\", \"Mon\", \"mon\", \"MM\", \"DAY\", \"Day\", \"day\", \"DY\", \"Dy\",\n+            \"dy\", \"DDD\", \"IDDD\", \"DD\", \"D\", \"ID\", \"W\", \"WW\", \"IW\", \"CC\", \"J\", \"Q\", \"RM\", \"rm\", \"TZ\", \"tz\", \"TZH\", \"TZM\", \"OF\"\n+        };\n+        private static final List<String> FILL_MODIFIERS = List.of(\"FM\", \"fm\", \"\");\n+        private static final List<String> ORDINAL_SUFFIX_MODIFIERS = List.of(\"TH\", \"th\", \"\");\n+\n+        @SuppressForbidden(reason = \"It is ok to use ThreadLocalRandom outside of an actual test\")\n+        private static Random rnd() {\n+            return ThreadLocalRandom.current();\n+        }\n+\n+        private static BigDecimal randomSecondsWithFractions(int minYear, int maxYear) {\n+            BigDecimal seconds = new BigDecimal(RandomNumbers.randomLongBetween(rnd(), \n+                (minYear - 1970) * SECONDS_IN_YEAR, (maxYear - 1970) * SECONDS_IN_YEAR));\n+            BigDecimal fractions = new BigDecimal(RandomNumbers.randomIntBetween(rnd(), 0, 999_999)).movePointLeft(6);\n+            return seconds.add(fractions);\n+        }\n+\n+        private static <T> T randomFromCollection(Collection<T> list) {\n+            List<T> l = new ArrayList<>(list);\n+            return l.get(rnd().nextInt(l.size()));\n+        }\n+        \n+        private static String patternWithRandomModifiers(String pattern) {\n+            if (NOT_FULLY_MATCHABLE_PATTERNS.contains(pattern)) {\n+                return pattern;\n+            }\n+            return randomFromCollection(FILL_MODIFIERS) + pattern + randomFromCollection(ORDINAL_SUFFIX_MODIFIERS);\n+        }\n+    \n+        private static List<TestCase> generateTestCases() {\n+            \n+            final List<BigDecimal> testEpochSeconds = new LinkedList<>();\n+            for (int i = 0; i < 50; i++) {\n+                testEpochSeconds.add(randomSecondsWithFractions(-1200, 2500));\n+            }\n+            for (int i = 0; i < 5; i++) {\n+                testEpochSeconds.add(randomSecondsWithFractions(-1, 1));\n+            }\n+    \n+            List<TestCase> testCases = new ArrayList<>();\n+    \n+            // check each format string alone\n+            for (String pattern : PATTERNS) {\n+                testCases.add(new TestCase(randomFromCollection(testEpochSeconds), NOT_FULLY_MATCHABLE_PATTERNS.contains(pattern) \n+                    ? pattern \n+                    : String.join(PATTERN_DELIMITER, pattern, FILL_MODIFIERS.get(0) + pattern + ORDINAL_SUFFIX_MODIFIERS.get(0))));\n+            }\n+            \n+            // let's check all of the format strings with a non-ambiguous format string\n+            for (BigDecimal es : testEpochSeconds) {\n+                testCases.add(new TestCase(es, IntStream.range(0, PATTERNS.length)\n+                    .mapToObj(idx -> idx + \":\" + patternWithRandomModifiers(PATTERNS[idx]))\n+                    .collect(Collectors.joining(PATTERN_DELIMITER))));\n+            }\n+    \n+            // check the lowercase versions of the format strings\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), IntStream.range(0, PATTERNS.length)\n+                .mapToObj(idx -> (idx + \":\" + patternWithRandomModifiers(PATTERNS[idx])).toLowerCase(Locale.ROOT))\n+                .collect(Collectors.joining(PATTERN_DELIMITER))));\n+    \n+            // potentially ambiguous format string test cases, to check if our format string parsing is in-sync with PostgreSQL\n+            // greedy and prefers the longer format strings\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"YYYYYYYYYYYYYYY,YYYYYYYYY\"));\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"SSSSSSSSSSSSSSSS\"));\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"DDDDDDDD\"));\n+    \n+            // Roman numbers\n+            for (int i = 1; i <= 12; i++) {\n+                testCases.add(new TestCase(\n+                    new BigDecimal(dateTime(0).withMonth(i).toEpochSecond()), rnd().nextBoolean() ? \"RM\" : \"rm\"));\n+            }\n+            \n+            // random strings made out of template patterns and random characters\n+            final String randomCharacters = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYabcdefghijklmnopqrstuvwxy _-.:;\";\n+            final List<String> formatStringsToRandomTest = Arrays.stream(PATTERNS)\n+                .filter(s -> NOT_FULLY_MATCHABLE_PATTERNS.contains(s) == false)\n+                .collect(Collectors.toList());\n+            \n+            for (int i = 0; i < 20; i++) {\n+                String patternWithLiterals = IntStream.rangeClosed(1, 30).mapToObj(idx -> \n+                    rnd().nextInt(100) < 80 \n+                        ? randomCharacters.substring(rnd().nextInt(randomCharacters.length())).substring(0, 1) \n+                        : (randomFromCollection(FILL_MODIFIERS) \n+                            + randomFromCollection(formatStringsToRandomTest) \n+                            + randomFromCollection(ORDINAL_SUFFIX_MODIFIERS)))\n+                    .collect(Collectors.joining());\n+                \n+                // clean up the random string from the unsupported modifiers\n+                for (String unsupportedPatternModifier : UNSUPPORTED_PATTERN_MODIFIERS) {\n+                    patternWithLiterals = patternWithLiterals\n+                        .replace(unsupportedPatternModifier, \"\")\n+                        .replace(unsupportedPatternModifier.toLowerCase(Locale.ROOT), \"\");\n+                }\n+                testCases.add(new TestCase(randomFromCollection(testEpochSeconds), patternWithLiterals));\n+            }\n+    \n+            return testCases;\n+        }\n+        \n+        private static String adjustZoneIdToPostgres(String zoneId) {\n+            // when the zone is specified by the offset in Postgres, it follows the POSIX definition, so the +- signs are flipped\n+            // compared to ISO-8601, see more info at: https://www.postgresql.org/docs/current/datetime-posix-timezone-specs.html\n+            if (zoneId.startsWith(\"+\")) {\n+                zoneId = zoneId.replaceFirst(quote(\"+\"), \"-\");\n+            } else if (zoneId.startsWith(\"-\")) {\n+                zoneId = zoneId.replaceFirst(quote(\"-\"), \"+\");\n+            }\n+            return zoneId;\n+        }\n+        \n+        /**\n+         * Generates an SQL file that can be used to create the test dataset for the unit test of the <code>TO_CHAR</code>\n+         * implementation. In case the <code>TO_CHAR</code> implementation needs an upgrade, add the list of the new format\n+         * strings to the list of the format string, regenerate the SQL, run it against the PostgreSQL version you are targeting\n+         * and update the test CSV file.\n+         */\n+        private static String unitTestExporterScript() {\n+            return generateTestCases().stream().map(tc -> {\n+                long seconds = tc.secondsAndFractionsSinceEpoch.longValue();\n+                BigDecimal fractions = tc.secondsAndFractionsSinceEpoch.remainder(BigDecimal.ONE).movePointRight(6);\n+                return String.format(Locale.ROOT,\n+                    \"SET TIME ZONE '%7$s';\\n\" +\n+                    \"\\\\copy (SELECT %1$d as id, %2$s as epoch_seconds_and_microsends, '%6$s' as zone_id, '%5$s' as format_string, \" +\n+                        \"(TO_TIMESTAMP(%3$d) + INTERVAL '%4$d microseconds') as to_timestamp_result, \" +\n+                        \"TO_CHAR((TO_TIMESTAMP(%3$d) + INTERVAL '%4$d microseconds'), '%5$s') as to_char_result) to stdout \" +\n+                        \"with DELIMITER as '\" + DELIMITER + \"' NULL as '' csv \\n\",\n+                    tc.id, tc.secondsAndFractionsSinceEpoch.toPlainString(), seconds, fractions.intValue(), tc.formatString, tc.zoneId, \n+                    adjustZoneIdToPostgres(tc.zoneId)\n+                );\n+            }).collect(Collectors.joining(\"\\n\"));\n+        }\n+        \n+        public static void main(String[] args) throws Exception {\n+            String scriptFilename = args.length < 1 ? \"/tmp/postgresql-tochar-test.sql\" : args[0];\n+            Files.writeString(Path.of(scriptFilename), unitTestExporterScript(), StandardCharsets.UTF_8);\n+        }\n+    }\n+\n+    @ParametersFactory(argumentFormatting = \"%1$s: timestamp=%5$s, zone=%3$s, format=%4$s\")\n+    public static List<Object[]> readCsv() throws Exception {\n+        Path testFilePath = Path.of(DateTimeToCharProcessorTests.class.getResource(\"tochar.csv\").toURI());\n+        return Files.readAllLines(testFilePath).stream().map(line -> {\n+            String[] cols = line.split(quote(TestGenerator.DELIMITER));\n+            return new Object[]{ cols[0], cols[1], cols[2], cols[3], cols[4], cols[5] };\n+        }).collect(Collectors.toList());\n+    }\n+\n+    private final String id;\n+    private final String secondsAndFractionsSinceEpoch;\n+    private final String zone;\n+    private final String formatString;\n+    private final String posgresTimestamp;\n+    private final String expectedResult;\n+\n+    public DateTimeToCharProcessorTests(String id, String secondsAndFractionsSinceEpoch, String zone, String formatString,\n+        String postgresTimestamp, String expectedResult) {\n+        this.id = id;\n+        this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+        this.zone = zone;\n+        this.formatString = formatString;\n+        this.posgresTimestamp = postgresTimestamp;\n+        this.expectedResult = expectedResult;\n+    }\n+\n+    private static ZonedDateTime dateTimeWithFractions(String secondAndFractionsSinceEpoch) {\n+        BigDecimal b = new BigDecimal(secondAndFractionsSinceEpoch);\n+        long seconds = b.longValue();\n+        int fractions = b.remainder(BigDecimal.ONE).movePointRight(9).intValueExact();\n+        int adjustment = 0;\n+        if (fractions < 0) {\n+            fractions += 1e9;\n+            adjustment = -1;\n+        }\n+        return dateTime((seconds + adjustment) * 1000).withNano(fractions);\n+    }\n+    \n+    public void test() throws Exception {\n+        ZoneId zoneId = ZoneId.of(zone);\n+        ZonedDateTime timestamp = dateTimeWithFractions(secondsAndFractionsSinceEpoch);\n+        String actualResult =\n+            (String) new ToChar(Source.EMPTY, l(timestamp, DataTypes.DATETIME), l(formatString, DataTypes.KEYWORD), zoneId)\n+                .makePipe()\n+                .asProcessor()\n+                .process(null);\n+        List<String> expectedResultSplitted = List.of(expectedResult.split(quote(TestGenerator.PATTERN_DELIMITER)));\n+        List<String> resultSplitted = List.of(actualResult.split(quote(TestGenerator.PATTERN_DELIMITER)));\n+        List<String> formatStringSplitted = List.of(formatString.split(TestGenerator.PATTERN_DELIMITER));\n+        assertEquals(formatStringSplitted.size(), resultSplitted.size());\n+        assertEquals(formatStringSplitted.size(), expectedResultSplitted.size());\n+        for (int i = 0; i < formatStringSplitted.size(); i++) {\n+            String patternMaybeWithIndex = formatStringSplitted.get(i);\n+            String pattern = patternMaybeWithIndex.contains(\":\") \n+                ? patternMaybeWithIndex.substring(patternMaybeWithIndex.indexOf(\":\") + 1)\n+                : patternMaybeWithIndex;\n+            String expectedPart = expectedResultSplitted.get(i);\n+            String actualPart = resultSplitted.get(i);\n+            try {\n+                assertEquals(\n+                    String.format(Locale.ROOT, \n+                        \"\\nTest id:                            %s\\n\" +\n+                        \"zone:                               %s\\n\" +\n+                        \"timestamp (as epoch):               %s\\n\" +\n+                        \"timestamp (java, UTC):              %s\\n\" +\n+                        \"timestamp (postgres, to_timestamp): %s\\n\" +\n+                        \"timestamp (java with zone):         %s\\n\" +\n+                        \"format string:                      %s\\n\" +\n+                        \"expected (postgres to_char result): %s\\n\" +\n+                        \"actual (ES to_char result):         %s\\n\" +\n+                        \"    FAILED (sub)pattern: %s,\",\n+                        id, zone, secondsAndFractionsSinceEpoch, timestamp, posgresTimestamp, timestamp.withZoneSameInstant(zoneId), \n+                        formatString, expectedResult, actualResult, patternMaybeWithIndex), \n+                    expectedPart, actualPart);\n+            } catch (AssertionError err) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 313}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIyMDU3Nw==", "bodyText": "Using assume would stop checking the rest of the patterns (we are in a for loop here). I can remove the TZ and tz from the test generator.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552220577", "createdAt": "2021-01-05T21:51:03Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    private static class TestCase {\n+        private static final AtomicInteger COUNTER = new AtomicInteger(0);\n+        \n+        // timezones that are valid both in Java and in Postgres\n+        public static final List<String> POSTGRES_TEST_ZONE_LIST = List.of(\n+            // location-based and long-names\n+            \"US/Samoa\", \"Pacific/Honolulu\", \"Pacific/Marquesas\", \"Pacific/Gambier\", \"America/Juneau\", \"Canada/Yukon\", \"America/Vancouver\",\n+            \"Pacific/Easter\", \"US/Mountain\", \"America/Chicago\", \"US/Michigan\", \"Atlantic/Bermuda\", \"Canada/Newfoundland\",\n+            \"Atlantic/Cape_Verde\", \"Pacific/Kiritimati\", \"Pacific/Chatham\", \"Pacific/Auckland\", \"Asia/Sakhalin\", \"Australia/Tasmania\", \n+            \"Australia/North\", \"Asia/Tokyo\", \"Australia/Eucla\", \"Asia/Singapore\", \"Asia/Rangoon\", \"Indian/Chagos\", \"Asia/Calcutta\", \n+            \"Asia/Tashkent\", \"Asia/Tehran\", \"Asia/Dubai\", \"Africa/Nairobi\", \"Europe/Brussels\", \"Europe/Vienna\", \"Europe/London\", \n+            \"Etc/GMT+12\",\n+            // short names of zones\n+            \"GMT\", \"UTC\", \"CET\",\n+            // offsets\n+            \"+11:00\", \"+04:30\", \"+01:00\", \"+00:00\", \"-00:00\", \"-01:15\", \"-02:00\", \"-11:00\");\n+\n+        private final int id;\n+        private final BigDecimal secondsAndFractionsSinceEpoch;\n+        private final String formatString;\n+        private final String zoneId;\n+        \n+        TestCase(BigDecimal secondsAndFractionsSinceEpoch, String formatString) {\n+            this.id = COUNTER.incrementAndGet();\n+            this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+            this.formatString = formatString;\n+            this.zoneId = TestGenerator.randomFromCollection(POSTGRES_TEST_ZONE_LIST);\n+        }\n+\n+    }\n+\n+    /**\n+     * Generates an sql file that can be used to generate the test dataset for this unit test (to be used with the <code>psql</code> cli).\n+     *\n+     * Run the @{link {@link TestGenerator#main(String[])}} class and execute the following command to generate the output dataset with:\n+     *\n+     * <p>\n+     *  <code>\n+     *      # easy way to spin up the latest Postgres\n+     *      docker run --rm --name postgres-latest -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres:latest\n+     *\n+     *      # generate the csv for the unit test\n+     *      PGPASSWORD=\"mysecretpassword\" psql --quiet -h localhost -p 5432 -U postgres -f /tmp/postgresql-tochar-test.sql \\\n+     *          &gt; /path/to/tochar.csv\n+     *  </code>\n+     * </p>\n+     */\n+    private static class TestGenerator {\n+        \n+        private static final long SECONDS_IN_YEAR = 365 * 24 * 60 * 60L;\n+        private static final String DELIMITER = \"|\";\n+        private static final String PATTERN_DELIMITER = \" @ \";\n+        // these patterns are hard to sync up between PostgreSQL and Elasticsearch, so we just warn, but actually\n+        // accept the output of Elasticsearch as is\n+        private static final Set<String> NOT_FULLY_MATCHABLE_PATTERNS = Set.of(\"TZ\", \"tz\");\n+        private static final Set<String> UNSUPPORTED_PATTERN_MODIFIERS = Set.of(\"FX\", \"TM\", \"SP\");\n+        private static final String[] PATTERNS = new String[] {\n+            \"HH\", \"HH12\", \"HH24\", \"MI\", \"SS\", \"MS\", \"US\", \"FF1\", \"FF2\", \"FF3\", \"FF4\", \"FF5\", \"FF6\", \"SSSS\", \"SSSSS\", \"AM\", \"am\", \"PM\",\n+            \"pm\", \"A.M.\", \"a.m.\", \"P.M.\", \"p.m.\", \"Y,YYY\", \"YYYY\", \"YYY\", \"YY\", \"Y\", \"IYYY\", \"IYY\", \"IY\", \"I\", \"BC\", \"bc\", \"AD\", \"ad\",\n+            \"B.C.\", \"b.c.\", \"A.D.\", \"a.d.\", \"MONTH\", \"Month\", \"month\", \"MON\", \"Mon\", \"mon\", \"MM\", \"DAY\", \"Day\", \"day\", \"DY\", \"Dy\",\n+            \"dy\", \"DDD\", \"IDDD\", \"DD\", \"D\", \"ID\", \"W\", \"WW\", \"IW\", \"CC\", \"J\", \"Q\", \"RM\", \"rm\", \"TZ\", \"tz\", \"TZH\", \"TZM\", \"OF\"\n+        };\n+        private static final List<String> FILL_MODIFIERS = List.of(\"FM\", \"fm\", \"\");\n+        private static final List<String> ORDINAL_SUFFIX_MODIFIERS = List.of(\"TH\", \"th\", \"\");\n+\n+        @SuppressForbidden(reason = \"It is ok to use ThreadLocalRandom outside of an actual test\")\n+        private static Random rnd() {\n+            return ThreadLocalRandom.current();\n+        }\n+\n+        private static BigDecimal randomSecondsWithFractions(int minYear, int maxYear) {\n+            BigDecimal seconds = new BigDecimal(RandomNumbers.randomLongBetween(rnd(), \n+                (minYear - 1970) * SECONDS_IN_YEAR, (maxYear - 1970) * SECONDS_IN_YEAR));\n+            BigDecimal fractions = new BigDecimal(RandomNumbers.randomIntBetween(rnd(), 0, 999_999)).movePointLeft(6);\n+            return seconds.add(fractions);\n+        }\n+\n+        private static <T> T randomFromCollection(Collection<T> list) {\n+            List<T> l = new ArrayList<>(list);\n+            return l.get(rnd().nextInt(l.size()));\n+        }\n+        \n+        private static String patternWithRandomModifiers(String pattern) {\n+            if (NOT_FULLY_MATCHABLE_PATTERNS.contains(pattern)) {\n+                return pattern;\n+            }\n+            return randomFromCollection(FILL_MODIFIERS) + pattern + randomFromCollection(ORDINAL_SUFFIX_MODIFIERS);\n+        }\n+    \n+        private static List<TestCase> generateTestCases() {\n+            \n+            final List<BigDecimal> testEpochSeconds = new LinkedList<>();\n+            for (int i = 0; i < 50; i++) {\n+                testEpochSeconds.add(randomSecondsWithFractions(-1200, 2500));\n+            }\n+            for (int i = 0; i < 5; i++) {\n+                testEpochSeconds.add(randomSecondsWithFractions(-1, 1));\n+            }\n+    \n+            List<TestCase> testCases = new ArrayList<>();\n+    \n+            // check each format string alone\n+            for (String pattern : PATTERNS) {\n+                testCases.add(new TestCase(randomFromCollection(testEpochSeconds), NOT_FULLY_MATCHABLE_PATTERNS.contains(pattern) \n+                    ? pattern \n+                    : String.join(PATTERN_DELIMITER, pattern, FILL_MODIFIERS.get(0) + pattern + ORDINAL_SUFFIX_MODIFIERS.get(0))));\n+            }\n+            \n+            // let's check all of the format strings with a non-ambiguous format string\n+            for (BigDecimal es : testEpochSeconds) {\n+                testCases.add(new TestCase(es, IntStream.range(0, PATTERNS.length)\n+                    .mapToObj(idx -> idx + \":\" + patternWithRandomModifiers(PATTERNS[idx]))\n+                    .collect(Collectors.joining(PATTERN_DELIMITER))));\n+            }\n+    \n+            // check the lowercase versions of the format strings\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), IntStream.range(0, PATTERNS.length)\n+                .mapToObj(idx -> (idx + \":\" + patternWithRandomModifiers(PATTERNS[idx])).toLowerCase(Locale.ROOT))\n+                .collect(Collectors.joining(PATTERN_DELIMITER))));\n+    \n+            // potentially ambiguous format string test cases, to check if our format string parsing is in-sync with PostgreSQL\n+            // greedy and prefers the longer format strings\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"YYYYYYYYYYYYYYY,YYYYYYYYY\"));\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"SSSSSSSSSSSSSSSS\"));\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"DDDDDDDD\"));\n+    \n+            // Roman numbers\n+            for (int i = 1; i <= 12; i++) {\n+                testCases.add(new TestCase(\n+                    new BigDecimal(dateTime(0).withMonth(i).toEpochSecond()), rnd().nextBoolean() ? \"RM\" : \"rm\"));\n+            }\n+            \n+            // random strings made out of template patterns and random characters\n+            final String randomCharacters = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYabcdefghijklmnopqrstuvwxy _-.:;\";\n+            final List<String> formatStringsToRandomTest = Arrays.stream(PATTERNS)\n+                .filter(s -> NOT_FULLY_MATCHABLE_PATTERNS.contains(s) == false)\n+                .collect(Collectors.toList());\n+            \n+            for (int i = 0; i < 20; i++) {\n+                String patternWithLiterals = IntStream.rangeClosed(1, 30).mapToObj(idx -> \n+                    rnd().nextInt(100) < 80 \n+                        ? randomCharacters.substring(rnd().nextInt(randomCharacters.length())).substring(0, 1) \n+                        : (randomFromCollection(FILL_MODIFIERS) \n+                            + randomFromCollection(formatStringsToRandomTest) \n+                            + randomFromCollection(ORDINAL_SUFFIX_MODIFIERS)))\n+                    .collect(Collectors.joining());\n+                \n+                // clean up the random string from the unsupported modifiers\n+                for (String unsupportedPatternModifier : UNSUPPORTED_PATTERN_MODIFIERS) {\n+                    patternWithLiterals = patternWithLiterals\n+                        .replace(unsupportedPatternModifier, \"\")\n+                        .replace(unsupportedPatternModifier.toLowerCase(Locale.ROOT), \"\");\n+                }\n+                testCases.add(new TestCase(randomFromCollection(testEpochSeconds), patternWithLiterals));\n+            }\n+    \n+            return testCases;\n+        }\n+        \n+        private static String adjustZoneIdToPostgres(String zoneId) {\n+            // when the zone is specified by the offset in Postgres, it follows the POSIX definition, so the +- signs are flipped\n+            // compared to ISO-8601, see more info at: https://www.postgresql.org/docs/current/datetime-posix-timezone-specs.html\n+            if (zoneId.startsWith(\"+\")) {\n+                zoneId = zoneId.replaceFirst(quote(\"+\"), \"-\");\n+            } else if (zoneId.startsWith(\"-\")) {\n+                zoneId = zoneId.replaceFirst(quote(\"-\"), \"+\");\n+            }\n+            return zoneId;\n+        }\n+        \n+        /**\n+         * Generates an SQL file that can be used to create the test dataset for the unit test of the <code>TO_CHAR</code>\n+         * implementation. In case the <code>TO_CHAR</code> implementation needs an upgrade, add the list of the new format\n+         * strings to the list of the format string, regenerate the SQL, run it against the PostgreSQL version you are targeting\n+         * and update the test CSV file.\n+         */\n+        private static String unitTestExporterScript() {\n+            return generateTestCases().stream().map(tc -> {\n+                long seconds = tc.secondsAndFractionsSinceEpoch.longValue();\n+                BigDecimal fractions = tc.secondsAndFractionsSinceEpoch.remainder(BigDecimal.ONE).movePointRight(6);\n+                return String.format(Locale.ROOT,\n+                    \"SET TIME ZONE '%7$s';\\n\" +\n+                    \"\\\\copy (SELECT %1$d as id, %2$s as epoch_seconds_and_microsends, '%6$s' as zone_id, '%5$s' as format_string, \" +\n+                        \"(TO_TIMESTAMP(%3$d) + INTERVAL '%4$d microseconds') as to_timestamp_result, \" +\n+                        \"TO_CHAR((TO_TIMESTAMP(%3$d) + INTERVAL '%4$d microseconds'), '%5$s') as to_char_result) to stdout \" +\n+                        \"with DELIMITER as '\" + DELIMITER + \"' NULL as '' csv \\n\",\n+                    tc.id, tc.secondsAndFractionsSinceEpoch.toPlainString(), seconds, fractions.intValue(), tc.formatString, tc.zoneId, \n+                    adjustZoneIdToPostgres(tc.zoneId)\n+                );\n+            }).collect(Collectors.joining(\"\\n\"));\n+        }\n+        \n+        public static void main(String[] args) throws Exception {\n+            String scriptFilename = args.length < 1 ? \"/tmp/postgresql-tochar-test.sql\" : args[0];\n+            Files.writeString(Path.of(scriptFilename), unitTestExporterScript(), StandardCharsets.UTF_8);\n+        }\n+    }\n+\n+    @ParametersFactory(argumentFormatting = \"%1$s: timestamp=%5$s, zone=%3$s, format=%4$s\")\n+    public static List<Object[]> readCsv() throws Exception {\n+        Path testFilePath = Path.of(DateTimeToCharProcessorTests.class.getResource(\"tochar.csv\").toURI());\n+        return Files.readAllLines(testFilePath).stream().map(line -> {\n+            String[] cols = line.split(quote(TestGenerator.DELIMITER));\n+            return new Object[]{ cols[0], cols[1], cols[2], cols[3], cols[4], cols[5] };\n+        }).collect(Collectors.toList());\n+    }\n+\n+    private final String id;\n+    private final String secondsAndFractionsSinceEpoch;\n+    private final String zone;\n+    private final String formatString;\n+    private final String posgresTimestamp;\n+    private final String expectedResult;\n+\n+    public DateTimeToCharProcessorTests(String id, String secondsAndFractionsSinceEpoch, String zone, String formatString,\n+        String postgresTimestamp, String expectedResult) {\n+        this.id = id;\n+        this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+        this.zone = zone;\n+        this.formatString = formatString;\n+        this.posgresTimestamp = postgresTimestamp;\n+        this.expectedResult = expectedResult;\n+    }\n+\n+    private static ZonedDateTime dateTimeWithFractions(String secondAndFractionsSinceEpoch) {\n+        BigDecimal b = new BigDecimal(secondAndFractionsSinceEpoch);\n+        long seconds = b.longValue();\n+        int fractions = b.remainder(BigDecimal.ONE).movePointRight(9).intValueExact();\n+        int adjustment = 0;\n+        if (fractions < 0) {\n+            fractions += 1e9;\n+            adjustment = -1;\n+        }\n+        return dateTime((seconds + adjustment) * 1000).withNano(fractions);\n+    }\n+    \n+    public void test() throws Exception {\n+        ZoneId zoneId = ZoneId.of(zone);\n+        ZonedDateTime timestamp = dateTimeWithFractions(secondsAndFractionsSinceEpoch);\n+        String actualResult =\n+            (String) new ToChar(Source.EMPTY, l(timestamp, DataTypes.DATETIME), l(formatString, DataTypes.KEYWORD), zoneId)\n+                .makePipe()\n+                .asProcessor()\n+                .process(null);\n+        List<String> expectedResultSplitted = List.of(expectedResult.split(quote(TestGenerator.PATTERN_DELIMITER)));\n+        List<String> resultSplitted = List.of(actualResult.split(quote(TestGenerator.PATTERN_DELIMITER)));\n+        List<String> formatStringSplitted = List.of(formatString.split(TestGenerator.PATTERN_DELIMITER));\n+        assertEquals(formatStringSplitted.size(), resultSplitted.size());\n+        assertEquals(formatStringSplitted.size(), expectedResultSplitted.size());\n+        for (int i = 0; i < formatStringSplitted.size(); i++) {\n+            String patternMaybeWithIndex = formatStringSplitted.get(i);\n+            String pattern = patternMaybeWithIndex.contains(\":\") \n+                ? patternMaybeWithIndex.substring(patternMaybeWithIndex.indexOf(\":\") + 1)\n+                : patternMaybeWithIndex;\n+            String expectedPart = expectedResultSplitted.get(i);\n+            String actualPart = resultSplitted.get(i);\n+            try {\n+                assertEquals(\n+                    String.format(Locale.ROOT, \n+                        \"\\nTest id:                            %s\\n\" +\n+                        \"zone:                               %s\\n\" +\n+                        \"timestamp (as epoch):               %s\\n\" +\n+                        \"timestamp (java, UTC):              %s\\n\" +\n+                        \"timestamp (postgres, to_timestamp): %s\\n\" +\n+                        \"timestamp (java with zone):         %s\\n\" +\n+                        \"format string:                      %s\\n\" +\n+                        \"expected (postgres to_char result): %s\\n\" +\n+                        \"actual (ES to_char result):         %s\\n\" +\n+                        \"    FAILED (sub)pattern: %s,\",\n+                        id, zone, secondsAndFractionsSinceEpoch, timestamp, posgresTimestamp, timestamp.withZoneSameInstant(zoneId), \n+                        formatString, expectedResult, actualResult, patternMaybeWithIndex), \n+                    expectedPart, actualPart);\n+            } catch (AssertionError err) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA1NDI4MQ=="}, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 313}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTgxNjE4MA==", "bodyText": "Why not generate a test per pattern?\nMy previous question stands, why the check for not fully matchable is done after and not before the test execution?\nAlso what's the story behind not fully matchable? I didn't see any docs for them...", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r555816180", "createdAt": "2021-01-12T14:34:34Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    private static class TestCase {\n+        private static final AtomicInteger COUNTER = new AtomicInteger(0);\n+        \n+        // timezones that are valid both in Java and in Postgres\n+        public static final List<String> POSTGRES_TEST_ZONE_LIST = List.of(\n+            // location-based and long-names\n+            \"US/Samoa\", \"Pacific/Honolulu\", \"Pacific/Marquesas\", \"Pacific/Gambier\", \"America/Juneau\", \"Canada/Yukon\", \"America/Vancouver\",\n+            \"Pacific/Easter\", \"US/Mountain\", \"America/Chicago\", \"US/Michigan\", \"Atlantic/Bermuda\", \"Canada/Newfoundland\",\n+            \"Atlantic/Cape_Verde\", \"Pacific/Kiritimati\", \"Pacific/Chatham\", \"Pacific/Auckland\", \"Asia/Sakhalin\", \"Australia/Tasmania\", \n+            \"Australia/North\", \"Asia/Tokyo\", \"Australia/Eucla\", \"Asia/Singapore\", \"Asia/Rangoon\", \"Indian/Chagos\", \"Asia/Calcutta\", \n+            \"Asia/Tashkent\", \"Asia/Tehran\", \"Asia/Dubai\", \"Africa/Nairobi\", \"Europe/Brussels\", \"Europe/Vienna\", \"Europe/London\", \n+            \"Etc/GMT+12\",\n+            // short names of zones\n+            \"GMT\", \"UTC\", \"CET\",\n+            // offsets\n+            \"+11:00\", \"+04:30\", \"+01:00\", \"+00:00\", \"-00:00\", \"-01:15\", \"-02:00\", \"-11:00\");\n+\n+        private final int id;\n+        private final BigDecimal secondsAndFractionsSinceEpoch;\n+        private final String formatString;\n+        private final String zoneId;\n+        \n+        TestCase(BigDecimal secondsAndFractionsSinceEpoch, String formatString) {\n+            this.id = COUNTER.incrementAndGet();\n+            this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+            this.formatString = formatString;\n+            this.zoneId = TestGenerator.randomFromCollection(POSTGRES_TEST_ZONE_LIST);\n+        }\n+\n+    }\n+\n+    /**\n+     * Generates an sql file that can be used to generate the test dataset for this unit test (to be used with the <code>psql</code> cli).\n+     *\n+     * Run the @{link {@link TestGenerator#main(String[])}} class and execute the following command to generate the output dataset with:\n+     *\n+     * <p>\n+     *  <code>\n+     *      # easy way to spin up the latest Postgres\n+     *      docker run --rm --name postgres-latest -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres:latest\n+     *\n+     *      # generate the csv for the unit test\n+     *      PGPASSWORD=\"mysecretpassword\" psql --quiet -h localhost -p 5432 -U postgres -f /tmp/postgresql-tochar-test.sql \\\n+     *          &gt; /path/to/tochar.csv\n+     *  </code>\n+     * </p>\n+     */\n+    private static class TestGenerator {\n+        \n+        private static final long SECONDS_IN_YEAR = 365 * 24 * 60 * 60L;\n+        private static final String DELIMITER = \"|\";\n+        private static final String PATTERN_DELIMITER = \" @ \";\n+        // these patterns are hard to sync up between PostgreSQL and Elasticsearch, so we just warn, but actually\n+        // accept the output of Elasticsearch as is\n+        private static final Set<String> NOT_FULLY_MATCHABLE_PATTERNS = Set.of(\"TZ\", \"tz\");\n+        private static final Set<String> UNSUPPORTED_PATTERN_MODIFIERS = Set.of(\"FX\", \"TM\", \"SP\");\n+        private static final String[] PATTERNS = new String[] {\n+            \"HH\", \"HH12\", \"HH24\", \"MI\", \"SS\", \"MS\", \"US\", \"FF1\", \"FF2\", \"FF3\", \"FF4\", \"FF5\", \"FF6\", \"SSSS\", \"SSSSS\", \"AM\", \"am\", \"PM\",\n+            \"pm\", \"A.M.\", \"a.m.\", \"P.M.\", \"p.m.\", \"Y,YYY\", \"YYYY\", \"YYY\", \"YY\", \"Y\", \"IYYY\", \"IYY\", \"IY\", \"I\", \"BC\", \"bc\", \"AD\", \"ad\",\n+            \"B.C.\", \"b.c.\", \"A.D.\", \"a.d.\", \"MONTH\", \"Month\", \"month\", \"MON\", \"Mon\", \"mon\", \"MM\", \"DAY\", \"Day\", \"day\", \"DY\", \"Dy\",\n+            \"dy\", \"DDD\", \"IDDD\", \"DD\", \"D\", \"ID\", \"W\", \"WW\", \"IW\", \"CC\", \"J\", \"Q\", \"RM\", \"rm\", \"TZ\", \"tz\", \"TZH\", \"TZM\", \"OF\"\n+        };\n+        private static final List<String> FILL_MODIFIERS = List.of(\"FM\", \"fm\", \"\");\n+        private static final List<String> ORDINAL_SUFFIX_MODIFIERS = List.of(\"TH\", \"th\", \"\");\n+\n+        @SuppressForbidden(reason = \"It is ok to use ThreadLocalRandom outside of an actual test\")\n+        private static Random rnd() {\n+            return ThreadLocalRandom.current();\n+        }\n+\n+        private static BigDecimal randomSecondsWithFractions(int minYear, int maxYear) {\n+            BigDecimal seconds = new BigDecimal(RandomNumbers.randomLongBetween(rnd(), \n+                (minYear - 1970) * SECONDS_IN_YEAR, (maxYear - 1970) * SECONDS_IN_YEAR));\n+            BigDecimal fractions = new BigDecimal(RandomNumbers.randomIntBetween(rnd(), 0, 999_999)).movePointLeft(6);\n+            return seconds.add(fractions);\n+        }\n+\n+        private static <T> T randomFromCollection(Collection<T> list) {\n+            List<T> l = new ArrayList<>(list);\n+            return l.get(rnd().nextInt(l.size()));\n+        }\n+        \n+        private static String patternWithRandomModifiers(String pattern) {\n+            if (NOT_FULLY_MATCHABLE_PATTERNS.contains(pattern)) {\n+                return pattern;\n+            }\n+            return randomFromCollection(FILL_MODIFIERS) + pattern + randomFromCollection(ORDINAL_SUFFIX_MODIFIERS);\n+        }\n+    \n+        private static List<TestCase> generateTestCases() {\n+            \n+            final List<BigDecimal> testEpochSeconds = new LinkedList<>();\n+            for (int i = 0; i < 50; i++) {\n+                testEpochSeconds.add(randomSecondsWithFractions(-1200, 2500));\n+            }\n+            for (int i = 0; i < 5; i++) {\n+                testEpochSeconds.add(randomSecondsWithFractions(-1, 1));\n+            }\n+    \n+            List<TestCase> testCases = new ArrayList<>();\n+    \n+            // check each format string alone\n+            for (String pattern : PATTERNS) {\n+                testCases.add(new TestCase(randomFromCollection(testEpochSeconds), NOT_FULLY_MATCHABLE_PATTERNS.contains(pattern) \n+                    ? pattern \n+                    : String.join(PATTERN_DELIMITER, pattern, FILL_MODIFIERS.get(0) + pattern + ORDINAL_SUFFIX_MODIFIERS.get(0))));\n+            }\n+            \n+            // let's check all of the format strings with a non-ambiguous format string\n+            for (BigDecimal es : testEpochSeconds) {\n+                testCases.add(new TestCase(es, IntStream.range(0, PATTERNS.length)\n+                    .mapToObj(idx -> idx + \":\" + patternWithRandomModifiers(PATTERNS[idx]))\n+                    .collect(Collectors.joining(PATTERN_DELIMITER))));\n+            }\n+    \n+            // check the lowercase versions of the format strings\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), IntStream.range(0, PATTERNS.length)\n+                .mapToObj(idx -> (idx + \":\" + patternWithRandomModifiers(PATTERNS[idx])).toLowerCase(Locale.ROOT))\n+                .collect(Collectors.joining(PATTERN_DELIMITER))));\n+    \n+            // potentially ambiguous format string test cases, to check if our format string parsing is in-sync with PostgreSQL\n+            // greedy and prefers the longer format strings\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"YYYYYYYYYYYYYYY,YYYYYYYYY\"));\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"SSSSSSSSSSSSSSSS\"));\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"DDDDDDDD\"));\n+    \n+            // Roman numbers\n+            for (int i = 1; i <= 12; i++) {\n+                testCases.add(new TestCase(\n+                    new BigDecimal(dateTime(0).withMonth(i).toEpochSecond()), rnd().nextBoolean() ? \"RM\" : \"rm\"));\n+            }\n+            \n+            // random strings made out of template patterns and random characters\n+            final String randomCharacters = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYabcdefghijklmnopqrstuvwxy _-.:;\";\n+            final List<String> formatStringsToRandomTest = Arrays.stream(PATTERNS)\n+                .filter(s -> NOT_FULLY_MATCHABLE_PATTERNS.contains(s) == false)\n+                .collect(Collectors.toList());\n+            \n+            for (int i = 0; i < 20; i++) {\n+                String patternWithLiterals = IntStream.rangeClosed(1, 30).mapToObj(idx -> \n+                    rnd().nextInt(100) < 80 \n+                        ? randomCharacters.substring(rnd().nextInt(randomCharacters.length())).substring(0, 1) \n+                        : (randomFromCollection(FILL_MODIFIERS) \n+                            + randomFromCollection(formatStringsToRandomTest) \n+                            + randomFromCollection(ORDINAL_SUFFIX_MODIFIERS)))\n+                    .collect(Collectors.joining());\n+                \n+                // clean up the random string from the unsupported modifiers\n+                for (String unsupportedPatternModifier : UNSUPPORTED_PATTERN_MODIFIERS) {\n+                    patternWithLiterals = patternWithLiterals\n+                        .replace(unsupportedPatternModifier, \"\")\n+                        .replace(unsupportedPatternModifier.toLowerCase(Locale.ROOT), \"\");\n+                }\n+                testCases.add(new TestCase(randomFromCollection(testEpochSeconds), patternWithLiterals));\n+            }\n+    \n+            return testCases;\n+        }\n+        \n+        private static String adjustZoneIdToPostgres(String zoneId) {\n+            // when the zone is specified by the offset in Postgres, it follows the POSIX definition, so the +- signs are flipped\n+            // compared to ISO-8601, see more info at: https://www.postgresql.org/docs/current/datetime-posix-timezone-specs.html\n+            if (zoneId.startsWith(\"+\")) {\n+                zoneId = zoneId.replaceFirst(quote(\"+\"), \"-\");\n+            } else if (zoneId.startsWith(\"-\")) {\n+                zoneId = zoneId.replaceFirst(quote(\"-\"), \"+\");\n+            }\n+            return zoneId;\n+        }\n+        \n+        /**\n+         * Generates an SQL file that can be used to create the test dataset for the unit test of the <code>TO_CHAR</code>\n+         * implementation. In case the <code>TO_CHAR</code> implementation needs an upgrade, add the list of the new format\n+         * strings to the list of the format string, regenerate the SQL, run it against the PostgreSQL version you are targeting\n+         * and update the test CSV file.\n+         */\n+        private static String unitTestExporterScript() {\n+            return generateTestCases().stream().map(tc -> {\n+                long seconds = tc.secondsAndFractionsSinceEpoch.longValue();\n+                BigDecimal fractions = tc.secondsAndFractionsSinceEpoch.remainder(BigDecimal.ONE).movePointRight(6);\n+                return String.format(Locale.ROOT,\n+                    \"SET TIME ZONE '%7$s';\\n\" +\n+                    \"\\\\copy (SELECT %1$d as id, %2$s as epoch_seconds_and_microsends, '%6$s' as zone_id, '%5$s' as format_string, \" +\n+                        \"(TO_TIMESTAMP(%3$d) + INTERVAL '%4$d microseconds') as to_timestamp_result, \" +\n+                        \"TO_CHAR((TO_TIMESTAMP(%3$d) + INTERVAL '%4$d microseconds'), '%5$s') as to_char_result) to stdout \" +\n+                        \"with DELIMITER as '\" + DELIMITER + \"' NULL as '' csv \\n\",\n+                    tc.id, tc.secondsAndFractionsSinceEpoch.toPlainString(), seconds, fractions.intValue(), tc.formatString, tc.zoneId, \n+                    adjustZoneIdToPostgres(tc.zoneId)\n+                );\n+            }).collect(Collectors.joining(\"\\n\"));\n+        }\n+        \n+        public static void main(String[] args) throws Exception {\n+            String scriptFilename = args.length < 1 ? \"/tmp/postgresql-tochar-test.sql\" : args[0];\n+            Files.writeString(Path.of(scriptFilename), unitTestExporterScript(), StandardCharsets.UTF_8);\n+        }\n+    }\n+\n+    @ParametersFactory(argumentFormatting = \"%1$s: timestamp=%5$s, zone=%3$s, format=%4$s\")\n+    public static List<Object[]> readCsv() throws Exception {\n+        Path testFilePath = Path.of(DateTimeToCharProcessorTests.class.getResource(\"tochar.csv\").toURI());\n+        return Files.readAllLines(testFilePath).stream().map(line -> {\n+            String[] cols = line.split(quote(TestGenerator.DELIMITER));\n+            return new Object[]{ cols[0], cols[1], cols[2], cols[3], cols[4], cols[5] };\n+        }).collect(Collectors.toList());\n+    }\n+\n+    private final String id;\n+    private final String secondsAndFractionsSinceEpoch;\n+    private final String zone;\n+    private final String formatString;\n+    private final String posgresTimestamp;\n+    private final String expectedResult;\n+\n+    public DateTimeToCharProcessorTests(String id, String secondsAndFractionsSinceEpoch, String zone, String formatString,\n+        String postgresTimestamp, String expectedResult) {\n+        this.id = id;\n+        this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+        this.zone = zone;\n+        this.formatString = formatString;\n+        this.posgresTimestamp = postgresTimestamp;\n+        this.expectedResult = expectedResult;\n+    }\n+\n+    private static ZonedDateTime dateTimeWithFractions(String secondAndFractionsSinceEpoch) {\n+        BigDecimal b = new BigDecimal(secondAndFractionsSinceEpoch);\n+        long seconds = b.longValue();\n+        int fractions = b.remainder(BigDecimal.ONE).movePointRight(9).intValueExact();\n+        int adjustment = 0;\n+        if (fractions < 0) {\n+            fractions += 1e9;\n+            adjustment = -1;\n+        }\n+        return dateTime((seconds + adjustment) * 1000).withNano(fractions);\n+    }\n+    \n+    public void test() throws Exception {\n+        ZoneId zoneId = ZoneId.of(zone);\n+        ZonedDateTime timestamp = dateTimeWithFractions(secondsAndFractionsSinceEpoch);\n+        String actualResult =\n+            (String) new ToChar(Source.EMPTY, l(timestamp, DataTypes.DATETIME), l(formatString, DataTypes.KEYWORD), zoneId)\n+                .makePipe()\n+                .asProcessor()\n+                .process(null);\n+        List<String> expectedResultSplitted = List.of(expectedResult.split(quote(TestGenerator.PATTERN_DELIMITER)));\n+        List<String> resultSplitted = List.of(actualResult.split(quote(TestGenerator.PATTERN_DELIMITER)));\n+        List<String> formatStringSplitted = List.of(formatString.split(TestGenerator.PATTERN_DELIMITER));\n+        assertEquals(formatStringSplitted.size(), resultSplitted.size());\n+        assertEquals(formatStringSplitted.size(), expectedResultSplitted.size());\n+        for (int i = 0; i < formatStringSplitted.size(); i++) {\n+            String patternMaybeWithIndex = formatStringSplitted.get(i);\n+            String pattern = patternMaybeWithIndex.contains(\":\") \n+                ? patternMaybeWithIndex.substring(patternMaybeWithIndex.indexOf(\":\") + 1)\n+                : patternMaybeWithIndex;\n+            String expectedPart = expectedResultSplitted.get(i);\n+            String actualPart = resultSplitted.get(i);\n+            try {\n+                assertEquals(\n+                    String.format(Locale.ROOT, \n+                        \"\\nTest id:                            %s\\n\" +\n+                        \"zone:                               %s\\n\" +\n+                        \"timestamp (as epoch):               %s\\n\" +\n+                        \"timestamp (java, UTC):              %s\\n\" +\n+                        \"timestamp (postgres, to_timestamp): %s\\n\" +\n+                        \"timestamp (java with zone):         %s\\n\" +\n+                        \"format string:                      %s\\n\" +\n+                        \"expected (postgres to_char result): %s\\n\" +\n+                        \"actual (ES to_char result):         %s\\n\" +\n+                        \"    FAILED (sub)pattern: %s,\",\n+                        id, zone, secondsAndFractionsSinceEpoch, timestamp, posgresTimestamp, timestamp.withZoneSameInstant(zoneId), \n+                        formatString, expectedResult, actualResult, patternMaybeWithIndex), \n+                    expectedPart, actualPart);\n+            } catch (AssertionError err) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA1NDI4MQ=="}, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 313}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NDUxNDUyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNjo0Njo1OVrOIOeyJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxNjowNjo1MFrOIPyVWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA1NTMzMw==", "bodyText": "Arrays.asList()", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552055333", "createdAt": "2021-01-05T16:46:59Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    private static class TestCase {\n+        private static final AtomicInteger COUNTER = new AtomicInteger(0);\n+        \n+        // timezones that are valid both in Java and in Postgres\n+        public static final List<String> POSTGRES_TEST_ZONE_LIST = List.of(\n+            // location-based and long-names\n+            \"US/Samoa\", \"Pacific/Honolulu\", \"Pacific/Marquesas\", \"Pacific/Gambier\", \"America/Juneau\", \"Canada/Yukon\", \"America/Vancouver\",\n+            \"Pacific/Easter\", \"US/Mountain\", \"America/Chicago\", \"US/Michigan\", \"Atlantic/Bermuda\", \"Canada/Newfoundland\",\n+            \"Atlantic/Cape_Verde\", \"Pacific/Kiritimati\", \"Pacific/Chatham\", \"Pacific/Auckland\", \"Asia/Sakhalin\", \"Australia/Tasmania\", \n+            \"Australia/North\", \"Asia/Tokyo\", \"Australia/Eucla\", \"Asia/Singapore\", \"Asia/Rangoon\", \"Indian/Chagos\", \"Asia/Calcutta\", \n+            \"Asia/Tashkent\", \"Asia/Tehran\", \"Asia/Dubai\", \"Africa/Nairobi\", \"Europe/Brussels\", \"Europe/Vienna\", \"Europe/London\", \n+            \"Etc/GMT+12\",\n+            // short names of zones\n+            \"GMT\", \"UTC\", \"CET\",\n+            // offsets\n+            \"+11:00\", \"+04:30\", \"+01:00\", \"+00:00\", \"-00:00\", \"-01:15\", \"-02:00\", \"-11:00\");\n+\n+        private final int id;\n+        private final BigDecimal secondsAndFractionsSinceEpoch;\n+        private final String formatString;\n+        private final String zoneId;\n+        \n+        TestCase(BigDecimal secondsAndFractionsSinceEpoch, String formatString) {\n+            this.id = COUNTER.incrementAndGet();\n+            this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+            this.formatString = formatString;\n+            this.zoneId = TestGenerator.randomFromCollection(POSTGRES_TEST_ZONE_LIST);\n+        }\n+\n+    }\n+\n+    /**\n+     * Generates an sql file that can be used to generate the test dataset for this unit test (to be used with the <code>psql</code> cli).\n+     *\n+     * Run the @{link {@link TestGenerator#main(String[])}} class and execute the following command to generate the output dataset with:\n+     *\n+     * <p>\n+     *  <code>\n+     *      # easy way to spin up the latest Postgres\n+     *      docker run --rm --name postgres-latest -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres:latest\n+     *\n+     *      # generate the csv for the unit test\n+     *      PGPASSWORD=\"mysecretpassword\" psql --quiet -h localhost -p 5432 -U postgres -f /tmp/postgresql-tochar-test.sql \\\n+     *          &gt; /path/to/tochar.csv\n+     *  </code>\n+     * </p>\n+     */\n+    private static class TestGenerator {\n+        \n+        private static final long SECONDS_IN_YEAR = 365 * 24 * 60 * 60L;\n+        private static final String DELIMITER = \"|\";\n+        private static final String PATTERN_DELIMITER = \" @ \";\n+        // these patterns are hard to sync up between PostgreSQL and Elasticsearch, so we just warn, but actually\n+        // accept the output of Elasticsearch as is\n+        private static final Set<String> NOT_FULLY_MATCHABLE_PATTERNS = Set.of(\"TZ\", \"tz\");\n+        private static final Set<String> UNSUPPORTED_PATTERN_MODIFIERS = Set.of(\"FX\", \"TM\", \"SP\");\n+        private static final String[] PATTERNS = new String[] {\n+            \"HH\", \"HH12\", \"HH24\", \"MI\", \"SS\", \"MS\", \"US\", \"FF1\", \"FF2\", \"FF3\", \"FF4\", \"FF5\", \"FF6\", \"SSSS\", \"SSSSS\", \"AM\", \"am\", \"PM\",\n+            \"pm\", \"A.M.\", \"a.m.\", \"P.M.\", \"p.m.\", \"Y,YYY\", \"YYYY\", \"YYY\", \"YY\", \"Y\", \"IYYY\", \"IYY\", \"IY\", \"I\", \"BC\", \"bc\", \"AD\", \"ad\",\n+            \"B.C.\", \"b.c.\", \"A.D.\", \"a.d.\", \"MONTH\", \"Month\", \"month\", \"MON\", \"Mon\", \"mon\", \"MM\", \"DAY\", \"Day\", \"day\", \"DY\", \"Dy\",\n+            \"dy\", \"DDD\", \"IDDD\", \"DD\", \"D\", \"ID\", \"W\", \"WW\", \"IW\", \"CC\", \"J\", \"Q\", \"RM\", \"rm\", \"TZ\", \"tz\", \"TZH\", \"TZM\", \"OF\"\n+        };\n+        private static final List<String> FILL_MODIFIERS = List.of(\"FM\", \"fm\", \"\");\n+        private static final List<String> ORDINAL_SUFFIX_MODIFIERS = List.of(\"TH\", \"th\", \"\");\n+\n+        @SuppressForbidden(reason = \"It is ok to use ThreadLocalRandom outside of an actual test\")\n+        private static Random rnd() {\n+            return ThreadLocalRandom.current();\n+        }\n+\n+        private static BigDecimal randomSecondsWithFractions(int minYear, int maxYear) {\n+            BigDecimal seconds = new BigDecimal(RandomNumbers.randomLongBetween(rnd(), \n+                (minYear - 1970) * SECONDS_IN_YEAR, (maxYear - 1970) * SECONDS_IN_YEAR));\n+            BigDecimal fractions = new BigDecimal(RandomNumbers.randomIntBetween(rnd(), 0, 999_999)).movePointLeft(6);\n+            return seconds.add(fractions);\n+        }\n+\n+        private static <T> T randomFromCollection(Collection<T> list) {\n+            List<T> l = new ArrayList<>(list);\n+            return l.get(rnd().nextInt(l.size()));\n+        }\n+        \n+        private static String patternWithRandomModifiers(String pattern) {\n+            if (NOT_FULLY_MATCHABLE_PATTERNS.contains(pattern)) {\n+                return pattern;\n+            }\n+            return randomFromCollection(FILL_MODIFIERS) + pattern + randomFromCollection(ORDINAL_SUFFIX_MODIFIERS);\n+        }\n+    \n+        private static List<TestCase> generateTestCases() {\n+            \n+            final List<BigDecimal> testEpochSeconds = new LinkedList<>();\n+            for (int i = 0; i < 50; i++) {\n+                testEpochSeconds.add(randomSecondsWithFractions(-1200, 2500));\n+            }\n+            for (int i = 0; i < 5; i++) {\n+                testEpochSeconds.add(randomSecondsWithFractions(-1, 1));\n+            }\n+    \n+            List<TestCase> testCases = new ArrayList<>();\n+    \n+            // check each format string alone\n+            for (String pattern : PATTERNS) {\n+                testCases.add(new TestCase(randomFromCollection(testEpochSeconds), NOT_FULLY_MATCHABLE_PATTERNS.contains(pattern) \n+                    ? pattern \n+                    : String.join(PATTERN_DELIMITER, pattern, FILL_MODIFIERS.get(0) + pattern + ORDINAL_SUFFIX_MODIFIERS.get(0))));\n+            }\n+            \n+            // let's check all of the format strings with a non-ambiguous format string\n+            for (BigDecimal es : testEpochSeconds) {\n+                testCases.add(new TestCase(es, IntStream.range(0, PATTERNS.length)\n+                    .mapToObj(idx -> idx + \":\" + patternWithRandomModifiers(PATTERNS[idx]))\n+                    .collect(Collectors.joining(PATTERN_DELIMITER))));\n+            }\n+    \n+            // check the lowercase versions of the format strings\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), IntStream.range(0, PATTERNS.length)\n+                .mapToObj(idx -> (idx + \":\" + patternWithRandomModifiers(PATTERNS[idx])).toLowerCase(Locale.ROOT))\n+                .collect(Collectors.joining(PATTERN_DELIMITER))));\n+    \n+            // potentially ambiguous format string test cases, to check if our format string parsing is in-sync with PostgreSQL\n+            // greedy and prefers the longer format strings\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"YYYYYYYYYYYYYYY,YYYYYYYYY\"));\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"SSSSSSSSSSSSSSSS\"));\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"DDDDDDDD\"));\n+    \n+            // Roman numbers\n+            for (int i = 1; i <= 12; i++) {\n+                testCases.add(new TestCase(\n+                    new BigDecimal(dateTime(0).withMonth(i).toEpochSecond()), rnd().nextBoolean() ? \"RM\" : \"rm\"));\n+            }\n+            \n+            // random strings made out of template patterns and random characters\n+            final String randomCharacters = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYabcdefghijklmnopqrstuvwxy _-.:;\";\n+            final List<String> formatStringsToRandomTest = Arrays.stream(PATTERNS)\n+                .filter(s -> NOT_FULLY_MATCHABLE_PATTERNS.contains(s) == false)\n+                .collect(Collectors.toList());\n+            \n+            for (int i = 0; i < 20; i++) {\n+                String patternWithLiterals = IntStream.rangeClosed(1, 30).mapToObj(idx -> \n+                    rnd().nextInt(100) < 80 \n+                        ? randomCharacters.substring(rnd().nextInt(randomCharacters.length())).substring(0, 1) \n+                        : (randomFromCollection(FILL_MODIFIERS) \n+                            + randomFromCollection(formatStringsToRandomTest) \n+                            + randomFromCollection(ORDINAL_SUFFIX_MODIFIERS)))\n+                    .collect(Collectors.joining());\n+                \n+                // clean up the random string from the unsupported modifiers\n+                for (String unsupportedPatternModifier : UNSUPPORTED_PATTERN_MODIFIERS) {\n+                    patternWithLiterals = patternWithLiterals\n+                        .replace(unsupportedPatternModifier, \"\")\n+                        .replace(unsupportedPatternModifier.toLowerCase(Locale.ROOT), \"\");\n+                }\n+                testCases.add(new TestCase(randomFromCollection(testEpochSeconds), patternWithLiterals));\n+            }\n+    \n+            return testCases;\n+        }\n+        \n+        private static String adjustZoneIdToPostgres(String zoneId) {\n+            // when the zone is specified by the offset in Postgres, it follows the POSIX definition, so the +- signs are flipped\n+            // compared to ISO-8601, see more info at: https://www.postgresql.org/docs/current/datetime-posix-timezone-specs.html\n+            if (zoneId.startsWith(\"+\")) {\n+                zoneId = zoneId.replaceFirst(quote(\"+\"), \"-\");\n+            } else if (zoneId.startsWith(\"-\")) {\n+                zoneId = zoneId.replaceFirst(quote(\"-\"), \"+\");\n+            }\n+            return zoneId;\n+        }\n+        \n+        /**\n+         * Generates an SQL file that can be used to create the test dataset for the unit test of the <code>TO_CHAR</code>\n+         * implementation. In case the <code>TO_CHAR</code> implementation needs an upgrade, add the list of the new format\n+         * strings to the list of the format string, regenerate the SQL, run it against the PostgreSQL version you are targeting\n+         * and update the test CSV file.\n+         */\n+        private static String unitTestExporterScript() {\n+            return generateTestCases().stream().map(tc -> {\n+                long seconds = tc.secondsAndFractionsSinceEpoch.longValue();\n+                BigDecimal fractions = tc.secondsAndFractionsSinceEpoch.remainder(BigDecimal.ONE).movePointRight(6);\n+                return String.format(Locale.ROOT,\n+                    \"SET TIME ZONE '%7$s';\\n\" +\n+                    \"\\\\copy (SELECT %1$d as id, %2$s as epoch_seconds_and_microsends, '%6$s' as zone_id, '%5$s' as format_string, \" +\n+                        \"(TO_TIMESTAMP(%3$d) + INTERVAL '%4$d microseconds') as to_timestamp_result, \" +\n+                        \"TO_CHAR((TO_TIMESTAMP(%3$d) + INTERVAL '%4$d microseconds'), '%5$s') as to_char_result) to stdout \" +\n+                        \"with DELIMITER as '\" + DELIMITER + \"' NULL as '' csv \\n\",\n+                    tc.id, tc.secondsAndFractionsSinceEpoch.toPlainString(), seconds, fractions.intValue(), tc.formatString, tc.zoneId, \n+                    adjustZoneIdToPostgres(tc.zoneId)\n+                );\n+            }).collect(Collectors.joining(\"\\n\"));\n+        }\n+        \n+        public static void main(String[] args) throws Exception {\n+            String scriptFilename = args.length < 1 ? \"/tmp/postgresql-tochar-test.sql\" : args[0];\n+            Files.writeString(Path.of(scriptFilename), unitTestExporterScript(), StandardCharsets.UTF_8);\n+        }\n+    }\n+\n+    @ParametersFactory(argumentFormatting = \"%1$s: timestamp=%5$s, zone=%3$s, format=%4$s\")\n+    public static List<Object[]> readCsv() throws Exception {\n+        Path testFilePath = Path.of(DateTimeToCharProcessorTests.class.getResource(\"tochar.csv\").toURI());\n+        return Files.readAllLines(testFilePath).stream().map(line -> {\n+            String[] cols = line.split(quote(TestGenerator.DELIMITER));\n+            return new Object[]{ cols[0], cols[1], cols[2], cols[3], cols[4], cols[5] };\n+        }).collect(Collectors.toList());\n+    }\n+\n+    private final String id;\n+    private final String secondsAndFractionsSinceEpoch;\n+    private final String zone;\n+    private final String formatString;\n+    private final String posgresTimestamp;\n+    private final String expectedResult;\n+\n+    public DateTimeToCharProcessorTests(String id, String secondsAndFractionsSinceEpoch, String zone, String formatString,\n+        String postgresTimestamp, String expectedResult) {\n+        this.id = id;\n+        this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+        this.zone = zone;\n+        this.formatString = formatString;\n+        this.posgresTimestamp = postgresTimestamp;\n+        this.expectedResult = expectedResult;\n+    }\n+\n+    private static ZonedDateTime dateTimeWithFractions(String secondAndFractionsSinceEpoch) {\n+        BigDecimal b = new BigDecimal(secondAndFractionsSinceEpoch);\n+        long seconds = b.longValue();\n+        int fractions = b.remainder(BigDecimal.ONE).movePointRight(9).intValueExact();\n+        int adjustment = 0;\n+        if (fractions < 0) {\n+            fractions += 1e9;\n+            adjustment = -1;\n+        }\n+        return dateTime((seconds + adjustment) * 1000).withNano(fractions);\n+    }\n+    \n+    public void test() throws Exception {\n+        ZoneId zoneId = ZoneId.of(zone);\n+        ZonedDateTime timestamp = dateTimeWithFractions(secondsAndFractionsSinceEpoch);\n+        String actualResult =\n+            (String) new ToChar(Source.EMPTY, l(timestamp, DataTypes.DATETIME), l(formatString, DataTypes.KEYWORD), zoneId)\n+                .makePipe()\n+                .asProcessor()\n+                .process(null);\n+        List<String> expectedResultSplitted = List.of(expectedResult.split(quote(TestGenerator.PATTERN_DELIMITER)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 285}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQyNDIxNw==", "bodyText": "Done.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r553424217", "createdAt": "2021-01-07T16:06:50Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    private static class TestCase {\n+        private static final AtomicInteger COUNTER = new AtomicInteger(0);\n+        \n+        // timezones that are valid both in Java and in Postgres\n+        public static final List<String> POSTGRES_TEST_ZONE_LIST = List.of(\n+            // location-based and long-names\n+            \"US/Samoa\", \"Pacific/Honolulu\", \"Pacific/Marquesas\", \"Pacific/Gambier\", \"America/Juneau\", \"Canada/Yukon\", \"America/Vancouver\",\n+            \"Pacific/Easter\", \"US/Mountain\", \"America/Chicago\", \"US/Michigan\", \"Atlantic/Bermuda\", \"Canada/Newfoundland\",\n+            \"Atlantic/Cape_Verde\", \"Pacific/Kiritimati\", \"Pacific/Chatham\", \"Pacific/Auckland\", \"Asia/Sakhalin\", \"Australia/Tasmania\", \n+            \"Australia/North\", \"Asia/Tokyo\", \"Australia/Eucla\", \"Asia/Singapore\", \"Asia/Rangoon\", \"Indian/Chagos\", \"Asia/Calcutta\", \n+            \"Asia/Tashkent\", \"Asia/Tehran\", \"Asia/Dubai\", \"Africa/Nairobi\", \"Europe/Brussels\", \"Europe/Vienna\", \"Europe/London\", \n+            \"Etc/GMT+12\",\n+            // short names of zones\n+            \"GMT\", \"UTC\", \"CET\",\n+            // offsets\n+            \"+11:00\", \"+04:30\", \"+01:00\", \"+00:00\", \"-00:00\", \"-01:15\", \"-02:00\", \"-11:00\");\n+\n+        private final int id;\n+        private final BigDecimal secondsAndFractionsSinceEpoch;\n+        private final String formatString;\n+        private final String zoneId;\n+        \n+        TestCase(BigDecimal secondsAndFractionsSinceEpoch, String formatString) {\n+            this.id = COUNTER.incrementAndGet();\n+            this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+            this.formatString = formatString;\n+            this.zoneId = TestGenerator.randomFromCollection(POSTGRES_TEST_ZONE_LIST);\n+        }\n+\n+    }\n+\n+    /**\n+     * Generates an sql file that can be used to generate the test dataset for this unit test (to be used with the <code>psql</code> cli).\n+     *\n+     * Run the @{link {@link TestGenerator#main(String[])}} class and execute the following command to generate the output dataset with:\n+     *\n+     * <p>\n+     *  <code>\n+     *      # easy way to spin up the latest Postgres\n+     *      docker run --rm --name postgres-latest -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres:latest\n+     *\n+     *      # generate the csv for the unit test\n+     *      PGPASSWORD=\"mysecretpassword\" psql --quiet -h localhost -p 5432 -U postgres -f /tmp/postgresql-tochar-test.sql \\\n+     *          &gt; /path/to/tochar.csv\n+     *  </code>\n+     * </p>\n+     */\n+    private static class TestGenerator {\n+        \n+        private static final long SECONDS_IN_YEAR = 365 * 24 * 60 * 60L;\n+        private static final String DELIMITER = \"|\";\n+        private static final String PATTERN_DELIMITER = \" @ \";\n+        // these patterns are hard to sync up between PostgreSQL and Elasticsearch, so we just warn, but actually\n+        // accept the output of Elasticsearch as is\n+        private static final Set<String> NOT_FULLY_MATCHABLE_PATTERNS = Set.of(\"TZ\", \"tz\");\n+        private static final Set<String> UNSUPPORTED_PATTERN_MODIFIERS = Set.of(\"FX\", \"TM\", \"SP\");\n+        private static final String[] PATTERNS = new String[] {\n+            \"HH\", \"HH12\", \"HH24\", \"MI\", \"SS\", \"MS\", \"US\", \"FF1\", \"FF2\", \"FF3\", \"FF4\", \"FF5\", \"FF6\", \"SSSS\", \"SSSSS\", \"AM\", \"am\", \"PM\",\n+            \"pm\", \"A.M.\", \"a.m.\", \"P.M.\", \"p.m.\", \"Y,YYY\", \"YYYY\", \"YYY\", \"YY\", \"Y\", \"IYYY\", \"IYY\", \"IY\", \"I\", \"BC\", \"bc\", \"AD\", \"ad\",\n+            \"B.C.\", \"b.c.\", \"A.D.\", \"a.d.\", \"MONTH\", \"Month\", \"month\", \"MON\", \"Mon\", \"mon\", \"MM\", \"DAY\", \"Day\", \"day\", \"DY\", \"Dy\",\n+            \"dy\", \"DDD\", \"IDDD\", \"DD\", \"D\", \"ID\", \"W\", \"WW\", \"IW\", \"CC\", \"J\", \"Q\", \"RM\", \"rm\", \"TZ\", \"tz\", \"TZH\", \"TZM\", \"OF\"\n+        };\n+        private static final List<String> FILL_MODIFIERS = List.of(\"FM\", \"fm\", \"\");\n+        private static final List<String> ORDINAL_SUFFIX_MODIFIERS = List.of(\"TH\", \"th\", \"\");\n+\n+        @SuppressForbidden(reason = \"It is ok to use ThreadLocalRandom outside of an actual test\")\n+        private static Random rnd() {\n+            return ThreadLocalRandom.current();\n+        }\n+\n+        private static BigDecimal randomSecondsWithFractions(int minYear, int maxYear) {\n+            BigDecimal seconds = new BigDecimal(RandomNumbers.randomLongBetween(rnd(), \n+                (minYear - 1970) * SECONDS_IN_YEAR, (maxYear - 1970) * SECONDS_IN_YEAR));\n+            BigDecimal fractions = new BigDecimal(RandomNumbers.randomIntBetween(rnd(), 0, 999_999)).movePointLeft(6);\n+            return seconds.add(fractions);\n+        }\n+\n+        private static <T> T randomFromCollection(Collection<T> list) {\n+            List<T> l = new ArrayList<>(list);\n+            return l.get(rnd().nextInt(l.size()));\n+        }\n+        \n+        private static String patternWithRandomModifiers(String pattern) {\n+            if (NOT_FULLY_MATCHABLE_PATTERNS.contains(pattern)) {\n+                return pattern;\n+            }\n+            return randomFromCollection(FILL_MODIFIERS) + pattern + randomFromCollection(ORDINAL_SUFFIX_MODIFIERS);\n+        }\n+    \n+        private static List<TestCase> generateTestCases() {\n+            \n+            final List<BigDecimal> testEpochSeconds = new LinkedList<>();\n+            for (int i = 0; i < 50; i++) {\n+                testEpochSeconds.add(randomSecondsWithFractions(-1200, 2500));\n+            }\n+            for (int i = 0; i < 5; i++) {\n+                testEpochSeconds.add(randomSecondsWithFractions(-1, 1));\n+            }\n+    \n+            List<TestCase> testCases = new ArrayList<>();\n+    \n+            // check each format string alone\n+            for (String pattern : PATTERNS) {\n+                testCases.add(new TestCase(randomFromCollection(testEpochSeconds), NOT_FULLY_MATCHABLE_PATTERNS.contains(pattern) \n+                    ? pattern \n+                    : String.join(PATTERN_DELIMITER, pattern, FILL_MODIFIERS.get(0) + pattern + ORDINAL_SUFFIX_MODIFIERS.get(0))));\n+            }\n+            \n+            // let's check all of the format strings with a non-ambiguous format string\n+            for (BigDecimal es : testEpochSeconds) {\n+                testCases.add(new TestCase(es, IntStream.range(0, PATTERNS.length)\n+                    .mapToObj(idx -> idx + \":\" + patternWithRandomModifiers(PATTERNS[idx]))\n+                    .collect(Collectors.joining(PATTERN_DELIMITER))));\n+            }\n+    \n+            // check the lowercase versions of the format strings\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), IntStream.range(0, PATTERNS.length)\n+                .mapToObj(idx -> (idx + \":\" + patternWithRandomModifiers(PATTERNS[idx])).toLowerCase(Locale.ROOT))\n+                .collect(Collectors.joining(PATTERN_DELIMITER))));\n+    \n+            // potentially ambiguous format string test cases, to check if our format string parsing is in-sync with PostgreSQL\n+            // greedy and prefers the longer format strings\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"YYYYYYYYYYYYYYY,YYYYYYYYY\"));\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"SSSSSSSSSSSSSSSS\"));\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"DDDDDDDD\"));\n+    \n+            // Roman numbers\n+            for (int i = 1; i <= 12; i++) {\n+                testCases.add(new TestCase(\n+                    new BigDecimal(dateTime(0).withMonth(i).toEpochSecond()), rnd().nextBoolean() ? \"RM\" : \"rm\"));\n+            }\n+            \n+            // random strings made out of template patterns and random characters\n+            final String randomCharacters = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYabcdefghijklmnopqrstuvwxy _-.:;\";\n+            final List<String> formatStringsToRandomTest = Arrays.stream(PATTERNS)\n+                .filter(s -> NOT_FULLY_MATCHABLE_PATTERNS.contains(s) == false)\n+                .collect(Collectors.toList());\n+            \n+            for (int i = 0; i < 20; i++) {\n+                String patternWithLiterals = IntStream.rangeClosed(1, 30).mapToObj(idx -> \n+                    rnd().nextInt(100) < 80 \n+                        ? randomCharacters.substring(rnd().nextInt(randomCharacters.length())).substring(0, 1) \n+                        : (randomFromCollection(FILL_MODIFIERS) \n+                            + randomFromCollection(formatStringsToRandomTest) \n+                            + randomFromCollection(ORDINAL_SUFFIX_MODIFIERS)))\n+                    .collect(Collectors.joining());\n+                \n+                // clean up the random string from the unsupported modifiers\n+                for (String unsupportedPatternModifier : UNSUPPORTED_PATTERN_MODIFIERS) {\n+                    patternWithLiterals = patternWithLiterals\n+                        .replace(unsupportedPatternModifier, \"\")\n+                        .replace(unsupportedPatternModifier.toLowerCase(Locale.ROOT), \"\");\n+                }\n+                testCases.add(new TestCase(randomFromCollection(testEpochSeconds), patternWithLiterals));\n+            }\n+    \n+            return testCases;\n+        }\n+        \n+        private static String adjustZoneIdToPostgres(String zoneId) {\n+            // when the zone is specified by the offset in Postgres, it follows the POSIX definition, so the +- signs are flipped\n+            // compared to ISO-8601, see more info at: https://www.postgresql.org/docs/current/datetime-posix-timezone-specs.html\n+            if (zoneId.startsWith(\"+\")) {\n+                zoneId = zoneId.replaceFirst(quote(\"+\"), \"-\");\n+            } else if (zoneId.startsWith(\"-\")) {\n+                zoneId = zoneId.replaceFirst(quote(\"-\"), \"+\");\n+            }\n+            return zoneId;\n+        }\n+        \n+        /**\n+         * Generates an SQL file that can be used to create the test dataset for the unit test of the <code>TO_CHAR</code>\n+         * implementation. In case the <code>TO_CHAR</code> implementation needs an upgrade, add the list of the new format\n+         * strings to the list of the format string, regenerate the SQL, run it against the PostgreSQL version you are targeting\n+         * and update the test CSV file.\n+         */\n+        private static String unitTestExporterScript() {\n+            return generateTestCases().stream().map(tc -> {\n+                long seconds = tc.secondsAndFractionsSinceEpoch.longValue();\n+                BigDecimal fractions = tc.secondsAndFractionsSinceEpoch.remainder(BigDecimal.ONE).movePointRight(6);\n+                return String.format(Locale.ROOT,\n+                    \"SET TIME ZONE '%7$s';\\n\" +\n+                    \"\\\\copy (SELECT %1$d as id, %2$s as epoch_seconds_and_microsends, '%6$s' as zone_id, '%5$s' as format_string, \" +\n+                        \"(TO_TIMESTAMP(%3$d) + INTERVAL '%4$d microseconds') as to_timestamp_result, \" +\n+                        \"TO_CHAR((TO_TIMESTAMP(%3$d) + INTERVAL '%4$d microseconds'), '%5$s') as to_char_result) to stdout \" +\n+                        \"with DELIMITER as '\" + DELIMITER + \"' NULL as '' csv \\n\",\n+                    tc.id, tc.secondsAndFractionsSinceEpoch.toPlainString(), seconds, fractions.intValue(), tc.formatString, tc.zoneId, \n+                    adjustZoneIdToPostgres(tc.zoneId)\n+                );\n+            }).collect(Collectors.joining(\"\\n\"));\n+        }\n+        \n+        public static void main(String[] args) throws Exception {\n+            String scriptFilename = args.length < 1 ? \"/tmp/postgresql-tochar-test.sql\" : args[0];\n+            Files.writeString(Path.of(scriptFilename), unitTestExporterScript(), StandardCharsets.UTF_8);\n+        }\n+    }\n+\n+    @ParametersFactory(argumentFormatting = \"%1$s: timestamp=%5$s, zone=%3$s, format=%4$s\")\n+    public static List<Object[]> readCsv() throws Exception {\n+        Path testFilePath = Path.of(DateTimeToCharProcessorTests.class.getResource(\"tochar.csv\").toURI());\n+        return Files.readAllLines(testFilePath).stream().map(line -> {\n+            String[] cols = line.split(quote(TestGenerator.DELIMITER));\n+            return new Object[]{ cols[0], cols[1], cols[2], cols[3], cols[4], cols[5] };\n+        }).collect(Collectors.toList());\n+    }\n+\n+    private final String id;\n+    private final String secondsAndFractionsSinceEpoch;\n+    private final String zone;\n+    private final String formatString;\n+    private final String posgresTimestamp;\n+    private final String expectedResult;\n+\n+    public DateTimeToCharProcessorTests(String id, String secondsAndFractionsSinceEpoch, String zone, String formatString,\n+        String postgresTimestamp, String expectedResult) {\n+        this.id = id;\n+        this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+        this.zone = zone;\n+        this.formatString = formatString;\n+        this.posgresTimestamp = postgresTimestamp;\n+        this.expectedResult = expectedResult;\n+    }\n+\n+    private static ZonedDateTime dateTimeWithFractions(String secondAndFractionsSinceEpoch) {\n+        BigDecimal b = new BigDecimal(secondAndFractionsSinceEpoch);\n+        long seconds = b.longValue();\n+        int fractions = b.remainder(BigDecimal.ONE).movePointRight(9).intValueExact();\n+        int adjustment = 0;\n+        if (fractions < 0) {\n+            fractions += 1e9;\n+            adjustment = -1;\n+        }\n+        return dateTime((seconds + adjustment) * 1000).withNano(fractions);\n+    }\n+    \n+    public void test() throws Exception {\n+        ZoneId zoneId = ZoneId.of(zone);\n+        ZonedDateTime timestamp = dateTimeWithFractions(secondsAndFractionsSinceEpoch);\n+        String actualResult =\n+            (String) new ToChar(Source.EMPTY, l(timestamp, DataTypes.DATETIME), l(formatString, DataTypes.KEYWORD), zoneId)\n+                .makePipe()\n+                .asProcessor()\n+                .process(null);\n+        List<String> expectedResultSplitted = List.of(expectedResult.split(quote(TestGenerator.PATTERN_DELIMITER)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA1NTMzMw=="}, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 285}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NDUyMzg1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNjo0OToyMFrOIOe36w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxNjowNzozN1rOIPyXew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA1NjgxMQ==", "bodyText": "Please add some docs on the number of arguments and their purpose so that folks that pick this test in the future under what they're after without having to dig too much into Postgres.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552056811", "createdAt": "2021-01-05T16:49:20Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    private static class TestCase {\n+        private static final AtomicInteger COUNTER = new AtomicInteger(0);\n+        \n+        // timezones that are valid both in Java and in Postgres\n+        public static final List<String> POSTGRES_TEST_ZONE_LIST = List.of(\n+            // location-based and long-names\n+            \"US/Samoa\", \"Pacific/Honolulu\", \"Pacific/Marquesas\", \"Pacific/Gambier\", \"America/Juneau\", \"Canada/Yukon\", \"America/Vancouver\",\n+            \"Pacific/Easter\", \"US/Mountain\", \"America/Chicago\", \"US/Michigan\", \"Atlantic/Bermuda\", \"Canada/Newfoundland\",\n+            \"Atlantic/Cape_Verde\", \"Pacific/Kiritimati\", \"Pacific/Chatham\", \"Pacific/Auckland\", \"Asia/Sakhalin\", \"Australia/Tasmania\", \n+            \"Australia/North\", \"Asia/Tokyo\", \"Australia/Eucla\", \"Asia/Singapore\", \"Asia/Rangoon\", \"Indian/Chagos\", \"Asia/Calcutta\", \n+            \"Asia/Tashkent\", \"Asia/Tehran\", \"Asia/Dubai\", \"Africa/Nairobi\", \"Europe/Brussels\", \"Europe/Vienna\", \"Europe/London\", \n+            \"Etc/GMT+12\",\n+            // short names of zones\n+            \"GMT\", \"UTC\", \"CET\",\n+            // offsets\n+            \"+11:00\", \"+04:30\", \"+01:00\", \"+00:00\", \"-00:00\", \"-01:15\", \"-02:00\", \"-11:00\");\n+\n+        private final int id;\n+        private final BigDecimal secondsAndFractionsSinceEpoch;\n+        private final String formatString;\n+        private final String zoneId;\n+        \n+        TestCase(BigDecimal secondsAndFractionsSinceEpoch, String formatString) {\n+            this.id = COUNTER.incrementAndGet();\n+            this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+            this.formatString = formatString;\n+            this.zoneId = TestGenerator.randomFromCollection(POSTGRES_TEST_ZONE_LIST);\n+        }\n+\n+    }\n+\n+    /**\n+     * Generates an sql file that can be used to generate the test dataset for this unit test (to be used with the <code>psql</code> cli).\n+     *\n+     * Run the @{link {@link TestGenerator#main(String[])}} class and execute the following command to generate the output dataset with:\n+     *\n+     * <p>\n+     *  <code>\n+     *      # easy way to spin up the latest Postgres\n+     *      docker run --rm --name postgres-latest -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres:latest\n+     *\n+     *      # generate the csv for the unit test\n+     *      PGPASSWORD=\"mysecretpassword\" psql --quiet -h localhost -p 5432 -U postgres -f /tmp/postgresql-tochar-test.sql \\\n+     *          &gt; /path/to/tochar.csv\n+     *  </code>\n+     * </p>\n+     */\n+    private static class TestGenerator {\n+        \n+        private static final long SECONDS_IN_YEAR = 365 * 24 * 60 * 60L;\n+        private static final String DELIMITER = \"|\";\n+        private static final String PATTERN_DELIMITER = \" @ \";\n+        // these patterns are hard to sync up between PostgreSQL and Elasticsearch, so we just warn, but actually\n+        // accept the output of Elasticsearch as is\n+        private static final Set<String> NOT_FULLY_MATCHABLE_PATTERNS = Set.of(\"TZ\", \"tz\");\n+        private static final Set<String> UNSUPPORTED_PATTERN_MODIFIERS = Set.of(\"FX\", \"TM\", \"SP\");\n+        private static final String[] PATTERNS = new String[] {\n+            \"HH\", \"HH12\", \"HH24\", \"MI\", \"SS\", \"MS\", \"US\", \"FF1\", \"FF2\", \"FF3\", \"FF4\", \"FF5\", \"FF6\", \"SSSS\", \"SSSSS\", \"AM\", \"am\", \"PM\",\n+            \"pm\", \"A.M.\", \"a.m.\", \"P.M.\", \"p.m.\", \"Y,YYY\", \"YYYY\", \"YYY\", \"YY\", \"Y\", \"IYYY\", \"IYY\", \"IY\", \"I\", \"BC\", \"bc\", \"AD\", \"ad\",\n+            \"B.C.\", \"b.c.\", \"A.D.\", \"a.d.\", \"MONTH\", \"Month\", \"month\", \"MON\", \"Mon\", \"mon\", \"MM\", \"DAY\", \"Day\", \"day\", \"DY\", \"Dy\",\n+            \"dy\", \"DDD\", \"IDDD\", \"DD\", \"D\", \"ID\", \"W\", \"WW\", \"IW\", \"CC\", \"J\", \"Q\", \"RM\", \"rm\", \"TZ\", \"tz\", \"TZH\", \"TZM\", \"OF\"\n+        };\n+        private static final List<String> FILL_MODIFIERS = List.of(\"FM\", \"fm\", \"\");\n+        private static final List<String> ORDINAL_SUFFIX_MODIFIERS = List.of(\"TH\", \"th\", \"\");\n+\n+        @SuppressForbidden(reason = \"It is ok to use ThreadLocalRandom outside of an actual test\")\n+        private static Random rnd() {\n+            return ThreadLocalRandom.current();\n+        }\n+\n+        private static BigDecimal randomSecondsWithFractions(int minYear, int maxYear) {\n+            BigDecimal seconds = new BigDecimal(RandomNumbers.randomLongBetween(rnd(), \n+                (minYear - 1970) * SECONDS_IN_YEAR, (maxYear - 1970) * SECONDS_IN_YEAR));\n+            BigDecimal fractions = new BigDecimal(RandomNumbers.randomIntBetween(rnd(), 0, 999_999)).movePointLeft(6);\n+            return seconds.add(fractions);\n+        }\n+\n+        private static <T> T randomFromCollection(Collection<T> list) {\n+            List<T> l = new ArrayList<>(list);\n+            return l.get(rnd().nextInt(l.size()));\n+        }\n+        \n+        private static String patternWithRandomModifiers(String pattern) {\n+            if (NOT_FULLY_MATCHABLE_PATTERNS.contains(pattern)) {\n+                return pattern;\n+            }\n+            return randomFromCollection(FILL_MODIFIERS) + pattern + randomFromCollection(ORDINAL_SUFFIX_MODIFIERS);\n+        }\n+    \n+        private static List<TestCase> generateTestCases() {\n+            \n+            final List<BigDecimal> testEpochSeconds = new LinkedList<>();\n+            for (int i = 0; i < 50; i++) {\n+                testEpochSeconds.add(randomSecondsWithFractions(-1200, 2500));\n+            }\n+            for (int i = 0; i < 5; i++) {\n+                testEpochSeconds.add(randomSecondsWithFractions(-1, 1));\n+            }\n+    \n+            List<TestCase> testCases = new ArrayList<>();\n+    \n+            // check each format string alone\n+            for (String pattern : PATTERNS) {\n+                testCases.add(new TestCase(randomFromCollection(testEpochSeconds), NOT_FULLY_MATCHABLE_PATTERNS.contains(pattern) \n+                    ? pattern \n+                    : String.join(PATTERN_DELIMITER, pattern, FILL_MODIFIERS.get(0) + pattern + ORDINAL_SUFFIX_MODIFIERS.get(0))));\n+            }\n+            \n+            // let's check all of the format strings with a non-ambiguous format string\n+            for (BigDecimal es : testEpochSeconds) {\n+                testCases.add(new TestCase(es, IntStream.range(0, PATTERNS.length)\n+                    .mapToObj(idx -> idx + \":\" + patternWithRandomModifiers(PATTERNS[idx]))\n+                    .collect(Collectors.joining(PATTERN_DELIMITER))));\n+            }\n+    \n+            // check the lowercase versions of the format strings\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), IntStream.range(0, PATTERNS.length)\n+                .mapToObj(idx -> (idx + \":\" + patternWithRandomModifiers(PATTERNS[idx])).toLowerCase(Locale.ROOT))\n+                .collect(Collectors.joining(PATTERN_DELIMITER))));\n+    \n+            // potentially ambiguous format string test cases, to check if our format string parsing is in-sync with PostgreSQL\n+            // greedy and prefers the longer format strings\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"YYYYYYYYYYYYYYY,YYYYYYYYY\"));\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"SSSSSSSSSSSSSSSS\"));\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"DDDDDDDD\"));\n+    \n+            // Roman numbers\n+            for (int i = 1; i <= 12; i++) {\n+                testCases.add(new TestCase(\n+                    new BigDecimal(dateTime(0).withMonth(i).toEpochSecond()), rnd().nextBoolean() ? \"RM\" : \"rm\"));\n+            }\n+            \n+            // random strings made out of template patterns and random characters\n+            final String randomCharacters = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYabcdefghijklmnopqrstuvwxy _-.:;\";\n+            final List<String> formatStringsToRandomTest = Arrays.stream(PATTERNS)\n+                .filter(s -> NOT_FULLY_MATCHABLE_PATTERNS.contains(s) == false)\n+                .collect(Collectors.toList());\n+            \n+            for (int i = 0; i < 20; i++) {\n+                String patternWithLiterals = IntStream.rangeClosed(1, 30).mapToObj(idx -> \n+                    rnd().nextInt(100) < 80 \n+                        ? randomCharacters.substring(rnd().nextInt(randomCharacters.length())).substring(0, 1) \n+                        : (randomFromCollection(FILL_MODIFIERS) \n+                            + randomFromCollection(formatStringsToRandomTest) \n+                            + randomFromCollection(ORDINAL_SUFFIX_MODIFIERS)))\n+                    .collect(Collectors.joining());\n+                \n+                // clean up the random string from the unsupported modifiers\n+                for (String unsupportedPatternModifier : UNSUPPORTED_PATTERN_MODIFIERS) {\n+                    patternWithLiterals = patternWithLiterals\n+                        .replace(unsupportedPatternModifier, \"\")\n+                        .replace(unsupportedPatternModifier.toLowerCase(Locale.ROOT), \"\");\n+                }\n+                testCases.add(new TestCase(randomFromCollection(testEpochSeconds), patternWithLiterals));\n+            }\n+    \n+            return testCases;\n+        }\n+        \n+        private static String adjustZoneIdToPostgres(String zoneId) {\n+            // when the zone is specified by the offset in Postgres, it follows the POSIX definition, so the +- signs are flipped\n+            // compared to ISO-8601, see more info at: https://www.postgresql.org/docs/current/datetime-posix-timezone-specs.html\n+            if (zoneId.startsWith(\"+\")) {\n+                zoneId = zoneId.replaceFirst(quote(\"+\"), \"-\");\n+            } else if (zoneId.startsWith(\"-\")) {\n+                zoneId = zoneId.replaceFirst(quote(\"-\"), \"+\");\n+            }\n+            return zoneId;\n+        }\n+        \n+        /**\n+         * Generates an SQL file that can be used to create the test dataset for the unit test of the <code>TO_CHAR</code>\n+         * implementation. In case the <code>TO_CHAR</code> implementation needs an upgrade, add the list of the new format\n+         * strings to the list of the format string, regenerate the SQL, run it against the PostgreSQL version you are targeting\n+         * and update the test CSV file.\n+         */\n+        private static String unitTestExporterScript() {\n+            return generateTestCases().stream().map(tc -> {\n+                long seconds = tc.secondsAndFractionsSinceEpoch.longValue();\n+                BigDecimal fractions = tc.secondsAndFractionsSinceEpoch.remainder(BigDecimal.ONE).movePointRight(6);\n+                return String.format(Locale.ROOT,\n+                    \"SET TIME ZONE '%7$s';\\n\" +\n+                    \"\\\\copy (SELECT %1$d as id, %2$s as epoch_seconds_and_microsends, '%6$s' as zone_id, '%5$s' as format_string, \" +\n+                        \"(TO_TIMESTAMP(%3$d) + INTERVAL '%4$d microseconds') as to_timestamp_result, \" +\n+                        \"TO_CHAR((TO_TIMESTAMP(%3$d) + INTERVAL '%4$d microseconds'), '%5$s') as to_char_result) to stdout \" +\n+                        \"with DELIMITER as '\" + DELIMITER + \"' NULL as '' csv \\n\",\n+                    tc.id, tc.secondsAndFractionsSinceEpoch.toPlainString(), seconds, fractions.intValue(), tc.formatString, tc.zoneId, \n+                    adjustZoneIdToPostgres(tc.zoneId)\n+                );\n+            }).collect(Collectors.joining(\"\\n\"));\n+        }\n+        \n+        public static void main(String[] args) throws Exception {\n+            String scriptFilename = args.length < 1 ? \"/tmp/postgresql-tochar-test.sql\" : args[0];\n+            Files.writeString(Path.of(scriptFilename), unitTestExporterScript(), StandardCharsets.UTF_8);\n+        }\n+    }\n+\n+    @ParametersFactory(argumentFormatting = \"%1$s: timestamp=%5$s, zone=%3$s, format=%4$s\")\n+    public static List<Object[]> readCsv() throws Exception {\n+        Path testFilePath = Path.of(DateTimeToCharProcessorTests.class.getResource(\"tochar.csv\").toURI());\n+        return Files.readAllLines(testFilePath).stream().map(line -> {\n+            String[] cols = line.split(quote(TestGenerator.DELIMITER));\n+            return new Object[]{ cols[0], cols[1], cols[2], cols[3], cols[4], cols[5] };\n+        }).collect(Collectors.toList());\n+    }\n+\n+    private final String id;\n+    private final String secondsAndFractionsSinceEpoch;\n+    private final String zone;\n+    private final String formatString;\n+    private final String posgresTimestamp;\n+    private final String expectedResult;\n+\n+    public DateTimeToCharProcessorTests(String id, String secondsAndFractionsSinceEpoch, String zone, String formatString,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 255}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQyNDc2Mw==", "bodyText": "Added docs.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r553424763", "createdAt": "2021-01-07T16:07:37Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    private static class TestCase {\n+        private static final AtomicInteger COUNTER = new AtomicInteger(0);\n+        \n+        // timezones that are valid both in Java and in Postgres\n+        public static final List<String> POSTGRES_TEST_ZONE_LIST = List.of(\n+            // location-based and long-names\n+            \"US/Samoa\", \"Pacific/Honolulu\", \"Pacific/Marquesas\", \"Pacific/Gambier\", \"America/Juneau\", \"Canada/Yukon\", \"America/Vancouver\",\n+            \"Pacific/Easter\", \"US/Mountain\", \"America/Chicago\", \"US/Michigan\", \"Atlantic/Bermuda\", \"Canada/Newfoundland\",\n+            \"Atlantic/Cape_Verde\", \"Pacific/Kiritimati\", \"Pacific/Chatham\", \"Pacific/Auckland\", \"Asia/Sakhalin\", \"Australia/Tasmania\", \n+            \"Australia/North\", \"Asia/Tokyo\", \"Australia/Eucla\", \"Asia/Singapore\", \"Asia/Rangoon\", \"Indian/Chagos\", \"Asia/Calcutta\", \n+            \"Asia/Tashkent\", \"Asia/Tehran\", \"Asia/Dubai\", \"Africa/Nairobi\", \"Europe/Brussels\", \"Europe/Vienna\", \"Europe/London\", \n+            \"Etc/GMT+12\",\n+            // short names of zones\n+            \"GMT\", \"UTC\", \"CET\",\n+            // offsets\n+            \"+11:00\", \"+04:30\", \"+01:00\", \"+00:00\", \"-00:00\", \"-01:15\", \"-02:00\", \"-11:00\");\n+\n+        private final int id;\n+        private final BigDecimal secondsAndFractionsSinceEpoch;\n+        private final String formatString;\n+        private final String zoneId;\n+        \n+        TestCase(BigDecimal secondsAndFractionsSinceEpoch, String formatString) {\n+            this.id = COUNTER.incrementAndGet();\n+            this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+            this.formatString = formatString;\n+            this.zoneId = TestGenerator.randomFromCollection(POSTGRES_TEST_ZONE_LIST);\n+        }\n+\n+    }\n+\n+    /**\n+     * Generates an sql file that can be used to generate the test dataset for this unit test (to be used with the <code>psql</code> cli).\n+     *\n+     * Run the @{link {@link TestGenerator#main(String[])}} class and execute the following command to generate the output dataset with:\n+     *\n+     * <p>\n+     *  <code>\n+     *      # easy way to spin up the latest Postgres\n+     *      docker run --rm --name postgres-latest -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres:latest\n+     *\n+     *      # generate the csv for the unit test\n+     *      PGPASSWORD=\"mysecretpassword\" psql --quiet -h localhost -p 5432 -U postgres -f /tmp/postgresql-tochar-test.sql \\\n+     *          &gt; /path/to/tochar.csv\n+     *  </code>\n+     * </p>\n+     */\n+    private static class TestGenerator {\n+        \n+        private static final long SECONDS_IN_YEAR = 365 * 24 * 60 * 60L;\n+        private static final String DELIMITER = \"|\";\n+        private static final String PATTERN_DELIMITER = \" @ \";\n+        // these patterns are hard to sync up between PostgreSQL and Elasticsearch, so we just warn, but actually\n+        // accept the output of Elasticsearch as is\n+        private static final Set<String> NOT_FULLY_MATCHABLE_PATTERNS = Set.of(\"TZ\", \"tz\");\n+        private static final Set<String> UNSUPPORTED_PATTERN_MODIFIERS = Set.of(\"FX\", \"TM\", \"SP\");\n+        private static final String[] PATTERNS = new String[] {\n+            \"HH\", \"HH12\", \"HH24\", \"MI\", \"SS\", \"MS\", \"US\", \"FF1\", \"FF2\", \"FF3\", \"FF4\", \"FF5\", \"FF6\", \"SSSS\", \"SSSSS\", \"AM\", \"am\", \"PM\",\n+            \"pm\", \"A.M.\", \"a.m.\", \"P.M.\", \"p.m.\", \"Y,YYY\", \"YYYY\", \"YYY\", \"YY\", \"Y\", \"IYYY\", \"IYY\", \"IY\", \"I\", \"BC\", \"bc\", \"AD\", \"ad\",\n+            \"B.C.\", \"b.c.\", \"A.D.\", \"a.d.\", \"MONTH\", \"Month\", \"month\", \"MON\", \"Mon\", \"mon\", \"MM\", \"DAY\", \"Day\", \"day\", \"DY\", \"Dy\",\n+            \"dy\", \"DDD\", \"IDDD\", \"DD\", \"D\", \"ID\", \"W\", \"WW\", \"IW\", \"CC\", \"J\", \"Q\", \"RM\", \"rm\", \"TZ\", \"tz\", \"TZH\", \"TZM\", \"OF\"\n+        };\n+        private static final List<String> FILL_MODIFIERS = List.of(\"FM\", \"fm\", \"\");\n+        private static final List<String> ORDINAL_SUFFIX_MODIFIERS = List.of(\"TH\", \"th\", \"\");\n+\n+        @SuppressForbidden(reason = \"It is ok to use ThreadLocalRandom outside of an actual test\")\n+        private static Random rnd() {\n+            return ThreadLocalRandom.current();\n+        }\n+\n+        private static BigDecimal randomSecondsWithFractions(int minYear, int maxYear) {\n+            BigDecimal seconds = new BigDecimal(RandomNumbers.randomLongBetween(rnd(), \n+                (minYear - 1970) * SECONDS_IN_YEAR, (maxYear - 1970) * SECONDS_IN_YEAR));\n+            BigDecimal fractions = new BigDecimal(RandomNumbers.randomIntBetween(rnd(), 0, 999_999)).movePointLeft(6);\n+            return seconds.add(fractions);\n+        }\n+\n+        private static <T> T randomFromCollection(Collection<T> list) {\n+            List<T> l = new ArrayList<>(list);\n+            return l.get(rnd().nextInt(l.size()));\n+        }\n+        \n+        private static String patternWithRandomModifiers(String pattern) {\n+            if (NOT_FULLY_MATCHABLE_PATTERNS.contains(pattern)) {\n+                return pattern;\n+            }\n+            return randomFromCollection(FILL_MODIFIERS) + pattern + randomFromCollection(ORDINAL_SUFFIX_MODIFIERS);\n+        }\n+    \n+        private static List<TestCase> generateTestCases() {\n+            \n+            final List<BigDecimal> testEpochSeconds = new LinkedList<>();\n+            for (int i = 0; i < 50; i++) {\n+                testEpochSeconds.add(randomSecondsWithFractions(-1200, 2500));\n+            }\n+            for (int i = 0; i < 5; i++) {\n+                testEpochSeconds.add(randomSecondsWithFractions(-1, 1));\n+            }\n+    \n+            List<TestCase> testCases = new ArrayList<>();\n+    \n+            // check each format string alone\n+            for (String pattern : PATTERNS) {\n+                testCases.add(new TestCase(randomFromCollection(testEpochSeconds), NOT_FULLY_MATCHABLE_PATTERNS.contains(pattern) \n+                    ? pattern \n+                    : String.join(PATTERN_DELIMITER, pattern, FILL_MODIFIERS.get(0) + pattern + ORDINAL_SUFFIX_MODIFIERS.get(0))));\n+            }\n+            \n+            // let's check all of the format strings with a non-ambiguous format string\n+            for (BigDecimal es : testEpochSeconds) {\n+                testCases.add(new TestCase(es, IntStream.range(0, PATTERNS.length)\n+                    .mapToObj(idx -> idx + \":\" + patternWithRandomModifiers(PATTERNS[idx]))\n+                    .collect(Collectors.joining(PATTERN_DELIMITER))));\n+            }\n+    \n+            // check the lowercase versions of the format strings\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), IntStream.range(0, PATTERNS.length)\n+                .mapToObj(idx -> (idx + \":\" + patternWithRandomModifiers(PATTERNS[idx])).toLowerCase(Locale.ROOT))\n+                .collect(Collectors.joining(PATTERN_DELIMITER))));\n+    \n+            // potentially ambiguous format string test cases, to check if our format string parsing is in-sync with PostgreSQL\n+            // greedy and prefers the longer format strings\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"YYYYYYYYYYYYYYY,YYYYYYYYY\"));\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"SSSSSSSSSSSSSSSS\"));\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"DDDDDDDD\"));\n+    \n+            // Roman numbers\n+            for (int i = 1; i <= 12; i++) {\n+                testCases.add(new TestCase(\n+                    new BigDecimal(dateTime(0).withMonth(i).toEpochSecond()), rnd().nextBoolean() ? \"RM\" : \"rm\"));\n+            }\n+            \n+            // random strings made out of template patterns and random characters\n+            final String randomCharacters = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYabcdefghijklmnopqrstuvwxy _-.:;\";\n+            final List<String> formatStringsToRandomTest = Arrays.stream(PATTERNS)\n+                .filter(s -> NOT_FULLY_MATCHABLE_PATTERNS.contains(s) == false)\n+                .collect(Collectors.toList());\n+            \n+            for (int i = 0; i < 20; i++) {\n+                String patternWithLiterals = IntStream.rangeClosed(1, 30).mapToObj(idx -> \n+                    rnd().nextInt(100) < 80 \n+                        ? randomCharacters.substring(rnd().nextInt(randomCharacters.length())).substring(0, 1) \n+                        : (randomFromCollection(FILL_MODIFIERS) \n+                            + randomFromCollection(formatStringsToRandomTest) \n+                            + randomFromCollection(ORDINAL_SUFFIX_MODIFIERS)))\n+                    .collect(Collectors.joining());\n+                \n+                // clean up the random string from the unsupported modifiers\n+                for (String unsupportedPatternModifier : UNSUPPORTED_PATTERN_MODIFIERS) {\n+                    patternWithLiterals = patternWithLiterals\n+                        .replace(unsupportedPatternModifier, \"\")\n+                        .replace(unsupportedPatternModifier.toLowerCase(Locale.ROOT), \"\");\n+                }\n+                testCases.add(new TestCase(randomFromCollection(testEpochSeconds), patternWithLiterals));\n+            }\n+    \n+            return testCases;\n+        }\n+        \n+        private static String adjustZoneIdToPostgres(String zoneId) {\n+            // when the zone is specified by the offset in Postgres, it follows the POSIX definition, so the +- signs are flipped\n+            // compared to ISO-8601, see more info at: https://www.postgresql.org/docs/current/datetime-posix-timezone-specs.html\n+            if (zoneId.startsWith(\"+\")) {\n+                zoneId = zoneId.replaceFirst(quote(\"+\"), \"-\");\n+            } else if (zoneId.startsWith(\"-\")) {\n+                zoneId = zoneId.replaceFirst(quote(\"-\"), \"+\");\n+            }\n+            return zoneId;\n+        }\n+        \n+        /**\n+         * Generates an SQL file that can be used to create the test dataset for the unit test of the <code>TO_CHAR</code>\n+         * implementation. In case the <code>TO_CHAR</code> implementation needs an upgrade, add the list of the new format\n+         * strings to the list of the format string, regenerate the SQL, run it against the PostgreSQL version you are targeting\n+         * and update the test CSV file.\n+         */\n+        private static String unitTestExporterScript() {\n+            return generateTestCases().stream().map(tc -> {\n+                long seconds = tc.secondsAndFractionsSinceEpoch.longValue();\n+                BigDecimal fractions = tc.secondsAndFractionsSinceEpoch.remainder(BigDecimal.ONE).movePointRight(6);\n+                return String.format(Locale.ROOT,\n+                    \"SET TIME ZONE '%7$s';\\n\" +\n+                    \"\\\\copy (SELECT %1$d as id, %2$s as epoch_seconds_and_microsends, '%6$s' as zone_id, '%5$s' as format_string, \" +\n+                        \"(TO_TIMESTAMP(%3$d) + INTERVAL '%4$d microseconds') as to_timestamp_result, \" +\n+                        \"TO_CHAR((TO_TIMESTAMP(%3$d) + INTERVAL '%4$d microseconds'), '%5$s') as to_char_result) to stdout \" +\n+                        \"with DELIMITER as '\" + DELIMITER + \"' NULL as '' csv \\n\",\n+                    tc.id, tc.secondsAndFractionsSinceEpoch.toPlainString(), seconds, fractions.intValue(), tc.formatString, tc.zoneId, \n+                    adjustZoneIdToPostgres(tc.zoneId)\n+                );\n+            }).collect(Collectors.joining(\"\\n\"));\n+        }\n+        \n+        public static void main(String[] args) throws Exception {\n+            String scriptFilename = args.length < 1 ? \"/tmp/postgresql-tochar-test.sql\" : args[0];\n+            Files.writeString(Path.of(scriptFilename), unitTestExporterScript(), StandardCharsets.UTF_8);\n+        }\n+    }\n+\n+    @ParametersFactory(argumentFormatting = \"%1$s: timestamp=%5$s, zone=%3$s, format=%4$s\")\n+    public static List<Object[]> readCsv() throws Exception {\n+        Path testFilePath = Path.of(DateTimeToCharProcessorTests.class.getResource(\"tochar.csv\").toURI());\n+        return Files.readAllLines(testFilePath).stream().map(line -> {\n+            String[] cols = line.split(quote(TestGenerator.DELIMITER));\n+            return new Object[]{ cols[0], cols[1], cols[2], cols[3], cols[4], cols[5] };\n+        }).collect(Collectors.toList());\n+    }\n+\n+    private final String id;\n+    private final String secondsAndFractionsSinceEpoch;\n+    private final String zone;\n+    private final String formatString;\n+    private final String posgresTimestamp;\n+    private final String expectedResult;\n+\n+    public DateTimeToCharProcessorTests(String id, String secondsAndFractionsSinceEpoch, String zone, String formatString,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA1NjgxMQ=="}, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 255}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NDUzMzU2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNjo1MTo0M1rOIOe9yQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxNjowODowMVrOIPyYWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA1ODMxMw==", "bodyText": "It looks like this is the only class where these methods are defined so why not move them here?", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552058313", "createdAt": "2021-01-05T16:51:43Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,376 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQyNDk4NA==", "bodyText": "Moved.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r553424984", "createdAt": "2021-01-07T16:08:01Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,376 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA1ODMxMw=="}, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NDUzNzc3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNjo1Mjo0NFrOIOfAcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNjo1Mjo0NFrOIOfAcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA1ODk5NQ==", "bodyText": "Fully qualifying the static method in the same class is just noise. Please update your formatting rule and just call of", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552058995", "createdAt": "2021-01-05T16:52:44Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,376 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NDU0MDU4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNjo1MzozMFrOIOfCNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQyMjowMTo1MVrOIOpKPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA1OTQ0Ng==", "bodyText": "It's worth adding some static imports for String, Integer, etc.. to simplify these function definitions.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552059446", "createdAt": "2021-01-05T16:53:30Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,376 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIyNTM0Mg==", "bodyText": "Added, except for String.format that clashes with the format of this class.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552225342", "createdAt": "2021-01-05T22:01:51Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,376 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA1OTQ0Ng=="}, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NDU0NDYzOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNjo1NDoyMVrOIOfEjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQyMzoxMDo1NVrOIOq4JQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2MDA0NQ==", "bodyText": "Please add a comment on why 24000001 - isn't this constant defined anywhere in the Java time API?", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552060045", "createdAt": "2021-01-05T16:54:21Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,376 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI1MzQ3Nw==", "bodyText": "Switched to TemporalAccessor.get(JulianFields.JULIAN_DAY) that already does this calculation.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552253477", "createdAt": "2021-01-05T23:10:55Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,376 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2MDA0NQ=="}, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NDU1MjMyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNjo1NjoxOVrOIOfJaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxNjowODo1MlrOIPyabw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2MTI5MQ==", "bodyText": "Either fix the supress warning or initialize the variable in the static block above where FORMATTER_MAP is defined.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552061291", "createdAt": "2021-01-05T16:56:19Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,376 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::removeLeadingZerosFromOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQyNTUxOQ==", "bodyText": "Fixed, removed the @SuppressWarnings", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r553425519", "createdAt": "2021-01-07T16:08:52Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,376 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::removeLeadingZerosFromOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2MTI5MQ=="}, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NDU1MzczOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNjo1Njo0MVrOIOfKTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQyMjowOTo0NlrOIOpXpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2MTUxNg==", "bodyText": "What is fillMode?", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552061516", "createdAt": "2021-01-05T16:56:41Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,376 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::removeLeadingZerosFromOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int\n+        MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().getAsInt();\n+\n+    private final String pattern;\n+    private final boolean lowercaseAccepted;\n+    private final Function<String, String> fillMode;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIyODc3NA==", "bodyText": "Suppressing leading zeroes or removing blanks: https://www.postgresql.org/docs/13/functions-formatting.html#FUNCTIONS-FORMATTING-DATETIMEMOD-TABLE", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552228774", "createdAt": "2021-01-05T22:09:46Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,376 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::removeLeadingZerosFromOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int\n+        MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().getAsInt();\n+\n+    private final String pattern;\n+    private final boolean lowercaseAccepted;\n+    private final Function<String, String> fillMode;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2MTUxNg=="}, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 137}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NDU1NTIwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNjo1NzowM1rOIOfLIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNjo1NzowM1rOIOfLIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2MTcyOA==", "bodyText": "acceptsLowercase", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552061728", "createdAt": "2021-01-05T16:57:03Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,376 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::removeLeadingZerosFromOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int\n+        MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().getAsInt();\n+\n+    private final String pattern;\n+    private final boolean lowercaseAccepted;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 136}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NDU1OTkxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNjo1Nzo1NFrOIOfNtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxNjowOTo0NFrOIPyceA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2MjM5MA==", "bodyText": "formatter, toString, asString", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552062390", "createdAt": "2021-01-05T16:57:54Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,376 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::removeLeadingZerosFromOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int\n+        MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().getAsInt();\n+\n+    private final String pattern;\n+    private final boolean lowercaseAccepted;\n+    private final Function<String, String> fillMode;\n+    private final boolean hasOrdinalSuffix;\n+    private final Function<TemporalAccessor, String> formatFn;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQyNjA0MA==", "bodyText": "Renamed to formatter", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r553426040", "createdAt": "2021-01-07T16:09:44Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,376 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::removeLeadingZerosFromOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int\n+        MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().getAsInt();\n+\n+    private final String pattern;\n+    private final boolean lowercaseAccepted;\n+    private final Function<String, String> fillMode;\n+    private final boolean hasOrdinalSuffix;\n+    private final Function<TemporalAccessor, String> formatFn;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2MjM5MA=="}, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 139}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NDU2MjQwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/qa/server/src/main/resources/datetime.csv-spec", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNjo1ODozNVrOIOfPXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxNjoxMjo1OFrOIPyj7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2MjgxNA==", "bodyText": "If you order by a field, I think it's better to show that field in the result to \"prove\" that the order is correct, otherwise the tests orders by emp_no, but one cannot tell the results are correct. This is valid for all other tests in this PR.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552062814", "createdAt": "2021-01-05T16:58:35Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/qa/server/src/main/resources/datetime.csv-spec", "diffHunk": "@@ -601,6 +601,110 @@ HAVING DATETIME_FORMAT(MAX(birth_date), 'dd')::integer > 20  ORDER BY 1 DESC;\n 1961-02-26 00:00:00.000Z | 02\n ;\n \n+selectToChar\n+schema::df_date:s|df_datetime:s|df_time:s\n+SELECT TO_CHAR('2020-04-05T11:22:33.123Z'::date, 'DD/MM/YYYY HH24:MI:SS.FF3') AS df_date,\n+TO_CHAR('2020-04-05T11:22:33.123Z'::datetime, 'DD/MM/YYYY HH24:MI:SS.FF2') AS df_datetime,\n+TO_CHAR('11:22:33.123456789Z'::time, 'HH24:MI:SS.FF2') AS df_time;\n+\n+       df_date          |    df_datetime         |   df_time\n+------------------------+------------------------+----------------\n+05/04/2020 00:00:00.000 | 05/04/2020 11:22:33.12 | 11:22:33.12\n+;\n+\n+selectToCharWithField\n+schema::birth_date:ts|gender:s|df_birth_date1:s|df_birth_date2:s\n+SELECT birth_date, gender, TO_CHAR(birth_date, 'MM/DD/YYYY') AS df_birth_date1, \n+TO_CHAR(birth_date, CONCAT(gender, 'MDD')) AS df_birth_date2 FROM test_emp WHERE emp_no BETWEEN 10047 AND 10057 ORDER BY emp_no;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI2ODcwMA==", "bodyText": "Not sure I understand why do you need the emp_no field to check the correctness in this case. Correctness of the ORDER BY is already covered by other integration tests. Correctness can be checked by simply comparing the birth_date and gender values with the results of the TO_CHAR in df_birth_date1 and df_birth_date2 columns in the output regardless of ordering. Having said that, I can remove the emp_no from the ORDER BY if it is a concern or add it as a field to the output.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552268700", "createdAt": "2021-01-05T23:51:00Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/sql/qa/server/src/main/resources/datetime.csv-spec", "diffHunk": "@@ -601,6 +601,110 @@ HAVING DATETIME_FORMAT(MAX(birth_date), 'dd')::integer > 20  ORDER BY 1 DESC;\n 1961-02-26 00:00:00.000Z | 02\n ;\n \n+selectToChar\n+schema::df_date:s|df_datetime:s|df_time:s\n+SELECT TO_CHAR('2020-04-05T11:22:33.123Z'::date, 'DD/MM/YYYY HH24:MI:SS.FF3') AS df_date,\n+TO_CHAR('2020-04-05T11:22:33.123Z'::datetime, 'DD/MM/YYYY HH24:MI:SS.FF2') AS df_datetime,\n+TO_CHAR('11:22:33.123456789Z'::time, 'HH24:MI:SS.FF2') AS df_time;\n+\n+       df_date          |    df_datetime         |   df_time\n+------------------------+------------------------+----------------\n+05/04/2020 00:00:00.000 | 05/04/2020 11:22:33.12 | 11:22:33.12\n+;\n+\n+selectToCharWithField\n+schema::birth_date:ts|gender:s|df_birth_date1:s|df_birth_date2:s\n+SELECT birth_date, gender, TO_CHAR(birth_date, 'MM/DD/YYYY') AS df_birth_date1, \n+TO_CHAR(birth_date, CONCAT(gender, 'MDD')) AS df_birth_date2 FROM test_emp WHERE emp_no BETWEEN 10047 AND 10057 ORDER BY emp_no;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2MjgxNA=="}, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQyMDk4NQ==", "bodyText": "The concern I have is different. Sorry for not being more descriptive.\nYou have ORDER BY emp_no in your test query and that's ok. What's not ok imo is that I cannot tell if the results have been ordered correctly by emp_no. If you add emp_no as a column to be returned by the SELECT I can visually assess that the results are indeed ordered correctly by emp_no.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552420985", "createdAt": "2021-01-06T07:56:36Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/qa/server/src/main/resources/datetime.csv-spec", "diffHunk": "@@ -601,6 +601,110 @@ HAVING DATETIME_FORMAT(MAX(birth_date), 'dd')::integer > 20  ORDER BY 1 DESC;\n 1961-02-26 00:00:00.000Z | 02\n ;\n \n+selectToChar\n+schema::df_date:s|df_datetime:s|df_time:s\n+SELECT TO_CHAR('2020-04-05T11:22:33.123Z'::date, 'DD/MM/YYYY HH24:MI:SS.FF3') AS df_date,\n+TO_CHAR('2020-04-05T11:22:33.123Z'::datetime, 'DD/MM/YYYY HH24:MI:SS.FF2') AS df_datetime,\n+TO_CHAR('11:22:33.123456789Z'::time, 'HH24:MI:SS.FF2') AS df_time;\n+\n+       df_date          |    df_datetime         |   df_time\n+------------------------+------------------------+----------------\n+05/04/2020 00:00:00.000 | 05/04/2020 11:22:33.12 | 11:22:33.12\n+;\n+\n+selectToCharWithField\n+schema::birth_date:ts|gender:s|df_birth_date1:s|df_birth_date2:s\n+SELECT birth_date, gender, TO_CHAR(birth_date, 'MM/DD/YYYY') AS df_birth_date1, \n+TO_CHAR(birth_date, CONCAT(gender, 'MDD')) AS df_birth_date2 FROM test_emp WHERE emp_no BETWEEN 10047 AND 10057 ORDER BY emp_no;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2MjgxNA=="}, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQyNzk1MA==", "bodyText": "Added emp_no.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r553427950", "createdAt": "2021-01-07T16:12:58Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/sql/qa/server/src/main/resources/datetime.csv-spec", "diffHunk": "@@ -601,6 +601,110 @@ HAVING DATETIME_FORMAT(MAX(birth_date), 'dd')::integer > 20  ORDER BY 1 DESC;\n 1961-02-26 00:00:00.000Z | 02\n ;\n \n+selectToChar\n+schema::df_date:s|df_datetime:s|df_time:s\n+SELECT TO_CHAR('2020-04-05T11:22:33.123Z'::date, 'DD/MM/YYYY HH24:MI:SS.FF3') AS df_date,\n+TO_CHAR('2020-04-05T11:22:33.123Z'::datetime, 'DD/MM/YYYY HH24:MI:SS.FF2') AS df_datetime,\n+TO_CHAR('11:22:33.123456789Z'::time, 'HH24:MI:SS.FF2') AS df_time;\n+\n+       df_date          |    df_datetime         |   df_time\n+------------------------+------------------------+----------------\n+05/04/2020 00:00:00.000 | 05/04/2020 11:22:33.12 | 11:22:33.12\n+;\n+\n+selectToCharWithField\n+schema::birth_date:ts|gender:s|df_birth_date1:s|df_birth_date2:s\n+SELECT birth_date, gender, TO_CHAR(birth_date, 'MM/DD/YYYY') AS df_birth_date1, \n+TO_CHAR(birth_date, CONCAT(gender, 'MDD')) AS df_birth_date2 FROM test_emp WHERE emp_no BETWEEN 10047 AND 10057 ORDER BY emp_no;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2MjgxNA=="}, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NDU3ODY0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNzowMjo0NlrOIOfZfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQyMjo0ODoxMVrOIOqXnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2NTQwNg==", "bodyText": "Why is this called text yet it accepts a fillMode? Why is defined as a general Function yet seems to have limited implementations?", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552065406", "createdAt": "2021-01-05T17:02:46Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,376 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::removeLeadingZerosFromOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int\n+        MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().getAsInt();\n+\n+    private final String pattern;\n+    private final boolean lowercaseAccepted;\n+    private final Function<String, String> fillMode;\n+    private final boolean hasOrdinalSuffix;\n+    private final Function<TemporalAccessor, String> formatFn;\n+\n+    private ToCharFormatter(\n+        String pattern,\n+        boolean lowercaseAccepted,\n+        Function<String, String> fillMode,\n+        boolean hasOrdinalSuffix,\n+        Function<TemporalAccessor, String> formatFn) {\n+\n+        this.pattern = pattern;\n+        this.lowercaseAccepted = lowercaseAccepted;\n+        this.fillMode = fillMode;\n+        this.hasOrdinalSuffix = hasOrdinalSuffix;\n+        this.formatFn = formatFn;\n+    }\n+\n+    private static Builder of(String pattern) {\n+        return new Builder(pattern);\n+    }\n+\n+    private String format(TemporalAccessor temporalAccessor) {\n+        return formatFn.apply(temporalAccessor);\n+    }\n+\n+    private ToCharFormatter withModifier(Function<String, String> modifierFn) {\n+        return new ToCharFormatter(pattern, lowercaseAccepted, fillMode, hasOrdinalSuffix, formatFn.andThen(modifierFn));\n+    }\n+\n+    private static List<ToCharFormatter> parsePattern(String toCharPattern) {\n+        LinkedList<ToCharFormatter> formatters = new LinkedList<>();\n+\n+        boolean fillModeModifierActive = false;\n+\n+        while (toCharPattern.isEmpty() == false) {\n+            boolean foundPattern = false;\n+            for (int length = Math.min(MAX_TO_CHAR_FORMAT_STRING_LENGTH, toCharPattern.length()); length >= 1; length--) {\n+                final String potentialPattern = toCharPattern.substring(0, length);\n+                if (isFillModeModifier(potentialPattern)) {\n+                    // try to apply the fill mode modifier to the next formatter\n+                    fillModeModifierActive = true;\n+                    foundPattern = true;\n+                } else if (isOrdinalSuffixModifier(potentialPattern)) {\n+                    // try to apply the ordinal suffix modifier to the last formatter\n+                    ToCharFormatter lastFormatter = formatters.removeLast();\n+                    if (lastFormatter == null) {\n+                        // if there was no previous pattern, simply prints the ordinal suffix pattern\n+                        lastFormatter = literal(potentialPattern);\n+                    } else if (lastFormatter.hasOrdinalSuffix) {\n+                        lastFormatter = lastFormatter.withModifier(s -> appendOrdinalSuffix(potentialPattern, s));\n+                    }\n+                    formatters.addLast(lastFormatter);\n+                    foundPattern = true;\n+                } else {\n+                    ToCharFormatter formatter = FORMATTER_MAP.get(potentialPattern);\n+                    // check if it is a known pattern string, if so apply it, with any modifier\n+                    if (formatter != null) {\n+                        if (fillModeModifierActive && formatter.fillMode != null) {\n+                            formatter = formatter.withModifier(formatter.fillMode);\n+                        }\n+                        formatters.addLast(formatter);\n+                        fillModeModifierActive = false;\n+                        foundPattern = true;\n+                    }\n+                }\n+                if (foundPattern) {\n+                    toCharPattern = toCharPattern.substring(length);\n+                    break;\n+                }\n+            }\n+            if (foundPattern == false) {\n+                // the fill mode modifier does not apply in case of literals\n+                formatters.addLast(literal(toCharPattern.substring(0, 1)));\n+                toCharPattern = toCharPattern.substring(1);\n+                fillModeModifierActive = false;\n+            }\n+        }\n+        return formatters;\n+    }\n+\n+    private static boolean isOrdinalSuffixModifier(String potentialPattern) {\n+        return \"TH\".equals(potentialPattern) || \"th\".equals(potentialPattern);\n+    }\n+\n+    private static boolean isFillModeModifier(String potentialPattern) {\n+        return \"FM\".equals(potentialPattern) || \"fm\".equals(potentialPattern);\n+    }\n+\n+    public static Function<TemporalAccessor, String> ofPattern(String pattern) {\n+        if (Strings.isEmpty(pattern)) {\n+            return timestamp -> \"\";\n+        }\n+        final List<ToCharFormatter> toCharFormatters = parsePattern(pattern);\n+        return timestamp -> toCharFormatters.stream().map(p -> p.format(timestamp)).collect(Collectors.joining());\n+    }\n+\n+    private static ToCharFormatter literal(String literal) {\n+        return new ToCharFormatter(literal, false, null, true, t -> literal);\n+    }\n+\n+    private static String ordinalSuffix(int i) {\n+        if (i < 0) {\n+            i = -i;\n+        }\n+        int mod100 = i % 100;\n+        int mod10 = i % 10;\n+        if (mod10 == 1 && mod100 != 11) {\n+            return \"st\";\n+        } else if (mod10 == 2 && mod100 != 12) {\n+            return \"nd\";\n+        } else if (mod10 == 3 && mod100 != 13) {\n+            return \"rd\";\n+        } else {\n+            return \"th\";\n+        }\n+    }\n+\n+    private static String appendOrdinalSuffix(String defaultSuffix, String s) {\n+        try {\n+            // the Y,YYY pattern might can cause problems with the parsing, but thankfully the last 3\n+            // characters is enough to calculate the suffix\n+            int i = Integer.parseInt(lastNCharacter(s, 3));\n+            final boolean upperCase = defaultSuffix.equals(defaultSuffix.toUpperCase(Locale.ROOT));\n+            return s + (upperCase ? ordinalSuffix(i).toUpperCase(Locale.ROOT) : ordinalSuffix(i));\n+        } catch (NumberFormatException ex) {\n+            return s + defaultSuffix;\n+        }\n+    }\n+\n+    private static String removeLeadingZeros(String number) {\n+        return String.valueOf(Integer.parseInt(number));\n+    }\n+\n+    private static String removePadding(String paddedText) {\n+        return paddedText.replaceAll(\" +$\", \"\");\n+    }\n+\n+    private static String formatOffset(String offset) {\n+        if (offset.equals(\"Z\")) {\n+            return \"+00\";\n+        }\n+        if (offset.matches(\"^[+-][0-9][0-9]00$\")) {\n+            offset = offset.substring(0, offset.length() - 2);\n+        } else if (offset.matches(\"^[+-][0-9]{3,4}$\")) {\n+            offset = offset.substring(0, offset.length() - 2) + \":\" + offset.substring(offset.length() - 2);\n+        } else if (offset.matches(\"^[+-][0-9][0-9]:00$\")) {\n+            offset = offset.substring(0, offset.length() - 3);\n+        }\n+        return offset.substring(0, Math.min(offset.length(), 6));\n+    }\n+\n+    private static String removeLeadingZerosFromOffset(String offset) {\n+        if (offset.matches(\"[+-]0{1,2}\")) {\n+            return offset.substring(0, 2);\n+        } else {\n+            if (offset.startsWith(\"+0\")) {\n+                return \"+\" + offset.substring(2);\n+            } else if (offset.startsWith(\"-0\")) {\n+                return \"-\" + offset.substring(2);\n+            } else {\n+                return offset;\n+            }\n+        }\n+    }\n+\n+    private static String absoluteWeekBasedYear(TemporalAccessor t) {\n+        int year = t.get(IsoFields.WEEK_BASED_YEAR);\n+        year = year > 0 ? year : -(year - 1);\n+        return String.format(Locale.ROOT, \"%04d\", year);\n+    }\n+\n+    private static String firstDigitsOfNanos(String nano, int digits) {\n+        return String.format(Locale.ROOT, \"%09d\", Integer.parseInt(nano)).substring(0, digits);\n+    }\n+\n+    private static String lastNCharacter(String s, int n) {\n+        return s.substring(Math.max(0, s.length() - n));\n+    }\n+\n+    private static String zoneAbbreviationOf(TemporalAccessor temporalAccessor) {\n+        String zone = ZoneId.from(temporalAccessor).getDisplayName(TextStyle.SHORT, Locale.ROOT);\n+        return \"Z\".equals(zone) ? \"UTC\" : zone;\n+    }\n+\n+    private static class Builder {\n+\n+        private final String pattern;\n+        private boolean lowercaseAccepted = true;\n+        private Function<String, String> fillMode = ToCharFormatter::removeLeadingZeros;\n+        private boolean hasOrdinalSuffix = true;\n+        private Function<TemporalAccessor, String> formatFn;\n+\n+        Builder(String pattern) {\n+            this.pattern = pattern;\n+        }\n+\n+        public Builder formatFn(final String javaPattern) {\n+            return formatFn(javaPattern, null);\n+        }\n+\n+        public Builder formatFn(final String javaPattern, final Function<String, String> additionalMapper) {\n+            this.formatFn = temporalAccessor -> {\n+                String formatted = DateTimeFormatter.ofPattern(javaPattern != null ? javaPattern : \"'\" + pattern + \"'\", Locale.ROOT)\n+                    .format(temporalAccessor);\n+                return additionalMapper == null ? formatted : additionalMapper.apply(formatted);\n+            };\n+            return this;\n+        }\n+\n+        public Builder formatFn(Function<TemporalAccessor, String> formatFn) {\n+            this.formatFn = formatFn;\n+            return this;\n+        }\n+\n+        public Builder noFillMode() {\n+            this.fillMode = null;\n+            return this;\n+        }\n+\n+        public Builder text() {\n+            return text(ToCharFormatter::removePadding);\n+        }\n+\n+        public Builder text(Function<String, String> fillMode) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 361}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI0NTE0OQ==", "bodyText": "Refactored, simplified this part.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552245149", "createdAt": "2021-01-05T22:48:11Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,376 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::removeLeadingZerosFromOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int\n+        MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().getAsInt();\n+\n+    private final String pattern;\n+    private final boolean lowercaseAccepted;\n+    private final Function<String, String> fillMode;\n+    private final boolean hasOrdinalSuffix;\n+    private final Function<TemporalAccessor, String> formatFn;\n+\n+    private ToCharFormatter(\n+        String pattern,\n+        boolean lowercaseAccepted,\n+        Function<String, String> fillMode,\n+        boolean hasOrdinalSuffix,\n+        Function<TemporalAccessor, String> formatFn) {\n+\n+        this.pattern = pattern;\n+        this.lowercaseAccepted = lowercaseAccepted;\n+        this.fillMode = fillMode;\n+        this.hasOrdinalSuffix = hasOrdinalSuffix;\n+        this.formatFn = formatFn;\n+    }\n+\n+    private static Builder of(String pattern) {\n+        return new Builder(pattern);\n+    }\n+\n+    private String format(TemporalAccessor temporalAccessor) {\n+        return formatFn.apply(temporalAccessor);\n+    }\n+\n+    private ToCharFormatter withModifier(Function<String, String> modifierFn) {\n+        return new ToCharFormatter(pattern, lowercaseAccepted, fillMode, hasOrdinalSuffix, formatFn.andThen(modifierFn));\n+    }\n+\n+    private static List<ToCharFormatter> parsePattern(String toCharPattern) {\n+        LinkedList<ToCharFormatter> formatters = new LinkedList<>();\n+\n+        boolean fillModeModifierActive = false;\n+\n+        while (toCharPattern.isEmpty() == false) {\n+            boolean foundPattern = false;\n+            for (int length = Math.min(MAX_TO_CHAR_FORMAT_STRING_LENGTH, toCharPattern.length()); length >= 1; length--) {\n+                final String potentialPattern = toCharPattern.substring(0, length);\n+                if (isFillModeModifier(potentialPattern)) {\n+                    // try to apply the fill mode modifier to the next formatter\n+                    fillModeModifierActive = true;\n+                    foundPattern = true;\n+                } else if (isOrdinalSuffixModifier(potentialPattern)) {\n+                    // try to apply the ordinal suffix modifier to the last formatter\n+                    ToCharFormatter lastFormatter = formatters.removeLast();\n+                    if (lastFormatter == null) {\n+                        // if there was no previous pattern, simply prints the ordinal suffix pattern\n+                        lastFormatter = literal(potentialPattern);\n+                    } else if (lastFormatter.hasOrdinalSuffix) {\n+                        lastFormatter = lastFormatter.withModifier(s -> appendOrdinalSuffix(potentialPattern, s));\n+                    }\n+                    formatters.addLast(lastFormatter);\n+                    foundPattern = true;\n+                } else {\n+                    ToCharFormatter formatter = FORMATTER_MAP.get(potentialPattern);\n+                    // check if it is a known pattern string, if so apply it, with any modifier\n+                    if (formatter != null) {\n+                        if (fillModeModifierActive && formatter.fillMode != null) {\n+                            formatter = formatter.withModifier(formatter.fillMode);\n+                        }\n+                        formatters.addLast(formatter);\n+                        fillModeModifierActive = false;\n+                        foundPattern = true;\n+                    }\n+                }\n+                if (foundPattern) {\n+                    toCharPattern = toCharPattern.substring(length);\n+                    break;\n+                }\n+            }\n+            if (foundPattern == false) {\n+                // the fill mode modifier does not apply in case of literals\n+                formatters.addLast(literal(toCharPattern.substring(0, 1)));\n+                toCharPattern = toCharPattern.substring(1);\n+                fillModeModifierActive = false;\n+            }\n+        }\n+        return formatters;\n+    }\n+\n+    private static boolean isOrdinalSuffixModifier(String potentialPattern) {\n+        return \"TH\".equals(potentialPattern) || \"th\".equals(potentialPattern);\n+    }\n+\n+    private static boolean isFillModeModifier(String potentialPattern) {\n+        return \"FM\".equals(potentialPattern) || \"fm\".equals(potentialPattern);\n+    }\n+\n+    public static Function<TemporalAccessor, String> ofPattern(String pattern) {\n+        if (Strings.isEmpty(pattern)) {\n+            return timestamp -> \"\";\n+        }\n+        final List<ToCharFormatter> toCharFormatters = parsePattern(pattern);\n+        return timestamp -> toCharFormatters.stream().map(p -> p.format(timestamp)).collect(Collectors.joining());\n+    }\n+\n+    private static ToCharFormatter literal(String literal) {\n+        return new ToCharFormatter(literal, false, null, true, t -> literal);\n+    }\n+\n+    private static String ordinalSuffix(int i) {\n+        if (i < 0) {\n+            i = -i;\n+        }\n+        int mod100 = i % 100;\n+        int mod10 = i % 10;\n+        if (mod10 == 1 && mod100 != 11) {\n+            return \"st\";\n+        } else if (mod10 == 2 && mod100 != 12) {\n+            return \"nd\";\n+        } else if (mod10 == 3 && mod100 != 13) {\n+            return \"rd\";\n+        } else {\n+            return \"th\";\n+        }\n+    }\n+\n+    private static String appendOrdinalSuffix(String defaultSuffix, String s) {\n+        try {\n+            // the Y,YYY pattern might can cause problems with the parsing, but thankfully the last 3\n+            // characters is enough to calculate the suffix\n+            int i = Integer.parseInt(lastNCharacter(s, 3));\n+            final boolean upperCase = defaultSuffix.equals(defaultSuffix.toUpperCase(Locale.ROOT));\n+            return s + (upperCase ? ordinalSuffix(i).toUpperCase(Locale.ROOT) : ordinalSuffix(i));\n+        } catch (NumberFormatException ex) {\n+            return s + defaultSuffix;\n+        }\n+    }\n+\n+    private static String removeLeadingZeros(String number) {\n+        return String.valueOf(Integer.parseInt(number));\n+    }\n+\n+    private static String removePadding(String paddedText) {\n+        return paddedText.replaceAll(\" +$\", \"\");\n+    }\n+\n+    private static String formatOffset(String offset) {\n+        if (offset.equals(\"Z\")) {\n+            return \"+00\";\n+        }\n+        if (offset.matches(\"^[+-][0-9][0-9]00$\")) {\n+            offset = offset.substring(0, offset.length() - 2);\n+        } else if (offset.matches(\"^[+-][0-9]{3,4}$\")) {\n+            offset = offset.substring(0, offset.length() - 2) + \":\" + offset.substring(offset.length() - 2);\n+        } else if (offset.matches(\"^[+-][0-9][0-9]:00$\")) {\n+            offset = offset.substring(0, offset.length() - 3);\n+        }\n+        return offset.substring(0, Math.min(offset.length(), 6));\n+    }\n+\n+    private static String removeLeadingZerosFromOffset(String offset) {\n+        if (offset.matches(\"[+-]0{1,2}\")) {\n+            return offset.substring(0, 2);\n+        } else {\n+            if (offset.startsWith(\"+0\")) {\n+                return \"+\" + offset.substring(2);\n+            } else if (offset.startsWith(\"-0\")) {\n+                return \"-\" + offset.substring(2);\n+            } else {\n+                return offset;\n+            }\n+        }\n+    }\n+\n+    private static String absoluteWeekBasedYear(TemporalAccessor t) {\n+        int year = t.get(IsoFields.WEEK_BASED_YEAR);\n+        year = year > 0 ? year : -(year - 1);\n+        return String.format(Locale.ROOT, \"%04d\", year);\n+    }\n+\n+    private static String firstDigitsOfNanos(String nano, int digits) {\n+        return String.format(Locale.ROOT, \"%09d\", Integer.parseInt(nano)).substring(0, digits);\n+    }\n+\n+    private static String lastNCharacter(String s, int n) {\n+        return s.substring(Math.max(0, s.length() - n));\n+    }\n+\n+    private static String zoneAbbreviationOf(TemporalAccessor temporalAccessor) {\n+        String zone = ZoneId.from(temporalAccessor).getDisplayName(TextStyle.SHORT, Locale.ROOT);\n+        return \"Z\".equals(zone) ? \"UTC\" : zone;\n+    }\n+\n+    private static class Builder {\n+\n+        private final String pattern;\n+        private boolean lowercaseAccepted = true;\n+        private Function<String, String> fillMode = ToCharFormatter::removeLeadingZeros;\n+        private boolean hasOrdinalSuffix = true;\n+        private Function<TemporalAccessor, String> formatFn;\n+\n+        Builder(String pattern) {\n+            this.pattern = pattern;\n+        }\n+\n+        public Builder formatFn(final String javaPattern) {\n+            return formatFn(javaPattern, null);\n+        }\n+\n+        public Builder formatFn(final String javaPattern, final Function<String, String> additionalMapper) {\n+            this.formatFn = temporalAccessor -> {\n+                String formatted = DateTimeFormatter.ofPattern(javaPattern != null ? javaPattern : \"'\" + pattern + \"'\", Locale.ROOT)\n+                    .format(temporalAccessor);\n+                return additionalMapper == null ? formatted : additionalMapper.apply(formatted);\n+            };\n+            return this;\n+        }\n+\n+        public Builder formatFn(Function<TemporalAccessor, String> formatFn) {\n+            this.formatFn = formatFn;\n+            return this;\n+        }\n+\n+        public Builder noFillMode() {\n+            this.fillMode = null;\n+            return this;\n+        }\n+\n+        public Builder text() {\n+            return text(ToCharFormatter::removePadding);\n+        }\n+\n+        public Builder text(Function<String, String> fillMode) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2NTQwNg=="}, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 361}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NDU4MDM5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNzowMzoxN1rOIOfakQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQyMjozNzowMFrOIOqGIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2NTY4MQ==", "bodyText": "Since there is a relationship between fillMode and ordinalSuffix should that apply to noFillMode as well?", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552065681", "createdAt": "2021-01-05T17:03:17Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,376 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::removeLeadingZerosFromOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int\n+        MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().getAsInt();\n+\n+    private final String pattern;\n+    private final boolean lowercaseAccepted;\n+    private final Function<String, String> fillMode;\n+    private final boolean hasOrdinalSuffix;\n+    private final Function<TemporalAccessor, String> formatFn;\n+\n+    private ToCharFormatter(\n+        String pattern,\n+        boolean lowercaseAccepted,\n+        Function<String, String> fillMode,\n+        boolean hasOrdinalSuffix,\n+        Function<TemporalAccessor, String> formatFn) {\n+\n+        this.pattern = pattern;\n+        this.lowercaseAccepted = lowercaseAccepted;\n+        this.fillMode = fillMode;\n+        this.hasOrdinalSuffix = hasOrdinalSuffix;\n+        this.formatFn = formatFn;\n+    }\n+\n+    private static Builder of(String pattern) {\n+        return new Builder(pattern);\n+    }\n+\n+    private String format(TemporalAccessor temporalAccessor) {\n+        return formatFn.apply(temporalAccessor);\n+    }\n+\n+    private ToCharFormatter withModifier(Function<String, String> modifierFn) {\n+        return new ToCharFormatter(pattern, lowercaseAccepted, fillMode, hasOrdinalSuffix, formatFn.andThen(modifierFn));\n+    }\n+\n+    private static List<ToCharFormatter> parsePattern(String toCharPattern) {\n+        LinkedList<ToCharFormatter> formatters = new LinkedList<>();\n+\n+        boolean fillModeModifierActive = false;\n+\n+        while (toCharPattern.isEmpty() == false) {\n+            boolean foundPattern = false;\n+            for (int length = Math.min(MAX_TO_CHAR_FORMAT_STRING_LENGTH, toCharPattern.length()); length >= 1; length--) {\n+                final String potentialPattern = toCharPattern.substring(0, length);\n+                if (isFillModeModifier(potentialPattern)) {\n+                    // try to apply the fill mode modifier to the next formatter\n+                    fillModeModifierActive = true;\n+                    foundPattern = true;\n+                } else if (isOrdinalSuffixModifier(potentialPattern)) {\n+                    // try to apply the ordinal suffix modifier to the last formatter\n+                    ToCharFormatter lastFormatter = formatters.removeLast();\n+                    if (lastFormatter == null) {\n+                        // if there was no previous pattern, simply prints the ordinal suffix pattern\n+                        lastFormatter = literal(potentialPattern);\n+                    } else if (lastFormatter.hasOrdinalSuffix) {\n+                        lastFormatter = lastFormatter.withModifier(s -> appendOrdinalSuffix(potentialPattern, s));\n+                    }\n+                    formatters.addLast(lastFormatter);\n+                    foundPattern = true;\n+                } else {\n+                    ToCharFormatter formatter = FORMATTER_MAP.get(potentialPattern);\n+                    // check if it is a known pattern string, if so apply it, with any modifier\n+                    if (formatter != null) {\n+                        if (fillModeModifierActive && formatter.fillMode != null) {\n+                            formatter = formatter.withModifier(formatter.fillMode);\n+                        }\n+                        formatters.addLast(formatter);\n+                        fillModeModifierActive = false;\n+                        foundPattern = true;\n+                    }\n+                }\n+                if (foundPattern) {\n+                    toCharPattern = toCharPattern.substring(length);\n+                    break;\n+                }\n+            }\n+            if (foundPattern == false) {\n+                // the fill mode modifier does not apply in case of literals\n+                formatters.addLast(literal(toCharPattern.substring(0, 1)));\n+                toCharPattern = toCharPattern.substring(1);\n+                fillModeModifierActive = false;\n+            }\n+        }\n+        return formatters;\n+    }\n+\n+    private static boolean isOrdinalSuffixModifier(String potentialPattern) {\n+        return \"TH\".equals(potentialPattern) || \"th\".equals(potentialPattern);\n+    }\n+\n+    private static boolean isFillModeModifier(String potentialPattern) {\n+        return \"FM\".equals(potentialPattern) || \"fm\".equals(potentialPattern);\n+    }\n+\n+    public static Function<TemporalAccessor, String> ofPattern(String pattern) {\n+        if (Strings.isEmpty(pattern)) {\n+            return timestamp -> \"\";\n+        }\n+        final List<ToCharFormatter> toCharFormatters = parsePattern(pattern);\n+        return timestamp -> toCharFormatters.stream().map(p -> p.format(timestamp)).collect(Collectors.joining());\n+    }\n+\n+    private static ToCharFormatter literal(String literal) {\n+        return new ToCharFormatter(literal, false, null, true, t -> literal);\n+    }\n+\n+    private static String ordinalSuffix(int i) {\n+        if (i < 0) {\n+            i = -i;\n+        }\n+        int mod100 = i % 100;\n+        int mod10 = i % 10;\n+        if (mod10 == 1 && mod100 != 11) {\n+            return \"st\";\n+        } else if (mod10 == 2 && mod100 != 12) {\n+            return \"nd\";\n+        } else if (mod10 == 3 && mod100 != 13) {\n+            return \"rd\";\n+        } else {\n+            return \"th\";\n+        }\n+    }\n+\n+    private static String appendOrdinalSuffix(String defaultSuffix, String s) {\n+        try {\n+            // the Y,YYY pattern might can cause problems with the parsing, but thankfully the last 3\n+            // characters is enough to calculate the suffix\n+            int i = Integer.parseInt(lastNCharacter(s, 3));\n+            final boolean upperCase = defaultSuffix.equals(defaultSuffix.toUpperCase(Locale.ROOT));\n+            return s + (upperCase ? ordinalSuffix(i).toUpperCase(Locale.ROOT) : ordinalSuffix(i));\n+        } catch (NumberFormatException ex) {\n+            return s + defaultSuffix;\n+        }\n+    }\n+\n+    private static String removeLeadingZeros(String number) {\n+        return String.valueOf(Integer.parseInt(number));\n+    }\n+\n+    private static String removePadding(String paddedText) {\n+        return paddedText.replaceAll(\" +$\", \"\");\n+    }\n+\n+    private static String formatOffset(String offset) {\n+        if (offset.equals(\"Z\")) {\n+            return \"+00\";\n+        }\n+        if (offset.matches(\"^[+-][0-9][0-9]00$\")) {\n+            offset = offset.substring(0, offset.length() - 2);\n+        } else if (offset.matches(\"^[+-][0-9]{3,4}$\")) {\n+            offset = offset.substring(0, offset.length() - 2) + \":\" + offset.substring(offset.length() - 2);\n+        } else if (offset.matches(\"^[+-][0-9][0-9]:00$\")) {\n+            offset = offset.substring(0, offset.length() - 3);\n+        }\n+        return offset.substring(0, Math.min(offset.length(), 6));\n+    }\n+\n+    private static String removeLeadingZerosFromOffset(String offset) {\n+        if (offset.matches(\"[+-]0{1,2}\")) {\n+            return offset.substring(0, 2);\n+        } else {\n+            if (offset.startsWith(\"+0\")) {\n+                return \"+\" + offset.substring(2);\n+            } else if (offset.startsWith(\"-0\")) {\n+                return \"-\" + offset.substring(2);\n+            } else {\n+                return offset;\n+            }\n+        }\n+    }\n+\n+    private static String absoluteWeekBasedYear(TemporalAccessor t) {\n+        int year = t.get(IsoFields.WEEK_BASED_YEAR);\n+        year = year > 0 ? year : -(year - 1);\n+        return String.format(Locale.ROOT, \"%04d\", year);\n+    }\n+\n+    private static String firstDigitsOfNanos(String nano, int digits) {\n+        return String.format(Locale.ROOT, \"%09d\", Integer.parseInt(nano)).substring(0, digits);\n+    }\n+\n+    private static String lastNCharacter(String s, int n) {\n+        return s.substring(Math.max(0, s.length() - n));\n+    }\n+\n+    private static String zoneAbbreviationOf(TemporalAccessor temporalAccessor) {\n+        String zone = ZoneId.from(temporalAccessor).getDisplayName(TextStyle.SHORT, Locale.ROOT);\n+        return \"Z\".equals(zone) ? \"UTC\" : zone;\n+    }\n+\n+    private static class Builder {\n+\n+        private final String pattern;\n+        private boolean lowercaseAccepted = true;\n+        private Function<String, String> fillMode = ToCharFormatter::removeLeadingZeros;\n+        private boolean hasOrdinalSuffix = true;\n+        private Function<TemporalAccessor, String> formatFn;\n+\n+        Builder(String pattern) {\n+            this.pattern = pattern;\n+        }\n+\n+        public Builder formatFn(final String javaPattern) {\n+            return formatFn(javaPattern, null);\n+        }\n+\n+        public Builder formatFn(final String javaPattern, final Function<String, String> additionalMapper) {\n+            this.formatFn = temporalAccessor -> {\n+                String formatted = DateTimeFormatter.ofPattern(javaPattern != null ? javaPattern : \"'\" + pattern + \"'\", Locale.ROOT)\n+                    .format(temporalAccessor);\n+                return additionalMapper == null ? formatted : additionalMapper.apply(formatted);\n+            };\n+            return this;\n+        }\n+\n+        public Builder formatFn(Function<TemporalAccessor, String> formatFn) {\n+            this.formatFn = formatFn;\n+            return this;\n+        }\n+\n+        public Builder noFillMode() {\n+            this.fillMode = null;\n+            return this;\n+        }\n+\n+        public Builder text() {\n+            return text(ToCharFormatter::removePadding);\n+        }\n+\n+        public Builder text(Function<String, String> fillMode) {\n+            this.hasOrdinalSuffix = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 362}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI0MDY3NA==", "bodyText": "No. For example FF6 (6 digit nanosecond) should not remove the leading zeros, but can have ordinal suffix (000001st nanosecond).", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552240674", "createdAt": "2021-01-05T22:37:00Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,376 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::removeLeadingZerosFromOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int\n+        MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().getAsInt();\n+\n+    private final String pattern;\n+    private final boolean lowercaseAccepted;\n+    private final Function<String, String> fillMode;\n+    private final boolean hasOrdinalSuffix;\n+    private final Function<TemporalAccessor, String> formatFn;\n+\n+    private ToCharFormatter(\n+        String pattern,\n+        boolean lowercaseAccepted,\n+        Function<String, String> fillMode,\n+        boolean hasOrdinalSuffix,\n+        Function<TemporalAccessor, String> formatFn) {\n+\n+        this.pattern = pattern;\n+        this.lowercaseAccepted = lowercaseAccepted;\n+        this.fillMode = fillMode;\n+        this.hasOrdinalSuffix = hasOrdinalSuffix;\n+        this.formatFn = formatFn;\n+    }\n+\n+    private static Builder of(String pattern) {\n+        return new Builder(pattern);\n+    }\n+\n+    private String format(TemporalAccessor temporalAccessor) {\n+        return formatFn.apply(temporalAccessor);\n+    }\n+\n+    private ToCharFormatter withModifier(Function<String, String> modifierFn) {\n+        return new ToCharFormatter(pattern, lowercaseAccepted, fillMode, hasOrdinalSuffix, formatFn.andThen(modifierFn));\n+    }\n+\n+    private static List<ToCharFormatter> parsePattern(String toCharPattern) {\n+        LinkedList<ToCharFormatter> formatters = new LinkedList<>();\n+\n+        boolean fillModeModifierActive = false;\n+\n+        while (toCharPattern.isEmpty() == false) {\n+            boolean foundPattern = false;\n+            for (int length = Math.min(MAX_TO_CHAR_FORMAT_STRING_LENGTH, toCharPattern.length()); length >= 1; length--) {\n+                final String potentialPattern = toCharPattern.substring(0, length);\n+                if (isFillModeModifier(potentialPattern)) {\n+                    // try to apply the fill mode modifier to the next formatter\n+                    fillModeModifierActive = true;\n+                    foundPattern = true;\n+                } else if (isOrdinalSuffixModifier(potentialPattern)) {\n+                    // try to apply the ordinal suffix modifier to the last formatter\n+                    ToCharFormatter lastFormatter = formatters.removeLast();\n+                    if (lastFormatter == null) {\n+                        // if there was no previous pattern, simply prints the ordinal suffix pattern\n+                        lastFormatter = literal(potentialPattern);\n+                    } else if (lastFormatter.hasOrdinalSuffix) {\n+                        lastFormatter = lastFormatter.withModifier(s -> appendOrdinalSuffix(potentialPattern, s));\n+                    }\n+                    formatters.addLast(lastFormatter);\n+                    foundPattern = true;\n+                } else {\n+                    ToCharFormatter formatter = FORMATTER_MAP.get(potentialPattern);\n+                    // check if it is a known pattern string, if so apply it, with any modifier\n+                    if (formatter != null) {\n+                        if (fillModeModifierActive && formatter.fillMode != null) {\n+                            formatter = formatter.withModifier(formatter.fillMode);\n+                        }\n+                        formatters.addLast(formatter);\n+                        fillModeModifierActive = false;\n+                        foundPattern = true;\n+                    }\n+                }\n+                if (foundPattern) {\n+                    toCharPattern = toCharPattern.substring(length);\n+                    break;\n+                }\n+            }\n+            if (foundPattern == false) {\n+                // the fill mode modifier does not apply in case of literals\n+                formatters.addLast(literal(toCharPattern.substring(0, 1)));\n+                toCharPattern = toCharPattern.substring(1);\n+                fillModeModifierActive = false;\n+            }\n+        }\n+        return formatters;\n+    }\n+\n+    private static boolean isOrdinalSuffixModifier(String potentialPattern) {\n+        return \"TH\".equals(potentialPattern) || \"th\".equals(potentialPattern);\n+    }\n+\n+    private static boolean isFillModeModifier(String potentialPattern) {\n+        return \"FM\".equals(potentialPattern) || \"fm\".equals(potentialPattern);\n+    }\n+\n+    public static Function<TemporalAccessor, String> ofPattern(String pattern) {\n+        if (Strings.isEmpty(pattern)) {\n+            return timestamp -> \"\";\n+        }\n+        final List<ToCharFormatter> toCharFormatters = parsePattern(pattern);\n+        return timestamp -> toCharFormatters.stream().map(p -> p.format(timestamp)).collect(Collectors.joining());\n+    }\n+\n+    private static ToCharFormatter literal(String literal) {\n+        return new ToCharFormatter(literal, false, null, true, t -> literal);\n+    }\n+\n+    private static String ordinalSuffix(int i) {\n+        if (i < 0) {\n+            i = -i;\n+        }\n+        int mod100 = i % 100;\n+        int mod10 = i % 10;\n+        if (mod10 == 1 && mod100 != 11) {\n+            return \"st\";\n+        } else if (mod10 == 2 && mod100 != 12) {\n+            return \"nd\";\n+        } else if (mod10 == 3 && mod100 != 13) {\n+            return \"rd\";\n+        } else {\n+            return \"th\";\n+        }\n+    }\n+\n+    private static String appendOrdinalSuffix(String defaultSuffix, String s) {\n+        try {\n+            // the Y,YYY pattern might can cause problems with the parsing, but thankfully the last 3\n+            // characters is enough to calculate the suffix\n+            int i = Integer.parseInt(lastNCharacter(s, 3));\n+            final boolean upperCase = defaultSuffix.equals(defaultSuffix.toUpperCase(Locale.ROOT));\n+            return s + (upperCase ? ordinalSuffix(i).toUpperCase(Locale.ROOT) : ordinalSuffix(i));\n+        } catch (NumberFormatException ex) {\n+            return s + defaultSuffix;\n+        }\n+    }\n+\n+    private static String removeLeadingZeros(String number) {\n+        return String.valueOf(Integer.parseInt(number));\n+    }\n+\n+    private static String removePadding(String paddedText) {\n+        return paddedText.replaceAll(\" +$\", \"\");\n+    }\n+\n+    private static String formatOffset(String offset) {\n+        if (offset.equals(\"Z\")) {\n+            return \"+00\";\n+        }\n+        if (offset.matches(\"^[+-][0-9][0-9]00$\")) {\n+            offset = offset.substring(0, offset.length() - 2);\n+        } else if (offset.matches(\"^[+-][0-9]{3,4}$\")) {\n+            offset = offset.substring(0, offset.length() - 2) + \":\" + offset.substring(offset.length() - 2);\n+        } else if (offset.matches(\"^[+-][0-9][0-9]:00$\")) {\n+            offset = offset.substring(0, offset.length() - 3);\n+        }\n+        return offset.substring(0, Math.min(offset.length(), 6));\n+    }\n+\n+    private static String removeLeadingZerosFromOffset(String offset) {\n+        if (offset.matches(\"[+-]0{1,2}\")) {\n+            return offset.substring(0, 2);\n+        } else {\n+            if (offset.startsWith(\"+0\")) {\n+                return \"+\" + offset.substring(2);\n+            } else if (offset.startsWith(\"-0\")) {\n+                return \"-\" + offset.substring(2);\n+            } else {\n+                return offset;\n+            }\n+        }\n+    }\n+\n+    private static String absoluteWeekBasedYear(TemporalAccessor t) {\n+        int year = t.get(IsoFields.WEEK_BASED_YEAR);\n+        year = year > 0 ? year : -(year - 1);\n+        return String.format(Locale.ROOT, \"%04d\", year);\n+    }\n+\n+    private static String firstDigitsOfNanos(String nano, int digits) {\n+        return String.format(Locale.ROOT, \"%09d\", Integer.parseInt(nano)).substring(0, digits);\n+    }\n+\n+    private static String lastNCharacter(String s, int n) {\n+        return s.substring(Math.max(0, s.length() - n));\n+    }\n+\n+    private static String zoneAbbreviationOf(TemporalAccessor temporalAccessor) {\n+        String zone = ZoneId.from(temporalAccessor).getDisplayName(TextStyle.SHORT, Locale.ROOT);\n+        return \"Z\".equals(zone) ? \"UTC\" : zone;\n+    }\n+\n+    private static class Builder {\n+\n+        private final String pattern;\n+        private boolean lowercaseAccepted = true;\n+        private Function<String, String> fillMode = ToCharFormatter::removeLeadingZeros;\n+        private boolean hasOrdinalSuffix = true;\n+        private Function<TemporalAccessor, String> formatFn;\n+\n+        Builder(String pattern) {\n+            this.pattern = pattern;\n+        }\n+\n+        public Builder formatFn(final String javaPattern) {\n+            return formatFn(javaPattern, null);\n+        }\n+\n+        public Builder formatFn(final String javaPattern, final Function<String, String> additionalMapper) {\n+            this.formatFn = temporalAccessor -> {\n+                String formatted = DateTimeFormatter.ofPattern(javaPattern != null ? javaPattern : \"'\" + pattern + \"'\", Locale.ROOT)\n+                    .format(temporalAccessor);\n+                return additionalMapper == null ? formatted : additionalMapper.apply(formatted);\n+            };\n+            return this;\n+        }\n+\n+        public Builder formatFn(Function<TemporalAccessor, String> formatFn) {\n+            this.formatFn = formatFn;\n+            return this;\n+        }\n+\n+        public Builder noFillMode() {\n+            this.fillMode = null;\n+            return this;\n+        }\n+\n+        public Builder text() {\n+            return text(ToCharFormatter::removePadding);\n+        }\n+\n+        public Builder text(Function<String, String> fillMode) {\n+            this.hasOrdinalSuffix = false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2NTY4MQ=="}, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 362}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NDU4ODk5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToChar.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNzowNToyM1rOIOff4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQyMzoxOTo0OFrOIOrEfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2NzA0MA==", "bodyText": "Is this needed? The default implementation is doing getClass().getSimpleName().toLowerCase(Locale.ROOT) which should be toChar, if I'm not missing anything.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552067040", "createdAt": "2021-01-05T17:05:23Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToChar.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.BinaryScalarFunction;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+\n+import java.time.ZoneId;\n+\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeFormatProcessor.Formatter.TO_CHAR;\n+\n+public class ToChar extends BaseDateTimeFormatFunction {\n+    public ToChar(Source source, Expression timestamp, Expression pattern, ZoneId zoneId) {\n+        super(source, timestamp, pattern, zoneId);\n+    }\n+\n+    @Override\n+    protected DateTimeFormatProcessor.Formatter formatter() {\n+        return TO_CHAR;\n+    }\n+\n+    @Override\n+    protected NodeInfo.NodeCtor3<Expression, Expression, ZoneId, BaseDateTimeFormatFunction> ctor() {\n+        return ToChar::new;\n+    }\n+    \n+    @Override\n+    protected String scriptMethodName() {\n+        return \"toChar\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI1NjYzOA==", "bodyText": "That will be to[c]har instead of to[C]har, InternalSqlScriptUtils.toChar would not follow the lowerCamelCase format.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552256638", "createdAt": "2021-01-05T23:19:48Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToChar.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.BinaryScalarFunction;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+\n+import java.time.ZoneId;\n+\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeFormatProcessor.Formatter.TO_CHAR;\n+\n+public class ToChar extends BaseDateTimeFormatFunction {\n+    public ToChar(Source source, Expression timestamp, Expression pattern, ZoneId zoneId) {\n+        super(source, timestamp, pattern, zoneId);\n+    }\n+\n+    @Override\n+    protected DateTimeFormatProcessor.Formatter formatter() {\n+        return TO_CHAR;\n+    }\n+\n+    @Override\n+    protected NodeInfo.NodeCtor3<Expression, Expression, ZoneId, BaseDateTimeFormatFunction> ctor() {\n+        return ToChar::new;\n+    }\n+    \n+    @Override\n+    protected String scriptMethodName() {\n+        return \"toChar\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2NzA0MA=="}, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NDYwNTEwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNzowOTozOFrOIOfphw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxNjoxMjowMlrOIPyh0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2OTUxMQ==", "bodyText": "Based on the code, it looks like the builder always ends up with text(), noFillMode or the default fill mode. If this assertion is correct, this behavior should be incapsulated in the builder to avoid calling build() and make these methods the final ones. Additionally aligned the names to better express what's going on:\ntext() -> noPadding()/removePadding()\ntext(fillMode) -> methodWithNameOfTheGivenFunction", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552069511", "createdAt": "2021-01-05T17:09:38Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,376 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::removeLeadingZerosFromOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int\n+        MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().getAsInt();\n+\n+    private final String pattern;\n+    private final boolean lowercaseAccepted;\n+    private final Function<String, String> fillMode;\n+    private final boolean hasOrdinalSuffix;\n+    private final Function<TemporalAccessor, String> formatFn;\n+\n+    private ToCharFormatter(\n+        String pattern,\n+        boolean lowercaseAccepted,\n+        Function<String, String> fillMode,\n+        boolean hasOrdinalSuffix,\n+        Function<TemporalAccessor, String> formatFn) {\n+\n+        this.pattern = pattern;\n+        this.lowercaseAccepted = lowercaseAccepted;\n+        this.fillMode = fillMode;\n+        this.hasOrdinalSuffix = hasOrdinalSuffix;\n+        this.formatFn = formatFn;\n+    }\n+\n+    private static Builder of(String pattern) {\n+        return new Builder(pattern);\n+    }\n+\n+    private String format(TemporalAccessor temporalAccessor) {\n+        return formatFn.apply(temporalAccessor);\n+    }\n+\n+    private ToCharFormatter withModifier(Function<String, String> modifierFn) {\n+        return new ToCharFormatter(pattern, lowercaseAccepted, fillMode, hasOrdinalSuffix, formatFn.andThen(modifierFn));\n+    }\n+\n+    private static List<ToCharFormatter> parsePattern(String toCharPattern) {\n+        LinkedList<ToCharFormatter> formatters = new LinkedList<>();\n+\n+        boolean fillModeModifierActive = false;\n+\n+        while (toCharPattern.isEmpty() == false) {\n+            boolean foundPattern = false;\n+            for (int length = Math.min(MAX_TO_CHAR_FORMAT_STRING_LENGTH, toCharPattern.length()); length >= 1; length--) {\n+                final String potentialPattern = toCharPattern.substring(0, length);\n+                if (isFillModeModifier(potentialPattern)) {\n+                    // try to apply the fill mode modifier to the next formatter\n+                    fillModeModifierActive = true;\n+                    foundPattern = true;\n+                } else if (isOrdinalSuffixModifier(potentialPattern)) {\n+                    // try to apply the ordinal suffix modifier to the last formatter\n+                    ToCharFormatter lastFormatter = formatters.removeLast();\n+                    if (lastFormatter == null) {\n+                        // if there was no previous pattern, simply prints the ordinal suffix pattern\n+                        lastFormatter = literal(potentialPattern);\n+                    } else if (lastFormatter.hasOrdinalSuffix) {\n+                        lastFormatter = lastFormatter.withModifier(s -> appendOrdinalSuffix(potentialPattern, s));\n+                    }\n+                    formatters.addLast(lastFormatter);\n+                    foundPattern = true;\n+                } else {\n+                    ToCharFormatter formatter = FORMATTER_MAP.get(potentialPattern);\n+                    // check if it is a known pattern string, if so apply it, with any modifier\n+                    if (formatter != null) {\n+                        if (fillModeModifierActive && formatter.fillMode != null) {\n+                            formatter = formatter.withModifier(formatter.fillMode);\n+                        }\n+                        formatters.addLast(formatter);\n+                        fillModeModifierActive = false;\n+                        foundPattern = true;\n+                    }\n+                }\n+                if (foundPattern) {\n+                    toCharPattern = toCharPattern.substring(length);\n+                    break;\n+                }\n+            }\n+            if (foundPattern == false) {\n+                // the fill mode modifier does not apply in case of literals\n+                formatters.addLast(literal(toCharPattern.substring(0, 1)));\n+                toCharPattern = toCharPattern.substring(1);\n+                fillModeModifierActive = false;\n+            }\n+        }\n+        return formatters;\n+    }\n+\n+    private static boolean isOrdinalSuffixModifier(String potentialPattern) {\n+        return \"TH\".equals(potentialPattern) || \"th\".equals(potentialPattern);\n+    }\n+\n+    private static boolean isFillModeModifier(String potentialPattern) {\n+        return \"FM\".equals(potentialPattern) || \"fm\".equals(potentialPattern);\n+    }\n+\n+    public static Function<TemporalAccessor, String> ofPattern(String pattern) {\n+        if (Strings.isEmpty(pattern)) {\n+            return timestamp -> \"\";\n+        }\n+        final List<ToCharFormatter> toCharFormatters = parsePattern(pattern);\n+        return timestamp -> toCharFormatters.stream().map(p -> p.format(timestamp)).collect(Collectors.joining());\n+    }\n+\n+    private static ToCharFormatter literal(String literal) {\n+        return new ToCharFormatter(literal, false, null, true, t -> literal);\n+    }\n+\n+    private static String ordinalSuffix(int i) {\n+        if (i < 0) {\n+            i = -i;\n+        }\n+        int mod100 = i % 100;\n+        int mod10 = i % 10;\n+        if (mod10 == 1 && mod100 != 11) {\n+            return \"st\";\n+        } else if (mod10 == 2 && mod100 != 12) {\n+            return \"nd\";\n+        } else if (mod10 == 3 && mod100 != 13) {\n+            return \"rd\";\n+        } else {\n+            return \"th\";\n+        }\n+    }\n+\n+    private static String appendOrdinalSuffix(String defaultSuffix, String s) {\n+        try {\n+            // the Y,YYY pattern might can cause problems with the parsing, but thankfully the last 3\n+            // characters is enough to calculate the suffix\n+            int i = Integer.parseInt(lastNCharacter(s, 3));\n+            final boolean upperCase = defaultSuffix.equals(defaultSuffix.toUpperCase(Locale.ROOT));\n+            return s + (upperCase ? ordinalSuffix(i).toUpperCase(Locale.ROOT) : ordinalSuffix(i));\n+        } catch (NumberFormatException ex) {\n+            return s + defaultSuffix;\n+        }\n+    }\n+\n+    private static String removeLeadingZeros(String number) {\n+        return String.valueOf(Integer.parseInt(number));\n+    }\n+\n+    private static String removePadding(String paddedText) {\n+        return paddedText.replaceAll(\" +$\", \"\");\n+    }\n+\n+    private static String formatOffset(String offset) {\n+        if (offset.equals(\"Z\")) {\n+            return \"+00\";\n+        }\n+        if (offset.matches(\"^[+-][0-9][0-9]00$\")) {\n+            offset = offset.substring(0, offset.length() - 2);\n+        } else if (offset.matches(\"^[+-][0-9]{3,4}$\")) {\n+            offset = offset.substring(0, offset.length() - 2) + \":\" + offset.substring(offset.length() - 2);\n+        } else if (offset.matches(\"^[+-][0-9][0-9]:00$\")) {\n+            offset = offset.substring(0, offset.length() - 3);\n+        }\n+        return offset.substring(0, Math.min(offset.length(), 6));\n+    }\n+\n+    private static String removeLeadingZerosFromOffset(String offset) {\n+        if (offset.matches(\"[+-]0{1,2}\")) {\n+            return offset.substring(0, 2);\n+        } else {\n+            if (offset.startsWith(\"+0\")) {\n+                return \"+\" + offset.substring(2);\n+            } else if (offset.startsWith(\"-0\")) {\n+                return \"-\" + offset.substring(2);\n+            } else {\n+                return offset;\n+            }\n+        }\n+    }\n+\n+    private static String absoluteWeekBasedYear(TemporalAccessor t) {\n+        int year = t.get(IsoFields.WEEK_BASED_YEAR);\n+        year = year > 0 ? year : -(year - 1);\n+        return String.format(Locale.ROOT, \"%04d\", year);\n+    }\n+\n+    private static String firstDigitsOfNanos(String nano, int digits) {\n+        return String.format(Locale.ROOT, \"%09d\", Integer.parseInt(nano)).substring(0, digits);\n+    }\n+\n+    private static String lastNCharacter(String s, int n) {\n+        return s.substring(Math.max(0, s.length() - n));\n+    }\n+\n+    private static String zoneAbbreviationOf(TemporalAccessor temporalAccessor) {\n+        String zone = ZoneId.from(temporalAccessor).getDisplayName(TextStyle.SHORT, Locale.ROOT);\n+        return \"Z\".equals(zone) ? \"UTC\" : zone;\n+    }\n+\n+    private static class Builder {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 322}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQyNzQwOQ==", "bodyText": "Refactored the builder numeric(), numericWithLeadingZeros(), text() and offset() replaced the build() method calls.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r553427409", "createdAt": "2021-01-07T16:12:02Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,376 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::removeLeadingZerosFromOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int\n+        MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().getAsInt();\n+\n+    private final String pattern;\n+    private final boolean lowercaseAccepted;\n+    private final Function<String, String> fillMode;\n+    private final boolean hasOrdinalSuffix;\n+    private final Function<TemporalAccessor, String> formatFn;\n+\n+    private ToCharFormatter(\n+        String pattern,\n+        boolean lowercaseAccepted,\n+        Function<String, String> fillMode,\n+        boolean hasOrdinalSuffix,\n+        Function<TemporalAccessor, String> formatFn) {\n+\n+        this.pattern = pattern;\n+        this.lowercaseAccepted = lowercaseAccepted;\n+        this.fillMode = fillMode;\n+        this.hasOrdinalSuffix = hasOrdinalSuffix;\n+        this.formatFn = formatFn;\n+    }\n+\n+    private static Builder of(String pattern) {\n+        return new Builder(pattern);\n+    }\n+\n+    private String format(TemporalAccessor temporalAccessor) {\n+        return formatFn.apply(temporalAccessor);\n+    }\n+\n+    private ToCharFormatter withModifier(Function<String, String> modifierFn) {\n+        return new ToCharFormatter(pattern, lowercaseAccepted, fillMode, hasOrdinalSuffix, formatFn.andThen(modifierFn));\n+    }\n+\n+    private static List<ToCharFormatter> parsePattern(String toCharPattern) {\n+        LinkedList<ToCharFormatter> formatters = new LinkedList<>();\n+\n+        boolean fillModeModifierActive = false;\n+\n+        while (toCharPattern.isEmpty() == false) {\n+            boolean foundPattern = false;\n+            for (int length = Math.min(MAX_TO_CHAR_FORMAT_STRING_LENGTH, toCharPattern.length()); length >= 1; length--) {\n+                final String potentialPattern = toCharPattern.substring(0, length);\n+                if (isFillModeModifier(potentialPattern)) {\n+                    // try to apply the fill mode modifier to the next formatter\n+                    fillModeModifierActive = true;\n+                    foundPattern = true;\n+                } else if (isOrdinalSuffixModifier(potentialPattern)) {\n+                    // try to apply the ordinal suffix modifier to the last formatter\n+                    ToCharFormatter lastFormatter = formatters.removeLast();\n+                    if (lastFormatter == null) {\n+                        // if there was no previous pattern, simply prints the ordinal suffix pattern\n+                        lastFormatter = literal(potentialPattern);\n+                    } else if (lastFormatter.hasOrdinalSuffix) {\n+                        lastFormatter = lastFormatter.withModifier(s -> appendOrdinalSuffix(potentialPattern, s));\n+                    }\n+                    formatters.addLast(lastFormatter);\n+                    foundPattern = true;\n+                } else {\n+                    ToCharFormatter formatter = FORMATTER_MAP.get(potentialPattern);\n+                    // check if it is a known pattern string, if so apply it, with any modifier\n+                    if (formatter != null) {\n+                        if (fillModeModifierActive && formatter.fillMode != null) {\n+                            formatter = formatter.withModifier(formatter.fillMode);\n+                        }\n+                        formatters.addLast(formatter);\n+                        fillModeModifierActive = false;\n+                        foundPattern = true;\n+                    }\n+                }\n+                if (foundPattern) {\n+                    toCharPattern = toCharPattern.substring(length);\n+                    break;\n+                }\n+            }\n+            if (foundPattern == false) {\n+                // the fill mode modifier does not apply in case of literals\n+                formatters.addLast(literal(toCharPattern.substring(0, 1)));\n+                toCharPattern = toCharPattern.substring(1);\n+                fillModeModifierActive = false;\n+            }\n+        }\n+        return formatters;\n+    }\n+\n+    private static boolean isOrdinalSuffixModifier(String potentialPattern) {\n+        return \"TH\".equals(potentialPattern) || \"th\".equals(potentialPattern);\n+    }\n+\n+    private static boolean isFillModeModifier(String potentialPattern) {\n+        return \"FM\".equals(potentialPattern) || \"fm\".equals(potentialPattern);\n+    }\n+\n+    public static Function<TemporalAccessor, String> ofPattern(String pattern) {\n+        if (Strings.isEmpty(pattern)) {\n+            return timestamp -> \"\";\n+        }\n+        final List<ToCharFormatter> toCharFormatters = parsePattern(pattern);\n+        return timestamp -> toCharFormatters.stream().map(p -> p.format(timestamp)).collect(Collectors.joining());\n+    }\n+\n+    private static ToCharFormatter literal(String literal) {\n+        return new ToCharFormatter(literal, false, null, true, t -> literal);\n+    }\n+\n+    private static String ordinalSuffix(int i) {\n+        if (i < 0) {\n+            i = -i;\n+        }\n+        int mod100 = i % 100;\n+        int mod10 = i % 10;\n+        if (mod10 == 1 && mod100 != 11) {\n+            return \"st\";\n+        } else if (mod10 == 2 && mod100 != 12) {\n+            return \"nd\";\n+        } else if (mod10 == 3 && mod100 != 13) {\n+            return \"rd\";\n+        } else {\n+            return \"th\";\n+        }\n+    }\n+\n+    private static String appendOrdinalSuffix(String defaultSuffix, String s) {\n+        try {\n+            // the Y,YYY pattern might can cause problems with the parsing, but thankfully the last 3\n+            // characters is enough to calculate the suffix\n+            int i = Integer.parseInt(lastNCharacter(s, 3));\n+            final boolean upperCase = defaultSuffix.equals(defaultSuffix.toUpperCase(Locale.ROOT));\n+            return s + (upperCase ? ordinalSuffix(i).toUpperCase(Locale.ROOT) : ordinalSuffix(i));\n+        } catch (NumberFormatException ex) {\n+            return s + defaultSuffix;\n+        }\n+    }\n+\n+    private static String removeLeadingZeros(String number) {\n+        return String.valueOf(Integer.parseInt(number));\n+    }\n+\n+    private static String removePadding(String paddedText) {\n+        return paddedText.replaceAll(\" +$\", \"\");\n+    }\n+\n+    private static String formatOffset(String offset) {\n+        if (offset.equals(\"Z\")) {\n+            return \"+00\";\n+        }\n+        if (offset.matches(\"^[+-][0-9][0-9]00$\")) {\n+            offset = offset.substring(0, offset.length() - 2);\n+        } else if (offset.matches(\"^[+-][0-9]{3,4}$\")) {\n+            offset = offset.substring(0, offset.length() - 2) + \":\" + offset.substring(offset.length() - 2);\n+        } else if (offset.matches(\"^[+-][0-9][0-9]:00$\")) {\n+            offset = offset.substring(0, offset.length() - 3);\n+        }\n+        return offset.substring(0, Math.min(offset.length(), 6));\n+    }\n+\n+    private static String removeLeadingZerosFromOffset(String offset) {\n+        if (offset.matches(\"[+-]0{1,2}\")) {\n+            return offset.substring(0, 2);\n+        } else {\n+            if (offset.startsWith(\"+0\")) {\n+                return \"+\" + offset.substring(2);\n+            } else if (offset.startsWith(\"-0\")) {\n+                return \"-\" + offset.substring(2);\n+            } else {\n+                return offset;\n+            }\n+        }\n+    }\n+\n+    private static String absoluteWeekBasedYear(TemporalAccessor t) {\n+        int year = t.get(IsoFields.WEEK_BASED_YEAR);\n+        year = year > 0 ? year : -(year - 1);\n+        return String.format(Locale.ROOT, \"%04d\", year);\n+    }\n+\n+    private static String firstDigitsOfNanos(String nano, int digits) {\n+        return String.format(Locale.ROOT, \"%09d\", Integer.parseInt(nano)).substring(0, digits);\n+    }\n+\n+    private static String lastNCharacter(String s, int n) {\n+        return s.substring(Math.max(0, s.length() - n));\n+    }\n+\n+    private static String zoneAbbreviationOf(TemporalAccessor temporalAccessor) {\n+        String zone = ZoneId.from(temporalAccessor).getDisplayName(TextStyle.SHORT, Locale.ROOT);\n+        return \"Z\".equals(zone) ? \"UTC\" : zone;\n+    }\n+\n+    private static class Builder {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2OTUxMQ=="}, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 322}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NDY0Mjg4OnYy", "diffSide": "RIGHT", "path": "docs/reference/sql/functions/date-time.asciidoc", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNzoxODo1NFrOIOgAFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxNjoxMzo1NFrOIPymHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA3NTI4Ng==", "bodyText": "I would have used a [NOTE] for these two cases, as well.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552075286", "createdAt": "2021-01-05T17:18:54Z", "author": {"login": "astefan"}, "path": "docs/reference/sql/functions/date-time.asciidoc", "diffHunk": "@@ -818,6 +818,57 @@ include-tagged::{sql-specs}/docs/docs.csv-spec[formatDateTime]\n include-tagged::{sql-specs}/docs/docs.csv-spec[formatTime]\n --------------------------------------------------\n \n+\n+[[sql-functions-datetime-to_char]]\n+==== `TO_CHAR`\n+\n+.Synopsis:\n+[source, sql]\n+--------------------------------------------------\n+TO_CHAR(\n+    date_exp/datetime_exp/time_exp, <1>\n+    string_exp) <2>\n+--------------------------------------------------\n+\n+*Input*:\n+\n+<1> date/datetime/time expression\n+<2> format pattern\n+\n+*Output*: string\n+\n+*Description*: Returns the date/datetime/time as a string using the format specified in the 2nd argument. The formatting\n+pattern conforms to\n+https://www.postgresql.org/docs/13/functions-formatting.html[PostgreSQL Template Patterns for Date/Time Formatting].\n+If any of the two arguments is `null` or the pattern is an empty string `null` is returned.\n+\n+[NOTE]\n+If the 1st argument is of type `time`, then the pattern specified by the 2nd argument cannot contain date related units\n+(e.g. 'dd', 'MM', 'YYYY', etc.). If it contains such units an error is returned.\n+\n+*Special Cases*", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI2Mjg0Mg==", "bodyText": "Follows the way the FORMAT is written.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552262842", "createdAt": "2021-01-05T23:38:05Z", "author": {"login": "palesz"}, "path": "docs/reference/sql/functions/date-time.asciidoc", "diffHunk": "@@ -818,6 +818,57 @@ include-tagged::{sql-specs}/docs/docs.csv-spec[formatDateTime]\n include-tagged::{sql-specs}/docs/docs.csv-spec[formatTime]\n --------------------------------------------------\n \n+\n+[[sql-functions-datetime-to_char]]\n+==== `TO_CHAR`\n+\n+.Synopsis:\n+[source, sql]\n+--------------------------------------------------\n+TO_CHAR(\n+    date_exp/datetime_exp/time_exp, <1>\n+    string_exp) <2>\n+--------------------------------------------------\n+\n+*Input*:\n+\n+<1> date/datetime/time expression\n+<2> format pattern\n+\n+*Output*: string\n+\n+*Description*: Returns the date/datetime/time as a string using the format specified in the 2nd argument. The formatting\n+pattern conforms to\n+https://www.postgresql.org/docs/13/functions-formatting.html[PostgreSQL Template Patterns for Date/Time Formatting].\n+If any of the two arguments is `null` or the pattern is an empty string `null` is returned.\n+\n+[NOTE]\n+If the 1st argument is of type `time`, then the pattern specified by the 2nd argument cannot contain date related units\n+(e.g. 'dd', 'MM', 'YYYY', etc.). If it contains such units an error is returned.\n+\n+*Special Cases*", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA3NTI4Ng=="}, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQyMjY1MA==", "bodyText": "This doesn't mean FORMAT has used the \"proper\" approach in this case, just like was the case for ordering the functions alphabetically. Using a [NOTE] instead of the current approach is not a hard rule afaik, but I would test converting those two statements in [NOTE]s, potentially look at other examples in the rest of the Elasticsearch documentation and decide if it's worth the change.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552422650", "createdAt": "2021-01-06T08:00:54Z", "author": {"login": "astefan"}, "path": "docs/reference/sql/functions/date-time.asciidoc", "diffHunk": "@@ -818,6 +818,57 @@ include-tagged::{sql-specs}/docs/docs.csv-spec[formatDateTime]\n include-tagged::{sql-specs}/docs/docs.csv-spec[formatTime]\n --------------------------------------------------\n \n+\n+[[sql-functions-datetime-to_char]]\n+==== `TO_CHAR`\n+\n+.Synopsis:\n+[source, sql]\n+--------------------------------------------------\n+TO_CHAR(\n+    date_exp/datetime_exp/time_exp, <1>\n+    string_exp) <2>\n+--------------------------------------------------\n+\n+*Input*:\n+\n+<1> date/datetime/time expression\n+<2> format pattern\n+\n+*Output*: string\n+\n+*Description*: Returns the date/datetime/time as a string using the format specified in the 2nd argument. The formatting\n+pattern conforms to\n+https://www.postgresql.org/docs/13/functions-formatting.html[PostgreSQL Template Patterns for Date/Time Formatting].\n+If any of the two arguments is `null` or the pattern is an empty string `null` is returned.\n+\n+[NOTE]\n+If the 1st argument is of type `time`, then the pattern specified by the 2nd argument cannot contain date related units\n+(e.g. 'dd', 'MM', 'YYYY', etc.). If it contains such units an error is returned.\n+\n+*Special Cases*", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA3NTI4Ng=="}, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQyODUxMA==", "bodyText": "Moved to [NOTE]", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r553428510", "createdAt": "2021-01-07T16:13:54Z", "author": {"login": "palesz"}, "path": "docs/reference/sql/functions/date-time.asciidoc", "diffHunk": "@@ -818,6 +818,57 @@ include-tagged::{sql-specs}/docs/docs.csv-spec[formatDateTime]\n include-tagged::{sql-specs}/docs/docs.csv-spec[formatTime]\n --------------------------------------------------\n \n+\n+[[sql-functions-datetime-to_char]]\n+==== `TO_CHAR`\n+\n+.Synopsis:\n+[source, sql]\n+--------------------------------------------------\n+TO_CHAR(\n+    date_exp/datetime_exp/time_exp, <1>\n+    string_exp) <2>\n+--------------------------------------------------\n+\n+*Input*:\n+\n+<1> date/datetime/time expression\n+<2> format pattern\n+\n+*Output*: string\n+\n+*Description*: Returns the date/datetime/time as a string using the format specified in the 2nd argument. The formatting\n+pattern conforms to\n+https://www.postgresql.org/docs/13/functions-formatting.html[PostgreSQL Template Patterns for Date/Time Formatting].\n+If any of the two arguments is `null` or the pattern is an empty string `null` is returned.\n+\n+[NOTE]\n+If the 1st argument is of type `time`, then the pattern specified by the 2nd argument cannot contain date related units\n+(e.g. 'dd', 'MM', 'YYYY', etc.). If it contains such units an error is returned.\n+\n+*Special Cases*", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA3NTI4Ng=="}, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NDY0NTc4OnYy", "diffSide": "RIGHT", "path": "docs/reference/sql/functions/date-time.asciidoc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNzoxOTo0MlrOIOgBzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNzoyMjoxMVrOIOgHJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA3NTcyNw==", "bodyText": "Not sure if \"implemented\" should be used or \"supported\". I'd lean towards the latter though.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552075727", "createdAt": "2021-01-05T17:19:42Z", "author": {"login": "astefan"}, "path": "docs/reference/sql/functions/date-time.asciidoc", "diffHunk": "@@ -818,6 +818,57 @@ include-tagged::{sql-specs}/docs/docs.csv-spec[formatDateTime]\n include-tagged::{sql-specs}/docs/docs.csv-spec[formatTime]\n --------------------------------------------------\n \n+\n+[[sql-functions-datetime-to_char]]\n+==== `TO_CHAR`\n+\n+.Synopsis:\n+[source, sql]\n+--------------------------------------------------\n+TO_CHAR(\n+    date_exp/datetime_exp/time_exp, <1>\n+    string_exp) <2>\n+--------------------------------------------------\n+\n+*Input*:\n+\n+<1> date/datetime/time expression\n+<2> format pattern\n+\n+*Output*: string\n+\n+*Description*: Returns the date/datetime/time as a string using the format specified in the 2nd argument. The formatting\n+pattern conforms to\n+https://www.postgresql.org/docs/13/functions-formatting.html[PostgreSQL Template Patterns for Date/Time Formatting].\n+If any of the two arguments is `null` or the pattern is an empty string `null` is returned.\n+\n+[NOTE]\n+If the 1st argument is of type `time`, then the pattern specified by the 2nd argument cannot contain date related units\n+(e.g. 'dd', 'MM', 'YYYY', etc.). If it contains such units an error is returned.\n+\n+*Special Cases*\n+\n+- The result of the patterns `TZ` and `tz` (time zone abbreviations) in some cases differ from the results returned by the TO_CHAR \n+in PostgreSQL. The reason is that the time zone abbreviations specified by the JDK are different from the ones specified by PostgreSQL. \n+This function might show an actual time zone abbreviation instead of the generic `LMT` or empty string or offset returned by the PostgreSQL \n+implementation. The summer/daylight markers might also differ between the two implementations (will see `HT` instead of `HST`).\n+- The `FX`, `TM`, `SP` pattern modifiers are not implemented and will  show up as `FX`, `TM` `SP` literals in the output.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA3NzA5NA==", "bodyText": "Comma after TM in the last sentence is missing.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552077094", "createdAt": "2021-01-05T17:22:11Z", "author": {"login": "astefan"}, "path": "docs/reference/sql/functions/date-time.asciidoc", "diffHunk": "@@ -818,6 +818,57 @@ include-tagged::{sql-specs}/docs/docs.csv-spec[formatDateTime]\n include-tagged::{sql-specs}/docs/docs.csv-spec[formatTime]\n --------------------------------------------------\n \n+\n+[[sql-functions-datetime-to_char]]\n+==== `TO_CHAR`\n+\n+.Synopsis:\n+[source, sql]\n+--------------------------------------------------\n+TO_CHAR(\n+    date_exp/datetime_exp/time_exp, <1>\n+    string_exp) <2>\n+--------------------------------------------------\n+\n+*Input*:\n+\n+<1> date/datetime/time expression\n+<2> format pattern\n+\n+*Output*: string\n+\n+*Description*: Returns the date/datetime/time as a string using the format specified in the 2nd argument. The formatting\n+pattern conforms to\n+https://www.postgresql.org/docs/13/functions-formatting.html[PostgreSQL Template Patterns for Date/Time Formatting].\n+If any of the two arguments is `null` or the pattern is an empty string `null` is returned.\n+\n+[NOTE]\n+If the 1st argument is of type `time`, then the pattern specified by the 2nd argument cannot contain date related units\n+(e.g. 'dd', 'MM', 'YYYY', etc.). If it contains such units an error is returned.\n+\n+*Special Cases*\n+\n+- The result of the patterns `TZ` and `tz` (time zone abbreviations) in some cases differ from the results returned by the TO_CHAR \n+in PostgreSQL. The reason is that the time zone abbreviations specified by the JDK are different from the ones specified by PostgreSQL. \n+This function might show an actual time zone abbreviation instead of the generic `LMT` or empty string or offset returned by the PostgreSQL \n+implementation. The summer/daylight markers might also differ between the two implementations (will see `HT` instead of `HST`).\n+- The `FX`, `TM`, `SP` pattern modifiers are not implemented and will  show up as `FX`, `TM` `SP` literals in the output.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA3NTcyNw=="}, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NDY4MTQ2OnYy", "diffSide": "RIGHT", "path": "docs/reference/sql/functions/index.asciidoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNzoyODo1MFrOIOgXQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNzoyODo1MFrOIOgXQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA4MTIxNw==", "bodyText": "The list of functions in each category should be ordered alphabetically. As it is now it's wrong, not only for TO_CHAR but also (from previous code changes) for EXTRACT and TIME_PARSE functions.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552081217", "createdAt": "2021-01-05T17:28:50Z", "author": {"login": "astefan"}, "path": "docs/reference/sql/functions/index.asciidoc", "diffHunk": "@@ -59,6 +59,7 @@\n ** <<sql-functions-datetime-datetimeformat>>\n ** <<sql-functions-datetime-datetimeparse>>\n ** <<sql-functions-datetime-format>>\n+** <<sql-functions-datetime-to_char>>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NDczNzM3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/whitelist/InternalSqlScriptUtils.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNzo0NDoxOVrOIOg5YA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxNjoxNDoxMlrOIPymwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA4OTk1Mg==", "bodyText": "You need a test in QueryTranslatorTests as well.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552089952", "createdAt": "2021-01-05T17:44:19Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/whitelist/InternalSqlScriptUtils.java", "diffHunk": "@@ -300,6 +300,10 @@ public static String format(Object dateTime, String pattern, String tzId) {\n         return (String) Formatter.FORMAT.format(asDateTime(dateTime), pattern, ZoneId.of(tzId));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE5NDI3OQ==", "bodyText": "And some tests in VerifierErrorMessagesTests.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552194279", "createdAt": "2021-01-05T21:06:02Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/whitelist/InternalSqlScriptUtils.java", "diffHunk": "@@ -300,6 +300,10 @@ public static String format(Object dateTime, String pattern, String tzId) {\n         return (String) Formatter.FORMAT.format(asDateTime(dateTime), pattern, ZoneId.of(tzId));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA4OTk1Mg=="}, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQyODY3Mg==", "bodyText": "Done.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r553428672", "createdAt": "2021-01-07T16:14:12Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/whitelist/InternalSqlScriptUtils.java", "diffHunk": "@@ -300,6 +300,10 @@ public static String format(Object dateTime, String pattern, String tzId) {\n         return (String) Formatter.FORMAT.format(asDateTime(dateTime), pattern, ZoneId.of(tzId));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA4OTk1Mg=="}, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NTQ2OTE0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQyMToyNTozN1rOIOn67w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQyMToyNTozN1rOIOn67w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIwNTAzOQ==", "bodyText": "Could you take these patterns from ToCharFormatter's FORMATTER_MAP content? Manually listing that long list of patterns feels brittle to me (things could be missed).", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552205039", "createdAt": "2021-01-05T21:25:37Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    private static class TestCase {\n+        private static final AtomicInteger COUNTER = new AtomicInteger(0);\n+        \n+        // timezones that are valid both in Java and in Postgres\n+        public static final List<String> POSTGRES_TEST_ZONE_LIST = List.of(\n+            // location-based and long-names\n+            \"US/Samoa\", \"Pacific/Honolulu\", \"Pacific/Marquesas\", \"Pacific/Gambier\", \"America/Juneau\", \"Canada/Yukon\", \"America/Vancouver\",\n+            \"Pacific/Easter\", \"US/Mountain\", \"America/Chicago\", \"US/Michigan\", \"Atlantic/Bermuda\", \"Canada/Newfoundland\",\n+            \"Atlantic/Cape_Verde\", \"Pacific/Kiritimati\", \"Pacific/Chatham\", \"Pacific/Auckland\", \"Asia/Sakhalin\", \"Australia/Tasmania\", \n+            \"Australia/North\", \"Asia/Tokyo\", \"Australia/Eucla\", \"Asia/Singapore\", \"Asia/Rangoon\", \"Indian/Chagos\", \"Asia/Calcutta\", \n+            \"Asia/Tashkent\", \"Asia/Tehran\", \"Asia/Dubai\", \"Africa/Nairobi\", \"Europe/Brussels\", \"Europe/Vienna\", \"Europe/London\", \n+            \"Etc/GMT+12\",\n+            // short names of zones\n+            \"GMT\", \"UTC\", \"CET\",\n+            // offsets\n+            \"+11:00\", \"+04:30\", \"+01:00\", \"+00:00\", \"-00:00\", \"-01:15\", \"-02:00\", \"-11:00\");\n+\n+        private final int id;\n+        private final BigDecimal secondsAndFractionsSinceEpoch;\n+        private final String formatString;\n+        private final String zoneId;\n+        \n+        TestCase(BigDecimal secondsAndFractionsSinceEpoch, String formatString) {\n+            this.id = COUNTER.incrementAndGet();\n+            this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+            this.formatString = formatString;\n+            this.zoneId = TestGenerator.randomFromCollection(POSTGRES_TEST_ZONE_LIST);\n+        }\n+\n+    }\n+\n+    /**\n+     * Generates an sql file that can be used to generate the test dataset for this unit test (to be used with the <code>psql</code> cli).\n+     *\n+     * Run the @{link {@link TestGenerator#main(String[])}} class and execute the following command to generate the output dataset with:\n+     *\n+     * <p>\n+     *  <code>\n+     *      # easy way to spin up the latest Postgres\n+     *      docker run --rm --name postgres-latest -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres:latest\n+     *\n+     *      # generate the csv for the unit test\n+     *      PGPASSWORD=\"mysecretpassword\" psql --quiet -h localhost -p 5432 -U postgres -f /tmp/postgresql-tochar-test.sql \\\n+     *          &gt; /path/to/tochar.csv\n+     *  </code>\n+     * </p>\n+     */\n+    private static class TestGenerator {\n+        \n+        private static final long SECONDS_IN_YEAR = 365 * 24 * 60 * 60L;\n+        private static final String DELIMITER = \"|\";\n+        private static final String PATTERN_DELIMITER = \" @ \";\n+        // these patterns are hard to sync up between PostgreSQL and Elasticsearch, so we just warn, but actually\n+        // accept the output of Elasticsearch as is\n+        private static final Set<String> NOT_FULLY_MATCHABLE_PATTERNS = Set.of(\"TZ\", \"tz\");\n+        private static final Set<String> UNSUPPORTED_PATTERN_MODIFIERS = Set.of(\"FX\", \"TM\", \"SP\");\n+        private static final String[] PATTERNS = new String[] {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NTQ4MTA2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQyMToyNzozOFrOIOoDiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQyMzoyMjo1MFrOIOrIhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIwNzI0Mw==", "bodyText": "Any good reason for not using ESTestCase's random() ?", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552207243", "createdAt": "2021-01-05T21:27:38Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    private static class TestCase {\n+        private static final AtomicInteger COUNTER = new AtomicInteger(0);\n+        \n+        // timezones that are valid both in Java and in Postgres\n+        public static final List<String> POSTGRES_TEST_ZONE_LIST = List.of(\n+            // location-based and long-names\n+            \"US/Samoa\", \"Pacific/Honolulu\", \"Pacific/Marquesas\", \"Pacific/Gambier\", \"America/Juneau\", \"Canada/Yukon\", \"America/Vancouver\",\n+            \"Pacific/Easter\", \"US/Mountain\", \"America/Chicago\", \"US/Michigan\", \"Atlantic/Bermuda\", \"Canada/Newfoundland\",\n+            \"Atlantic/Cape_Verde\", \"Pacific/Kiritimati\", \"Pacific/Chatham\", \"Pacific/Auckland\", \"Asia/Sakhalin\", \"Australia/Tasmania\", \n+            \"Australia/North\", \"Asia/Tokyo\", \"Australia/Eucla\", \"Asia/Singapore\", \"Asia/Rangoon\", \"Indian/Chagos\", \"Asia/Calcutta\", \n+            \"Asia/Tashkent\", \"Asia/Tehran\", \"Asia/Dubai\", \"Africa/Nairobi\", \"Europe/Brussels\", \"Europe/Vienna\", \"Europe/London\", \n+            \"Etc/GMT+12\",\n+            // short names of zones\n+            \"GMT\", \"UTC\", \"CET\",\n+            // offsets\n+            \"+11:00\", \"+04:30\", \"+01:00\", \"+00:00\", \"-00:00\", \"-01:15\", \"-02:00\", \"-11:00\");\n+\n+        private final int id;\n+        private final BigDecimal secondsAndFractionsSinceEpoch;\n+        private final String formatString;\n+        private final String zoneId;\n+        \n+        TestCase(BigDecimal secondsAndFractionsSinceEpoch, String formatString) {\n+            this.id = COUNTER.incrementAndGet();\n+            this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+            this.formatString = formatString;\n+            this.zoneId = TestGenerator.randomFromCollection(POSTGRES_TEST_ZONE_LIST);\n+        }\n+\n+    }\n+\n+    /**\n+     * Generates an sql file that can be used to generate the test dataset for this unit test (to be used with the <code>psql</code> cli).\n+     *\n+     * Run the @{link {@link TestGenerator#main(String[])}} class and execute the following command to generate the output dataset with:\n+     *\n+     * <p>\n+     *  <code>\n+     *      # easy way to spin up the latest Postgres\n+     *      docker run --rm --name postgres-latest -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres:latest\n+     *\n+     *      # generate the csv for the unit test\n+     *      PGPASSWORD=\"mysecretpassword\" psql --quiet -h localhost -p 5432 -U postgres -f /tmp/postgresql-tochar-test.sql \\\n+     *          &gt; /path/to/tochar.csv\n+     *  </code>\n+     * </p>\n+     */\n+    private static class TestGenerator {\n+        \n+        private static final long SECONDS_IN_YEAR = 365 * 24 * 60 * 60L;\n+        private static final String DELIMITER = \"|\";\n+        private static final String PATTERN_DELIMITER = \" @ \";\n+        // these patterns are hard to sync up between PostgreSQL and Elasticsearch, so we just warn, but actually\n+        // accept the output of Elasticsearch as is\n+        private static final Set<String> NOT_FULLY_MATCHABLE_PATTERNS = Set.of(\"TZ\", \"tz\");\n+        private static final Set<String> UNSUPPORTED_PATTERN_MODIFIERS = Set.of(\"FX\", \"TM\", \"SP\");\n+        private static final String[] PATTERNS = new String[] {\n+            \"HH\", \"HH12\", \"HH24\", \"MI\", \"SS\", \"MS\", \"US\", \"FF1\", \"FF2\", \"FF3\", \"FF4\", \"FF5\", \"FF6\", \"SSSS\", \"SSSSS\", \"AM\", \"am\", \"PM\",\n+            \"pm\", \"A.M.\", \"a.m.\", \"P.M.\", \"p.m.\", \"Y,YYY\", \"YYYY\", \"YYY\", \"YY\", \"Y\", \"IYYY\", \"IYY\", \"IY\", \"I\", \"BC\", \"bc\", \"AD\", \"ad\",\n+            \"B.C.\", \"b.c.\", \"A.D.\", \"a.d.\", \"MONTH\", \"Month\", \"month\", \"MON\", \"Mon\", \"mon\", \"MM\", \"DAY\", \"Day\", \"day\", \"DY\", \"Dy\",\n+            \"dy\", \"DDD\", \"IDDD\", \"DD\", \"D\", \"ID\", \"W\", \"WW\", \"IW\", \"CC\", \"J\", \"Q\", \"RM\", \"rm\", \"TZ\", \"tz\", \"TZH\", \"TZM\", \"OF\"\n+        };\n+        private static final List<String> FILL_MODIFIERS = List.of(\"FM\", \"fm\", \"\");\n+        private static final List<String> ORDINAL_SUFFIX_MODIFIERS = List.of(\"TH\", \"th\", \"\");\n+\n+        @SuppressForbidden(reason = \"It is ok to use ThreadLocalRandom outside of an actual test\")\n+        private static Random rnd() {\n+            return ThreadLocalRandom.current();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI1NzY3MQ==", "bodyText": "It is not available (throws exception) when the TestGenerator.main() is executed outside of the test infrastructure.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552257671", "createdAt": "2021-01-05T23:22:50Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    private static class TestCase {\n+        private static final AtomicInteger COUNTER = new AtomicInteger(0);\n+        \n+        // timezones that are valid both in Java and in Postgres\n+        public static final List<String> POSTGRES_TEST_ZONE_LIST = List.of(\n+            // location-based and long-names\n+            \"US/Samoa\", \"Pacific/Honolulu\", \"Pacific/Marquesas\", \"Pacific/Gambier\", \"America/Juneau\", \"Canada/Yukon\", \"America/Vancouver\",\n+            \"Pacific/Easter\", \"US/Mountain\", \"America/Chicago\", \"US/Michigan\", \"Atlantic/Bermuda\", \"Canada/Newfoundland\",\n+            \"Atlantic/Cape_Verde\", \"Pacific/Kiritimati\", \"Pacific/Chatham\", \"Pacific/Auckland\", \"Asia/Sakhalin\", \"Australia/Tasmania\", \n+            \"Australia/North\", \"Asia/Tokyo\", \"Australia/Eucla\", \"Asia/Singapore\", \"Asia/Rangoon\", \"Indian/Chagos\", \"Asia/Calcutta\", \n+            \"Asia/Tashkent\", \"Asia/Tehran\", \"Asia/Dubai\", \"Africa/Nairobi\", \"Europe/Brussels\", \"Europe/Vienna\", \"Europe/London\", \n+            \"Etc/GMT+12\",\n+            // short names of zones\n+            \"GMT\", \"UTC\", \"CET\",\n+            // offsets\n+            \"+11:00\", \"+04:30\", \"+01:00\", \"+00:00\", \"-00:00\", \"-01:15\", \"-02:00\", \"-11:00\");\n+\n+        private final int id;\n+        private final BigDecimal secondsAndFractionsSinceEpoch;\n+        private final String formatString;\n+        private final String zoneId;\n+        \n+        TestCase(BigDecimal secondsAndFractionsSinceEpoch, String formatString) {\n+            this.id = COUNTER.incrementAndGet();\n+            this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+            this.formatString = formatString;\n+            this.zoneId = TestGenerator.randomFromCollection(POSTGRES_TEST_ZONE_LIST);\n+        }\n+\n+    }\n+\n+    /**\n+     * Generates an sql file that can be used to generate the test dataset for this unit test (to be used with the <code>psql</code> cli).\n+     *\n+     * Run the @{link {@link TestGenerator#main(String[])}} class and execute the following command to generate the output dataset with:\n+     *\n+     * <p>\n+     *  <code>\n+     *      # easy way to spin up the latest Postgres\n+     *      docker run --rm --name postgres-latest -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres:latest\n+     *\n+     *      # generate the csv for the unit test\n+     *      PGPASSWORD=\"mysecretpassword\" psql --quiet -h localhost -p 5432 -U postgres -f /tmp/postgresql-tochar-test.sql \\\n+     *          &gt; /path/to/tochar.csv\n+     *  </code>\n+     * </p>\n+     */\n+    private static class TestGenerator {\n+        \n+        private static final long SECONDS_IN_YEAR = 365 * 24 * 60 * 60L;\n+        private static final String DELIMITER = \"|\";\n+        private static final String PATTERN_DELIMITER = \" @ \";\n+        // these patterns are hard to sync up between PostgreSQL and Elasticsearch, so we just warn, but actually\n+        // accept the output of Elasticsearch as is\n+        private static final Set<String> NOT_FULLY_MATCHABLE_PATTERNS = Set.of(\"TZ\", \"tz\");\n+        private static final Set<String> UNSUPPORTED_PATTERN_MODIFIERS = Set.of(\"FX\", \"TM\", \"SP\");\n+        private static final String[] PATTERNS = new String[] {\n+            \"HH\", \"HH12\", \"HH24\", \"MI\", \"SS\", \"MS\", \"US\", \"FF1\", \"FF2\", \"FF3\", \"FF4\", \"FF5\", \"FF6\", \"SSSS\", \"SSSSS\", \"AM\", \"am\", \"PM\",\n+            \"pm\", \"A.M.\", \"a.m.\", \"P.M.\", \"p.m.\", \"Y,YYY\", \"YYYY\", \"YYY\", \"YY\", \"Y\", \"IYYY\", \"IYY\", \"IY\", \"I\", \"BC\", \"bc\", \"AD\", \"ad\",\n+            \"B.C.\", \"b.c.\", \"A.D.\", \"a.d.\", \"MONTH\", \"Month\", \"month\", \"MON\", \"Mon\", \"mon\", \"MM\", \"DAY\", \"Day\", \"day\", \"DY\", \"Dy\",\n+            \"dy\", \"DDD\", \"IDDD\", \"DD\", \"D\", \"ID\", \"W\", \"WW\", \"IW\", \"CC\", \"J\", \"Q\", \"RM\", \"rm\", \"TZ\", \"tz\", \"TZH\", \"TZM\", \"OF\"\n+        };\n+        private static final List<String> FILL_MODIFIERS = List.of(\"FM\", \"fm\", \"\");\n+        private static final List<String> ORDINAL_SUFFIX_MODIFIERS = List.of(\"TH\", \"th\", \"\");\n+\n+        @SuppressForbidden(reason = \"It is ok to use ThreadLocalRandom outside of an actual test\")\n+        private static Random rnd() {\n+            return ThreadLocalRandom.current();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIwNzI0Mw=="}, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NTUwMTg0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQyMTozMjowNlrOIOoTHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQyMzoyNDozOVrOIOrK4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIxMTIyOQ==", "bodyText": "Our test infra does have a lot of helper methods for generating random stuff. I feel like you are re-inventing the wheel here with all the randomization logic in this class.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552211229", "createdAt": "2021-01-05T21:32:06Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    private static class TestCase {\n+        private static final AtomicInteger COUNTER = new AtomicInteger(0);\n+        \n+        // timezones that are valid both in Java and in Postgres\n+        public static final List<String> POSTGRES_TEST_ZONE_LIST = List.of(\n+            // location-based and long-names\n+            \"US/Samoa\", \"Pacific/Honolulu\", \"Pacific/Marquesas\", \"Pacific/Gambier\", \"America/Juneau\", \"Canada/Yukon\", \"America/Vancouver\",\n+            \"Pacific/Easter\", \"US/Mountain\", \"America/Chicago\", \"US/Michigan\", \"Atlantic/Bermuda\", \"Canada/Newfoundland\",\n+            \"Atlantic/Cape_Verde\", \"Pacific/Kiritimati\", \"Pacific/Chatham\", \"Pacific/Auckland\", \"Asia/Sakhalin\", \"Australia/Tasmania\", \n+            \"Australia/North\", \"Asia/Tokyo\", \"Australia/Eucla\", \"Asia/Singapore\", \"Asia/Rangoon\", \"Indian/Chagos\", \"Asia/Calcutta\", \n+            \"Asia/Tashkent\", \"Asia/Tehran\", \"Asia/Dubai\", \"Africa/Nairobi\", \"Europe/Brussels\", \"Europe/Vienna\", \"Europe/London\", \n+            \"Etc/GMT+12\",\n+            // short names of zones\n+            \"GMT\", \"UTC\", \"CET\",\n+            // offsets\n+            \"+11:00\", \"+04:30\", \"+01:00\", \"+00:00\", \"-00:00\", \"-01:15\", \"-02:00\", \"-11:00\");\n+\n+        private final int id;\n+        private final BigDecimal secondsAndFractionsSinceEpoch;\n+        private final String formatString;\n+        private final String zoneId;\n+        \n+        TestCase(BigDecimal secondsAndFractionsSinceEpoch, String formatString) {\n+            this.id = COUNTER.incrementAndGet();\n+            this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+            this.formatString = formatString;\n+            this.zoneId = TestGenerator.randomFromCollection(POSTGRES_TEST_ZONE_LIST);\n+        }\n+\n+    }\n+\n+    /**\n+     * Generates an sql file that can be used to generate the test dataset for this unit test (to be used with the <code>psql</code> cli).\n+     *\n+     * Run the @{link {@link TestGenerator#main(String[])}} class and execute the following command to generate the output dataset with:\n+     *\n+     * <p>\n+     *  <code>\n+     *      # easy way to spin up the latest Postgres\n+     *      docker run --rm --name postgres-latest -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres:latest\n+     *\n+     *      # generate the csv for the unit test\n+     *      PGPASSWORD=\"mysecretpassword\" psql --quiet -h localhost -p 5432 -U postgres -f /tmp/postgresql-tochar-test.sql \\\n+     *          &gt; /path/to/tochar.csv\n+     *  </code>\n+     * </p>\n+     */\n+    private static class TestGenerator {\n+        \n+        private static final long SECONDS_IN_YEAR = 365 * 24 * 60 * 60L;\n+        private static final String DELIMITER = \"|\";\n+        private static final String PATTERN_DELIMITER = \" @ \";\n+        // these patterns are hard to sync up between PostgreSQL and Elasticsearch, so we just warn, but actually\n+        // accept the output of Elasticsearch as is\n+        private static final Set<String> NOT_FULLY_MATCHABLE_PATTERNS = Set.of(\"TZ\", \"tz\");\n+        private static final Set<String> UNSUPPORTED_PATTERN_MODIFIERS = Set.of(\"FX\", \"TM\", \"SP\");\n+        private static final String[] PATTERNS = new String[] {\n+            \"HH\", \"HH12\", \"HH24\", \"MI\", \"SS\", \"MS\", \"US\", \"FF1\", \"FF2\", \"FF3\", \"FF4\", \"FF5\", \"FF6\", \"SSSS\", \"SSSSS\", \"AM\", \"am\", \"PM\",\n+            \"pm\", \"A.M.\", \"a.m.\", \"P.M.\", \"p.m.\", \"Y,YYY\", \"YYYY\", \"YYY\", \"YY\", \"Y\", \"IYYY\", \"IYY\", \"IY\", \"I\", \"BC\", \"bc\", \"AD\", \"ad\",\n+            \"B.C.\", \"b.c.\", \"A.D.\", \"a.d.\", \"MONTH\", \"Month\", \"month\", \"MON\", \"Mon\", \"mon\", \"MM\", \"DAY\", \"Day\", \"day\", \"DY\", \"Dy\",\n+            \"dy\", \"DDD\", \"IDDD\", \"DD\", \"D\", \"ID\", \"W\", \"WW\", \"IW\", \"CC\", \"J\", \"Q\", \"RM\", \"rm\", \"TZ\", \"tz\", \"TZH\", \"TZM\", \"OF\"\n+        };\n+        private static final List<String> FILL_MODIFIERS = List.of(\"FM\", \"fm\", \"\");\n+        private static final List<String> ORDINAL_SUFFIX_MODIFIERS = List.of(\"TH\", \"th\", \"\");\n+\n+        @SuppressForbidden(reason = \"It is ok to use ThreadLocalRandom outside of an actual test\")\n+        private static Random rnd() {\n+            return ThreadLocalRandom.current();\n+        }\n+\n+        private static BigDecimal randomSecondsWithFractions(int minYear, int maxYear) {\n+            BigDecimal seconds = new BigDecimal(RandomNumbers.randomLongBetween(rnd(), \n+                (minYear - 1970) * SECONDS_IN_YEAR, (maxYear - 1970) * SECONDS_IN_YEAR));\n+            BigDecimal fractions = new BigDecimal(RandomNumbers.randomIntBetween(rnd(), 0, 999_999)).movePointLeft(6);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI1ODI3NQ==", "bodyText": "I agree 100% and maybe I am missing something, but did not see an obvious way to use those random methods outside of the test infrastructure (TestGenerator.main()). Suggestions are welcome.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552258275", "createdAt": "2021-01-05T23:24:39Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    private static class TestCase {\n+        private static final AtomicInteger COUNTER = new AtomicInteger(0);\n+        \n+        // timezones that are valid both in Java and in Postgres\n+        public static final List<String> POSTGRES_TEST_ZONE_LIST = List.of(\n+            // location-based and long-names\n+            \"US/Samoa\", \"Pacific/Honolulu\", \"Pacific/Marquesas\", \"Pacific/Gambier\", \"America/Juneau\", \"Canada/Yukon\", \"America/Vancouver\",\n+            \"Pacific/Easter\", \"US/Mountain\", \"America/Chicago\", \"US/Michigan\", \"Atlantic/Bermuda\", \"Canada/Newfoundland\",\n+            \"Atlantic/Cape_Verde\", \"Pacific/Kiritimati\", \"Pacific/Chatham\", \"Pacific/Auckland\", \"Asia/Sakhalin\", \"Australia/Tasmania\", \n+            \"Australia/North\", \"Asia/Tokyo\", \"Australia/Eucla\", \"Asia/Singapore\", \"Asia/Rangoon\", \"Indian/Chagos\", \"Asia/Calcutta\", \n+            \"Asia/Tashkent\", \"Asia/Tehran\", \"Asia/Dubai\", \"Africa/Nairobi\", \"Europe/Brussels\", \"Europe/Vienna\", \"Europe/London\", \n+            \"Etc/GMT+12\",\n+            // short names of zones\n+            \"GMT\", \"UTC\", \"CET\",\n+            // offsets\n+            \"+11:00\", \"+04:30\", \"+01:00\", \"+00:00\", \"-00:00\", \"-01:15\", \"-02:00\", \"-11:00\");\n+\n+        private final int id;\n+        private final BigDecimal secondsAndFractionsSinceEpoch;\n+        private final String formatString;\n+        private final String zoneId;\n+        \n+        TestCase(BigDecimal secondsAndFractionsSinceEpoch, String formatString) {\n+            this.id = COUNTER.incrementAndGet();\n+            this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+            this.formatString = formatString;\n+            this.zoneId = TestGenerator.randomFromCollection(POSTGRES_TEST_ZONE_LIST);\n+        }\n+\n+    }\n+\n+    /**\n+     * Generates an sql file that can be used to generate the test dataset for this unit test (to be used with the <code>psql</code> cli).\n+     *\n+     * Run the @{link {@link TestGenerator#main(String[])}} class and execute the following command to generate the output dataset with:\n+     *\n+     * <p>\n+     *  <code>\n+     *      # easy way to spin up the latest Postgres\n+     *      docker run --rm --name postgres-latest -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres:latest\n+     *\n+     *      # generate the csv for the unit test\n+     *      PGPASSWORD=\"mysecretpassword\" psql --quiet -h localhost -p 5432 -U postgres -f /tmp/postgresql-tochar-test.sql \\\n+     *          &gt; /path/to/tochar.csv\n+     *  </code>\n+     * </p>\n+     */\n+    private static class TestGenerator {\n+        \n+        private static final long SECONDS_IN_YEAR = 365 * 24 * 60 * 60L;\n+        private static final String DELIMITER = \"|\";\n+        private static final String PATTERN_DELIMITER = \" @ \";\n+        // these patterns are hard to sync up between PostgreSQL and Elasticsearch, so we just warn, but actually\n+        // accept the output of Elasticsearch as is\n+        private static final Set<String> NOT_FULLY_MATCHABLE_PATTERNS = Set.of(\"TZ\", \"tz\");\n+        private static final Set<String> UNSUPPORTED_PATTERN_MODIFIERS = Set.of(\"FX\", \"TM\", \"SP\");\n+        private static final String[] PATTERNS = new String[] {\n+            \"HH\", \"HH12\", \"HH24\", \"MI\", \"SS\", \"MS\", \"US\", \"FF1\", \"FF2\", \"FF3\", \"FF4\", \"FF5\", \"FF6\", \"SSSS\", \"SSSSS\", \"AM\", \"am\", \"PM\",\n+            \"pm\", \"A.M.\", \"a.m.\", \"P.M.\", \"p.m.\", \"Y,YYY\", \"YYYY\", \"YYY\", \"YY\", \"Y\", \"IYYY\", \"IYY\", \"IY\", \"I\", \"BC\", \"bc\", \"AD\", \"ad\",\n+            \"B.C.\", \"b.c.\", \"A.D.\", \"a.d.\", \"MONTH\", \"Month\", \"month\", \"MON\", \"Mon\", \"mon\", \"MM\", \"DAY\", \"Day\", \"day\", \"DY\", \"Dy\",\n+            \"dy\", \"DDD\", \"IDDD\", \"DD\", \"D\", \"ID\", \"W\", \"WW\", \"IW\", \"CC\", \"J\", \"Q\", \"RM\", \"rm\", \"TZ\", \"tz\", \"TZH\", \"TZM\", \"OF\"\n+        };\n+        private static final List<String> FILL_MODIFIERS = List.of(\"FM\", \"fm\", \"\");\n+        private static final List<String> ORDINAL_SUFFIX_MODIFIERS = List.of(\"TH\", \"th\", \"\");\n+\n+        @SuppressForbidden(reason = \"It is ok to use ThreadLocalRandom outside of an actual test\")\n+        private static Random rnd() {\n+            return ThreadLocalRandom.current();\n+        }\n+\n+        private static BigDecimal randomSecondsWithFractions(int minYear, int maxYear) {\n+            BigDecimal seconds = new BigDecimal(RandomNumbers.randomLongBetween(rnd(), \n+                (minYear - 1970) * SECONDS_IN_YEAR, (maxYear - 1970) * SECONDS_IN_YEAR));\n+            BigDecimal fractions = new BigDecimal(RandomNumbers.randomIntBetween(rnd(), 0, 999_999)).movePointLeft(6);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIxMTIyOQ=="}, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MTk1NzI0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharTestScript.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QwOTo0NTo1OFrOIPlvmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QwOTo0NTo1OFrOIPlvmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzIxNzk0NA==", "bodyText": "Store the result in current directory, it's much more common - /tmp is not portable nor something where folks will typically look.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r553217944", "createdAt": "2021-01-07T09:45:58Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharTestScript.java", "diffHunk": "@@ -0,0 +1,242 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.common.util.set.Sets;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+/**\n+ * Generates an psql file that can be used to generate the test dataset for the {@link DateTimeToCharProcessorTests}.\n+ */\n+public class ToCharTestScript {\n+\n+    private static class TestRecord {\n+\n+        // timezones that are valid both in Java and in Postgres\n+        public static final List<String> POSTGRES_TEST_ZONE_LIST = asList(\n+            // location-based and long-names\n+            \"US/Samoa\", \"Pacific/Honolulu\", \"Pacific/Marquesas\", \"Pacific/Gambier\", \"America/Juneau\", \"Canada/Yukon\", \"America/Vancouver\",\n+            \"Pacific/Easter\", \"US/Mountain\", \"America/Chicago\", \"US/Michigan\", \"Atlantic/Bermuda\", \"Canada/Newfoundland\",\n+            \"Atlantic/Cape_Verde\", \"Pacific/Kiritimati\", \"Pacific/Chatham\", \"Pacific/Auckland\", \"Asia/Sakhalin\", \"Australia/Tasmania\",\n+            \"Australia/North\", \"Asia/Tokyo\", \"Australia/Eucla\", \"Asia/Singapore\", \"Asia/Rangoon\", \"Indian/Chagos\", \"Asia/Calcutta\",\n+            \"Asia/Tashkent\", \"Asia/Tehran\", \"Asia/Dubai\", \"Africa/Nairobi\", \"Europe/Brussels\", \"Europe/Vienna\", \"Europe/London\",\n+            \"Etc/GMT+12\",\n+            // short names of zones\n+            \"GMT\", \"UTC\", \"CET\",\n+            // offsets\n+            \"+11:00\", \"+04:30\", \"+01:00\", \"+00:00\", \"-00:00\", \"-01:15\", \"-02:00\", \"-11:00\");\n+        \n+        private final BigDecimal secondsAndFractionsSinceEpoch;\n+        private final String formatString;\n+        private final String zoneId;\n+\n+        TestRecord(BigDecimal secondsAndFractionsSinceEpoch, String formatString) {\n+            this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+            this.formatString = formatString;\n+            this.zoneId = ToCharTestScript.randomFromCollection(POSTGRES_TEST_ZONE_LIST);\n+        }\n+\n+    }\n+\n+    private static final long SECONDS_IN_YEAR = 365 * 24 * 60 * 60L;\n+    public static final String DELIMITER = \"|\";\n+    public static final String PATTERN_DELIMITER = \" @ \";\n+    // these patterns are hard to sync up between PostgreSQL and Elasticsearch, so we just warn, but actually\n+    // accept the output of Elasticsearch as is\n+    public static final Set<String> NOT_FULLY_MATCHABLE_PATTERNS = Set.of(\"TZ\", \"tz\");\n+    private static final Set<String> UNSUPPORTED_PATTERN_MODIFIERS = Set.of(\"FX\", \"TM\", \"SP\");\n+    private static final List<String> PATTERNS = new ArrayList<>(ToCharFormatter.FORMATTER_MAP.keySet());\n+    private static final List<String> FILL_MODIFIERS = asList(\"FM\", \"fm\", \"\");\n+    private static final List<String> ORDINAL_SUFFIX_MODIFIERS = asList(\"TH\", \"th\", \"\");\n+\n+    private final List<TestRecord> testRecords = new ArrayList<>();\n+    private final List<BigDecimal> testEpochSeconds = new ArrayList<>();\n+\n+    @SuppressForbidden(reason = \"It is ok to use ThreadLocalRandom outside of an actual test\")\n+    private static Random rnd() {\n+        return ThreadLocalRandom.current();\n+    }\n+\n+    public ToCharTestScript() {\n+        generateTestTimestamps();\n+        \n+        patternsOneByOne();\n+        allPatternsTogether();\n+        lowercasePatterns();\n+        postgreSQLPatternParsingBehaviour();\n+        monthsAsRomanNumbers();\n+        randomizedPatternStrings();\n+    }\n+\n+    private void generateTestTimestamps() {\n+        final int latestYearToTest = 3000;\n+        int countOfTestYears = 150;\n+        for (int i = 0; i < countOfTestYears; i++) {\n+            testEpochSeconds.add(randomSecondsWithFractions(-latestYearToTest, latestYearToTest));\n+        }\n+\n+        int countOfTestYearsAroundYearZero = 10;\n+        for (int i = 0; i < countOfTestYearsAroundYearZero; i++) {\n+            testEpochSeconds.add(randomSecondsWithFractions(-1, 1));\n+        }\n+    }\n+\n+    private void patternsOneByOne() {\n+        for (String pattern : PATTERNS) {\n+            testRecords.add(new TestRecord(\n+                randomFromCollection(testEpochSeconds),\n+                NOT_FULLY_MATCHABLE_PATTERNS.contains(pattern) ?\n+                    pattern :\n+                    String.join(PATTERN_DELIMITER, pattern, FILL_MODIFIERS.get(0) + pattern + ORDINAL_SUFFIX_MODIFIERS.get(0))));\n+        }\n+    }\n+\n+    private void allPatternsTogether() {\n+        for (BigDecimal es : testEpochSeconds) {\n+            testRecords.add(new TestRecord(\n+                es,\n+                IntStream.range(0, PATTERNS.size())\n+                    .mapToObj(idx -> idx + \":\" + patternWithRandomModifiers(PATTERNS.get(idx)))\n+                    .collect(Collectors.joining(PATTERN_DELIMITER))));\n+        }\n+    }\n+\n+    private void lowercasePatterns() {\n+        testRecords.add(new TestRecord(\n+            randomFromCollection(testEpochSeconds),\n+            IntStream.range(0, PATTERNS.size())\n+                .mapToObj(idx -> (idx + \":\" + patternWithRandomModifiers(PATTERNS.get(idx))).toLowerCase(Locale.ROOT))\n+                .collect(Collectors.joining(PATTERN_DELIMITER))));\n+    }\n+\n+    private void postgreSQLPatternParsingBehaviour() {\n+        // potentially ambiguous format string test cases, to check if our format string parsing is in-sync with PostgreSQL\n+        // that is greedy and prefers the longer format strings\n+        testRecords.add(new TestRecord(randomFromCollection(testEpochSeconds), \"YYYYYYYYYYYYYYY,YYYYYYYYY\"));\n+        testRecords.add(new TestRecord(randomFromCollection(testEpochSeconds), \"SSSSSSSSSSSSSSSS\"));\n+        testRecords.add(new TestRecord(randomFromCollection(testEpochSeconds), \"DDDDDDDD\"));\n+    }\n+\n+    private void monthsAsRomanNumbers() {\n+        for (int i = 1; i <= 12; i++) {\n+            testRecords.add(new TestRecord(\n+                new BigDecimal(dateTime(0).withMonth(i).toEpochSecond()),\n+                rnd().nextBoolean() ? \"RM\" : \"rm\"));\n+        }\n+    }\n+\n+    private void randomizedPatternStrings() {\n+        final String randomCharacters = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYabcdefghijklmnopqrstuvwxy _-.:;\";\n+\n+        final int randomizedPatternCount = 20;\n+        final int lengthOfRandomizedPattern = 30;\n+        final int pctChanceOfRandomCharacter = 80;\n+        for (int i = 0; i < randomizedPatternCount; i++) {\n+            String patternWithLiterals = IntStream.rangeClosed(1, lengthOfRandomizedPattern)\n+                    .mapToObj(idx -> {\n+                        if (rnd().nextInt(100) < pctChanceOfRandomCharacter) {\n+                            return randomCharacters.substring(rnd().nextInt(randomCharacters.length())).substring(0, 1);\n+                        } else {\n+                            return (randomFromCollection(FILL_MODIFIERS) + randomFromCollection(PATTERNS) \n+                                + randomFromCollection(ORDINAL_SUFFIX_MODIFIERS));\n+                        }})\n+                    .collect(Collectors.joining());\n+\n+            // clean up the random string from the unsupported modifiers\n+            for (String unsupportedPatternModifier : Sets.union(UNSUPPORTED_PATTERN_MODIFIERS, NOT_FULLY_MATCHABLE_PATTERNS)) {\n+                patternWithLiterals = patternWithLiterals\n+                    .replace(unsupportedPatternModifier, \"\")\n+                    .replace(unsupportedPatternModifier.toLowerCase(Locale.ROOT), \"\");\n+            }\n+            testRecords.add(new TestRecord(randomFromCollection(testEpochSeconds), patternWithLiterals));\n+        }\n+    }\n+\n+    private static BigDecimal randomSecondsWithFractions(int minYear, int maxYear) {\n+        BigDecimal seconds =\n+            new BigDecimal(RandomNumbers.randomLongBetween(rnd(), (minYear - 1970) * SECONDS_IN_YEAR, (maxYear - 1970) * SECONDS_IN_YEAR));\n+        BigDecimal fractions = new BigDecimal(RandomNumbers.randomIntBetween(rnd(), 0, 999_999)).movePointLeft(6);\n+        return seconds.add(fractions);\n+    }\n+\n+    private static <T> T randomFromCollection(Collection<T> list) {\n+        List<T> l = new ArrayList<>(list);\n+        return l.get(rnd().nextInt(l.size()));\n+    }\n+\n+    private static String patternWithRandomModifiers(String pattern) {\n+        if (NOT_FULLY_MATCHABLE_PATTERNS.contains(pattern)) {\n+            return pattern;\n+        }\n+        return randomFromCollection(FILL_MODIFIERS) + pattern + randomFromCollection(ORDINAL_SUFFIX_MODIFIERS);\n+    }\n+\n+    private static String adjustZoneIdToPostgres(String zoneId) {\n+        // when the zone is specified by the offset in Postgres, it follows the POSIX definition, so the +- signs are flipped\n+        // compared to ISO-8601, see more info at: https://www.postgresql.org/docs/current/datetime-posix-timezone-specs.html\n+        if (zoneId.startsWith(\"+\")) {\n+            zoneId = zoneId.replaceFirst(quote(\"+\"), \"-\");\n+        } else if (zoneId.startsWith(\"-\")) {\n+            zoneId = zoneId.replaceFirst(quote(\"-\"), \"+\");\n+        }\n+        return zoneId;\n+    }\n+\n+    /**\n+     * Generates an SQL file (psql input) that can be used to create the test dataset for the unit test of the <code>TO_CHAR</code>\n+     * implementation. In case the <code>TO_CHAR</code> implementation needs an upgrade, add the list of the new format\n+     * strings to the list of the format string, regenerate the SQL, run it against the PostgreSQL version you are targeting\n+     * and update the test CSV file.\n+     */\n+    private String unitTestExporterScript() {\n+        String header =\n+            \"\\n\\\\echo #\" +\n+            \"\\n\\\\echo # DO NOT EDIT manually, was generated using \" + ToCharTestScript.class.getName() +\n+            \"\\n\\\\echo #\\n\\n\";\n+        String testCases = testRecords.stream().map(tc -> {\n+            long seconds = tc.secondsAndFractionsSinceEpoch.longValue();\n+            BigDecimal fractions = tc.secondsAndFractionsSinceEpoch.remainder(BigDecimal.ONE).movePointRight(6);\n+            return String.format(Locale.ROOT, \n+                \"SET TIME ZONE '%6$s';\\n\"\n+                    + \"\\\\copy (SELECT %1$s as epoch_seconds_and_microsends, '%5$s' as zone_id, '%4$s' as format_string, \" \n+                    + \"(TO_TIMESTAMP(%2$d) + INTERVAL '%3$d microseconds') as to_timestamp_result, \"\n+                    + \"TO_CHAR((TO_TIMESTAMP(%2$d) + INTERVAL '%3$d microseconds'), '%4$s') as to_char_result) to stdout \" \n+                    + \"with DELIMITER as '\" + DELIMITER + \"' NULL as '' csv \\n\",\n+                tc.secondsAndFractionsSinceEpoch.toPlainString(),\n+                seconds,\n+                fractions.intValue(),\n+                tc.formatString,\n+                tc.zoneId,\n+                adjustZoneIdToPostgres(tc.zoneId));\n+        }).collect(Collectors.joining(\"\\n\"));\n+        return header + testCases;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        String scriptFilename = args.length < 1 ? \"/tmp/postgresql-tochar-test.sql\" : args[0];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ffbdb3f4aaea069ce5bd2f11b1333ced8580a963"}, "originalPosition": 239}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MTk5MjgzOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharTestScript.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QwOTo1NDo1NlrOIPmEaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQwMDowODo0OVrOIQBDfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzIyMzI3Mg==", "bodyText": "My initial comment stands - why aren't these strings externalized as in declared into a separate file?\nI'm not clear how they were produced nor why they have to be declared inside the java file and not separately?\nI like the idea of having everything in one place however in this case the input clearly comes from postgres and since the input is actually external, why not apply that to the zone list as well considering the declaration is ~ 40 strings.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r553223272", "createdAt": "2021-01-07T09:54:56Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharTestScript.java", "diffHunk": "@@ -0,0 +1,242 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.common.util.set.Sets;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+/**\n+ * Generates an psql file that can be used to generate the test dataset for the {@link DateTimeToCharProcessorTests}.\n+ */\n+public class ToCharTestScript {\n+\n+    private static class TestRecord {\n+\n+        // timezones that are valid both in Java and in Postgres\n+        public static final List<String> POSTGRES_TEST_ZONE_LIST = asList(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ffbdb3f4aaea069ce5bd2f11b1333ced8580a963"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzM4OTExMg==", "bodyText": "The list of time zones here are a few hand-picked that are available in older JDK versions (supported, CI runs against it), latest JDK versions and also in Postgres. These are inputs to the generator and show up in the generated sql script that you can run against PostgreSQL to (re)generate the expected TO_CHAR() outputs.\nWhat about if instead of burning these in, I put the output of the SELECT name from pg_timezone_names into a file and cross-check it against the Java timezone list? The one callout I have to add is that the ToCharTestScript will have to be run against the oldest supported JDK version, otherwise the tests on the CI will fail because of unsupported time zones.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r553389112", "createdAt": "2021-01-07T15:13:25Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharTestScript.java", "diffHunk": "@@ -0,0 +1,242 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.common.util.set.Sets;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+/**\n+ * Generates an psql file that can be used to generate the test dataset for the {@link DateTimeToCharProcessorTests}.\n+ */\n+public class ToCharTestScript {\n+\n+    private static class TestRecord {\n+\n+        // timezones that are valid both in Java and in Postgres\n+        public static final List<String> POSTGRES_TEST_ZONE_LIST = asList(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzIyMzI3Mg=="}, "originalCommit": {"oid": "ffbdb3f4aaea069ce5bd2f11b1333ced8580a963"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzUyNzc3NQ==", "bodyText": "If there's a way to generate the list, even better - put the output into a file along a header that indicates how the list came to be and make the test read it.\nI don't to over-engineer too much this PR which took significant time.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r553527775", "createdAt": "2021-01-07T19:11:08Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharTestScript.java", "diffHunk": "@@ -0,0 +1,242 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.common.util.set.Sets;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+/**\n+ * Generates an psql file that can be used to generate the test dataset for the {@link DateTimeToCharProcessorTests}.\n+ */\n+public class ToCharTestScript {\n+\n+    private static class TestRecord {\n+\n+        // timezones that are valid both in Java and in Postgres\n+        public static final List<String> POSTGRES_TEST_ZONE_LIST = asList(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzIyMzI3Mg=="}, "originalCommit": {"oid": "ffbdb3f4aaea069ce5bd2f11b1333ced8580a963"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzY2NTQwNQ==", "bodyText": "Done.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r553665405", "createdAt": "2021-01-08T00:08:49Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharTestScript.java", "diffHunk": "@@ -0,0 +1,242 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.common.util.set.Sets;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+/**\n+ * Generates an psql file that can be used to generate the test dataset for the {@link DateTimeToCharProcessorTests}.\n+ */\n+public class ToCharTestScript {\n+\n+    private static class TestRecord {\n+\n+        // timezones that are valid both in Java and in Postgres\n+        public static final List<String> POSTGRES_TEST_ZONE_LIST = asList(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzIyMzI3Mg=="}, "originalCommit": {"oid": "ffbdb3f4aaea069ce5bd2f11b1333ced8580a963"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4NDQwNjQwOnYy", "diffSide": "RIGHT", "path": "docs/reference/sql/functions/date-time.asciidoc", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QyMToyNzoyN1rOIP8_XA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQwMDowOTowMlrOIQBDvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzU5ODgxMg==", "bodyText": "Specifier with lowercase letters.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r553598812", "createdAt": "2021-01-07T21:27:27Z", "author": {"login": "astefan"}, "path": "docs/reference/sql/functions/date-time.asciidoc", "diffHunk": "@@ -791,15 +791,12 @@ If any of the two arguments is `null` or the pattern is an empty string `null` i\n \n [NOTE]\n If the 1st argument is of type `time`, then pattern specified by the 2nd argument cannot contain date related units\n-(e.g. 'dd', 'MM', 'YYYY', etc.). If it contains such units an error is returned.\n-\n-*Special Cases*\n-\n-- Format specifier `F` will be working similar to format specifier `f`.\n+(e.g. 'dd', 'MM', 'YYYY', etc.). If it contains such units an error is returned. +\n+Format specifier `F` will be working similar to format specifier `f`.\n It will return the fractional part of seconds, and the number of digits will be same as of the number of `Fs` provided as input (up to 9 digits).\n Result will contain `0` appended in the end to match with number of `F` provided.\n-e.g.: for a time part `10:20:30.1234` and pattern `HH:mm:ss.FFFFFF`, the output string of the function would be: `10:20:30.123400`.\n-- Format Specifier `y` will return year-of-era instead of one/two low-order digits.\n+e.g.: for a time part `10:20:30.1234` and pattern `HH:mm:ss.FFFFFF`, the output string of the function would be: `10:20:30.123400`. +\n+Format Specifier `y` will return year-of-era instead of one/two low-order digits.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d25b353205f8d0ca7cfb001e1d501045860710a"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzY2NTQ2OQ==", "bodyText": "Done.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r553665469", "createdAt": "2021-01-08T00:09:02Z", "author": {"login": "palesz"}, "path": "docs/reference/sql/functions/date-time.asciidoc", "diffHunk": "@@ -791,15 +791,12 @@ If any of the two arguments is `null` or the pattern is an empty string `null` i\n \n [NOTE]\n If the 1st argument is of type `time`, then pattern specified by the 2nd argument cannot contain date related units\n-(e.g. 'dd', 'MM', 'YYYY', etc.). If it contains such units an error is returned.\n-\n-*Special Cases*\n-\n-- Format specifier `F` will be working similar to format specifier `f`.\n+(e.g. 'dd', 'MM', 'YYYY', etc.). If it contains such units an error is returned. +\n+Format specifier `F` will be working similar to format specifier `f`.\n It will return the fractional part of seconds, and the number of digits will be same as of the number of `Fs` provided as input (up to 9 digits).\n Result will contain `0` appended in the end to match with number of `F` provided.\n-e.g.: for a time part `10:20:30.1234` and pattern `HH:mm:ss.FFFFFF`, the output string of the function would be: `10:20:30.123400`.\n-- Format Specifier `y` will return year-of-era instead of one/two low-order digits.\n+e.g.: for a time part `10:20:30.1234` and pattern `HH:mm:ss.FFFFFF`, the output string of the function would be: `10:20:30.123400`. +\n+Format Specifier `y` will return year-of-era instead of one/two low-order digits.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzU5ODgxMg=="}, "originalCommit": {"oid": "7d25b353205f8d0ca7cfb001e1d501045860710a"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4NDQ1MDA2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QyMTo0MjoyMlrOIP9Y7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQwMDowOTowOFrOIQBD5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzYwNTM1OQ==", "bodyText": "I think all these lines would be more readable if you'd import static all these static types.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r553605359", "createdAt": "2021-01-07T21:42:22Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.List;\n+import java.util.Locale;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    /**\n+     * Tests the {@link ToCharFormatter} against actual PostgreSQL output.\n+     * \n+     * Process to (re)generate the test data:\n+     * <ol>\n+     *     <li>Run the @{link {@link ToCharTestScript#main(String[])}} class</li>\n+     *     <li>Spin up a Postgres instance (latest or a specific version) using docker:\n+     *       <pre>\n+     *       docker run --rm --name postgres-latest -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres:latest\n+     *       </pre>\n+     *     </li>\n+     *     <li>Generate the test dataset by execution the SQL against PostgreSQL and capturing the output:\n+     *       <pre>\n+     *       PGPASSWORD=\"mysecretpassword\" psql --quiet -h localhost -p 5432 -U postgres -f /tmp/postgresql-tochar-test.sql \\\n+     *           &gt; /path/to/tochar.generated.csv\n+     *       </pre>\n+     *     </li>\n+     * </ol>\n+     */\n+    public void testAgainstPostgreSQLOutput() throws Exception {\n+        String testFile = \"tochar.generated.csv\";\n+        Path testFilePath = Path.of(DateTimeToCharProcessorTests.class.getResource(testFile).toURI());\n+        int lineNumber = 0;\n+        for (String line : Files.readAllLines(testFilePath)) {\n+            lineNumber += 1;\n+            if (line.startsWith(\"#\")) {\n+                continue;\n+            }\n+            String[] cols = line.split(quote(ToCharTestScript.DELIMITER));\n+            testOneCase(testFile, lineNumber, cols[0], cols[1], cols[2], cols[3], cols[4]);\n+        }\n+    }\n+\n+    /**\n+     * @param testFile The name of the testfile where this testcase is coming from\n+     * @param lineNumber The line number of the testcase within the testfile\n+     * @param secondsAndFractionsSinceEpoch The date represented by seconds and fractions since epoch that was used to \n+     *                                      generate the TO_CHAR() PostgreSQL output.\n+     * @param zone The long/short name or offset for the timezone used when generating the expected TO_CHAR() output.\n+     * @param formatString The pattern to be tested (this is exactly the pattern that was passed into the TO_CHAR() function in PostgreSQL).\n+     * @param posgresTimestamp The timestamp represented by PostgreSQL as string in the default format (without calling TO_CHAR()).\n+     * @param expectedResult The PostgreSQL output of <code>TO_CHAR(\n+     *                       (TO_TIMESTAMP([[secondsSinceEpoch]]) + INTERVAL '[[fractions]] microseconds'), \n+     *                       '[[formatString]]')</code>.\n+     */\n+    private void testOneCase(\n+        String testFile, int lineNumber, String secondsAndFractionsSinceEpoch, String zone,\n+        String formatString, String posgresTimestamp, String expectedResult) {\n+        ZoneId zoneId = ZoneId.of(zone);\n+        ZonedDateTime timestamp = dateTimeWithFractions(secondsAndFractionsSinceEpoch);\n+        String actualResult =\n+            (String) new ToChar(Source.EMPTY, l(timestamp, DataTypes.DATETIME), l(formatString, DataTypes.KEYWORD), zoneId)\n+                .makePipe()\n+                .asProcessor()\n+                .process(null);\n+        List<String> expectedResultSplitted = asList(expectedResult.split(quote(ToCharTestScript.PATTERN_DELIMITER)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ffbdb3f4aaea069ce5bd2f11b1333ced8580a963"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzY2NTUwOA==", "bodyText": "Done.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r553665508", "createdAt": "2021-01-08T00:09:08Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.List;\n+import java.util.Locale;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    /**\n+     * Tests the {@link ToCharFormatter} against actual PostgreSQL output.\n+     * \n+     * Process to (re)generate the test data:\n+     * <ol>\n+     *     <li>Run the @{link {@link ToCharTestScript#main(String[])}} class</li>\n+     *     <li>Spin up a Postgres instance (latest or a specific version) using docker:\n+     *       <pre>\n+     *       docker run --rm --name postgres-latest -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres:latest\n+     *       </pre>\n+     *     </li>\n+     *     <li>Generate the test dataset by execution the SQL against PostgreSQL and capturing the output:\n+     *       <pre>\n+     *       PGPASSWORD=\"mysecretpassword\" psql --quiet -h localhost -p 5432 -U postgres -f /tmp/postgresql-tochar-test.sql \\\n+     *           &gt; /path/to/tochar.generated.csv\n+     *       </pre>\n+     *     </li>\n+     * </ol>\n+     */\n+    public void testAgainstPostgreSQLOutput() throws Exception {\n+        String testFile = \"tochar.generated.csv\";\n+        Path testFilePath = Path.of(DateTimeToCharProcessorTests.class.getResource(testFile).toURI());\n+        int lineNumber = 0;\n+        for (String line : Files.readAllLines(testFilePath)) {\n+            lineNumber += 1;\n+            if (line.startsWith(\"#\")) {\n+                continue;\n+            }\n+            String[] cols = line.split(quote(ToCharTestScript.DELIMITER));\n+            testOneCase(testFile, lineNumber, cols[0], cols[1], cols[2], cols[3], cols[4]);\n+        }\n+    }\n+\n+    /**\n+     * @param testFile The name of the testfile where this testcase is coming from\n+     * @param lineNumber The line number of the testcase within the testfile\n+     * @param secondsAndFractionsSinceEpoch The date represented by seconds and fractions since epoch that was used to \n+     *                                      generate the TO_CHAR() PostgreSQL output.\n+     * @param zone The long/short name or offset for the timezone used when generating the expected TO_CHAR() output.\n+     * @param formatString The pattern to be tested (this is exactly the pattern that was passed into the TO_CHAR() function in PostgreSQL).\n+     * @param posgresTimestamp The timestamp represented by PostgreSQL as string in the default format (without calling TO_CHAR()).\n+     * @param expectedResult The PostgreSQL output of <code>TO_CHAR(\n+     *                       (TO_TIMESTAMP([[secondsSinceEpoch]]) + INTERVAL '[[fractions]] microseconds'), \n+     *                       '[[formatString]]')</code>.\n+     */\n+    private void testOneCase(\n+        String testFile, int lineNumber, String secondsAndFractionsSinceEpoch, String zone,\n+        String formatString, String posgresTimestamp, String expectedResult) {\n+        ZoneId zoneId = ZoneId.of(zone);\n+        ZonedDateTime timestamp = dateTimeWithFractions(secondsAndFractionsSinceEpoch);\n+        String actualResult =\n+            (String) new ToChar(Source.EMPTY, l(timestamp, DataTypes.DATETIME), l(formatString, DataTypes.KEYWORD), zoneId)\n+                .makePipe()\n+                .asProcessor()\n+                .process(null);\n+        List<String> expectedResultSplitted = asList(expectedResult.split(quote(ToCharTestScript.PATTERN_DELIMITER)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzYwNTM1OQ=="}, "originalCommit": {"oid": "ffbdb3f4aaea069ce5bd2f11b1333ced8580a963"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ5Mzg2MDYxOnYy", "diffSide": "RIGHT", "path": "docs/reference/sql/functions/date-time.asciidoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxMTo0OToyNFrOIRSEWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxMTo0OToyNFrOIRSEWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDk5MjcyOA==", "bodyText": "Did this mean to say \"will show\"? If HT refers to Hawaii, an indication that this is an example would clarify the intent (e.g. ... for Hawaii)", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r554992728", "createdAt": "2021-01-11T11:49:24Z", "author": {"login": "bpintea"}, "path": "docs/reference/sql/functions/date-time.asciidoc", "diffHunk": "@@ -818,6 +815,54 @@ include-tagged::{sql-specs}/docs/docs.csv-spec[formatDateTime]\n include-tagged::{sql-specs}/docs/docs.csv-spec[formatTime]\n --------------------------------------------------\n \n+\n+[[sql-functions-datetime-to_char]]\n+==== `TO_CHAR`\n+\n+.Synopsis:\n+[source, sql]\n+--------------------------------------------------\n+TO_CHAR(\n+    date_exp/datetime_exp/time_exp, <1>\n+    string_exp) <2>\n+--------------------------------------------------\n+\n+*Input*:\n+\n+<1> date/datetime/time expression\n+<2> format pattern\n+\n+*Output*: string\n+\n+*Description*: Returns the date/datetime/time as a string using the format specified in the 2nd argument. The formatting\n+pattern conforms to\n+https://www.postgresql.org/docs/13/functions-formatting.html[PostgreSQL Template Patterns for Date/Time Formatting].\n+If any of the two arguments is `null` or the pattern is an empty string `null` is returned.\n+\n+[NOTE]\n+If the 1st argument is of type `time`, then the pattern specified by the 2nd argument cannot contain date related units\n+(e.g. 'dd', 'MM', 'YYYY', etc.). If it contains such units an error is returned. +\n+The result of the patterns `TZ` and `tz` (time zone abbreviations) in some cases differ from the results returned by the `TO_CHAR`\n+in PostgreSQL. The reason is that the time zone abbreviations specified by the JDK are different from the ones specified by PostgreSQL. \n+This function might show an actual time zone abbreviation instead of the generic `LMT` or empty string or offset returned by the PostgreSQL \n+implementation. The summer/daylight markers might also differ between the two implementations (will see `HT` instead of `HST`). +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22da6f66707f5b4317b90b37bdcb8fcbd8dc62b4"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ5Mzg5MDAxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxMTo1ODowNlrOIRSWBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxNDoxOTozMFrOIRXQgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDk5NzI1Mg==", "bodyText": "Does this need a bounds check (2021-13-11)? month seems to come straight out of parseInt.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r554997252", "createdAt": "2021-01-11T11:58:06Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,377 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.JulianFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static java.lang.Integer.parseInt;\n+\n+/**\n+ * Formatting according to the PostgreSQL <code>to_char</code> function specification:\n+ * https://www.postgresql.org/docs/13/functions-formatting.html#FUNCTIONS-FORMATTING-DATETIME-TABLE\n+ */\n+class ToCharFormatter {\n+\n+    protected static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            of(\"HH\").formatFn(\"hh\").numeric(),\n+            of(\"HH12\").formatFn(\"hh\").numeric(),\n+            of(\"HH24\").formatFn(\"HH\").numeric(),\n+            of(\"MI\").formatFn(\"mm\").numeric(),\n+            of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", parseInt(x))).numeric(),\n+            of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).numericWithLeadingZeros(),\n+            of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).numericWithLeadingZeros(),\n+            of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).numericWithLeadingZeros(),\n+            of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).numericWithLeadingZeros(),\n+            of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).numericWithLeadingZeros(),\n+            of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).numericWithLeadingZeros(),\n+            of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).numericWithLeadingZeros(),\n+            of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).numericWithLeadingZeros(),\n+            of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(parseInt(milliSecondOfDay) / 1000)).numeric(),\n+            of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(parseInt(milliSecondOfDay) / 1000)).numeric(),\n+            of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).numericWithLeadingZeros(),\n+            of(\"YYYY\").formatFn(\"yyyy\").numeric(),\n+            of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)).numeric(),\n+            of(\"YY\").formatFn(\"yy\").numeric(),\n+            of(\"Y\").formatFn(\"yy\", year -> year.substring(1)).numeric(),\n+            of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)).numeric(),\n+            of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)).numeric(),\n+            of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)).numeric(),\n+            of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)).numeric(),\n+            of(\"BC\").formatFn(\"G\").text(),\n+            of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            of(\"AD\").formatFn(\"G\").text(),\n+            of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            of(\"Mon\").formatFn(\"MMM\").text(),\n+            of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            of(\"MM\").formatFn(\"MM\").numeric(),\n+            of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            of(\"Dy\").formatFn(\"E\").text(),\n+            of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            of(\"DDD\").formatFn(\"DDD\").numeric(),\n+            of(\"IDDD\").formatFn(t -> String.format(Locale.ROOT,\n+                \"%03d\",\n+                (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))\n+            ).numeric(),\n+            of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", parseInt(x))).numeric(),\n+            of(\"ID\").formatFn(\"e\").numeric(),\n+            of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))).numeric(),\n+            of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))).numeric(),\n+            of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))).numeric(),\n+            of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))).numeric(),\n+            of(\"CC\").formatFn(t -> {\n+                int century = yearToCentury(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }).numeric(),\n+            of(\"J\").formatFn(t -> String.valueOf(t.getLong(JulianFields.JULIAN_DAY))).numeric(),\n+            of(\"Q\").formatFn(\"Q\").numeric(),\n+            of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", monthToRoman(parseInt(month)))).text(),\n+            of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", monthToRoman(parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            of(\"TZH\").acceptsLowercase(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            of(\"TZM\").acceptsLowercase(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            of(\"OF\").acceptsLowercase(false).formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset).offset()\n+        );\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.acceptsLowercase) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+    \n+    private static final int MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().orElse(Integer.MAX_VALUE);\n+    \n+    private static final String[] ROMAN_NUMBERS = {\"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\"};\n+\n+    private final String pattern;\n+    private final boolean acceptsLowercase;\n+    // Fill mode: suppress leading zeroes and padding blanks\n+    // https://www.postgresql.org/docs/13/functions-formatting.html#FUNCTIONS-FORMATTING-DATETIMEMOD-TABLE\n+    private final Function<String, String> fillModeFn;\n+    private final boolean hasOrdinalSuffix;\n+    private final Function<TemporalAccessor, String> formatter;\n+\n+    private ToCharFormatter(\n+        String pattern,\n+        boolean acceptsLowercase,\n+        Function<String, String> fillModeFn,\n+        boolean hasOrdinalSuffix,\n+        Function<TemporalAccessor, String> formatter) {\n+\n+        this.pattern = pattern;\n+        this.acceptsLowercase = acceptsLowercase;\n+        this.fillModeFn = fillModeFn;\n+        this.hasOrdinalSuffix = hasOrdinalSuffix;\n+        this.formatter = formatter;\n+    }\n+\n+    private static Builder of(String pattern) {\n+        return new Builder(pattern);\n+    }\n+\n+    private static String monthToRoman(int month) {\n+        return ROMAN_NUMBERS[month - 1];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22da6f66707f5b4317b90b37bdcb8fcbd8dc62b4"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTA3Nzc2Mw==", "bodyText": "PostgreSQL roman numbers expected to be in the range 1-12 and although Undecimber exists (see also here), based on the current calls monthToRoman is only called on top of MM, which I believe (and correct me if I am wrong) will only return with 1-12, hence no checks in this method.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r555077763", "createdAt": "2021-01-11T14:19:30Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,377 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.JulianFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static java.lang.Integer.parseInt;\n+\n+/**\n+ * Formatting according to the PostgreSQL <code>to_char</code> function specification:\n+ * https://www.postgresql.org/docs/13/functions-formatting.html#FUNCTIONS-FORMATTING-DATETIME-TABLE\n+ */\n+class ToCharFormatter {\n+\n+    protected static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            of(\"HH\").formatFn(\"hh\").numeric(),\n+            of(\"HH12\").formatFn(\"hh\").numeric(),\n+            of(\"HH24\").formatFn(\"HH\").numeric(),\n+            of(\"MI\").formatFn(\"mm\").numeric(),\n+            of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", parseInt(x))).numeric(),\n+            of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).numericWithLeadingZeros(),\n+            of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).numericWithLeadingZeros(),\n+            of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).numericWithLeadingZeros(),\n+            of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).numericWithLeadingZeros(),\n+            of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).numericWithLeadingZeros(),\n+            of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).numericWithLeadingZeros(),\n+            of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).numericWithLeadingZeros(),\n+            of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).numericWithLeadingZeros(),\n+            of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(parseInt(milliSecondOfDay) / 1000)).numeric(),\n+            of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(parseInt(milliSecondOfDay) / 1000)).numeric(),\n+            of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).numericWithLeadingZeros(),\n+            of(\"YYYY\").formatFn(\"yyyy\").numeric(),\n+            of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)).numeric(),\n+            of(\"YY\").formatFn(\"yy\").numeric(),\n+            of(\"Y\").formatFn(\"yy\", year -> year.substring(1)).numeric(),\n+            of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)).numeric(),\n+            of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)).numeric(),\n+            of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)).numeric(),\n+            of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)).numeric(),\n+            of(\"BC\").formatFn(\"G\").text(),\n+            of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            of(\"AD\").formatFn(\"G\").text(),\n+            of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            of(\"Mon\").formatFn(\"MMM\").text(),\n+            of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            of(\"MM\").formatFn(\"MM\").numeric(),\n+            of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            of(\"Dy\").formatFn(\"E\").text(),\n+            of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            of(\"DDD\").formatFn(\"DDD\").numeric(),\n+            of(\"IDDD\").formatFn(t -> String.format(Locale.ROOT,\n+                \"%03d\",\n+                (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))\n+            ).numeric(),\n+            of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", parseInt(x))).numeric(),\n+            of(\"ID\").formatFn(\"e\").numeric(),\n+            of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))).numeric(),\n+            of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))).numeric(),\n+            of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))).numeric(),\n+            of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))).numeric(),\n+            of(\"CC\").formatFn(t -> {\n+                int century = yearToCentury(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }).numeric(),\n+            of(\"J\").formatFn(t -> String.valueOf(t.getLong(JulianFields.JULIAN_DAY))).numeric(),\n+            of(\"Q\").formatFn(\"Q\").numeric(),\n+            of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", monthToRoman(parseInt(month)))).text(),\n+            of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", monthToRoman(parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            of(\"TZH\").acceptsLowercase(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            of(\"TZM\").acceptsLowercase(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            of(\"OF\").acceptsLowercase(false).formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset).offset()\n+        );\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.acceptsLowercase) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+    \n+    private static final int MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().orElse(Integer.MAX_VALUE);\n+    \n+    private static final String[] ROMAN_NUMBERS = {\"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\"};\n+\n+    private final String pattern;\n+    private final boolean acceptsLowercase;\n+    // Fill mode: suppress leading zeroes and padding blanks\n+    // https://www.postgresql.org/docs/13/functions-formatting.html#FUNCTIONS-FORMATTING-DATETIMEMOD-TABLE\n+    private final Function<String, String> fillModeFn;\n+    private final boolean hasOrdinalSuffix;\n+    private final Function<TemporalAccessor, String> formatter;\n+\n+    private ToCharFormatter(\n+        String pattern,\n+        boolean acceptsLowercase,\n+        Function<String, String> fillModeFn,\n+        boolean hasOrdinalSuffix,\n+        Function<TemporalAccessor, String> formatter) {\n+\n+        this.pattern = pattern;\n+        this.acceptsLowercase = acceptsLowercase;\n+        this.fillModeFn = fillModeFn;\n+        this.hasOrdinalSuffix = hasOrdinalSuffix;\n+        this.formatter = formatter;\n+    }\n+\n+    private static Builder of(String pattern) {\n+        return new Builder(pattern);\n+    }\n+\n+    private static String monthToRoman(int month) {\n+        return ROMAN_NUMBERS[month - 1];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDk5NzI1Mg=="}, "originalCommit": {"oid": "22da6f66707f5b4317b90b37bdcb8fcbd8dc62b4"}, "originalPosition": 165}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ5OTEyMDU2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharTestScript.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQxNDoxODoyNVrOISDgAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQxNDoxODoyNVrOISDgAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTgwMjYyNg==", "bodyText": "replace the dot in the filename with a dash instead - tochar-test_timezones.txt or tochar-test-tz.txt", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r555802626", "createdAt": "2021-01-12T14:18:25Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharTestScript.java", "diffHunk": "@@ -71,6 +57,9 @@\n     private static final List<String> PATTERNS = new ArrayList<>(ToCharFormatter.FORMATTER_MAP.keySet());\n     private static final List<String> FILL_MODIFIERS = asList(\"FM\", \"fm\", \"\");\n     private static final List<String> ORDINAL_SUFFIX_MODIFIERS = asList(\"TH\", \"th\", \"\");\n+    // timezones that are valid both in Java and in Postgres\n+    public static final List<String> TIMEZONES_TO_TEST =\n+            readAllLinesWithoutComment(ToCharTestScript.class.getResource(\"tochar.test_timezones.txt\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "114dce9d497e2be83412e4e6293448629b2aa081"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ5OTEyODIyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQxNDoxOToyNVrOISDk8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQxNDoxOToyNVrOISDk8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTgwMzg5MQ==", "bodyText": "Replace the dot in the filename with -, tochar-generated.csv", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r555803891", "createdAt": "2021-01-12T14:19:25Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -44,16 +46,15 @@\n      *     </li>\n      * </ol>\n      */\n-    public void testAgainstPostgreSQLOutput() throws Exception {\n+    public void testAgainstPostgreSQLOutput() {\n         String testFile = \"tochar.generated.csv\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "114dce9d497e2be83412e4e6293448629b2aa081"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ5OTE2MDg4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharTestScript.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQxNDoyNTowNVrOISD5KQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQxNDoyNTowNVrOISD5KQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTgwOTA2NQ==", "bodyText": "This issue is still in place - why use a ThreadLocalRandom when no concurrency is needed and not rely on Random itself?\nAlso try to move away from it being static as that's tricky to clean-up. The new Random can be created within the main method and then passed around.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r555809065", "createdAt": "2021-01-12T14:25:05Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharTestScript.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.common.util.set.Sets;\n+\n+import java.math.BigDecimal;\n+import java.net.URI;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+/**\n+ * Generates an psql file that can be used to generate the test dataset for the {@link DateTimeToCharProcessorTests}.\n+ */\n+public class ToCharTestScript {\n+\n+    private static class TestRecord {\n+        private final BigDecimal secondsAndFractionsSinceEpoch;\n+        private final String formatString;\n+        private final String zoneId;\n+\n+        TestRecord(BigDecimal secondsAndFractionsSinceEpoch, String formatString) {\n+            this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+            this.formatString = formatString;\n+            this.zoneId = ToCharTestScript.randomFromCollection(TIMEZONES_TO_TEST);\n+        }\n+    }\n+\n+    private static final long SECONDS_IN_YEAR = 365 * 24 * 60 * 60L;\n+    public static final String DELIMITER = \"|\";\n+    public static final String PATTERN_DELIMITER = \" @ \";\n+    // these patterns are hard to sync up between PostgreSQL and Elasticsearch, so we just warn, but actually\n+    // accept the output of Elasticsearch as is\n+    public static final Set<String> NOT_FULLY_MATCHABLE_PATTERNS = Set.of(\"TZ\", \"tz\");\n+    private static final Set<String> UNSUPPORTED_PATTERN_MODIFIERS = Set.of(\"FX\", \"TM\", \"SP\");\n+    private static final List<String> PATTERNS = new ArrayList<>(ToCharFormatter.FORMATTER_MAP.keySet());\n+    private static final List<String> FILL_MODIFIERS = asList(\"FM\", \"fm\", \"\");\n+    private static final List<String> ORDINAL_SUFFIX_MODIFIERS = asList(\"TH\", \"th\", \"\");\n+    // timezones that are valid both in Java and in Postgres\n+    public static final List<String> TIMEZONES_TO_TEST =\n+            readAllLinesWithoutComment(ToCharTestScript.class.getResource(\"tochar.test_timezones.txt\"));\n+\n+    private final List<TestRecord> testRecords = new ArrayList<>();\n+    private final List<BigDecimal> testEpochSeconds = new ArrayList<>();\n+\n+    @SuppressForbidden(reason = \"It is ok to use ThreadLocalRandom outside of an actual test\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "114dce9d497e2be83412e4e6293448629b2aa081"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUzNDI2MTE2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMFQyMDoxODo1M1rOIXQZSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMFQyMDoxODo1M1rOIXQZSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTI1Njc3Nw==", "bodyText": "I believe it is possible to pass a rich object instead of primitives inside Object[] - not sure whether formatting works.\nAnyway, it's just a note for future reference.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r561256777", "createdAt": "2021-01-20T20:18:53Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -22,43 +27,56 @@\n import static org.elasticsearch.xpack.ql.type.DataTypes.KEYWORD;\n import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.ToCharTestScript.DELIMITER;\n-import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.ToCharTestScript.NOT_FULLY_MATCHABLE_PATTERNS;\n import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.ToCharTestScript.PATTERN_DELIMITER;\n \n+/**\n+ * Tests the {@link ToCharFormatter} against actual PostgreSQL output.\n+ *\n+ * Process to (re)generate the test data:\n+ * <ol>\n+ *     <li>Run the @{link {@link ToCharTestScript#main(String[])}} class</li>\n+ *     <li>Spin up a Postgres instance (latest or a specific version) using docker:\n+ *       <pre>\n+ *       docker run --rm --name postgres-latest -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres:latest\n+ *       </pre>\n+ *     </li>\n+ *     <li>Generate the test dataset by execution the SQL against PostgreSQL and capturing the output:\n+ *       <pre>\n+ *       PGPASSWORD=\"mysecretpassword\" psql --quiet -h localhost -p 5432 -U postgres -f /tmp/postgresql-tochar-test.sql \\\n+ *           &gt; /path/to/tochar-generated.csv\n+ *       </pre>\n+ *     </li>\n+ * </ol>\n+ * \n+ * In case you need to mute any of the tests, mute all tests by adding {@link org.apache.lucene.util.LuceneTestCase.AwaitsFix}\n+ * on the class level.\n+ */\n public class DateTimeToCharProcessorTests extends ESTestCase {\n-\n-    /**\n-     * Tests the {@link ToCharFormatter} against actual PostgreSQL output.\n-     * \n-     * Process to (re)generate the test data:\n-     * <ol>\n-     *     <li>Run the @{link {@link ToCharTestScript#main(String[])}} class</li>\n-     *     <li>Spin up a Postgres instance (latest or a specific version) using docker:\n-     *       <pre>\n-     *       docker run --rm --name postgres-latest -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres:latest\n-     *       </pre>\n-     *     </li>\n-     *     <li>Generate the test dataset by execution the SQL against PostgreSQL and capturing the output:\n-     *       <pre>\n-     *       PGPASSWORD=\"mysecretpassword\" psql --quiet -h localhost -p 5432 -U postgres -f /tmp/postgresql-tochar-test.sql \\\n-     *           &gt; /path/to/tochar-generated.csv\n-     *       </pre>\n-     *     </li>\n-     * </ol>\n-     */\n-    public void testAgainstPostgreSQLOutput() {\n+    \n+    @ParametersFactory(argumentFormatting = \"%1$s:%2$s %5$s\")\n+    public static Iterable<Object[]> parameters() throws Exception {\n+        List<Object[]> params = new ArrayList<>();\n         String testFile = \"tochar-generated.csv\";\n         int lineNumber = 0;\n-        for (String line : ToCharTestScript.readAllLinesWithoutComment(DateTimeToCharProcessorTests.class.getResource(testFile))) {\n+        for (String line : Files.readAllLines(Path.of(DateTimeToCharProcessorTests.class.getResource(testFile).toURI()))) {\n             lineNumber += 1;\n             if (line.startsWith(\"#\")) {\n                 continue;\n             }\n             String[] cols = line.split(quote(DELIMITER));\n-            testOneCase(testFile, lineNumber, cols[0], cols[1], cols[2], cols[3], cols[4]);\n+            params.add(new Object[]{testFile, lineNumber, cols[0], cols[1], cols[2], cols[3], cols[4]});\n         }\n+        return params;\n     }\n \n+    private final String testFile;\n+    private final int lineNumber;\n+    private final String secondsAndFractionsSinceEpoch;\n+    private final String zone;\n+    private final String formatString;\n+    private final String posgresTimestamp;\n+    private final String expectedResult;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6771c86da5d2d1a6286c55a3b7aac4f988bb45ed"}, "originalPosition": 93}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4539, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}