{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA5ODU2ODA2", "number": 55836, "title": "Add cache for application privileges", "bodyText": "Add caching support for application privileges to reduce number of round-trips to security index when building application privilege descriptors.\nA few key points of the changes:\n\nPer discussion #54317, the main cache is keyed by concrete application name and values are a set of application privilege descriptors.\nA secondary cache is also added to map a set of application expressions (i.e. with wildcard) to a set of concrete application names.\nDue to the cache design, privilege retrieving in NativePrivilegeStore is changed to always fetching all privilege documents for a given application.\nThe change is applied to all places including \"get privilege\", \"has privileges\" API and  CompositeRolesStore (for authentication).\n\nInitially I wanted to exclude CompositeRolesStore from the caching. But this means no code can be deleted from NativePrivilegeStore. We basically have to add \"retriving by application name\" on top of existing query logic. For simplicity, I later decided to include it so that the query part can be largely simplified.\n\n\nAdded an API to clear privilege cache, which is also used internally when adding/deleting privileges. These operations already clear role cache, the privilege cache invalidation is added on top of it.\nAdd security index state listener to clear cache on state changes.\nDocs added\nYaml tests added\n\nResolves: #54317", "createdAt": "2020-04-28T03:16:23Z", "url": "https://github.com/elastic/elasticsearch/pull/55836", "merged": true, "mergeCommit": {"oid": "38185e5da05e8b6322ae7f1eed8399e869cafd6b"}, "closed": true, "closedAt": "2020-06-29T03:59:01Z", "author": {"login": "ywangd"}, "timelineItems": {"totalCount": 67, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcboTergH2gAyNDA5ODU2ODA2OmI3MmQwZDNkZTE5YjBkNmMyYzY1MDQwMTIwMWZhNjQ4ZGRiMWY2YmU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcv4B-lAFqTQzODg1ODA2Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "b72d0d3de19b0d6c2c650401201fa648ddb1f6be", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/b72d0d3de19b0d6c2c650401201fa648ddb1f6be", "committedDate": "2020-04-27T05:19:31Z", "message": "WIP"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a02aba35ea0e04c5717e6240a71d0625d82e129a", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/a02aba35ea0e04c5717e6240a71d0625d82e129a", "committedDate": "2020-04-27T06:42:26Z", "message": "Add tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6d9fa0aca50fc709c47963d892720c487be02e37", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/6d9fa0aca50fc709c47963d892720c487be02e37", "committedDate": "2020-04-27T08:30:40Z", "message": "Add invalidation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ee33fffc1ed432cd7baee23db54222947ac1c69b", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/ee33fffc1ed432cd7baee23db54222947ac1c69b", "committedDate": "2020-04-27T08:51:28Z", "message": "Add some corrurrency liveness protection"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4bbd16d80b1279f7bd981eed82409fd9830d3df4", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/4bbd16d80b1279f7bd981eed82409fd9830d3df4", "committedDate": "2020-04-27T12:39:03Z", "message": "Add API for both rest and transport"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "df28676568c9ac872ebcb07c31da7449b313d2f0", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/df28676568c9ac872ebcb07c31da7449b313d2f0", "committedDate": "2020-04-27T15:54:25Z", "message": "Simplify NativePrivilegeStore"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4a63a16a5ee3c17670219c087d157d77761d2cf5", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/4a63a16a5ee3c17670219c087d157d77761d2cf5", "committedDate": "2020-04-27T15:56:50Z", "message": "Minor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a1d177cbcf5d99d7cb0f9bf9e2593fed5c27eaa8", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/a1d177cbcf5d99d7cb0f9bf9e2593fed5c27eaa8", "committedDate": "2020-04-27T16:10:30Z", "message": "More tweak"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "05061f972d863e577d838ac9ee721b9e23b4f68a", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/05061f972d863e577d838ac9ee721b9e23b4f68a", "committedDate": "2020-04-28T02:49:43Z", "message": "Add single node tests\n\nRest tests\nDocuments\nOther tweaks and optimizations"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAxNDcxNTEz", "url": "https://github.com/elastic/elasticsearch/pull/55836#pullrequestreview-401471513", "createdAt": "2020-04-28T03:24:32Z", "commit": {"oid": "05061f972d863e577d838ac9ee721b9e23b4f68a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQwMzoyNDozMlrOGNA1Zw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQwMzoyNDozMlrOGNA1Zw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjI5ODM0Mw==", "bodyText": "This pattern is used in CompositeRolesStore. However it is still possible that the cache gets invalidated immediately after the if check. The window for it to happen is much small, but still exists in theory.\nThe other pattern is to use ListenableFuture. This would solves the stale entry problem here because the future itself is removed from the cached. So adding items to the removed future has no impact to the cache. However, this pattern could potentially have a deadlock issue? If the thread computing for future crashes, will all the other thread waiting for it get stuck? If this is true, I'd prefer to use the first pattern since a stale entry (with very low chance) is less harmful than deadlocking.", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r416298343", "createdAt": "2020-04-28T03:24:32Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/NativePrivilegeStore.java", "diffHunk": "@@ -83,47 +100,120 @@\n     private final Settings settings;\n     private final Client client;\n     private final SecurityIndexManager securityIndexManager;\n+    private final Cache<String, Set<ApplicationPrivilegeDescriptor>> descriptorsCache;\n+    private final CacheIteratorHelper<String, Set<ApplicationPrivilegeDescriptor>> descriptorsCacheHelper;\n+    private final Cache<Set<String>, Set<String>> applicationNamesCache;\n+    private final CacheIteratorHelper<Set<String>, Set<String>> applicationNamesCacheHelper;\n+    private final AtomicLong numInvalidation = new AtomicLong();\n \n     public NativePrivilegeStore(Settings settings, Client client, SecurityIndexManager securityIndexManager) {\n         this.settings = settings;\n         this.client = client;\n         this.securityIndexManager = securityIndexManager;\n+        CacheBuilder<String, Set<ApplicationPrivilegeDescriptor>> builder = CacheBuilder.builder();\n+        final int cacheSize = DESCRIPTOR_CACHE_SIZE_SETTING.get(settings);\n+        if (cacheSize >= 0) {\n+            builder.setMaximumWeight(cacheSize);\n+            builder.weigher((k, v) -> v.size());\n+        }\n+        descriptorsCache = builder.build();\n+        descriptorsCacheHelper = new CacheIteratorHelper<>(descriptorsCache);\n+\n+        CacheBuilder<Set<String>, Set<String>> applicationNamesCacheBuilder = CacheBuilder.builder();\n+        final int nameCacheSize = APPLICATION_NAME_CACHE_SIZE_SETTING.get(settings);\n+        if (nameCacheSize >= 0) {\n+            applicationNamesCacheBuilder.setMaximumWeight(nameCacheSize);\n+            applicationNamesCacheBuilder.weigher((k, v) -> k.size() + v.size());\n+        }\n+        applicationNamesCache = applicationNamesCacheBuilder.build();\n+        applicationNamesCacheHelper = new CacheIteratorHelper<>(applicationNamesCache);\n     }\n \n     public void getPrivileges(Collection<String> applications, Collection<String> names,\n                               ActionListener<Collection<ApplicationPrivilegeDescriptor>> listener) {\n+\n+        // TODO: We should have a way to express true Zero applications\n+        final Set<String> applicationNamesCacheKey = (isEmpty(applications) || applications.contains(\"*\")) ?\n+            Collections.singleton(\"*\") : Set.copyOf(applications);\n+\n+        // Always fetch for the concrete application names even when the passed in application names do not\n+        // contain any wildcard. This serves as a negative lookup.\n+        Set<String> concreteApplicationNames = applicationNamesCache.get(applicationNamesCacheKey);\n+\n+        if (concreteApplicationNames != null && concreteApplicationNames.size() == 0) {\n+            logger.debug(\"returning empty application privileges as application names result in empty list\");\n+            listener.onResponse(Collections.emptySet());\n+\n+        } else {\n+            final Tuple<Set<String>, Map<String, Set<ApplicationPrivilegeDescriptor>>> cacheStatus;\n+            if (concreteApplicationNames == null) {\n+                cacheStatus = cacheStatusForApplicationNames(applicationNamesCacheKey);\n+            } else {\n+                cacheStatus = cacheStatusForApplicationNames(concreteApplicationNames);\n+            }\n+\n+            if (cacheStatus.v1().isEmpty()) {\n+                logger.debug(\"All application privileges found in cache\");\n+                final Set<ApplicationPrivilegeDescriptor> cachedDescriptors =\n+                    cacheStatus.v2().values().stream().flatMap(Collection::stream).collect(Collectors.toUnmodifiableSet());\n+                listener.onResponse(filterDescriptorsForNames(cachedDescriptors, names));\n+            } else {\n+                final long invalidationCounter = numInvalidation.get();\n+                // Always fetch all privileges of an application for caching purpose\n+                logger.debug(\"Fetching application privilege documents for: {}\", cacheStatus.v1());\n+                innerGetPrivileges(cacheStatus.v1(), ActionListener.wrap(fetchedDescriptors -> {\n+                    final Map<String, Set<ApplicationPrivilegeDescriptor>> mapOfFetchedDescriptors = fetchedDescriptors.stream()\n+                        .collect(Collectors.groupingBy(ApplicationPrivilegeDescriptor::getApplication, Collectors.toUnmodifiableSet()));\n+                    final Set<String> allApplicationNames =\n+                        Stream.concat(cacheStatus.v2().keySet().stream(), mapOfFetchedDescriptors.keySet().stream())\n+                            .collect(Collectors.toUnmodifiableSet());\n+                    // Avoid caching potential stale results.\n+                    // TODO: It is still possible that cache gets invalidated immediately after the if check\n+                    if (invalidationCounter == numInvalidation.get()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05061f972d863e577d838ac9ee721b9e23b4f68a"}, "originalPosition": 137}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAxNDcxODU5", "url": "https://github.com/elastic/elasticsearch/pull/55836#pullrequestreview-401471859", "createdAt": "2020-04-28T03:25:51Z", "commit": {"oid": "05061f972d863e577d838ac9ee721b9e23b4f68a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQwMzoyNTo1MVrOGNA3Eg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQwMzoyNTo1MVrOGNA3Eg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjI5ODc3MA==", "bodyText": "This is a minor optimisation so we do not store an etnry of {Set('app-1'), Set('app-1')}, where there is no expansion at all.", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r416298770", "createdAt": "2020-04-28T03:25:51Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/NativePrivilegeStore.java", "diffHunk": "@@ -83,47 +100,120 @@\n     private final Settings settings;\n     private final Client client;\n     private final SecurityIndexManager securityIndexManager;\n+    private final Cache<String, Set<ApplicationPrivilegeDescriptor>> descriptorsCache;\n+    private final CacheIteratorHelper<String, Set<ApplicationPrivilegeDescriptor>> descriptorsCacheHelper;\n+    private final Cache<Set<String>, Set<String>> applicationNamesCache;\n+    private final CacheIteratorHelper<Set<String>, Set<String>> applicationNamesCacheHelper;\n+    private final AtomicLong numInvalidation = new AtomicLong();\n \n     public NativePrivilegeStore(Settings settings, Client client, SecurityIndexManager securityIndexManager) {\n         this.settings = settings;\n         this.client = client;\n         this.securityIndexManager = securityIndexManager;\n+        CacheBuilder<String, Set<ApplicationPrivilegeDescriptor>> builder = CacheBuilder.builder();\n+        final int cacheSize = DESCRIPTOR_CACHE_SIZE_SETTING.get(settings);\n+        if (cacheSize >= 0) {\n+            builder.setMaximumWeight(cacheSize);\n+            builder.weigher((k, v) -> v.size());\n+        }\n+        descriptorsCache = builder.build();\n+        descriptorsCacheHelper = new CacheIteratorHelper<>(descriptorsCache);\n+\n+        CacheBuilder<Set<String>, Set<String>> applicationNamesCacheBuilder = CacheBuilder.builder();\n+        final int nameCacheSize = APPLICATION_NAME_CACHE_SIZE_SETTING.get(settings);\n+        if (nameCacheSize >= 0) {\n+            applicationNamesCacheBuilder.setMaximumWeight(nameCacheSize);\n+            applicationNamesCacheBuilder.weigher((k, v) -> k.size() + v.size());\n+        }\n+        applicationNamesCache = applicationNamesCacheBuilder.build();\n+        applicationNamesCacheHelper = new CacheIteratorHelper<>(applicationNamesCache);\n     }\n \n     public void getPrivileges(Collection<String> applications, Collection<String> names,\n                               ActionListener<Collection<ApplicationPrivilegeDescriptor>> listener) {\n+\n+        // TODO: We should have a way to express true Zero applications\n+        final Set<String> applicationNamesCacheKey = (isEmpty(applications) || applications.contains(\"*\")) ?\n+            Collections.singleton(\"*\") : Set.copyOf(applications);\n+\n+        // Always fetch for the concrete application names even when the passed in application names do not\n+        // contain any wildcard. This serves as a negative lookup.\n+        Set<String> concreteApplicationNames = applicationNamesCache.get(applicationNamesCacheKey);\n+\n+        if (concreteApplicationNames != null && concreteApplicationNames.size() == 0) {\n+            logger.debug(\"returning empty application privileges as application names result in empty list\");\n+            listener.onResponse(Collections.emptySet());\n+\n+        } else {\n+            final Tuple<Set<String>, Map<String, Set<ApplicationPrivilegeDescriptor>>> cacheStatus;\n+            if (concreteApplicationNames == null) {\n+                cacheStatus = cacheStatusForApplicationNames(applicationNamesCacheKey);\n+            } else {\n+                cacheStatus = cacheStatusForApplicationNames(concreteApplicationNames);\n+            }\n+\n+            if (cacheStatus.v1().isEmpty()) {\n+                logger.debug(\"All application privileges found in cache\");\n+                final Set<ApplicationPrivilegeDescriptor> cachedDescriptors =\n+                    cacheStatus.v2().values().stream().flatMap(Collection::stream).collect(Collectors.toUnmodifiableSet());\n+                listener.onResponse(filterDescriptorsForNames(cachedDescriptors, names));\n+            } else {\n+                final long invalidationCounter = numInvalidation.get();\n+                // Always fetch all privileges of an application for caching purpose\n+                logger.debug(\"Fetching application privilege documents for: {}\", cacheStatus.v1());\n+                innerGetPrivileges(cacheStatus.v1(), ActionListener.wrap(fetchedDescriptors -> {\n+                    final Map<String, Set<ApplicationPrivilegeDescriptor>> mapOfFetchedDescriptors = fetchedDescriptors.stream()\n+                        .collect(Collectors.groupingBy(ApplicationPrivilegeDescriptor::getApplication, Collectors.toUnmodifiableSet()));\n+                    final Set<String> allApplicationNames =\n+                        Stream.concat(cacheStatus.v2().keySet().stream(), mapOfFetchedDescriptors.keySet().stream())\n+                            .collect(Collectors.toUnmodifiableSet());\n+                    // Avoid caching potential stale results.\n+                    // TODO: It is still possible that cache gets invalidated immediately after the if check\n+                    if (invalidationCounter == numInvalidation.get()) {\n+                        // Do not cache the names if expansion has no effect\n+                        if (allApplicationNames.equals(applicationNamesCacheKey) == false) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05061f972d863e577d838ac9ee721b9e23b4f68a"}, "originalPosition": 139}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAxNDcyMzc2", "url": "https://github.com/elastic/elasticsearch/pull/55836#pullrequestreview-401472376", "createdAt": "2020-04-28T03:27:44Z", "commit": {"oid": "05061f972d863e577d838ac9ee721b9e23b4f68a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQwMzoyNzo0NVrOGNA5gg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQwMzoyNzo0NVrOGNA5gg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjI5OTM5NA==", "bodyText": "For invalidation, the application names cache is always completey invalidated since it requires some effort to identify the applicable entries. We could do this, but the gain may not be much.", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r416299394", "createdAt": "2020-04-28T03:27:45Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/NativePrivilegeStore.java", "diffHunk": "@@ -133,17 +223,69 @@ public void getPrivileges(Collection<String> applications, Collection<String> na\n                         .setFetchSource(true)\n                         .request();\n                     logger.trace(() ->\n-                        new ParameterizedMessage(\"Searching for privileges [{}] with query [{}]\", names, Strings.toString(query)));\n+                        new ParameterizedMessage(\"Searching for [{}] privileges with query [{}]\",\n+                            applications, Strings.toString(query)));\n                     request.indicesOptions().ignoreUnavailable();\n+                    // TODO: not parsing source of cached entries?\n                     ScrollHelper.fetchAllByEntity(client, request, new ContextPreservingActionListener<>(supplier, listener),\n                         hit -> buildPrivilege(hit.getId(), hit.getSourceRef()));\n                 }\n             });\n         }\n     }\n \n-    private boolean isSinglePrivilegeMatch(Collection<String> applications, Collection<String> names) {\n-        return applications != null && applications.size() == 1 && hasWildcard(applications) == false && names != null && names.size() == 1;\n+    public void invalidate(Collection<String> updatedApplicationNames) {\n+        logger.debug(\"Invalidating application privileges caches for: {}\", updatedApplicationNames);\n+        numInvalidation.incrementAndGet();\n+        // Always completely invalidate application names cache due to wildcard\n+        applicationNamesCache.invalidateAll();\n+        final Set<String> uniqueNames = Set.copyOf(updatedApplicationNames);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05061f972d863e577d838ac9ee721b9e23b4f68a"}, "originalPosition": 231}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "daafb80a97c35c1f5d1bc3a138409cb016160e73", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/daafb80a97c35c1f5d1bc3a138409cb016160e73", "committedDate": "2020-04-28T03:29:08Z", "message": "checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "545e27c3aef42158a6e296bb6077a9981e4d3589", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/545e27c3aef42158a6e296bb6077a9981e4d3589", "committedDate": "2020-04-28T03:39:29Z", "message": "More checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5987b3bf823e09fe685211395cdb8257de45a4c6", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/5987b3bf823e09fe685211395cdb8257de45a4c6", "committedDate": "2020-04-28T04:07:53Z", "message": "checkstyle again"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "60941785ac57b06e5ed9e305acd120db48566d32", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/60941785ac57b06e5ed9e305acd120db48566d32", "committedDate": "2020-04-28T04:09:59Z", "message": "Fix json API file"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1c58309b87b38718e10825eb15b9344ae9b38912", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/1c58309b87b38718e10825eb15b9344ae9b38912", "committedDate": "2020-04-28T04:27:51Z", "message": "Update API json file"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyMzU4NTAy", "url": "https://github.com/elastic/elasticsearch/pull/55836#pullrequestreview-402358502", "createdAt": "2020-04-29T04:32:19Z", "commit": {"oid": "1c58309b87b38718e10825eb15b9344ae9b38912"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwNDozMjoyMFrOGNvZPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwNjoyNzozNVrOGNxQQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA2MTE4MQ==", "bodyText": "We prefer Set.of to Collections.singleton", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r417061181", "createdAt": "2020-04-29T04:32:20Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/NativePrivilegeStore.java", "diffHunk": "@@ -83,47 +100,120 @@\n     private final Settings settings;\n     private final Client client;\n     private final SecurityIndexManager securityIndexManager;\n+    private final Cache<String, Set<ApplicationPrivilegeDescriptor>> descriptorsCache;\n+    private final CacheIteratorHelper<String, Set<ApplicationPrivilegeDescriptor>> descriptorsCacheHelper;\n+    private final Cache<Set<String>, Set<String>> applicationNamesCache;\n+    private final CacheIteratorHelper<Set<String>, Set<String>> applicationNamesCacheHelper;\n+    private final AtomicLong numInvalidation = new AtomicLong();\n \n     public NativePrivilegeStore(Settings settings, Client client, SecurityIndexManager securityIndexManager) {\n         this.settings = settings;\n         this.client = client;\n         this.securityIndexManager = securityIndexManager;\n+        CacheBuilder<String, Set<ApplicationPrivilegeDescriptor>> builder = CacheBuilder.builder();\n+        final int cacheSize = DESCRIPTOR_CACHE_SIZE_SETTING.get(settings);\n+        if (cacheSize >= 0) {\n+            builder.setMaximumWeight(cacheSize);\n+            builder.weigher((k, v) -> v.size());\n+        }\n+        descriptorsCache = builder.build();\n+        descriptorsCacheHelper = new CacheIteratorHelper<>(descriptorsCache);\n+\n+        CacheBuilder<Set<String>, Set<String>> applicationNamesCacheBuilder = CacheBuilder.builder();\n+        final int nameCacheSize = APPLICATION_NAME_CACHE_SIZE_SETTING.get(settings);\n+        if (nameCacheSize >= 0) {\n+            applicationNamesCacheBuilder.setMaximumWeight(nameCacheSize);\n+            applicationNamesCacheBuilder.weigher((k, v) -> k.size() + v.size());\n+        }\n+        applicationNamesCache = applicationNamesCacheBuilder.build();\n+        applicationNamesCacheHelper = new CacheIteratorHelper<>(applicationNamesCache);\n     }\n \n     public void getPrivileges(Collection<String> applications, Collection<String> names,\n                               ActionListener<Collection<ApplicationPrivilegeDescriptor>> listener) {\n+\n+        // TODO: We should have a way to express true Zero applications\n+        final Set<String> applicationNamesCacheKey = (isEmpty(applications) || applications.contains(\"*\")) ?\n+            Collections.singleton(\"*\") : Set.copyOf(applications);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c58309b87b38718e10825eb15b9344ae9b38912"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA2MjEzMw==", "bodyText": "You should avoid using a CacheIteratorHelper unless you absolutely need it.\nThis method iterates over the whole cache looking for matching items. In this case you don't need to do that, you can just invalidate an entry by key.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    descriptorsCacheHelper.removeKeysIf(uniqueNames::contains);\n          \n          \n            \n                   uniqueNames.forEach(descriptorsCache::invalidate);", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r417062133", "createdAt": "2020-04-29T04:36:48Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/NativePrivilegeStore.java", "diffHunk": "@@ -133,17 +223,69 @@ public void getPrivileges(Collection<String> applications, Collection<String> na\n                         .setFetchSource(true)\n                         .request();\n                     logger.trace(() ->\n-                        new ParameterizedMessage(\"Searching for privileges [{}] with query [{}]\", names, Strings.toString(query)));\n+                        new ParameterizedMessage(\"Searching for [{}] privileges with query [{}]\",\n+                            applications, Strings.toString(query)));\n                     request.indicesOptions().ignoreUnavailable();\n+                    // TODO: not parsing source of cached entries?\n                     ScrollHelper.fetchAllByEntity(client, request, new ContextPreservingActionListener<>(supplier, listener),\n                         hit -> buildPrivilege(hit.getId(), hit.getSourceRef()));\n                 }\n             });\n         }\n     }\n \n-    private boolean isSinglePrivilegeMatch(Collection<String> applications, Collection<String> names) {\n-        return applications != null && applications.size() == 1 && hasWildcard(applications) == false && names != null && names.size() == 1;\n+    public void invalidate(Collection<String> updatedApplicationNames) {\n+        logger.debug(\"Invalidating application privileges caches for: {}\", updatedApplicationNames);\n+        numInvalidation.incrementAndGet();\n+        // Always completely invalidate application names cache due to wildcard\n+        applicationNamesCache.invalidateAll();\n+        final Set<String> uniqueNames = Set.copyOf(updatedApplicationNames);\n+        descriptorsCacheHelper.removeKeysIf(uniqueNames::contains);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c58309b87b38718e10825eb15b9344ae9b38912"}, "originalPosition": 232}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA2MjcxOA==", "bodyText": "I don't think you need this.", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r417062718", "createdAt": "2020-04-29T04:39:22Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/NativePrivilegeStore.java", "diffHunk": "@@ -83,47 +100,120 @@\n     private final Settings settings;\n     private final Client client;\n     private final SecurityIndexManager securityIndexManager;\n+    private final Cache<String, Set<ApplicationPrivilegeDescriptor>> descriptorsCache;\n+    private final CacheIteratorHelper<String, Set<ApplicationPrivilegeDescriptor>> descriptorsCacheHelper;\n+    private final Cache<Set<String>, Set<String>> applicationNamesCache;\n+    private final CacheIteratorHelper<Set<String>, Set<String>> applicationNamesCacheHelper;\n+    private final AtomicLong numInvalidation = new AtomicLong();\n \n     public NativePrivilegeStore(Settings settings, Client client, SecurityIndexManager securityIndexManager) {\n         this.settings = settings;\n         this.client = client;\n         this.securityIndexManager = securityIndexManager;\n+        CacheBuilder<String, Set<ApplicationPrivilegeDescriptor>> builder = CacheBuilder.builder();\n+        final int cacheSize = DESCRIPTOR_CACHE_SIZE_SETTING.get(settings);\n+        if (cacheSize >= 0) {\n+            builder.setMaximumWeight(cacheSize);\n+            builder.weigher((k, v) -> v.size());\n+        }\n+        descriptorsCache = builder.build();\n+        descriptorsCacheHelper = new CacheIteratorHelper<>(descriptorsCache);\n+\n+        CacheBuilder<Set<String>, Set<String>> applicationNamesCacheBuilder = CacheBuilder.builder();\n+        final int nameCacheSize = APPLICATION_NAME_CACHE_SIZE_SETTING.get(settings);\n+        if (nameCacheSize >= 0) {\n+            applicationNamesCacheBuilder.setMaximumWeight(nameCacheSize);\n+            applicationNamesCacheBuilder.weigher((k, v) -> k.size() + v.size());\n+        }\n+        applicationNamesCache = applicationNamesCacheBuilder.build();\n+        applicationNamesCacheHelper = new CacheIteratorHelper<>(applicationNamesCache);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c58309b87b38718e10825eb15b9344ae9b38912"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA2Mjk2NQ==", "bodyText": "Nit, empty line", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r417062965", "createdAt": "2020-04-29T04:40:36Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/NativePrivilegeStore.java", "diffHunk": "@@ -83,47 +100,120 @@\n     private final Settings settings;\n     private final Client client;\n     private final SecurityIndexManager securityIndexManager;\n+    private final Cache<String, Set<ApplicationPrivilegeDescriptor>> descriptorsCache;\n+    private final CacheIteratorHelper<String, Set<ApplicationPrivilegeDescriptor>> descriptorsCacheHelper;\n+    private final Cache<Set<String>, Set<String>> applicationNamesCache;\n+    private final CacheIteratorHelper<Set<String>, Set<String>> applicationNamesCacheHelper;\n+    private final AtomicLong numInvalidation = new AtomicLong();\n \n     public NativePrivilegeStore(Settings settings, Client client, SecurityIndexManager securityIndexManager) {\n         this.settings = settings;\n         this.client = client;\n         this.securityIndexManager = securityIndexManager;\n+        CacheBuilder<String, Set<ApplicationPrivilegeDescriptor>> builder = CacheBuilder.builder();\n+        final int cacheSize = DESCRIPTOR_CACHE_SIZE_SETTING.get(settings);\n+        if (cacheSize >= 0) {\n+            builder.setMaximumWeight(cacheSize);\n+            builder.weigher((k, v) -> v.size());\n+        }\n+        descriptorsCache = builder.build();\n+        descriptorsCacheHelper = new CacheIteratorHelper<>(descriptorsCache);\n+\n+        CacheBuilder<Set<String>, Set<String>> applicationNamesCacheBuilder = CacheBuilder.builder();\n+        final int nameCacheSize = APPLICATION_NAME_CACHE_SIZE_SETTING.get(settings);\n+        if (nameCacheSize >= 0) {\n+            applicationNamesCacheBuilder.setMaximumWeight(nameCacheSize);\n+            applicationNamesCacheBuilder.weigher((k, v) -> k.size() + v.size());\n+        }\n+        applicationNamesCache = applicationNamesCacheBuilder.build();\n+        applicationNamesCacheHelper = new CacheIteratorHelper<>(applicationNamesCache);\n     }\n \n     public void getPrivileges(Collection<String> applications, Collection<String> names,\n                               ActionListener<Collection<ApplicationPrivilegeDescriptor>> listener) {\n+\n+        // TODO: We should have a way to express true Zero applications\n+        final Set<String> applicationNamesCacheKey = (isEmpty(applications) || applications.contains(\"*\")) ?\n+            Collections.singleton(\"*\") : Set.copyOf(applications);\n+\n+        // Always fetch for the concrete application names even when the passed in application names do not\n+        // contain any wildcard. This serves as a negative lookup.\n+        Set<String> concreteApplicationNames = applicationNamesCache.get(applicationNamesCacheKey);\n+\n+        if (concreteApplicationNames != null && concreteApplicationNames.size() == 0) {\n+            logger.debug(\"returning empty application privileges as application names result in empty list\");\n+            listener.onResponse(Collections.emptySet());\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c58309b87b38718e10825eb15b9344ae9b38912"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA2MzUxOA==", "bodyText": "Warning bells go off for me when I see complex Tuples like this (though I'm guilty of using them as well).\nI'd prefer we avoided it entirely, but if we really need it, can we assign the members to appropriately named local vars as soon as possible after the method returns?", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r417063518", "createdAt": "2020-04-29T04:43:02Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/NativePrivilegeStore.java", "diffHunk": "@@ -83,47 +100,120 @@\n     private final Settings settings;\n     private final Client client;\n     private final SecurityIndexManager securityIndexManager;\n+    private final Cache<String, Set<ApplicationPrivilegeDescriptor>> descriptorsCache;\n+    private final CacheIteratorHelper<String, Set<ApplicationPrivilegeDescriptor>> descriptorsCacheHelper;\n+    private final Cache<Set<String>, Set<String>> applicationNamesCache;\n+    private final CacheIteratorHelper<Set<String>, Set<String>> applicationNamesCacheHelper;\n+    private final AtomicLong numInvalidation = new AtomicLong();\n \n     public NativePrivilegeStore(Settings settings, Client client, SecurityIndexManager securityIndexManager) {\n         this.settings = settings;\n         this.client = client;\n         this.securityIndexManager = securityIndexManager;\n+        CacheBuilder<String, Set<ApplicationPrivilegeDescriptor>> builder = CacheBuilder.builder();\n+        final int cacheSize = DESCRIPTOR_CACHE_SIZE_SETTING.get(settings);\n+        if (cacheSize >= 0) {\n+            builder.setMaximumWeight(cacheSize);\n+            builder.weigher((k, v) -> v.size());\n+        }\n+        descriptorsCache = builder.build();\n+        descriptorsCacheHelper = new CacheIteratorHelper<>(descriptorsCache);\n+\n+        CacheBuilder<Set<String>, Set<String>> applicationNamesCacheBuilder = CacheBuilder.builder();\n+        final int nameCacheSize = APPLICATION_NAME_CACHE_SIZE_SETTING.get(settings);\n+        if (nameCacheSize >= 0) {\n+            applicationNamesCacheBuilder.setMaximumWeight(nameCacheSize);\n+            applicationNamesCacheBuilder.weigher((k, v) -> k.size() + v.size());\n+        }\n+        applicationNamesCache = applicationNamesCacheBuilder.build();\n+        applicationNamesCacheHelper = new CacheIteratorHelper<>(applicationNamesCache);\n     }\n \n     public void getPrivileges(Collection<String> applications, Collection<String> names,\n                               ActionListener<Collection<ApplicationPrivilegeDescriptor>> listener) {\n+\n+        // TODO: We should have a way to express true Zero applications\n+        final Set<String> applicationNamesCacheKey = (isEmpty(applications) || applications.contains(\"*\")) ?\n+            Collections.singleton(\"*\") : Set.copyOf(applications);\n+\n+        // Always fetch for the concrete application names even when the passed in application names do not\n+        // contain any wildcard. This serves as a negative lookup.\n+        Set<String> concreteApplicationNames = applicationNamesCache.get(applicationNamesCacheKey);\n+\n+        if (concreteApplicationNames != null && concreteApplicationNames.size() == 0) {\n+            logger.debug(\"returning empty application privileges as application names result in empty list\");\n+            listener.onResponse(Collections.emptySet());\n+\n+        } else {\n+            final Tuple<Set<String>, Map<String, Set<ApplicationPrivilegeDescriptor>>> cacheStatus;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c58309b87b38718e10825eb15b9344ae9b38912"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA3MjQ0Nw==", "bodyText": "If I update the privileges for 2 apps (1 already cached, 1 not yet cached) right at this point, then 1 app would be served from the cache and be pre-update and the other would be served from the index and be post-update.\nI think if we're going to have to hit the index anyway, we should just load for all applications and ensure we get as close as possible to a point-in-time read.", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r417072447", "createdAt": "2020-04-29T05:20:56Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/NativePrivilegeStore.java", "diffHunk": "@@ -83,47 +100,120 @@\n     private final Settings settings;\n     private final Client client;\n     private final SecurityIndexManager securityIndexManager;\n+    private final Cache<String, Set<ApplicationPrivilegeDescriptor>> descriptorsCache;\n+    private final CacheIteratorHelper<String, Set<ApplicationPrivilegeDescriptor>> descriptorsCacheHelper;\n+    private final Cache<Set<String>, Set<String>> applicationNamesCache;\n+    private final CacheIteratorHelper<Set<String>, Set<String>> applicationNamesCacheHelper;\n+    private final AtomicLong numInvalidation = new AtomicLong();\n \n     public NativePrivilegeStore(Settings settings, Client client, SecurityIndexManager securityIndexManager) {\n         this.settings = settings;\n         this.client = client;\n         this.securityIndexManager = securityIndexManager;\n+        CacheBuilder<String, Set<ApplicationPrivilegeDescriptor>> builder = CacheBuilder.builder();\n+        final int cacheSize = DESCRIPTOR_CACHE_SIZE_SETTING.get(settings);\n+        if (cacheSize >= 0) {\n+            builder.setMaximumWeight(cacheSize);\n+            builder.weigher((k, v) -> v.size());\n+        }\n+        descriptorsCache = builder.build();\n+        descriptorsCacheHelper = new CacheIteratorHelper<>(descriptorsCache);\n+\n+        CacheBuilder<Set<String>, Set<String>> applicationNamesCacheBuilder = CacheBuilder.builder();\n+        final int nameCacheSize = APPLICATION_NAME_CACHE_SIZE_SETTING.get(settings);\n+        if (nameCacheSize >= 0) {\n+            applicationNamesCacheBuilder.setMaximumWeight(nameCacheSize);\n+            applicationNamesCacheBuilder.weigher((k, v) -> k.size() + v.size());\n+        }\n+        applicationNamesCache = applicationNamesCacheBuilder.build();\n+        applicationNamesCacheHelper = new CacheIteratorHelper<>(applicationNamesCache);\n     }\n \n     public void getPrivileges(Collection<String> applications, Collection<String> names,\n                               ActionListener<Collection<ApplicationPrivilegeDescriptor>> listener) {\n+\n+        // TODO: We should have a way to express true Zero applications\n+        final Set<String> applicationNamesCacheKey = (isEmpty(applications) || applications.contains(\"*\")) ?\n+            Collections.singleton(\"*\") : Set.copyOf(applications);\n+\n+        // Always fetch for the concrete application names even when the passed in application names do not\n+        // contain any wildcard. This serves as a negative lookup.\n+        Set<String> concreteApplicationNames = applicationNamesCache.get(applicationNamesCacheKey);\n+\n+        if (concreteApplicationNames != null && concreteApplicationNames.size() == 0) {\n+            logger.debug(\"returning empty application privileges as application names result in empty list\");\n+            listener.onResponse(Collections.emptySet());\n+\n+        } else {\n+            final Tuple<Set<String>, Map<String, Set<ApplicationPrivilegeDescriptor>>> cacheStatus;\n+            if (concreteApplicationNames == null) {\n+                cacheStatus = cacheStatusForApplicationNames(applicationNamesCacheKey);\n+            } else {\n+                cacheStatus = cacheStatusForApplicationNames(concreteApplicationNames);\n+            }\n+\n+            if (cacheStatus.v1().isEmpty()) {\n+                logger.debug(\"All application privileges found in cache\");\n+                final Set<ApplicationPrivilegeDescriptor> cachedDescriptors =\n+                    cacheStatus.v2().values().stream().flatMap(Collection::stream).collect(Collectors.toUnmodifiableSet());\n+                listener.onResponse(filterDescriptorsForNames(cachedDescriptors, names));\n+            } else {\n+                final long invalidationCounter = numInvalidation.get();\n+                // Always fetch all privileges of an application for caching purpose\n+                logger.debug(\"Fetching application privilege documents for: {}\", cacheStatus.v1());\n+                innerGetPrivileges(cacheStatus.v1(), ActionListener.wrap(fetchedDescriptors -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c58309b87b38718e10825eb15b9344ae9b38912"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA4MjgwMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  \"url\":\"https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-clear-role-cache.html\",\n          \n          \n            \n                  \"url\":\"https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-clear-role-cache.html\",\n          \n      \n    \n    \n  \n\nWe need this to point to a real doc before committing.", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r417082803", "createdAt": "2020-04-29T05:59:05Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/src/test/resources/rest-api-spec/api/security.clear_cached_privileges.json", "diffHunk": "@@ -0,0 +1,26 @@\n+{\n+  \"security.clear_cached_privileges\":{\n+    \"documentation\":{\n+      \"url\":\"https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-clear-role-cache.html\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c58309b87b38718e10825eb15b9344ae9b38912"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA4MzI3NA==", "bodyText": "I'm not sure about this. It seems like this API ends up doing something other than what it was supposed to, just because we assume that the caller wants it.\nI understand why - if the privileges have changed then the roles cache is probably wrong, but it seems like it's chain side-effects together.", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r417083274", "createdAt": "2020-04-29T06:00:50Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/action/privilege/TransportClearPrivilegesCacheAction.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.action.privilege;\n+\n+import org.elasticsearch.action.FailedNodeException;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.nodes.TransportNodesAction;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.core.security.action.privilege.ClearPrivilegesCacheAction;\n+import org.elasticsearch.xpack.core.security.action.privilege.ClearPrivilegesCacheRequest;\n+import org.elasticsearch.xpack.core.security.action.privilege.ClearPrivilegesCacheResponse;\n+import org.elasticsearch.xpack.security.authz.store.CompositeRolesStore;\n+import org.elasticsearch.xpack.security.authz.store.NativePrivilegeStore;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+public class TransportClearPrivilegesCacheAction extends TransportNodesAction<ClearPrivilegesCacheRequest, ClearPrivilegesCacheResponse,\n+    ClearPrivilegesCacheRequest.Node, ClearPrivilegesCacheResponse.Node> {\n+\n+    private final NativePrivilegeStore privilegesStore;\n+    private final CompositeRolesStore rolesStore;\n+\n+    @Inject\n+    public TransportClearPrivilegesCacheAction(\n+        ThreadPool threadPool,\n+        ClusterService clusterService,\n+        TransportService transportService,\n+        ActionFilters actionFilters,\n+        NativePrivilegeStore privilegesStore,\n+        CompositeRolesStore rolesStore) {\n+        super(\n+            ClearPrivilegesCacheAction.NAME,\n+            threadPool,\n+            clusterService,\n+            transportService,\n+            actionFilters,\n+            ClearPrivilegesCacheRequest::new,\n+            ClearPrivilegesCacheRequest.Node::new,\n+            ThreadPool.Names.MANAGEMENT,\n+            ClearPrivilegesCacheResponse.Node.class);\n+        this.privilegesStore = privilegesStore;\n+        this.rolesStore = rolesStore;\n+    }\n+\n+    @Override\n+    protected ClearPrivilegesCacheResponse newResponse(\n+        ClearPrivilegesCacheRequest request, List<ClearPrivilegesCacheResponse.Node> nodes, List<FailedNodeException> failures) {\n+        return new ClearPrivilegesCacheResponse(clusterService.getClusterName(), nodes, failures);\n+    }\n+\n+    @Override\n+    protected ClearPrivilegesCacheRequest.Node newNodeRequest(ClearPrivilegesCacheRequest request) {\n+        return new ClearPrivilegesCacheRequest.Node(request);\n+    }\n+\n+    @Override\n+    protected ClearPrivilegesCacheResponse.Node newNodeResponse(StreamInput in) throws IOException {\n+        return new ClearPrivilegesCacheResponse.Node(in);\n+    }\n+\n+    @Override\n+    protected ClearPrivilegesCacheResponse.Node nodeOperation(ClearPrivilegesCacheRequest.Node request, Task task) {\n+        if (request.getApplicationNames() == null || request.getApplicationNames().length == 0) {\n+            privilegesStore.invalidateAll();\n+        } else {\n+            privilegesStore.invalidate(Arrays.asList(request.getApplicationNames()));\n+        }\n+        rolesStore.invalidateAll();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c58309b87b38718e10825eb15b9344ae9b38912"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA5MDMyNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        privilegesStore.invalidate(Arrays.asList(request.getApplicationNames()));\n          \n          \n            \n                        privilegesStore.invalidate(List.of(request.getApplicationNames()));", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r417090324", "createdAt": "2020-04-29T06:23:32Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/action/privilege/TransportClearPrivilegesCacheAction.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.action.privilege;\n+\n+import org.elasticsearch.action.FailedNodeException;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.nodes.TransportNodesAction;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.core.security.action.privilege.ClearPrivilegesCacheAction;\n+import org.elasticsearch.xpack.core.security.action.privilege.ClearPrivilegesCacheRequest;\n+import org.elasticsearch.xpack.core.security.action.privilege.ClearPrivilegesCacheResponse;\n+import org.elasticsearch.xpack.security.authz.store.CompositeRolesStore;\n+import org.elasticsearch.xpack.security.authz.store.NativePrivilegeStore;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+public class TransportClearPrivilegesCacheAction extends TransportNodesAction<ClearPrivilegesCacheRequest, ClearPrivilegesCacheResponse,\n+    ClearPrivilegesCacheRequest.Node, ClearPrivilegesCacheResponse.Node> {\n+\n+    private final NativePrivilegeStore privilegesStore;\n+    private final CompositeRolesStore rolesStore;\n+\n+    @Inject\n+    public TransportClearPrivilegesCacheAction(\n+        ThreadPool threadPool,\n+        ClusterService clusterService,\n+        TransportService transportService,\n+        ActionFilters actionFilters,\n+        NativePrivilegeStore privilegesStore,\n+        CompositeRolesStore rolesStore) {\n+        super(\n+            ClearPrivilegesCacheAction.NAME,\n+            threadPool,\n+            clusterService,\n+            transportService,\n+            actionFilters,\n+            ClearPrivilegesCacheRequest::new,\n+            ClearPrivilegesCacheRequest.Node::new,\n+            ThreadPool.Names.MANAGEMENT,\n+            ClearPrivilegesCacheResponse.Node.class);\n+        this.privilegesStore = privilegesStore;\n+        this.rolesStore = rolesStore;\n+    }\n+\n+    @Override\n+    protected ClearPrivilegesCacheResponse newResponse(\n+        ClearPrivilegesCacheRequest request, List<ClearPrivilegesCacheResponse.Node> nodes, List<FailedNodeException> failures) {\n+        return new ClearPrivilegesCacheResponse(clusterService.getClusterName(), nodes, failures);\n+    }\n+\n+    @Override\n+    protected ClearPrivilegesCacheRequest.Node newNodeRequest(ClearPrivilegesCacheRequest request) {\n+        return new ClearPrivilegesCacheRequest.Node(request);\n+    }\n+\n+    @Override\n+    protected ClearPrivilegesCacheResponse.Node newNodeResponse(StreamInput in) throws IOException {\n+        return new ClearPrivilegesCacheResponse.Node(in);\n+    }\n+\n+    @Override\n+    protected ClearPrivilegesCacheResponse.Node nodeOperation(ClearPrivilegesCacheRequest.Node request, Task task) {\n+        if (request.getApplicationNames() == null || request.getApplicationNames().length == 0) {\n+            privilegesStore.invalidateAll();\n+        } else {\n+            privilegesStore.invalidate(Arrays.asList(request.getApplicationNames()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c58309b87b38718e10825eb15b9344ae9b38912"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA5MTE5Mg==", "bodyText": "Separate to this PR, it feels like we could consolidate these duplicate classes into a common base class.", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r417091192", "createdAt": "2020-04-29T06:26:12Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/action/privilege/ClearPrivilegesCacheResponse.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.action.privilege;\n+\n+import org.elasticsearch.action.FailedNodeException;\n+import org.elasticsearch.action.support.nodes.BaseNodeResponse;\n+import org.elasticsearch.action.support.nodes.BaseNodesResponse;\n+import org.elasticsearch.cluster.ClusterName;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ToXContentFragment;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+\n+import java.io.IOException;\n+import java.util.List;\n+\n+public class ClearPrivilegesCacheResponse extends BaseNodesResponse<ClearPrivilegesCacheResponse.Node>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c58309b87b38718e10825eb15b9344ae9b38912"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA5MTY0OQ==", "bodyText": "Where do we call this? I think we should avoid having this method if we can.", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r417091649", "createdAt": "2020-04-29T06:27:35Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/support/CacheIteratorHelper.java", "diffHunk": "@@ -56,4 +56,17 @@ public void removeKeysIf(Predicate<K> removeIf) {\n             }\n         }\n     }\n+\n+    public void removeValuesIf(Predicate<V> removeIf) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c58309b87b38718e10825eb15b9344ae9b38912"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9100c24ceca158023ef2059ef0a16fea9c57f91c", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/9100c24ceca158023ef2059ef0a16fea9c57f91c", "committedDate": "2020-04-30T02:39:32Z", "message": "WIP"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3f9c5b7688845a6b301d683967d3d77207da35cb", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/3f9c5b7688845a6b301d683967d3d77207da35cb", "committedDate": "2020-04-30T06:24:10Z", "message": "Update x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/NativePrivilegeStore.java\n\nCo-Authored-By: Tim Vernum <tim@adjective.org>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "08865ddb8c0773b5bc38caef85a2a8ecf9b38b7f", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/08865ddb8c0773b5bc38caef85a2a8ecf9b38b7f", "committedDate": "2020-04-30T06:25:00Z", "message": "Merge branch 'es-54317-app-privilege-cache' of github.com:ywangd/elasticsearch into es-54317-app-privilege-cache"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b9538a8692484fe98164a5ee465ffa99076a5ecd", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/b9538a8692484fe98164a5ee465ffa99076a5ecd", "committedDate": "2020-04-30T06:32:18Z", "message": "Update x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/action/privilege/TransportClearPrivilegesCacheAction.java\n\nCo-Authored-By: Tim Vernum <tim@adjective.org>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9c5e94761e40d1847576f0c99cf1b10b8604513b", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/9c5e94761e40d1847576f0c99cf1b10b8604513b", "committedDate": "2020-04-30T06:34:40Z", "message": "Merge branch 'es-54317-app-privilege-cache' of github.com:ywangd/elasticsearch into es-54317-app-privilege-cache"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f5b166c9d734f2d62fa0a485a776d9bdc742d0bb", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/f5b166c9d734f2d62fa0a485a776d9bdc742d0bb", "committedDate": "2020-04-30T06:40:25Z", "message": "WIP"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1e7ce7c2c3f46c4be7849187acff2912184850e0", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/1e7ce7c2c3f46c4be7849187acff2912184850e0", "committedDate": "2020-04-30T12:13:22Z", "message": "Merge remote-tracking branch 'origin/master' into es-54317-app-privilege-cache"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f1f3e728644dc5e07eaccbef2f341fb6d368bb7d", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/f1f3e728644dc5e07eaccbef2f341fb6d368bb7d", "committedDate": "2020-04-30T12:26:16Z", "message": "Address feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a7b5b409e6e9fb4a4a88a4ebbbb1d6f1f49a877a", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/a7b5b409e6e9fb4a4a88a4ebbbb1d6f1f49a877a", "committedDate": "2020-04-30T12:36:57Z", "message": "Checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5306bc13d3f368cf7ed26a4c4a12b3bac09a9eab", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/5306bc13d3f368cf7ed26a4c4a12b3bac09a9eab", "committedDate": "2020-05-04T03:27:17Z", "message": "Address feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "03680bc9891557553be743288523860c71fa26be", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/03680bc9891557553be743288523860c71fa26be", "committedDate": "2020-05-04T04:26:45Z", "message": "Skip yaml tests for 7.x"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cdfe886b0920685089581ed4d7c391a261355d1f", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/cdfe886b0920685089581ed4d7c391a261355d1f", "committedDate": "2020-05-04T04:27:16Z", "message": "Merge remote-tracking branch 'origin/master' into es-54317-app-privilege-cache"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "435993df091f77e2f25a5460d7854003a482a5aa", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/435993df091f77e2f25a5460d7854003a482a5aa", "committedDate": "2020-05-04T04:47:09Z", "message": "Fix yaml tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "20be80d5e9ecc72936533b6797a79406ba415213", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/20be80d5e9ecc72936533b6797a79406ba415213", "committedDate": "2020-05-04T05:28:02Z", "message": "Add HLRC relevant files"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d2f2f3eeeb122b29b4d12defd8f9f4f0e5500b57", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/d2f2f3eeeb122b29b4d12defd8f9f4f0e5500b57", "committedDate": "2020-05-04T05:38:39Z", "message": "check style"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f1f7035fb45ceeefeda9d006ca7ae96ae7549d50", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/f1f7035fb45ceeefeda9d006ca7ae96ae7549d50", "committedDate": "2020-05-04T06:32:53Z", "message": "Fix broken docs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "db6020eef6900835ea5ed094f76967db28b8302e", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/db6020eef6900835ea5ed094f76967db28b8302e", "committedDate": "2020-05-04T23:11:47Z", "message": "Add bwc for the new transport action"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1NDEwNjY2", "url": "https://github.com/elastic/elasticsearch/pull/55836#pullrequestreview-405410666", "createdAt": "2020-05-04T23:16:18Z", "commit": {"oid": "db6020eef6900835ea5ed094f76967db28b8302e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQyMzoxNjoxOFrOGQVhwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQyMzoxNjoxOFrOGQVhwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc4MzEwNg==", "bodyText": "Added BWC handling.", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r419783106", "createdAt": "2020-05-04T23:16:18Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/action/privilege/TransportClearPrivilegesCacheAction.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.action.privilege;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.FailedNodeException;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.nodes.TransportNodesAction;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.core.security.action.privilege.ClearPrivilegesCacheAction;\n+import org.elasticsearch.xpack.core.security.action.privilege.ClearPrivilegesCacheRequest;\n+import org.elasticsearch.xpack.core.security.action.privilege.ClearPrivilegesCacheResponse;\n+import org.elasticsearch.xpack.security.authz.store.CompositeRolesStore;\n+import org.elasticsearch.xpack.security.authz.store.NativePrivilegeStore;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+public class TransportClearPrivilegesCacheAction extends TransportNodesAction<ClearPrivilegesCacheRequest, ClearPrivilegesCacheResponse,\n+    ClearPrivilegesCacheRequest.Node, ClearPrivilegesCacheResponse.Node> {\n+\n+    private final NativePrivilegeStore privilegesStore;\n+    private final CompositeRolesStore rolesStore;\n+\n+    @Inject\n+    public TransportClearPrivilegesCacheAction(\n+        ThreadPool threadPool,\n+        ClusterService clusterService,\n+        TransportService transportService,\n+        ActionFilters actionFilters,\n+        NativePrivilegeStore privilegesStore,\n+        CompositeRolesStore rolesStore) {\n+        super(\n+            ClearPrivilegesCacheAction.NAME,\n+            threadPool,\n+            clusterService,\n+            transportService,\n+            actionFilters,\n+            ClearPrivilegesCacheRequest::new,\n+            ClearPrivilegesCacheRequest.Node::new,\n+            ThreadPool.Names.MANAGEMENT,\n+            ClearPrivilegesCacheResponse.Node.class);\n+        this.privilegesStore = privilegesStore;\n+        this.rolesStore = rolesStore;\n+    }\n+\n+    @Override\n+    protected ClearPrivilegesCacheResponse newResponse(\n+        ClearPrivilegesCacheRequest request, List<ClearPrivilegesCacheResponse.Node> nodes, List<FailedNodeException> failures) {\n+        return new ClearPrivilegesCacheResponse(clusterService.getClusterName(), nodes, failures);\n+    }\n+\n+    @Override\n+    protected ClearPrivilegesCacheRequest.Node newNodeRequest(ClearPrivilegesCacheRequest request) {\n+        return new ClearPrivilegesCacheRequest.Node(request);\n+    }\n+\n+    @Override\n+    protected ClearPrivilegesCacheResponse.Node newNodeResponse(StreamInput in) throws IOException {\n+        return new ClearPrivilegesCacheResponse.Node(in);\n+    }\n+\n+    @Override\n+    protected ClearPrivilegesCacheResponse.Node nodeOperation(ClearPrivilegesCacheRequest.Node request, Task task) {\n+        if (request.getApplicationNames() == null || request.getApplicationNames().length == 0) {\n+            privilegesStore.invalidateAll();\n+        } else {\n+            privilegesStore.invalidate(List.of(request.getApplicationNames()));\n+        }\n+        if (request.isClearRolesCache()) {\n+            rolesStore.invalidateAll();\n+        }\n+        return new ClearPrivilegesCacheResponse.Node(clusterService.localNode());\n+    }\n+\n+    @Override\n+    protected void resolveRequest(ClearPrivilegesCacheRequest request, ClusterState clusterState) {\n+        assert request.concreteNodes() == null : \"request concreteNodes shouldn't be set\";\n+        String[] nodesIds = clusterState.nodes().resolveNodes(request.nodesIds());\n+        // TODO: version needs to be updated once 7.x backport is in place\n+        request.setConcreteNodes(Arrays.stream(nodesIds).map(clusterState.nodes()::get)\n+            .filter(node -> node.getVersion().onOrAfter(Version.V_8_0_0)).toArray(DiscoveryNode[]::new));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db6020eef6900835ea5ed094f76967db28b8302e"}, "originalPosition": 94}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1NDI2NDY4", "url": "https://github.com/elastic/elasticsearch/pull/55836#pullrequestreview-405426468", "createdAt": "2020-05-05T00:04:35Z", "commit": {"oid": "db6020eef6900835ea5ed094f76967db28b8302e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwMDowNDozNVrOGQWamw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwMDowNDozNVrOGQWamw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc5NzY1OQ==", "bodyText": "Do we need a ReplacedRoute here similar to the one in clear role cache action? i.e.:\n\n  \n    \n      elasticsearch/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/rest/action/role/RestClearRolesCacheAction.java\n    \n    \n        Lines 36 to 37\n      in\n      022d3d7\n    \n    \n    \n    \n\n        \n          \n           return Collections.singletonList(new ReplacedRoute(POST, \"/_security/role/{name}/_clear_cache\", POST, \n        \n\n        \n          \n               \"/_xpack/security/role/{name}/_clear_cache\")); \n        \n    \n  \n\n\nMy understanding is that the ReplacedRoute was needed because of xpack migration into main repo and is not necessary for new APIs. So I didn't add it here.", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r419797659", "createdAt": "2020-05-05T00:04:35Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/rest/action/privilege/RestClearPrivilegesAction.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.rest.action.privilege;\n+\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.license.XPackLicenseState;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.action.RestActions.NodesResponseRestListener;\n+import org.elasticsearch.xpack.core.security.action.privilege.ClearPrivilegesCacheAction;\n+import org.elasticsearch.xpack.core.security.action.privilege.ClearPrivilegesCacheRequest;\n+import org.elasticsearch.xpack.security.rest.action.SecurityBaseRestHandler;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.elasticsearch.rest.RestRequest.Method.POST;\n+\n+public class RestClearPrivilegesAction extends SecurityBaseRestHandler {\n+\n+    public RestClearPrivilegesAction(Settings settings, XPackLicenseState licenseState) {\n+        super(settings, licenseState);\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"security_clear_privileges_cache_action\";\n+    }\n+\n+    @Override\n+    public List<Route> routes() {\n+        return Collections.singletonList(new Route(POST, \"/_security/privilege/{application}/_clear_cache\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db6020eef6900835ea5ed094f76967db28b8302e"}, "originalPosition": 37}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "73dda1fecc2d32e45faf34b6aefafd866e65fdc3", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/73dda1fecc2d32e45faf34b6aefafd866e65fdc3", "committedDate": "2020-05-05T02:06:17Z", "message": "Add working rolling upgrade mixed-cluster tests for privilege cache clearing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ea9172f4cef32ddc4829cdf2bd44d197748618f8", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/ea9172f4cef32ddc4829cdf2bd44d197748618f8", "committedDate": "2020-05-05T02:06:35Z", "message": "Merge remote-tracking branch 'origin/master' into es-54317-app-privilege-cache"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "65f9524627fcaaadd7ec6350a36fbf20738980d5", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/65f9524627fcaaadd7ec6350a36fbf20738980d5", "committedDate": "2020-05-05T03:56:23Z", "message": "Remove bwc handling code and simply report no handler"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "04bb476648b14a9390e392d367d5f33d59e9e49c", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/04bb476648b14a9390e392d367d5f33d59e9e49c", "committedDate": "2020-05-05T04:02:07Z", "message": "Checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "07b7837c4284d40541d51eba66d431dc9680d80c", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/07b7837c4284d40541d51eba66d431dc9680d80c", "committedDate": "2020-05-15T01:12:05Z", "message": "Clear privilege cache on security index changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "34464d73dbe7fabc0e1ac39ea8877666740f1b22", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/34464d73dbe7fabc0e1ac39ea8877666740f1b22", "committedDate": "2020-05-15T01:12:27Z", "message": "Merge remote-tracking branch 'origin/master' into es-54317-app-privilege-cache"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5ODA5ODQ3", "url": "https://github.com/elastic/elasticsearch/pull/55836#pullrequestreview-419809847", "createdAt": "2020-05-28T06:27:09Z", "commit": {"oid": "34464d73dbe7fabc0e1ac39ea8877666740f1b22"}, "state": "COMMENTED", "comments": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQwNjoyNzoxMFrOGbnP9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNDoyMzo0M1rOGb3haA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYwNzc5OA==", "bodyText": "Should the docs have a callout <1> for the application name?", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r431607798", "createdAt": "2020-05-28T06:27:10Z", "author": {"login": "tvernum"}, "path": "client/rest-high-level/src/test/java/org/elasticsearch/client/documentation/SecurityDocumentationIT.java", "diffHunk": "@@ -1003,6 +1005,52 @@ public void onFailure(Exception e) {\n         }\n     }\n \n+    public void testClearPrivilegesCache() throws Exception {\n+        RestHighLevelClient client = highLevelClient();\n+        {\n+            //tag::clear-privileges-cache-request\n+            ClearPrivilegesCacheRequest request = new ClearPrivilegesCacheRequest(\"my_app\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34464d73dbe7fabc0e1ac39ea8877666740f1b22"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYwODQwMg==", "bodyText": "Per my comment above, maybe\n<1> The name of the application(s) for which the cache should be cleared", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r431608402", "createdAt": "2020-05-28T06:28:41Z", "author": {"login": "tvernum"}, "path": "docs/java-rest/high-level/security/clear-privileges-cache.asciidoc", "diffHunk": "@@ -0,0 +1,32 @@\n+\n+--\n+:api: clear-privileges-cache\n+:request: ClearPrivilegesCacheRequest\n+:response: ClearPrivilegesCacheResponse\n+--\n+[role=\"xpack\"]\n+[id=\"{upid}-{api}\"]\n+=== Clear Privileges Cache API\n+\n+[id=\"{upid}-{api}-request\"]\n+==== Clear Privileges Cache Request\n+\n+A +{request}+ supports defining the name of applications that the cache should be cleared for.\n+\n+[\"source\",\"java\",subs=\"attributes,callouts,macros\"]\n+--------------------------------------------------\n+include-tagged::{doc-tests-file}[{api}-request]\n+--------------------------------------------------\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34464d73dbe7fabc0e1ac39ea8877666740f1b22"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYwOTU5MQ==", "bodyText": "I know we don't do this in the other clear cache docs (but we should strive to improve) however I think it's worth stating that the cache is automatically cleared when a privilege is modified.\nI mention it because kibana_system  has permission to update privileges, but not clear the cache. This could seem like a problem, but it is actually fine, because we'll do it automatically.", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r431609591", "createdAt": "2020-05-28T06:31:47Z", "author": {"login": "tvernum"}, "path": "x-pack/docs/en/rest-api/security/clear-privileges-cache.asciidoc", "diffHunk": "@@ -0,0 +1,42 @@\n+[role=\"xpack\"]\n+[[security-api-clear-privilege-cache]]\n+=== Clear privileges cache API\n+++++\n+<titleabbrev>Clear privileges cache</titleabbrev>\n+++++\n+\n+Evicts privileges from the native application privilege cache.\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34464d73dbe7fabc0e1ac39ea8877666740f1b22"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYwOTc2Ng==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r431609766", "createdAt": "2020-05-28T06:32:16Z", "author": {"login": "tvernum"}, "path": "x-pack/docs/en/rest-api/security/delete-app-privileges.asciidoc", "diffHunk": "@@ -34,16 +34,16 @@ To use this API, you must have either:\n [[security-api-delete-privilege-example]]\n ==== {api-examples-title}\n \n-The following example deletes the `read` application privilege from the \n+The following example deletes the `read` application privilege from the\n `myapp` application:\n \n [source,console]\n --------------------------------------------------\n DELETE /_security/privilege/myapp/read\n --------------------------------------------------\n-// TEST[setup:app0102_privileges] \n+// TEST[setup:app0102_privileges]\n \n-If the role is successfully deleted, the request returns `{\"found\": true}`.\n+If the privilege is successfully deleted, the request returns `{\"found\": true}`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34464d73dbe7fabc0e1ac39ea8877666740f1b22"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxMDM0Nw==", "bodyText": "I don't like that this method follow bean conventions, but applicationNames doesn't. Can we pick one style?\nSpeaking personally, I think isClearRolesCache reads poorly, and clearRolesCache or shouldClearRolesCache are better.", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r431610347", "createdAt": "2020-05-28T06:33:41Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/action/privilege/ClearPrivilegesCacheRequest.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.action.privilege;\n+\n+import org.elasticsearch.action.support.nodes.BaseNodesRequest;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.transport.TransportRequest;\n+\n+import java.io.IOException;\n+\n+public class ClearPrivilegesCacheRequest extends BaseNodesRequest<ClearPrivilegesCacheRequest> {\n+\n+    private String[] applicationNames;\n+    private boolean clearRolesCache = false;\n+\n+    public ClearPrivilegesCacheRequest() {\n+        super((String[]) null);\n+    }\n+\n+    public ClearPrivilegesCacheRequest(StreamInput in) throws IOException {\n+        super(in);\n+        applicationNames = in.readOptionalStringArray();\n+        clearRolesCache = in.readBoolean();\n+    }\n+\n+    public ClearPrivilegesCacheRequest applicationNames(String... applicationNames) {\n+        this.applicationNames = applicationNames;\n+        return this;\n+    }\n+\n+    public ClearPrivilegesCacheRequest clearRolesCache(boolean clearRolesCache) {\n+        this.clearRolesCache = clearRolesCache;\n+        return this;\n+    }\n+\n+    public String[] applicationNames() {\n+        return applicationNames;\n+    }\n+\n+    public boolean isClearRolesCache() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34464d73dbe7fabc0e1ac39ea8877666740f1b22"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxMDg3OQ==", "bodyText": "Yes. Not a priority, but there's a bunch of copy paste here that we could ditch.", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r431610879", "createdAt": "2020-05-28T06:35:02Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/action/privilege/ClearPrivilegesCacheResponse.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.action.privilege;\n+\n+import org.elasticsearch.action.FailedNodeException;\n+import org.elasticsearch.action.support.nodes.BaseNodeResponse;\n+import org.elasticsearch.action.support.nodes.BaseNodesResponse;\n+import org.elasticsearch.cluster.ClusterName;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ToXContentFragment;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+\n+import java.io.IOException;\n+import java.util.List;\n+\n+public class ClearPrivilegesCacheResponse extends BaseNodesResponse<ClearPrivilegesCacheResponse.Node>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA5MTE5Mg=="}, "originalCommit": {"oid": "1c58309b87b38718e10825eb15b9344ae9b38912"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY0NTA0Nw==", "bodyText": "I don't follow this comment.", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r431645047", "createdAt": "2020-05-28T07:48:12Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/CompositeRolesStore.java", "diffHunk": "@@ -410,6 +410,7 @@ public static void buildRoleFromDescriptors(Collection<RoleDescriptor> roleDescr\n             final Set<String> applicationPrivilegeNames = applicationPrivilegesMap.values().stream()\n                     .flatMap(Collection::stream)\n                     .collect(Collectors.toSet());\n+            // Role itself is cached, so skipping caching for application privileges", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34464d73dbe7fabc0e1ac39ea8877666740f1b22"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY0NjM2Nw==", "bodyText": "This should be list I think. See #53207", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r431646367", "createdAt": "2020-05-28T07:50:37Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/src/test/resources/rest-api-spec/api/security.clear_cached_privileges.json", "diffHunk": "@@ -0,0 +1,26 @@\n+{\n+  \"security.clear_cached_privileges\":{\n+    \"documentation\":{\n+      \"url\":\"https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-clear-privilege-cache.html\",\n+      \"description\":\"Evicts application privileges from the native application privileges cache.\"\n+    },\n+    \"stability\":\"stable\",\n+    \"url\":{\n+      \"paths\":[\n+        {\n+          \"path\":\"/_security/privilege/{application}/_clear_cache\",\n+          \"methods\":[\n+            \"POST\"\n+          ],\n+          \"parts\":{\n+            \"application\":{\n+              \"type\":\"string\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34464d73dbe7fabc0e1ac39ea8877666740f1b22"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY4NjU1OQ==", "bodyText": "Why is this a LinkedHashSet? I don't understand why the original order would matter for the cache key.", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r431686559", "createdAt": "2020-05-28T08:59:47Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/NativePrivilegeStore.java", "diffHunk": "@@ -83,47 +97,95 @@\n     private final Settings settings;\n     private final Client client;\n     private final SecurityIndexManager securityIndexManager;\n+    private final Cache<String, Set<ApplicationPrivilegeDescriptor>> descriptorsCache;\n+    private final Cache<Set<String>, Set<String>> applicationNamesCache;\n+    private final AtomicLong numInvalidation = new AtomicLong();\n \n     public NativePrivilegeStore(Settings settings, Client client, SecurityIndexManager securityIndexManager) {\n         this.settings = settings;\n         this.client = client;\n         this.securityIndexManager = securityIndexManager;\n+        CacheBuilder<String, Set<ApplicationPrivilegeDescriptor>> builder = CacheBuilder.builder();\n+        final int cacheSize = DESCRIPTOR_CACHE_SIZE_SETTING.get(settings);\n+        if (cacheSize >= 0) {\n+            builder.setMaximumWeight(cacheSize);\n+            builder.weigher((k, v) -> v.size());\n+        }\n+        descriptorsCache = builder.build();\n+\n+        CacheBuilder<Set<String>, Set<String>> applicationNamesCacheBuilder = CacheBuilder.builder();\n+        final int nameCacheSize = APPLICATION_NAME_CACHE_SIZE_SETTING.get(settings);\n+        if (nameCacheSize >= 0) {\n+            applicationNamesCacheBuilder.setMaximumWeight(nameCacheSize);\n+            applicationNamesCacheBuilder.weigher((k, v) -> k.size() + v.size());\n+        }\n+        applicationNamesCache = applicationNamesCacheBuilder.build();\n     }\n \n     public void getPrivileges(Collection<String> applications, Collection<String> names,\n                               ActionListener<Collection<ApplicationPrivilegeDescriptor>> listener) {\n+\n+        // TODO: We should have a way to express true Zero applications\n+        final Set<String> applicationNamesCacheKey = (isEmpty(applications) || applications.contains(\"*\")) ?\n+            Set.of(\"*\") : new LinkedHashSet<>(applications);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34464d73dbe7fabc0e1ac39ea8877666740f1b22"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTgxOTYzNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.debug(\"returning empty application privileges as application names result in empty list\");\n          \n          \n            \n                        logger.debug(\"returning empty application privileges for [{}] as application names result in empty list\",\n          \n          \n            \n                            applicationNamesCacheKey);", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r431819634", "createdAt": "2020-05-28T13:06:43Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/NativePrivilegeStore.java", "diffHunk": "@@ -83,47 +97,95 @@\n     private final Settings settings;\n     private final Client client;\n     private final SecurityIndexManager securityIndexManager;\n+    private final Cache<String, Set<ApplicationPrivilegeDescriptor>> descriptorsCache;\n+    private final Cache<Set<String>, Set<String>> applicationNamesCache;\n+    private final AtomicLong numInvalidation = new AtomicLong();\n \n     public NativePrivilegeStore(Settings settings, Client client, SecurityIndexManager securityIndexManager) {\n         this.settings = settings;\n         this.client = client;\n         this.securityIndexManager = securityIndexManager;\n+        CacheBuilder<String, Set<ApplicationPrivilegeDescriptor>> builder = CacheBuilder.builder();\n+        final int cacheSize = DESCRIPTOR_CACHE_SIZE_SETTING.get(settings);\n+        if (cacheSize >= 0) {\n+            builder.setMaximumWeight(cacheSize);\n+            builder.weigher((k, v) -> v.size());\n+        }\n+        descriptorsCache = builder.build();\n+\n+        CacheBuilder<Set<String>, Set<String>> applicationNamesCacheBuilder = CacheBuilder.builder();\n+        final int nameCacheSize = APPLICATION_NAME_CACHE_SIZE_SETTING.get(settings);\n+        if (nameCacheSize >= 0) {\n+            applicationNamesCacheBuilder.setMaximumWeight(nameCacheSize);\n+            applicationNamesCacheBuilder.weigher((k, v) -> k.size() + v.size());\n+        }\n+        applicationNamesCache = applicationNamesCacheBuilder.build();\n     }\n \n     public void getPrivileges(Collection<String> applications, Collection<String> names,\n                               ActionListener<Collection<ApplicationPrivilegeDescriptor>> listener) {\n+\n+        // TODO: We should have a way to express true Zero applications\n+        final Set<String> applicationNamesCacheKey = (isEmpty(applications) || applications.contains(\"*\")) ?\n+            Set.of(\"*\") : new LinkedHashSet<>(applications);\n+\n+        // Always fetch for the concrete application names even when the passed-in application names has no wildcard.\n+        // This serves as a negative lookup, i.e. when a passed-in non-wildcard application does not exist.\n+        Set<String> concreteApplicationNames = applicationNamesCache.get(applicationNamesCacheKey);\n+\n+        if (concreteApplicationNames != null && concreteApplicationNames.size() == 0) {\n+            logger.debug(\"returning empty application privileges as application names result in empty list\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34464d73dbe7fabc0e1ac39ea8877666740f1b22"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTgxOTk0MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.debug(\"All application privileges found in cache\");\n          \n          \n            \n                            logger.debug(\"All application privileges for [{}] found in cache\", applicationNamesCacheKey);", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r431819941", "createdAt": "2020-05-28T13:07:12Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/NativePrivilegeStore.java", "diffHunk": "@@ -83,47 +97,95 @@\n     private final Settings settings;\n     private final Client client;\n     private final SecurityIndexManager securityIndexManager;\n+    private final Cache<String, Set<ApplicationPrivilegeDescriptor>> descriptorsCache;\n+    private final Cache<Set<String>, Set<String>> applicationNamesCache;\n+    private final AtomicLong numInvalidation = new AtomicLong();\n \n     public NativePrivilegeStore(Settings settings, Client client, SecurityIndexManager securityIndexManager) {\n         this.settings = settings;\n         this.client = client;\n         this.securityIndexManager = securityIndexManager;\n+        CacheBuilder<String, Set<ApplicationPrivilegeDescriptor>> builder = CacheBuilder.builder();\n+        final int cacheSize = DESCRIPTOR_CACHE_SIZE_SETTING.get(settings);\n+        if (cacheSize >= 0) {\n+            builder.setMaximumWeight(cacheSize);\n+            builder.weigher((k, v) -> v.size());\n+        }\n+        descriptorsCache = builder.build();\n+\n+        CacheBuilder<Set<String>, Set<String>> applicationNamesCacheBuilder = CacheBuilder.builder();\n+        final int nameCacheSize = APPLICATION_NAME_CACHE_SIZE_SETTING.get(settings);\n+        if (nameCacheSize >= 0) {\n+            applicationNamesCacheBuilder.setMaximumWeight(nameCacheSize);\n+            applicationNamesCacheBuilder.weigher((k, v) -> k.size() + v.size());\n+        }\n+        applicationNamesCache = applicationNamesCacheBuilder.build();\n     }\n \n     public void getPrivileges(Collection<String> applications, Collection<String> names,\n                               ActionListener<Collection<ApplicationPrivilegeDescriptor>> listener) {\n+\n+        // TODO: We should have a way to express true Zero applications\n+        final Set<String> applicationNamesCacheKey = (isEmpty(applications) || applications.contains(\"*\")) ?\n+            Set.of(\"*\") : new LinkedHashSet<>(applications);\n+\n+        // Always fetch for the concrete application names even when the passed-in application names has no wildcard.\n+        // This serves as a negative lookup, i.e. when a passed-in non-wildcard application does not exist.\n+        Set<String> concreteApplicationNames = applicationNamesCache.get(applicationNamesCacheKey);\n+\n+        if (concreteApplicationNames != null && concreteApplicationNames.size() == 0) {\n+            logger.debug(\"returning empty application privileges as application names result in empty list\");\n+            listener.onResponse(Collections.emptySet());\n+        } else {\n+            final Set<ApplicationPrivilegeDescriptor> cachedDescriptors = cachedDescriptorsForApplicationNames(\n+                concreteApplicationNames != null ? concreteApplicationNames : applicationNamesCacheKey);\n+            if (cachedDescriptors != null) {\n+                logger.debug(\"All application privileges found in cache\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34464d73dbe7fabc0e1ac39ea8877666740f1b22"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg2NDQ2Mg==", "bodyText": "I think a ReadWriteLock would solve the problem. Treat the invalidator as the writer and the cache population as the reader. The invalidator would need exclusive access, but we could support multiple populators.\nI'll need to think about it again when it's not midnight, but I think it's reasonable (if used alongside the invalidationCounter so the lock window is small).", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r431864462", "createdAt": "2020-05-28T14:09:57Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/NativePrivilegeStore.java", "diffHunk": "@@ -83,47 +100,120 @@\n     private final Settings settings;\n     private final Client client;\n     private final SecurityIndexManager securityIndexManager;\n+    private final Cache<String, Set<ApplicationPrivilegeDescriptor>> descriptorsCache;\n+    private final CacheIteratorHelper<String, Set<ApplicationPrivilegeDescriptor>> descriptorsCacheHelper;\n+    private final Cache<Set<String>, Set<String>> applicationNamesCache;\n+    private final CacheIteratorHelper<Set<String>, Set<String>> applicationNamesCacheHelper;\n+    private final AtomicLong numInvalidation = new AtomicLong();\n \n     public NativePrivilegeStore(Settings settings, Client client, SecurityIndexManager securityIndexManager) {\n         this.settings = settings;\n         this.client = client;\n         this.securityIndexManager = securityIndexManager;\n+        CacheBuilder<String, Set<ApplicationPrivilegeDescriptor>> builder = CacheBuilder.builder();\n+        final int cacheSize = DESCRIPTOR_CACHE_SIZE_SETTING.get(settings);\n+        if (cacheSize >= 0) {\n+            builder.setMaximumWeight(cacheSize);\n+            builder.weigher((k, v) -> v.size());\n+        }\n+        descriptorsCache = builder.build();\n+        descriptorsCacheHelper = new CacheIteratorHelper<>(descriptorsCache);\n+\n+        CacheBuilder<Set<String>, Set<String>> applicationNamesCacheBuilder = CacheBuilder.builder();\n+        final int nameCacheSize = APPLICATION_NAME_CACHE_SIZE_SETTING.get(settings);\n+        if (nameCacheSize >= 0) {\n+            applicationNamesCacheBuilder.setMaximumWeight(nameCacheSize);\n+            applicationNamesCacheBuilder.weigher((k, v) -> k.size() + v.size());\n+        }\n+        applicationNamesCache = applicationNamesCacheBuilder.build();\n+        applicationNamesCacheHelper = new CacheIteratorHelper<>(applicationNamesCache);\n     }\n \n     public void getPrivileges(Collection<String> applications, Collection<String> names,\n                               ActionListener<Collection<ApplicationPrivilegeDescriptor>> listener) {\n+\n+        // TODO: We should have a way to express true Zero applications\n+        final Set<String> applicationNamesCacheKey = (isEmpty(applications) || applications.contains(\"*\")) ?\n+            Collections.singleton(\"*\") : Set.copyOf(applications);\n+\n+        // Always fetch for the concrete application names even when the passed in application names do not\n+        // contain any wildcard. This serves as a negative lookup.\n+        Set<String> concreteApplicationNames = applicationNamesCache.get(applicationNamesCacheKey);\n+\n+        if (concreteApplicationNames != null && concreteApplicationNames.size() == 0) {\n+            logger.debug(\"returning empty application privileges as application names result in empty list\");\n+            listener.onResponse(Collections.emptySet());\n+\n+        } else {\n+            final Tuple<Set<String>, Map<String, Set<ApplicationPrivilegeDescriptor>>> cacheStatus;\n+            if (concreteApplicationNames == null) {\n+                cacheStatus = cacheStatusForApplicationNames(applicationNamesCacheKey);\n+            } else {\n+                cacheStatus = cacheStatusForApplicationNames(concreteApplicationNames);\n+            }\n+\n+            if (cacheStatus.v1().isEmpty()) {\n+                logger.debug(\"All application privileges found in cache\");\n+                final Set<ApplicationPrivilegeDescriptor> cachedDescriptors =\n+                    cacheStatus.v2().values().stream().flatMap(Collection::stream).collect(Collectors.toUnmodifiableSet());\n+                listener.onResponse(filterDescriptorsForNames(cachedDescriptors, names));\n+            } else {\n+                final long invalidationCounter = numInvalidation.get();\n+                // Always fetch all privileges of an application for caching purpose\n+                logger.debug(\"Fetching application privilege documents for: {}\", cacheStatus.v1());\n+                innerGetPrivileges(cacheStatus.v1(), ActionListener.wrap(fetchedDescriptors -> {\n+                    final Map<String, Set<ApplicationPrivilegeDescriptor>> mapOfFetchedDescriptors = fetchedDescriptors.stream()\n+                        .collect(Collectors.groupingBy(ApplicationPrivilegeDescriptor::getApplication, Collectors.toUnmodifiableSet()));\n+                    final Set<String> allApplicationNames =\n+                        Stream.concat(cacheStatus.v2().keySet().stream(), mapOfFetchedDescriptors.keySet().stream())\n+                            .collect(Collectors.toUnmodifiableSet());\n+                    // Avoid caching potential stale results.\n+                    // TODO: It is still possible that cache gets invalidated immediately after the if check\n+                    if (invalidationCounter == numInvalidation.get()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjI5ODM0Mw=="}, "originalCommit": {"oid": "05061f972d863e577d838ac9ee721b9e23b4f68a"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg2NjAyMQ==", "bodyText": "That's a weird mix of assert and require.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    assert Objects.requireNonNull(applications).isEmpty() == false;\n          \n          \n            \n                    assert applications != null && applications.size() > 0 : \"Application names are required (found \" + applications + \")\";", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r431866021", "createdAt": "2020-05-28T14:12:14Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/NativePrivilegeStore.java", "diffHunk": "@@ -83,47 +97,95 @@\n     private final Settings settings;\n     private final Client client;\n     private final SecurityIndexManager securityIndexManager;\n+    private final Cache<String, Set<ApplicationPrivilegeDescriptor>> descriptorsCache;\n+    private final Cache<Set<String>, Set<String>> applicationNamesCache;\n+    private final AtomicLong numInvalidation = new AtomicLong();\n \n     public NativePrivilegeStore(Settings settings, Client client, SecurityIndexManager securityIndexManager) {\n         this.settings = settings;\n         this.client = client;\n         this.securityIndexManager = securityIndexManager;\n+        CacheBuilder<String, Set<ApplicationPrivilegeDescriptor>> builder = CacheBuilder.builder();\n+        final int cacheSize = DESCRIPTOR_CACHE_SIZE_SETTING.get(settings);\n+        if (cacheSize >= 0) {\n+            builder.setMaximumWeight(cacheSize);\n+            builder.weigher((k, v) -> v.size());\n+        }\n+        descriptorsCache = builder.build();\n+\n+        CacheBuilder<Set<String>, Set<String>> applicationNamesCacheBuilder = CacheBuilder.builder();\n+        final int nameCacheSize = APPLICATION_NAME_CACHE_SIZE_SETTING.get(settings);\n+        if (nameCacheSize >= 0) {\n+            applicationNamesCacheBuilder.setMaximumWeight(nameCacheSize);\n+            applicationNamesCacheBuilder.weigher((k, v) -> k.size() + v.size());\n+        }\n+        applicationNamesCache = applicationNamesCacheBuilder.build();\n     }\n \n     public void getPrivileges(Collection<String> applications, Collection<String> names,\n                               ActionListener<Collection<ApplicationPrivilegeDescriptor>> listener) {\n+\n+        // TODO: We should have a way to express true Zero applications\n+        final Set<String> applicationNamesCacheKey = (isEmpty(applications) || applications.contains(\"*\")) ?\n+            Set.of(\"*\") : new LinkedHashSet<>(applications);\n+\n+        // Always fetch for the concrete application names even when the passed-in application names has no wildcard.\n+        // This serves as a negative lookup, i.e. when a passed-in non-wildcard application does not exist.\n+        Set<String> concreteApplicationNames = applicationNamesCache.get(applicationNamesCacheKey);\n+\n+        if (concreteApplicationNames != null && concreteApplicationNames.size() == 0) {\n+            logger.debug(\"returning empty application privileges as application names result in empty list\");\n+            listener.onResponse(Collections.emptySet());\n+        } else {\n+            final Set<ApplicationPrivilegeDescriptor> cachedDescriptors = cachedDescriptorsForApplicationNames(\n+                concreteApplicationNames != null ? concreteApplicationNames : applicationNamesCacheKey);\n+            if (cachedDescriptors != null) {\n+                logger.debug(\"All application privileges found in cache\");\n+                listener.onResponse(filterDescriptorsForPrivilegeNames(cachedDescriptors, names));\n+            } else {\n+                final long invalidationCounter = numInvalidation.get();\n+                // Always fetch all privileges of an application for caching purpose\n+                logger.debug(\"Fetching application privilege documents for: {}\", applicationNamesCacheKey);\n+                innerGetPrivileges(applicationNamesCacheKey, ActionListener.wrap(fetchedDescriptors -> {\n+                    final Map<String, Set<ApplicationPrivilegeDescriptor>> mapOfFetchedDescriptors = fetchedDescriptors.stream()\n+                        .collect(Collectors.groupingBy(ApplicationPrivilegeDescriptor::getApplication, Collectors.toUnmodifiableSet()));\n+                    // Avoid caching potential stale results.\n+                    // TODO: It is still possible that cache gets invalidated immediately after the if check\n+                    if (invalidationCounter == numInvalidation.get()) {\n+                        final Set<String> fetchedApplicationNames = Collections.unmodifiableSet(mapOfFetchedDescriptors.keySet());\n+                        // Do not cache the names if expansion has no effect\n+                        if (fetchedApplicationNames.equals(applicationNamesCacheKey) == false) {\n+                            logger.debug(\"Caching application names query: {} = {}\", applicationNamesCacheKey, fetchedApplicationNames);\n+                            applicationNamesCache.put(applicationNamesCacheKey, fetchedApplicationNames);\n+                        }\n+                        for (Map.Entry<String, Set<ApplicationPrivilegeDescriptor>> entry : mapOfFetchedDescriptors.entrySet()) {\n+                            logger.debug(\"Caching descriptors for application: {}\", entry.getKey());\n+                            descriptorsCache.put(entry.getKey(), entry.getValue());\n+                        }\n+                    }\n+                    listener.onResponse(filterDescriptorsForPrivilegeNames(fetchedDescriptors, names));\n+                }, listener::onFailure));\n+            }\n+        }\n+    }\n+\n+    private void innerGetPrivileges(Collection<String> applications,\n+        ActionListener<Collection<ApplicationPrivilegeDescriptor>> listener) {\n+        assert Objects.requireNonNull(applications).isEmpty() == false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34464d73dbe7fabc0e1ac39ea8877666740f1b22"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg2NzIzMA==", "bodyText": "Nit: I think the order of the methods in this file is a bit random.\nThis probably should be after innerGetPrivileges since it's an implementation detail of that method.", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r431867230", "createdAt": "2020-05-28T14:13:55Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/NativePrivilegeStore.java", "diffHunk": "@@ -133,25 +195,75 @@ public void getPrivileges(Collection<String> applications, Collection<String> na\n                         .setFetchSource(true)\n                         .request();\n                     logger.trace(() ->\n-                        new ParameterizedMessage(\"Searching for privileges [{}] with query [{}]\", names, Strings.toString(query)));\n+                        new ParameterizedMessage(\"Searching for [{}] privileges with query [{}]\",\n+                            applications, Strings.toString(query)));\n                     request.indicesOptions().ignoreUnavailable();\n+                    // TODO: not parsing source of cached entries?\n                     ScrollHelper.fetchAllByEntity(client, request, new ContextPreservingActionListener<>(supplier, listener),\n                         hit -> buildPrivilege(hit.getId(), hit.getSourceRef()));\n                 }\n             });\n         }\n     }\n \n-    private boolean isSinglePrivilegeMatch(Collection<String> applications, Collection<String> names) {\n-        return applications != null && applications.size() == 1 && hasWildcard(applications) == false && names != null && names.size() == 1;\n+    public void onSecurityIndexStateChange(SecurityIndexManager.State previousState, SecurityIndexManager.State currentState) {\n+        if (isMoveFromRedToNonRed(previousState, currentState) || isIndexDeleted(previousState, currentState)\n+            || previousState.isIndexUpToDate != currentState.isIndexUpToDate) {\n+            invalidateAll();\n+        }\n     }\n \n-    private boolean hasWildcard(Collection<String> applications) {\n-        return applications.stream().anyMatch(n -> n.endsWith(\"*\"));\n+    public void invalidate(Collection<String> updatedApplicationNames) {\n+        logger.debug(\"Invalidating application privileges caches for: {}\", updatedApplicationNames);\n+        numInvalidation.incrementAndGet();\n+        // Always completely invalidate application names cache due to wildcard\n+        applicationNamesCache.invalidateAll();\n+        final Set<String> uniqueNames = Set.copyOf(updatedApplicationNames);\n+        uniqueNames.forEach(descriptorsCache::invalidate);\n     }\n \n-    private QueryBuilder getPrivilegeNameQuery(Collection<String> names) {\n-        return QueryBuilders.termsQuery(ApplicationPrivilegeDescriptor.Fields.NAME.getPreferredName(), names);\n+    public void invalidateAll() {\n+        logger.debug(\"Invalidating all application privileges caches\");\n+        numInvalidation.incrementAndGet();\n+        applicationNamesCache.invalidateAll();\n+        descriptorsCache.invalidateAll();\n+    }\n+\n+    /**\n+     * Try resolve all privileges for given application names from the cache.\n+     * It returns non-null result only when privileges of ALL applications are\n+     * found in the cache, i.e. it returns null if any of application name is\n+     * NOT found in the cache. Since the cached is keyed by concrete application\n+     * name, this means any wildcard will result in null.\n+     */\n+    private Set<ApplicationPrivilegeDescriptor> cachedDescriptorsForApplicationNames(Set<String> applicationNames) {\n+\n+        final Set<ApplicationPrivilegeDescriptor> cachedDescriptors = new HashSet<>();\n+        for (String applicationName: applicationNames) {\n+            if (applicationName.endsWith(\"*\")) {\n+                return null;\n+            } else {\n+                final Set<ApplicationPrivilegeDescriptor> descriptors = descriptorsCache.get(applicationName);\n+                if (descriptors == null) {\n+                    return null;\n+                } else {\n+                    cachedDescriptors.addAll(descriptors);\n+                }\n+            }\n+        }\n+        return Collections.unmodifiableSet(cachedDescriptors);\n+    }\n+\n+    /**\n+     * Filter to get all privilege descriptors that have any of the given privilege names.\n+     */\n+    private Collection<ApplicationPrivilegeDescriptor> filterDescriptorsForPrivilegeNames(\n+        Collection<ApplicationPrivilegeDescriptor> descriptors, Collection<String> privilegeNames) {\n+        // empty set of names equals to retrieve everything\n+        if (isEmpty(privilegeNames)) {\n+            return descriptors;\n+        }\n+        return descriptors.stream().filter(d -> privilegeNames.contains(d.getName())).collect(Collectors.toUnmodifiableSet());\n     }\n \n     private QueryBuilder getApplicationNameQuery(Collection<String> applications) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34464d73dbe7fabc0e1ac39ea8877666740f1b22"}, "originalPosition": 278}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg2ODcwNA==", "bodyText": "I don't think we need this TODO do we?\nI think in this context it's simpler to parse everything than try and track doc changes (because we trust the cache if it's populated, we only go to the index when the cache is missing something).", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r431868704", "createdAt": "2020-05-28T14:15:59Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/NativePrivilegeStore.java", "diffHunk": "@@ -133,25 +195,75 @@ public void getPrivileges(Collection<String> applications, Collection<String> na\n                         .setFetchSource(true)\n                         .request();\n                     logger.trace(() ->\n-                        new ParameterizedMessage(\"Searching for privileges [{}] with query [{}]\", names, Strings.toString(query)));\n+                        new ParameterizedMessage(\"Searching for [{}] privileges with query [{}]\",\n+                            applications, Strings.toString(query)));\n                     request.indicesOptions().ignoreUnavailable();\n+                    // TODO: not parsing source of cached entries?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34464d73dbe7fabc0e1ac39ea8877666740f1b22"}, "originalPosition": 204}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg3NDQwOA==", "bodyText": "Remind me, what's Kibana's typical usage pattern for querying? Does it use wildcards for the application name?\nIf so, I think invalidating the name cache means that invalidating for a single application (which might not even exist) would effectively invalidate the whole cache because it would mean that querying for kibana* would end up not using any cache at all.", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r431874408", "createdAt": "2020-05-28T14:23:43Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/NativePrivilegeStore.java", "diffHunk": "@@ -133,17 +223,69 @@ public void getPrivileges(Collection<String> applications, Collection<String> na\n                         .setFetchSource(true)\n                         .request();\n                     logger.trace(() ->\n-                        new ParameterizedMessage(\"Searching for privileges [{}] with query [{}]\", names, Strings.toString(query)));\n+                        new ParameterizedMessage(\"Searching for [{}] privileges with query [{}]\",\n+                            applications, Strings.toString(query)));\n                     request.indicesOptions().ignoreUnavailable();\n+                    // TODO: not parsing source of cached entries?\n                     ScrollHelper.fetchAllByEntity(client, request, new ContextPreservingActionListener<>(supplier, listener),\n                         hit -> buildPrivilege(hit.getId(), hit.getSourceRef()));\n                 }\n             });\n         }\n     }\n \n-    private boolean isSinglePrivilegeMatch(Collection<String> applications, Collection<String> names) {\n-        return applications != null && applications.size() == 1 && hasWildcard(applications) == false && names != null && names.size() == 1;\n+    public void invalidate(Collection<String> updatedApplicationNames) {\n+        logger.debug(\"Invalidating application privileges caches for: {}\", updatedApplicationNames);\n+        numInvalidation.incrementAndGet();\n+        // Always completely invalidate application names cache due to wildcard\n+        applicationNamesCache.invalidateAll();\n+        final Set<String> uniqueNames = Set.copyOf(updatedApplicationNames);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjI5OTM5NA=="}, "originalCommit": {"oid": "05061f972d863e577d838ac9ee721b9e23b4f68a"}, "originalPosition": 231}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwNjMwMjA3", "url": "https://github.com/elastic/elasticsearch/pull/55836#pullrequestreview-420630207", "createdAt": "2020-05-29T03:32:20Z", "commit": {"oid": "34464d73dbe7fabc0e1ac39ea8877666740f1b22"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwMzozMjoyMFrOGcNqVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwMzo0MzowOVrOGcNzUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIzNzE0Mw==", "bodyText": "Should the action names be different? It seems hard to check that the right value is cached when they're all the same.", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r432237143", "createdAt": "2020-05-29T03:32:20Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authz/store/NativePrivilegeStoreCacheTests.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.authz.store;\n+\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.action.ActionFuture;\n+import org.elasticsearch.action.DocWriteResponse;\n+import org.elasticsearch.action.admin.cluster.health.ClusterHealthAction;\n+import org.elasticsearch.action.admin.cluster.health.ClusterHealthRequestBuilder;\n+import org.elasticsearch.action.delete.DeleteRequest;\n+import org.elasticsearch.action.delete.DeleteResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.common.settings.SecureString;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.test.SecuritySingleNodeTestCase;\n+import org.elasticsearch.xpack.core.security.action.privilege.ClearPrivilegesCacheAction;\n+import org.elasticsearch.xpack.core.security.action.privilege.ClearPrivilegesCacheRequest;\n+import org.elasticsearch.xpack.core.security.action.privilege.ClearPrivilegesCacheResponse;\n+import org.elasticsearch.xpack.core.security.action.privilege.DeletePrivilegesRequestBuilder;\n+import org.elasticsearch.xpack.core.security.action.privilege.GetPrivilegesRequestBuilder;\n+import org.elasticsearch.xpack.core.security.action.privilege.PutPrivilegesAction;\n+import org.elasticsearch.xpack.core.security.action.privilege.PutPrivilegesRequest;\n+import org.elasticsearch.xpack.core.security.action.privilege.PutPrivilegesResponse;\n+import org.elasticsearch.xpack.core.security.action.role.PutRoleRequestBuilder;\n+import org.elasticsearch.xpack.core.security.action.role.PutRoleResponse;\n+import org.elasticsearch.xpack.core.security.action.user.HasPrivilegesAction;\n+import org.elasticsearch.xpack.core.security.action.user.HasPrivilegesRequest;\n+import org.elasticsearch.xpack.core.security.action.user.HasPrivilegesResponse;\n+import org.elasticsearch.xpack.core.security.action.user.PutUserRequestBuilder;\n+import org.elasticsearch.xpack.core.security.action.user.PutUserResponse;\n+import org.elasticsearch.xpack.core.security.authc.support.Hasher;\n+import org.elasticsearch.xpack.core.security.authz.RoleDescriptor;\n+import org.elasticsearch.xpack.core.security.authz.privilege.ApplicationPrivilegeDescriptor;\n+import org.junit.Before;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+\n+import static java.util.Collections.emptyMap;\n+import static java.util.Collections.singleton;\n+import static java.util.Collections.singletonMap;\n+import static org.elasticsearch.action.support.WriteRequest.RefreshPolicy.IMMEDIATE;\n+import static org.elasticsearch.test.SecuritySettingsSource.TEST_PASSWORD_HASHED;\n+import static org.elasticsearch.test.SecuritySettingsSource.TEST_ROLE;\n+import static org.elasticsearch.test.SecuritySettingsSourceField.TEST_PASSWORD;\n+import static org.elasticsearch.xpack.core.security.authz.privilege.ApplicationPrivilegeDescriptor.DOC_TYPE_VALUE;\n+import static org.elasticsearch.xpack.core.security.index.RestrictedIndicesNames.SECURITY_MAIN_ALIAS;\n+\n+public class NativePrivilegeStoreCacheTests extends SecuritySingleNodeTestCase {\n+\n+    private static final String APP_USER_NAME = \"app_user\";\n+\n+    @Override\n+    protected String configUsers() {\n+        return super.configUsers()\n+            + APP_USER_NAME + \":\" + TEST_PASSWORD_HASHED + \"\\n\";\n+    }\n+\n+    @Override\n+    protected String configRoles() {\n+        return super.configRoles()\n+            + \"app_role:\\n\"\n+            + \"  cluster: ['monitor']\\n\"\n+            + \"  indices:\\n\"\n+            + \"    - names: ['*']\\n\"\n+            + \"      privileges: ['read']\\n\"\n+            + \"  applications:\\n\"\n+            + \"    - application: 'app-1'\\n\"\n+            + \"      privileges: ['read', 'check']\\n\"\n+            + \"      resources: ['foo']\\n\"\n+            + \"    - application: 'app-2'\\n\"\n+            + \"      privileges: ['check']\\n\"\n+            + \"      resources: ['foo']\\n\";\n+    }\n+\n+    @Override\n+    protected String configUsersRoles() {\n+        return super.configUsersRoles()\n+            + \"app_role:\" + APP_USER_NAME + \"\\n\"\n+            + TEST_ROLE + \":\" + APP_USER_NAME + \"\\n\";\n+    }\n+\n+    @Before\n+    public void configureApplicationPrivileges() {\n+        final List<ApplicationPrivilegeDescriptor> applicationPrivilegeDescriptors = Arrays.asList(\n+            new ApplicationPrivilegeDescriptor(\"app-1\", \"read\", Set.of(\"a:b:c\", \"x:y:z\"), emptyMap()),\n+            new ApplicationPrivilegeDescriptor(\"app-1\", \"write\", Set.of(\"a:b:c\", \"x:y:z\"), emptyMap()),\n+            new ApplicationPrivilegeDescriptor(\"app-1\", \"admin\", Set.of(\"a:b:c\", \"x:y:z\"), emptyMap()),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34464d73dbe7fabc0e1ac39ea8877666740f1b22"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIzNzc3OA==", "bodyText": "I think this is a sign that this test shouldn't be an integration test like this. If it weren't quite so integrated you would be able to spy on the client used by the privilege store.", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r432237778", "createdAt": "2020-05-29T03:35:30Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authz/store/NativePrivilegeStoreCacheTests.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.authz.store;\n+\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.action.ActionFuture;\n+import org.elasticsearch.action.DocWriteResponse;\n+import org.elasticsearch.action.admin.cluster.health.ClusterHealthAction;\n+import org.elasticsearch.action.admin.cluster.health.ClusterHealthRequestBuilder;\n+import org.elasticsearch.action.delete.DeleteRequest;\n+import org.elasticsearch.action.delete.DeleteResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.common.settings.SecureString;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.test.SecuritySingleNodeTestCase;\n+import org.elasticsearch.xpack.core.security.action.privilege.ClearPrivilegesCacheAction;\n+import org.elasticsearch.xpack.core.security.action.privilege.ClearPrivilegesCacheRequest;\n+import org.elasticsearch.xpack.core.security.action.privilege.ClearPrivilegesCacheResponse;\n+import org.elasticsearch.xpack.core.security.action.privilege.DeletePrivilegesRequestBuilder;\n+import org.elasticsearch.xpack.core.security.action.privilege.GetPrivilegesRequestBuilder;\n+import org.elasticsearch.xpack.core.security.action.privilege.PutPrivilegesAction;\n+import org.elasticsearch.xpack.core.security.action.privilege.PutPrivilegesRequest;\n+import org.elasticsearch.xpack.core.security.action.privilege.PutPrivilegesResponse;\n+import org.elasticsearch.xpack.core.security.action.role.PutRoleRequestBuilder;\n+import org.elasticsearch.xpack.core.security.action.role.PutRoleResponse;\n+import org.elasticsearch.xpack.core.security.action.user.HasPrivilegesAction;\n+import org.elasticsearch.xpack.core.security.action.user.HasPrivilegesRequest;\n+import org.elasticsearch.xpack.core.security.action.user.HasPrivilegesResponse;\n+import org.elasticsearch.xpack.core.security.action.user.PutUserRequestBuilder;\n+import org.elasticsearch.xpack.core.security.action.user.PutUserResponse;\n+import org.elasticsearch.xpack.core.security.authc.support.Hasher;\n+import org.elasticsearch.xpack.core.security.authz.RoleDescriptor;\n+import org.elasticsearch.xpack.core.security.authz.privilege.ApplicationPrivilegeDescriptor;\n+import org.junit.Before;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+\n+import static java.util.Collections.emptyMap;\n+import static java.util.Collections.singleton;\n+import static java.util.Collections.singletonMap;\n+import static org.elasticsearch.action.support.WriteRequest.RefreshPolicy.IMMEDIATE;\n+import static org.elasticsearch.test.SecuritySettingsSource.TEST_PASSWORD_HASHED;\n+import static org.elasticsearch.test.SecuritySettingsSource.TEST_ROLE;\n+import static org.elasticsearch.test.SecuritySettingsSourceField.TEST_PASSWORD;\n+import static org.elasticsearch.xpack.core.security.authz.privilege.ApplicationPrivilegeDescriptor.DOC_TYPE_VALUE;\n+import static org.elasticsearch.xpack.core.security.index.RestrictedIndicesNames.SECURITY_MAIN_ALIAS;\n+\n+public class NativePrivilegeStoreCacheTests extends SecuritySingleNodeTestCase {\n+\n+    private static final String APP_USER_NAME = \"app_user\";\n+\n+    @Override\n+    protected String configUsers() {\n+        return super.configUsers()\n+            + APP_USER_NAME + \":\" + TEST_PASSWORD_HASHED + \"\\n\";\n+    }\n+\n+    @Override\n+    protected String configRoles() {\n+        return super.configRoles()\n+            + \"app_role:\\n\"\n+            + \"  cluster: ['monitor']\\n\"\n+            + \"  indices:\\n\"\n+            + \"    - names: ['*']\\n\"\n+            + \"      privileges: ['read']\\n\"\n+            + \"  applications:\\n\"\n+            + \"    - application: 'app-1'\\n\"\n+            + \"      privileges: ['read', 'check']\\n\"\n+            + \"      resources: ['foo']\\n\"\n+            + \"    - application: 'app-2'\\n\"\n+            + \"      privileges: ['check']\\n\"\n+            + \"      resources: ['foo']\\n\";\n+    }\n+\n+    @Override\n+    protected String configUsersRoles() {\n+        return super.configUsersRoles()\n+            + \"app_role:\" + APP_USER_NAME + \"\\n\"\n+            + TEST_ROLE + \":\" + APP_USER_NAME + \"\\n\";\n+    }\n+\n+    @Before\n+    public void configureApplicationPrivileges() {\n+        final List<ApplicationPrivilegeDescriptor> applicationPrivilegeDescriptors = Arrays.asList(\n+            new ApplicationPrivilegeDescriptor(\"app-1\", \"read\", Set.of(\"a:b:c\", \"x:y:z\"), emptyMap()),\n+            new ApplicationPrivilegeDescriptor(\"app-1\", \"write\", Set.of(\"a:b:c\", \"x:y:z\"), emptyMap()),\n+            new ApplicationPrivilegeDescriptor(\"app-1\", \"admin\", Set.of(\"a:b:c\", \"x:y:z\"), emptyMap()),\n+            new ApplicationPrivilegeDescriptor(\"app-2\", \"read\", Set.of(\"e:f:g\", \"t:u:v\"), emptyMap()),\n+            new ApplicationPrivilegeDescriptor(\"app-2\", \"write\", Set.of(\"e:f:g\", \"t:u:v\"), emptyMap()),\n+            new ApplicationPrivilegeDescriptor(\"app-2\", \"admin\", Set.of(\"e:f:g\", \"t:u:v\"), emptyMap()));\n+\n+        final PutPrivilegesRequest putPrivilegesRequest = new PutPrivilegesRequest();\n+        putPrivilegesRequest.setPrivileges(applicationPrivilegeDescriptors);\n+        final ActionFuture<PutPrivilegesResponse> future =\n+            client().execute(PutPrivilegesAction.INSTANCE, putPrivilegesRequest);\n+\n+        final PutPrivilegesResponse putPrivilegesResponse = future.actionGet();\n+        assertEquals(2, putPrivilegesResponse.created().size());\n+        assertEquals(6, putPrivilegesResponse.created().values().stream().mapToInt(List::size).sum());\n+    }\n+\n+    public void testGetPrivileges() {\n+        final Client client = client();\n+\n+        ApplicationPrivilegeDescriptor[] privileges = new GetPrivilegesRequestBuilder(client)\n+            .application(\"app-2\").privileges(\"write\").execute().actionGet().privileges();\n+\n+        assertEquals(1, privileges.length);\n+        assertEquals(\"app-2\", privileges[0].getApplication());\n+        assertEquals(\"write\", privileges[0].getName());\n+\n+        // A hacky way to test cache is populated and used by deleting the backing documents.\n+        // The test will fail if the cache is not in place", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34464d73dbe7fabc0e1ac39ea8877666740f1b22"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIzODA0Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void testGetPrivileges() {\n          \n          \n            \n                public void testGetPrivilegesUsesCache() {", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r432238042", "createdAt": "2020-05-29T03:36:50Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authz/store/NativePrivilegeStoreCacheTests.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.authz.store;\n+\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.action.ActionFuture;\n+import org.elasticsearch.action.DocWriteResponse;\n+import org.elasticsearch.action.admin.cluster.health.ClusterHealthAction;\n+import org.elasticsearch.action.admin.cluster.health.ClusterHealthRequestBuilder;\n+import org.elasticsearch.action.delete.DeleteRequest;\n+import org.elasticsearch.action.delete.DeleteResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.common.settings.SecureString;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.test.SecuritySingleNodeTestCase;\n+import org.elasticsearch.xpack.core.security.action.privilege.ClearPrivilegesCacheAction;\n+import org.elasticsearch.xpack.core.security.action.privilege.ClearPrivilegesCacheRequest;\n+import org.elasticsearch.xpack.core.security.action.privilege.ClearPrivilegesCacheResponse;\n+import org.elasticsearch.xpack.core.security.action.privilege.DeletePrivilegesRequestBuilder;\n+import org.elasticsearch.xpack.core.security.action.privilege.GetPrivilegesRequestBuilder;\n+import org.elasticsearch.xpack.core.security.action.privilege.PutPrivilegesAction;\n+import org.elasticsearch.xpack.core.security.action.privilege.PutPrivilegesRequest;\n+import org.elasticsearch.xpack.core.security.action.privilege.PutPrivilegesResponse;\n+import org.elasticsearch.xpack.core.security.action.role.PutRoleRequestBuilder;\n+import org.elasticsearch.xpack.core.security.action.role.PutRoleResponse;\n+import org.elasticsearch.xpack.core.security.action.user.HasPrivilegesAction;\n+import org.elasticsearch.xpack.core.security.action.user.HasPrivilegesRequest;\n+import org.elasticsearch.xpack.core.security.action.user.HasPrivilegesResponse;\n+import org.elasticsearch.xpack.core.security.action.user.PutUserRequestBuilder;\n+import org.elasticsearch.xpack.core.security.action.user.PutUserResponse;\n+import org.elasticsearch.xpack.core.security.authc.support.Hasher;\n+import org.elasticsearch.xpack.core.security.authz.RoleDescriptor;\n+import org.elasticsearch.xpack.core.security.authz.privilege.ApplicationPrivilegeDescriptor;\n+import org.junit.Before;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+\n+import static java.util.Collections.emptyMap;\n+import static java.util.Collections.singleton;\n+import static java.util.Collections.singletonMap;\n+import static org.elasticsearch.action.support.WriteRequest.RefreshPolicy.IMMEDIATE;\n+import static org.elasticsearch.test.SecuritySettingsSource.TEST_PASSWORD_HASHED;\n+import static org.elasticsearch.test.SecuritySettingsSource.TEST_ROLE;\n+import static org.elasticsearch.test.SecuritySettingsSourceField.TEST_PASSWORD;\n+import static org.elasticsearch.xpack.core.security.authz.privilege.ApplicationPrivilegeDescriptor.DOC_TYPE_VALUE;\n+import static org.elasticsearch.xpack.core.security.index.RestrictedIndicesNames.SECURITY_MAIN_ALIAS;\n+\n+public class NativePrivilegeStoreCacheTests extends SecuritySingleNodeTestCase {\n+\n+    private static final String APP_USER_NAME = \"app_user\";\n+\n+    @Override\n+    protected String configUsers() {\n+        return super.configUsers()\n+            + APP_USER_NAME + \":\" + TEST_PASSWORD_HASHED + \"\\n\";\n+    }\n+\n+    @Override\n+    protected String configRoles() {\n+        return super.configRoles()\n+            + \"app_role:\\n\"\n+            + \"  cluster: ['monitor']\\n\"\n+            + \"  indices:\\n\"\n+            + \"    - names: ['*']\\n\"\n+            + \"      privileges: ['read']\\n\"\n+            + \"  applications:\\n\"\n+            + \"    - application: 'app-1'\\n\"\n+            + \"      privileges: ['read', 'check']\\n\"\n+            + \"      resources: ['foo']\\n\"\n+            + \"    - application: 'app-2'\\n\"\n+            + \"      privileges: ['check']\\n\"\n+            + \"      resources: ['foo']\\n\";\n+    }\n+\n+    @Override\n+    protected String configUsersRoles() {\n+        return super.configUsersRoles()\n+            + \"app_role:\" + APP_USER_NAME + \"\\n\"\n+            + TEST_ROLE + \":\" + APP_USER_NAME + \"\\n\";\n+    }\n+\n+    @Before\n+    public void configureApplicationPrivileges() {\n+        final List<ApplicationPrivilegeDescriptor> applicationPrivilegeDescriptors = Arrays.asList(\n+            new ApplicationPrivilegeDescriptor(\"app-1\", \"read\", Set.of(\"a:b:c\", \"x:y:z\"), emptyMap()),\n+            new ApplicationPrivilegeDescriptor(\"app-1\", \"write\", Set.of(\"a:b:c\", \"x:y:z\"), emptyMap()),\n+            new ApplicationPrivilegeDescriptor(\"app-1\", \"admin\", Set.of(\"a:b:c\", \"x:y:z\"), emptyMap()),\n+            new ApplicationPrivilegeDescriptor(\"app-2\", \"read\", Set.of(\"e:f:g\", \"t:u:v\"), emptyMap()),\n+            new ApplicationPrivilegeDescriptor(\"app-2\", \"write\", Set.of(\"e:f:g\", \"t:u:v\"), emptyMap()),\n+            new ApplicationPrivilegeDescriptor(\"app-2\", \"admin\", Set.of(\"e:f:g\", \"t:u:v\"), emptyMap()));\n+\n+        final PutPrivilegesRequest putPrivilegesRequest = new PutPrivilegesRequest();\n+        putPrivilegesRequest.setPrivileges(applicationPrivilegeDescriptors);\n+        final ActionFuture<PutPrivilegesResponse> future =\n+            client().execute(PutPrivilegesAction.INSTANCE, putPrivilegesRequest);\n+\n+        final PutPrivilegesResponse putPrivilegesResponse = future.actionGet();\n+        assertEquals(2, putPrivilegesResponse.created().size());\n+        assertEquals(6, putPrivilegesResponse.created().values().stream().mapToInt(List::size).sum());\n+    }\n+\n+    public void testGetPrivileges() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34464d73dbe7fabc0e1ac39ea8877666740f1b22"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIzODc1OA==", "bodyText": "Something like\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void testWildcard() {\n          \n          \n            \n                public void testPopulationOfCacheWhenLoadingPrivilegesForAllApplications() {\n          \n      \n    \n    \n  \n\n?", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r432238758", "createdAt": "2020-05-29T03:39:58Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authz/store/NativePrivilegeStoreCacheTests.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.authz.store;\n+\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.action.ActionFuture;\n+import org.elasticsearch.action.DocWriteResponse;\n+import org.elasticsearch.action.admin.cluster.health.ClusterHealthAction;\n+import org.elasticsearch.action.admin.cluster.health.ClusterHealthRequestBuilder;\n+import org.elasticsearch.action.delete.DeleteRequest;\n+import org.elasticsearch.action.delete.DeleteResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.common.settings.SecureString;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.test.SecuritySingleNodeTestCase;\n+import org.elasticsearch.xpack.core.security.action.privilege.ClearPrivilegesCacheAction;\n+import org.elasticsearch.xpack.core.security.action.privilege.ClearPrivilegesCacheRequest;\n+import org.elasticsearch.xpack.core.security.action.privilege.ClearPrivilegesCacheResponse;\n+import org.elasticsearch.xpack.core.security.action.privilege.DeletePrivilegesRequestBuilder;\n+import org.elasticsearch.xpack.core.security.action.privilege.GetPrivilegesRequestBuilder;\n+import org.elasticsearch.xpack.core.security.action.privilege.PutPrivilegesAction;\n+import org.elasticsearch.xpack.core.security.action.privilege.PutPrivilegesRequest;\n+import org.elasticsearch.xpack.core.security.action.privilege.PutPrivilegesResponse;\n+import org.elasticsearch.xpack.core.security.action.role.PutRoleRequestBuilder;\n+import org.elasticsearch.xpack.core.security.action.role.PutRoleResponse;\n+import org.elasticsearch.xpack.core.security.action.user.HasPrivilegesAction;\n+import org.elasticsearch.xpack.core.security.action.user.HasPrivilegesRequest;\n+import org.elasticsearch.xpack.core.security.action.user.HasPrivilegesResponse;\n+import org.elasticsearch.xpack.core.security.action.user.PutUserRequestBuilder;\n+import org.elasticsearch.xpack.core.security.action.user.PutUserResponse;\n+import org.elasticsearch.xpack.core.security.authc.support.Hasher;\n+import org.elasticsearch.xpack.core.security.authz.RoleDescriptor;\n+import org.elasticsearch.xpack.core.security.authz.privilege.ApplicationPrivilegeDescriptor;\n+import org.junit.Before;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+\n+import static java.util.Collections.emptyMap;\n+import static java.util.Collections.singleton;\n+import static java.util.Collections.singletonMap;\n+import static org.elasticsearch.action.support.WriteRequest.RefreshPolicy.IMMEDIATE;\n+import static org.elasticsearch.test.SecuritySettingsSource.TEST_PASSWORD_HASHED;\n+import static org.elasticsearch.test.SecuritySettingsSource.TEST_ROLE;\n+import static org.elasticsearch.test.SecuritySettingsSourceField.TEST_PASSWORD;\n+import static org.elasticsearch.xpack.core.security.authz.privilege.ApplicationPrivilegeDescriptor.DOC_TYPE_VALUE;\n+import static org.elasticsearch.xpack.core.security.index.RestrictedIndicesNames.SECURITY_MAIN_ALIAS;\n+\n+public class NativePrivilegeStoreCacheTests extends SecuritySingleNodeTestCase {\n+\n+    private static final String APP_USER_NAME = \"app_user\";\n+\n+    @Override\n+    protected String configUsers() {\n+        return super.configUsers()\n+            + APP_USER_NAME + \":\" + TEST_PASSWORD_HASHED + \"\\n\";\n+    }\n+\n+    @Override\n+    protected String configRoles() {\n+        return super.configRoles()\n+            + \"app_role:\\n\"\n+            + \"  cluster: ['monitor']\\n\"\n+            + \"  indices:\\n\"\n+            + \"    - names: ['*']\\n\"\n+            + \"      privileges: ['read']\\n\"\n+            + \"  applications:\\n\"\n+            + \"    - application: 'app-1'\\n\"\n+            + \"      privileges: ['read', 'check']\\n\"\n+            + \"      resources: ['foo']\\n\"\n+            + \"    - application: 'app-2'\\n\"\n+            + \"      privileges: ['check']\\n\"\n+            + \"      resources: ['foo']\\n\";\n+    }\n+\n+    @Override\n+    protected String configUsersRoles() {\n+        return super.configUsersRoles()\n+            + \"app_role:\" + APP_USER_NAME + \"\\n\"\n+            + TEST_ROLE + \":\" + APP_USER_NAME + \"\\n\";\n+    }\n+\n+    @Before\n+    public void configureApplicationPrivileges() {\n+        final List<ApplicationPrivilegeDescriptor> applicationPrivilegeDescriptors = Arrays.asList(\n+            new ApplicationPrivilegeDescriptor(\"app-1\", \"read\", Set.of(\"a:b:c\", \"x:y:z\"), emptyMap()),\n+            new ApplicationPrivilegeDescriptor(\"app-1\", \"write\", Set.of(\"a:b:c\", \"x:y:z\"), emptyMap()),\n+            new ApplicationPrivilegeDescriptor(\"app-1\", \"admin\", Set.of(\"a:b:c\", \"x:y:z\"), emptyMap()),\n+            new ApplicationPrivilegeDescriptor(\"app-2\", \"read\", Set.of(\"e:f:g\", \"t:u:v\"), emptyMap()),\n+            new ApplicationPrivilegeDescriptor(\"app-2\", \"write\", Set.of(\"e:f:g\", \"t:u:v\"), emptyMap()),\n+            new ApplicationPrivilegeDescriptor(\"app-2\", \"admin\", Set.of(\"e:f:g\", \"t:u:v\"), emptyMap()));\n+\n+        final PutPrivilegesRequest putPrivilegesRequest = new PutPrivilegesRequest();\n+        putPrivilegesRequest.setPrivileges(applicationPrivilegeDescriptors);\n+        final ActionFuture<PutPrivilegesResponse> future =\n+            client().execute(PutPrivilegesAction.INSTANCE, putPrivilegesRequest);\n+\n+        final PutPrivilegesResponse putPrivilegesResponse = future.actionGet();\n+        assertEquals(2, putPrivilegesResponse.created().size());\n+        assertEquals(6, putPrivilegesResponse.created().values().stream().mapToInt(List::size).sum());\n+    }\n+\n+    public void testGetPrivileges() {\n+        final Client client = client();\n+\n+        ApplicationPrivilegeDescriptor[] privileges = new GetPrivilegesRequestBuilder(client)\n+            .application(\"app-2\").privileges(\"write\").execute().actionGet().privileges();\n+\n+        assertEquals(1, privileges.length);\n+        assertEquals(\"app-2\", privileges[0].getApplication());\n+        assertEquals(\"write\", privileges[0].getName());\n+\n+        // A hacky way to test cache is populated and used by deleting the backing documents.\n+        // The test will fail if the cache is not in place\n+        assertFalse(client.prepareBulk()\n+            .add(new DeleteRequest(SECURITY_MAIN_ALIAS, DOC_TYPE_VALUE + \"_app-2:read\"))\n+            .add(new DeleteRequest(SECURITY_MAIN_ALIAS, DOC_TYPE_VALUE + \"_app-2:write\"))\n+            .add(new DeleteRequest(SECURITY_MAIN_ALIAS, DOC_TYPE_VALUE + \"_app-2:admin\"))\n+            .setRefreshPolicy(IMMEDIATE).execute().actionGet().hasFailures());\n+\n+        // We can still get the privileges because it is cached\n+        privileges = new GetPrivilegesRequestBuilder(client)\n+            .application(\"app-2\").privileges(\"read\").execute().actionGet().privileges();\n+\n+        assertEquals(1, privileges.length);\n+\n+        // We can get all app-2 privileges because cache is keyed by application\n+        privileges = new GetPrivilegesRequestBuilder(client)\n+            .application(\"app-2\").execute().actionGet().privileges();\n+\n+        assertEquals(3, privileges.length);\n+\n+        // Now properly invalidate the cache\n+        final ClearPrivilegesCacheResponse clearPrivilegesCacheResponse =\n+            client.execute(ClearPrivilegesCacheAction.INSTANCE, new ClearPrivilegesCacheRequest()).actionGet();\n+        assertFalse(clearPrivilegesCacheResponse.hasFailures());\n+\n+        // app-2 is no longer found\n+        privileges = new GetPrivilegesRequestBuilder(client)\n+            .application(\"app-2\").privileges(\"read\").execute().actionGet().privileges();\n+        assertEquals(0, privileges.length);\n+    }\n+\n+    public void testWildcard() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34464d73dbe7fabc0e1ac39ea8877666740f1b22"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIzOTQ0Mg==", "bodyText": "Why did this test get removed?\nIsn't that still a valid scenario?", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r432239442", "createdAt": "2020-05-29T03:43:09Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authz/store/NativePrivilegeStoreTests.java", "diffHunk": "@@ -114,42 +118,27 @@ public void cleanup() {\n     }\n \n     public void testGetSinglePrivilegeByName() throws Exception {\n-        final ApplicationPrivilegeDescriptor sourcePrivilege = new ApplicationPrivilegeDescriptor(\"myapp\", \"admin\",\n-            newHashSet(\"action:admin/*\", \"action:login\", \"data:read/*\"), emptyMap()\n-        );\n-\n-        final PlainActionFuture<ApplicationPrivilegeDescriptor> future = new PlainActionFuture<>();\n-        store.getPrivilege(\"myapp\", \"admin\", future);\n-        assertThat(requests, iterableWithSize(1));\n-        assertThat(requests.get(0), instanceOf(GetRequest.class));\n-        GetRequest request = (GetRequest) requests.get(0);\n-        assertThat(request.index(), equalTo(RestrictedIndicesNames.SECURITY_MAIN_ALIAS));\n-        assertThat(request.id(), equalTo(\"application-privilege_myapp:admin\"));\n-\n-        final String docSource = Strings.toString(sourcePrivilege);\n-        listener.get().onResponse(new GetResponse(\n-            new GetResult(request.index(), request.id(), 0, 1, 1L, true,\n-                new BytesArray(docSource), emptyMap(), emptyMap())\n+        final List<ApplicationPrivilegeDescriptor> sourcePrivileges = List.of(\n+            new ApplicationPrivilegeDescriptor(\"myapp\", \"admin\",\n+                newHashSet(\"action:admin/*\", \"action:login\", \"data:read/*\"), emptyMap()\n         ));\n-        final ApplicationPrivilegeDescriptor getPrivilege = future.get(1, TimeUnit.SECONDS);\n-        assertThat(getPrivilege, equalTo(sourcePrivilege));\n-    }\n \n-    public void testGetMissingPrivilege() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34464d73dbe7fabc0e1ac39ea8877666740f1b22"}, "originalPosition": 89}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e87d8974b248a20d5947facd397d7b2b9bb206bb", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/e87d8974b248a20d5947facd397d7b2b9bb206bb", "committedDate": "2020-05-29T06:58:14Z", "message": "Update x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/NativePrivilegeStore.java\n\nCo-authored-by: Tim Vernum <tim@adjective.org>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5acc7ec3738dc134013ff5f7ab955ee95b330779", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/5acc7ec3738dc134013ff5f7ab955ee95b330779", "committedDate": "2020-05-29T06:58:42Z", "message": "Update x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/NativePrivilegeStore.java\n\nCo-authored-by: Tim Vernum <tim@adjective.org>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5e3174a6b8a3ecf6591e3c68bc51195d8d177a06", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/5e3174a6b8a3ecf6591e3c68bc51195d8d177a06", "committedDate": "2020-05-29T13:15:02Z", "message": "Update x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/NativePrivilegeStore.java\n\nCo-authored-by: Tim Vernum <tim@adjective.org>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "385fb124c868d55fe903db2d732e875364135231", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/385fb124c868d55fe903db2d732e875364135231", "committedDate": "2020-05-29T14:23:54Z", "message": "Update x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authz/store/NativePrivilegeStoreCacheTests.java\n\nCo-authored-by: Tim Vernum <tim@adjective.org>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e411dc9254178c9b7a389d5c90a5922abdf7cdbd", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/e411dc9254178c9b7a389d5c90a5922abdf7cdbd", "committedDate": "2020-05-29T14:24:21Z", "message": "Update x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authz/store/NativePrivilegeStoreCacheTests.java\n\nCo-authored-by: Tim Vernum <tim@adjective.org>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "58b3942a138c135a4ed9caeeaf4c83e38e59336e", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/58b3942a138c135a4ed9caeeaf4c83e38e59336e", "committedDate": "2020-05-29T14:36:41Z", "message": "Address feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a8f8e81d7dce8dcf736ef55ba712f2090b6c9fcc", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/a8f8e81d7dce8dcf736ef55ba712f2090b6c9fcc", "committedDate": "2020-05-29T14:37:02Z", "message": "Merge remote-tracking branch 'origin/master' into es-54317-app-privilege-cache"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9a763c37817121dadf2878891660e7b602ebbd67", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/9a763c37817121dadf2878891660e7b602ebbd67", "committedDate": "2020-05-29T14:45:49Z", "message": "Address feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a43b3ef2a3ccb784e7bdbfbf1a95788b61607d31", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/a43b3ef2a3ccb784e7bdbfbf1a95788b61607d31", "committedDate": "2020-05-29T14:56:35Z", "message": "Fix docs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac6c39f8beb3f496832074b355df868358c29b6e", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/ac6c39f8beb3f496832074b355df868358c29b6e", "committedDate": "2020-06-02T13:56:02Z", "message": "Address feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8e1dc13e46237b7e169d444710c578bd31c7e557", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/8e1dc13e46237b7e169d444710c578bd31c7e557", "committedDate": "2020-06-02T13:56:41Z", "message": "Merge remote-tracking branch 'origin/master' into es-54317-app-privilege-cache"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "21c89fba7a493461dca8a8551fb7dc3d54e96a67", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/21c89fba7a493461dca8a8551fb7dc3d54e96a67", "committedDate": "2020-06-02T13:58:25Z", "message": "Remove todo as it is pointless"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1499a26c051cae85fc78aa80c33c6bc5fa7abfdd", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/1499a26c051cae85fc78aa80c33c6bc5fa7abfdd", "committedDate": "2020-06-03T13:10:21Z", "message": "Address feedback for readwritelock and cache invalidation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3b7e773b93672fe53f289a84e26d095fb3cacf6c", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/3b7e773b93672fe53f289a84e26d095fb3cacf6c", "committedDate": "2020-06-03T13:10:38Z", "message": "Merge remote-tracking branch 'origin/master' into es-54317-app-privilege-cache"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "83a0e196d5e3b39a70a30c9c4f3df800f77ee19c", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/83a0e196d5e3b39a70a30c9c4f3df800f77ee19c", "committedDate": "2020-06-04T08:47:19Z", "message": "add tests for caching behaviour"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3deef1e803df46d643f42e1557d3e4b7bb7c00b7", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/3deef1e803df46d643f42e1557d3e4b7bb7c00b7", "committedDate": "2020-06-04T08:47:37Z", "message": "Merge remote-tracking branch 'origin/master' into es-54317-app-privilege-cache"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9364e36f80aa3d4f8c2a14267a4abddf032d3dba", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/9364e36f80aa3d4f8c2a14267a4abddf032d3dba", "committedDate": "2020-06-15T01:56:41Z", "message": "Add TTL as a safety net. Also consolidate cache size to a single setting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0280c3e9cec5c4d659c868337f13a83b70f303f5", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/0280c3e9cec5c4d659c868337f13a83b70f303f5", "committedDate": "2020-06-15T01:56:48Z", "message": "Merge remote-tracking branch 'origin/master' into es-54317-app-privilege-cache"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2MzM0NzIz", "url": "https://github.com/elastic/elasticsearch/pull/55836#pullrequestreview-436334723", "createdAt": "2020-06-24T05:31:35Z", "commit": {"oid": "0280c3e9cec5c4d659c868337f13a83b70f303f5"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwNTozMTozNVrOGoDe7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwNTozMTozNVrOGoDe7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDY1MzI5NA==", "bodyText": "I think we can release the lock immediately after incrementing numInvalidation. It will mean that, in theory, we could invalidate things that we don't need to, but would mean holding a lock for less time.\nDid you consider the trade-off of how long to lock for vs perfect cache accuracy?\nIf we keep the lock around all the invalidation process, then I think the calculation of uniqueNames should be before the lock is acquired.", "url": "https://github.com/elastic/elasticsearch/pull/55836#discussion_r444653294", "createdAt": "2020-06-24T05:31:35Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/NativePrivilegeStore.java", "diffHunk": "@@ -346,4 +419,55 @@ private static String toDocId(String application, String name) {\n         return DOC_TYPE_VALUE + \"_\" + application + \":\" + name;\n     }\n \n+    public void onSecurityIndexStateChange(SecurityIndexManager.State previousState, SecurityIndexManager.State currentState) {\n+        if (isMoveFromRedToNonRed(previousState, currentState) || isIndexDeleted(previousState, currentState)\n+            || previousState.isIndexUpToDate != currentState.isIndexUpToDate) {\n+            invalidateAll();\n+        }\n+    }\n+\n+    public void invalidate(Collection<String> updatedApplicationNames) {\n+        if (descriptorsCache == null) {\n+            return;\n+        }\n+        logger.debug(\"Invalidating application privileges caches for: {}\", updatedApplicationNames);\n+        try (ReleasableLock ignored = invalidationWriteLock.acquire()) {\n+            numInvalidation.incrementAndGet();\n+            final Set<String> uniqueNames = Set.copyOf(updatedApplicationNames);\n+            // Always completely invalidate application names cache due to wildcard\n+            applicationNamesCache.invalidateAll();\n+            uniqueNames.forEach(descriptorsCache::invalidate);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0280c3e9cec5c4d659c868337f13a83b70f303f5"}, "originalPosition": 459}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ae3c7842c5fe525c7bce92fe38dcfccec4e16c7c", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/ae3c7842c5fe525c7bce92fe38dcfccec4e16c7c", "committedDate": "2020-06-29T02:35:50Z", "message": "Address feedback about lock duration"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "68a4dc1167aa96c99021ad5d62a168c93b9c6d6d", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/68a4dc1167aa96c99021ad5d62a168c93b9c6d6d", "committedDate": "2020-06-29T02:35:58Z", "message": "Merge remote-tracking branch 'origin/master' into es-54317-app-privilege-cache"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4ODU4MDY2", "url": "https://github.com/elastic/elasticsearch/pull/55836#pullrequestreview-438858066", "createdAt": "2020-06-29T02:57:22Z", "commit": {"oid": "68a4dc1167aa96c99021ad5d62a168c93b9c6d6d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 462, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}