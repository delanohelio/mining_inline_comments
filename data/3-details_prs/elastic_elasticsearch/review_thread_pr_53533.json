{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg3NjgxNjcy", "number": 53533, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxMToxMjoyOFrODtfE9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxMjowOTowMlrODtgKxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MDIxNjg3OnYy", "diffSide": "RIGHT", "path": "client/rest-high-level/src/test/java/org/elasticsearch/client/RestHighLevelClientTests.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxMToxMjoyOFrOF-73AA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwOTowNzoxOVrOF_iErw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTUzNjc2OA==", "bodyText": "very minor, but should we go with UTF_8 here? (to stay within the \"utf8 everywhere\" bounds)", "url": "https://github.com/elastic/elasticsearch/pull/53533#discussion_r401536768", "createdAt": "2020-04-01T11:12:28Z", "author": {"login": "andreidan"}, "path": "client/rest-high-level/src/test/java/org/elasticsearch/client/RestHighLevelClientTests.java", "diffHunk": "@@ -320,6 +326,50 @@ public void testParseEntity() throws IOException {\n         }\n     }\n \n+    public void testParseCompressedEntity() throws IOException {\n+        CheckedFunction<XContentParser, String, IOException> entityParser = parser -> {\n+            assertEquals(XContentParser.Token.START_OBJECT, parser.nextToken());\n+            assertEquals(XContentParser.Token.FIELD_NAME, parser.nextToken());\n+            assertTrue(parser.nextToken().isValue());\n+            String value = parser.text();\n+            assertEquals(XContentParser.Token.END_OBJECT, parser.nextToken());\n+            return value;\n+        };\n+\n+        HttpEntity jsonEntity = new NByteArrayEntity(compress(\"{\\\"field\\\":\\\"value\\\"}\"), ContentType.APPLICATION_JSON);\n+        assertEquals(\"value\", restHighLevelClient.parseEntity(enrichHeaderContentEncodingWithGzip(jsonEntity), entityParser));\n+        HttpEntity yamlEntity = new NByteArrayEntity(compress(\"---\\nfield: value\\n\"), ContentType.create(\"application/yaml\"));\n+        assertEquals(\"value\", restHighLevelClient.parseEntity(enrichHeaderContentEncodingWithGzip(yamlEntity), entityParser));\n+        HttpEntity smileEntity = createCompressedBinaryEntity(SmileXContent.contentBuilder(), ContentType.create(\"application/smile\"));\n+        assertEquals(\"value\", restHighLevelClient.parseEntity(enrichHeaderContentEncodingWithGzip(smileEntity), entityParser));\n+        HttpEntity cborEntity = createCompressedBinaryEntity(CborXContent.contentBuilder(), ContentType.create(\"application/cbor\"));\n+        assertEquals(\"value\", restHighLevelClient.parseEntity(enrichHeaderContentEncodingWithGzip(cborEntity), entityParser));\n+    }\n+\n+    private static byte[] compress(String content) throws IOException {\n+        return compress(content.getBytes(StandardCharsets.ISO_8859_1));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5aac2e6b8dd3ebd092def8a82231484ac9a664cf"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE2Mjg2Mw==", "bodyText": "The reason why I used ISO_8859_1 here was because in a previous commit I was not using the GzipDecompressingEntity and somehow it was not able to correctly compress and decompress. I changed it now to UTF_8, great catch!", "url": "https://github.com/elastic/elasticsearch/pull/53533#discussion_r402162863", "createdAt": "2020-04-02T09:07:19Z", "author": {"login": "Hakky54"}, "path": "client/rest-high-level/src/test/java/org/elasticsearch/client/RestHighLevelClientTests.java", "diffHunk": "@@ -320,6 +326,50 @@ public void testParseEntity() throws IOException {\n         }\n     }\n \n+    public void testParseCompressedEntity() throws IOException {\n+        CheckedFunction<XContentParser, String, IOException> entityParser = parser -> {\n+            assertEquals(XContentParser.Token.START_OBJECT, parser.nextToken());\n+            assertEquals(XContentParser.Token.FIELD_NAME, parser.nextToken());\n+            assertTrue(parser.nextToken().isValue());\n+            String value = parser.text();\n+            assertEquals(XContentParser.Token.END_OBJECT, parser.nextToken());\n+            return value;\n+        };\n+\n+        HttpEntity jsonEntity = new NByteArrayEntity(compress(\"{\\\"field\\\":\\\"value\\\"}\"), ContentType.APPLICATION_JSON);\n+        assertEquals(\"value\", restHighLevelClient.parseEntity(enrichHeaderContentEncodingWithGzip(jsonEntity), entityParser));\n+        HttpEntity yamlEntity = new NByteArrayEntity(compress(\"---\\nfield: value\\n\"), ContentType.create(\"application/yaml\"));\n+        assertEquals(\"value\", restHighLevelClient.parseEntity(enrichHeaderContentEncodingWithGzip(yamlEntity), entityParser));\n+        HttpEntity smileEntity = createCompressedBinaryEntity(SmileXContent.contentBuilder(), ContentType.create(\"application/smile\"));\n+        assertEquals(\"value\", restHighLevelClient.parseEntity(enrichHeaderContentEncodingWithGzip(smileEntity), entityParser));\n+        HttpEntity cborEntity = createCompressedBinaryEntity(CborXContent.contentBuilder(), ContentType.create(\"application/cbor\"));\n+        assertEquals(\"value\", restHighLevelClient.parseEntity(enrichHeaderContentEncodingWithGzip(cborEntity), entityParser));\n+    }\n+\n+    private static byte[] compress(String content) throws IOException {\n+        return compress(content.getBytes(StandardCharsets.ISO_8859_1));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTUzNjc2OA=="}, "originalCommit": {"oid": "5aac2e6b8dd3ebd092def8a82231484ac9a664cf"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MDI1Mzc1OnYy", "diffSide": "RIGHT", "path": "test/framework/src/main/java/org/elasticsearch/test/rest/ESRestTestCase.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxMToyMzo1NlrOF-8N3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwOToxMzowN1rOF_iSnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTU0MjYyMw==", "bodyText": "I think we can make use of ESRestHighLevelClientTestCase and have HttpCompressionIT moved to the client (org.elasticsearch.client) tests and extend it? That way we'll keep ESRestTestCase agnostic of the high level rest client as it's already quite knowledgeable, and HttpCompressionIT is essentially testing how our clients are handling the compression so I think it would fit in the client package. What do you think?", "url": "https://github.com/elastic/elasticsearch/pull/53533#discussion_r401542623", "createdAt": "2020-04-01T11:23:56Z", "author": {"login": "andreidan"}, "path": "test/framework/src/main/java/org/elasticsearch/test/rest/ESRestTestCase.java", "diffHunk": "@@ -139,6 +141,7 @@ public static boolean hasXPack() {\n      * A client for the running Elasticsearch cluster\n      */\n     private static RestClient client;\n+    private static RestHighLevelClient restHighLevelClient;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5aac2e6b8dd3ebd092def8a82231484ac9a664cf"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE2NjQzMQ==", "bodyText": "Good one, I refactored it!", "url": "https://github.com/elastic/elasticsearch/pull/53533#discussion_r402166431", "createdAt": "2020-04-02T09:13:07Z", "author": {"login": "Hakky54"}, "path": "test/framework/src/main/java/org/elasticsearch/test/rest/ESRestTestCase.java", "diffHunk": "@@ -139,6 +141,7 @@ public static boolean hasXPack() {\n      * A client for the running Elasticsearch cluster\n      */\n     private static RestClient client;\n+    private static RestHighLevelClient restHighLevelClient;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTU0MjYyMw=="}, "originalCommit": {"oid": "5aac2e6b8dd3ebd092def8a82231484ac9a664cf"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MDMyMjkyOnYy", "diffSide": "RIGHT", "path": "qa/smoke-test-http/src/test/java/org/elasticsearch/http/HttpCompressionIT.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxMTo0NTo1M1rOF-84vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwOTowODoyMlrOF_iHJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTU1MzU5OA==", "bodyText": "Nice test! Should we also assert we got one hit back? (we'd read something from the payload this way)", "url": "https://github.com/elastic/elasticsearch/pull/53533#discussion_r401553598", "createdAt": "2020-04-01T11:45:53Z", "author": {"login": "andreidan"}, "path": "qa/smoke-test-http/src/test/java/org/elasticsearch/http/HttpCompressionIT.java", "diffHunk": "@@ -59,4 +66,29 @@ public void testUncompressedResponseByDefault() throws IOException {\n         assertNull(response.getHeader(HttpHeaders.CONTENT_ENCODING));\n     }\n \n+    public void testCompressesResponseIfRequestedWhileUsingRestHighLevelClient() throws IOException {\n+        String documentId = \"1\";\n+        String indexName = \"company\";\n+\n+        IndexRequest indexRequest = new IndexRequest(indexName)\n+            .source(SAMPLE_DOCUMENT, XContentType.JSON)\n+            .id(documentId);\n+        IndexResponse indexResponse = restHighLevelClient().index(indexRequest, RequestOptions.DEFAULT);\n+        assertOK(indexResponse);\n+\n+        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder()\n+            .query(new MatchQueryBuilder(\"_id\", documentId));\n+\n+        SearchRequest searchRequest = new SearchRequest()\n+            .indices(indexName)\n+            .source(sourceBuilder);\n+\n+        RequestOptions requestOptions = RequestOptions.DEFAULT.toBuilder()\n+            .addHeader(HttpHeaders.ACCEPT_ENCODING, GZIP_ENCODING)\n+            .build();\n+\n+        SearchResponse searchResponse = restHighLevelClient().search(searchRequest, requestOptions);\n+        assertOK(searchResponse);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5aac2e6b8dd3ebd092def8a82231484ac9a664cf"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE2MzQ5NA==", "bodyText": "Included asserting amount of hits and even the source of the hit", "url": "https://github.com/elastic/elasticsearch/pull/53533#discussion_r402163494", "createdAt": "2020-04-02T09:08:22Z", "author": {"login": "Hakky54"}, "path": "qa/smoke-test-http/src/test/java/org/elasticsearch/http/HttpCompressionIT.java", "diffHunk": "@@ -59,4 +66,29 @@ public void testUncompressedResponseByDefault() throws IOException {\n         assertNull(response.getHeader(HttpHeaders.CONTENT_ENCODING));\n     }\n \n+    public void testCompressesResponseIfRequestedWhileUsingRestHighLevelClient() throws IOException {\n+        String documentId = \"1\";\n+        String indexName = \"company\";\n+\n+        IndexRequest indexRequest = new IndexRequest(indexName)\n+            .source(SAMPLE_DOCUMENT, XContentType.JSON)\n+            .id(documentId);\n+        IndexResponse indexResponse = restHighLevelClient().index(indexRequest, RequestOptions.DEFAULT);\n+        assertOK(indexResponse);\n+\n+        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder()\n+            .query(new MatchQueryBuilder(\"_id\", documentId));\n+\n+        SearchRequest searchRequest = new SearchRequest()\n+            .indices(indexName)\n+            .source(sourceBuilder);\n+\n+        RequestOptions requestOptions = RequestOptions.DEFAULT.toBuilder()\n+            .addHeader(HttpHeaders.ACCEPT_ENCODING, GZIP_ENCODING)\n+            .build();\n+\n+        SearchResponse searchResponse = restHighLevelClient().search(searchRequest, requestOptions);\n+        assertOK(searchResponse);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTU1MzU5OA=="}, "originalCommit": {"oid": "5aac2e6b8dd3ebd092def8a82231484ac9a664cf"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MDM2Mjc0OnYy", "diffSide": "RIGHT", "path": "client/rest-high-level/src/test/java/org/elasticsearch/client/RestHighLevelClientTests.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxMTo1ODoyN1rOF-9R4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwOTozMToyM1rOF_i_HQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTU2MDAzNQ==", "bodyText": "Shall we convert this to a method that creates an encoded HttpEntity?\nie. HttpEntity createGzipEncodedEntity(String content)\nAnd we could use real apache entities instead of mocks/spies. We can create a BasicHttpEntity, a BasicHeader for the encoding and set the header we create on the entity using setContentEncoding(Header contentEncoding)", "url": "https://github.com/elastic/elasticsearch/pull/53533#discussion_r401560035", "createdAt": "2020-04-01T11:58:27Z", "author": {"login": "andreidan"}, "path": "client/rest-high-level/src/test/java/org/elasticsearch/client/RestHighLevelClientTests.java", "diffHunk": "@@ -320,6 +326,50 @@ public void testParseEntity() throws IOException {\n         }\n     }\n \n+    public void testParseCompressedEntity() throws IOException {\n+        CheckedFunction<XContentParser, String, IOException> entityParser = parser -> {\n+            assertEquals(XContentParser.Token.START_OBJECT, parser.nextToken());\n+            assertEquals(XContentParser.Token.FIELD_NAME, parser.nextToken());\n+            assertTrue(parser.nextToken().isValue());\n+            String value = parser.text();\n+            assertEquals(XContentParser.Token.END_OBJECT, parser.nextToken());\n+            return value;\n+        };\n+\n+        HttpEntity jsonEntity = new NByteArrayEntity(compress(\"{\\\"field\\\":\\\"value\\\"}\"), ContentType.APPLICATION_JSON);\n+        assertEquals(\"value\", restHighLevelClient.parseEntity(enrichHeaderContentEncodingWithGzip(jsonEntity), entityParser));\n+        HttpEntity yamlEntity = new NByteArrayEntity(compress(\"---\\nfield: value\\n\"), ContentType.create(\"application/yaml\"));\n+        assertEquals(\"value\", restHighLevelClient.parseEntity(enrichHeaderContentEncodingWithGzip(yamlEntity), entityParser));\n+        HttpEntity smileEntity = createCompressedBinaryEntity(SmileXContent.contentBuilder(), ContentType.create(\"application/smile\"));\n+        assertEquals(\"value\", restHighLevelClient.parseEntity(enrichHeaderContentEncodingWithGzip(smileEntity), entityParser));\n+        HttpEntity cborEntity = createCompressedBinaryEntity(CborXContent.contentBuilder(), ContentType.create(\"application/cbor\"));\n+        assertEquals(\"value\", restHighLevelClient.parseEntity(enrichHeaderContentEncodingWithGzip(cborEntity), entityParser));\n+    }\n+\n+    private static byte[] compress(String content) throws IOException {\n+        return compress(content.getBytes(StandardCharsets.ISO_8859_1));\n+    }\n+\n+    private static byte[] compress(byte[] content) throws IOException {\n+        ByteArrayOutputStream bos = new ByteArrayOutputStream(content.length);\n+        GZIPOutputStream gzip = new GZIPOutputStream(bos);\n+        gzip.write(content);\n+        gzip.close();\n+        bos.close();\n+\n+        return bos.toByteArray();\n+    }\n+\n+    private static HttpEntity enrichHeaderContentEncodingWithGzip(HttpEntity httpEntity) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5aac2e6b8dd3ebd092def8a82231484ac9a664cf"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE3NzgyMQ==", "bodyText": "Yes, also done. And instead of using BasicHttpEntity I have used NByteArrayEntity and included the content encoding and discarded enrichHeaderContentEncodingWithGzip method as that one is not needed anymore. Thank you for the feedback!", "url": "https://github.com/elastic/elasticsearch/pull/53533#discussion_r402177821", "createdAt": "2020-04-02T09:31:23Z", "author": {"login": "Hakky54"}, "path": "client/rest-high-level/src/test/java/org/elasticsearch/client/RestHighLevelClientTests.java", "diffHunk": "@@ -320,6 +326,50 @@ public void testParseEntity() throws IOException {\n         }\n     }\n \n+    public void testParseCompressedEntity() throws IOException {\n+        CheckedFunction<XContentParser, String, IOException> entityParser = parser -> {\n+            assertEquals(XContentParser.Token.START_OBJECT, parser.nextToken());\n+            assertEquals(XContentParser.Token.FIELD_NAME, parser.nextToken());\n+            assertTrue(parser.nextToken().isValue());\n+            String value = parser.text();\n+            assertEquals(XContentParser.Token.END_OBJECT, parser.nextToken());\n+            return value;\n+        };\n+\n+        HttpEntity jsonEntity = new NByteArrayEntity(compress(\"{\\\"field\\\":\\\"value\\\"}\"), ContentType.APPLICATION_JSON);\n+        assertEquals(\"value\", restHighLevelClient.parseEntity(enrichHeaderContentEncodingWithGzip(jsonEntity), entityParser));\n+        HttpEntity yamlEntity = new NByteArrayEntity(compress(\"---\\nfield: value\\n\"), ContentType.create(\"application/yaml\"));\n+        assertEquals(\"value\", restHighLevelClient.parseEntity(enrichHeaderContentEncodingWithGzip(yamlEntity), entityParser));\n+        HttpEntity smileEntity = createCompressedBinaryEntity(SmileXContent.contentBuilder(), ContentType.create(\"application/smile\"));\n+        assertEquals(\"value\", restHighLevelClient.parseEntity(enrichHeaderContentEncodingWithGzip(smileEntity), entityParser));\n+        HttpEntity cborEntity = createCompressedBinaryEntity(CborXContent.contentBuilder(), ContentType.create(\"application/cbor\"));\n+        assertEquals(\"value\", restHighLevelClient.parseEntity(enrichHeaderContentEncodingWithGzip(cborEntity), entityParser));\n+    }\n+\n+    private static byte[] compress(String content) throws IOException {\n+        return compress(content.getBytes(StandardCharsets.ISO_8859_1));\n+    }\n+\n+    private static byte[] compress(byte[] content) throws IOException {\n+        ByteArrayOutputStream bos = new ByteArrayOutputStream(content.length);\n+        GZIPOutputStream gzip = new GZIPOutputStream(bos);\n+        gzip.write(content);\n+        gzip.close();\n+        bos.close();\n+\n+        return bos.toByteArray();\n+    }\n+\n+    private static HttpEntity enrichHeaderContentEncodingWithGzip(HttpEntity httpEntity) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTU2MDAzNQ=="}, "originalCommit": {"oid": "5aac2e6b8dd3ebd092def8a82231484ac9a664cf"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MDM2NjcwOnYy", "diffSide": "RIGHT", "path": "client/rest-high-level/src/test/java/org/elasticsearch/client/RestHighLevelClientTests.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxMTo1OTo0MVrOF-9UXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwOToxMDoxN1rOF_iLwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTU2MDY2OA==", "bodyText": "This might be subjective, but this is a bit hard to read. I find it hard to see what exactly is being tested. Would it be a bit easier to read if we extract the enriched header entities on a separate line above the assert statement?\nie. assertEquals(\"value\", restHighLevelClient.parseEntity(enrichHeaderContentEncodingWithGzip(jsonEntity), entityParser)); could become\nHttpEntity jsonEntity = createGzipEncodedEntity(\"{ ... }\"); \nassertThat(restHighLevelClient.parseEntity(jsonEntity, entityParser), is(\"value));", "url": "https://github.com/elastic/elasticsearch/pull/53533#discussion_r401560668", "createdAt": "2020-04-01T11:59:41Z", "author": {"login": "andreidan"}, "path": "client/rest-high-level/src/test/java/org/elasticsearch/client/RestHighLevelClientTests.java", "diffHunk": "@@ -320,6 +326,50 @@ public void testParseEntity() throws IOException {\n         }\n     }\n \n+    public void testParseCompressedEntity() throws IOException {\n+        CheckedFunction<XContentParser, String, IOException> entityParser = parser -> {\n+            assertEquals(XContentParser.Token.START_OBJECT, parser.nextToken());\n+            assertEquals(XContentParser.Token.FIELD_NAME, parser.nextToken());\n+            assertTrue(parser.nextToken().isValue());\n+            String value = parser.text();\n+            assertEquals(XContentParser.Token.END_OBJECT, parser.nextToken());\n+            return value;\n+        };\n+\n+        HttpEntity jsonEntity = new NByteArrayEntity(compress(\"{\\\"field\\\":\\\"value\\\"}\"), ContentType.APPLICATION_JSON);\n+        assertEquals(\"value\", restHighLevelClient.parseEntity(enrichHeaderContentEncodingWithGzip(jsonEntity), entityParser));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5aac2e6b8dd3ebd092def8a82231484ac9a664cf"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE2NDY3Mg==", "bodyText": "Yes, you are right. It is indeed hard to read. I have refactored it with your suggestion, hope it make easier to understand and more enjoyable to read", "url": "https://github.com/elastic/elasticsearch/pull/53533#discussion_r402164672", "createdAt": "2020-04-02T09:10:17Z", "author": {"login": "Hakky54"}, "path": "client/rest-high-level/src/test/java/org/elasticsearch/client/RestHighLevelClientTests.java", "diffHunk": "@@ -320,6 +326,50 @@ public void testParseEntity() throws IOException {\n         }\n     }\n \n+    public void testParseCompressedEntity() throws IOException {\n+        CheckedFunction<XContentParser, String, IOException> entityParser = parser -> {\n+            assertEquals(XContentParser.Token.START_OBJECT, parser.nextToken());\n+            assertEquals(XContentParser.Token.FIELD_NAME, parser.nextToken());\n+            assertTrue(parser.nextToken().isValue());\n+            String value = parser.text();\n+            assertEquals(XContentParser.Token.END_OBJECT, parser.nextToken());\n+            return value;\n+        };\n+\n+        HttpEntity jsonEntity = new NByteArrayEntity(compress(\"{\\\"field\\\":\\\"value\\\"}\"), ContentType.APPLICATION_JSON);\n+        assertEquals(\"value\", restHighLevelClient.parseEntity(enrichHeaderContentEncodingWithGzip(jsonEntity), entityParser));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTU2MDY2OA=="}, "originalCommit": {"oid": "5aac2e6b8dd3ebd092def8a82231484ac9a664cf"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MDM5NTU5OnYy", "diffSide": "RIGHT", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/RestHighLevelClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxMjowOTowMlrOF-9meA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwOToxNDoxMlrOF_iVYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTU2NTMwNA==", "bodyText": "super minor: shall we rename headerValue to gzipHeaderValue to point out we found the gzip encoding header?", "url": "https://github.com/elastic/elasticsearch/pull/53533#discussion_r401565304", "createdAt": "2020-04-01T12:09:02Z", "author": {"login": "andreidan"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/RestHighLevelClient.java", "diffHunk": "@@ -1872,11 +1874,18 @@ protected final ElasticsearchStatusException parseResponseException(ResponseExce\n         return elasticsearchException;\n     }\n \n-    protected final <Resp> Resp parseEntity(final HttpEntity entity,\n+    protected final <Resp> Resp parseEntity(final HttpEntity httpEntity,\n                                       final CheckedFunction<XContentParser, Resp, IOException> entityParser) throws IOException {\n-        if (entity == null) {\n+        if (httpEntity == null) {\n             throw new IllegalStateException(\"Response body expected but not returned\");\n         }\n+\n+        final HttpEntity entity = Optional.ofNullable(httpEntity.getContentEncoding())\n+            .map(Header::getValue)\n+            .filter(\"gzip\"::equalsIgnoreCase)\n+            .map(headerValue -> (HttpEntity) new GzipDecompressingEntity(httpEntity))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5aac2e6b8dd3ebd092def8a82231484ac9a664cf"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE2NzEzNw==", "bodyText": "Good suggestion, also applied!", "url": "https://github.com/elastic/elasticsearch/pull/53533#discussion_r402167137", "createdAt": "2020-04-02T09:14:12Z", "author": {"login": "Hakky54"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/RestHighLevelClient.java", "diffHunk": "@@ -1872,11 +1874,18 @@ protected final ElasticsearchStatusException parseResponseException(ResponseExce\n         return elasticsearchException;\n     }\n \n-    protected final <Resp> Resp parseEntity(final HttpEntity entity,\n+    protected final <Resp> Resp parseEntity(final HttpEntity httpEntity,\n                                       final CheckedFunction<XContentParser, Resp, IOException> entityParser) throws IOException {\n-        if (entity == null) {\n+        if (httpEntity == null) {\n             throw new IllegalStateException(\"Response body expected but not returned\");\n         }\n+\n+        final HttpEntity entity = Optional.ofNullable(httpEntity.getContentEncoding())\n+            .map(Header::getValue)\n+            .filter(\"gzip\"::equalsIgnoreCase)\n+            .map(headerValue -> (HttpEntity) new GzipDecompressingEntity(httpEntity))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTU2NTMwNA=="}, "originalCommit": {"oid": "5aac2e6b8dd3ebd092def8a82231484ac9a664cf"}, "originalPosition": 25}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3236, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}