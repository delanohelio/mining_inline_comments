{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQyNTQ2MDk0", "number": 58808, "title": "Enforce higher priority for RepositoriesService ClusterStateApplier", "bodyText": "This avoids shards allocation failures when the repository instance\ncomes in the same ClusterState update as the shard allocation.", "createdAt": "2020-07-01T08:54:28Z", "url": "https://github.com/elastic/elasticsearch/pull/58808", "merged": true, "mergeCommit": {"oid": "6cd9770f0f30b7073d5ef1f3b5485e9a40497f8c"}, "closed": true, "closedAt": "2020-07-03T10:30:25Z", "author": {"login": "fcofdez"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcwmRwXAH2gAyNDQyNTQ2MDk0OmVhNjc4MTE0M2I4NWU4YTJjNThkNjVhYzQxZGEyZjc5MzFhYWJjYzI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcxNjbXAFqTQ0MjE3Njg4OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "ea6781143b85e8a2c58d65ac41da2f7931aabcc2", "author": {"user": {"login": "fcofdez", "name": "Francisco Fern\u00e1ndez Casta\u00f1o"}}, "url": "https://github.com/elastic/elasticsearch/commit/ea6781143b85e8a2c58d65ac41da2f7931aabcc2", "committedDate": "2020-07-01T08:50:14Z", "message": "Enforce higher priority for RepositoriesService ClusterStateApplier\n\nThis avoids shards allocation failures when the repository instance\ncomes in the same ClusterState update as the shard allocation."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwNzgyNjA0", "url": "https://github.com/elastic/elasticsearch/pull/58808#pullrequestreview-440782604", "createdAt": "2020-07-01T11:27:06Z", "commit": {"oid": "ea6781143b85e8a2c58d65ac41da2f7931aabcc2"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMToyNzowNlrOGrh8kA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMTo1MzowMlrOGritNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI5ODEyOA==", "bodyText": "Why autoManageMasterNodes = false?", "url": "https://github.com/elastic/elasticsearch/pull/58808#discussion_r448298128", "createdAt": "2020-07-01T11:27:06Z", "author": {"login": "ywelsch"}, "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/xpack/searchablesnapshots/ClusterStateApplierOrderingTests.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.searchablesnapshots;\n+\n+import org.elasticsearch.action.admin.cluster.snapshots.create.CreateSnapshotResponse;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotResponse;\n+import org.elasticsearch.action.index.IndexRequestBuilder;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.routing.RoutingNode;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.UnassignedInfo;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.IndexSettings;\n+import org.elasticsearch.snapshots.SnapshotInfo;\n+import org.elasticsearch.test.ESIntegTestCase;\n+import org.elasticsearch.xpack.core.searchablesnapshots.MountSearchableSnapshotAction;\n+import org.elasticsearch.xpack.core.searchablesnapshots.MountSearchableSnapshotRequest;\n+\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Locale;\n+\n+import static org.elasticsearch.cluster.routing.UnassignedInfo.Reason.ALLOCATION_FAILED;\n+import static org.elasticsearch.index.IndexSettings.INDEX_SOFT_DELETES_SETTING;\n+import static org.elasticsearch.test.ESIntegTestCase.Scope.TEST;\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThan;\n+import static org.hamcrest.Matchers.is;\n+\n+@ESIntegTestCase.ClusterScope(scope = TEST, numDataNodes = 0, autoManageMasterNodes = false)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea6781143b85e8a2c58d65ac41da2f7931aabcc2"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI5OTE4NA==", "bodyText": "I think all the randomization above here is not needed and just unnecessarily making the test more complicated than need be. Just use string literals directly in the code.", "url": "https://github.com/elastic/elasticsearch/pull/58808#discussion_r448299184", "createdAt": "2020-07-01T11:29:03Z", "author": {"login": "ywelsch"}, "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/xpack/searchablesnapshots/ClusterStateApplierOrderingTests.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.searchablesnapshots;\n+\n+import org.elasticsearch.action.admin.cluster.snapshots.create.CreateSnapshotResponse;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotResponse;\n+import org.elasticsearch.action.index.IndexRequestBuilder;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.routing.RoutingNode;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.UnassignedInfo;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.IndexSettings;\n+import org.elasticsearch.snapshots.SnapshotInfo;\n+import org.elasticsearch.test.ESIntegTestCase;\n+import org.elasticsearch.xpack.core.searchablesnapshots.MountSearchableSnapshotAction;\n+import org.elasticsearch.xpack.core.searchablesnapshots.MountSearchableSnapshotRequest;\n+\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Locale;\n+\n+import static org.elasticsearch.cluster.routing.UnassignedInfo.Reason.ALLOCATION_FAILED;\n+import static org.elasticsearch.index.IndexSettings.INDEX_SOFT_DELETES_SETTING;\n+import static org.elasticsearch.test.ESIntegTestCase.Scope.TEST;\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThan;\n+import static org.hamcrest.Matchers.is;\n+\n+@ESIntegTestCase.ClusterScope(scope = TEST, numDataNodes = 0, autoManageMasterNodes = false)\n+public class ClusterStateApplierOrderingTests extends BaseSearchableSnapshotsIntegTestCase {\n+\n+    public void testRepositoriesServiceClusterStateApplierIsCalledBeforeIndicesClusterStateService() throws Exception {\n+        final String fsRepoName = randomAlphaOfLength(10);\n+        final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        final String restoredIndexName = randomBoolean() ? indexName : randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        final String snapshotName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea6781143b85e8a2c58d65ac41da2f7931aabcc2"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMwMDE4OA==", "bodyText": "add a note that this restriction can be lifted when #55142 is resolved.", "url": "https://github.com/elastic/elasticsearch/pull/58808#discussion_r448300188", "createdAt": "2020-07-01T11:31:10Z", "author": {"login": "ywelsch"}, "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/xpack/searchablesnapshots/ClusterStateApplierOrderingTests.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.searchablesnapshots;\n+\n+import org.elasticsearch.action.admin.cluster.snapshots.create.CreateSnapshotResponse;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotResponse;\n+import org.elasticsearch.action.index.IndexRequestBuilder;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.routing.RoutingNode;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.UnassignedInfo;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.IndexSettings;\n+import org.elasticsearch.snapshots.SnapshotInfo;\n+import org.elasticsearch.test.ESIntegTestCase;\n+import org.elasticsearch.xpack.core.searchablesnapshots.MountSearchableSnapshotAction;\n+import org.elasticsearch.xpack.core.searchablesnapshots.MountSearchableSnapshotRequest;\n+\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Locale;\n+\n+import static org.elasticsearch.cluster.routing.UnassignedInfo.Reason.ALLOCATION_FAILED;\n+import static org.elasticsearch.index.IndexSettings.INDEX_SOFT_DELETES_SETTING;\n+import static org.elasticsearch.test.ESIntegTestCase.Scope.TEST;\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThan;\n+import static org.hamcrest.Matchers.is;\n+\n+@ESIntegTestCase.ClusterScope(scope = TEST, numDataNodes = 0, autoManageMasterNodes = false)\n+public class ClusterStateApplierOrderingTests extends BaseSearchableSnapshotsIntegTestCase {\n+\n+    public void testRepositoriesServiceClusterStateApplierIsCalledBeforeIndicesClusterStateService() throws Exception {\n+        final String fsRepoName = randomAlphaOfLength(10);\n+        final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        final String restoredIndexName = randomBoolean() ? indexName : randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        final String snapshotName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+\n+        // The scenario is easily reproducible with a 2 node (data and master) cluster\n+        internalCluster().setBootstrapMasterNodeIndex(1);\n+        internalCluster().startNodes(2);\n+        ensureStableCluster(2);\n+\n+        final Path repo = randomRepoPath();\n+        assertAcked(\n+            client().admin().cluster().preparePutRepository(fsRepoName).setType(\"fs\").setSettings(Settings.builder().put(\"location\", repo))\n+        );\n+\n+        assertAcked(prepareCreate(indexName, Settings.builder().put(INDEX_SOFT_DELETES_SETTING.getKey(), true)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea6781143b85e8a2c58d65ac41da2f7931aabcc2"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMxMDU4MQ==", "bodyText": "Isn't this racing against state recovery and the actual allocation taking place? We might be adding the listener too late. Perhaps we should delay state recovery (for example by setting gateway.recover_after_data_nodes to 3 on restart, and start up a third data node after the listener is registered (on the master)).", "url": "https://github.com/elastic/elasticsearch/pull/58808#discussion_r448310581", "createdAt": "2020-07-01T11:53:02Z", "author": {"login": "ywelsch"}, "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/xpack/searchablesnapshots/ClusterStateApplierOrderingTests.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.searchablesnapshots;\n+\n+import org.elasticsearch.action.admin.cluster.snapshots.create.CreateSnapshotResponse;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotResponse;\n+import org.elasticsearch.action.index.IndexRequestBuilder;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.routing.RoutingNode;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.UnassignedInfo;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.IndexSettings;\n+import org.elasticsearch.snapshots.SnapshotInfo;\n+import org.elasticsearch.test.ESIntegTestCase;\n+import org.elasticsearch.xpack.core.searchablesnapshots.MountSearchableSnapshotAction;\n+import org.elasticsearch.xpack.core.searchablesnapshots.MountSearchableSnapshotRequest;\n+\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Locale;\n+\n+import static org.elasticsearch.cluster.routing.UnassignedInfo.Reason.ALLOCATION_FAILED;\n+import static org.elasticsearch.index.IndexSettings.INDEX_SOFT_DELETES_SETTING;\n+import static org.elasticsearch.test.ESIntegTestCase.Scope.TEST;\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThan;\n+import static org.hamcrest.Matchers.is;\n+\n+@ESIntegTestCase.ClusterScope(scope = TEST, numDataNodes = 0, autoManageMasterNodes = false)\n+public class ClusterStateApplierOrderingTests extends BaseSearchableSnapshotsIntegTestCase {\n+\n+    public void testRepositoriesServiceClusterStateApplierIsCalledBeforeIndicesClusterStateService() throws Exception {\n+        final String fsRepoName = randomAlphaOfLength(10);\n+        final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        final String restoredIndexName = randomBoolean() ? indexName : randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        final String snapshotName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+\n+        // The scenario is easily reproducible with a 2 node (data and master) cluster\n+        internalCluster().setBootstrapMasterNodeIndex(1);\n+        internalCluster().startNodes(2);\n+        ensureStableCluster(2);\n+\n+        final Path repo = randomRepoPath();\n+        assertAcked(\n+            client().admin().cluster().preparePutRepository(fsRepoName).setType(\"fs\").setSettings(Settings.builder().put(\"location\", repo))\n+        );\n+\n+        assertAcked(prepareCreate(indexName, Settings.builder().put(INDEX_SOFT_DELETES_SETTING.getKey(), true)));\n+\n+        final List<IndexRequestBuilder> indexRequestBuilders = new ArrayList<>();\n+        for (int i = between(10, 10_000); i >= 0; i--) {\n+            indexRequestBuilders.add(client().prepareIndex(indexName).setSource(\"foo\", randomBoolean() ? \"bar\" : \"baz\"));\n+        }\n+        indexRandom(true, true, indexRequestBuilders);\n+        refresh(indexName);\n+\n+        CreateSnapshotResponse createSnapshotResponse = client().admin()\n+            .cluster()\n+            .prepareCreateSnapshot(fsRepoName, snapshotName)\n+            .setWaitForCompletion(true)\n+            .get();\n+        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo();\n+        assertThat(snapshotInfo.successfulShards(), greaterThan(0));\n+        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()));\n+\n+        assertAcked(client().admin().indices().prepareDelete(indexName));\n+\n+        Settings.Builder indexSettingsBuilder = Settings.builder()\n+            .put(SearchableSnapshots.SNAPSHOT_CACHE_ENABLED_SETTING.getKey(), false)\n+            .put(IndexSettings.INDEX_CHECK_ON_STARTUP.getKey(), Boolean.FALSE.toString())\n+            .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0);\n+\n+        final MountSearchableSnapshotRequest req = new MountSearchableSnapshotRequest(\n+            restoredIndexName,\n+            fsRepoName,\n+            snapshotInfo.snapshotId().getName(),\n+            indexName,\n+            indexSettingsBuilder.build(),\n+            Strings.EMPTY_ARRAY,\n+            true\n+        );\n+\n+        final RestoreSnapshotResponse restoreSnapshotResponse = client().execute(MountSearchableSnapshotAction.INSTANCE, req).get();\n+        assertThat(restoreSnapshotResponse.getRestoreInfo().failedShards(), equalTo(0));\n+\n+        ensureGreen(restoredIndexName);\n+\n+        // In order to reproduce this issue we need to force a full cluster restart so the new elected master\n+        // sends the entire ClusterState in one message, including assigned shards and repositories.\n+        internalCluster().fullRestart();\n+\n+        List<UnassignedInfo.Reason> unassignedReasons = new ArrayList<>();\n+        internalCluster().clusterService().addListener(event -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea6781143b85e8a2c58d65ac41da2f7931aabcc2"}, "originalPosition": 101}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "690b00c6fc6e25d93ae49ff967da3fa9b3d6ceee", "author": {"user": {"login": "fcofdez", "name": "Francisco Fern\u00e1ndez Casta\u00f1o"}}, "url": "https://github.com/elastic/elasticsearch/commit/690b00c6fc6e25d93ae49ff967da3fa9b3d6ceee", "committedDate": "2020-07-01T16:18:45Z", "message": "Address review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "af5696e5d95d63acd823305854e7fa4cd2b3ce82", "author": {"user": {"login": "fcofdez", "name": "Francisco Fern\u00e1ndez Casta\u00f1o"}}, "url": "https://github.com/elastic/elasticsearch/commit/af5696e5d95d63acd823305854e7fa4cd2b3ce82", "committedDate": "2020-07-01T16:46:41Z", "message": "Merge remote-tracking branch 'origin/master' into repository-not-found-shard-failure"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyMTc2ODg5", "url": "https://github.com/elastic/elasticsearch/pull/58808#pullrequestreview-442176889", "createdAt": "2020-07-03T06:35:50Z", "commit": {"oid": "af5696e5d95d63acd823305854e7fa4cd2b3ce82"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2461, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}