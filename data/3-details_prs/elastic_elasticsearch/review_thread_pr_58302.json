{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM2Mjg4NTc4", "number": 58302, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMTo0MDozN1rOEJGhhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMzozMjowOVrOEJIlMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3OTc5NTI1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/job/messages/Messages.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMTo0MDozN1rOGpdwMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMjoyMTo1M1rOGpe1Pw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEzMjI3NA==", "bodyText": "change status to state", "url": "https://github.com/elastic/elasticsearch/pull/58302#discussion_r446132274", "createdAt": "2020-06-26T11:40:37Z", "author": {"login": "dimitris-athanasiou"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/job/messages/Messages.java", "diffHunk": "@@ -74,6 +74,8 @@\n     public static final String DATA_FRAME_ANALYTICS_AUDIT_STARTED_LOADING_DATA = \"Started loading data\";\n     public static final String DATA_FRAME_ANALYTICS_AUDIT_STARTED_ANALYZING = \"Started analyzing\";\n     public static final String DATA_FRAME_ANALYTICS_AUDIT_STARTED_WRITING_RESULTS = \"Started writing results\";\n+    public static final String DATA_FRAME_ANALYTICS_CANNOT_UPDATE_IN_CURRENT_STATE =\n+        \"Cannot update analytics [{0}] while its status is {1}\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59b322175757e47639deda719ec80d98ee2ad026"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEzMjYzNg==", "bodyText": "I also wonder here if it'd be more informative to say that we cannot update the job unless its in the stopped state. What do you think", "url": "https://github.com/elastic/elasticsearch/pull/58302#discussion_r446132636", "createdAt": "2020-06-26T11:41:30Z", "author": {"login": "dimitris-athanasiou"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/job/messages/Messages.java", "diffHunk": "@@ -74,6 +74,8 @@\n     public static final String DATA_FRAME_ANALYTICS_AUDIT_STARTED_LOADING_DATA = \"Started loading data\";\n     public static final String DATA_FRAME_ANALYTICS_AUDIT_STARTED_ANALYZING = \"Started analyzing\";\n     public static final String DATA_FRAME_ANALYTICS_AUDIT_STARTED_WRITING_RESULTS = \"Started writing results\";\n+    public static final String DATA_FRAME_ANALYTICS_CANNOT_UPDATE_IN_CURRENT_STATE =\n+        \"Cannot update analytics [{0}] while its status is {1}\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEzMjI3NA=="}, "originalCommit": {"oid": "59b322175757e47639deda719ec80d98ee2ad026"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEzNDQwNg==", "bodyText": "Also, if we keep as is, we should wrap {1}in square brackets.", "url": "https://github.com/elastic/elasticsearch/pull/58302#discussion_r446134406", "createdAt": "2020-06-26T11:45:57Z", "author": {"login": "dimitris-athanasiou"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/job/messages/Messages.java", "diffHunk": "@@ -74,6 +74,8 @@\n     public static final String DATA_FRAME_ANALYTICS_AUDIT_STARTED_LOADING_DATA = \"Started loading data\";\n     public static final String DATA_FRAME_ANALYTICS_AUDIT_STARTED_ANALYZING = \"Started analyzing\";\n     public static final String DATA_FRAME_ANALYTICS_AUDIT_STARTED_WRITING_RESULTS = \"Started writing results\";\n+    public static final String DATA_FRAME_ANALYTICS_CANNOT_UPDATE_IN_CURRENT_STATE =\n+        \"Cannot update analytics [{0}] while its status is {1}\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEzMjI3NA=="}, "originalCommit": {"oid": "59b322175757e47639deda719ec80d98ee2ad026"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE0OTk1MQ==", "bodyText": "I also wonder here if it'd be more informative to say that we cannot update the job unless its in the stopped state. What do you think\n\nSGTM", "url": "https://github.com/elastic/elasticsearch/pull/58302#discussion_r446149951", "createdAt": "2020-06-26T12:21:53Z", "author": {"login": "przemekwitek"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/job/messages/Messages.java", "diffHunk": "@@ -74,6 +74,8 @@\n     public static final String DATA_FRAME_ANALYTICS_AUDIT_STARTED_LOADING_DATA = \"Started loading data\";\n     public static final String DATA_FRAME_ANALYTICS_AUDIT_STARTED_ANALYZING = \"Started analyzing\";\n     public static final String DATA_FRAME_ANALYTICS_AUDIT_STARTED_WRITING_RESULTS = \"Started writing results\";\n+    public static final String DATA_FRAME_ANALYTICS_CANNOT_UPDATE_IN_CURRENT_STATE =\n+        \"Cannot update analytics [{0}] while its status is {1}\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEzMjI3NA=="}, "originalCommit": {"oid": "59b322175757e47639deda719ec80d98ee2ad026"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3OTgwMDk5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ml/dataframe/DataFrameAnalyticsConfigUpdateTests.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMTo0Mjo1MVrOGpdz0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMjowNjoyMlrOGpea3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEzMzIwMw==", "bodyText": "I'd rather we split this in 4 tests with names for each property that is updated. The reason I think that's beneficial, is that if the test fails, the test title immediately tells us what went wrong.", "url": "https://github.com/elastic/elasticsearch/pull/58302#discussion_r446133203", "createdAt": "2020-06-26T11:42:51Z", "author": {"login": "dimitris-athanasiou"}, "path": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ml/dataframe/DataFrameAnalyticsConfigUpdateTests.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ml.dataframe;\n+\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.unit.ByteSizeValue;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.test.AbstractSerializingTestCase;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.xpack.core.ml.dataframe.DataFrameAnalyticsConfigTests.randomValidId;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.not;\n+\n+public class DataFrameAnalyticsConfigUpdateTests extends AbstractSerializingTestCase<DataFrameAnalyticsConfigUpdate> {\n+\n+    @Override\n+    protected DataFrameAnalyticsConfigUpdate doParseInstance(XContentParser parser) throws IOException {\n+        return DataFrameAnalyticsConfigUpdate.PARSER.apply(parser, null).build();\n+    }\n+\n+    @Override\n+    protected DataFrameAnalyticsConfigUpdate createTestInstance() {\n+        return randomUpdate(randomValidId());\n+    }\n+\n+    @Override\n+    protected Writeable.Reader<DataFrameAnalyticsConfigUpdate> instanceReader() {\n+        return DataFrameAnalyticsConfigUpdate::new;\n+    }\n+\n+    public static DataFrameAnalyticsConfigUpdate randomUpdate(String id) {\n+        DataFrameAnalyticsConfigUpdate.Builder builder = new DataFrameAnalyticsConfigUpdate.Builder(id);\n+        if (randomBoolean()) {\n+            builder.setDescription(randomAlphaOfLength(20));\n+        }\n+        if (randomBoolean()) {\n+            builder.setModelMemoryLimit(new ByteSizeValue(randomNonNegativeLong()));\n+        }\n+        if (randomBoolean()) {\n+            builder.setAllowLazyStart(randomBoolean());\n+        }\n+        return builder.build();\n+    }\n+\n+    public void testMergeWithConfig() {\n+        String id = randomValidId();\n+        {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59b322175757e47639deda719ec80d98ee2ad026"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE0MzE5OQ==", "bodyText": "Done.", "url": "https://github.com/elastic/elasticsearch/pull/58302#discussion_r446143199", "createdAt": "2020-06-26T12:06:22Z", "author": {"login": "przemekwitek"}, "path": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ml/dataframe/DataFrameAnalyticsConfigUpdateTests.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ml.dataframe;\n+\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.unit.ByteSizeValue;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.test.AbstractSerializingTestCase;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.xpack.core.ml.dataframe.DataFrameAnalyticsConfigTests.randomValidId;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.not;\n+\n+public class DataFrameAnalyticsConfigUpdateTests extends AbstractSerializingTestCase<DataFrameAnalyticsConfigUpdate> {\n+\n+    @Override\n+    protected DataFrameAnalyticsConfigUpdate doParseInstance(XContentParser parser) throws IOException {\n+        return DataFrameAnalyticsConfigUpdate.PARSER.apply(parser, null).build();\n+    }\n+\n+    @Override\n+    protected DataFrameAnalyticsConfigUpdate createTestInstance() {\n+        return randomUpdate(randomValidId());\n+    }\n+\n+    @Override\n+    protected Writeable.Reader<DataFrameAnalyticsConfigUpdate> instanceReader() {\n+        return DataFrameAnalyticsConfigUpdate::new;\n+    }\n+\n+    public static DataFrameAnalyticsConfigUpdate randomUpdate(String id) {\n+        DataFrameAnalyticsConfigUpdate.Builder builder = new DataFrameAnalyticsConfigUpdate.Builder(id);\n+        if (randomBoolean()) {\n+            builder.setDescription(randomAlphaOfLength(20));\n+        }\n+        if (randomBoolean()) {\n+            builder.setModelMemoryLimit(new ByteSizeValue(randomNonNegativeLong()));\n+        }\n+        if (randomBoolean()) {\n+            builder.setAllowLazyStart(randomBoolean());\n+        }\n+        return builder.build();\n+    }\n+\n+    public void testMergeWithConfig() {\n+        String id = randomValidId();\n+        {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEzMzIwMw=="}, "originalCommit": {"oid": "59b322175757e47639deda719ec80d98ee2ad026"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3OTgxMzA1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/dataframe/persistence/DataFrameAnalyticsConfigProvider.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMTo0NzozNlrOGpd7Nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMzozMTowNFrOGpg_XQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEzNTA5NQ==", "bodyText": "We should be able to use the local get method to avoid having to handle parsing here.", "url": "https://github.com/elastic/elasticsearch/pull/58302#discussion_r446135095", "createdAt": "2020-06-26T11:47:36Z", "author": {"login": "dimitris-athanasiou"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/dataframe/persistence/DataFrameAnalyticsConfigProvider.java", "diffHunk": "@@ -68,28 +77,116 @@ public DataFrameAnalyticsConfigProvider(Client client, NamedXContentRegistry xCo\n         this.xContentRegistry = xContentRegistry;\n     }\n \n-    public void put(DataFrameAnalyticsConfig config, Map<String, String> headers, ActionListener<IndexResponse> listener) {\n-        String id = config.getId();\n-\n+    /**\n+     * Puts the given {@link DataFrameAnalyticsConfig} document into the config index.\n+     */\n+    public void put(DataFrameAnalyticsConfig config, Map<String, String> headers, ActionListener<DataFrameAnalyticsConfig> listener) {\n         if (headers.isEmpty() == false) {\n             // Filter any values in headers that aren't security fields\n             config = new DataFrameAnalyticsConfig.Builder(config)\n                 .setHeaders(filterSecurityHeaders(headers))\n                 .build();\n         }\n+        index(config, null, listener);\n+    }\n+\n+    /**\n+     * Updates the {@link DataFrameAnalyticsConfig} document in the config index using given {@link DataFrameAnalyticsConfigUpdate}.\n+     */\n+    public void update(DataFrameAnalyticsConfigUpdate update,\n+                       Map<String, String> headers,\n+                       ClusterState clusterState,\n+                       ActionListener<DataFrameAnalyticsConfig> listener) {\n+        String id = update.getId();\n+        GetRequest getRequest = new GetRequest(MlConfigIndex.indexName(), DataFrameAnalyticsConfig.documentId(id));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59b322175757e47639deda719ec80d98ee2ad026"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE0OTI2Mg==", "bodyText": "What do you think would be the right place to store getSeqNo and getPrimaryTerm then?\nShould I extend GetDataFrameAnalyticsAction.Response with these 2 fields?\nOr maybe even extend the base response class (AbstractGetResourcesResponse)?", "url": "https://github.com/elastic/elasticsearch/pull/58302#discussion_r446149262", "createdAt": "2020-06-26T12:20:24Z", "author": {"login": "przemekwitek"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/dataframe/persistence/DataFrameAnalyticsConfigProvider.java", "diffHunk": "@@ -68,28 +77,116 @@ public DataFrameAnalyticsConfigProvider(Client client, NamedXContentRegistry xCo\n         this.xContentRegistry = xContentRegistry;\n     }\n \n-    public void put(DataFrameAnalyticsConfig config, Map<String, String> headers, ActionListener<IndexResponse> listener) {\n-        String id = config.getId();\n-\n+    /**\n+     * Puts the given {@link DataFrameAnalyticsConfig} document into the config index.\n+     */\n+    public void put(DataFrameAnalyticsConfig config, Map<String, String> headers, ActionListener<DataFrameAnalyticsConfig> listener) {\n         if (headers.isEmpty() == false) {\n             // Filter any values in headers that aren't security fields\n             config = new DataFrameAnalyticsConfig.Builder(config)\n                 .setHeaders(filterSecurityHeaders(headers))\n                 .build();\n         }\n+        index(config, null, listener);\n+    }\n+\n+    /**\n+     * Updates the {@link DataFrameAnalyticsConfig} document in the config index using given {@link DataFrameAnalyticsConfigUpdate}.\n+     */\n+    public void update(DataFrameAnalyticsConfigUpdate update,\n+                       Map<String, String> headers,\n+                       ClusterState clusterState,\n+                       ActionListener<DataFrameAnalyticsConfig> listener) {\n+        String id = update.getId();\n+        GetRequest getRequest = new GetRequest(MlConfigIndex.indexName(), DataFrameAnalyticsConfig.documentId(id));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEzNTA5NQ=="}, "originalCommit": {"oid": "59b322175757e47639deda719ec80d98ee2ad026"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE4NTMwOQ==", "bodyText": "Oh, I see. This is why you had to get the doc directly. Sorry, I missed that. Hm, I'd say let's leave this as is then for now.", "url": "https://github.com/elastic/elasticsearch/pull/58302#discussion_r446185309", "createdAt": "2020-06-26T13:31:04Z", "author": {"login": "dimitris-athanasiou"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/dataframe/persistence/DataFrameAnalyticsConfigProvider.java", "diffHunk": "@@ -68,28 +77,116 @@ public DataFrameAnalyticsConfigProvider(Client client, NamedXContentRegistry xCo\n         this.xContentRegistry = xContentRegistry;\n     }\n \n-    public void put(DataFrameAnalyticsConfig config, Map<String, String> headers, ActionListener<IndexResponse> listener) {\n-        String id = config.getId();\n-\n+    /**\n+     * Puts the given {@link DataFrameAnalyticsConfig} document into the config index.\n+     */\n+    public void put(DataFrameAnalyticsConfig config, Map<String, String> headers, ActionListener<DataFrameAnalyticsConfig> listener) {\n         if (headers.isEmpty() == false) {\n             // Filter any values in headers that aren't security fields\n             config = new DataFrameAnalyticsConfig.Builder(config)\n                 .setHeaders(filterSecurityHeaders(headers))\n                 .build();\n         }\n+        index(config, null, listener);\n+    }\n+\n+    /**\n+     * Updates the {@link DataFrameAnalyticsConfig} document in the config index using given {@link DataFrameAnalyticsConfigUpdate}.\n+     */\n+    public void update(DataFrameAnalyticsConfigUpdate update,\n+                       Map<String, String> headers,\n+                       ClusterState clusterState,\n+                       ActionListener<DataFrameAnalyticsConfig> listener) {\n+        String id = update.getId();\n+        GetRequest getRequest = new GetRequest(MlConfigIndex.indexName(), DataFrameAnalyticsConfig.documentId(id));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEzNTA5NQ=="}, "originalCommit": {"oid": "59b322175757e47639deda719ec80d98ee2ad026"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3OTgxNjI4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/dataframe/persistence/DataFrameAnalyticsConfigProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMTo0ODo1OVrOGpd9cQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMjoxNDo0MlrOGpeoeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEzNTY2NQ==", "bodyText": "I would suggest adding a boolean requiresRestart() in DataFrameAnalyticsConfigUpdate. This will make the code more readable without the comment plus it will create a space ready for extending it with other properties that require restart.", "url": "https://github.com/elastic/elasticsearch/pull/58302#discussion_r446135665", "createdAt": "2020-06-26T11:48:59Z", "author": {"login": "dimitris-athanasiou"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/dataframe/persistence/DataFrameAnalyticsConfigProvider.java", "diffHunk": "@@ -68,28 +77,116 @@ public DataFrameAnalyticsConfigProvider(Client client, NamedXContentRegistry xCo\n         this.xContentRegistry = xContentRegistry;\n     }\n \n-    public void put(DataFrameAnalyticsConfig config, Map<String, String> headers, ActionListener<IndexResponse> listener) {\n-        String id = config.getId();\n-\n+    /**\n+     * Puts the given {@link DataFrameAnalyticsConfig} document into the config index.\n+     */\n+    public void put(DataFrameAnalyticsConfig config, Map<String, String> headers, ActionListener<DataFrameAnalyticsConfig> listener) {\n         if (headers.isEmpty() == false) {\n             // Filter any values in headers that aren't security fields\n             config = new DataFrameAnalyticsConfig.Builder(config)\n                 .setHeaders(filterSecurityHeaders(headers))\n                 .build();\n         }\n+        index(config, null, listener);\n+    }\n+\n+    /**\n+     * Updates the {@link DataFrameAnalyticsConfig} document in the config index using given {@link DataFrameAnalyticsConfigUpdate}.\n+     */\n+    public void update(DataFrameAnalyticsConfigUpdate update,\n+                       Map<String, String> headers,\n+                       ClusterState clusterState,\n+                       ActionListener<DataFrameAnalyticsConfig> listener) {\n+        String id = update.getId();\n+        GetRequest getRequest = new GetRequest(MlConfigIndex.indexName(), DataFrameAnalyticsConfig.documentId(id));\n+        executeAsyncWithOrigin(client, ML_ORIGIN, GetAction.INSTANCE, getRequest, ActionListener.wrap(\n+            getResponse -> {\n+\n+                // Fail the update request if the config to be updated doesn't exist\n+                if (getResponse.isExists() == false) {\n+                    listener.onFailure(ExceptionsHelper.missingDataFrameAnalytics(id));\n+                    return;\n+                }\n+\n+                // Parse the original config\n+                DataFrameAnalyticsConfig originalConfig;\n+                try {\n+                    try (InputStream stream = getResponse.getSourceAsBytesRef().streamInput();\n+                         XContentParser parser = XContentFactory.xContent(XContentType.JSON)\n+                             .createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, stream)) {\n+                        originalConfig = DataFrameAnalyticsConfig.LENIENT_PARSER.apply(parser, null).build();\n+                    }\n+                } catch (IOException e) {\n+                    listener.onFailure(\n+                        new ElasticsearchParseException(\"Failed to parse data frame analytics configuration [\" + id + \"]\", e));\n+                    return;\n+                }\n+\n+                // Check that the update can be applied given current analytics state\n+                checkUpdateCanBeApplied(originalConfig, update, clusterState);\n+\n+                // Merge the original config with the given update object\n+                DataFrameAnalyticsConfig.Builder updatedConfigBuilder = update.mergeWithConfig(originalConfig);\n+                if (headers.isEmpty() == false) {\n+                    updatedConfigBuilder.setHeaders(filterSecurityHeaders(headers));\n+                }\n+                DataFrameAnalyticsConfig updatedConfig = updatedConfigBuilder.build();\n+\n+                // Index the update config\n+                index(updatedConfig, getResponse, listener);\n+            },\n+            listener::onFailure\n+        ));\n+    }\n+\n+    private static void checkUpdateCanBeApplied(DataFrameAnalyticsConfig originalConfig,\n+                                                DataFrameAnalyticsConfigUpdate update,\n+                                                ClusterState clusterState) {\n+        String analyticsId = update.getId();\n+        PersistentTasksCustomMetadata tasks = clusterState.getMetadata().custom(PersistentTasksCustomMetadata.TYPE);\n+        DataFrameAnalyticsState analyticsState = MlTasks.getDataFrameAnalyticsState(analyticsId, tasks);\n+        if (DataFrameAnalyticsState.STOPPED.equals(analyticsState)) {\n+            // Analytics is stopped, therefore it is safe to proceed with the udpate\n+            return;\n+        }\n+        // Changing model memory limit requires task restart, therefore it cannot be safely updated when the task is running\n+        if (update.getModelMemoryLimit() != null && update.getModelMemoryLimit().equals(originalConfig.getModelMemoryLimit()) == false) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59b322175757e47639deda719ec80d98ee2ad026"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE0NjY4MA==", "bodyText": "Done.", "url": "https://github.com/elastic/elasticsearch/pull/58302#discussion_r446146680", "createdAt": "2020-06-26T12:14:42Z", "author": {"login": "przemekwitek"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/dataframe/persistence/DataFrameAnalyticsConfigProvider.java", "diffHunk": "@@ -68,28 +77,116 @@ public DataFrameAnalyticsConfigProvider(Client client, NamedXContentRegistry xCo\n         this.xContentRegistry = xContentRegistry;\n     }\n \n-    public void put(DataFrameAnalyticsConfig config, Map<String, String> headers, ActionListener<IndexResponse> listener) {\n-        String id = config.getId();\n-\n+    /**\n+     * Puts the given {@link DataFrameAnalyticsConfig} document into the config index.\n+     */\n+    public void put(DataFrameAnalyticsConfig config, Map<String, String> headers, ActionListener<DataFrameAnalyticsConfig> listener) {\n         if (headers.isEmpty() == false) {\n             // Filter any values in headers that aren't security fields\n             config = new DataFrameAnalyticsConfig.Builder(config)\n                 .setHeaders(filterSecurityHeaders(headers))\n                 .build();\n         }\n+        index(config, null, listener);\n+    }\n+\n+    /**\n+     * Updates the {@link DataFrameAnalyticsConfig} document in the config index using given {@link DataFrameAnalyticsConfigUpdate}.\n+     */\n+    public void update(DataFrameAnalyticsConfigUpdate update,\n+                       Map<String, String> headers,\n+                       ClusterState clusterState,\n+                       ActionListener<DataFrameAnalyticsConfig> listener) {\n+        String id = update.getId();\n+        GetRequest getRequest = new GetRequest(MlConfigIndex.indexName(), DataFrameAnalyticsConfig.documentId(id));\n+        executeAsyncWithOrigin(client, ML_ORIGIN, GetAction.INSTANCE, getRequest, ActionListener.wrap(\n+            getResponse -> {\n+\n+                // Fail the update request if the config to be updated doesn't exist\n+                if (getResponse.isExists() == false) {\n+                    listener.onFailure(ExceptionsHelper.missingDataFrameAnalytics(id));\n+                    return;\n+                }\n+\n+                // Parse the original config\n+                DataFrameAnalyticsConfig originalConfig;\n+                try {\n+                    try (InputStream stream = getResponse.getSourceAsBytesRef().streamInput();\n+                         XContentParser parser = XContentFactory.xContent(XContentType.JSON)\n+                             .createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, stream)) {\n+                        originalConfig = DataFrameAnalyticsConfig.LENIENT_PARSER.apply(parser, null).build();\n+                    }\n+                } catch (IOException e) {\n+                    listener.onFailure(\n+                        new ElasticsearchParseException(\"Failed to parse data frame analytics configuration [\" + id + \"]\", e));\n+                    return;\n+                }\n+\n+                // Check that the update can be applied given current analytics state\n+                checkUpdateCanBeApplied(originalConfig, update, clusterState);\n+\n+                // Merge the original config with the given update object\n+                DataFrameAnalyticsConfig.Builder updatedConfigBuilder = update.mergeWithConfig(originalConfig);\n+                if (headers.isEmpty() == false) {\n+                    updatedConfigBuilder.setHeaders(filterSecurityHeaders(headers));\n+                }\n+                DataFrameAnalyticsConfig updatedConfig = updatedConfigBuilder.build();\n+\n+                // Index the update config\n+                index(updatedConfig, getResponse, listener);\n+            },\n+            listener::onFailure\n+        ));\n+    }\n+\n+    private static void checkUpdateCanBeApplied(DataFrameAnalyticsConfig originalConfig,\n+                                                DataFrameAnalyticsConfigUpdate update,\n+                                                ClusterState clusterState) {\n+        String analyticsId = update.getId();\n+        PersistentTasksCustomMetadata tasks = clusterState.getMetadata().custom(PersistentTasksCustomMetadata.TYPE);\n+        DataFrameAnalyticsState analyticsState = MlTasks.getDataFrameAnalyticsState(analyticsId, tasks);\n+        if (DataFrameAnalyticsState.STOPPED.equals(analyticsState)) {\n+            // Analytics is stopped, therefore it is safe to proceed with the udpate\n+            return;\n+        }\n+        // Changing model memory limit requires task restart, therefore it cannot be safely updated when the task is running\n+        if (update.getModelMemoryLimit() != null && update.getModelMemoryLimit().equals(originalConfig.getModelMemoryLimit()) == false) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEzNTY2NQ=="}, "originalCommit": {"oid": "59b322175757e47639deda719ec80d98ee2ad026"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3OTgyMTU2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/dataframe/persistence/DataFrameAnalyticsConfigProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMTo1MTowMFrOGpeAxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMTo1MTowMFrOGpeAxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEzNjUxNg==", "bodyText": "Nice to use those 2 :-)", "url": "https://github.com/elastic/elasticsearch/pull/58302#discussion_r446136516", "createdAt": "2020-06-26T11:51:00Z", "author": {"login": "dimitris-athanasiou"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/dataframe/persistence/DataFrameAnalyticsConfigProvider.java", "diffHunk": "@@ -68,28 +77,116 @@ public DataFrameAnalyticsConfigProvider(Client client, NamedXContentRegistry xCo\n         this.xContentRegistry = xContentRegistry;\n     }\n \n-    public void put(DataFrameAnalyticsConfig config, Map<String, String> headers, ActionListener<IndexResponse> listener) {\n-        String id = config.getId();\n-\n+    /**\n+     * Puts the given {@link DataFrameAnalyticsConfig} document into the config index.\n+     */\n+    public void put(DataFrameAnalyticsConfig config, Map<String, String> headers, ActionListener<DataFrameAnalyticsConfig> listener) {\n         if (headers.isEmpty() == false) {\n             // Filter any values in headers that aren't security fields\n             config = new DataFrameAnalyticsConfig.Builder(config)\n                 .setHeaders(filterSecurityHeaders(headers))\n                 .build();\n         }\n+        index(config, null, listener);\n+    }\n+\n+    /**\n+     * Updates the {@link DataFrameAnalyticsConfig} document in the config index using given {@link DataFrameAnalyticsConfigUpdate}.\n+     */\n+    public void update(DataFrameAnalyticsConfigUpdate update,\n+                       Map<String, String> headers,\n+                       ClusterState clusterState,\n+                       ActionListener<DataFrameAnalyticsConfig> listener) {\n+        String id = update.getId();\n+        GetRequest getRequest = new GetRequest(MlConfigIndex.indexName(), DataFrameAnalyticsConfig.documentId(id));\n+        executeAsyncWithOrigin(client, ML_ORIGIN, GetAction.INSTANCE, getRequest, ActionListener.wrap(\n+            getResponse -> {\n+\n+                // Fail the update request if the config to be updated doesn't exist\n+                if (getResponse.isExists() == false) {\n+                    listener.onFailure(ExceptionsHelper.missingDataFrameAnalytics(id));\n+                    return;\n+                }\n+\n+                // Parse the original config\n+                DataFrameAnalyticsConfig originalConfig;\n+                try {\n+                    try (InputStream stream = getResponse.getSourceAsBytesRef().streamInput();\n+                         XContentParser parser = XContentFactory.xContent(XContentType.JSON)\n+                             .createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, stream)) {\n+                        originalConfig = DataFrameAnalyticsConfig.LENIENT_PARSER.apply(parser, null).build();\n+                    }\n+                } catch (IOException e) {\n+                    listener.onFailure(\n+                        new ElasticsearchParseException(\"Failed to parse data frame analytics configuration [\" + id + \"]\", e));\n+                    return;\n+                }\n+\n+                // Check that the update can be applied given current analytics state\n+                checkUpdateCanBeApplied(originalConfig, update, clusterState);\n+\n+                // Merge the original config with the given update object\n+                DataFrameAnalyticsConfig.Builder updatedConfigBuilder = update.mergeWithConfig(originalConfig);\n+                if (headers.isEmpty() == false) {\n+                    updatedConfigBuilder.setHeaders(filterSecurityHeaders(headers));\n+                }\n+                DataFrameAnalyticsConfig updatedConfig = updatedConfigBuilder.build();\n+\n+                // Index the update config\n+                index(updatedConfig, getResponse, listener);\n+            },\n+            listener::onFailure\n+        ));\n+    }\n+\n+    private static void checkUpdateCanBeApplied(DataFrameAnalyticsConfig originalConfig,\n+                                                DataFrameAnalyticsConfigUpdate update,\n+                                                ClusterState clusterState) {\n+        String analyticsId = update.getId();\n+        PersistentTasksCustomMetadata tasks = clusterState.getMetadata().custom(PersistentTasksCustomMetadata.TYPE);\n+        DataFrameAnalyticsState analyticsState = MlTasks.getDataFrameAnalyticsState(analyticsId, tasks);\n+        if (DataFrameAnalyticsState.STOPPED.equals(analyticsState)) {\n+            // Analytics is stopped, therefore it is safe to proceed with the udpate\n+            return;\n+        }\n+        // Changing model memory limit requires task restart, therefore it cannot be safely updated when the task is running\n+        if (update.getModelMemoryLimit() != null && update.getModelMemoryLimit().equals(originalConfig.getModelMemoryLimit()) == false) {\n+            throw ExceptionsHelper.conflictStatusException(\n+                Messages.getMessage(Messages.DATA_FRAME_ANALYTICS_CANNOT_UPDATE_IN_CURRENT_STATE, analyticsId, analyticsState));\n+        }\n+    }\n+\n+    /**\n+     * Indexes the new version of {@link DataFrameAnalyticsConfig} document into the config index.\n+     *\n+     * @param config config object to be indexed\n+     * @param getResponse {@link GetResponse} coming from requesting the previous version of the config.\n+     *                    If null, this config is indexed for the first time\n+     * @param listener listener to be called after indexing\n+     */\n+    private void index(DataFrameAnalyticsConfig config,\n+                       @Nullable GetResponse getResponse,\n+                       ActionListener<DataFrameAnalyticsConfig> listener) {\n         try (XContentBuilder builder = XContentFactory.jsonBuilder()) {\n             config.toXContent(builder, new ToXContent.MapParams(TO_XCONTENT_PARAMS));\n             IndexRequest indexRequest = new IndexRequest(MlConfigIndex.indexName())\n-                    .id(DataFrameAnalyticsConfig.documentId(config.getId()))\n-                    .opType(DocWriteRequest.OpType.CREATE)\n-                    .setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE)\n-                    .source(builder);\n+                .id(DataFrameAnalyticsConfig.documentId(config.getId()))\n+                .setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE)\n+                .source(builder);\n+            if (getResponse == null) {\n+                indexRequest.opType(DocWriteRequest.OpType.CREATE);\n+            } else {\n+                indexRequest\n+                    .opType(DocWriteRequest.OpType.INDEX)\n+                    .setIfSeqNo(getResponse.getSeqNo())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59b322175757e47639deda719ec80d98ee2ad026"}, "originalPosition": 149}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MDEzMjMzOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/job/messages/Messages.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMzozMjowOVrOGphBvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMzo1MzoyNVrOGphxUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE4NTkxNg==", "bodyText": "type: remove double quote", "url": "https://github.com/elastic/elasticsearch/pull/58302#discussion_r446185916", "createdAt": "2020-06-26T13:32:09Z", "author": {"login": "dimitris-athanasiou"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/job/messages/Messages.java", "diffHunk": "@@ -74,8 +74,7 @@\n     public static final String DATA_FRAME_ANALYTICS_AUDIT_STARTED_LOADING_DATA = \"Started loading data\";\n     public static final String DATA_FRAME_ANALYTICS_AUDIT_STARTED_ANALYZING = \"Started analyzing\";\n     public static final String DATA_FRAME_ANALYTICS_AUDIT_STARTED_WRITING_RESULTS = \"Started writing results\";\n-    public static final String DATA_FRAME_ANALYTICS_CANNOT_UPDATE_IN_CURRENT_STATE =\n-        \"Cannot update analytics [{0}] while its status is {1}\";\n+    public static final String DATA_FRAME_ANALYTICS_CANNOT_UPDATE_IN_CURRENT_STATE = \"Cannot update analytics [{0}] unless it''s stopped\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f20af1bd01fbffc4eb9a3f85d99c1ea27b2e233"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE5NjUyOQ==", "bodyText": "I believe it is needed so that a single quote renders properly. Please look at the other messages, like:\n    public static final String JOB_AUDIT_REVERTED = \"Job model snapshot reverted to ''{0}''\";", "url": "https://github.com/elastic/elasticsearch/pull/58302#discussion_r446196529", "createdAt": "2020-06-26T13:50:50Z", "author": {"login": "przemekwitek"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/job/messages/Messages.java", "diffHunk": "@@ -74,8 +74,7 @@\n     public static final String DATA_FRAME_ANALYTICS_AUDIT_STARTED_LOADING_DATA = \"Started loading data\";\n     public static final String DATA_FRAME_ANALYTICS_AUDIT_STARTED_ANALYZING = \"Started analyzing\";\n     public static final String DATA_FRAME_ANALYTICS_AUDIT_STARTED_WRITING_RESULTS = \"Started writing results\";\n-    public static final String DATA_FRAME_ANALYTICS_CANNOT_UPDATE_IN_CURRENT_STATE =\n-        \"Cannot update analytics [{0}] while its status is {1}\";\n+    public static final String DATA_FRAME_ANALYTICS_CANNOT_UPDATE_IN_CURRENT_STATE = \"Cannot update analytics [{0}] unless it''s stopped\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE4NTkxNg=="}, "originalCommit": {"oid": "2f20af1bd01fbffc4eb9a3f85d99c1ea27b2e233"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE5ODA5OA==", "bodyText": "or remove contraction and change to it is :D", "url": "https://github.com/elastic/elasticsearch/pull/58302#discussion_r446198098", "createdAt": "2020-06-26T13:53:25Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/job/messages/Messages.java", "diffHunk": "@@ -74,8 +74,7 @@\n     public static final String DATA_FRAME_ANALYTICS_AUDIT_STARTED_LOADING_DATA = \"Started loading data\";\n     public static final String DATA_FRAME_ANALYTICS_AUDIT_STARTED_ANALYZING = \"Started analyzing\";\n     public static final String DATA_FRAME_ANALYTICS_AUDIT_STARTED_WRITING_RESULTS = \"Started writing results\";\n-    public static final String DATA_FRAME_ANALYTICS_CANNOT_UPDATE_IN_CURRENT_STATE =\n-        \"Cannot update analytics [{0}] while its status is {1}\";\n+    public static final String DATA_FRAME_ANALYTICS_CANNOT_UPDATE_IN_CURRENT_STATE = \"Cannot update analytics [{0}] unless it''s stopped\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE4NTkxNg=="}, "originalCommit": {"oid": "2f20af1bd01fbffc4eb9a3f85d99c1ea27b2e233"}, "originalPosition": 6}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1454, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}