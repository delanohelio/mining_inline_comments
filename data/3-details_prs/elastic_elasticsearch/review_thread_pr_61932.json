{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc4NzI5Mzk4", "number": 61932, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxOToyNToxN1rOEgIFZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxOTozMjo0OFrOEgIOKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMTIyMzQyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/mapper/DateFieldMapper.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxOToyNToxN1rOHM0fKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxOToyNToxN1rOHM0fKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIwNDkwNg==", "bodyText": "Small comment, maybe we should scope the try/ catch down to avoid rewrapping an IllegalArgumentException from the constructor call ? It doesn't seem like a concern for this specific constructor, but seems like good practice.", "url": "https://github.com/elastic/elasticsearch/pull/61932#discussion_r483204906", "createdAt": "2020-09-03T19:25:17Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/DateFieldMapper.java", "diffHunk": "@@ -213,21 +213,38 @@ public Builder(String name, Resolution resolution, DateFormatter dateFormatter,\n         }\n \n         protected DateFieldType setupFieldType(BuilderContext context) {\n-            DateFormatter dateTimeFormatter = DateFormatter.forPattern(format.getValue()).withLocale(locale.getValue());\n-            return new DateFieldType(buildFullName(context), index.getValue(), docValues.getValue(),\n-                dateTimeFormatter, resolution, meta.getValue());\n+            try {\n+                DateFormatter dateTimeFormatter = DateFormatter.forPattern(format.getValue()).withLocale(locale.getValue());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1150090dc95b64ff34ca51116e7fa2e03cbe433d"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMTI0NTg2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/mapper/DateFieldMapper.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxOTozMjo0OFrOHM0tZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxMDo0OTo0OFrOHNJAsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIwODU0OQ==", "bodyText": "Small comment, catch is usually on same line as previous brace.\nNot relevant for this PR, but reading this made me notice that we parse null_value dates different from ones that appear in documents. Specifically, I wonder why we don't use DateFieldType#parse here ?", "url": "https://github.com/elastic/elasticsearch/pull/61932#discussion_r483208549", "createdAt": "2020-09-03T19:32:48Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/DateFieldMapper.java", "diffHunk": "@@ -213,21 +213,38 @@ public Builder(String name, Resolution resolution, DateFormatter dateFormatter,\n         }\n \n         protected DateFieldType setupFieldType(BuilderContext context) {\n-            DateFormatter dateTimeFormatter = DateFormatter.forPattern(format.getValue()).withLocale(locale.getValue());\n-            return new DateFieldType(buildFullName(context), index.getValue(), docValues.getValue(),\n-                dateTimeFormatter, resolution, meta.getValue());\n+            try {\n+                DateFormatter dateTimeFormatter = DateFormatter.forPattern(format.getValue()).withLocale(locale.getValue());\n+                return new DateFieldType(buildFullName(context), index.getValue(), docValues.getValue(),\n+                    dateTimeFormatter, resolution, meta.getValue());\n+            }\n+            catch (IllegalArgumentException e) {\n+                throw new IllegalArgumentException(\"Error parsing [format] on field [\" + name() + \"]: \" + e.getMessage(), e);\n+            }\n         }\n \n         @Override\n         protected List<Parameter<?>> getParameters() {\n             return List.of(index, docValues, store, format, locale, nullValue, ignoreMalformed, boost, meta);\n         }\n \n+        private Long parseNullValue(DateFormatter formatter) {\n+            if (nullValue.getValue() == null) {\n+                return null;\n+            }\n+            try {\n+                return formatter.parseMillis(nullValue.getValue());\n+            }\n+            catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1150090dc95b64ff34ca51116e7fa2e03cbe433d"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU0MTE2OQ==", "bodyText": "Specifically, I wonder why we don't use DateFieldType#parse here ?\n\nThis is a bug, I'll open a separate PR to fix.", "url": "https://github.com/elastic/elasticsearch/pull/61932#discussion_r483541169", "createdAt": "2020-09-04T10:49:48Z", "author": {"login": "romseygeek"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/DateFieldMapper.java", "diffHunk": "@@ -213,21 +213,38 @@ public Builder(String name, Resolution resolution, DateFormatter dateFormatter,\n         }\n \n         protected DateFieldType setupFieldType(BuilderContext context) {\n-            DateFormatter dateTimeFormatter = DateFormatter.forPattern(format.getValue()).withLocale(locale.getValue());\n-            return new DateFieldType(buildFullName(context), index.getValue(), docValues.getValue(),\n-                dateTimeFormatter, resolution, meta.getValue());\n+            try {\n+                DateFormatter dateTimeFormatter = DateFormatter.forPattern(format.getValue()).withLocale(locale.getValue());\n+                return new DateFieldType(buildFullName(context), index.getValue(), docValues.getValue(),\n+                    dateTimeFormatter, resolution, meta.getValue());\n+            }\n+            catch (IllegalArgumentException e) {\n+                throw new IllegalArgumentException(\"Error parsing [format] on field [\" + name() + \"]: \" + e.getMessage(), e);\n+            }\n         }\n \n         @Override\n         protected List<Parameter<?>> getParameters() {\n             return List.of(index, docValues, store, format, locale, nullValue, ignoreMalformed, boost, meta);\n         }\n \n+        private Long parseNullValue(DateFormatter formatter) {\n+            if (nullValue.getValue() == null) {\n+                return null;\n+            }\n+            try {\n+                return formatter.parseMillis(nullValue.getValue());\n+            }\n+            catch (Exception e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIwODU0OQ=="}, "originalCommit": {"oid": "1150090dc95b64ff34ca51116e7fa2e03cbe433d"}, "originalPosition": 29}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1713, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}