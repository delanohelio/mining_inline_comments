{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc3Mjg3OTc3", "number": 52527, "title": "Auto-allocate searchable snapshots", "bodyText": "This commit allows plugins to supply their own allocator for existing shards,\ngeneralizing the default GatewayAllocator. It uses this to implement a very\nsimple auto-allocation process for searchable snapshots which respects the\nallocation deciders but which can otherwise be assigned to any node.\nRelates #50999", "createdAt": "2020-02-19T17:20:30Z", "url": "https://github.com/elastic/elasticsearch/pull/52527", "merged": true, "mergeCommit": {"oid": "215e94d2ae3732f84c9e18d2f995e4310c8572f4"}, "closed": true, "closedAt": "2020-03-11T15:04:27Z", "author": {"login": "DaveCTurner"}, "timelineItems": {"totalCount": 35, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcF5zv-gH2gAyMzc3Mjg3OTc3OmE1MjQxNzlkNTA1ZjQ2NDA5ZTk2ZDQ2MWU3NDk1ZDZkNWZiZjJkZjg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcMmjoUgH2gAyMzc3Mjg3OTc3OjA1YjY5MGM1MjQ3MmIzMjQ2Nzk4MzI2MDg4Nzg0YWUzYTkxZTRiNzk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "a524179d505f46409e96d461e7495d6d5fbf2df8", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/a524179d505f46409e96d461e7495d6d5fbf2df8", "committedDate": "2020-02-19T17:16:49Z", "message": "Auto-allocate searchable snapshots\n\nThis commit allows plugins to supply their own allocator for existing shards,\ngeneralizing the default `GatewayAllocator`. It uses this to implement a very\nsimple auto-allocation process for searchable snapshots which respects the\nallocation deciders but which can otherwise be assigned to any node."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxMjg0Nzc5", "url": "https://github.com/elastic/elasticsearch/pull/52527#pullrequestreview-361284779", "createdAt": "2020-02-19T17:22:24Z", "commit": {"oid": "a524179d505f46409e96d461e7495d6d5fbf2df8"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQxNzoyMjoyNFrOFrwVgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQxNzoyNDozMlrOFrwaZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQyNTAyNA==", "bodyText": "for discussion", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r381425024", "createdAt": "2020-02-19T17:22:24Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java", "diffHunk": "@@ -413,10 +421,18 @@ private void reroute(RoutingAllocation allocation) {\n         assert hasDeadNodes(allocation) == false : \"dead nodes should be explicitly cleaned up. See disassociateDeadNodes\";\n         assert AutoExpandReplicas.getAutoExpandReplicaChanges(allocation.metaData(), allocation).isEmpty() :\n             \"auto-expand replicas out of sync with number of nodes in the cluster\";\n+        assert existingShardsAllocators.isEmpty() == false : \"must have at least one ExistingShardsAllocator\";\n \n         removeDelayMarkers(allocation);\n+\n+        allocation.routingNodes().unassigned().sort(PriorityComparator.getAllocationComparator(allocation)); // sort for priority ordering\n+\n         // try to allocate existing shard copies first\n-        gatewayAllocator.allocateUnassigned(allocation);\n+        // TODO TBD the order in which allocators run depends on the order of plugins so is not properly defined. Does this matter?\n+        // TODO TBD this means earlier allocators allocate shards before the later allocators can allocate possibly-higher-priority ones", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a524179d505f46409e96d461e7495d6d5fbf2df8"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQyNTA3OA==", "bodyText": "for discussion", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r381425078", "createdAt": "2020-02-19T17:22:30Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java", "diffHunk": "@@ -413,10 +421,18 @@ private void reroute(RoutingAllocation allocation) {\n         assert hasDeadNodes(allocation) == false : \"dead nodes should be explicitly cleaned up. See disassociateDeadNodes\";\n         assert AutoExpandReplicas.getAutoExpandReplicaChanges(allocation.metaData(), allocation).isEmpty() :\n             \"auto-expand replicas out of sync with number of nodes in the cluster\";\n+        assert existingShardsAllocators.isEmpty() == false : \"must have at least one ExistingShardsAllocator\";\n \n         removeDelayMarkers(allocation);\n+\n+        allocation.routingNodes().unassigned().sort(PriorityComparator.getAllocationComparator(allocation)); // sort for priority ordering\n+\n         // try to allocate existing shard copies first\n-        gatewayAllocator.allocateUnassigned(allocation);\n+        // TODO TBD the order in which allocators run depends on the order of plugins so is not properly defined. Does this matter?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a524179d505f46409e96d461e7495d6d5fbf2df8"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQyNjI3OQ==", "bodyText": "With this commit, this hack is no longer needed since we do not fetch the shard info like this.", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r381426279", "createdAt": "2020-02-19T17:24:32Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/index/store/Store.java", "diffHunk": "@@ -446,13 +446,8 @@ public static void tryOpenIndex(Path indexLocation, ShardId shardId, NodeEnviron\n         try (ShardLock lock = shardLocker.lock(shardId, \"open index\", TimeUnit.SECONDS.toMillis(5));\n              Directory dir = new SimpleFSDirectory(indexLocation)) {\n             failIfCorrupted(dir);\n-            // Previously we called Lucene#readSegmentInfos which verifies that some Lucene metadata is readable and makes sense, but if it\n-            // weren't then we would mark this shard as corrupt when allocated, so it seems that this is unnecessary (and it breaks when\n-            // the shard's directory is virtual since we use SimpleFSDirectory above.\n-            // TODO NORELEASE is this ok? Need to check that we definitely add a corruption marker if the metadata is corrupt.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a524179d505f46409e96d461e7495d6d5fbf2df8"}, "originalPosition": 7}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "44df8606f303642ce7230c5d76cdcad0a89415c2", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/44df8606f303642ce7230c5d76cdcad0a89415c2", "committedDate": "2020-02-19T18:25:59Z", "message": "Rename"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1015ac8f4d2ba98d69d1a756ebb08a4ffd42e9e3", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/1015ac8f4d2ba98d69d1a756ebb08a4ffd42e9e3", "committedDate": "2020-02-19T20:11:00Z", "message": "Merge branch 'feature/searchable-snapshots' into 2020-02-19-pluggable-allocator-for-existing-shards"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "438ec61043958b6bec8354def99b49d690eeac2f", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/438ec61043958b6bec8354def99b49d690eeac2f", "committedDate": "2020-02-19T21:19:14Z", "message": "Merge branch 'feature/searchable-snapshots' into 2020-02-19-pluggable-allocator-for-existing-shards"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxNjg3NTc3", "url": "https://github.com/elastic/elasticsearch/pull/52527#pullrequestreview-361687577", "createdAt": "2020-02-20T07:47:01Z", "commit": {"oid": "438ec61043958b6bec8354def99b49d690eeac2f"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwNzo0NzowMlrOFsJCrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwODoxNjoxOVrOFsJv0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTgyOTgwNg==", "bodyText": "I think I would prefer to not name the plugin in index settings and instead just have a searchable snapshot specific setting that triggers this.", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r381829806", "createdAt": "2020-02-20T07:47:02Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/gateway/PrimaryShardAllocator.java", "diffHunk": "@@ -82,6 +98,14 @@ public AllocateUnassignedDecision makeAllocationDecision(final ShardRouting unas\n             return AllocateUnassignedDecision.NOT_TAKEN;\n         }\n \n+        final IndexMetaData indexMetaData = allocation.metaData().getIndexSafe(unassignedShard.index());\n+        final String existingShardsAllocator = ExistingShardsAllocator.EXISTING_SHARDS_ALLOCATOR_SETTING.get(indexMetaData.getSettings());\n+        if (unassignedShard.recoverySource().getType() == RecoverySource.Type.EXISTING_STORE\n+            && existingShardsAllocator.equals(GatewayAllocator.ALLOCATOR_NAME) == false) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "438ec61043958b6bec8354def99b49d690eeac2f"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTgzOTk5OA==", "bodyText": "It seems like the loop here and the handling of a NO decision belongs in the framework (allocation service?) rather than in every plugin. It is important that this is done right.\nThis in turn could lead to removing GatewayAllocator completely and letting Replica and PrimaryShardAllocator become individual ExistingShardsAllocators. A method to allow processExistingRecoveries would be necessary though.", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r381839998", "createdAt": "2020-02-20T08:12:56Z", "author": {"login": "henningandersen"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/SearchableSnapshotAllocator.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.searchablesnapshots;\n+\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RoutingNode;\n+import org.elasticsearch.cluster.routing.RoutingNodes;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.UnassignedInfo;\n+import org.elasticsearch.cluster.routing.allocation.AllocateUnassignedDecision;\n+import org.elasticsearch.cluster.routing.allocation.AllocationDecision;\n+import org.elasticsearch.cluster.routing.allocation.ExistingShardsAllocator;\n+import org.elasticsearch.cluster.routing.allocation.FailedShard;\n+import org.elasticsearch.cluster.routing.allocation.NodeAllocationResult;\n+import org.elasticsearch.cluster.routing.allocation.RoutingAllocation;\n+import org.elasticsearch.cluster.routing.allocation.decider.Decision;\n+import org.elasticsearch.common.settings.Settings;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class SearchableSnapshotAllocator implements ExistingShardsAllocator {\n+\n+    static final String ALLOCATOR_NAME = \"searchable_snapshot_allocator\";\n+\n+    @Override\n+    public void allocateUnassigned(RoutingAllocation allocation) {\n+\n+        final RoutingNodes.UnassignedShards.UnassignedIterator iterator = allocation.routingNodes().unassigned().iterator();\n+\n+        while (iterator.hasNext()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "438ec61043958b6bec8354def99b49d690eeac2f"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg0MTM2MA==", "bodyText": "If we want to name the allocator in settings, I think we should just pick the right allocator per shard from the outside?", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r381841360", "createdAt": "2020-02-20T08:16:19Z", "author": {"login": "henningandersen"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/SearchableSnapshotAllocator.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.searchablesnapshots;\n+\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RoutingNode;\n+import org.elasticsearch.cluster.routing.RoutingNodes;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.UnassignedInfo;\n+import org.elasticsearch.cluster.routing.allocation.AllocateUnassignedDecision;\n+import org.elasticsearch.cluster.routing.allocation.AllocationDecision;\n+import org.elasticsearch.cluster.routing.allocation.ExistingShardsAllocator;\n+import org.elasticsearch.cluster.routing.allocation.FailedShard;\n+import org.elasticsearch.cluster.routing.allocation.NodeAllocationResult;\n+import org.elasticsearch.cluster.routing.allocation.RoutingAllocation;\n+import org.elasticsearch.cluster.routing.allocation.decider.Decision;\n+import org.elasticsearch.common.settings.Settings;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class SearchableSnapshotAllocator implements ExistingShardsAllocator {\n+\n+    static final String ALLOCATOR_NAME = \"searchable_snapshot_allocator\";\n+\n+    @Override\n+    public void allocateUnassigned(RoutingAllocation allocation) {\n+\n+        final RoutingNodes.UnassignedShards.UnassignedIterator iterator = allocation.routingNodes().unassigned().iterator();\n+\n+        while (iterator.hasNext()) {\n+            final ShardRouting shardRouting = iterator.next();\n+            final AllocateUnassignedDecision allocateUnassignedDecision = decideAllocation(allocation, shardRouting);\n+\n+            if (allocateUnassignedDecision.isDecisionTaken()) {\n+                if (allocateUnassignedDecision.getAllocationDecision() == AllocationDecision.YES) {\n+                    if (shardRouting.primary() && shardRouting.recoverySource().getType() == RecoverySource.Type.EXISTING_STORE) {\n+                        // we don't care what the allocation ID is since we know that these shards cannot really be stale, so we can\n+                        // safely ignore the allocation ID with a forced-stale allocation\n+                        iterator.updateUnassigned(shardRouting.unassignedInfo(),\n+                            RecoverySource.ExistingStoreRecoverySource.FORCE_STALE_PRIMARY_INSTANCE, allocation.changes());\n+                    }\n+                    iterator.initialize(allocateUnassignedDecision.getTargetNode().getId(), null, 0L, allocation.changes());\n+                } else {\n+                    iterator.removeAndIgnore(allocateUnassignedDecision.getAllocationStatus(), allocation.changes());\n+                }\n+            }\n+        }\n+    }\n+\n+    private static AllocateUnassignedDecision decideAllocation(RoutingAllocation allocation, ShardRouting shardRouting) {\n+        if (isResponsibleFor(allocation, shardRouting)) {\n+            Decision.Type bestDecision = Decision.Type.NO;\n+            RoutingNode bestNode = null;\n+            final List<NodeAllocationResult> nodeAllocationResults\n+                = allocation.debugDecision() ? new ArrayList<>(allocation.routingNodes().size()) : null;\n+\n+            for (final RoutingNode routingNode : allocation.routingNodes()) {\n+                final Decision decision = allocation.deciders().canAllocate(shardRouting, routingNode, allocation);\n+                if (decision.type() == Decision.Type.YES\n+                    || (decision.type() == Decision.Type.THROTTLE && bestDecision != Decision.Type.YES)) {\n+                    bestDecision = decision.type();\n+                    bestNode = routingNode;\n+                }\n+                if (nodeAllocationResults != null) {\n+                    nodeAllocationResults.add(new NodeAllocationResult(routingNode.node(), null, decision));\n+                }\n+            }\n+\n+            switch (bestDecision) {\n+                case YES:\n+                    return AllocateUnassignedDecision.yes(bestNode.node(), null, nodeAllocationResults, false);\n+                case THROTTLE:\n+                    return AllocateUnassignedDecision.throttle(nodeAllocationResults);\n+                case NO:\n+                    return AllocateUnassignedDecision.no(UnassignedInfo.AllocationStatus.DECIDERS_NO, nodeAllocationResults);\n+            }\n+        }\n+\n+        return AllocateUnassignedDecision.NOT_TAKEN;\n+    }\n+\n+    private static boolean isResponsibleFor(RoutingAllocation allocation, ShardRouting shardRouting) {\n+        final Settings settings = allocation.metaData().getIndexSafe(shardRouting.index()).getSettings();\n+        return shardRouting.unassigned() && ExistingShardsAllocator.EXISTING_SHARDS_ALLOCATOR_SETTING.get(settings).equals(ALLOCATOR_NAME);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "438ec61043958b6bec8354def99b49d690eeac2f"}, "originalPosition": 88}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxNzQyNDIy", "url": "https://github.com/elastic/elasticsearch/pull/52527#pullrequestreview-361742422", "createdAt": "2020-02-20T09:22:03Z", "commit": {"oid": "438ec61043958b6bec8354def99b49d690eeac2f"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwOToyMjowM1rOFsLwlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwOTozOTo0OFrOFsMY9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg3NDMyNw==", "bodyText": "We could leave it to the core framework to decide which allocator to invoke", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r381874327", "createdAt": "2020-02-20T09:22:03Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java", "diffHunk": "@@ -413,10 +421,18 @@ private void reroute(RoutingAllocation allocation) {\n         assert hasDeadNodes(allocation) == false : \"dead nodes should be explicitly cleaned up. See disassociateDeadNodes\";\n         assert AutoExpandReplicas.getAutoExpandReplicaChanges(allocation.metaData(), allocation).isEmpty() :\n             \"auto-expand replicas out of sync with number of nodes in the cluster\";\n+        assert existingShardsAllocators.isEmpty() == false : \"must have at least one ExistingShardsAllocator\";\n \n         removeDelayMarkers(allocation);\n+\n+        allocation.routingNodes().unassigned().sort(PriorityComparator.getAllocationComparator(allocation)); // sort for priority ordering\n+\n         // try to allocate existing shard copies first\n-        gatewayAllocator.allocateUnassigned(allocation);\n+        // TODO TBD the order in which allocators run depends on the order of plugins so is not properly defined. Does this matter?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQyNTA3OA=="}, "originalCommit": {"oid": "a524179d505f46409e96d461e7495d6d5fbf2df8"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg4NDE3MQ==", "bodyText": "I wonder if we should have a separate facility that ensures that certain plugins are installed in the presence of certain types of indices. Otherwise we have to build this again and again for any plugin-specific setting that we introduce.\nTake for example \"follower\" indices (CCR). Those only make sense in the context of x-pack.", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r381884171", "createdAt": "2020-02-20T09:38:54Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/gateway/PrimaryShardAllocator.java", "diffHunk": "@@ -82,6 +98,14 @@ public AllocateUnassignedDecision makeAllocationDecision(final ShardRouting unas\n             return AllocateUnassignedDecision.NOT_TAKEN;\n         }\n \n+        final IndexMetaData indexMetaData = allocation.metaData().getIndexSafe(unassignedShard.index());\n+        final String existingShardsAllocator = ExistingShardsAllocator.EXISTING_SHARDS_ALLOCATOR_SETTING.get(indexMetaData.getSettings());\n+        if (unassignedShard.recoverySource().getType() == RecoverySource.Type.EXISTING_STORE\n+            && existingShardsAllocator.equals(GatewayAllocator.ALLOCATOR_NAME) == false) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTgyOTgwNg=="}, "originalCommit": {"oid": "438ec61043958b6bec8354def99b49d690eeac2f"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg4NDY2MA==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r381884660", "createdAt": "2020-02-20T09:39:48Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/index/store/Store.java", "diffHunk": "@@ -446,13 +446,8 @@ public static void tryOpenIndex(Path indexLocation, ShardId shardId, NodeEnviron\n         try (ShardLock lock = shardLocker.lock(shardId, \"open index\", TimeUnit.SECONDS.toMillis(5));\n              Directory dir = new SimpleFSDirectory(indexLocation)) {\n             failIfCorrupted(dir);\n-            // Previously we called Lucene#readSegmentInfos which verifies that some Lucene metadata is readable and makes sense, but if it\n-            // weren't then we would mark this shard as corrupt when allocated, so it seems that this is unnecessary (and it breaks when\n-            // the shard's directory is virtual since we use SimpleFSDirectory above.\n-            // TODO NORELEASE is this ok? Need to check that we definitely add a corruption marker if the metadata is corrupt.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQyNjI3OQ=="}, "originalCommit": {"oid": "a524179d505f46409e96d461e7495d6d5fbf2df8"}, "originalPosition": 7}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "41071b2d3a90e4bf314fe34c2b1f275bdef3b072", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/41071b2d3a90e4bf314fe34c2b1f275bdef3b072", "committedDate": "2020-02-20T18:10:25Z", "message": "Select a unique allocator for each shard\n\nMove the iteration through the shards from the individual allocators up to the\nAllocationService, allowing us to allocate them in proper priority order and\nalso allowing us to assign a unique allocator to each shard according to an\nindex setting."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9d1da9640637b1a8e46d8543c43cee722120c365", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/9d1da9640637b1a8e46d8543c43cee722120c365", "committedDate": "2020-02-20T18:22:37Z", "message": "Didn't know I edited that"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ab39f0a2537f35d8b1beeb7367ed4cc7b2ca03cf", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/ab39f0a2537f35d8b1beeb7367ed4cc7b2ca03cf", "committedDate": "2020-02-21T08:44:56Z", "message": "Revert sorting by primary/replica since we have to iterate twice anyway"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "66ca0631b230a8428e7bf391aefea9ca5656144e", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/66ca0631b230a8428e7bf391aefea9ca5656144e", "committedDate": "2020-02-21T09:24:12Z", "message": "Revert some unnecessary changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "02e615811704046a80f7464cdbc5174c4d4785f5", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/02e615811704046a80f7464cdbc5174c4d4785f5", "committedDate": "2020-02-21T09:56:30Z", "message": "Add tests for duplicate checks of existing shards allocators"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5154f7f91d3e5084bb3d6db618542fb0769d4f8a", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/5154f7f91d3e5084bb3d6db618542fb0769d4f8a", "committedDate": "2020-02-21T10:15:12Z", "message": "We always take a decision right now"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e61a3426fbf314f4119c28a61f19f0d7a76b973e", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/e61a3426fbf314f4119c28a61f19f0d7a76b973e", "committedDate": "2020-02-21T13:29:37Z", "message": "Add test of allocation service behaviour"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aad3fc018a24627b1da5992058ea87011e5ddc20", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/aad3fc018a24627b1da5992058ea87011e5ddc20", "committedDate": "2020-02-21T13:43:53Z", "message": "Add test for unknown allocator too"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "09c49b88887e84fce940b219e563e936732458c1", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/09c49b88887e84fce940b219e563e936732458c1", "committedDate": "2020-02-21T14:21:10Z", "message": "Merge branch 'feature/searchable-snapshots' into 2020-02-19-pluggable-allocator-for-existing-shards"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzMTA2NjUw", "url": "https://github.com/elastic/elasticsearch/pull/52527#pullrequestreview-363106650", "createdAt": "2020-02-23T16:26:43Z", "commit": {"oid": "09c49b88887e84fce940b219e563e936732458c1"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yM1QxNjoyNjo0M1rOFtRmIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yM1QxNjo0Njo1NlrOFtRsCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAxODUyOA==", "bodyText": "for started shards, you used a for loop, whereas here there's a lambda. Perhaps just make it consistent?", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r383018528", "createdAt": "2020-02-23T16:26:43Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java", "diffHunk": "@@ -217,7 +230,8 @@ public ClusterState applyFailedShards(final ClusterState clusterState, final Lis\n                 logger.trace(\"{} shard routing failed in an earlier iteration (routing: {})\", shardToFail.shardId(), shardToFail);\n             }\n         }\n-        gatewayAllocator.applyFailedShards(allocation, failedShards);\n+        existingShardsAllocators.values().forEach(existingShardsAllocator ->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09c49b88887e84fce940b219e563e936732458c1"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAxODg5Nw==", "bodyText": "as these lookups can be expensive in case there are many unassigned shards, I wonder if we should pass the retrieved IndexMetaData to the ExistingShardsAllocator.", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r383018897", "createdAt": "2020-02-23T16:31:36Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java", "diffHunk": "@@ -470,7 +514,104 @@ protected long currentNanoTime() {\n     }\n \n     public void cleanCaches() {\n-        gatewayAllocator.cleanCaches();\n+        assert assertInitialized();\n+        existingShardsAllocators.values().forEach(ExistingShardsAllocator::cleanCaches);\n+    }\n+\n+    public int getNumberOfInFlightFetches() {\n+        assert assertInitialized();\n+        return existingShardsAllocators.values().stream().mapToInt(ExistingShardsAllocator::getNumberOfInFlightFetches).sum();\n+    }\n+\n+    public ShardAllocationDecision explainShardAllocation(ShardRouting shardRouting, RoutingAllocation allocation) {\n+        assert allocation.debugDecision();\n+        AllocateUnassignedDecision allocateDecision\n+            = shardRouting.unassigned() ? explainUnassignedShardAllocation(shardRouting, allocation) : AllocateUnassignedDecision.NOT_TAKEN;\n+        if (allocateDecision.isDecisionTaken()) {\n+            return new ShardAllocationDecision(allocateDecision, MoveDecision.NOT_TAKEN);\n+        } else {\n+            return shardsAllocator.decideShardAllocation(shardRouting, allocation);\n+        }\n+    }\n+\n+    private AllocateUnassignedDecision explainUnassignedShardAllocation(ShardRouting shardRouting, RoutingAllocation routingAllocation) {\n+        assert shardRouting.unassigned();\n+        assert routingAllocation.debugDecision();\n+        assert assertInitialized();\n+        final ExistingShardsAllocator existingShardsAllocator = getAllocatorForShard(shardRouting, routingAllocation);\n+        final AllocateUnassignedDecision decision\n+            = existingShardsAllocator.explainUnassignedShardAllocation(shardRouting, routingAllocation);\n+        if (decision.isDecisionTaken()) {\n+            return decision;\n+        }\n+        return AllocateUnassignedDecision.NOT_TAKEN;\n+    }\n+\n+    private ExistingShardsAllocator getAllocatorForShard(ShardRouting shardRouting, RoutingAllocation routingAllocation) {\n+        assert assertInitialized();\n+        final String allocatorName = ExistingShardsAllocator.EXISTING_SHARDS_ALLOCATOR_SETTING.get(\n+            routingAllocation.metaData().getIndexSafe(shardRouting.index()).getSettings());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09c49b88887e84fce940b219e563e936732458c1"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAxOTg3OQ==", "bodyText": "The cluster module already receives the clusterPlugins at initialization time. Perhaps we can just reuse those or even extract the ExistingShardsAllocator at init time?", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r383019879", "createdAt": "2020-02-23T16:45:29Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/cluster/ClusterModule.java", "diffHunk": "@@ -251,4 +252,21 @@ protected void configure() {\n         bind(AllocationDeciders.class).toInstance(allocationDeciders);\n         bind(ShardsAllocator.class).toInstance(shardsAllocator);\n     }\n+\n+    public void setExistingShardsAllocators(GatewayAllocator gatewayAllocator, List<ClusterPlugin> clusterPlugins) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09c49b88887e84fce940b219e563e936732458c1"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAyMDA0MQ==", "bodyText": "maybe omit the \"instead\", and explain what the key in this map represents (to which setting it is tied)", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r383020041", "createdAt": "2020-02-23T16:46:56Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/plugins/ClusterPlugin.java", "diffHunk": "@@ -59,6 +60,14 @@\n         return Collections.emptyMap();\n     }\n \n+    /**\n+     * Return {@link ExistingShardsAllocator} implementations added by this plugin, which will run instead of the default", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09c49b88887e84fce940b219e563e936732458c1"}, "originalPosition": 28}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0MjY0MTg1", "url": "https://github.com/elastic/elasticsearch/pull/52527#pullrequestreview-364264185", "createdAt": "2020-02-25T16:03:35Z", "commit": {"oid": "09c49b88887e84fce940b219e563e936732458c1"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNjowMzozNVrOFuMA2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxMTozNTo0OVrOFuoNhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzk3NTY0Mw==", "bodyText": "nit: I would prefer to leave the field null until initialized (and thus non-final), that seems simpler to me.", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r383975643", "createdAt": "2020-02-25T16:03:35Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java", "diffHunk": "@@ -70,26 +73,32 @@\n     private static final Logger logger = LogManager.getLogger(AllocationService.class);\n \n     private final AllocationDeciders allocationDeciders;\n-    private GatewayAllocator gatewayAllocator;\n+    private final Map<String, ExistingShardsAllocator> existingShardsAllocators = new HashMap<>();\n     private final ShardsAllocator shardsAllocator;\n     private final ClusterInfoService clusterInfoService;\n \n-    public AllocationService(AllocationDeciders allocationDeciders,\n-                             GatewayAllocator gatewayAllocator,\n+    // only for tests that use the GatewayAllocator as the unique ExistingShardsAllocator\n+    public AllocationService(AllocationDeciders allocationDeciders, GatewayAllocator gatewayAllocator,\n                              ShardsAllocator shardsAllocator, ClusterInfoService clusterInfoService) {\n         this(allocationDeciders, shardsAllocator, clusterInfoService);\n-        setGatewayAllocator(gatewayAllocator);\n+        setExistingShardsAllocators(Collections.singletonMap(GatewayAllocator.ALLOCATOR_NAME, gatewayAllocator));\n     }\n \n-    public AllocationService(AllocationDeciders allocationDeciders,\n-                             ShardsAllocator shardsAllocator, ClusterInfoService clusterInfoService) {\n+    public AllocationService(AllocationDeciders allocationDeciders, ShardsAllocator shardsAllocator,\n+                             ClusterInfoService clusterInfoService) {\n         this.allocationDeciders = allocationDeciders;\n         this.shardsAllocator = shardsAllocator;\n         this.clusterInfoService = clusterInfoService;\n     }\n \n-    public void setGatewayAllocator(GatewayAllocator gatewayAllocator) {\n-        this.gatewayAllocator = gatewayAllocator;\n+    /**\n+     * Inject the {@link ExistingShardsAllocator}s to use. May only be called once.\n+     */\n+    public void setExistingShardsAllocators(Map<String, ExistingShardsAllocator> existingShardsAllocators) {\n+        assert this.existingShardsAllocators.isEmpty()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09c49b88887e84fce940b219e563e936732458c1"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMwMzUzNw==", "bodyText": "I would prefer to use a dedicated interface with the 3 methods that a plugin is allowed to use (in particular, they are not allowed to call .next() on this iterator).", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r384303537", "createdAt": "2020-02-26T06:57:58Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/cluster/routing/allocation/ExistingShardsAllocator.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.cluster.routing.allocation;\n+\n+import org.elasticsearch.cluster.routing.RoutingNodes;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.gateway.GatewayAllocator;\n+\n+import java.util.List;\n+\n+/**\n+ * Searches for, and allocates, shards for which there is an existing on-disk copy somewhere in the cluster. The default implementation is\n+ * {@link GatewayAllocator}, but plugins can supply their own implementations too.\n+ */\n+public interface ExistingShardsAllocator {\n+\n+    /**\n+     * Allows plugins to override how we allocate shards that may already exist on disk in the cluster.\n+     */\n+    Setting<String> EXISTING_SHARDS_ALLOCATOR_SETTING = Setting.simpleString(\n+        \"index.allocation.existing_shards_allocator\", GatewayAllocator.ALLOCATOR_NAME,\n+        Setting.Property.IndexScope, Setting.Property.PrivateIndex);\n+\n+    /**\n+     * Called before starting a round of allocation, allowing the allocator to invalidate some caches if appropriate.\n+     */\n+    void beforeAllocation(RoutingAllocation allocation);\n+\n+\n+    /**\n+     * Called during a round of allocation after attempting to allocate all the primaries but before any replicas, allowing the allocator\n+     * to prepare for replica allocation.\n+     */\n+    void afterPrimariesBeforeReplicas(RoutingAllocation allocation);\n+\n+    /**\n+     * Allocate any unassigned shards in the given {@link RoutingAllocation} for which this {@link ExistingShardsAllocator} is responsible.\n+     */\n+    void allocateUnassigned(RoutingAllocation allocation, ShardRouting shardRouting,\n+                            RoutingNodes.UnassignedShards.UnassignedIterator iterator);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09c49b88887e84fce940b219e563e936732458c1"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQxMjM5OA==", "bodyText": "nit: I think the _allocator suffix in the name is superfluous and should be removed.", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r384412398", "createdAt": "2020-02-26T10:44:49Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/gateway/GatewayAllocator.java", "diffHunk": "@@ -54,7 +55,9 @@\n import java.util.stream.Collectors;\n import java.util.stream.StreamSupport;\n \n-public class GatewayAllocator {\n+public class GatewayAllocator implements ExistingShardsAllocator {\n+\n+    public static final String ALLOCATOR_NAME = \"gateway_allocator\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09c49b88887e84fce940b219e563e936732458c1"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQxMzY1OA==", "bodyText": "Some of the methods in this interface have RoutingAllocation first, others have ShardRouting first. I think we should order them consistently. I personally prefer to put the subject of the operation (ShardRouting or List<ShardRouting) first and the \"context\" (RoutingAllocation) last.", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r384413658", "createdAt": "2020-02-26T10:46:57Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/cluster/routing/allocation/ExistingShardsAllocator.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.cluster.routing.allocation;\n+\n+import org.elasticsearch.cluster.routing.RoutingNodes;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.gateway.GatewayAllocator;\n+\n+import java.util.List;\n+\n+/**\n+ * Searches for, and allocates, shards for which there is an existing on-disk copy somewhere in the cluster. The default implementation is\n+ * {@link GatewayAllocator}, but plugins can supply their own implementations too.\n+ */\n+public interface ExistingShardsAllocator {\n+\n+    /**\n+     * Allows plugins to override how we allocate shards that may already exist on disk in the cluster.\n+     */\n+    Setting<String> EXISTING_SHARDS_ALLOCATOR_SETTING = Setting.simpleString(\n+        \"index.allocation.existing_shards_allocator\", GatewayAllocator.ALLOCATOR_NAME,\n+        Setting.Property.IndexScope, Setting.Property.PrivateIndex);\n+\n+    /**\n+     * Called before starting a round of allocation, allowing the allocator to invalidate some caches if appropriate.\n+     */\n+    void beforeAllocation(RoutingAllocation allocation);\n+\n+\n+    /**\n+     * Called during a round of allocation after attempting to allocate all the primaries but before any replicas, allowing the allocator\n+     * to prepare for replica allocation.\n+     */\n+    void afterPrimariesBeforeReplicas(RoutingAllocation allocation);\n+\n+    /**\n+     * Allocate any unassigned shards in the given {@link RoutingAllocation} for which this {@link ExistingShardsAllocator} is responsible.\n+     */\n+    void allocateUnassigned(RoutingAllocation allocation, ShardRouting shardRouting,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09c49b88887e84fce940b219e563e936732458c1"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQyMjI5Nw==", "bodyText": "nit: allocateExistingUnassignedShards?", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r384422297", "createdAt": "2020-02-26T11:03:08Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java", "diffHunk": "@@ -413,15 +427,43 @@ private void reroute(RoutingAllocation allocation) {\n         assert hasDeadNodes(allocation) == false : \"dead nodes should be explicitly cleaned up. See disassociateDeadNodes\";\n         assert AutoExpandReplicas.getAutoExpandReplicaChanges(allocation.metaData(), allocation).isEmpty() :\n             \"auto-expand replicas out of sync with number of nodes in the cluster\";\n+        assert assertInitialized();\n \n         removeDelayMarkers(allocation);\n-        // try to allocate existing shard copies first\n-        gatewayAllocator.allocateUnassigned(allocation);\n \n+        allocateExistingShards(allocation);  // try to allocate existing shard copies first\n         shardsAllocator.allocate(allocation);\n         assert RoutingNodes.assertShardStats(allocation.routingNodes());\n     }\n \n+    private void allocateExistingShards(RoutingAllocation allocation) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09c49b88887e84fce940b219e563e936732458c1"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQyNjI1OA==", "bodyText": "I find this assert unnecessary since it is a final field and it is initialized in constructor?", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r384426258", "createdAt": "2020-02-26T11:11:23Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/gateway/GatewayAllocator.java", "diffHunk": "@@ -101,47 +106,64 @@ public int getNumberOfInFlightFetch() {\n         return count;\n     }\n \n+    @Override\n     public void applyStartedShards(final RoutingAllocation allocation, final List<ShardRouting> startedShards) {\n         for (ShardRouting startedShard : startedShards) {\n             Releasables.close(asyncFetchStarted.remove(startedShard.shardId()));\n             Releasables.close(asyncFetchStore.remove(startedShard.shardId()));\n         }\n     }\n \n+    @Override\n     public void applyFailedShards(final RoutingAllocation allocation, final List<FailedShard> failedShards) {\n         for (FailedShard failedShard : failedShards) {\n             Releasables.close(asyncFetchStarted.remove(failedShard.getRoutingEntry().shardId()));\n             Releasables.close(asyncFetchStore.remove(failedShard.getRoutingEntry().shardId()));\n         }\n     }\n \n-    public void allocateUnassigned(final RoutingAllocation allocation) {\n+    @Override\n+    public void beforeAllocation(final RoutingAllocation allocation) {\n         assert primaryShardAllocator != null;\n         assert replicaShardAllocator != null;\n         ensureAsyncFetchStorePrimaryRecency(allocation);\n-        innerAllocatedUnassigned(allocation, primaryShardAllocator, replicaShardAllocator);\n     }\n \n-    // allow for testing infra to change shard allocators implementation\n-    protected static void innerAllocatedUnassigned(RoutingAllocation allocation,\n-                                                   PrimaryShardAllocator primaryShardAllocator,\n-                                                   ReplicaShardAllocator replicaShardAllocator) {\n-        RoutingNodes.UnassignedShards unassigned = allocation.routingNodes().unassigned();\n-        unassigned.sort(PriorityComparator.getAllocationComparator(allocation)); // sort for priority ordering\n-\n-        primaryShardAllocator.allocateUnassigned(allocation);\n+    @Override\n+    public void afterPrimariesBeforeReplicas(RoutingAllocation allocation) {\n+        assert replicaShardAllocator != null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09c49b88887e84fce940b219e563e936732458c1"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQyNjQ5Nw==", "bodyText": "I find these two asserts unnecessary since the fields are final and initialized in constructor?", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r384426497", "createdAt": "2020-02-26T11:11:52Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/gateway/GatewayAllocator.java", "diffHunk": "@@ -101,47 +106,64 @@ public int getNumberOfInFlightFetch() {\n         return count;\n     }\n \n+    @Override\n     public void applyStartedShards(final RoutingAllocation allocation, final List<ShardRouting> startedShards) {\n         for (ShardRouting startedShard : startedShards) {\n             Releasables.close(asyncFetchStarted.remove(startedShard.shardId()));\n             Releasables.close(asyncFetchStore.remove(startedShard.shardId()));\n         }\n     }\n \n+    @Override\n     public void applyFailedShards(final RoutingAllocation allocation, final List<FailedShard> failedShards) {\n         for (FailedShard failedShard : failedShards) {\n             Releasables.close(asyncFetchStarted.remove(failedShard.getRoutingEntry().shardId()));\n             Releasables.close(asyncFetchStore.remove(failedShard.getRoutingEntry().shardId()));\n         }\n     }\n \n-    public void allocateUnassigned(final RoutingAllocation allocation) {\n+    @Override\n+    public void beforeAllocation(final RoutingAllocation allocation) {\n         assert primaryShardAllocator != null;\n         assert replicaShardAllocator != null;\n         ensureAsyncFetchStorePrimaryRecency(allocation);\n-        innerAllocatedUnassigned(allocation, primaryShardAllocator, replicaShardAllocator);\n     }\n \n-    // allow for testing infra to change shard allocators implementation\n-    protected static void innerAllocatedUnassigned(RoutingAllocation allocation,\n-                                                   PrimaryShardAllocator primaryShardAllocator,\n-                                                   ReplicaShardAllocator replicaShardAllocator) {\n-        RoutingNodes.UnassignedShards unassigned = allocation.routingNodes().unassigned();\n-        unassigned.sort(PriorityComparator.getAllocationComparator(allocation)); // sort for priority ordering\n-\n-        primaryShardAllocator.allocateUnassigned(allocation);\n+    @Override\n+    public void afterPrimariesBeforeReplicas(RoutingAllocation allocation) {\n+        assert replicaShardAllocator != null;\n         if (allocation.routingNodes().hasInactiveShards()) {\n             // cancel existing recoveries if we have a better match\n             replicaShardAllocator.processExistingRecoveries(allocation);\n         }\n-        replicaShardAllocator.allocateUnassigned(allocation);\n     }\n \n-    /**\n-     * Computes and returns the design for allocating a single unassigned shard.  If called on an assigned shard,\n-     * {@link AllocateUnassignedDecision#NOT_TAKEN} is returned.\n-     */\n-    public AllocateUnassignedDecision decideUnassignedShardAllocation(ShardRouting unassignedShard, RoutingAllocation routingAllocation) {\n+    @Override\n+    public void allocateUnassigned(final RoutingAllocation allocation, ShardRouting shardRouting,\n+                                   RoutingNodes.UnassignedShards.UnassignedIterator iterator) {\n+        assert primaryShardAllocator != null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09c49b88887e84fce940b219e563e936732458c1"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQzNzYzNg==", "bodyText": "I think the decision made here effectively bypasses the balancer. I assume you want to tackle that in a follow-up? Would be nice to know if the intention is to invoke balancer somehow here or if the code here will be changed to only consider the nodes that already have data that can be reused?", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r384437636", "createdAt": "2020-02-26T11:35:49Z", "author": {"login": "henningandersen"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/SearchableSnapshotAllocator.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.searchablesnapshots;\n+\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RoutingNode;\n+import org.elasticsearch.cluster.routing.RoutingNodes;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.UnassignedInfo;\n+import org.elasticsearch.cluster.routing.allocation.AllocateUnassignedDecision;\n+import org.elasticsearch.cluster.routing.allocation.AllocationDecision;\n+import org.elasticsearch.cluster.routing.allocation.ExistingShardsAllocator;\n+import org.elasticsearch.cluster.routing.allocation.FailedShard;\n+import org.elasticsearch.cluster.routing.allocation.NodeAllocationResult;\n+import org.elasticsearch.cluster.routing.allocation.RoutingAllocation;\n+import org.elasticsearch.cluster.routing.allocation.decider.Decision;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class SearchableSnapshotAllocator implements ExistingShardsAllocator {\n+\n+    static final String ALLOCATOR_NAME = \"searchable_snapshot_allocator\";\n+\n+    @Override\n+    public void beforeAllocation(RoutingAllocation allocation) {\n+    }\n+\n+    @Override\n+    public void afterPrimariesBeforeReplicas(RoutingAllocation allocation) {\n+    }\n+\n+    @Override\n+    public void allocateUnassigned(RoutingAllocation allocation, ShardRouting shardRouting,\n+                                   RoutingNodes.UnassignedShards.UnassignedIterator iterator) {\n+        final AllocateUnassignedDecision allocateUnassignedDecision = decideAllocation(allocation, shardRouting);\n+        assert allocateUnassignedDecision.isDecisionTaken();\n+\n+        if (allocateUnassignedDecision.getAllocationDecision() == AllocationDecision.YES) {\n+            if (shardRouting.primary() && shardRouting.recoverySource().getType() == RecoverySource.Type.EXISTING_STORE) {\n+                // we don't care what the allocation ID is since we know that these shards cannot really be stale, so we can\n+                // safely ignore the allocation ID with a forced-stale allocation\n+                iterator.updateUnassigned(shardRouting.unassignedInfo(),\n+                    RecoverySource.ExistingStoreRecoverySource.FORCE_STALE_PRIMARY_INSTANCE, allocation.changes());\n+            }\n+            iterator.initialize(allocateUnassignedDecision.getTargetNode().getId(), null, 0L, allocation.changes());\n+        } else {\n+            iterator.removeAndIgnore(allocateUnassignedDecision.getAllocationStatus(), allocation.changes());\n+        }\n+    }\n+\n+    private static AllocateUnassignedDecision decideAllocation(RoutingAllocation allocation, ShardRouting shardRouting) {\n+        assert shardRouting.unassigned();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09c49b88887e84fce940b219e563e936732458c1"}, "originalPosition": 56}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f1228d6507d255e1cc2770a9311953cd08f0a9e8", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/f1228d6507d255e1cc2770a9311953cd08f0a9e8", "committedDate": "2020-03-02T12:29:36Z", "message": "Merge branch 'feature/searchable-snapshots' into 2020-02-19-pluggable-allocator-for-existing-shards"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "76824384122e22ab99f89b6f6bbf8ed10fdc1dbf", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/76824384122e22ab99f89b6f6bbf8ed10fdc1dbf", "committedDate": "2020-03-02T12:38:26Z", "message": "Reformat"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c9b84abb5c0baf326b626328c3acb068fd0b7e00", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/c9b84abb5c0baf326b626328c3acb068fd0b7e00", "committedDate": "2020-03-02T12:44:36Z", "message": "Consistent use of loops"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6cd09170c514caee8c2848fb8708ed94280555ad", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/6cd09170c514caee8c2848fb8708ed94280555ad", "committedDate": "2020-03-02T12:47:29Z", "message": "Improve comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e6e5b7e617a94e725a072abe140376b8a92118ad", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/e6e5b7e617a94e725a072abe140376b8a92118ad", "committedDate": "2020-03-02T12:57:12Z", "message": "Use null  rather than empty for unset"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c7c1701c25e51874d75446fe28f8e38691f02df4", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/c7c1701c25e51874d75446fe28f8e38691f02df4", "committedDate": "2020-03-02T13:41:22Z", "message": "Extract interface"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a72d9ba05df5f3861095eb50b6450c3feae98b15", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/a72d9ba05df5f3861095eb50b6450c3feae98b15", "committedDate": "2020-03-02T13:56:52Z", "message": "Consistent argument order"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3301a2b8444c5a37c263754033109d8bee054963", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/3301a2b8444c5a37c263754033109d8bee054963", "committedDate": "2020-03-02T13:57:57Z", "message": "More specific method name"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4b8888c0311d0bfc886baa7ae0349b61749d103e", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/4b8888c0311d0bfc886baa7ae0349b61749d103e", "committedDate": "2020-03-02T14:27:10Z", "message": "Capture plugins at init time"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5NzU1MTM4", "url": "https://github.com/elastic/elasticsearch/pull/52527#pullrequestreview-369755138", "createdAt": "2020-03-05T17:08:25Z", "commit": {"oid": "4b8888c0311d0bfc886baa7ae0349b61749d103e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwMTE1OTE0", "url": "https://github.com/elastic/elasticsearch/pull/52527#pullrequestreview-370115914", "createdAt": "2020-03-06T07:02:17Z", "commit": {"oid": "4b8888c0311d0bfc886baa7ae0349b61749d103e"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwNzowMjoxN1rOFyu27Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwNzoyMToyMVrOFyvL4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc0MDg0NQ==", "bodyText": "Can we include clusterPlugin.getClass().getName() into the message?", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r388740845", "createdAt": "2020-03-06T07:02:17Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/cluster/ClusterModule.java", "diffHunk": "@@ -251,4 +254,21 @@ protected void configure() {\n         bind(AllocationDeciders.class).toInstance(allocationDeciders);\n         bind(ShardsAllocator.class).toInstance(shardsAllocator);\n     }\n+\n+    public void setExistingShardsAllocators(GatewayAllocator gatewayAllocator) {\n+        final Map<String, ExistingShardsAllocator> existingShardsAllocators = new HashMap<>();\n+        existingShardsAllocators.put(GatewayAllocator.ALLOCATOR_NAME, gatewayAllocator);\n+\n+        for (ClusterPlugin clusterPlugin : clusterPlugins) {\n+            for (Map.Entry<String, ExistingShardsAllocator> existingShardsAllocatorEntry\n+                : clusterPlugin.getExistingShardsAllocators().entrySet()) {\n+                final String allocatorName = existingShardsAllocatorEntry.getKey();\n+                if (existingShardsAllocators.put(allocatorName, existingShardsAllocatorEntry.getValue()) != null) {\n+                    throw new IllegalArgumentException(\"ExistingShardsAllocator [\" + allocatorName + \"] already defined\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b8888c0311d0bfc886baa7ae0349b61749d103e"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc0MzU5OQ==", "bodyText": "nit: remove extra empty line.", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r388743599", "createdAt": "2020-03-06T07:12:29Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/cluster/routing/allocation/ExistingShardsAllocator.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.cluster.routing.allocation;\n+\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RoutingChangesObserver;\n+import org.elasticsearch.cluster.routing.RoutingNodes;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.UnassignedInfo;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.gateway.GatewayAllocator;\n+\n+import java.util.List;\n+\n+/**\n+ * Searches for, and allocates, shards for which there is an existing on-disk copy somewhere in the cluster. The default implementation is\n+ * {@link GatewayAllocator}, but plugins can supply their own implementations too.\n+ */\n+public interface ExistingShardsAllocator {\n+\n+    /**\n+     * Allows plugins to override how we allocate shards that may already exist on disk in the cluster.\n+     */\n+    Setting<String> EXISTING_SHARDS_ALLOCATOR_SETTING = Setting.simpleString(\n+        \"index.allocation.existing_shards_allocator\", GatewayAllocator.ALLOCATOR_NAME,\n+        Setting.Property.IndexScope, Setting.Property.PrivateIndex);\n+\n+    /**\n+     * Called before starting a round of allocation, allowing the allocator to invalidate some caches if appropriate.\n+     */\n+    void beforeAllocation(RoutingAllocation allocation);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b8888c0311d0bfc886baa7ae0349b61749d103e"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc0NjIxMA==", "bodyText": "nit: swap argument order to make it the same as in ExistingShardsAllocator:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void allocateUnassigned(RoutingAllocation allocation, ShardRouting shardRouting,\n          \n          \n            \n                public void allocateUnassigned(ShardRouting shardRouting, RoutingAllocation allocation,", "url": "https://github.com/elastic/elasticsearch/pull/52527#discussion_r388746210", "createdAt": "2020-03-06T07:21:21Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/gateway/BaseGatewayShardAllocator.java", "diffHunk": "@@ -45,40 +45,38 @@\n     protected final Logger logger = LogManager.getLogger(this.getClass());\n \n     /**\n-     * Allocate unassigned shards to nodes (if any) where valid copies of the shard already exist.\n+     * Allocate an unassigned shard to nodes (if any) where valid copies of the shard already exist.\n      * It is up to the individual implementations of {@link #makeAllocationDecision(ShardRouting, RoutingAllocation, Logger)}\n      * to make decisions on assigning shards to nodes.\n      *\n      * @param allocation the allocation state container object\n+     * @param shardRouting the shard to allocate\n+     * @param unassignedAllocationHandler handles the allocation of the current shard\n      */\n-    public void allocateUnassigned(RoutingAllocation allocation) {\n-        final RoutingNodes routingNodes = allocation.routingNodes();\n-        final RoutingNodes.UnassignedShards.UnassignedIterator unassignedIterator = routingNodes.unassigned().iterator();\n-        while (unassignedIterator.hasNext()) {\n-            final ShardRouting shard = unassignedIterator.next();\n-            final AllocateUnassignedDecision allocateUnassignedDecision = makeAllocationDecision(shard, allocation, logger);\n+    public void allocateUnassigned(RoutingAllocation allocation, ShardRouting shardRouting,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b8888c0311d0bfc886baa7ae0349b61749d103e"}, "originalPosition": 31}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac303eb1587a24c565f05808845c7a7a93820ac8", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/ac303eb1587a24c565f05808845c7a7a93820ac8", "committedDate": "2020-03-11T10:03:58Z", "message": "Merge branch 'feature/searchable-snapshots' into 2020-02-19-pluggable-allocator-for-existing-shards"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "01c9b332f2ae5da3ffe904a60b88736a1c8075a0", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/01c9b332f2ae5da3ffe904a60b88736a1c8075a0", "committedDate": "2020-03-11T10:05:34Z", "message": "Include plugin class name in error"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1857794ee90db345ad630389bccc6dc679d84299", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/1857794ee90db345ad630389bccc6dc679d84299", "committedDate": "2020-03-11T10:05:56Z", "message": "Whitespace"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "41fa9c6d042bb48c4588b28e14730bde02647e8e", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/41fa9c6d042bb48c4588b28e14730bde02647e8e", "committedDate": "2020-03-11T10:15:21Z", "message": "Reorder params"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4c9d3ee5ec37bde13a62774d11f715ba69e8d5bf", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/4c9d3ee5ec37bde13a62774d11f715ba69e8d5bf", "committedDate": "2020-03-11T10:32:38Z", "message": "Merge branch 'feature/searchable-snapshots' into 2020-02-19-pluggable-allocator-for-existing-shards"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "05b690c52472b3246798326088784ae3a91e4b79", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/05b690c52472b3246798326088784ae3a91e4b79", "committedDate": "2020-03-11T12:48:29Z", "message": "Merge branch 'feature/searchable-snapshots' into 2020-02-19-pluggable-allocator-for-existing-shards"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2447, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}