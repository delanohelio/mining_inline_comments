{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE0OTg2MzMy", "number": 56398, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMDo0OToxM1rOD70fnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMDo0OToxM1rOD70fnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MDUyNjM2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authz/store/FileRolesStoreTests.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMDo0OToxM1rOGUYZlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwMjozOTo0NlrOGUfgrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAyNDQ2OA==", "bodyText": "Not a big deal but you can maintain the modifiedFileRolesModified.addAll(roleSet); from before and assert it contains role5.", "url": "https://github.com/elastic/elasticsearch/pull/56398#discussion_r424024468", "createdAt": "2020-05-12T20:49:13Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authz/store/FileRolesStoreTests.java", "diffHunk": "@@ -394,48 +394,56 @@ public void testAutoReload() throws Exception {\n             assertThat(role.cluster().check(\"cluster:admin/foo/bar\", request, authentication), is(false));\n \n             // truncate to remove some\n-            final Set<String> truncatedFileRolesModified = new HashSet<>();\n+            // Not asserting exact content of the role change set since file truncation and subsequent are not\n+            // atomic and hence can result in different change set to be reported.\n             final CountDownLatch truncateLatch = new CountDownLatch(1);\n             store = new FileRolesStore(settings, env, watcherService, roleSet -> {\n-                truncatedFileRolesModified.addAll(roleSet);\n-                truncateLatch.countDown();\n+                if (roleSet.contains(\"dummy1\")) {\n+                    truncateLatch.countDown();\n+                }\n             }, new XPackLicenseState(Settings.EMPTY), xContentRegistry());\n \n             final Set<String> allRolesPreTruncate = store.getAllRoleNames();\n+            assertTrue(allRolesPreTruncate.contains(\"role5\"));\n+            // Use a marker role so that when the countdown latch is triggered,\n+            // we are sure it is triggered by the new file content instead of the initial truncation\n             try (BufferedWriter writer = Files.newBufferedWriter(tmp, StandardCharsets.UTF_8, StandardOpenOption.TRUNCATE_EXISTING)) {\n                 writer.append(\"role5:\").append(System.lineSeparator());\n                 writer.append(\"  cluster:\").append(System.lineSeparator());\n-                writer.append(\"    - 'MONITOR'\");\n+                writer.append(\"    - 'MONITOR'\").append(System.lineSeparator());\n+                writer.append(\"dummy1:\").append(System.lineSeparator());\n+                writer.append(\"  cluster:\").append(System.lineSeparator());\n+                writer.append(\"    - 'ALL'\");\n             }\n \n-            truncateLatch.await();\n-            assertEquals(allRolesPreTruncate.size() - 1, truncatedFileRolesModified.size());\n-            assertTrue(allRolesPreTruncate.contains(\"role5\"));\n-            assertFalse(truncatedFileRolesModified.contains(\"role5\"));\n+            assertTrue(truncateLatch.await(5, TimeUnit.SECONDS));\n             descriptors = store.roleDescriptors(Collections.singleton(\"role5\"));\n             assertThat(descriptors, notNullValue());\n             assertEquals(1, descriptors.size());\n+            assertArrayEquals(new String[]{\"MONITOR\"}, descriptors.iterator().next().getClusterPrivileges());\n \n             // modify\n-            final Set<String> modifiedFileRolesModified = new HashSet<>();\n             final CountDownLatch modifyLatch = new CountDownLatch(1);\n             store = new FileRolesStore(settings, env, watcherService, roleSet -> {\n-                modifiedFileRolesModified.addAll(roleSet);\n-                modifyLatch.countDown();\n+                if (roleSet.contains(\"dummy2\")) {\n+                    modifyLatch.countDown();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff8aa946a2aede6152f4e8ca982406d5ae3ba2a4"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE0MDk3NQ==", "bodyText": "Added back.", "url": "https://github.com/elastic/elasticsearch/pull/56398#discussion_r424140975", "createdAt": "2020-05-13T02:39:46Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authz/store/FileRolesStoreTests.java", "diffHunk": "@@ -394,48 +394,56 @@ public void testAutoReload() throws Exception {\n             assertThat(role.cluster().check(\"cluster:admin/foo/bar\", request, authentication), is(false));\n \n             // truncate to remove some\n-            final Set<String> truncatedFileRolesModified = new HashSet<>();\n+            // Not asserting exact content of the role change set since file truncation and subsequent are not\n+            // atomic and hence can result in different change set to be reported.\n             final CountDownLatch truncateLatch = new CountDownLatch(1);\n             store = new FileRolesStore(settings, env, watcherService, roleSet -> {\n-                truncatedFileRolesModified.addAll(roleSet);\n-                truncateLatch.countDown();\n+                if (roleSet.contains(\"dummy1\")) {\n+                    truncateLatch.countDown();\n+                }\n             }, new XPackLicenseState(Settings.EMPTY), xContentRegistry());\n \n             final Set<String> allRolesPreTruncate = store.getAllRoleNames();\n+            assertTrue(allRolesPreTruncate.contains(\"role5\"));\n+            // Use a marker role so that when the countdown latch is triggered,\n+            // we are sure it is triggered by the new file content instead of the initial truncation\n             try (BufferedWriter writer = Files.newBufferedWriter(tmp, StandardCharsets.UTF_8, StandardOpenOption.TRUNCATE_EXISTING)) {\n                 writer.append(\"role5:\").append(System.lineSeparator());\n                 writer.append(\"  cluster:\").append(System.lineSeparator());\n-                writer.append(\"    - 'MONITOR'\");\n+                writer.append(\"    - 'MONITOR'\").append(System.lineSeparator());\n+                writer.append(\"dummy1:\").append(System.lineSeparator());\n+                writer.append(\"  cluster:\").append(System.lineSeparator());\n+                writer.append(\"    - 'ALL'\");\n             }\n \n-            truncateLatch.await();\n-            assertEquals(allRolesPreTruncate.size() - 1, truncatedFileRolesModified.size());\n-            assertTrue(allRolesPreTruncate.contains(\"role5\"));\n-            assertFalse(truncatedFileRolesModified.contains(\"role5\"));\n+            assertTrue(truncateLatch.await(5, TimeUnit.SECONDS));\n             descriptors = store.roleDescriptors(Collections.singleton(\"role5\"));\n             assertThat(descriptors, notNullValue());\n             assertEquals(1, descriptors.size());\n+            assertArrayEquals(new String[]{\"MONITOR\"}, descriptors.iterator().next().getClusterPrivileges());\n \n             // modify\n-            final Set<String> modifiedFileRolesModified = new HashSet<>();\n             final CountDownLatch modifyLatch = new CountDownLatch(1);\n             store = new FileRolesStore(settings, env, watcherService, roleSet -> {\n-                modifiedFileRolesModified.addAll(roleSet);\n-                modifyLatch.countDown();\n+                if (roleSet.contains(\"dummy2\")) {\n+                    modifyLatch.countDown();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAyNDQ2OA=="}, "originalCommit": {"oid": "ff8aa946a2aede6152f4e8ca982406d5ae3ba2a4"}, "originalPosition": 47}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 643, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}