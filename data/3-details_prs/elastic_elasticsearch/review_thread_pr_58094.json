{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM0MzkyOTI0", "number": 58094, "reviewThreads": {"totalCount": 37, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNTowMjozNlrOEGZAEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQyMzoxMDo1OFrOEI9BgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MTM2NTMxOnYy", "diffSide": "RIGHT", "path": "server/src/internalClusterTest/java/org/elasticsearch/blocks/SimpleBlocksIT.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNTowMjozNlrOGlKD-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNTowMjozNlrOGlKD-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYxNTM1NQ==", "bodyText": "I think closeIndexResponse is a confusing name here?", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r441615355", "createdAt": "2020-06-17T15:02:36Z", "author": {"login": "dakrone"}, "path": "server/src/internalClusterTest/java/org/elasticsearch/blocks/SimpleBlocksIT.java", "diffHunk": "@@ -133,11 +163,320 @@ private void canNotIndexDocument(String index) {\n \n     private void setIndexReadOnly(String index, Object value) {\n         HashMap<String, Object> newSettings = new HashMap<>();\n-        newSettings.put(IndexMetadata.SETTING_READ_ONLY, value);\n+        newSettings.put(SETTING_READ_ONLY, value);\n \n         UpdateSettingsRequestBuilder settingsRequest = client().admin().indices().prepareUpdateSettings(index);\n         settingsRequest.setSettings(newSettings);\n         AcknowledgedResponse settingsResponse = settingsRequest.execute().actionGet();\n         assertThat(settingsResponse, notNullValue());\n     }\n+\n+\n+    public void testAddBlocksWhileExistingBlocks() {\n+        createIndex(\"test\");\n+        ensureGreen(\"test\");\n+\n+        for (APIBlock otherBlock : APIBlock.values()) {\n+\n+            for (APIBlock block : Arrays.asList(APIBlock.READ, APIBlock.WRITE)) {\n+                try {\n+                    enableIndexBlock(\"test\", block.settingName());\n+\n+                    // Adding a block is not blocked\n+                    AcknowledgedResponse closeIndexResponse = client().admin().indices()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a87646578660c0fa2f77543fcf03b0277dd3c776"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MTM4NjE2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/readonly/AddIndexBlockAction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNTowNjo0NlrOGlKRIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNTowNjo0NlrOGlKRIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYxODcyMw==", "bodyText": "A lot of our action names follow a hierarchy, so I'd suggest\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final String NAME = \"indices:admin/add-index-block\";\n          \n          \n            \n                public static final String NAME = \"indices:admin/block/add\";\n          \n      \n    \n    \n  \n\nWhich gives us the chance to set permissions for indices:admin/block/* in the event we ever add another API (think indices:admin/block/remove for example)", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r441618723", "createdAt": "2020-06-17T15:06:46Z", "author": {"login": "dakrone"}, "path": "server/src/main/java/org/elasticsearch/action/admin/indices/readonly/AddIndexBlockAction.java", "diffHunk": "@@ -0,0 +1,32 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.admin.indices.readonly;\n+\n+import org.elasticsearch.action.ActionType;\n+\n+public class AddIndexBlockAction extends ActionType<AddIndexBlockResponse> {\n+\n+    public static final AddIndexBlockAction INSTANCE = new AddIndexBlockAction();\n+    public static final String NAME = \"indices:admin/add-index-block\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a87646578660c0fa2f77543fcf03b0277dd3c776"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MTQxMTE2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/readonly/AddIndexBlockClusterStateUpdateRequest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNToxMTozM1rOGlKgXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNToxMTozM1rOGlKgXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYyMjYyMw==", "bodyText": "This docstring needs to be updated", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r441622623", "createdAt": "2020-06-17T15:11:33Z", "author": {"login": "dakrone"}, "path": "server/src/main/java/org/elasticsearch/action/admin/indices/readonly/AddIndexBlockClusterStateUpdateRequest.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.action.admin.indices.readonly;\n+\n+import org.elasticsearch.cluster.ack.IndicesClusterStateUpdateRequest;\n+import org.elasticsearch.cluster.metadata.IndexMetadata.APIBlock;\n+\n+/**\n+ * Cluster state update request that allows to close one or more indices", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a87646578660c0fa2f77543fcf03b0277dd3c776"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MTQyMTU0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/readonly/AddIndexBlockRequest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNToxMzozNlrOGlKnDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNToxMzozNlrOGlKnDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYyNDMzMw==", "bodyText": "This needs to be updated as well :)", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r441624333", "createdAt": "2020-06-17T15:13:36Z", "author": {"login": "dakrone"}, "path": "server/src/main/java/org/elasticsearch/action/admin/indices/readonly/AddIndexBlockRequest.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.admin.indices.readonly;\n+\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.IndicesRequest;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.action.support.master.AcknowledgedRequest;\n+import org.elasticsearch.cluster.metadata.IndexMetadata.APIBlock;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.util.CollectionUtils;\n+\n+import java.io.IOException;\n+\n+import static org.elasticsearch.action.ValidateActions.addValidationError;\n+\n+/**\n+ * A request to close an index.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a87646578660c0fa2f77543fcf03b0277dd3c776"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MTQyNjc3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/readonly/AddIndexBlockRequest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNToxNDo1MVrOGlKqjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwOTo1NjoxNVrOGoLT1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYyNTIzMA==", "bodyText": "I think we may also want to validate that a block was specified and non-null?", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r441625230", "createdAt": "2020-06-17T15:14:51Z", "author": {"login": "dakrone"}, "path": "server/src/main/java/org/elasticsearch/action/admin/indices/readonly/AddIndexBlockRequest.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.admin.indices.readonly;\n+\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.IndicesRequest;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.action.support.master.AcknowledgedRequest;\n+import org.elasticsearch.cluster.metadata.IndexMetadata.APIBlock;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.util.CollectionUtils;\n+\n+import java.io.IOException;\n+\n+import static org.elasticsearch.action.ValidateActions.addValidationError;\n+\n+/**\n+ * A request to close an index.\n+ */\n+public class AddIndexBlockRequest extends AcknowledgedRequest<AddIndexBlockRequest> implements IndicesRequest.Replaceable {\n+\n+    private APIBlock block;\n+    private String[] indices;\n+    private IndicesOptions indicesOptions = IndicesOptions.strictExpandOpen();\n+\n+    public AddIndexBlockRequest(StreamInput in) throws IOException {\n+        super(in);\n+        indices = in.readStringArray();\n+        indicesOptions = IndicesOptions.readIndicesOptions(in);\n+        block = APIBlock.readFrom(in);\n+    }\n+\n+    public AddIndexBlockRequest() {\n+    }\n+\n+    /**\n+     * Constructs a new close index request for the specified index.\n+     */\n+    public AddIndexBlockRequest(APIBlock block, String... indices) {\n+        this.block = block;\n+        this.indices = indices;\n+    }\n+\n+    @Override\n+    public ActionRequestValidationException validate() {\n+        ActionRequestValidationException validationException = null;\n+        if (CollectionUtils.isEmpty(indices)) {\n+            validationException = addValidationError(\"index is missing\", validationException);\n+        }\n+        return validationException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a87646578660c0fa2f77543fcf03b0277dd3c776"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc4MTUyNw==", "bodyText": "I've made it so that it never can be null (as also requested below)", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r444781527", "createdAt": "2020-06-24T09:56:15Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/action/admin/indices/readonly/AddIndexBlockRequest.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.admin.indices.readonly;\n+\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.IndicesRequest;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.action.support.master.AcknowledgedRequest;\n+import org.elasticsearch.cluster.metadata.IndexMetadata.APIBlock;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.util.CollectionUtils;\n+\n+import java.io.IOException;\n+\n+import static org.elasticsearch.action.ValidateActions.addValidationError;\n+\n+/**\n+ * A request to close an index.\n+ */\n+public class AddIndexBlockRequest extends AcknowledgedRequest<AddIndexBlockRequest> implements IndicesRequest.Replaceable {\n+\n+    private APIBlock block;\n+    private String[] indices;\n+    private IndicesOptions indicesOptions = IndicesOptions.strictExpandOpen();\n+\n+    public AddIndexBlockRequest(StreamInput in) throws IOException {\n+        super(in);\n+        indices = in.readStringArray();\n+        indicesOptions = IndicesOptions.readIndicesOptions(in);\n+        block = APIBlock.readFrom(in);\n+    }\n+\n+    public AddIndexBlockRequest() {\n+    }\n+\n+    /**\n+     * Constructs a new close index request for the specified index.\n+     */\n+    public AddIndexBlockRequest(APIBlock block, String... indices) {\n+        this.block = block;\n+        this.indices = indices;\n+    }\n+\n+    @Override\n+    public ActionRequestValidationException validate() {\n+        ActionRequestValidationException validationException = null;\n+        if (CollectionUtils.isEmpty(indices)) {\n+            validationException = addValidationError(\"index is missing\", validationException);\n+        }\n+        return validationException;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYyNTIzMA=="}, "originalCommit": {"oid": "a87646578660c0fa2f77543fcf03b0277dd3c776"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MTQyNzMwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/readonly/AddIndexBlockRequest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNToxNDo1OVrOGlKq6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNToxNDo1OVrOGlKq6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYyNTMyMw==", "bodyText": "Needs to be updated :)", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r441625323", "createdAt": "2020-06-17T15:14:59Z", "author": {"login": "dakrone"}, "path": "server/src/main/java/org/elasticsearch/action/admin/indices/readonly/AddIndexBlockRequest.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.admin.indices.readonly;\n+\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.IndicesRequest;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.action.support.master.AcknowledgedRequest;\n+import org.elasticsearch.cluster.metadata.IndexMetadata.APIBlock;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.util.CollectionUtils;\n+\n+import java.io.IOException;\n+\n+import static org.elasticsearch.action.ValidateActions.addValidationError;\n+\n+/**\n+ * A request to close an index.\n+ */\n+public class AddIndexBlockRequest extends AcknowledgedRequest<AddIndexBlockRequest> implements IndicesRequest.Replaceable {\n+\n+    private APIBlock block;\n+    private String[] indices;\n+    private IndicesOptions indicesOptions = IndicesOptions.strictExpandOpen();\n+\n+    public AddIndexBlockRequest(StreamInput in) throws IOException {\n+        super(in);\n+        indices = in.readStringArray();\n+        indicesOptions = IndicesOptions.readIndicesOptions(in);\n+        block = APIBlock.readFrom(in);\n+    }\n+\n+    public AddIndexBlockRequest() {\n+    }\n+\n+    /**\n+     * Constructs a new close index request for the specified index.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a87646578660c0fa2f77543fcf03b0277dd3c776"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MTQyODc5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/readonly/AddIndexBlockRequest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNToxNToxNlrOGlKr4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNToxNToxNlrOGlKr4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYyNTU3MA==", "bodyText": "Needs to be updated (last time I'll mention it for this file)", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r441625570", "createdAt": "2020-06-17T15:15:16Z", "author": {"login": "dakrone"}, "path": "server/src/main/java/org/elasticsearch/action/admin/indices/readonly/AddIndexBlockRequest.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.admin.indices.readonly;\n+\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.IndicesRequest;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.action.support.master.AcknowledgedRequest;\n+import org.elasticsearch.cluster.metadata.IndexMetadata.APIBlock;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.util.CollectionUtils;\n+\n+import java.io.IOException;\n+\n+import static org.elasticsearch.action.ValidateActions.addValidationError;\n+\n+/**\n+ * A request to close an index.\n+ */\n+public class AddIndexBlockRequest extends AcknowledgedRequest<AddIndexBlockRequest> implements IndicesRequest.Replaceable {\n+\n+    private APIBlock block;\n+    private String[] indices;\n+    private IndicesOptions indicesOptions = IndicesOptions.strictExpandOpen();\n+\n+    public AddIndexBlockRequest(StreamInput in) throws IOException {\n+        super(in);\n+        indices = in.readStringArray();\n+        indicesOptions = IndicesOptions.readIndicesOptions(in);\n+        block = APIBlock.readFrom(in);\n+    }\n+\n+    public AddIndexBlockRequest() {\n+    }\n+\n+    /**\n+     * Constructs a new close index request for the specified index.\n+     */\n+    public AddIndexBlockRequest(APIBlock block, String... indices) {\n+        this.block = block;\n+        this.indices = indices;\n+    }\n+\n+    @Override\n+    public ActionRequestValidationException validate() {\n+        ActionRequestValidationException validationException = null;\n+        if (CollectionUtils.isEmpty(indices)) {\n+            validationException = addValidationError(\"index is missing\", validationException);\n+        }\n+        return validationException;\n+    }\n+\n+    /**\n+     * The indices to be closed\n+     * @return the indices to be closed", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a87646578660c0fa2f77543fcf03b0277dd3c776"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MTQzMzA3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/readonly/AddIndexBlockRequest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNToxNjoxMlrOGlKunQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNToxNjoxMlrOGlKunQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYyNjI2OQ==", "bodyText": "Can you wrap these in Objects.requireNonNull? I'd rather catch NPEs here than in serialization", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r441626269", "createdAt": "2020-06-17T15:16:12Z", "author": {"login": "dakrone"}, "path": "server/src/main/java/org/elasticsearch/action/admin/indices/readonly/AddIndexBlockRequest.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.admin.indices.readonly;\n+\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.IndicesRequest;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.action.support.master.AcknowledgedRequest;\n+import org.elasticsearch.cluster.metadata.IndexMetadata.APIBlock;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.util.CollectionUtils;\n+\n+import java.io.IOException;\n+\n+import static org.elasticsearch.action.ValidateActions.addValidationError;\n+\n+/**\n+ * A request to close an index.\n+ */\n+public class AddIndexBlockRequest extends AcknowledgedRequest<AddIndexBlockRequest> implements IndicesRequest.Replaceable {\n+\n+    private APIBlock block;\n+    private String[] indices;\n+    private IndicesOptions indicesOptions = IndicesOptions.strictExpandOpen();\n+\n+    public AddIndexBlockRequest(StreamInput in) throws IOException {\n+        super(in);\n+        indices = in.readStringArray();\n+        indicesOptions = IndicesOptions.readIndicesOptions(in);\n+        block = APIBlock.readFrom(in);\n+    }\n+\n+    public AddIndexBlockRequest() {\n+    }\n+\n+    /**\n+     * Constructs a new close index request for the specified index.\n+     */\n+    public AddIndexBlockRequest(APIBlock block, String... indices) {\n+        this.block = block;\n+        this.indices = indices;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a87646578660c0fa2f77543fcf03b0277dd3c776"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MTQzNjM2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/readonly/AddIndexBlockRequest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNToxNjo1NFrOGlKwww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwOTo1Njo0MVrOGoLUxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYyNjgxOQ==", "bodyText": "I think we should make this private (or even better, remove it entirely) since leaving block and indices as null would lead to an NPE on serialization", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r441626819", "createdAt": "2020-06-17T15:16:54Z", "author": {"login": "dakrone"}, "path": "server/src/main/java/org/elasticsearch/action/admin/indices/readonly/AddIndexBlockRequest.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.admin.indices.readonly;\n+\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.IndicesRequest;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.action.support.master.AcknowledgedRequest;\n+import org.elasticsearch.cluster.metadata.IndexMetadata.APIBlock;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.util.CollectionUtils;\n+\n+import java.io.IOException;\n+\n+import static org.elasticsearch.action.ValidateActions.addValidationError;\n+\n+/**\n+ * A request to close an index.\n+ */\n+public class AddIndexBlockRequest extends AcknowledgedRequest<AddIndexBlockRequest> implements IndicesRequest.Replaceable {\n+\n+    private APIBlock block;\n+    private String[] indices;\n+    private IndicesOptions indicesOptions = IndicesOptions.strictExpandOpen();\n+\n+    public AddIndexBlockRequest(StreamInput in) throws IOException {\n+        super(in);\n+        indices = in.readStringArray();\n+        indicesOptions = IndicesOptions.readIndicesOptions(in);\n+        block = APIBlock.readFrom(in);\n+    }\n+\n+    public AddIndexBlockRequest() {\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a87646578660c0fa2f77543fcf03b0277dd3c776"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc4MTc2Nw==", "bodyText": "I've removed it", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r444781767", "createdAt": "2020-06-24T09:56:41Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/action/admin/indices/readonly/AddIndexBlockRequest.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.admin.indices.readonly;\n+\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.IndicesRequest;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.action.support.master.AcknowledgedRequest;\n+import org.elasticsearch.cluster.metadata.IndexMetadata.APIBlock;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.util.CollectionUtils;\n+\n+import java.io.IOException;\n+\n+import static org.elasticsearch.action.ValidateActions.addValidationError;\n+\n+/**\n+ * A request to close an index.\n+ */\n+public class AddIndexBlockRequest extends AcknowledgedRequest<AddIndexBlockRequest> implements IndicesRequest.Replaceable {\n+\n+    private APIBlock block;\n+    private String[] indices;\n+    private IndicesOptions indicesOptions = IndicesOptions.strictExpandOpen();\n+\n+    public AddIndexBlockRequest(StreamInput in) throws IOException {\n+        super(in);\n+        indices = in.readStringArray();\n+        indicesOptions = IndicesOptions.readIndicesOptions(in);\n+        block = APIBlock.readFrom(in);\n+    }\n+\n+    public AddIndexBlockRequest() {\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYyNjgxOQ=="}, "originalCommit": {"oid": "a87646578660c0fa2f77543fcf03b0277dd3c776"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MTQ1Nzg1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/readonly/AddIndexBlockRequestBuilder.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNToyMTo0NFrOGlK-sw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMDowMTo0OVrOGoLfpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYzMDM4Nw==", "bodyText": "To be 100% honest, I don't think we need this class, the request itself is pretty simple, and we haven't been adding builders for quite a while since the transport client is no more. I think it could be removed?", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r441630387", "createdAt": "2020-06-17T15:21:44Z", "author": {"login": "dakrone"}, "path": "server/src/main/java/org/elasticsearch/action/admin/indices/readonly/AddIndexBlockRequestBuilder.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.admin.indices.readonly;\n+\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.action.support.master.AcknowledgedRequestBuilder;\n+import org.elasticsearch.client.ElasticsearchClient;\n+import org.elasticsearch.cluster.metadata.IndexMetadata.APIBlock;\n+\n+/**\n+ * Builder for close index request\n+ */\n+public class AddIndexBlockRequestBuilder", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a87646578660c0fa2f77543fcf03b0277dd3c776"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc4NDU0OQ==", "bodyText": "I would prefer to keep the builder, in particular as this is being backported to 7.x, which still has the transport client. I also prefer to keep things consistent in the code base.", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r444784549", "createdAt": "2020-06-24T10:01:49Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/action/admin/indices/readonly/AddIndexBlockRequestBuilder.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.admin.indices.readonly;\n+\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.action.support.master.AcknowledgedRequestBuilder;\n+import org.elasticsearch.client.ElasticsearchClient;\n+import org.elasticsearch.cluster.metadata.IndexMetadata.APIBlock;\n+\n+/**\n+ * Builder for close index request\n+ */\n+public class AddIndexBlockRequestBuilder", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYzMDM4Nw=="}, "originalCommit": {"oid": "a87646578660c0fa2f77543fcf03b0277dd3c776"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MTYxNTU5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/readonly/AddIndexBlockResponse.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNTo1OTozMFrOGlMijw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQwODowMjo1NFrOGqJHtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY1NTk1MQ==", "bodyText": "We are trying to get away from dynamically keyed objects in our REST APIs, would it be possible to change this to an array of objects with name: ... and failures: [...] keys?", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r441655951", "createdAt": "2020-06-17T15:59:30Z", "author": {"login": "dakrone"}, "path": "server/src/main/java/org/elasticsearch/action/admin/indices/readonly/AddIndexBlockResponse.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.action.admin.indices.readonly;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.support.DefaultShardOperationFailedException;\n+import org.elasticsearch.action.support.master.ShardsAcknowledgedResponse;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.util.CollectionUtils;\n+import org.elasticsearch.common.xcontent.ToXContentFragment;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.Index;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static java.util.Collections.unmodifiableList;\n+\n+public class AddIndexBlockResponse extends ShardsAcknowledgedResponse {\n+\n+    private final List<AddBlockResult> indices;\n+\n+    AddIndexBlockResponse(StreamInput in) throws IOException {\n+        super(in, true);\n+        indices = unmodifiableList(in.readList(AddBlockResult::new));\n+    }\n+\n+    public AddIndexBlockResponse(final boolean acknowledged, final boolean shardsAcknowledged, final List<AddBlockResult> indices) {\n+        super(acknowledged, shardsAcknowledged);\n+        this.indices = unmodifiableList(Objects.requireNonNull(indices));\n+    }\n+\n+    public List<AddBlockResult> getIndices() {\n+        return indices;\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        super.writeTo(out);\n+        writeShardsAcknowledged(out);\n+        out.writeList(indices);\n+    }\n+\n+    @Override\n+    protected void addCustomFields(final XContentBuilder builder, final Params params) throws IOException {\n+        super.addCustomFields(builder, params);\n+        builder.startObject(\"indices\");\n+        for (AddBlockResult index : indices) {\n+            index.toXContent(builder, params);\n+        }\n+        builder.endObject();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return Strings.toString(this);\n+    }\n+\n+    public static class AddBlockResult implements Writeable, ToXContentFragment {\n+\n+        private final Index index;\n+        private final @Nullable Exception exception;\n+        private final @Nullable AddBlockShardResult[] shards;\n+\n+        public AddBlockResult(final Index index) {\n+            this(index, null, null);\n+        }\n+\n+        public AddBlockResult(final Index index, final Exception failure) {\n+            this(index, Objects.requireNonNull(failure), null);\n+        }\n+\n+        public AddBlockResult(final Index index, final AddBlockShardResult[] shards) {\n+            this(index, null, Objects.requireNonNull(shards));\n+        }\n+\n+        private AddBlockResult(final Index index, @Nullable final Exception exception, @Nullable final AddBlockShardResult[] shards) {\n+            this.index = Objects.requireNonNull(index);\n+            this.exception = exception;\n+            this.shards = shards;\n+        }\n+\n+        AddBlockResult(final StreamInput in) throws IOException {\n+            this.index = new Index(in);\n+            this.exception = in.readException();\n+            this.shards = in.readOptionalArray(AddBlockShardResult::new, AddBlockShardResult[]::new);\n+        }\n+\n+        @Override\n+        public void writeTo(final StreamOutput out) throws IOException {\n+            index.writeTo(out);\n+            out.writeException(exception);\n+            out.writeOptionalArray(shards);\n+        }\n+\n+        public Index getIndex() {\n+            return index;\n+        }\n+\n+        public Exception getException() {\n+            return exception;\n+        }\n+\n+        public AddBlockShardResult[] getShards() {\n+            return shards;\n+        }\n+\n+        public boolean hasFailures() {\n+            if (exception != null) {\n+                return true;\n+            }\n+            if (shards != null) {\n+                for (AddBlockShardResult shard : shards) {\n+                    if (shard.hasFailures()) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(final XContentBuilder builder, final Params params) throws IOException {\n+            builder.startObject(index.getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a87646578660c0fa2f77543fcf03b0277dd3c776"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc4NjYxOA==", "bodyText": "Looking at other similar APIs here (close index, or index stats), they all dynamically key by index name. For consistency reasons, I prefer to go with what we currently have today. I understand that we want to eventually move to a different place, but would prefer doing so consistently across these APIs.", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r444786618", "createdAt": "2020-06-24T10:05:37Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/action/admin/indices/readonly/AddIndexBlockResponse.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.action.admin.indices.readonly;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.support.DefaultShardOperationFailedException;\n+import org.elasticsearch.action.support.master.ShardsAcknowledgedResponse;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.util.CollectionUtils;\n+import org.elasticsearch.common.xcontent.ToXContentFragment;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.Index;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static java.util.Collections.unmodifiableList;\n+\n+public class AddIndexBlockResponse extends ShardsAcknowledgedResponse {\n+\n+    private final List<AddBlockResult> indices;\n+\n+    AddIndexBlockResponse(StreamInput in) throws IOException {\n+        super(in, true);\n+        indices = unmodifiableList(in.readList(AddBlockResult::new));\n+    }\n+\n+    public AddIndexBlockResponse(final boolean acknowledged, final boolean shardsAcknowledged, final List<AddBlockResult> indices) {\n+        super(acknowledged, shardsAcknowledged);\n+        this.indices = unmodifiableList(Objects.requireNonNull(indices));\n+    }\n+\n+    public List<AddBlockResult> getIndices() {\n+        return indices;\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        super.writeTo(out);\n+        writeShardsAcknowledged(out);\n+        out.writeList(indices);\n+    }\n+\n+    @Override\n+    protected void addCustomFields(final XContentBuilder builder, final Params params) throws IOException {\n+        super.addCustomFields(builder, params);\n+        builder.startObject(\"indices\");\n+        for (AddBlockResult index : indices) {\n+            index.toXContent(builder, params);\n+        }\n+        builder.endObject();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return Strings.toString(this);\n+    }\n+\n+    public static class AddBlockResult implements Writeable, ToXContentFragment {\n+\n+        private final Index index;\n+        private final @Nullable Exception exception;\n+        private final @Nullable AddBlockShardResult[] shards;\n+\n+        public AddBlockResult(final Index index) {\n+            this(index, null, null);\n+        }\n+\n+        public AddBlockResult(final Index index, final Exception failure) {\n+            this(index, Objects.requireNonNull(failure), null);\n+        }\n+\n+        public AddBlockResult(final Index index, final AddBlockShardResult[] shards) {\n+            this(index, null, Objects.requireNonNull(shards));\n+        }\n+\n+        private AddBlockResult(final Index index, @Nullable final Exception exception, @Nullable final AddBlockShardResult[] shards) {\n+            this.index = Objects.requireNonNull(index);\n+            this.exception = exception;\n+            this.shards = shards;\n+        }\n+\n+        AddBlockResult(final StreamInput in) throws IOException {\n+            this.index = new Index(in);\n+            this.exception = in.readException();\n+            this.shards = in.readOptionalArray(AddBlockShardResult::new, AddBlockShardResult[]::new);\n+        }\n+\n+        @Override\n+        public void writeTo(final StreamOutput out) throws IOException {\n+            index.writeTo(out);\n+            out.writeException(exception);\n+            out.writeOptionalArray(shards);\n+        }\n+\n+        public Index getIndex() {\n+            return index;\n+        }\n+\n+        public Exception getException() {\n+            return exception;\n+        }\n+\n+        public AddBlockShardResult[] getShards() {\n+            return shards;\n+        }\n+\n+        public boolean hasFailures() {\n+            if (exception != null) {\n+                return true;\n+            }\n+            if (shards != null) {\n+                for (AddBlockShardResult shard : shards) {\n+                    if (shard.hasFailures()) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(final XContentBuilder builder, final Params params) throws IOException {\n+            builder.startObject(index.getName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY1NTk1MQ=="}, "originalCommit": {"oid": "a87646578660c0fa2f77543fcf03b0277dd3c776"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTg4MDAzNw==", "bodyText": "I don't agree, I think if we go with consistency with our earlier APIs, then we would never eventually transition to the change. Since this is introducing a new API if we make the change now it's one less that we have to change in the future when we eventually have REST versioning.\nWe've discussed this a lot on the core/features team and always ended up with newly introduced APIs using the newer format, rather than matching the existing dynamically keyed format.", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r445880037", "createdAt": "2020-06-25T22:48:50Z", "author": {"login": "dakrone"}, "path": "server/src/main/java/org/elasticsearch/action/admin/indices/readonly/AddIndexBlockResponse.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.action.admin.indices.readonly;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.support.DefaultShardOperationFailedException;\n+import org.elasticsearch.action.support.master.ShardsAcknowledgedResponse;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.util.CollectionUtils;\n+import org.elasticsearch.common.xcontent.ToXContentFragment;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.Index;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static java.util.Collections.unmodifiableList;\n+\n+public class AddIndexBlockResponse extends ShardsAcknowledgedResponse {\n+\n+    private final List<AddBlockResult> indices;\n+\n+    AddIndexBlockResponse(StreamInput in) throws IOException {\n+        super(in, true);\n+        indices = unmodifiableList(in.readList(AddBlockResult::new));\n+    }\n+\n+    public AddIndexBlockResponse(final boolean acknowledged, final boolean shardsAcknowledged, final List<AddBlockResult> indices) {\n+        super(acknowledged, shardsAcknowledged);\n+        this.indices = unmodifiableList(Objects.requireNonNull(indices));\n+    }\n+\n+    public List<AddBlockResult> getIndices() {\n+        return indices;\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        super.writeTo(out);\n+        writeShardsAcknowledged(out);\n+        out.writeList(indices);\n+    }\n+\n+    @Override\n+    protected void addCustomFields(final XContentBuilder builder, final Params params) throws IOException {\n+        super.addCustomFields(builder, params);\n+        builder.startObject(\"indices\");\n+        for (AddBlockResult index : indices) {\n+            index.toXContent(builder, params);\n+        }\n+        builder.endObject();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return Strings.toString(this);\n+    }\n+\n+    public static class AddBlockResult implements Writeable, ToXContentFragment {\n+\n+        private final Index index;\n+        private final @Nullable Exception exception;\n+        private final @Nullable AddBlockShardResult[] shards;\n+\n+        public AddBlockResult(final Index index) {\n+            this(index, null, null);\n+        }\n+\n+        public AddBlockResult(final Index index, final Exception failure) {\n+            this(index, Objects.requireNonNull(failure), null);\n+        }\n+\n+        public AddBlockResult(final Index index, final AddBlockShardResult[] shards) {\n+            this(index, null, Objects.requireNonNull(shards));\n+        }\n+\n+        private AddBlockResult(final Index index, @Nullable final Exception exception, @Nullable final AddBlockShardResult[] shards) {\n+            this.index = Objects.requireNonNull(index);\n+            this.exception = exception;\n+            this.shards = shards;\n+        }\n+\n+        AddBlockResult(final StreamInput in) throws IOException {\n+            this.index = new Index(in);\n+            this.exception = in.readException();\n+            this.shards = in.readOptionalArray(AddBlockShardResult::new, AddBlockShardResult[]::new);\n+        }\n+\n+        @Override\n+        public void writeTo(final StreamOutput out) throws IOException {\n+            index.writeTo(out);\n+            out.writeException(exception);\n+            out.writeOptionalArray(shards);\n+        }\n+\n+        public Index getIndex() {\n+            return index;\n+        }\n+\n+        public Exception getException() {\n+            return exception;\n+        }\n+\n+        public AddBlockShardResult[] getShards() {\n+            return shards;\n+        }\n+\n+        public boolean hasFailures() {\n+            if (exception != null) {\n+                return true;\n+            }\n+            if (shards != null) {\n+                for (AddBlockShardResult shard : shards) {\n+                    if (shard.hasFailures()) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(final XContentBuilder builder, final Params params) throws IOException {\n+            builder.startObject(index.getName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY1NTk1MQ=="}, "originalCommit": {"oid": "a87646578660c0fa2f77543fcf03b0277dd3c776"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njg0MjgwNg==", "bodyText": "I've adapted the PR to your wishes now, but I don't agree with the general principle. What the team is suggesting is making our lives easier (less stuff to transition), but at the same time is leaving the user with an inconsistent set of APIs (every API having a slightly different look and feel). I think it's the wrong tradeoff to do, especially with the versioned HTTP API looming around the corner (where the need to strive for consistency within the same API version should be an even stronger guiding principle).", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r446842806", "createdAt": "2020-06-29T08:02:54Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/action/admin/indices/readonly/AddIndexBlockResponse.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.action.admin.indices.readonly;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.support.DefaultShardOperationFailedException;\n+import org.elasticsearch.action.support.master.ShardsAcknowledgedResponse;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.util.CollectionUtils;\n+import org.elasticsearch.common.xcontent.ToXContentFragment;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.Index;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static java.util.Collections.unmodifiableList;\n+\n+public class AddIndexBlockResponse extends ShardsAcknowledgedResponse {\n+\n+    private final List<AddBlockResult> indices;\n+\n+    AddIndexBlockResponse(StreamInput in) throws IOException {\n+        super(in, true);\n+        indices = unmodifiableList(in.readList(AddBlockResult::new));\n+    }\n+\n+    public AddIndexBlockResponse(final boolean acknowledged, final boolean shardsAcknowledged, final List<AddBlockResult> indices) {\n+        super(acknowledged, shardsAcknowledged);\n+        this.indices = unmodifiableList(Objects.requireNonNull(indices));\n+    }\n+\n+    public List<AddBlockResult> getIndices() {\n+        return indices;\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        super.writeTo(out);\n+        writeShardsAcknowledged(out);\n+        out.writeList(indices);\n+    }\n+\n+    @Override\n+    protected void addCustomFields(final XContentBuilder builder, final Params params) throws IOException {\n+        super.addCustomFields(builder, params);\n+        builder.startObject(\"indices\");\n+        for (AddBlockResult index : indices) {\n+            index.toXContent(builder, params);\n+        }\n+        builder.endObject();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return Strings.toString(this);\n+    }\n+\n+    public static class AddBlockResult implements Writeable, ToXContentFragment {\n+\n+        private final Index index;\n+        private final @Nullable Exception exception;\n+        private final @Nullable AddBlockShardResult[] shards;\n+\n+        public AddBlockResult(final Index index) {\n+            this(index, null, null);\n+        }\n+\n+        public AddBlockResult(final Index index, final Exception failure) {\n+            this(index, Objects.requireNonNull(failure), null);\n+        }\n+\n+        public AddBlockResult(final Index index, final AddBlockShardResult[] shards) {\n+            this(index, null, Objects.requireNonNull(shards));\n+        }\n+\n+        private AddBlockResult(final Index index, @Nullable final Exception exception, @Nullable final AddBlockShardResult[] shards) {\n+            this.index = Objects.requireNonNull(index);\n+            this.exception = exception;\n+            this.shards = shards;\n+        }\n+\n+        AddBlockResult(final StreamInput in) throws IOException {\n+            this.index = new Index(in);\n+            this.exception = in.readException();\n+            this.shards = in.readOptionalArray(AddBlockShardResult::new, AddBlockShardResult[]::new);\n+        }\n+\n+        @Override\n+        public void writeTo(final StreamOutput out) throws IOException {\n+            index.writeTo(out);\n+            out.writeException(exception);\n+            out.writeOptionalArray(shards);\n+        }\n+\n+        public Index getIndex() {\n+            return index;\n+        }\n+\n+        public Exception getException() {\n+            return exception;\n+        }\n+\n+        public AddBlockShardResult[] getShards() {\n+            return shards;\n+        }\n+\n+        public boolean hasFailures() {\n+            if (exception != null) {\n+                return true;\n+            }\n+            if (shards != null) {\n+                for (AddBlockShardResult shard : shards) {\n+                    if (shard.hasFailures()) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(final XContentBuilder builder, final Params params) throws IOException {\n+            builder.startObject(index.getName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY1NTk1MQ=="}, "originalCommit": {"oid": "a87646578660c0fa2f77543fcf03b0277dd3c776"}, "originalPosition": 145}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MTYxNzczOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/readonly/AddIndexBlockResponse.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNjowMDowMlrOGlMj2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNjowMDowMlrOGlMj2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY1NjI4MQ==", "bodyText": "I think this should be failed_shards rather than camel case to match our usual API conventions", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r441656281", "createdAt": "2020-06-17T16:00:02Z", "author": {"login": "dakrone"}, "path": "server/src/main/java/org/elasticsearch/action/admin/indices/readonly/AddIndexBlockResponse.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.action.admin.indices.readonly;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.support.DefaultShardOperationFailedException;\n+import org.elasticsearch.action.support.master.ShardsAcknowledgedResponse;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.util.CollectionUtils;\n+import org.elasticsearch.common.xcontent.ToXContentFragment;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.Index;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static java.util.Collections.unmodifiableList;\n+\n+public class AddIndexBlockResponse extends ShardsAcknowledgedResponse {\n+\n+    private final List<AddBlockResult> indices;\n+\n+    AddIndexBlockResponse(StreamInput in) throws IOException {\n+        super(in, true);\n+        indices = unmodifiableList(in.readList(AddBlockResult::new));\n+    }\n+\n+    public AddIndexBlockResponse(final boolean acknowledged, final boolean shardsAcknowledged, final List<AddBlockResult> indices) {\n+        super(acknowledged, shardsAcknowledged);\n+        this.indices = unmodifiableList(Objects.requireNonNull(indices));\n+    }\n+\n+    public List<AddBlockResult> getIndices() {\n+        return indices;\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        super.writeTo(out);\n+        writeShardsAcknowledged(out);\n+        out.writeList(indices);\n+    }\n+\n+    @Override\n+    protected void addCustomFields(final XContentBuilder builder, final Params params) throws IOException {\n+        super.addCustomFields(builder, params);\n+        builder.startObject(\"indices\");\n+        for (AddBlockResult index : indices) {\n+            index.toXContent(builder, params);\n+        }\n+        builder.endObject();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return Strings.toString(this);\n+    }\n+\n+    public static class AddBlockResult implements Writeable, ToXContentFragment {\n+\n+        private final Index index;\n+        private final @Nullable Exception exception;\n+        private final @Nullable AddBlockShardResult[] shards;\n+\n+        public AddBlockResult(final Index index) {\n+            this(index, null, null);\n+        }\n+\n+        public AddBlockResult(final Index index, final Exception failure) {\n+            this(index, Objects.requireNonNull(failure), null);\n+        }\n+\n+        public AddBlockResult(final Index index, final AddBlockShardResult[] shards) {\n+            this(index, null, Objects.requireNonNull(shards));\n+        }\n+\n+        private AddBlockResult(final Index index, @Nullable final Exception exception, @Nullable final AddBlockShardResult[] shards) {\n+            this.index = Objects.requireNonNull(index);\n+            this.exception = exception;\n+            this.shards = shards;\n+        }\n+\n+        AddBlockResult(final StreamInput in) throws IOException {\n+            this.index = new Index(in);\n+            this.exception = in.readException();\n+            this.shards = in.readOptionalArray(AddBlockShardResult::new, AddBlockShardResult[]::new);\n+        }\n+\n+        @Override\n+        public void writeTo(final StreamOutput out) throws IOException {\n+            index.writeTo(out);\n+            out.writeException(exception);\n+            out.writeOptionalArray(shards);\n+        }\n+\n+        public Index getIndex() {\n+            return index;\n+        }\n+\n+        public Exception getException() {\n+            return exception;\n+        }\n+\n+        public AddBlockShardResult[] getShards() {\n+            return shards;\n+        }\n+\n+        public boolean hasFailures() {\n+            if (exception != null) {\n+                return true;\n+            }\n+            if (shards != null) {\n+                for (AddBlockShardResult shard : shards) {\n+                    if (shard.hasFailures()) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(final XContentBuilder builder, final Params params) throws IOException {\n+            builder.startObject(index.getName());\n+            {\n+                if (hasFailures()) {\n+                    builder.field(\"blocked\", false);\n+                    if (exception != null) {\n+                        builder.startObject(\"exception\");\n+                        ElasticsearchException.generateFailureXContent(builder, params, exception, true);\n+                        builder.endObject();\n+                    } else {\n+                        builder.startObject(\"failedShards\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a87646578660c0fa2f77543fcf03b0277dd3c776"}, "originalPosition": 154}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MTYyMjczOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/readonly/TransportAddIndexBlockAction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNjowMToxOVrOGlMm-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNjowMToxOVrOGlMm-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY1NzA4MQ==", "bodyText": "Documentation needs to be updated", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r441657081", "createdAt": "2020-06-17T16:01:19Z", "author": {"login": "dakrone"}, "path": "server/src/main/java/org/elasticsearch/action/admin/indices/readonly/TransportAddIndexBlockAction.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.admin.indices.readonly;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.DestructiveOperations;\n+import org.elasticsearch.action.support.master.TransportMasterNodeAction;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.block.ClusterBlockLevel;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.metadata.MetadataIndexStateService;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.index.Index;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+\n+/**\n+ * Close index action", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a87646578660c0fa2f77543fcf03b0277dd3c776"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MTYyODQ1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/readonly/TransportVerifyShardIndexBlockAction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNjowMjo0MlrOGlMqeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNjowMjo0MlrOGlMqeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY1Nzk3OA==", "bodyText": "Can you add javadocs for this class please?", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r441657978", "createdAt": "2020-06-17T16:02:42Z", "author": {"login": "dakrone"}, "path": "server/src/main/java/org/elasticsearch/action/admin/indices/readonly/TransportVerifyShardIndexBlockAction.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.action.admin.indices.readonly;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.ActionType;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.replication.ReplicationOperation;\n+import org.elasticsearch.action.support.replication.ReplicationRequest;\n+import org.elasticsearch.action.support.replication.ReplicationResponse;\n+import org.elasticsearch.action.support.replication.TransportReplicationAction;\n+import org.elasticsearch.cluster.action.shard.ShardStateAction;\n+import org.elasticsearch.cluster.block.ClusterBlock;\n+import org.elasticsearch.cluster.block.ClusterBlocks;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.lease.Releasable;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.shard.IndexShard;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.indices.IndicesService;\n+import org.elasticsearch.tasks.TaskId;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+\n+public class TransportVerifyShardIndexBlockAction extends TransportReplicationAction<", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a87646578660c0fa2f77543fcf03b0277dd3c776"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MTYzNjE3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/client/IndicesAdminClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNjowNDo0OFrOGlMvQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMDowNjoxMlrOGoLo3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY1OTIwMQ==", "bodyText": "I don't think we need to add these since we are not supporting the transport client any longer?", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r441659201", "createdAt": "2020-06-17T16:04:48Z", "author": {"login": "dakrone"}, "path": "server/src/main/java/org/elasticsearch/client/IndicesAdminClient.java", "diffHunk": "@@ -284,6 +288,23 @@\n      */\n     void open(OpenIndexRequest request, ActionListener<OpenIndexResponse> listener);\n \n+    /**\n+     * Adds a block to an index\n+     *\n+     * @param block   The block to add\n+     * @param indices The name of the indices to add the block to\n+     */\n+    AddIndexBlockRequestBuilder prepareAddBlock(APIBlock block, String... indices);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a87646578660c0fa2f77543fcf03b0277dd3c776"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc4NjkxMA==", "bodyText": "see comment above about transport client", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r444786910", "createdAt": "2020-06-24T10:06:12Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/client/IndicesAdminClient.java", "diffHunk": "@@ -284,6 +288,23 @@\n      */\n     void open(OpenIndexRequest request, ActionListener<OpenIndexResponse> listener);\n \n+    /**\n+     * Adds a block to an index\n+     *\n+     * @param block   The block to add\n+     * @param indices The name of the indices to add the block to\n+     */\n+    AddIndexBlockRequestBuilder prepareAddBlock(APIBlock block, String... indices);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY1OTIwMQ=="}, "originalCommit": {"oid": "a87646578660c0fa2f77543fcf03b0277dd3c776"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MTYzNzA0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/client/support/AbstractClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNjowNTowM1rOGlMvxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNjowNTowM1rOGlMvxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY1OTMzNQ==", "bodyText": "Same about no need to add since we aren't supporting the transport client", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r441659335", "createdAt": "2020-06-17T16:05:03Z", "author": {"login": "dakrone"}, "path": "server/src/main/java/org/elasticsearch/client/support/AbstractClient.java", "diffHunk": "@@ -1331,6 +1336,16 @@ public void open(final OpenIndexRequest request, final ActionListener<OpenIndexR\n             execute(OpenIndexAction.INSTANCE, request, listener);\n         }\n \n+        @Override\n+        public AddIndexBlockRequestBuilder prepareAddBlock(APIBlock block, String... indices) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a87646578660c0fa2f77543fcf03b0277dd3c776"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MTY0MDI0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexStateService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNjowNTo0OFrOGlMxsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNjowNTo0OFrOGlMxsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY1OTgyNg==", "bodyText": "Can you add javadocs for this method please?", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r441659826", "createdAt": "2020-06-17T16:05:48Z", "author": {"login": "dakrone"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexStateService.java", "diffHunk": "@@ -304,6 +310,149 @@ static ClusterState addIndexClosedBlocks(final Index[] indices, final Map<Index,\n         return ClusterState.builder(currentState).blocks(blocks).metadata(metadata).routingTable(routingTable.build()).build();\n     }\n \n+    static ClusterState addIndexBlock(final Index[] indices, final Map<Index, ClusterBlock> blockedIndices,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a87646578660c0fa2f77543fcf03b0277dd3c776"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MTY1NTkyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexStateService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNjowOTozOVrOGlM7Hg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNjowOTozOVrOGlM7Hg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY2MjIzOA==", "bodyText": "Super minor, but perhaps\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    clusterService.submitStateUpdateTask(\"add-index-block \" + Arrays.toString(concreteIndices),\n          \n          \n            \n                    clusterService.submitStateUpdateTask(\"add-index-block-[\" + request.getBlock() + \"]-\" Arrays.toString(concreteIndices),\n          \n      \n    \n    \n  \n\nSo we can see the intended block in the pending tasks list", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r441662238", "createdAt": "2020-06-17T16:09:39Z", "author": {"login": "dakrone"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexStateService.java", "diffHunk": "@@ -304,6 +310,149 @@ static ClusterState addIndexClosedBlocks(final Index[] indices, final Map<Index,\n         return ClusterState.builder(currentState).blocks(blocks).metadata(metadata).routingTable(routingTable.build()).build();\n     }\n \n+    static ClusterState addIndexBlock(final Index[] indices, final Map<Index, ClusterBlock> blockedIndices,\n+                                      final ClusterState currentState, APIBlock block) {\n+        final Metadata.Builder metadata = Metadata.builder(currentState.metadata());\n+\n+        final Set<Index> indicesToAddBlock = new HashSet<>();\n+        for (Index index : indices) {\n+            metadata.getSafe(index); // to check if index exists\n+            if (currentState.blocks().hasIndexBlock(index.getName(), block.block)) {\n+                logger.debug(\"index {} already has block {}, ignoring\", index, block.block);\n+            } else {\n+                indicesToAddBlock.add(index);\n+            }\n+        }\n+\n+        if (indicesToAddBlock.isEmpty()) {\n+            return currentState;\n+        }\n+\n+        final ClusterBlocks.Builder blocks = ClusterBlocks.builder().blocks(currentState.blocks());\n+        final RoutingTable.Builder routingTable = RoutingTable.builder(currentState.routingTable());\n+\n+        for (Index index : indicesToAddBlock) {\n+            ClusterBlock indexBlock = null;\n+            final Set<ClusterBlock> clusterBlocks = currentState.blocks().indices().get(index.getName());\n+            if (clusterBlocks != null) {\n+                for (ClusterBlock clusterBlock : clusterBlocks) {\n+                    if (clusterBlock.id() == block.block.id()) {\n+                        // Reuse the existing UUID-based block\n+                        indexBlock = clusterBlock;\n+                        break;\n+                    }\n+                }\n+            }\n+            if (indexBlock == null) {\n+                // Create a new UUID-based block\n+                indexBlock = createUUIDBasedBlock(block.block);\n+            }\n+            assert Strings.hasLength(indexBlock.uuid()) : \"Block should have a UUID\";\n+            blocks.addIndexBlock(index.getName(), indexBlock);\n+            blockedIndices.put(index, indexBlock);\n+            // update index settings as well to match the block\n+            final IndexMetadata indexMetadata = metadata.getSafe(index);\n+            if (block.setting().get(indexMetadata.getSettings()) == false) {\n+                final Settings updatedSettings = Settings.builder()\n+                    .put(indexMetadata.getSettings()).put(block.settingName(), true).build();\n+\n+                metadata.put(IndexMetadata.builder(indexMetadata)\n+                    .settings(updatedSettings)\n+                    .settingsVersion(indexMetadata.getSettingsVersion() + 1));\n+            }\n+        }\n+\n+        logger.info(() -> new ParameterizedMessage(\"adding block {} to indices {}\", block.name,\n+            blockedIndices.keySet().stream().map(Object::toString).collect(Collectors.joining(\",\"))));\n+        return ClusterState.builder(currentState).blocks(blocks).metadata(metadata).routingTable(routingTable.build()).build();\n+    }\n+\n+    public void addIndexBlock(AddIndexBlockClusterStateUpdateRequest request,\n+                              ActionListener<AddIndexBlockResponse> listener) {\n+        final Index[] concreteIndices = request.indices();\n+        if (concreteIndices == null || concreteIndices.length == 0) {\n+            throw new IllegalArgumentException(\"Index name is required\");\n+        }\n+        List<String> writeIndices = new ArrayList<>();\n+        SortedMap<String, IndexAbstraction> lookup = clusterService.state().metadata().getIndicesLookup();\n+        for (Index index : concreteIndices) {\n+            IndexAbstraction ia = lookup.get(index.getName());\n+            if (ia != null && ia.getParentDataStream() != null && ia.getParentDataStream().getWriteIndex().getIndex().equals(index)) {\n+                writeIndices.add(index.getName());\n+            }\n+        }\n+        if (writeIndices.size() > 0) {\n+            throw new IllegalArgumentException(\"cannot add a block to the following data stream write indices [\" +\n+                Strings.collectionToCommaDelimitedString(writeIndices) + \"]\");\n+        }\n+\n+        clusterService.submitStateUpdateTask(\"add-index-block \" + Arrays.toString(concreteIndices),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a87646578660c0fa2f77543fcf03b0277dd3c776"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MTY2NjUzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexStateService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNjoxMjoyMFrOGlNBgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNjoxMjoyMFrOGlNBgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY2Mzg3Mw==", "bodyText": "Can you add the block type and blockedIndices list to this state update task as well?", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r441663873", "createdAt": "2020-06-17T16:12:20Z", "author": {"login": "dakrone"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexStateService.java", "diffHunk": "@@ -304,6 +310,149 @@ static ClusterState addIndexClosedBlocks(final Index[] indices, final Map<Index,\n         return ClusterState.builder(currentState).blocks(blocks).metadata(metadata).routingTable(routingTable.build()).build();\n     }\n \n+    static ClusterState addIndexBlock(final Index[] indices, final Map<Index, ClusterBlock> blockedIndices,\n+                                      final ClusterState currentState, APIBlock block) {\n+        final Metadata.Builder metadata = Metadata.builder(currentState.metadata());\n+\n+        final Set<Index> indicesToAddBlock = new HashSet<>();\n+        for (Index index : indices) {\n+            metadata.getSafe(index); // to check if index exists\n+            if (currentState.blocks().hasIndexBlock(index.getName(), block.block)) {\n+                logger.debug(\"index {} already has block {}, ignoring\", index, block.block);\n+            } else {\n+                indicesToAddBlock.add(index);\n+            }\n+        }\n+\n+        if (indicesToAddBlock.isEmpty()) {\n+            return currentState;\n+        }\n+\n+        final ClusterBlocks.Builder blocks = ClusterBlocks.builder().blocks(currentState.blocks());\n+        final RoutingTable.Builder routingTable = RoutingTable.builder(currentState.routingTable());\n+\n+        for (Index index : indicesToAddBlock) {\n+            ClusterBlock indexBlock = null;\n+            final Set<ClusterBlock> clusterBlocks = currentState.blocks().indices().get(index.getName());\n+            if (clusterBlocks != null) {\n+                for (ClusterBlock clusterBlock : clusterBlocks) {\n+                    if (clusterBlock.id() == block.block.id()) {\n+                        // Reuse the existing UUID-based block\n+                        indexBlock = clusterBlock;\n+                        break;\n+                    }\n+                }\n+            }\n+            if (indexBlock == null) {\n+                // Create a new UUID-based block\n+                indexBlock = createUUIDBasedBlock(block.block);\n+            }\n+            assert Strings.hasLength(indexBlock.uuid()) : \"Block should have a UUID\";\n+            blocks.addIndexBlock(index.getName(), indexBlock);\n+            blockedIndices.put(index, indexBlock);\n+            // update index settings as well to match the block\n+            final IndexMetadata indexMetadata = metadata.getSafe(index);\n+            if (block.setting().get(indexMetadata.getSettings()) == false) {\n+                final Settings updatedSettings = Settings.builder()\n+                    .put(indexMetadata.getSettings()).put(block.settingName(), true).build();\n+\n+                metadata.put(IndexMetadata.builder(indexMetadata)\n+                    .settings(updatedSettings)\n+                    .settingsVersion(indexMetadata.getSettingsVersion() + 1));\n+            }\n+        }\n+\n+        logger.info(() -> new ParameterizedMessage(\"adding block {} to indices {}\", block.name,\n+            blockedIndices.keySet().stream().map(Object::toString).collect(Collectors.joining(\",\"))));\n+        return ClusterState.builder(currentState).blocks(blocks).metadata(metadata).routingTable(routingTable.build()).build();\n+    }\n+\n+    public void addIndexBlock(AddIndexBlockClusterStateUpdateRequest request,\n+                              ActionListener<AddIndexBlockResponse> listener) {\n+        final Index[] concreteIndices = request.indices();\n+        if (concreteIndices == null || concreteIndices.length == 0) {\n+            throw new IllegalArgumentException(\"Index name is required\");\n+        }\n+        List<String> writeIndices = new ArrayList<>();\n+        SortedMap<String, IndexAbstraction> lookup = clusterService.state().metadata().getIndicesLookup();\n+        for (Index index : concreteIndices) {\n+            IndexAbstraction ia = lookup.get(index.getName());\n+            if (ia != null && ia.getParentDataStream() != null && ia.getParentDataStream().getWriteIndex().getIndex().equals(index)) {\n+                writeIndices.add(index.getName());\n+            }\n+        }\n+        if (writeIndices.size() > 0) {\n+            throw new IllegalArgumentException(\"cannot add a block to the following data stream write indices [\" +\n+                Strings.collectionToCommaDelimitedString(writeIndices) + \"]\");\n+        }\n+\n+        clusterService.submitStateUpdateTask(\"add-index-block \" + Arrays.toString(concreteIndices),\n+            new ClusterStateUpdateTask(Priority.URGENT) {\n+\n+                private final Map<Index, ClusterBlock> blockedIndices = new HashMap<>();\n+\n+                @Override\n+                public ClusterState execute(final ClusterState currentState) {\n+                    return addIndexBlock(concreteIndices, blockedIndices, currentState, request.getBlock());\n+                }\n+\n+                @Override\n+                public void clusterStateProcessed(final String source, final ClusterState oldState, final ClusterState newState) {\n+                    if (oldState == newState) {\n+                        assert blockedIndices.isEmpty() : \"List of blocked indices is not empty but cluster state wasn't changed\";\n+                        listener.onResponse(new AddIndexBlockResponse(true, false, Collections.emptyList()));\n+                    } else {\n+                        assert blockedIndices.isEmpty() == false : \"List of blocked indices is empty but cluster state was changed\";\n+                        threadPool.executor(ThreadPool.Names.MANAGEMENT)\n+                            .execute(new WaitForBlocksApplied(blockedIndices, request,\n+                                    ActionListener.wrap(verifyResults ->\n+                                            clusterService.submitStateUpdateTask(\"finalize-index-block\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a87646578660c0fa2f77543fcf03b0277dd3c776"}, "originalPosition": 120}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MTY3MzY4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/readonly/AddIndexBlockRequestBuilder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNjoxNDoyM1rOGlNGOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNjoxNDoyM1rOGlNGOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY2NTA4Mg==", "bodyText": "Docstrings in this file need to be updated :)", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r441665082", "createdAt": "2020-06-17T16:14:23Z", "author": {"login": "dakrone"}, "path": "server/src/main/java/org/elasticsearch/action/admin/indices/readonly/AddIndexBlockRequestBuilder.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.admin.indices.readonly;\n+\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.action.support.master.AcknowledgedRequestBuilder;\n+import org.elasticsearch.client.ElasticsearchClient;\n+import org.elasticsearch.cluster.metadata.IndexMetadata.APIBlock;\n+\n+/**\n+ * Builder for close index request", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a87646578660c0fa2f77543fcf03b0277dd3c776"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MTY5NDY4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexStateService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNjoyMDowMVrOGlNTSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMDowNjo0NlrOGoLqFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY2ODQyNQ==", "bodyText": "I'm really uncomfortable mutating the blockedIndices map that was passed in as a parameter. I had to read this over and over to see what was happening. Can we refactor this method so that it becomes part of the return value (maybe using a Tuple if we don't want to add an object) so that it's easier to reason about?", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r441668425", "createdAt": "2020-06-17T16:20:01Z", "author": {"login": "dakrone"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexStateService.java", "diffHunk": "@@ -304,6 +310,149 @@ static ClusterState addIndexClosedBlocks(final Index[] indices, final Map<Index,\n         return ClusterState.builder(currentState).blocks(blocks).metadata(metadata).routingTable(routingTable.build()).build();\n     }\n \n+    static ClusterState addIndexBlock(final Index[] indices, final Map<Index, ClusterBlock> blockedIndices,\n+                                      final ClusterState currentState, APIBlock block) {\n+        final Metadata.Builder metadata = Metadata.builder(currentState.metadata());\n+\n+        final Set<Index> indicesToAddBlock = new HashSet<>();\n+        for (Index index : indices) {\n+            metadata.getSafe(index); // to check if index exists\n+            if (currentState.blocks().hasIndexBlock(index.getName(), block.block)) {\n+                logger.debug(\"index {} already has block {}, ignoring\", index, block.block);\n+            } else {\n+                indicesToAddBlock.add(index);\n+            }\n+        }\n+\n+        if (indicesToAddBlock.isEmpty()) {\n+            return currentState;\n+        }\n+\n+        final ClusterBlocks.Builder blocks = ClusterBlocks.builder().blocks(currentState.blocks());\n+        final RoutingTable.Builder routingTable = RoutingTable.builder(currentState.routingTable());\n+\n+        for (Index index : indicesToAddBlock) {\n+            ClusterBlock indexBlock = null;\n+            final Set<ClusterBlock> clusterBlocks = currentState.blocks().indices().get(index.getName());\n+            if (clusterBlocks != null) {\n+                for (ClusterBlock clusterBlock : clusterBlocks) {\n+                    if (clusterBlock.id() == block.block.id()) {\n+                        // Reuse the existing UUID-based block\n+                        indexBlock = clusterBlock;\n+                        break;\n+                    }\n+                }\n+            }\n+            if (indexBlock == null) {\n+                // Create a new UUID-based block\n+                indexBlock = createUUIDBasedBlock(block.block);\n+            }\n+            assert Strings.hasLength(indexBlock.uuid()) : \"Block should have a UUID\";\n+            blocks.addIndexBlock(index.getName(), indexBlock);\n+            blockedIndices.put(index, indexBlock);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a87646578660c0fa2f77543fcf03b0277dd3c776"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc4NzIyMw==", "bodyText": "Good idea, changed  this to a tuple", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r444787223", "createdAt": "2020-06-24T10:06:46Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexStateService.java", "diffHunk": "@@ -304,6 +310,149 @@ static ClusterState addIndexClosedBlocks(final Index[] indices, final Map<Index,\n         return ClusterState.builder(currentState).blocks(blocks).metadata(metadata).routingTable(routingTable.build()).build();\n     }\n \n+    static ClusterState addIndexBlock(final Index[] indices, final Map<Index, ClusterBlock> blockedIndices,\n+                                      final ClusterState currentState, APIBlock block) {\n+        final Metadata.Builder metadata = Metadata.builder(currentState.metadata());\n+\n+        final Set<Index> indicesToAddBlock = new HashSet<>();\n+        for (Index index : indices) {\n+            metadata.getSafe(index); // to check if index exists\n+            if (currentState.blocks().hasIndexBlock(index.getName(), block.block)) {\n+                logger.debug(\"index {} already has block {}, ignoring\", index, block.block);\n+            } else {\n+                indicesToAddBlock.add(index);\n+            }\n+        }\n+\n+        if (indicesToAddBlock.isEmpty()) {\n+            return currentState;\n+        }\n+\n+        final ClusterBlocks.Builder blocks = ClusterBlocks.builder().blocks(currentState.blocks());\n+        final RoutingTable.Builder routingTable = RoutingTable.builder(currentState.routingTable());\n+\n+        for (Index index : indicesToAddBlock) {\n+            ClusterBlock indexBlock = null;\n+            final Set<ClusterBlock> clusterBlocks = currentState.blocks().indices().get(index.getName());\n+            if (clusterBlocks != null) {\n+                for (ClusterBlock clusterBlock : clusterBlocks) {\n+                    if (clusterBlock.id() == block.block.id()) {\n+                        // Reuse the existing UUID-based block\n+                        indexBlock = clusterBlock;\n+                        break;\n+                    }\n+                }\n+            }\n+            if (indexBlock == null) {\n+                // Create a new UUID-based block\n+                indexBlock = createUUIDBasedBlock(block.block);\n+            }\n+            assert Strings.hasLength(indexBlock.uuid()) : \"Block should have a UUID\";\n+            blocks.addIndexBlock(index.getName(), indexBlock);\n+            blockedIndices.put(index, indexBlock);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY2ODQyNQ=="}, "originalCommit": {"oid": "a87646578660c0fa2f77543fcf03b0277dd3c776"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MTcwMjI4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexStateService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNjoyMTo1N1rOGlNX0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMDowNzowNFrOGoLqvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY2OTU4Nw==", "bodyText": "Why use a lambda and parameterized message here? Usually it's used when also passing an exception we want to preserve as a cause. Am I missing something?", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r441669587", "createdAt": "2020-06-17T16:21:57Z", "author": {"login": "dakrone"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexStateService.java", "diffHunk": "@@ -304,6 +310,149 @@ static ClusterState addIndexClosedBlocks(final Index[] indices, final Map<Index,\n         return ClusterState.builder(currentState).blocks(blocks).metadata(metadata).routingTable(routingTable.build()).build();\n     }\n \n+    static ClusterState addIndexBlock(final Index[] indices, final Map<Index, ClusterBlock> blockedIndices,\n+                                      final ClusterState currentState, APIBlock block) {\n+        final Metadata.Builder metadata = Metadata.builder(currentState.metadata());\n+\n+        final Set<Index> indicesToAddBlock = new HashSet<>();\n+        for (Index index : indices) {\n+            metadata.getSafe(index); // to check if index exists\n+            if (currentState.blocks().hasIndexBlock(index.getName(), block.block)) {\n+                logger.debug(\"index {} already has block {}, ignoring\", index, block.block);\n+            } else {\n+                indicesToAddBlock.add(index);\n+            }\n+        }\n+\n+        if (indicesToAddBlock.isEmpty()) {\n+            return currentState;\n+        }\n+\n+        final ClusterBlocks.Builder blocks = ClusterBlocks.builder().blocks(currentState.blocks());\n+        final RoutingTable.Builder routingTable = RoutingTable.builder(currentState.routingTable());\n+\n+        for (Index index : indicesToAddBlock) {\n+            ClusterBlock indexBlock = null;\n+            final Set<ClusterBlock> clusterBlocks = currentState.blocks().indices().get(index.getName());\n+            if (clusterBlocks != null) {\n+                for (ClusterBlock clusterBlock : clusterBlocks) {\n+                    if (clusterBlock.id() == block.block.id()) {\n+                        // Reuse the existing UUID-based block\n+                        indexBlock = clusterBlock;\n+                        break;\n+                    }\n+                }\n+            }\n+            if (indexBlock == null) {\n+                // Create a new UUID-based block\n+                indexBlock = createUUIDBasedBlock(block.block);\n+            }\n+            assert Strings.hasLength(indexBlock.uuid()) : \"Block should have a UUID\";\n+            blocks.addIndexBlock(index.getName(), indexBlock);\n+            blockedIndices.put(index, indexBlock);\n+            // update index settings as well to match the block\n+            final IndexMetadata indexMetadata = metadata.getSafe(index);\n+            if (block.setting().get(indexMetadata.getSettings()) == false) {\n+                final Settings updatedSettings = Settings.builder()\n+                    .put(indexMetadata.getSettings()).put(block.settingName(), true).build();\n+\n+                metadata.put(IndexMetadata.builder(indexMetadata)\n+                    .settings(updatedSettings)\n+                    .settingsVersion(indexMetadata.getSettingsVersion() + 1));\n+            }\n+        }\n+\n+        logger.info(() -> new ParameterizedMessage(\"adding block {} to indices {}\", block.name,\n+            blockedIndices.keySet().stream().map(Object::toString).collect(Collectors.joining(\",\"))));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a87646578660c0fa2f77543fcf03b0277dd3c776"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc4NzM4OQ==", "bodyText": "No reason, code was copy-pasted from elsewhere", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r444787389", "createdAt": "2020-06-24T10:07:04Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexStateService.java", "diffHunk": "@@ -304,6 +310,149 @@ static ClusterState addIndexClosedBlocks(final Index[] indices, final Map<Index,\n         return ClusterState.builder(currentState).blocks(blocks).metadata(metadata).routingTable(routingTable.build()).build();\n     }\n \n+    static ClusterState addIndexBlock(final Index[] indices, final Map<Index, ClusterBlock> blockedIndices,\n+                                      final ClusterState currentState, APIBlock block) {\n+        final Metadata.Builder metadata = Metadata.builder(currentState.metadata());\n+\n+        final Set<Index> indicesToAddBlock = new HashSet<>();\n+        for (Index index : indices) {\n+            metadata.getSafe(index); // to check if index exists\n+            if (currentState.blocks().hasIndexBlock(index.getName(), block.block)) {\n+                logger.debug(\"index {} already has block {}, ignoring\", index, block.block);\n+            } else {\n+                indicesToAddBlock.add(index);\n+            }\n+        }\n+\n+        if (indicesToAddBlock.isEmpty()) {\n+            return currentState;\n+        }\n+\n+        final ClusterBlocks.Builder blocks = ClusterBlocks.builder().blocks(currentState.blocks());\n+        final RoutingTable.Builder routingTable = RoutingTable.builder(currentState.routingTable());\n+\n+        for (Index index : indicesToAddBlock) {\n+            ClusterBlock indexBlock = null;\n+            final Set<ClusterBlock> clusterBlocks = currentState.blocks().indices().get(index.getName());\n+            if (clusterBlocks != null) {\n+                for (ClusterBlock clusterBlock : clusterBlocks) {\n+                    if (clusterBlock.id() == block.block.id()) {\n+                        // Reuse the existing UUID-based block\n+                        indexBlock = clusterBlock;\n+                        break;\n+                    }\n+                }\n+            }\n+            if (indexBlock == null) {\n+                // Create a new UUID-based block\n+                indexBlock = createUUIDBasedBlock(block.block);\n+            }\n+            assert Strings.hasLength(indexBlock.uuid()) : \"Block should have a UUID\";\n+            blocks.addIndexBlock(index.getName(), indexBlock);\n+            blockedIndices.put(index, indexBlock);\n+            // update index settings as well to match the block\n+            final IndexMetadata indexMetadata = metadata.getSafe(index);\n+            if (block.setting().get(indexMetadata.getSettings()) == false) {\n+                final Settings updatedSettings = Settings.builder()\n+                    .put(indexMetadata.getSettings()).put(block.settingName(), true).build();\n+\n+                metadata.put(IndexMetadata.builder(indexMetadata)\n+                    .settings(updatedSettings)\n+                    .settingsVersion(indexMetadata.getSettingsVersion() + 1));\n+            }\n+        }\n+\n+        logger.info(() -> new ParameterizedMessage(\"adding block {} to indices {}\", block.name,\n+            blockedIndices.keySet().stream().map(Object::toString).collect(Collectors.joining(\",\"))));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY2OTU4Nw=="}, "originalCommit": {"oid": "a87646578660c0fa2f77543fcf03b0277dd3c776"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MTcwMzIwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexStateService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNjoyMjowOVrOGlNYYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNjoyMjowOVrOGlNYYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY2OTcyOA==", "bodyText": "Could you add javadocs please?", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r441669728", "createdAt": "2020-06-17T16:22:09Z", "author": {"login": "dakrone"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexStateService.java", "diffHunk": "@@ -304,6 +310,149 @@ static ClusterState addIndexClosedBlocks(final Index[] indices, final Map<Index,\n         return ClusterState.builder(currentState).blocks(blocks).metadata(metadata).routingTable(routingTable.build()).build();\n     }\n \n+    static ClusterState addIndexBlock(final Index[] indices, final Map<Index, ClusterBlock> blockedIndices,\n+                                      final ClusterState currentState, APIBlock block) {\n+        final Metadata.Builder metadata = Metadata.builder(currentState.metadata());\n+\n+        final Set<Index> indicesToAddBlock = new HashSet<>();\n+        for (Index index : indices) {\n+            metadata.getSafe(index); // to check if index exists\n+            if (currentState.blocks().hasIndexBlock(index.getName(), block.block)) {\n+                logger.debug(\"index {} already has block {}, ignoring\", index, block.block);\n+            } else {\n+                indicesToAddBlock.add(index);\n+            }\n+        }\n+\n+        if (indicesToAddBlock.isEmpty()) {\n+            return currentState;\n+        }\n+\n+        final ClusterBlocks.Builder blocks = ClusterBlocks.builder().blocks(currentState.blocks());\n+        final RoutingTable.Builder routingTable = RoutingTable.builder(currentState.routingTable());\n+\n+        for (Index index : indicesToAddBlock) {\n+            ClusterBlock indexBlock = null;\n+            final Set<ClusterBlock> clusterBlocks = currentState.blocks().indices().get(index.getName());\n+            if (clusterBlocks != null) {\n+                for (ClusterBlock clusterBlock : clusterBlocks) {\n+                    if (clusterBlock.id() == block.block.id()) {\n+                        // Reuse the existing UUID-based block\n+                        indexBlock = clusterBlock;\n+                        break;\n+                    }\n+                }\n+            }\n+            if (indexBlock == null) {\n+                // Create a new UUID-based block\n+                indexBlock = createUUIDBasedBlock(block.block);\n+            }\n+            assert Strings.hasLength(indexBlock.uuid()) : \"Block should have a UUID\";\n+            blocks.addIndexBlock(index.getName(), indexBlock);\n+            blockedIndices.put(index, indexBlock);\n+            // update index settings as well to match the block\n+            final IndexMetadata indexMetadata = metadata.getSafe(index);\n+            if (block.setting().get(indexMetadata.getSettings()) == false) {\n+                final Settings updatedSettings = Settings.builder()\n+                    .put(indexMetadata.getSettings()).put(block.settingName(), true).build();\n+\n+                metadata.put(IndexMetadata.builder(indexMetadata)\n+                    .settings(updatedSettings)\n+                    .settingsVersion(indexMetadata.getSettingsVersion() + 1));\n+            }\n+        }\n+\n+        logger.info(() -> new ParameterizedMessage(\"adding block {} to indices {}\", block.name,\n+            blockedIndices.keySet().stream().map(Object::toString).collect(Collectors.joining(\",\"))));\n+        return ClusterState.builder(currentState).blocks(blocks).metadata(metadata).routingTable(routingTable.build()).build();\n+    }\n+\n+    public void addIndexBlock(AddIndexBlockClusterStateUpdateRequest request,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a87646578660c0fa2f77543fcf03b0277dd3c776"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MTcwNTEyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexStateService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNjoyMjo0MVrOGlNZmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNjoyMjo0MVrOGlNZmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY3MDA0MA==", "bodyText": "Javadocs please :)", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r441670040", "createdAt": "2020-06-17T16:22:41Z", "author": {"login": "dakrone"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexStateService.java", "diffHunk": "@@ -429,6 +578,108 @@ public void onFailure(Exception e) {\n         }\n     }\n \n+    class WaitForBlocksApplied extends ActionRunnable<Map<Index, AddBlockResult>> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a87646578660c0fa2f77543fcf03b0277dd3c776"}, "originalPosition": 174}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MTcxNDgxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexStateService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNjoyNToxN1rOGlNf3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNjoyNToxN1rOGlNf3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY3MTY0NA==", "bodyText": "Javadocs please :) they really do help when code spelunking in the future (at least I find them incredibly useful)", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r441671644", "createdAt": "2020-06-17T16:25:17Z", "author": {"login": "dakrone"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexStateService.java", "diffHunk": "@@ -618,6 +869,60 @@ ClusterState openIndices(final Index[] indices, final ClusterState currentState)\n         return ClusterState.builder(updatedState).routingTable(routingTable.build()).build();\n     }\n \n+    static Tuple<ClusterState, Collection<AddBlockResult>> finalizeBlock(final ClusterState currentState,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a87646578660c0fa2f77543fcf03b0277dd3c776"}, "originalPosition": 283}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MTk0MjUzOnYy", "diffSide": "RIGHT", "path": "docs/reference/index-modules/blocks.asciidoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMjo1NDowNVrOGoQx5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMjo1NDowNVrOGoQx5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg3MTE0MA==", "bodyText": "I've fixed up these includes, but they're about closed indices. I don't think they're applicable here.\nAs the rest of the page provides plenty of context, I'd remove these sections entirely. They're not required.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            [discrete]\n          \n          \n            \n            [[add-index-block-api-desc]]\n          \n          \n            \n            ==== {api-description-title}\n          \n          \n            \n            \n          \n          \n            \n            You use the add index blocks API to add an index block.\n          \n          \n            \n            \n          \n          \n            \n            include::{es-repo-dir}/indices/open-close.asciidoc[tag=closed-index]\n          \n          \n            \n            \n          \n          \n            \n            [discrete]\n          \n          \n            \n            [[add-index-block-api-wait-for-active-shards]]\n          \n          \n            \n            ===== Wait For active shards\n          \n          \n            \n            \n          \n          \n            \n            include::{es-repo-dir}/indices/open-close.asciidoc[tag=wait-for-active-shards]", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r444871140", "createdAt": "2020-06-24T12:54:05Z", "author": {"login": "jrodewig"}, "path": "docs/reference/index-modules/blocks.asciidoc", "diffHunk": "@@ -0,0 +1,141 @@\n+[[index-modules-blocks]]\n+== Index blocks\n+\n+Index blocks limit the kind of operations that are available on a certain\n+index. The blocks come in different flavours, allowing to block write,\n+read, or metadata operations. The blocks can be set / removed using dynamic\n+index settings, or can be added using a dedicated API, which also ensures\n+that, once successfully returning to the user, all shards of the index are\n+properly accounting for the block, for example that all in-flight writes to\n+an index have been completed after adding the write block.\n+\n+[discrete]\n+[[index-block-settings]]\n+=== Index block settings\n+\n+The following _dynamic_ index settings determine the blocks present on an\n+index:\n+\n+`index.blocks.read_only`::\n+\n+    Set to `true` to make the index and index metadata read only, `false` to\n+    allow writes and metadata changes.\n+\n+`index.blocks.read_only_allow_delete`::\n+\n+    Similar to `index.blocks.read_only`, but also allows deleting the index to\n+    make more resources available. The <<disk-based-shard-allocation,disk-based shard\n+    allocator>> may add and remove this block automatically.\n+\n+Deleting documents from an index to release resources - rather than deleting the index itself - can increase the index size over time. When `index.blocks.read_only_allow_delete` is set to `true`, deleting documents is not permitted. However, deleting the index itself releases the read-only index block and makes resources available almost immediately.\n+\n+IMPORTANT: {es} adds and removes the read-only index block automatically when the disk utilization falls below the high watermark, controlled by <<cluster-routing-flood_stage,cluster.routing.allocation.disk.watermark.flood_stage>>.\n+\n+`index.blocks.read`::\n+\n+    Set to `true` to disable read operations against the index.\n+\n+`index.blocks.write`::\n+\n+    Set to `true` to disable data write operations against the index. Unlike `read_only`,\n+    this setting does not affect metadata. For instance, you can close an index with a `write`\n+    block, but not an index with a `read_only` block.\n+\n+`index.blocks.metadata`::\n+\n+    Set to `true` to disable index metadata reads and writes.\n+\n+[discrete]\n+[[add-index-block]]\n+=== Add index block API\n+\n+Adds an index block, and ensures that, once successfully returning to the\n+user, all shards of the index are properly accounting for the block, for\n+example that all in-flight writes to an index have been completed after\n+adding the write block.\n+\n+[source,console]\n+--------------------------------------------------\n+PUT /twitter/_block/write\n+--------------------------------------------------\n+// TEST[setup:twitter]\n+\n+The blocks available are `read_only`, `read_only_allow_delete`, `read`, `write`,\n+and `metadata`, and their meaning is described above in the settings section.\n+\n+[discrete]\n+[[add-index-block-api-request]]\n+==== {api-request-title}\n+\n+`PUT /<index>/_block/<block>`\n+\n+[discrete]\n+[[add-index-block-api-desc]]\n+==== {api-description-title}\n+\n+You use the add index blocks API to add an index block.\n+\n+include::{es-repo-dir}/indices/open-close.asciidoc[tag=closed-index]\n+\n+[discrete]\n+[[add-index-block-api-wait-for-active-shards]]\n+===== Wait For active shards\n+\n+include::{es-repo-dir}/indices/open-close.asciidoc[tag=wait-for-active-shards]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39498f6d7950cdc8bde62b6ec25f4d5be093030d"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MTk2Nzg5OnYy", "diffSide": "RIGHT", "path": "docs/reference/index-modules/blocks.asciidoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMzowMTowOFrOGoRCBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMzowMTowOFrOGoRCBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg3NTI2OQ==", "bodyText": "We should explicitly document the <block> path parameter.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n            `<block>`::\n          \n          \n            \n            (Required, string)\n          \n          \n            \n            Block type to add to the index.\n          \n          \n            \n            +\n          \n          \n            \n            .Valid values for `<block>`\n          \n          \n            \n            [%collapsible%open]\n          \n          \n            \n            ====\n          \n          \n            \n            `metadata`::\n          \n          \n            \n            Disable metadata changes, such as closing the index.\n          \n          \n            \n            \n          \n          \n            \n            `read`::\n          \n          \n            \n            Disable read operations.\n          \n          \n            \n            \n          \n          \n            \n            `read_only`::\n          \n          \n            \n            Disable write operations and metadata changes.\n          \n          \n            \n            \n          \n          \n            \n            `read_only_allow_delete`::\n          \n          \n            \n            Disable write operations and metadata changes.\n          \n          \n            \n            Document deletion is disabled.\n          \n          \n            \n            However, index deletion is still allowed.\n          \n          \n            \n            \n          \n          \n            \n            `write`::\n          \n          \n            \n            Disable write operations. However, metadata changes are still allowed.\n          \n          \n            \n            ====", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r444875269", "createdAt": "2020-06-24T13:01:08Z", "author": {"login": "jrodewig"}, "path": "docs/reference/index-modules/blocks.asciidoc", "diffHunk": "@@ -0,0 +1,141 @@\n+[[index-modules-blocks]]\n+== Index blocks\n+\n+Index blocks limit the kind of operations that are available on a certain\n+index. The blocks come in different flavours, allowing to block write,\n+read, or metadata operations. The blocks can be set / removed using dynamic\n+index settings, or can be added using a dedicated API, which also ensures\n+that, once successfully returning to the user, all shards of the index are\n+properly accounting for the block, for example that all in-flight writes to\n+an index have been completed after adding the write block.\n+\n+[discrete]\n+[[index-block-settings]]\n+=== Index block settings\n+\n+The following _dynamic_ index settings determine the blocks present on an\n+index:\n+\n+`index.blocks.read_only`::\n+\n+    Set to `true` to make the index and index metadata read only, `false` to\n+    allow writes and metadata changes.\n+\n+`index.blocks.read_only_allow_delete`::\n+\n+    Similar to `index.blocks.read_only`, but also allows deleting the index to\n+    make more resources available. The <<disk-based-shard-allocation,disk-based shard\n+    allocator>> may add and remove this block automatically.\n+\n+Deleting documents from an index to release resources - rather than deleting the index itself - can increase the index size over time. When `index.blocks.read_only_allow_delete` is set to `true`, deleting documents is not permitted. However, deleting the index itself releases the read-only index block and makes resources available almost immediately.\n+\n+IMPORTANT: {es} adds and removes the read-only index block automatically when the disk utilization falls below the high watermark, controlled by <<cluster-routing-flood_stage,cluster.routing.allocation.disk.watermark.flood_stage>>.\n+\n+`index.blocks.read`::\n+\n+    Set to `true` to disable read operations against the index.\n+\n+`index.blocks.write`::\n+\n+    Set to `true` to disable data write operations against the index. Unlike `read_only`,\n+    this setting does not affect metadata. For instance, you can close an index with a `write`\n+    block, but not an index with a `read_only` block.\n+\n+`index.blocks.metadata`::\n+\n+    Set to `true` to disable index metadata reads and writes.\n+\n+[discrete]\n+[[add-index-block]]\n+=== Add index block API\n+\n+Adds an index block, and ensures that, once successfully returning to the\n+user, all shards of the index are properly accounting for the block, for\n+example that all in-flight writes to an index have been completed after\n+adding the write block.\n+\n+[source,console]\n+--------------------------------------------------\n+PUT /twitter/_block/write\n+--------------------------------------------------\n+// TEST[setup:twitter]\n+\n+The blocks available are `read_only`, `read_only_allow_delete`, `read`, `write`,\n+and `metadata`, and their meaning is described above in the settings section.\n+\n+[discrete]\n+[[add-index-block-api-request]]\n+==== {api-request-title}\n+\n+`PUT /<index>/_block/<block>`\n+\n+[discrete]\n+[[add-index-block-api-desc]]\n+==== {api-description-title}\n+\n+You use the add index blocks API to add an index block.\n+\n+include::{es-repo-dir}/indices/open-close.asciidoc[tag=closed-index]\n+\n+[discrete]\n+[[add-index-block-api-wait-for-active-shards]]\n+===== Wait For active shards\n+\n+include::{es-repo-dir}/indices/open-close.asciidoc[tag=wait-for-active-shards]\n+\n+[discrete]\n+[[add-index-block-api-path-params]]\n+==== {api-path-parms-title}\n+\n+include::{es-repo-dir}/rest-api/common-parms.asciidoc[tag=index]\n++\n+To add blocks to all indices, use `_all` or `*`. To disallow the adding\n+of blocks to indices with `_all` or wildcard expressions,\n+change the `action.destructive_requires_name` cluster setting to `true`.\n+You can update this setting in the `elasticsearch.yml` file\n+or using the <<cluster-update-settings,cluster update settings>> API.\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39498f6d7950cdc8bde62b6ec25f4d5be093030d"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MTk3NjY4OnYy", "diffSide": "RIGHT", "path": "docs/reference/index-modules/blocks.asciidoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMzowMzoxOFrOGoRHRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMzowMzoxOFrOGoRHRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg3NjYxMg==", "bodyText": "I'd move this to the <block> path parameter definition below.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The blocks available are `read_only`, `read_only_allow_delete`, `read`, `write`,\n          \n          \n            \n            and `metadata`, and their meaning is described above in the settings section.", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r444876612", "createdAt": "2020-06-24T13:03:18Z", "author": {"login": "jrodewig"}, "path": "docs/reference/index-modules/blocks.asciidoc", "diffHunk": "@@ -0,0 +1,141 @@\n+[[index-modules-blocks]]\n+== Index blocks\n+\n+Index blocks limit the kind of operations that are available on a certain\n+index. The blocks come in different flavours, allowing to block write,\n+read, or metadata operations. The blocks can be set / removed using dynamic\n+index settings, or can be added using a dedicated API, which also ensures\n+that, once successfully returning to the user, all shards of the index are\n+properly accounting for the block, for example that all in-flight writes to\n+an index have been completed after adding the write block.\n+\n+[discrete]\n+[[index-block-settings]]\n+=== Index block settings\n+\n+The following _dynamic_ index settings determine the blocks present on an\n+index:\n+\n+`index.blocks.read_only`::\n+\n+    Set to `true` to make the index and index metadata read only, `false` to\n+    allow writes and metadata changes.\n+\n+`index.blocks.read_only_allow_delete`::\n+\n+    Similar to `index.blocks.read_only`, but also allows deleting the index to\n+    make more resources available. The <<disk-based-shard-allocation,disk-based shard\n+    allocator>> may add and remove this block automatically.\n+\n+Deleting documents from an index to release resources - rather than deleting the index itself - can increase the index size over time. When `index.blocks.read_only_allow_delete` is set to `true`, deleting documents is not permitted. However, deleting the index itself releases the read-only index block and makes resources available almost immediately.\n+\n+IMPORTANT: {es} adds and removes the read-only index block automatically when the disk utilization falls below the high watermark, controlled by <<cluster-routing-flood_stage,cluster.routing.allocation.disk.watermark.flood_stage>>.\n+\n+`index.blocks.read`::\n+\n+    Set to `true` to disable read operations against the index.\n+\n+`index.blocks.write`::\n+\n+    Set to `true` to disable data write operations against the index. Unlike `read_only`,\n+    this setting does not affect metadata. For instance, you can close an index with a `write`\n+    block, but not an index with a `read_only` block.\n+\n+`index.blocks.metadata`::\n+\n+    Set to `true` to disable index metadata reads and writes.\n+\n+[discrete]\n+[[add-index-block]]\n+=== Add index block API\n+\n+Adds an index block, and ensures that, once successfully returning to the\n+user, all shards of the index are properly accounting for the block, for\n+example that all in-flight writes to an index have been completed after\n+adding the write block.\n+\n+[source,console]\n+--------------------------------------------------\n+PUT /twitter/_block/write\n+--------------------------------------------------\n+// TEST[setup:twitter]\n+\n+The blocks available are `read_only`, `read_only_allow_delete`, `read`, `write`,\n+and `metadata`, and their meaning is described above in the settings section.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39498f6d7950cdc8bde62b6ec25f4d5be093030d"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MTk4NjMwOnYy", "diffSide": "RIGHT", "path": "docs/reference/index-modules/blocks.asciidoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMzowNjowNlrOGoRNsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMzowNjowNlrOGoRNsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg3ODI1Nw==", "bodyText": "The second part of this sentence (, and ensures that...) confused me. Is it saying If successful, the API returns a confirmation?  Either way, I'm not sure it's needed.\nIf you decide to keep it, I would reword and split into a separate sentence.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Adds an index block, and ensures that, once successfully returning to the\n          \n          \n            \n            user, all shards of the index are properly accounting for the block, for\n          \n          \n            \n            example that all in-flight writes to an index have been completed after\n          \n          \n            \n            adding the write block.\n          \n          \n            \n            Adds an index block to an index.", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r444878257", "createdAt": "2020-06-24T13:06:06Z", "author": {"login": "jrodewig"}, "path": "docs/reference/index-modules/blocks.asciidoc", "diffHunk": "@@ -0,0 +1,141 @@\n+[[index-modules-blocks]]\n+== Index blocks\n+\n+Index blocks limit the kind of operations that are available on a certain\n+index. The blocks come in different flavours, allowing to block write,\n+read, or metadata operations. The blocks can be set / removed using dynamic\n+index settings, or can be added using a dedicated API, which also ensures\n+that, once successfully returning to the user, all shards of the index are\n+properly accounting for the block, for example that all in-flight writes to\n+an index have been completed after adding the write block.\n+\n+[discrete]\n+[[index-block-settings]]\n+=== Index block settings\n+\n+The following _dynamic_ index settings determine the blocks present on an\n+index:\n+\n+`index.blocks.read_only`::\n+\n+    Set to `true` to make the index and index metadata read only, `false` to\n+    allow writes and metadata changes.\n+\n+`index.blocks.read_only_allow_delete`::\n+\n+    Similar to `index.blocks.read_only`, but also allows deleting the index to\n+    make more resources available. The <<disk-based-shard-allocation,disk-based shard\n+    allocator>> may add and remove this block automatically.\n+\n+Deleting documents from an index to release resources - rather than deleting the index itself - can increase the index size over time. When `index.blocks.read_only_allow_delete` is set to `true`, deleting documents is not permitted. However, deleting the index itself releases the read-only index block and makes resources available almost immediately.\n+\n+IMPORTANT: {es} adds and removes the read-only index block automatically when the disk utilization falls below the high watermark, controlled by <<cluster-routing-flood_stage,cluster.routing.allocation.disk.watermark.flood_stage>>.\n+\n+`index.blocks.read`::\n+\n+    Set to `true` to disable read operations against the index.\n+\n+`index.blocks.write`::\n+\n+    Set to `true` to disable data write operations against the index. Unlike `read_only`,\n+    this setting does not affect metadata. For instance, you can close an index with a `write`\n+    block, but not an index with a `read_only` block.\n+\n+`index.blocks.metadata`::\n+\n+    Set to `true` to disable index metadata reads and writes.\n+\n+[discrete]\n+[[add-index-block]]\n+=== Add index block API\n+\n+Adds an index block, and ensures that, once successfully returning to the\n+user, all shards of the index are properly accounting for the block, for\n+example that all in-flight writes to an index have been completed after\n+adding the write block.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39498f6d7950cdc8bde62b6ec25f4d5be093030d"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MTk5MjkxOnYy", "diffSide": "RIGHT", "path": "docs/reference/index-modules/blocks.asciidoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMzowNzo0OVrOGoRRyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMzowNzo0OVrOGoRRyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg3OTMwNg==", "bodyText": "Tweak for clarity.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                block, but not an index with a `read_only` block.\n          \n          \n            \n                block, but you cannot close an index with a `read_only` block.", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r444879306", "createdAt": "2020-06-24T13:07:49Z", "author": {"login": "jrodewig"}, "path": "docs/reference/index-modules/blocks.asciidoc", "diffHunk": "@@ -0,0 +1,141 @@\n+[[index-modules-blocks]]\n+== Index blocks\n+\n+Index blocks limit the kind of operations that are available on a certain\n+index. The blocks come in different flavours, allowing to block write,\n+read, or metadata operations. The blocks can be set / removed using dynamic\n+index settings, or can be added using a dedicated API, which also ensures\n+that, once successfully returning to the user, all shards of the index are\n+properly accounting for the block, for example that all in-flight writes to\n+an index have been completed after adding the write block.\n+\n+[discrete]\n+[[index-block-settings]]\n+=== Index block settings\n+\n+The following _dynamic_ index settings determine the blocks present on an\n+index:\n+\n+`index.blocks.read_only`::\n+\n+    Set to `true` to make the index and index metadata read only, `false` to\n+    allow writes and metadata changes.\n+\n+`index.blocks.read_only_allow_delete`::\n+\n+    Similar to `index.blocks.read_only`, but also allows deleting the index to\n+    make more resources available. The <<disk-based-shard-allocation,disk-based shard\n+    allocator>> may add and remove this block automatically.\n+\n+Deleting documents from an index to release resources - rather than deleting the index itself - can increase the index size over time. When `index.blocks.read_only_allow_delete` is set to `true`, deleting documents is not permitted. However, deleting the index itself releases the read-only index block and makes resources available almost immediately.\n+\n+IMPORTANT: {es} adds and removes the read-only index block automatically when the disk utilization falls below the high watermark, controlled by <<cluster-routing-flood_stage,cluster.routing.allocation.disk.watermark.flood_stage>>.\n+\n+`index.blocks.read`::\n+\n+    Set to `true` to disable read operations against the index.\n+\n+`index.blocks.write`::\n+\n+    Set to `true` to disable data write operations against the index. Unlike `read_only`,\n+    this setting does not affect metadata. For instance, you can close an index with a `write`\n+    block, but not an index with a `read_only` block.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39498f6d7950cdc8bde62b6ec25f4d5be093030d"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MjAxMDM0OnYy", "diffSide": "RIGHT", "path": "docs/reference/index-modules/blocks.asciidoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMzoxMjoyMVrOGoRdAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMzoxMjoyMVrOGoRdAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg4MjE3OA==", "bodyText": "This ensures the <block> path parameter definition renders correctly.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            [discrete]\n          \n          \n            \n            [[add-index-block-api-path-params]]\n          \n          \n            \n            ==== {api-path-parms-title}\n          \n          \n            \n            [discrete]\n          \n          \n            \n            [role=\"child_attributes\"]\n          \n          \n            \n            [[add-index-block-api-path-params]]\n          \n          \n            \n            ==== {api-path-parms-title}", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r444882178", "createdAt": "2020-06-24T13:12:21Z", "author": {"login": "jrodewig"}, "path": "docs/reference/index-modules/blocks.asciidoc", "diffHunk": "@@ -0,0 +1,141 @@\n+[[index-modules-blocks]]\n+== Index blocks\n+\n+Index blocks limit the kind of operations that are available on a certain\n+index. The blocks come in different flavours, allowing to block write,\n+read, or metadata operations. The blocks can be set / removed using dynamic\n+index settings, or can be added using a dedicated API, which also ensures\n+that, once successfully returning to the user, all shards of the index are\n+properly accounting for the block, for example that all in-flight writes to\n+an index have been completed after adding the write block.\n+\n+[discrete]\n+[[index-block-settings]]\n+=== Index block settings\n+\n+The following _dynamic_ index settings determine the blocks present on an\n+index:\n+\n+`index.blocks.read_only`::\n+\n+    Set to `true` to make the index and index metadata read only, `false` to\n+    allow writes and metadata changes.\n+\n+`index.blocks.read_only_allow_delete`::\n+\n+    Similar to `index.blocks.read_only`, but also allows deleting the index to\n+    make more resources available. The <<disk-based-shard-allocation,disk-based shard\n+    allocator>> may add and remove this block automatically.\n+\n+Deleting documents from an index to release resources - rather than deleting the index itself - can increase the index size over time. When `index.blocks.read_only_allow_delete` is set to `true`, deleting documents is not permitted. However, deleting the index itself releases the read-only index block and makes resources available almost immediately.\n+\n+IMPORTANT: {es} adds and removes the read-only index block automatically when the disk utilization falls below the high watermark, controlled by <<cluster-routing-flood_stage,cluster.routing.allocation.disk.watermark.flood_stage>>.\n+\n+`index.blocks.read`::\n+\n+    Set to `true` to disable read operations against the index.\n+\n+`index.blocks.write`::\n+\n+    Set to `true` to disable data write operations against the index. Unlike `read_only`,\n+    this setting does not affect metadata. For instance, you can close an index with a `write`\n+    block, but not an index with a `read_only` block.\n+\n+`index.blocks.metadata`::\n+\n+    Set to `true` to disable index metadata reads and writes.\n+\n+[discrete]\n+[[add-index-block]]\n+=== Add index block API\n+\n+Adds an index block, and ensures that, once successfully returning to the\n+user, all shards of the index are properly accounting for the block, for\n+example that all in-flight writes to an index have been completed after\n+adding the write block.\n+\n+[source,console]\n+--------------------------------------------------\n+PUT /twitter/_block/write\n+--------------------------------------------------\n+// TEST[setup:twitter]\n+\n+The blocks available are `read_only`, `read_only_allow_delete`, `read`, `write`,\n+and `metadata`, and their meaning is described above in the settings section.\n+\n+[discrete]\n+[[add-index-block-api-request]]\n+==== {api-request-title}\n+\n+`PUT /<index>/_block/<block>`\n+\n+[discrete]\n+[[add-index-block-api-desc]]\n+==== {api-description-title}\n+\n+You use the add index blocks API to add an index block.\n+\n+include::{es-repo-dir}/indices/open-close.asciidoc[tag=closed-index]\n+\n+[discrete]\n+[[add-index-block-api-wait-for-active-shards]]\n+===== Wait For active shards\n+\n+include::{es-repo-dir}/indices/open-close.asciidoc[tag=wait-for-active-shards]\n+\n+[discrete]\n+[[add-index-block-api-path-params]]\n+==== {api-path-parms-title}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39498f6d7950cdc8bde62b6ec25f4d5be093030d"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3ODE3MDg5OnYy", "diffSide": "RIGHT", "path": "rest-api-spec/src/main/resources/rest-api-spec/api/indices.add_block.json", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQyMjozNjoyOFrOGpOHGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQyMjozNjoyOFrOGpOHGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTg3NTk5NQ==", "bodyText": "Super minor nit\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                          \"description\":\"A comma separated list of indices to add blocks to\"\n          \n          \n            \n                          \"description\":\"A comma separated list of indices to add a block to\"", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r445875995", "createdAt": "2020-06-25T22:36:28Z", "author": {"login": "dakrone"}, "path": "rest-api-spec/src/main/resources/rest-api-spec/api/indices.add_block.json", "diffHunk": "@@ -0,0 +1,59 @@\n+{\n+  \"indices.add_block\":{\n+    \"documentation\":{\n+      \"url\":\"https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-blocks.html\",\n+      \"description\":\"Adds a block to an index.\"\n+    },\n+    \"stability\":\"stable\",\n+    \"url\":{\n+      \"paths\":[\n+        {\n+          \"path\":\"/{index}/_block/{block}\",\n+          \"methods\":[\n+            \"PUT\"\n+          ],\n+          \"parts\":{\n+            \"index\":{\n+              \"type\":\"list\",\n+              \"description\":\"A comma separated list of indices to add blocks to\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3069556007927fb98cb80d7cbf3c0a8e152ebab"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3ODIxNjI4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/readonly/TransportAddIndexBlockAction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQyMjo1ODozM1rOGpOjIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQyMjo1ODozM1rOGpOjIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTg4MzE3MQ==", "bodyText": "This javadoc could definitely be more helpful, since the basic text here could be inferred from the name of the class. I was thinking something along the lines of:\n\nThe {@link TransportAddIndexBlockAction} class adds a single index level block to a given set of indices. Not only does it set the correct setting, but it ensures that, once successfully returning to the user, all shards of the index are properly accounting for the block, for instance, when adding a write block all in-flight writes to an index have been completed prior to the response being returned. These actions are done in multiple cluster state updates (at least two). See also {@link TransportVerifyShardIndexBlockAction} for the eventual delegation for shard-level verification.", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r445883171", "createdAt": "2020-06-25T22:58:33Z", "author": {"login": "dakrone"}, "path": "server/src/main/java/org/elasticsearch/action/admin/indices/readonly/TransportAddIndexBlockAction.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.admin.indices.readonly;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.DestructiveOperations;\n+import org.elasticsearch.action.support.master.TransportMasterNodeAction;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.block.ClusterBlockLevel;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.metadata.MetadataIndexStateService;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.index.Index;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+\n+/**\n+ * Add index block action", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3069556007927fb98cb80d7cbf3c0a8e152ebab"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3ODIxNzU3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/readonly/TransportVerifyShardIndexBlockAction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQyMjo1OTowOVrOGpOj5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQyMjo1OTowOVrOGpOj5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTg4MzM2Nw==", "bodyText": "Minor nit\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new IllegalStateException(\"Index shard \" + shardId + \" is not blocking all operations during read-only marking\");\n          \n          \n            \n                        throw new IllegalStateException(\"index shard \" + shardId + \" is not blocking all operations during read-only marking\");", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r445883367", "createdAt": "2020-06-25T22:59:09Z", "author": {"login": "dakrone"}, "path": "server/src/main/java/org/elasticsearch/action/admin/indices/readonly/TransportVerifyShardIndexBlockAction.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.action.admin.indices.readonly;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.ActionType;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.replication.ReplicationOperation;\n+import org.elasticsearch.action.support.replication.ReplicationRequest;\n+import org.elasticsearch.action.support.replication.ReplicationResponse;\n+import org.elasticsearch.action.support.replication.TransportReplicationAction;\n+import org.elasticsearch.cluster.action.shard.ShardStateAction;\n+import org.elasticsearch.cluster.block.ClusterBlock;\n+import org.elasticsearch.cluster.block.ClusterBlocks;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.lease.Releasable;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.shard.IndexShard;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.indices.IndicesService;\n+import org.elasticsearch.tasks.TaskId;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+\n+/**\n+ * Action used to verify whether shards have properly applied a given index block,\n+ * and are no longer executing any operations in violation of that block. This action\n+ * requests all operation permits of the shard in order to wait for all write operations\n+ * to complete.\n+ */\n+public class TransportVerifyShardIndexBlockAction extends TransportReplicationAction<\n+    TransportVerifyShardIndexBlockAction.ShardRequest, TransportVerifyShardIndexBlockAction.ShardRequest, ReplicationResponse> {\n+\n+    public static final String NAME = AddIndexBlockAction.NAME + \"[s]\";\n+    public static final ActionType<ReplicationResponse> TYPE = new ActionType<>(NAME, ReplicationResponse::new);\n+    protected Logger logger = LogManager.getLogger(getClass());\n+\n+    @Inject\n+    public TransportVerifyShardIndexBlockAction(final Settings settings, final TransportService transportService,\n+                                                final ClusterService clusterService, final IndicesService indicesService,\n+                                                final ThreadPool threadPool, final ShardStateAction stateAction,\n+                                                final ActionFilters actionFilters) {\n+        super(settings, NAME, transportService, clusterService, indicesService, threadPool, stateAction, actionFilters,\n+            ShardRequest::new, ShardRequest::new, ThreadPool.Names.MANAGEMENT);\n+    }\n+\n+    @Override\n+    protected ReplicationResponse newResponseInstance(StreamInput in) throws IOException {\n+        return new ReplicationResponse(in);\n+    }\n+\n+    @Override\n+    protected void acquirePrimaryOperationPermit(final IndexShard primary,\n+                                                 final ShardRequest request,\n+                                                 final ActionListener<Releasable> onAcquired) {\n+        primary.acquireAllPrimaryOperationsPermits(onAcquired, request.timeout());\n+    }\n+\n+    @Override\n+    protected void acquireReplicaOperationPermit(final IndexShard replica,\n+                                                 final ShardRequest request,\n+                                                 final ActionListener<Releasable> onAcquired,\n+                                                 final long primaryTerm,\n+                                                 final long globalCheckpoint,\n+                                                 final long maxSeqNoOfUpdateOrDeletes) {\n+        replica.acquireAllReplicaOperationsPermits(primaryTerm, globalCheckpoint, maxSeqNoOfUpdateOrDeletes, onAcquired, request.timeout());\n+    }\n+\n+    @Override\n+    protected void shardOperationOnPrimary(final ShardRequest shardRequest, final IndexShard primary,\n+            ActionListener<PrimaryResult<ShardRequest, ReplicationResponse>> listener) {\n+        ActionListener.completeWith(listener, () -> {\n+            executeShardOperation(shardRequest, primary);\n+            return new PrimaryResult<>(shardRequest, new ReplicationResponse());\n+        });\n+    }\n+\n+    @Override\n+    protected ReplicaResult shardOperationOnReplica(final ShardRequest shardRequest, final IndexShard replica) throws IOException {\n+        executeShardOperation(shardRequest, replica);\n+        return new ReplicaResult();\n+    }\n+\n+    private void executeShardOperation(final ShardRequest request, final IndexShard indexShard) throws IOException {\n+        final ShardId shardId = indexShard.shardId();\n+        if (indexShard.getActiveOperationsCount() != IndexShard.OPERATIONS_BLOCKED) {\n+            throw new IllegalStateException(\"Index shard \" + shardId + \" is not blocking all operations during read-only marking\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3069556007927fb98cb80d7cbf3c0a8e152ebab"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3ODIxNzg2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/readonly/TransportVerifyShardIndexBlockAction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQyMjo1OToyMFrOGpOkHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQyMjo1OToyMFrOGpOkHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTg4MzQyMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new IllegalStateException(\"Index shard \" + shardId + \" must be blocked by \" + request.clusterBlock() +\n          \n          \n            \n                        throw new IllegalStateException(\"index shard \" + shardId + \" must be blocked by \" + request.clusterBlock() +", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r445883420", "createdAt": "2020-06-25T22:59:20Z", "author": {"login": "dakrone"}, "path": "server/src/main/java/org/elasticsearch/action/admin/indices/readonly/TransportVerifyShardIndexBlockAction.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.action.admin.indices.readonly;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.ActionType;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.replication.ReplicationOperation;\n+import org.elasticsearch.action.support.replication.ReplicationRequest;\n+import org.elasticsearch.action.support.replication.ReplicationResponse;\n+import org.elasticsearch.action.support.replication.TransportReplicationAction;\n+import org.elasticsearch.cluster.action.shard.ShardStateAction;\n+import org.elasticsearch.cluster.block.ClusterBlock;\n+import org.elasticsearch.cluster.block.ClusterBlocks;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.lease.Releasable;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.shard.IndexShard;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.indices.IndicesService;\n+import org.elasticsearch.tasks.TaskId;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+\n+/**\n+ * Action used to verify whether shards have properly applied a given index block,\n+ * and are no longer executing any operations in violation of that block. This action\n+ * requests all operation permits of the shard in order to wait for all write operations\n+ * to complete.\n+ */\n+public class TransportVerifyShardIndexBlockAction extends TransportReplicationAction<\n+    TransportVerifyShardIndexBlockAction.ShardRequest, TransportVerifyShardIndexBlockAction.ShardRequest, ReplicationResponse> {\n+\n+    public static final String NAME = AddIndexBlockAction.NAME + \"[s]\";\n+    public static final ActionType<ReplicationResponse> TYPE = new ActionType<>(NAME, ReplicationResponse::new);\n+    protected Logger logger = LogManager.getLogger(getClass());\n+\n+    @Inject\n+    public TransportVerifyShardIndexBlockAction(final Settings settings, final TransportService transportService,\n+                                                final ClusterService clusterService, final IndicesService indicesService,\n+                                                final ThreadPool threadPool, final ShardStateAction stateAction,\n+                                                final ActionFilters actionFilters) {\n+        super(settings, NAME, transportService, clusterService, indicesService, threadPool, stateAction, actionFilters,\n+            ShardRequest::new, ShardRequest::new, ThreadPool.Names.MANAGEMENT);\n+    }\n+\n+    @Override\n+    protected ReplicationResponse newResponseInstance(StreamInput in) throws IOException {\n+        return new ReplicationResponse(in);\n+    }\n+\n+    @Override\n+    protected void acquirePrimaryOperationPermit(final IndexShard primary,\n+                                                 final ShardRequest request,\n+                                                 final ActionListener<Releasable> onAcquired) {\n+        primary.acquireAllPrimaryOperationsPermits(onAcquired, request.timeout());\n+    }\n+\n+    @Override\n+    protected void acquireReplicaOperationPermit(final IndexShard replica,\n+                                                 final ShardRequest request,\n+                                                 final ActionListener<Releasable> onAcquired,\n+                                                 final long primaryTerm,\n+                                                 final long globalCheckpoint,\n+                                                 final long maxSeqNoOfUpdateOrDeletes) {\n+        replica.acquireAllReplicaOperationsPermits(primaryTerm, globalCheckpoint, maxSeqNoOfUpdateOrDeletes, onAcquired, request.timeout());\n+    }\n+\n+    @Override\n+    protected void shardOperationOnPrimary(final ShardRequest shardRequest, final IndexShard primary,\n+            ActionListener<PrimaryResult<ShardRequest, ReplicationResponse>> listener) {\n+        ActionListener.completeWith(listener, () -> {\n+            executeShardOperation(shardRequest, primary);\n+            return new PrimaryResult<>(shardRequest, new ReplicationResponse());\n+        });\n+    }\n+\n+    @Override\n+    protected ReplicaResult shardOperationOnReplica(final ShardRequest shardRequest, final IndexShard replica) throws IOException {\n+        executeShardOperation(shardRequest, replica);\n+        return new ReplicaResult();\n+    }\n+\n+    private void executeShardOperation(final ShardRequest request, final IndexShard indexShard) throws IOException {\n+        final ShardId shardId = indexShard.shardId();\n+        if (indexShard.getActiveOperationsCount() != IndexShard.OPERATIONS_BLOCKED) {\n+            throw new IllegalStateException(\"Index shard \" + shardId + \" is not blocking all operations during read-only marking\");\n+        }\n+\n+        final ClusterBlocks clusterBlocks = clusterService.state().blocks();\n+        if (clusterBlocks.hasIndexBlock(shardId.getIndexName(), request.clusterBlock()) == false) {\n+            throw new IllegalStateException(\"Index shard \" + shardId + \" must be blocked by \" + request.clusterBlock() +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3069556007927fb98cb80d7cbf3c0a8e152ebab"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3ODIyNTc4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexStateService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQyMzowMzo0MlrOGpOpRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQyMzowMzo0MlrOGpOpRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTg4NDc0MQ==", "bodyText": "super minor, but since we usually wrap things in []:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        blockedIndices.keySet().stream().map(Object::toString).collect(Collectors.joining(\",\")));\n          \n          \n            \n                        blockedIndices.keySet().stream().map(Object::toString).collect(Collectors.toList()));", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r445884741", "createdAt": "2020-06-25T23:03:42Z", "author": {"login": "dakrone"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexStateService.java", "diffHunk": "@@ -304,6 +310,176 @@ static ClusterState addIndexClosedBlocks(final Index[] indices, final Map<Index,\n         return ClusterState.builder(currentState).blocks(blocks).metadata(metadata).routingTable(routingTable.build()).build();\n     }\n \n+    /**\n+     * Updates the cluster state for the given indices with the given index block,\n+     * and also returns the updated indices (and their blocks) in a map.\n+     * @param indices The indices to add blocks to if needed\n+     * @param currentState The current cluster state\n+     * @param block The type of block to add\n+     * @return a tuple of the updated cluster state, as well as the blocks that got added\n+     */\n+    static Tuple<ClusterState, Map<Index, ClusterBlock>> addIndexBlock(final Index[] indices, final ClusterState currentState,\n+                                                                       final APIBlock block) {\n+        final Metadata.Builder metadata = Metadata.builder(currentState.metadata());\n+\n+        final Set<Index> indicesToAddBlock = new HashSet<>();\n+        for (Index index : indices) {\n+            metadata.getSafe(index); // to check if index exists\n+            if (currentState.blocks().hasIndexBlock(index.getName(), block.block)) {\n+                logger.debug(\"index {} already has block {}, ignoring\", index, block.block);\n+            } else {\n+                indicesToAddBlock.add(index);\n+            }\n+        }\n+\n+        if (indicesToAddBlock.isEmpty()) {\n+            return Tuple.tuple(currentState, Collections.emptyMap());\n+        }\n+\n+        final ClusterBlocks.Builder blocks = ClusterBlocks.builder().blocks(currentState.blocks());\n+        final RoutingTable.Builder routingTable = RoutingTable.builder(currentState.routingTable());\n+        final Map<Index, ClusterBlock> blockedIndices = new HashMap<>();\n+\n+        for (Index index : indicesToAddBlock) {\n+            ClusterBlock indexBlock = null;\n+            final Set<ClusterBlock> clusterBlocks = currentState.blocks().indices().get(index.getName());\n+            if (clusterBlocks != null) {\n+                for (ClusterBlock clusterBlock : clusterBlocks) {\n+                    if (clusterBlock.id() == block.block.id()) {\n+                        // Reuse the existing UUID-based block\n+                        indexBlock = clusterBlock;\n+                        break;\n+                    }\n+                }\n+            }\n+            if (indexBlock == null) {\n+                // Create a new UUID-based block\n+                indexBlock = createUUIDBasedBlock(block.block);\n+            }\n+            assert Strings.hasLength(indexBlock.uuid()) : \"Block should have a UUID\";\n+            blocks.addIndexBlock(index.getName(), indexBlock);\n+            blockedIndices.put(index, indexBlock);\n+            // update index settings as well to match the block\n+            final IndexMetadata indexMetadata = metadata.getSafe(index);\n+            if (block.setting().get(indexMetadata.getSettings()) == false) {\n+                final Settings updatedSettings = Settings.builder()\n+                    .put(indexMetadata.getSettings()).put(block.settingName(), true).build();\n+\n+                metadata.put(IndexMetadata.builder(indexMetadata)\n+                    .settings(updatedSettings)\n+                    .settingsVersion(indexMetadata.getSettingsVersion() + 1));\n+            }\n+        }\n+\n+        logger.info(\"adding block {} to indices {}\", block.name,\n+            blockedIndices.keySet().stream().map(Object::toString).collect(Collectors.joining(\",\")));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3069556007927fb98cb80d7cbf3c0a8e152ebab"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3ODIzODcyOnYy", "diffSide": "RIGHT", "path": "docs/reference/index-modules/blocks.asciidoc", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQyMzoxMDo1OFrOGpOxbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQyMzoxMDo1OFrOGpOxbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTg4NjgyOA==", "bodyText": "Should we call out that this only applies to write operations, not read operations?", "url": "https://github.com/elastic/elasticsearch/pull/58094#discussion_r445886828", "createdAt": "2020-06-25T23:10:58Z", "author": {"login": "dakrone"}, "path": "docs/reference/index-modules/blocks.asciidoc", "diffHunk": "@@ -0,0 +1,146 @@\n+[[index-modules-blocks]]\n+== Index blocks\n+\n+Index blocks limit the kind of operations that are available on a certain\n+index. The blocks come in different flavours, allowing to block write,\n+read, or metadata operations. The blocks can be set / removed using dynamic\n+index settings, or can be added using a dedicated API, which also ensures\n+that, once successfully returning to the user, all shards of the index are\n+properly accounting for the block, for example that all in-flight writes to\n+an index have been completed after adding the write block.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3069556007927fb98cb80d7cbf3c0a8e152ebab"}, "originalPosition": 10}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1613, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}