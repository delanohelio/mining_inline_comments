{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMzNDQ0NzQ3", "number": 58018, "title": "Sending operations concurrently in peer recovery", "bodyText": "Today, we send operations in phase2 of peer recoveries batch by batch sequentially. Normally that's okay as we should have a fairly small of operations in phase 2 due to the file-based threshold. However, if phase1 takes a lot of time and we are actively indexing, then phase2 can have a lot of operations to replay.\nWith this change, we will send multiple batches concurrently (defaults to 1) to reduce the recovery time.\nRelates #58011", "createdAt": "2020-06-12T03:36:07Z", "url": "https://github.com/elastic/elasticsearch/pull/58018", "merged": true, "mergeCommit": {"oid": "961db311f0efb19b6c360243c87479449f855898"}, "closed": true, "closedAt": "2020-07-07T22:00:04Z", "author": {"login": "dnhatn"}, "timelineItems": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcqaXrpAH2gAyNDMzNDQ0NzQ3OmEyMTAzYTc4NjEzMzBiZTRkZTc0ZmUzNDk2ZTA1OTI3YTQ3Y2Q0YmE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcysK_BgH2gAyNDMzNDQ0NzQ3OmZmN2U1N2IzMzI2ZjkxNGVlNjViNWY2NzYxMTYyY2NjZWU5Y2UyZWY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "a2103a7861330be4de74fe3496e05927a47cd4ba", "author": {"user": {"login": "dnhatn", "name": "Nhat Nguyen"}}, "url": "https://github.com/elastic/elasticsearch/commit/a2103a7861330be4de74fe3496e05927a47cd4ba", "committedDate": "2020-06-12T03:34:18Z", "message": "Sending operations concurrently in peer recovery"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI5NDQwODEz", "url": "https://github.com/elastic/elasticsearch/pull/58018#pullrequestreview-429440813", "createdAt": "2020-06-12T03:39:23Z", "commit": {"oid": "a2103a7861330be4de74fe3496e05927a47cd4ba"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQwMzozOToyM1rOGi2A9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQwMzozOToyM1rOGi2A9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE4OTc0OA==", "bodyText": "I think we should use the WRITE threadpool instead of GENERIC for indexing operations.", "url": "https://github.com/elastic/elasticsearch/pull/58018#discussion_r439189748", "createdAt": "2020-06-12T03:39:23Z", "author": {"login": "dnhatn"}, "path": "server/src/main/java/org/elasticsearch/indices/recovery/PeerRecoveryTargetService.java", "diffHunk": "@@ -119,7 +119,7 @@ public PeerRecoveryTargetService(ThreadPool threadPool, TransportService transpo\n             RecoveryCleanFilesRequest::new, new CleanFilesRequestHandler());\n         transportService.registerRequestHandler(Actions.PREPARE_TRANSLOG, ThreadPool.Names.GENERIC,\n                 RecoveryPrepareForTranslogOperationsRequest::new, new PrepareForTranslogOperationsRequestHandler());\n-        transportService.registerRequestHandler(Actions.TRANSLOG_OPS, ThreadPool.Names.GENERIC, RecoveryTranslogOperationsRequest::new,\n+        transportService.registerRequestHandler(Actions.TRANSLOG_OPS, ThreadPool.Names.WRITE, RecoveryTranslogOperationsRequest::new,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2103a7861330be4de74fe3496e05927a47cd4ba"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7707c3318111b53b310ce782295d049b06a98d71", "author": {"user": {"login": "dnhatn", "name": "Nhat Nguyen"}}, "url": "https://github.com/elastic/elasticsearch/commit/7707c3318111b53b310ce782295d049b06a98d71", "committedDate": "2020-06-12T04:00:20Z", "message": "fix test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI5NTk1ODIx", "url": "https://github.com/elastic/elasticsearch/pull/58018#pullrequestreview-429595821", "createdAt": "2020-06-12T09:28:05Z", "commit": {"oid": "7707c3318111b53b310ce782295d049b06a98d71"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI5NTk2Njk1", "url": "https://github.com/elastic/elasticsearch/pull/58018#pullrequestreview-429596695", "createdAt": "2020-06-12T09:29:27Z", "commit": {"oid": "7707c3318111b53b310ce782295d049b06a98d71"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQwOToyOToyN1rOGi9c6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQwOToyOToyN1rOGi9c6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTMxMTU5NA==", "bodyText": "I'm not sure I understand how this adds parallelism: If we only have one item here in the chunks list, then the MultiChunkTransfer won't do anything for us will it?", "url": "https://github.com/elastic/elasticsearch/pull/58018#discussion_r439311594", "createdAt": "2020-06-12T09:29:27Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/indices/recovery/RecoverySourceHandler.java", "diffHunk": "@@ -661,106 +655,122 @@ void phase2(\n             throw new IndexShardClosedException(request.shardId());\n         }\n         logger.trace(\"recovery [phase2]: sending transaction log operations (from [\" + startingSeqNo + \"] to [\" + endingSeqNo + \"]\");\n-\n-        final AtomicInteger skippedOps = new AtomicInteger();\n-        final AtomicInteger totalSentOps = new AtomicInteger();\n-        final AtomicInteger lastBatchCount = new AtomicInteger(); // used to estimate the count of the subsequent batch.\n-        final CheckedSupplier<List<Translog.Operation>, IOException> readNextBatch = () -> {\n-            // We need to synchronized Snapshot#next() because it's called by different threads through sendBatch.\n-            // Even though those calls are not concurrent, Snapshot#next() uses non-synchronized state and is not multi-thread-compatible.\n-            synchronized (snapshot) {\n-                final List<Translog.Operation> ops = lastBatchCount.get() > 0 ? new ArrayList<>(lastBatchCount.get()) : new ArrayList<>();\n-                long batchSizeInBytes = 0L;\n-                Translog.Operation operation;\n-                while ((operation = snapshot.next()) != null) {\n-                    if (shard.state() == IndexShardState.CLOSED) {\n-                        throw new IndexShardClosedException(request.shardId());\n-                    }\n-                    cancellableThreads.checkForCancel();\n-                    final long seqNo = operation.seqNo();\n-                    if (seqNo < startingSeqNo || seqNo > endingSeqNo) {\n-                        skippedOps.incrementAndGet();\n-                        continue;\n-                    }\n-                    ops.add(operation);\n-                    batchSizeInBytes += operation.estimateSize();\n-                    totalSentOps.incrementAndGet();\n-\n-                    // check if this request is past bytes threshold, and if so, send it off\n-                    if (batchSizeInBytes >= chunkSizeInBytes) {\n-                        break;\n-                    }\n-                }\n-                lastBatchCount.set(ops.size());\n-                return ops;\n-            }\n-        };\n-\n         final StopWatch stopWatch = new StopWatch().start();\n-        final ActionListener<Long> batchedListener = ActionListener.map(listener,\n-            targetLocalCheckpoint -> {\n-                assert snapshot.totalOperations() == snapshot.skippedOperations() + skippedOps.get() + totalSentOps.get()\n+        final StepListener<Void> sendListener = new StepListener<>();\n+        final OperationBatchSender sender = new OperationBatchSender(startingSeqNo, endingSeqNo, snapshot, maxSeenAutoIdTimestamp,\n+            maxSeqNoOfUpdatesOrDeletes, retentionLeases, mappingVersion, sendListener);\n+        sendListener.whenComplete(\n+            ignored -> {\n+                final long skippedOps = sender.skippedOps.get();\n+                final int totalSentOps = sender.sentOps.get();\n+                final long targetLocalCheckpoint = sender.targetLocalCheckpoint.get();\n+                assert snapshot.totalOperations() == snapshot.skippedOperations() + skippedOps + totalSentOps\n                     : String.format(Locale.ROOT, \"expected total [%d], overridden [%d], skipped [%d], total sent [%d]\",\n-                    snapshot.totalOperations(), snapshot.skippedOperations(), skippedOps.get(), totalSentOps.get());\n+                    snapshot.totalOperations(), snapshot.skippedOperations(), skippedOps, totalSentOps);\n                 stopWatch.stop();\n                 final TimeValue tookTime = stopWatch.totalTime();\n                 logger.trace(\"recovery [phase2]: took [{}]\", tookTime);\n-                return new SendSnapshotResult(targetLocalCheckpoint, totalSentOps.get(), tookTime);\n-            }\n-        );\n+                listener.onResponse(new SendSnapshotResult(targetLocalCheckpoint, totalSentOps, tookTime));\n+            }, listener::onFailure);\n+        sender.start();\n+    }\n \n-        sendBatch(\n-                readNextBatch,\n-                true,\n-                SequenceNumbers.UNASSIGNED_SEQ_NO,\n-                snapshot.totalOperations(),\n-                maxSeenAutoIdTimestamp,\n-                maxSeqNoOfUpdatesOrDeletes,\n-                retentionLeases,\n-                mappingVersion,\n-                batchedListener);\n+    private static class OperationChunkRequest implements MultiChunkTransfer.ChunkRequest {\n+        final List<Translog.Operation> operations;\n+        final boolean lastChunk;\n+\n+        OperationChunkRequest(List<Translog.Operation> operations, boolean lastChunk) {\n+            this.operations = operations;\n+            this.lastChunk = lastChunk;\n+        }\n+\n+        @Override\n+        public boolean lastChunk() {\n+            return lastChunk;\n+        }\n     }\n \n-    private void sendBatch(\n-            final CheckedSupplier<List<Translog.Operation>, IOException> nextBatch,\n-            final boolean firstBatch,\n-            final long targetLocalCheckpoint,\n-            final int totalTranslogOps,\n-            final long maxSeenAutoIdTimestamp,\n-            final long maxSeqNoOfUpdatesOrDeletes,\n-            final RetentionLeases retentionLeases,\n-            final long mappingVersionOnPrimary,\n-            final ActionListener<Long> listener) throws IOException {\n-        assert ThreadPool.assertCurrentMethodIsNotCalledRecursively();\n-        assert Transports.assertNotTransportThread(RecoverySourceHandler.this + \"[send translog]\");\n-        final List<Translog.Operation> operations = nextBatch.get();\n-        // send the leftover operations or if no operations were sent, request the target to respond with its local checkpoint\n-        if (operations.isEmpty() == false || firstBatch) {\n+    private class OperationBatchSender extends MultiChunkTransfer<Translog.Snapshot, OperationChunkRequest> {\n+        private final long startingSeqNo;\n+        private final long endingSeqNo;\n+        private final Translog.Snapshot snapshot;\n+        private final long maxSeenAutoIdTimestamp;\n+        private final long maxSeqNoOfUpdatesOrDeletes;\n+        private final RetentionLeases retentionLeases;\n+        private final long mappingVersion;\n+        private int lastBatchCount = 0; // used to estimate the count of the subsequent batch.\n+        private final AtomicInteger skippedOps = new AtomicInteger();\n+        private final AtomicInteger sentOps = new AtomicInteger();\n+        private final AtomicLong targetLocalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);\n+\n+        OperationBatchSender(long startingSeqNo, long endingSeqNo, Translog.Snapshot snapshot, long maxSeenAutoIdTimestamp,\n+                             long maxSeqNoOfUpdatesOrDeletes, RetentionLeases retentionLeases, long mappingVersion,\n+                             ActionListener<Void> listener) {\n+            super(logger, threadPool.getThreadContext(), listener, maxConcurrentFileChunks, List.of(snapshot));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7707c3318111b53b310ce782295d049b06a98d71"}, "originalPosition": 160}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI5NzkyNDA4", "url": "https://github.com/elastic/elasticsearch/pull/58018#pullrequestreview-429792408", "createdAt": "2020-06-12T14:34:05Z", "commit": {"oid": "7707c3318111b53b310ce782295d049b06a98d71"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e1332b3df020f3b36cd053cb7eea87c4729d0123", "author": {"user": {"login": "dnhatn", "name": "Nhat Nguyen"}}, "url": "https://github.com/elastic/elasticsearch/commit/e1332b3df020f3b36cd053cb7eea87c4729d0123", "committedDate": "2020-07-06T14:08:59Z", "message": "Merge branch 'master' into send-ops-concurrently"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a28c2e3dbfe6fbd4b9903251a211bf0a1f2e115c", "author": {"user": {"login": "dnhatn", "name": "Nhat Nguyen"}}, "url": "https://github.com/elastic/elasticsearch/commit/a28c2e3dbfe6fbd4b9903251a211bf0a1f2e115c", "committedDate": "2020-07-06T15:46:05Z", "message": "New setting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d34db4b50754d3676d76995be0b139e6a32ba095", "author": {"user": {"login": "dnhatn", "name": "Nhat Nguyen"}}, "url": "https://github.com/elastic/elasticsearch/commit/d34db4b50754d3676d76995be0b139e6a32ba095", "committedDate": "2020-07-06T15:47:02Z", "message": "Use generic to write operations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a564188d9869bc211383a926920d5160ccbda7c7", "author": {"user": {"login": "dnhatn", "name": "Nhat Nguyen"}}, "url": "https://github.com/elastic/elasticsearch/commit/a564188d9869bc211383a926920d5160ccbda7c7", "committedDate": "2020-07-06T15:55:56Z", "message": "fix setting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "44f83d6a6b7af1e5e4f646816631c739ea142f71", "author": {"user": {"login": "dnhatn", "name": "Nhat Nguyen"}}, "url": "https://github.com/elastic/elasticsearch/commit/44f83d6a6b7af1e5e4f646816631c739ea142f71", "committedDate": "2020-07-06T16:08:57Z", "message": "reduce random setting upper bound"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1a6b6300f6f12d949958d41b3bd8a46e7ac2eaa3", "author": {"user": {"login": "dnhatn", "name": "Nhat Nguyen"}}, "url": "https://github.com/elastic/elasticsearch/commit/1a6b6300f6f12d949958d41b3bd8a46e7ac2eaa3", "committedDate": "2020-07-06T18:15:36Z", "message": "Merge branch 'master' into send-ops-concurrently"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f0c2d713e69f2616c5b81749f03b8d676f411552", "author": {"user": {"login": "dnhatn", "name": "Nhat Nguyen"}}, "url": "https://github.com/elastic/elasticsearch/commit/f0c2d713e69f2616c5b81749f03b8d676f411552", "committedDate": "2020-07-06T18:22:14Z", "message": "stylecheck"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzMzk2MDU5", "url": "https://github.com/elastic/elasticsearch/pull/58018#pullrequestreview-443396059", "createdAt": "2020-07-06T20:46:20Z", "commit": {"oid": "f0c2d713e69f2616c5b81749f03b8d676f411552"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMDo0NjoyMFrOGtmjMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMDo0NjoyMFrOGtmjMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ3MDcwNA==", "bodyText": "Maybe reword this a little to something like (though maybe @DaveCTurner can use his native speaker powers here to help with wording :)):\nIncrease the value of this setting with care as higher values will cause increased CPU use, which might negatively impact indexing and search activities.", "url": "https://github.com/elastic/elasticsearch/pull/58018#discussion_r450470704", "createdAt": "2020-07-06T20:46:20Z", "author": {"login": "original-brownbear"}, "path": "docs/reference/modules/indices/recovery.asciidoc", "diffHunk": "@@ -48,3 +48,11 @@ sent in parallel for each recovery. Defaults to `2`.\n +\n You can increase the value of this setting when the recovery of a single shard\n is not reaching the traffic limit set by `indices.recovery.max_bytes_per_sec`.\n+\n+`indices.recovery.max_concurrent_operation_chunks`::\n+(<<cluster-update-settings,Dynamic>>, Expert) Number of operation chunk requests\n+sent in parallel for each recovery. Defaults to `1`.\n++\n+Increasing the value of this setting with care as it can cause recoveries to consume", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0c2d713e69f2616c5b81749f03b8d676f411552"}, "originalPosition": 9}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzNjAxNTcy", "url": "https://github.com/elastic/elasticsearch/pull/58018#pullrequestreview-443601572", "createdAt": "2020-07-07T06:41:36Z", "commit": {"oid": "f0c2d713e69f2616c5b81749f03b8d676f411552"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwNjo0MTozNlrOGtxCgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwNjo1Njo0MVrOGtxaNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDY0MjU2MQ==", "bodyText": "Suggest simply indices.recovery.max_concurrent_operations; the fact that operations are sent in chunks (i.e. batches) is a bit too much detail for users here IMO.", "url": "https://github.com/elastic/elasticsearch/pull/58018#discussion_r450642561", "createdAt": "2020-07-07T06:41:36Z", "author": {"login": "DaveCTurner"}, "path": "docs/reference/modules/indices/recovery.asciidoc", "diffHunk": "@@ -48,3 +48,11 @@ sent in parallel for each recovery. Defaults to `2`.\n +\n You can increase the value of this setting when the recovery of a single shard\n is not reaching the traffic limit set by `indices.recovery.max_bytes_per_sec`.\n+\n+`indices.recovery.max_concurrent_operation_chunks`::", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0c2d713e69f2616c5b81749f03b8d676f411552"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDY0NDc0OQ==", "bodyText": "Similarly:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            (<<cluster-update-settings,Dynamic>>, Expert) Number of operation chunk requests\n          \n          \n            \n            (<<cluster-update-settings,Dynamic>>, Expert) Number of operations", "url": "https://github.com/elastic/elasticsearch/pull/58018#discussion_r450644749", "createdAt": "2020-07-07T06:47:14Z", "author": {"login": "DaveCTurner"}, "path": "docs/reference/modules/indices/recovery.asciidoc", "diffHunk": "@@ -48,3 +48,11 @@ sent in parallel for each recovery. Defaults to `2`.\n +\n You can increase the value of this setting when the recovery of a single shard\n is not reaching the traffic limit set by `indices.recovery.max_bytes_per_sec`.\n+\n+`indices.recovery.max_concurrent_operation_chunks`::\n+(<<cluster-update-settings,Dynamic>>, Expert) Number of operation chunk requests", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0c2d713e69f2616c5b81749f03b8d676f411552"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDY0ODYzMA==", "bodyText": "Sure, how about this?\nConcurrently replaying operations during recovery can be very\nresource-intensive and may interfere with indexing, search, and other\nactivities in your cluster. Do not increase this setting without carefully\nverifying that your cluster has the resources available to handle the extra\nload that will result.", "url": "https://github.com/elastic/elasticsearch/pull/58018#discussion_r450648630", "createdAt": "2020-07-07T06:56:41Z", "author": {"login": "DaveCTurner"}, "path": "docs/reference/modules/indices/recovery.asciidoc", "diffHunk": "@@ -48,3 +48,11 @@ sent in parallel for each recovery. Defaults to `2`.\n +\n You can increase the value of this setting when the recovery of a single shard\n is not reaching the traffic limit set by `indices.recovery.max_bytes_per_sec`.\n+\n+`indices.recovery.max_concurrent_operation_chunks`::\n+(<<cluster-update-settings,Dynamic>>, Expert) Number of operation chunk requests\n+sent in parallel for each recovery. Defaults to `1`.\n++\n+Increasing the value of this setting with care as it can cause recoveries to consume", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ3MDcwNA=="}, "originalCommit": {"oid": "f0c2d713e69f2616c5b81749f03b8d676f411552"}, "originalPosition": 9}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e4f1fbfed406b007d3cc24b18781ce1b36607120", "author": {"user": {"login": "dnhatn", "name": "Nhat Nguyen"}}, "url": "https://github.com/elastic/elasticsearch/commit/e4f1fbfed406b007d3cc24b18781ce1b36607120", "committedDate": "2020-07-07T14:36:48Z", "message": "rewording"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a7f1df334af59e13dc663aae27318b60de500329", "author": {"user": {"login": "dnhatn", "name": "Nhat Nguyen"}}, "url": "https://github.com/elastic/elasticsearch/commit/a7f1df334af59e13dc663aae27318b60de500329", "committedDate": "2020-07-07T14:44:41Z", "message": "rewording"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "50c13f7ffd58174f189d0b1ca54dabf7eebb493d", "author": {"user": {"login": "dnhatn", "name": "Nhat Nguyen"}}, "url": "https://github.com/elastic/elasticsearch/commit/50c13f7ffd58174f189d0b1ca54dabf7eebb493d", "committedDate": "2020-07-07T14:45:03Z", "message": "Merge branch 'master' into send-ops-concurrently"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0MDMyODQ4", "url": "https://github.com/elastic/elasticsearch/pull/58018#pullrequestreview-444032848", "createdAt": "2020-07-07T15:58:51Z", "commit": {"oid": "50c13f7ffd58174f189d0b1ca54dabf7eebb493d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ef09c18745423d5c5c976ca1bc565380df400a88", "author": {"user": {"login": "dnhatn", "name": "Nhat Nguyen"}}, "url": "https://github.com/elastic/elasticsearch/commit/ef09c18745423d5c5c976ca1bc565380df400a88", "committedDate": "2020-07-07T16:33:48Z", "message": "fix test after removing uid from translog operation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ff7e57b3326f914ee65b5f6761162cccee9ce2ef", "author": {"user": {"login": "dnhatn", "name": "Nhat Nguyen"}}, "url": "https://github.com/elastic/elasticsearch/commit/ff7e57b3326f914ee65b5f6761162cccee9ce2ef", "committedDate": "2020-07-07T20:50:07Z", "message": "Merge branch 'master' into send-ops-concurrently"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 617, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}