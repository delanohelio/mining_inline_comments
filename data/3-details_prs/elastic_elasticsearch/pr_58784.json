{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQyMjkwMTUy", "number": 58784, "title": "Disallow mapping updates for doc ingestion privileges", "bodyText": "The create_doc, create, write and index privileges lose the Put Mapping allowed action in the next major release.\nCreate_doc, create and index also lose the Auto Put Mapping allowed action (mapping updates generated internally from templates).\nIn order to maintain the bwc in the 7.x releases, the above privileges will still allow the Put and Auto Put Mapping actions, but only when the \"index\" entity is an alias or a concrete index, but not a data stream or a backing index of a data stream.", "createdAt": "2020-06-30T20:58:38Z", "url": "https://github.com/elastic/elasticsearch/pull/58784", "merged": true, "mergeCommit": {"oid": "dd99bef666dd02714c09f5c56bea49395a34c680"}, "closed": true, "closedAt": "2020-07-14T18:45:03Z", "author": {"login": "albertzaharovits"}, "timelineItems": {"totalCount": 52, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcwb70GgH2gAyNDQyMjkwMTUyOmQ2MjI1MGRiYzZlMjQwM2M2MDQ0MjliZWNmZGIyNDgyNzM3NmExYTY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc05H72AH2gAyNDQyMjkwMTUyOmYzZmVjMzNjZGJiZDY4NjQxNDJlZmY3NWMwMzdiNTlkMjczYmY2YTM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "d62250dbc6e2403c604429becfdb24827376a1a6", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/d62250dbc6e2403c604429becfdb24827376a1a6", "committedDate": "2020-06-30T20:47:13Z", "message": "Done maybe"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "547faa3406862631093fea83f00f8acaea6bf177", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/547faa3406862631093fea83f00f8acaea6bf177", "committedDate": "2020-06-30T20:50:54Z", "message": "Merge branch 'master' into remove_put_mapping_priv"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwNTY3MDIx", "url": "https://github.com/elastic/elasticsearch/pull/58784#pullrequestreview-440567021", "createdAt": "2020-07-01T06:02:23Z", "commit": {"oid": "547faa3406862631093fea83f00f8acaea6bf177"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwNjowMjoyNFrOGrX4QA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwNjoxMzo0NFrOGrYGWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODEzMzE4NA==", "bodyText": "It's only loosely to this change, but I think we're long overdue on javadocs for these methods. I struggle to remember what they're supposed to do, and they're just getting more complex.", "url": "https://github.com/elastic/elasticsearch/pull/58784#discussion_r448133184", "createdAt": "2020-07-01T06:02:24Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "diffHunk": "@@ -46,14 +47,29 @@\n \n     public static final IndicesPermission NONE = new IndicesPermission();\n \n-    private final ConcurrentMap<String, Predicate<String>> allowedIndicesMatchersForAction = new ConcurrentHashMap<>();\n+    private final ConcurrentMap<String, Predicate<IndexAbstraction>> allowedIndicesMatchersForAction = new ConcurrentHashMap<>();\n \n     private final Group[] groups;\n \n     public IndicesPermission(Group... groups) {\n         this.groups = groups;\n     }\n \n+    public static Predicate<String> indexMatcher(Collection<String> ordinaryIndices, Collection<String> restrictedIndices) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "547faa3406862631093fea83f00f8acaea6bf177"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODEzNTIzMQ==", "bodyText": "It's a minor thing, but I have a mild dislike of that repeated isRestricted logic.\nWe could do something like:\n    final Predicate<String> namePredicate;\n    if (ordinaryIndices.isEmpty()) {\n        namePredicate = indexMatcher(restrictedIndices);\n    } else {\n        namePredicate = indexMatcher(ordinaryIndices)\n                .and(index -> false == RestrictedIndicesNames.isRestricted(index));\n        if (restrictedIndices.isEmpty() == false) {\n            namePredicate = indexMatcher(restrictedIndices).or(namePredicate);\n        }\n    }", "url": "https://github.com/elastic/elasticsearch/pull/58784#discussion_r448135231", "createdAt": "2020-07-01T06:09:06Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "diffHunk": "@@ -46,14 +47,29 @@\n \n     public static final IndicesPermission NONE = new IndicesPermission();\n \n-    private final ConcurrentMap<String, Predicate<String>> allowedIndicesMatchersForAction = new ConcurrentHashMap<>();\n+    private final ConcurrentMap<String, Predicate<IndexAbstraction>> allowedIndicesMatchersForAction = new ConcurrentHashMap<>();\n \n     private final Group[] groups;\n \n     public IndicesPermission(Group... groups) {\n         this.groups = groups;\n     }\n \n+    public static Predicate<String> indexMatcher(Collection<String> ordinaryIndices, Collection<String> restrictedIndices) {\n+        final Predicate<String> namePredicate;\n+        if (restrictedIndices.isEmpty()) {\n+            namePredicate = indexMatcher(ordinaryIndices)\n+                    .and(index -> false == RestrictedIndicesNames.isRestricted(index));\n+        } else if (ordinaryIndices.isEmpty()) {\n+            namePredicate = indexMatcher(restrictedIndices);\n+        } else {\n+            namePredicate = indexMatcher(restrictedIndices)\n+                    .or(indexMatcher(ordinaryIndices)\n+                            .and(index -> false == RestrictedIndicesNames.isRestricted(index)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "547faa3406862631093fea83f00f8acaea6bf177"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODEzNTczNA==", "bodyText": "I think we'll need AutoPutMapping too.", "url": "https://github.com/elastic/elasticsearch/pull/58784#discussion_r448135734", "createdAt": "2020-07-01T06:10:33Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "diffHunk": "@@ -276,6 +294,14 @@ private boolean isConcreteRestrictedIndex(String indexPattern) {\n         return RestrictedIndicesNames.isRestricted(indexPattern);\n     }\n \n+    private static boolean authorizeMappingUpdateBwcSpecialCase(Group group, String action) {\n+        return action.equals(PutMappingAction.NAME) ||", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "547faa3406862631093fea83f00f8acaea6bf177"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODEzNjc5NQ==", "bodyText": "My plan here was not to allow AutoPutMapping either, and force it to be a separate privilege (but that could be a followup).", "url": "https://github.com/elastic/elasticsearch/pull/58784#discussion_r448136795", "createdAt": "2020-07-01T06:13:44Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/privilege/IndexPrivilege.java", "diffHunk": "@@ -49,14 +49,13 @@\n     private static final Automaton READ_CROSS_CLUSTER_AUTOMATON = patterns(\"internal:transport/proxy/indices:data/read/*\",\n             ClusterSearchShardsAction.NAME);\n     private static final Automaton CREATE_AUTOMATON = patterns(\"indices:data/write/index*\", \"indices:data/write/bulk*\",\n-            PutMappingAction.NAME, AutoPutMappingAction.NAME);\n+            AutoPutMappingAction.NAME);\n     private static final Automaton CREATE_DOC_AUTOMATON = patterns(\"indices:data/write/index\", \"indices:data/write/index[*\",\n-        \"indices:data/write/index:op_type/create\", \"indices:data/write/bulk*\", PutMappingAction.NAME, AutoPutMappingAction.NAME);\n+        \"indices:data/write/index:op_type/create\", \"indices:data/write/bulk*\", AutoPutMappingAction.NAME);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "547faa3406862631093fea83f00f8acaea6bf177"}, "originalPosition": 8}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwNTczMjU3", "url": "https://github.com/elastic/elasticsearch/pull/58784#pullrequestreview-440573257", "createdAt": "2020-07-01T06:17:43Z", "commit": {"oid": "547faa3406862631093fea83f00f8acaea6bf177"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwNjoxNzo0M1rOGrYL5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwNjoxNzo0M1rOGrYL5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODEzODIxNA==", "bodyText": "We'll also need to think about how to write a deprecation warning if this BWC path gets used, but it's complex because we only want to do that if there isn't another Group that grants explicit mapping update access.", "url": "https://github.com/elastic/elasticsearch/pull/58784#discussion_r448138214", "createdAt": "2020-07-01T06:17:43Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "diffHunk": "@@ -276,6 +294,14 @@ private boolean isConcreteRestrictedIndex(String indexPattern) {\n         return RestrictedIndicesNames.isRestricted(indexPattern);\n     }\n \n+    private static boolean authorizeMappingUpdateBwcSpecialCase(Group group, String action) {\n+        return action.equals(PutMappingAction.NAME) ||\n+                (group.privilege().name().containsAll(IndexPrivilege.CREATE_DOC.name()) ||\n+                        group.privilege().name().containsAll(IndexPrivilege.CREATE.name()) ||\n+                        group.privilege().name().containsAll(IndexPrivilege.INDEX.name()) ||\n+                        group.privilege().name().containsAll(IndexPrivilege.WRITE.name()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "547faa3406862631093fea83f00f8acaea6bf177"}, "originalPosition": 77}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9dce3fcd44483bd924dbb665d54e052637139f63", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/9dce3fcd44483bd924dbb665d54e052637139f63", "committedDate": "2020-07-06T18:49:59Z", "message": "Merge branch 'master' into remove_put_mapping_priv"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "00bbb0fd2767724445bc0b4b9ce4f55220c05a55", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/00bbb0fd2767724445bc0b4b9ce4f55220c05a55", "committedDate": "2020-07-06T19:40:46Z", "message": "Merge fallout"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f4fb1c790f0bcd957138b89ac9bd357c38fd75de", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/f4fb1c790f0bcd957138b89ac9bd357c38fd75de", "committedDate": "2020-07-06T19:58:38Z", "message": "Auto put mapping is also bwc supported"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzNTYxOTEx", "url": "https://github.com/elastic/elasticsearch/pull/58784#pullrequestreview-443561911", "createdAt": "2020-07-07T04:56:58Z", "commit": {"oid": "f4fb1c790f0bcd957138b89ac9bd357c38fd75de"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwNDo1Njo1OVrOGtvFwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwNDo1Njo1OVrOGtvFwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYxMDYyNg==", "bodyText": "Can we please retain the previous comments on this block of code?", "url": "https://github.com/elastic/elasticsearch/pull/58784#discussion_r450610626", "createdAt": "2020-07-07T04:56:59Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "diffHunk": "@@ -213,12 +230,13 @@ public Automaton allowedActionsMatcher(String index) {\n             }\n \n             for (Group group : groups) {\n-                // check for privilege granted directly on the requested index/alias\n-                if (group.check(action, indexOrAlias) ||\n-                    // check for privilege granted on parent data stream if a backing index\n-                    (indexAbstraction != null && indexAbstraction.getType() == IndexAbstraction.Type.CONCRETE_INDEX &&\n-                        indexAbstraction.getParentDataStream() != null &&\n-                        group.check(action, indexAbstraction.getParentDataStream().getName()))) {\n+                boolean indexCheck = group.checkIndex(indexOrAlias) ||\n+                        (indexAbstraction != null && indexAbstraction.getType() == IndexAbstraction.Type.CONCRETE_INDEX &&\n+                                indexAbstraction.getParentDataStream() != null &&\n+                                group.checkIndex(indexAbstraction.getParentDataStream().getName()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4fb1c790f0bcd957138b89ac9bd357c38fd75de"}, "originalPosition": 71}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzNTYzMDQ4", "url": "https://github.com/elastic/elasticsearch/pull/58784#pullrequestreview-443563048", "createdAt": "2020-07-07T05:00:43Z", "commit": {"oid": "f4fb1c790f0bcd957138b89ac9bd357c38fd75de"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwNTowMDo0M1rOGtvJuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwNTowMDo0M1rOGtvJuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYxMTY0Mw==", "bodyText": "Nit: I'd simply the name to be just authorizeMappingUpdateBwc.", "url": "https://github.com/elastic/elasticsearch/pull/58784#discussion_r450611643", "createdAt": "2020-07-07T05:00:43Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "diffHunk": "@@ -281,6 +299,14 @@ private boolean isConcreteRestrictedIndex(String indexPattern) {\n         return RestrictedIndicesNames.isRestricted(indexPattern);\n     }\n \n+    private static boolean authorizeMappingUpdateBwcSpecialCase(Group group, String action) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4fb1c790f0bcd957138b89ac9bd357c38fd75de"}, "originalPosition": 82}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac0966d07d944325a93f985d65dee696fbcbe68e", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/ac0966d07d944325a93f985d65dee696fbcbe68e", "committedDate": "2020-07-07T10:45:41Z", "message": "IndicesPermission"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "63e7adecbd133dcd7aafc1859196988b54356aba", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/63e7adecbd133dcd7aafc1859196988b54356aba", "committedDate": "2020-07-07T11:13:02Z", "message": "WIP"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "905e4583cd14504881055d93507a4113b7d2f437", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/905e4583cd14504881055d93507a4113b7d2f437", "committedDate": "2020-07-07T12:34:49Z", "message": "Maybeee?"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e2dc3f9a04868e0fe79b135087ab49b455260e9f", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/e2dc3f9a04868e0fe79b135087ab49b455260e9f", "committedDate": "2020-07-07T12:45:00Z", "message": "authorizeMappingUpdateBwcSpecialCase"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9a5ff34c149f69f9a51dbaab60cacd357d7c8724", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/9a5ff34c149f69f9a51dbaab60cacd357d7c8724", "committedDate": "2020-07-07T12:46:02Z", "message": "Merge branch 'master' into remove_put_mapping_priv"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ec965111222ad7525b1cba40f95c3ff93b9eb74b", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/ec965111222ad7525b1cba40f95c3ff93b9eb74b", "committedDate": "2020-07-07T14:35:32Z", "message": "ReservedRolesStoreTests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e155998b779139e8bf4e2425ddedbeab175ef189", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/e155998b779139e8bf4e2425ddedbeab175ef189", "committedDate": "2020-07-07T14:36:02Z", "message": "Merge branch 'master' into remove_put_mapping_priv"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "04f95a97c9424d42840e8d0ecca8bcfc7c41ee0a", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/04f95a97c9424d42840e8d0ecca8bcfc7c41ee0a", "committedDate": "2020-07-07T15:12:07Z", "message": "WIP adjust tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a99f9f0bd5bd7cb9a67008f56f8f8974eb9f6026", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/a99f9f0bd5bd7cb9a67008f56f8f8974eb9f6026", "committedDate": "2020-07-07T16:03:49Z", "message": "Existing tests compiled"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0e7efed80242f2d46cb9bdcc1aec6219776d09fe", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/0e7efed80242f2d46cb9bdcc1aec6219776d09fe", "committedDate": "2020-07-07T16:06:22Z", "message": "Merge branch 'master' into remove_put_mapping_priv"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4dfe44a9936f99b633aad97d1f90f41741d7418c", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/4dfe44a9936f99b633aad97d1f90f41741d7418c", "committedDate": "2020-07-07T16:13:00Z", "message": "Checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "66e244ddc088c60bd94712eecb8a0acfd8be882a", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/66e244ddc088c60bd94712eecb8a0acfd8be882a", "committedDate": "2020-07-07T16:25:13Z", "message": "Checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2d34b462f3cfb530c05d1e8b81ce33d6c6ff7b4b", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/2d34b462f3cfb530c05d1e8b81ce33d6c6ff7b4b", "committedDate": "2020-07-07T18:05:07Z", "message": "Merge branch 'master' into remove_put_mapping_priv"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "44e0517017c37fdc6cd0ba1a8ba0b812e3fd71ae", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/44e0517017c37fdc6cd0ba1a8ba0b812e3fd71ae", "committedDate": "2020-07-08T05:13:07Z", "message": "Merge branch 'master' into remove_put_mapping_priv"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3c53f415640f477d1be56a23d7f4f779ba852652", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/3c53f415640f477d1be56a23d7f4f779ba852652", "committedDate": "2020-07-08T10:30:50Z", "message": "XPackRestIT"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "008ec5abe61d1769ba1b9bb4d7bc08df30139b46", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/008ec5abe61d1769ba1b9bb4d7bc08df30139b46", "committedDate": "2020-07-08T11:18:04Z", "message": "index -> write for ml yaml tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aa62846895c2742025df1ea0abec805b946d6f5f", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/aa62846895c2742025df1ea0abec805b946d6f5f", "committedDate": "2020-07-08T11:34:27Z", "message": "SmokeTestSecurityWithMustacheClientYamlTestSuiteIT"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c09a20b67ff3d811d729c7f315d745d48c78b25a", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/c09a20b67ff3d811d729c7f315d745d48c78b25a", "committedDate": "2020-07-08T11:35:57Z", "message": "Merge branch 'master' into remove_put_mapping_priv"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NjYwNTM0", "url": "https://github.com/elastic/elasticsearch/pull/58784#pullrequestreview-444660534", "createdAt": "2020-07-08T11:40:43Z", "commit": {"oid": "c09a20b67ff3d811d729c7f315d745d48c78b25a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxMTo0MDo0M1rOGukAUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxMTo0MDo0M1rOGukAUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQ3NzU4NQ==", "bodyText": "Uninteresting changes.", "url": "https://github.com/elastic/elasticsearch/pull/58784#discussion_r451477585", "createdAt": "2020-07-08T11:40:43Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/security/authz/store/ReservedRolesStoreTests.java", "diffHunk": "@@ -189,6 +189,7 @@\n import static org.hamcrest.Matchers.is;\n import static org.hamcrest.Matchers.not;\n import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c09a20b67ff3d811d729c7f315d745d48c78b25a"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3ec62d321533b7c6c35e12a0dcc029b7a0035794", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/3ec62d321533b7c6c35e12a0dcc029b7a0035794", "committedDate": "2020-07-08T17:14:02Z", "message": "Data stream tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "774a423cf759bbca61fb8653b167135a3b92e2be", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/774a423cf759bbca61fb8653b167135a3b92e2be", "committedDate": "2020-07-08T17:14:43Z", "message": "Merge branch 'master' into remove_put_mapping_priv"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4c6383c099b519217e194ca4babe153fcb26b868", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/4c6383c099b519217e194ca4babe153fcb26b868", "committedDate": "2020-07-08T18:33:37Z", "message": "IndexPrivilege tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "75bb67ec62b1070ec65ad03890087a6d6daa53ba", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/75bb67ec62b1070ec65ad03890087a6d6daa53ba", "committedDate": "2020-07-08T18:42:20Z", "message": "Nit"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b114c134a48a910cd2888df668726a9f42f1fc6b", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/b114c134a48a910cd2888df668726a9f42f1fc6b", "committedDate": "2020-07-08T19:27:37Z", "message": "IndicesMatcher action"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4a2394c672cb3ffb1a3695d91cbb7d6e6d29a4a4", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/4a2394c672cb3ffb1a3695d91cbb7d6e6d29a4a4", "committedDate": "2020-07-08T21:14:11Z", "message": "Almost"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e08624a8fd87eab2394bfea54248f3f1a8a1fe3e", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/e08624a8fd87eab2394bfea54248f3f1a8a1fe3e", "committedDate": "2020-07-08T22:23:18Z", "message": "Done testing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4071e953d67142f123159f44f4435d93fb5b812a", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/4071e953d67142f123159f44f4435d93fb5b812a", "committedDate": "2020-07-08T22:37:48Z", "message": "Review"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2OTI4NjAy", "url": "https://github.com/elastic/elasticsearch/pull/58784#pullrequestreview-446928602", "createdAt": "2020-07-13T00:57:50Z", "commit": {"oid": "4071e953d67142f123159f44f4435d93fb5b812a"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QwMDo1Nzo1MFrOGwYjPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QwNDowMzoxOFrOGwawBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM4NzA3MA==", "bodyText": "Nit: I am aware this is a carry-over from existing code, but could we please change the type from ConcurrentMap to just Map, i.e. Map<String, Predicate<IndexAbstraction>>?", "url": "https://github.com/elastic/elasticsearch/pull/58784#discussion_r453387070", "createdAt": "2020-07-13T00:57:50Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "diffHunk": "@@ -44,16 +47,38 @@\n  */\n public final class IndicesPermission {\n \n+    private static final DeprecationLogger deprecationLogger = DeprecationLogger.getLogger(IndicesPermission.class);\n+\n     public static final IndicesPermission NONE = new IndicesPermission();\n \n-    private final ConcurrentMap<String, Predicate<String>> allowedIndicesMatchersForAction = new ConcurrentHashMap<>();\n+    private static final Set<String> privilegeNameSetBwcAllowMappingUpdate = Set.of(\"create\", \"create_doc\", \"index\", \"write\");\n+\n+    private final ConcurrentMap<String, Predicate<IndexAbstraction>> allowedIndicesMatchersForAction = new ConcurrentHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4071e953d67142f123159f44f4435d93fb5b812a"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQxMDA3NA==", "bodyText": "I'd prefer to write these boolean expressions in a more boolean way, i.e.:\ngranted = granted || actionCheck;\nbwcGrantMappingUpdate = bwcGrantMappingUpdate || bwcMappingActionCheck;\nA minor benefit is that they short-circuit.\nAlso might wanna consider pulling it up into the above if check since the values do not change unless actionCheck or bwcMappingActionCheck is true.", "url": "https://github.com/elastic/elasticsearch/pull/58784#discussion_r453410074", "createdAt": "2020-07-13T03:00:24Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "diffHunk": "@@ -202,43 +229,83 @@ public Automaton allowedActionsMatcher(String index) {\n         Map<String, DocumentLevelPermissions> roleQueriesByIndex = new HashMap<>();\n         Map<String, Boolean> grantedBuilder = new HashMap<>();\n \n+        final boolean isMappingUpdateAction = action.equals(PutMappingAction.NAME) || action.equals(AutoPutMappingAction.NAME);\n+\n         for (String indexOrAlias : requestedIndicesOrAliases) {\n-            boolean granted = false;\n-            Set<String> concreteIndices = new HashSet<>();\n-            IndexAbstraction indexAbstraction = lookup.get(indexOrAlias);\n+            final boolean isBackingIndex;\n+            final boolean isDataStream;\n+            final Set<String> concreteIndices = new HashSet<>();\n+            final IndexAbstraction indexAbstraction = lookup.get(indexOrAlias);\n             if (indexAbstraction != null) {\n                 for (IndexMetadata indexMetadata : indexAbstraction.getIndices()) {\n                     concreteIndices.add(indexMetadata.getIndex().getName());\n                 }\n+                isBackingIndex = indexAbstraction.getType() == IndexAbstraction.Type.CONCRETE_INDEX &&\n+                        indexAbstraction.getParentDataStream() != null;\n+                isDataStream = indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM;\n+            } else {\n+                isBackingIndex = isDataStream = false;\n             }\n \n+            // true if ANY group covers the given index AND the given action\n+            boolean granted = false;\n+            // true if ANY group, which contains certain ingest privileges, covers the given index AND the action is a mapping update for\n+            // an index or an alias (but not for a data stream)\n+            boolean bwcGrantMappingUpdate = false;\n+            final List<Runnable> bwcDeprecationLogActions = new ArrayList<>();\n+\n             for (Group group : groups) {\n-                // check for privilege granted directly on the requested index/alias\n-                if (group.check(action, indexOrAlias) ||\n-                    // check for privilege granted on parent data stream if a backing index\n-                    (indexAbstraction != null && indexAbstraction.getType() == IndexAbstraction.Type.CONCRETE_INDEX &&\n-                        indexAbstraction.getParentDataStream() != null &&\n-                        group.check(action, indexAbstraction.getParentDataStream().getName()))) {\n-                    granted = true;\n-                    for (String index : concreteIndices) {\n-                        Set<FieldPermissions> fieldPermissions = fieldPermissionsByIndex.computeIfAbsent(index, (k) -> new HashSet<>());\n-                        fieldPermissionsByIndex.put(indexOrAlias, fieldPermissions);\n-                        fieldPermissions.add(group.getFieldPermissions());\n-                        DocumentLevelPermissions permissions =\n-                                roleQueriesByIndex.computeIfAbsent(index, (k) -> new DocumentLevelPermissions());\n-                        roleQueriesByIndex.putIfAbsent(indexOrAlias, permissions);\n-                        if (group.hasQuery()) {\n-                            permissions.addAll(group.getQuery());\n-                        } else {\n-                            // if more than one permission matches for a concrete index here and if\n-                            // a single permission doesn't have a role query then DLS will not be\n-                            // applied even when other permissions do have a role query\n-                            permissions.setAllowAll(true);\n+                // the group covers the given index OR the given index is a backing index and the group covers the parent data stream\n+                final boolean indexCheck = group.checkIndex(indexOrAlias) ||\n+                        (isBackingIndex && group.checkIndex(indexAbstraction.getParentDataStream().getName()));\n+                if (indexCheck) {\n+                    boolean actionCheck = group.checkAction(action);\n+                    // mapping updates are allowed for certain privileges on indices and aliases (but not on data streams),\n+                    // outside of the privilege definition\n+                    boolean bwcMappingActionCheck = isMappingUpdateAction && false == isDataStream && false == isBackingIndex &&\n+                            group.privilege().name().stream().anyMatch(privilegeNameSetBwcAllowMappingUpdate::contains);\n+                    if (actionCheck || bwcMappingActionCheck) {\n+                        // propagate DLS and FLS permissions over the concrete indices\n+                        for (String index : concreteIndices) {\n+                            Set<FieldPermissions> fieldPermissions = fieldPermissionsByIndex.computeIfAbsent(index, (k) -> new HashSet<>());\n+                            fieldPermissionsByIndex.put(indexOrAlias, fieldPermissions);\n+                            fieldPermissions.add(group.getFieldPermissions());\n+                            DocumentLevelPermissions permissions =\n+                                    roleQueriesByIndex.computeIfAbsent(index, (k) -> new DocumentLevelPermissions());\n+                            roleQueriesByIndex.putIfAbsent(indexOrAlias, permissions);\n+                            if (group.hasQuery()) {\n+                                permissions.addAll(group.getQuery());\n+                            } else {\n+                                // if more than one permission matches for a concrete index here and if\n+                                // a single permission doesn't have a role query then DLS will not be\n+                                // applied even when other permissions do have a role query\n+                                permissions.setAllowAll(true);\n+                            }\n+                        }\n+                    }\n+                    granted |= actionCheck;\n+                    bwcGrantMappingUpdate |= bwcMappingActionCheck;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4071e953d67142f123159f44f4435d93fb5b812a"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQxODE0MA==", "bodyText": "Nit: This check is done three times times in different places. I'd personally prefer to extract it into a method.", "url": "https://github.com/elastic/elasticsearch/pull/58784#discussion_r453418140", "createdAt": "2020-07-13T03:39:19Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "diffHunk": "@@ -349,30 +415,39 @@ public static Automaton buildIndexMatcherAutomaton(boolean allowRestrictedIndice\n             }\n         }\n \n-        private static Predicate<String> buildIndexMatcherPredicateForAction(String action, Group... groups) {\n+        private static Predicate<IndexAbstraction> buildIndexMatcherPredicateForAction(String action, Group... groups) {\n             final Set<String> ordinaryIndices = new HashSet<>();\n             final Set<String> restrictedIndices = new HashSet<>();\n+            final Set<String> grantMappingUpdatesOnIndices = new HashSet<>();\n+            final Set<String> grantMappingUpdatesOnRestrictedIndices = new HashSet<>();\n+            final boolean isMappingUpdateAction = action.equals(PutMappingAction.NAME) || action.equals(AutoPutMappingAction.NAME);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4071e953d67142f123159f44f4435d93fb5b812a"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQxOTE0OA==", "bodyText": "Similarly, this check is done three times. I'd prefer it to be a method, e.g. grantBwcMappingUpdate(group)", "url": "https://github.com/elastic/elasticsearch/pull/58784#discussion_r453419148", "createdAt": "2020-07-13T03:44:12Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "diffHunk": "@@ -349,30 +415,39 @@ public static Automaton buildIndexMatcherAutomaton(boolean allowRestrictedIndice\n             }\n         }\n \n-        private static Predicate<String> buildIndexMatcherPredicateForAction(String action, Group... groups) {\n+        private static Predicate<IndexAbstraction> buildIndexMatcherPredicateForAction(String action, Group... groups) {\n             final Set<String> ordinaryIndices = new HashSet<>();\n             final Set<String> restrictedIndices = new HashSet<>();\n+            final Set<String> grantMappingUpdatesOnIndices = new HashSet<>();\n+            final Set<String> grantMappingUpdatesOnRestrictedIndices = new HashSet<>();\n+            final boolean isMappingUpdateAction = action.equals(PutMappingAction.NAME) || action.equals(AutoPutMappingAction.NAME);\n             for (final Group group : groups) {\n                 if (group.actionMatcher.test(action)) {\n                     if (group.allowRestrictedIndices) {\n                         restrictedIndices.addAll(Arrays.asList(group.indices()));\n                     } else {\n                         ordinaryIndices.addAll(Arrays.asList(group.indices()));\n                     }\n+                } else if (isMappingUpdateAction &&\n+                        group.privilege().name().stream().anyMatch(privilegeNameSetBwcAllowMappingUpdate::contains)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4071e953d67142f123159f44f4435d93fb5b812a"}, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQxOTM5NQ==", "bodyText": "I wonder whether it would be better to display a single deprecation log per indexOrAlias, e.g. ... is granted by [privA, privB] ....\nAlso this if block can be placed inside the previous if (actionCheck || bwcMappingActionCheck) so its own if check can become just if (false == actionCheck).", "url": "https://github.com/elastic/elasticsearch/pull/58784#discussion_r453419395", "createdAt": "2020-07-13T03:45:07Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "diffHunk": "@@ -202,43 +229,83 @@ public Automaton allowedActionsMatcher(String index) {\n         Map<String, DocumentLevelPermissions> roleQueriesByIndex = new HashMap<>();\n         Map<String, Boolean> grantedBuilder = new HashMap<>();\n \n+        final boolean isMappingUpdateAction = action.equals(PutMappingAction.NAME) || action.equals(AutoPutMappingAction.NAME);\n+\n         for (String indexOrAlias : requestedIndicesOrAliases) {\n-            boolean granted = false;\n-            Set<String> concreteIndices = new HashSet<>();\n-            IndexAbstraction indexAbstraction = lookup.get(indexOrAlias);\n+            final boolean isBackingIndex;\n+            final boolean isDataStream;\n+            final Set<String> concreteIndices = new HashSet<>();\n+            final IndexAbstraction indexAbstraction = lookup.get(indexOrAlias);\n             if (indexAbstraction != null) {\n                 for (IndexMetadata indexMetadata : indexAbstraction.getIndices()) {\n                     concreteIndices.add(indexMetadata.getIndex().getName());\n                 }\n+                isBackingIndex = indexAbstraction.getType() == IndexAbstraction.Type.CONCRETE_INDEX &&\n+                        indexAbstraction.getParentDataStream() != null;\n+                isDataStream = indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM;\n+            } else {\n+                isBackingIndex = isDataStream = false;\n             }\n \n+            // true if ANY group covers the given index AND the given action\n+            boolean granted = false;\n+            // true if ANY group, which contains certain ingest privileges, covers the given index AND the action is a mapping update for\n+            // an index or an alias (but not for a data stream)\n+            boolean bwcGrantMappingUpdate = false;\n+            final List<Runnable> bwcDeprecationLogActions = new ArrayList<>();\n+\n             for (Group group : groups) {\n-                // check for privilege granted directly on the requested index/alias\n-                if (group.check(action, indexOrAlias) ||\n-                    // check for privilege granted on parent data stream if a backing index\n-                    (indexAbstraction != null && indexAbstraction.getType() == IndexAbstraction.Type.CONCRETE_INDEX &&\n-                        indexAbstraction.getParentDataStream() != null &&\n-                        group.check(action, indexAbstraction.getParentDataStream().getName()))) {\n-                    granted = true;\n-                    for (String index : concreteIndices) {\n-                        Set<FieldPermissions> fieldPermissions = fieldPermissionsByIndex.computeIfAbsent(index, (k) -> new HashSet<>());\n-                        fieldPermissionsByIndex.put(indexOrAlias, fieldPermissions);\n-                        fieldPermissions.add(group.getFieldPermissions());\n-                        DocumentLevelPermissions permissions =\n-                                roleQueriesByIndex.computeIfAbsent(index, (k) -> new DocumentLevelPermissions());\n-                        roleQueriesByIndex.putIfAbsent(indexOrAlias, permissions);\n-                        if (group.hasQuery()) {\n-                            permissions.addAll(group.getQuery());\n-                        } else {\n-                            // if more than one permission matches for a concrete index here and if\n-                            // a single permission doesn't have a role query then DLS will not be\n-                            // applied even when other permissions do have a role query\n-                            permissions.setAllowAll(true);\n+                // the group covers the given index OR the given index is a backing index and the group covers the parent data stream\n+                final boolean indexCheck = group.checkIndex(indexOrAlias) ||\n+                        (isBackingIndex && group.checkIndex(indexAbstraction.getParentDataStream().getName()));\n+                if (indexCheck) {\n+                    boolean actionCheck = group.checkAction(action);\n+                    // mapping updates are allowed for certain privileges on indices and aliases (but not on data streams),\n+                    // outside of the privilege definition\n+                    boolean bwcMappingActionCheck = isMappingUpdateAction && false == isDataStream && false == isBackingIndex &&\n+                            group.privilege().name().stream().anyMatch(privilegeNameSetBwcAllowMappingUpdate::contains);\n+                    if (actionCheck || bwcMappingActionCheck) {\n+                        // propagate DLS and FLS permissions over the concrete indices\n+                        for (String index : concreteIndices) {\n+                            Set<FieldPermissions> fieldPermissions = fieldPermissionsByIndex.computeIfAbsent(index, (k) -> new HashSet<>());\n+                            fieldPermissionsByIndex.put(indexOrAlias, fieldPermissions);\n+                            fieldPermissions.add(group.getFieldPermissions());\n+                            DocumentLevelPermissions permissions =\n+                                    roleQueriesByIndex.computeIfAbsent(index, (k) -> new DocumentLevelPermissions());\n+                            roleQueriesByIndex.putIfAbsent(indexOrAlias, permissions);\n+                            if (group.hasQuery()) {\n+                                permissions.addAll(group.getQuery());\n+                            } else {\n+                                // if more than one permission matches for a concrete index here and if\n+                                // a single permission doesn't have a role query then DLS will not be\n+                                // applied even when other permissions do have a role query\n+                                permissions.setAllowAll(true);\n+                            }\n+                        }\n+                    }\n+                    granted |= actionCheck;\n+                    bwcGrantMappingUpdate |= bwcMappingActionCheck;\n+                    if (false == actionCheck && bwcMappingActionCheck) {\n+                        for (String privilegeName : group.privilege.name()) {\n+                            if (privilegeNameSetBwcAllowMappingUpdate.contains(privilegeName)) {\n+                                bwcDeprecationLogActions.add(() -> {\n+                                    deprecationLogger.deprecate(\"[\" + indexOrAlias + \"] mapping update for ingest privilege [\" +\n+                                            privilegeName + \"]\", \"the mapping update action [\" + action + \"] on the [\" +\n+                                            indexOrAlias + \"] index, is granted by the [\" + privilegeName + \"] privilege,\" +\n+                                            \" but the privilege has been tightened to not allow it in the next major release\");\n+                                });\n+                            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4071e953d67142f123159f44f4435d93fb5b812a"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQyMDA3Nw==", "bodyText": "I think this check can be added as a default method to IndexAbstraction itself.", "url": "https://github.com/elastic/elasticsearch/pull/58784#discussion_r453420077", "createdAt": "2020-07-13T03:48:18Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "diffHunk": "@@ -349,30 +415,39 @@ public static Automaton buildIndexMatcherAutomaton(boolean allowRestrictedIndice\n             }\n         }\n \n-        private static Predicate<String> buildIndexMatcherPredicateForAction(String action, Group... groups) {\n+        private static Predicate<IndexAbstraction> buildIndexMatcherPredicateForAction(String action, Group... groups) {\n             final Set<String> ordinaryIndices = new HashSet<>();\n             final Set<String> restrictedIndices = new HashSet<>();\n+            final Set<String> grantMappingUpdatesOnIndices = new HashSet<>();\n+            final Set<String> grantMappingUpdatesOnRestrictedIndices = new HashSet<>();\n+            final boolean isMappingUpdateAction = action.equals(PutMappingAction.NAME) || action.equals(AutoPutMappingAction.NAME);\n             for (final Group group : groups) {\n                 if (group.actionMatcher.test(action)) {\n                     if (group.allowRestrictedIndices) {\n                         restrictedIndices.addAll(Arrays.asList(group.indices()));\n                     } else {\n                         ordinaryIndices.addAll(Arrays.asList(group.indices()));\n                     }\n+                } else if (isMappingUpdateAction &&\n+                        group.privilege().name().stream().anyMatch(privilegeNameSetBwcAllowMappingUpdate::contains)) {\n+                    // special BWC case for certain privileges: allow put mapping on indices and aliases (but not on data streams), even if\n+                    // the privilege definition does not currently allow it\n+                    if (group.allowRestrictedIndices) {\n+                        grantMappingUpdatesOnRestrictedIndices.addAll(Arrays.asList(group.indices()));\n+                    } else {\n+                        grantMappingUpdatesOnIndices.addAll(Arrays.asList(group.indices()));\n+                    }\n                 }\n             }\n-            final Predicate<String> predicate;\n-            if (restrictedIndices.isEmpty()) {\n-                predicate = indexMatcher(ordinaryIndices)\n-                    .and(index -> false == RestrictedIndicesNames.isRestricted(index));\n-            } else if (ordinaryIndices.isEmpty()) {\n-                predicate = indexMatcher(restrictedIndices);\n-            } else {\n-                predicate = indexMatcher(restrictedIndices)\n-                    .or(indexMatcher(ordinaryIndices)\n-                         .and(index -> false == RestrictedIndicesNames.isRestricted(index)));\n-            }\n-            return predicate;\n+            final Predicate<String> namePredicate = indexMatcher(ordinaryIndices, restrictedIndices);\n+            final Predicate<String> bwcSpecialCaseNamePredicate = indexMatcher(grantMappingUpdatesOnIndices,\n+                    grantMappingUpdatesOnRestrictedIndices);\n+            return indexAbstraction -> {\n+                return namePredicate.test(indexAbstraction.getName()) ||\n+                        (indexAbstraction.getType() != IndexAbstraction.Type.DATA_STREAM &&\n+                                (indexAbstraction.getParentDataStream() == null) &&", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4071e953d67142f123159f44f4435d93fb5b812a"}, "originalPosition": 249}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQyMTUwOA==", "bodyText": "I think this can be optimised as\nboolean bwcMappingActionCheck = actionCheck ? false : isMappingUpdateAction && false == isDataStream && false == isBackingIndex &&\n        group.privilege().name().stream().anyMatch(privilegeNameSetBwcAllowMappingUpdate::contains);", "url": "https://github.com/elastic/elasticsearch/pull/58784#discussion_r453421508", "createdAt": "2020-07-13T03:55:27Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "diffHunk": "@@ -202,43 +229,83 @@ public Automaton allowedActionsMatcher(String index) {\n         Map<String, DocumentLevelPermissions> roleQueriesByIndex = new HashMap<>();\n         Map<String, Boolean> grantedBuilder = new HashMap<>();\n \n+        final boolean isMappingUpdateAction = action.equals(PutMappingAction.NAME) || action.equals(AutoPutMappingAction.NAME);\n+\n         for (String indexOrAlias : requestedIndicesOrAliases) {\n-            boolean granted = false;\n-            Set<String> concreteIndices = new HashSet<>();\n-            IndexAbstraction indexAbstraction = lookup.get(indexOrAlias);\n+            final boolean isBackingIndex;\n+            final boolean isDataStream;\n+            final Set<String> concreteIndices = new HashSet<>();\n+            final IndexAbstraction indexAbstraction = lookup.get(indexOrAlias);\n             if (indexAbstraction != null) {\n                 for (IndexMetadata indexMetadata : indexAbstraction.getIndices()) {\n                     concreteIndices.add(indexMetadata.getIndex().getName());\n                 }\n+                isBackingIndex = indexAbstraction.getType() == IndexAbstraction.Type.CONCRETE_INDEX &&\n+                        indexAbstraction.getParentDataStream() != null;\n+                isDataStream = indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM;\n+            } else {\n+                isBackingIndex = isDataStream = false;\n             }\n \n+            // true if ANY group covers the given index AND the given action\n+            boolean granted = false;\n+            // true if ANY group, which contains certain ingest privileges, covers the given index AND the action is a mapping update for\n+            // an index or an alias (but not for a data stream)\n+            boolean bwcGrantMappingUpdate = false;\n+            final List<Runnable> bwcDeprecationLogActions = new ArrayList<>();\n+\n             for (Group group : groups) {\n-                // check for privilege granted directly on the requested index/alias\n-                if (group.check(action, indexOrAlias) ||\n-                    // check for privilege granted on parent data stream if a backing index\n-                    (indexAbstraction != null && indexAbstraction.getType() == IndexAbstraction.Type.CONCRETE_INDEX &&\n-                        indexAbstraction.getParentDataStream() != null &&\n-                        group.check(action, indexAbstraction.getParentDataStream().getName()))) {\n-                    granted = true;\n-                    for (String index : concreteIndices) {\n-                        Set<FieldPermissions> fieldPermissions = fieldPermissionsByIndex.computeIfAbsent(index, (k) -> new HashSet<>());\n-                        fieldPermissionsByIndex.put(indexOrAlias, fieldPermissions);\n-                        fieldPermissions.add(group.getFieldPermissions());\n-                        DocumentLevelPermissions permissions =\n-                                roleQueriesByIndex.computeIfAbsent(index, (k) -> new DocumentLevelPermissions());\n-                        roleQueriesByIndex.putIfAbsent(indexOrAlias, permissions);\n-                        if (group.hasQuery()) {\n-                            permissions.addAll(group.getQuery());\n-                        } else {\n-                            // if more than one permission matches for a concrete index here and if\n-                            // a single permission doesn't have a role query then DLS will not be\n-                            // applied even when other permissions do have a role query\n-                            permissions.setAllowAll(true);\n+                // the group covers the given index OR the given index is a backing index and the group covers the parent data stream\n+                final boolean indexCheck = group.checkIndex(indexOrAlias) ||\n+                        (isBackingIndex && group.checkIndex(indexAbstraction.getParentDataStream().getName()));\n+                if (indexCheck) {\n+                    boolean actionCheck = group.checkAction(action);\n+                    // mapping updates are allowed for certain privileges on indices and aliases (but not on data streams),\n+                    // outside of the privilege definition\n+                    boolean bwcMappingActionCheck = isMappingUpdateAction && false == isDataStream && false == isBackingIndex &&\n+                            group.privilege().name().stream().anyMatch(privilegeNameSetBwcAllowMappingUpdate::contains);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4071e953d67142f123159f44f4435d93fb5b812a"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQyMzExMQ==", "bodyText": "Would it be possible to push this logic into Group#checkIndex, i.e. make it take a IndexAbstraction so that the logic is internalised?", "url": "https://github.com/elastic/elasticsearch/pull/58784#discussion_r453423111", "createdAt": "2020-07-13T04:03:18Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "diffHunk": "@@ -202,43 +229,83 @@ public Automaton allowedActionsMatcher(String index) {\n         Map<String, DocumentLevelPermissions> roleQueriesByIndex = new HashMap<>();\n         Map<String, Boolean> grantedBuilder = new HashMap<>();\n \n+        final boolean isMappingUpdateAction = action.equals(PutMappingAction.NAME) || action.equals(AutoPutMappingAction.NAME);\n+\n         for (String indexOrAlias : requestedIndicesOrAliases) {\n-            boolean granted = false;\n-            Set<String> concreteIndices = new HashSet<>();\n-            IndexAbstraction indexAbstraction = lookup.get(indexOrAlias);\n+            final boolean isBackingIndex;\n+            final boolean isDataStream;\n+            final Set<String> concreteIndices = new HashSet<>();\n+            final IndexAbstraction indexAbstraction = lookup.get(indexOrAlias);\n             if (indexAbstraction != null) {\n                 for (IndexMetadata indexMetadata : indexAbstraction.getIndices()) {\n                     concreteIndices.add(indexMetadata.getIndex().getName());\n                 }\n+                isBackingIndex = indexAbstraction.getType() == IndexAbstraction.Type.CONCRETE_INDEX &&\n+                        indexAbstraction.getParentDataStream() != null;\n+                isDataStream = indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM;\n+            } else {\n+                isBackingIndex = isDataStream = false;\n             }\n \n+            // true if ANY group covers the given index AND the given action\n+            boolean granted = false;\n+            // true if ANY group, which contains certain ingest privileges, covers the given index AND the action is a mapping update for\n+            // an index or an alias (but not for a data stream)\n+            boolean bwcGrantMappingUpdate = false;\n+            final List<Runnable> bwcDeprecationLogActions = new ArrayList<>();\n+\n             for (Group group : groups) {\n-                // check for privilege granted directly on the requested index/alias\n-                if (group.check(action, indexOrAlias) ||\n-                    // check for privilege granted on parent data stream if a backing index\n-                    (indexAbstraction != null && indexAbstraction.getType() == IndexAbstraction.Type.CONCRETE_INDEX &&\n-                        indexAbstraction.getParentDataStream() != null &&\n-                        group.check(action, indexAbstraction.getParentDataStream().getName()))) {\n-                    granted = true;\n-                    for (String index : concreteIndices) {\n-                        Set<FieldPermissions> fieldPermissions = fieldPermissionsByIndex.computeIfAbsent(index, (k) -> new HashSet<>());\n-                        fieldPermissionsByIndex.put(indexOrAlias, fieldPermissions);\n-                        fieldPermissions.add(group.getFieldPermissions());\n-                        DocumentLevelPermissions permissions =\n-                                roleQueriesByIndex.computeIfAbsent(index, (k) -> new DocumentLevelPermissions());\n-                        roleQueriesByIndex.putIfAbsent(indexOrAlias, permissions);\n-                        if (group.hasQuery()) {\n-                            permissions.addAll(group.getQuery());\n-                        } else {\n-                            // if more than one permission matches for a concrete index here and if\n-                            // a single permission doesn't have a role query then DLS will not be\n-                            // applied even when other permissions do have a role query\n-                            permissions.setAllowAll(true);\n+                // the group covers the given index OR the given index is a backing index and the group covers the parent data stream\n+                final boolean indexCheck = group.checkIndex(indexOrAlias) ||\n+                        (isBackingIndex && group.checkIndex(indexAbstraction.getParentDataStream().getName()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4071e953d67142f123159f44f4435d93fb5b812a"}, "originalPosition": 132}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e6bd53f255dad90b29a0cb3d68d630cc07fe1aff", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/e6bd53f255dad90b29a0cb3d68d630cc07fe1aff", "committedDate": "2020-07-13T10:44:26Z", "message": "Merge branch 'master' into remove_put_mapping_priv"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eb50c54af29c796c9b74bc5fae9d24b828a1388e", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/eb50c54af29c796c9b74bc5fae9d24b828a1388e", "committedDate": "2020-07-13T11:24:15Z", "message": "Merge fallout"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3MjA4MzYz", "url": "https://github.com/elastic/elasticsearch/pull/58784#pullrequestreview-447208363", "createdAt": "2020-07-13T12:35:22Z", "commit": {"oid": "eb50c54af29c796c9b74bc5fae9d24b828a1388e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3Mjc1MDE2", "url": "https://github.com/elastic/elasticsearch/pull/58784#pullrequestreview-447275016", "createdAt": "2020-07-13T13:56:30Z", "commit": {"oid": "eb50c54af29c796c9b74bc5fae9d24b828a1388e"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxMzo1NjozMFrOGwpuMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNDowNzoxOFrOGwqLoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY2ODQwMg==", "bodyText": "Nit, should be CAPS.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final Set<String> privilegeNameSetBwcAllowMappingUpdate = Set.of(\"create\", \"create_doc\", \"index\", \"write\");\n          \n          \n            \n                private static final Set<String> BWC_PRIVILEGE_NAMES_ALLOW_MAPPING_UPDATE = Set.of(\"create\", \"create_doc\", \"index\", \"write\");", "url": "https://github.com/elastic/elasticsearch/pull/58784#discussion_r453668402", "createdAt": "2020-07-13T13:56:30Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "diffHunk": "@@ -44,16 +47,38 @@\n  */\n public final class IndicesPermission {\n \n+    private static final DeprecationLogger deprecationLogger = DeprecationLogger.getLogger(IndicesPermission.class);\n+\n     public static final IndicesPermission NONE = new IndicesPermission();\n \n-    private final ConcurrentMap<String, Predicate<String>> allowedIndicesMatchersForAction = new ConcurrentHashMap<>();\n+    private static final Set<String> privilegeNameSetBwcAllowMappingUpdate = Set.of(\"create\", \"create_doc\", \"index\", \"write\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb50c54af29c796c9b74bc5fae9d24b828a1388e"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY2OTcyNg==", "bodyText": "Can we remove the duplication of detemining isMappingUpdateAction (here and 144)?\nExtract a method, or defined a Set<String> of action names?", "url": "https://github.com/elastic/elasticsearch/pull/58784#discussion_r453669726", "createdAt": "2020-07-13T13:58:20Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "diffHunk": "@@ -202,43 +229,83 @@ public Automaton allowedActionsMatcher(String index) {\n         Map<String, DocumentLevelPermissions> roleQueriesByIndex = new HashMap<>();\n         Map<String, Boolean> grantedBuilder = new HashMap<>();\n \n+        final boolean isMappingUpdateAction = action.equals(PutMappingAction.NAME) || action.equals(AutoPutMappingAction.NAME);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb50c54af29c796c9b74bc5fae9d24b828a1388e"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY3MzQyNQ==", "bodyText": "If indexAbstraction is null, then isBackingIndex is always false (lines 246-247)", "url": "https://github.com/elastic/elasticsearch/pull/58784#discussion_r453673425", "createdAt": "2020-07-13T14:03:24Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "diffHunk": "@@ -202,43 +229,83 @@ public Automaton allowedActionsMatcher(String index) {\n         Map<String, DocumentLevelPermissions> roleQueriesByIndex = new HashMap<>();\n         Map<String, Boolean> grantedBuilder = new HashMap<>();\n \n+        final boolean isMappingUpdateAction = action.equals(PutMappingAction.NAME) || action.equals(AutoPutMappingAction.NAME);\n+\n         for (String indexOrAlias : requestedIndicesOrAliases) {\n-            boolean granted = false;\n-            Set<String> concreteIndices = new HashSet<>();\n-            IndexAbstraction indexAbstraction = lookup.get(indexOrAlias);\n+            final boolean isBackingIndex;\n+            final boolean isDataStream;\n+            final Set<String> concreteIndices = new HashSet<>();\n+            final IndexAbstraction indexAbstraction = lookup.get(indexOrAlias);\n             if (indexAbstraction != null) {\n                 for (IndexMetadata indexMetadata : indexAbstraction.getIndices()) {\n                     concreteIndices.add(indexMetadata.getIndex().getName());\n                 }\n+                isBackingIndex = indexAbstraction.getType() == IndexAbstraction.Type.CONCRETE_INDEX &&\n+                        indexAbstraction.getParentDataStream() != null;\n+                isDataStream = indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM;\n+            } else {\n+                isBackingIndex = isDataStream = false;\n             }\n \n+            // true if ANY group covers the given index AND the given action\n+            boolean granted = false;\n+            // true if ANY group, which contains certain ingest privileges, covers the given index AND the action is a mapping update for\n+            // an index or an alias (but not for a data stream)\n+            boolean bwcGrantMappingUpdate = false;\n+            final List<Runnable> bwcDeprecationLogActions = new ArrayList<>();\n+\n             for (Group group : groups) {\n-                // check for privilege granted directly on the requested index/alias\n-                if (group.check(action, indexOrAlias) ||\n-                    // check for privilege granted on parent data stream if a backing index\n-                    (indexAbstraction != null && indexAbstraction.getType() == IndexAbstraction.Type.CONCRETE_INDEX &&\n-                        indexAbstraction.getParentDataStream() != null &&\n-                        group.check(action, indexAbstraction.getParentDataStream().getName()))) {\n-                    granted = true;\n-                    for (String index : concreteIndices) {\n-                        Set<FieldPermissions> fieldPermissions = fieldPermissionsByIndex.computeIfAbsent(index, (k) -> new HashSet<>());\n-                        fieldPermissionsByIndex.put(indexOrAlias, fieldPermissions);\n-                        fieldPermissions.add(group.getFieldPermissions());\n-                        DocumentLevelPermissions permissions =\n-                                roleQueriesByIndex.computeIfAbsent(index, (k) -> new DocumentLevelPermissions());\n-                        roleQueriesByIndex.putIfAbsent(indexOrAlias, permissions);\n-                        if (group.hasQuery()) {\n-                            permissions.addAll(group.getQuery());\n-                        } else {\n-                            // if more than one permission matches for a concrete index here and if\n-                            // a single permission doesn't have a role query then DLS will not be\n-                            // applied even when other permissions do have a role query\n-                            permissions.setAllowAll(true);\n+                // the group covers the given index OR the given index is a backing index and the group covers the parent data stream\n+                final boolean indexCheck = group.checkIndex(indexOrAlias) ||\n+                        (isBackingIndex && group.checkIndex(indexAbstraction.getParentDataStream().getName()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQyMzExMQ=="}, "originalCommit": {"oid": "4071e953d67142f123159f44f4435d93fb5b812a"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY3NTkzNg==", "bodyText": "I'm not a fan of this wording - I'll propose an alternative during my day.", "url": "https://github.com/elastic/elasticsearch/pull/58784#discussion_r453675936", "createdAt": "2020-07-13T14:07:18Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "diffHunk": "@@ -202,43 +229,83 @@ public Automaton allowedActionsMatcher(String index) {\n         Map<String, DocumentLevelPermissions> roleQueriesByIndex = new HashMap<>();\n         Map<String, Boolean> grantedBuilder = new HashMap<>();\n \n+        final boolean isMappingUpdateAction = action.equals(PutMappingAction.NAME) || action.equals(AutoPutMappingAction.NAME);\n+\n         for (String indexOrAlias : requestedIndicesOrAliases) {\n-            boolean granted = false;\n-            Set<String> concreteIndices = new HashSet<>();\n-            IndexAbstraction indexAbstraction = lookup.get(indexOrAlias);\n+            final boolean isBackingIndex;\n+            final boolean isDataStream;\n+            final Set<String> concreteIndices = new HashSet<>();\n+            final IndexAbstraction indexAbstraction = lookup.get(indexOrAlias);\n             if (indexAbstraction != null) {\n                 for (IndexMetadata indexMetadata : indexAbstraction.getIndices()) {\n                     concreteIndices.add(indexMetadata.getIndex().getName());\n                 }\n+                isBackingIndex = indexAbstraction.getType() == IndexAbstraction.Type.CONCRETE_INDEX &&\n+                        indexAbstraction.getParentDataStream() != null;\n+                isDataStream = indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM;\n+            } else {\n+                isBackingIndex = isDataStream = false;\n             }\n \n+            // true if ANY group covers the given index AND the given action\n+            boolean granted = false;\n+            // true if ANY group, which contains certain ingest privileges, covers the given index AND the action is a mapping update for\n+            // an index or an alias (but not for a data stream)\n+            boolean bwcGrantMappingUpdate = false;\n+            final List<Runnable> bwcDeprecationLogActions = new ArrayList<>();\n+\n             for (Group group : groups) {\n-                // check for privilege granted directly on the requested index/alias\n-                if (group.check(action, indexOrAlias) ||\n-                    // check for privilege granted on parent data stream if a backing index\n-                    (indexAbstraction != null && indexAbstraction.getType() == IndexAbstraction.Type.CONCRETE_INDEX &&\n-                        indexAbstraction.getParentDataStream() != null &&\n-                        group.check(action, indexAbstraction.getParentDataStream().getName()))) {\n-                    granted = true;\n-                    for (String index : concreteIndices) {\n-                        Set<FieldPermissions> fieldPermissions = fieldPermissionsByIndex.computeIfAbsent(index, (k) -> new HashSet<>());\n-                        fieldPermissionsByIndex.put(indexOrAlias, fieldPermissions);\n-                        fieldPermissions.add(group.getFieldPermissions());\n-                        DocumentLevelPermissions permissions =\n-                                roleQueriesByIndex.computeIfAbsent(index, (k) -> new DocumentLevelPermissions());\n-                        roleQueriesByIndex.putIfAbsent(indexOrAlias, permissions);\n-                        if (group.hasQuery()) {\n-                            permissions.addAll(group.getQuery());\n-                        } else {\n-                            // if more than one permission matches for a concrete index here and if\n-                            // a single permission doesn't have a role query then DLS will not be\n-                            // applied even when other permissions do have a role query\n-                            permissions.setAllowAll(true);\n+                // the group covers the given index OR the given index is a backing index and the group covers the parent data stream\n+                final boolean indexCheck = group.checkIndex(indexOrAlias) ||\n+                        (isBackingIndex && group.checkIndex(indexAbstraction.getParentDataStream().getName()));\n+                if (indexCheck) {\n+                    boolean actionCheck = group.checkAction(action);\n+                    // mapping updates are allowed for certain privileges on indices and aliases (but not on data streams),\n+                    // outside of the privilege definition\n+                    boolean bwcMappingActionCheck = isMappingUpdateAction && false == isDataStream && false == isBackingIndex &&\n+                            group.privilege().name().stream().anyMatch(privilegeNameSetBwcAllowMappingUpdate::contains);\n+                    if (actionCheck || bwcMappingActionCheck) {\n+                        // propagate DLS and FLS permissions over the concrete indices\n+                        for (String index : concreteIndices) {\n+                            Set<FieldPermissions> fieldPermissions = fieldPermissionsByIndex.computeIfAbsent(index, (k) -> new HashSet<>());\n+                            fieldPermissionsByIndex.put(indexOrAlias, fieldPermissions);\n+                            fieldPermissions.add(group.getFieldPermissions());\n+                            DocumentLevelPermissions permissions =\n+                                    roleQueriesByIndex.computeIfAbsent(index, (k) -> new DocumentLevelPermissions());\n+                            roleQueriesByIndex.putIfAbsent(indexOrAlias, permissions);\n+                            if (group.hasQuery()) {\n+                                permissions.addAll(group.getQuery());\n+                            } else {\n+                                // if more than one permission matches for a concrete index here and if\n+                                // a single permission doesn't have a role query then DLS will not be\n+                                // applied even when other permissions do have a role query\n+                                permissions.setAllowAll(true);\n+                            }\n+                        }\n+                    }\n+                    granted |= actionCheck;\n+                    bwcGrantMappingUpdate |= bwcMappingActionCheck;\n+                    if (false == actionCheck && bwcMappingActionCheck) {\n+                        for (String privilegeName : group.privilege.name()) {\n+                            if (privilegeNameSetBwcAllowMappingUpdate.contains(privilegeName)) {\n+                                bwcDeprecationLogActions.add(() -> {\n+                                    deprecationLogger.deprecate(\"[\" + indexOrAlias + \"] mapping update for ingest privilege [\" +\n+                                            privilegeName + \"]\", \"the mapping update action [\" + action + \"] on the [\" +\n+                                            indexOrAlias + \"] index, is granted by the [\" + privilegeName + \"] privilege,\" +\n+                                            \" but the privilege has been tightened to not allow it in the next major release\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb50c54af29c796c9b74bc5fae9d24b828a1388e"}, "originalPosition": 167}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "49b92c61e29362e2a93c91e9061430372a21da45", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/49b92c61e29362e2a93c91e9061430372a21da45", "committedDate": "2020-07-13T15:12:52Z", "message": "Review partway"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "50f393b0c1190b80974d9220661bf754c4c3552f", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/50f393b0c1190b80974d9220661bf754c4c3552f", "committedDate": "2020-07-14T10:28:53Z", "message": "Merge branch 'master' into remove_put_mapping_priv"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f5a85d71895d05fdd76c2d4e303c49b7309c6d7a", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/f5a85d71895d05fdd76c2d4e303c49b7309c6d7a", "committedDate": "2020-07-14T12:18:52Z", "message": "Review"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3d3f64d581ab0f23823a621a7f6bb71c2e991f39", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/3d3f64d581ab0f23823a621a7f6bb71c2e991f39", "committedDate": "2020-07-14T12:27:03Z", "message": "Merge branch 'master' into remove_put_mapping_priv"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ4MTEzNTg4", "url": "https://github.com/elastic/elasticsearch/pull/58784#pullrequestreview-448113588", "createdAt": "2020-07-14T13:38:13Z", "commit": {"oid": "3d3f64d581ab0f23823a621a7f6bb71c2e991f39"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMzozODoxM1rOGxUDug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMzozODoxM1rOGxUDug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDM2MjA0Mg==", "bodyText": "How about\n\nthe index privilege [] allowed the update mapping action [] on index [], this privilege will not permit mapping updates in the next major release - users who require access to update mappings must be granted explicit privileges\n\nIf you don't like it we can merge as-is, & come back and reword it later.", "url": "https://github.com/elastic/elasticsearch/pull/58784#discussion_r454362042", "createdAt": "2020-07-14T13:38:13Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java", "diffHunk": "@@ -202,43 +227,83 @@ public Automaton allowedActionsMatcher(String index) {\n         Map<String, DocumentLevelPermissions> roleQueriesByIndex = new HashMap<>();\n         Map<String, Boolean> grantedBuilder = new HashMap<>();\n \n+        final boolean isMappingUpdateAction = isMappingUpdateAction(action);\n+\n         for (String indexOrAlias : requestedIndicesOrAliases) {\n-            boolean granted = false;\n-            Set<String> concreteIndices = new HashSet<>();\n-            IndexAbstraction indexAbstraction = lookup.get(indexOrAlias);\n+            final boolean isBackingIndex;\n+            final boolean isDataStream;\n+            final Set<String> concreteIndices = new HashSet<>();\n+            final IndexAbstraction indexAbstraction = lookup.get(indexOrAlias);\n             if (indexAbstraction != null) {\n                 for (IndexMetadata indexMetadata : indexAbstraction.getIndices()) {\n                     concreteIndices.add(indexMetadata.getIndex().getName());\n                 }\n+                isBackingIndex = indexAbstraction.getType() == IndexAbstraction.Type.CONCRETE_INDEX &&\n+                        indexAbstraction.getParentDataStream() != null;\n+                isDataStream = indexAbstraction.getType() == IndexAbstraction.Type.DATA_STREAM;\n+            } else {\n+                isBackingIndex = isDataStream = false;\n             }\n \n+            // true if ANY group covers the given index AND the given action\n+            boolean granted = false;\n+            // true if ANY group, which contains certain ingest privileges, covers the given index AND the action is a mapping update for\n+            // an index or an alias (but not for a data stream)\n+            boolean bwcGrantMappingUpdate = false;\n+            final List<Runnable> bwcDeprecationLogActions = new ArrayList<>();\n+\n             for (Group group : groups) {\n-                // check for privilege granted directly on the requested index/alias\n-                if (group.check(action, indexOrAlias) ||\n-                    // check for privilege granted on parent data stream if a backing index\n-                    (indexAbstraction != null && indexAbstraction.getType() == IndexAbstraction.Type.CONCRETE_INDEX &&\n-                        indexAbstraction.getParentDataStream() != null &&\n-                        group.check(action, indexAbstraction.getParentDataStream().getName()))) {\n-                    granted = true;\n-                    for (String index : concreteIndices) {\n-                        Set<FieldPermissions> fieldPermissions = fieldPermissionsByIndex.computeIfAbsent(index, (k) -> new HashSet<>());\n-                        fieldPermissionsByIndex.put(indexOrAlias, fieldPermissions);\n-                        fieldPermissions.add(group.getFieldPermissions());\n-                        DocumentLevelPermissions permissions =\n-                                roleQueriesByIndex.computeIfAbsent(index, (k) -> new DocumentLevelPermissions());\n-                        roleQueriesByIndex.putIfAbsent(indexOrAlias, permissions);\n-                        if (group.hasQuery()) {\n-                            permissions.addAll(group.getQuery());\n-                        } else {\n-                            // if more than one permission matches for a concrete index here and if\n-                            // a single permission doesn't have a role query then DLS will not be\n-                            // applied even when other permissions do have a role query\n-                            permissions.setAllowAll(true);\n+                // the group covers the given index OR the given index is a backing index and the group covers the parent data stream\n+                final boolean indexCheck = group.checkIndex(indexOrAlias) ||\n+                        (isBackingIndex && group.checkIndex(indexAbstraction.getParentDataStream().getName()));\n+                if (indexCheck) {\n+                    boolean actionCheck = group.checkAction(action);\n+                    granted = granted || actionCheck;\n+                    // mapping updates are allowed for certain privileges on indices and aliases (but not on data streams),\n+                    // outside of the privilege definition\n+                    boolean bwcMappingActionCheck = isMappingUpdateAction && false == isDataStream && false == isBackingIndex &&\n+                            containsPrivilegeThatGrantsMappingUpdatesForBwc(group);\n+                    bwcGrantMappingUpdate = bwcGrantMappingUpdate || bwcMappingActionCheck;\n+                    if (actionCheck || bwcMappingActionCheck) {\n+                        // propagate DLS and FLS permissions over the concrete indices\n+                        for (String index : concreteIndices) {\n+                            Set<FieldPermissions> fieldPermissions = fieldPermissionsByIndex.computeIfAbsent(index, (k) -> new HashSet<>());\n+                            fieldPermissionsByIndex.put(indexOrAlias, fieldPermissions);\n+                            fieldPermissions.add(group.getFieldPermissions());\n+                            DocumentLevelPermissions permissions =\n+                                    roleQueriesByIndex.computeIfAbsent(index, (k) -> new DocumentLevelPermissions());\n+                            roleQueriesByIndex.putIfAbsent(indexOrAlias, permissions);\n+                            if (group.hasQuery()) {\n+                                permissions.addAll(group.getQuery());\n+                            } else {\n+                                // if more than one permission matches for a concrete index here and if\n+                                // a single permission doesn't have a role query then DLS will not be\n+                                // applied even when other permissions do have a role query\n+                                permissions.setAllowAll(true);\n+                            }\n+                        }\n+                        if (false == actionCheck) {\n+                            for (String privilegeName : group.privilege.name()) {\n+                                if (PRIVILEGE_NAME_SET_BWC_ALLOW_MAPPING_UPDATE.contains(privilegeName)) {\n+                                    bwcDeprecationLogActions.add(() -> {\n+                                        deprecationLogger.deprecate(\"[\" + indexOrAlias + \"] mapping update for ingest privilege [\" +\n+                                                privilegeName + \"]\", \"the mapping update action [\" + action + \"] on the [\" +\n+                                                indexOrAlias + \"] index, is granted by the [\" + privilegeName + \"] privilege,\" +\n+                                                \" but the privilege has been tightened to not allow it in the next major release\");\n+                                    });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d3f64d581ab0f23823a621a7f6bb71c2e991f39"}, "originalPosition": 174}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "44c34737932ab841af2e815400e89d4fdbccab39", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/44c34737932ab841af2e815400e89d4fdbccab39", "committedDate": "2020-07-14T14:13:50Z", "message": "Review partway"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fd45d7b0f032adbd40238a8ec1b5f183bfc44367", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/fd45d7b0f032adbd40238a8ec1b5f183bfc44367", "committedDate": "2020-07-14T14:14:20Z", "message": "Merge branch 'master' into remove_put_mapping_priv"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3e4f1305e544ac59fa33182f6f67ecb9c127ccef", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/3e4f1305e544ac59fa33182f6f67ecb9c127ccef", "committedDate": "2020-07-14T14:25:27Z", "message": "Message"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "148057c008e8ab736f4a0ed1918b1cd77d49fcd6", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/148057c008e8ab736f4a0ed1918b1cd77d49fcd6", "committedDate": "2020-07-14T16:17:14Z", "message": "Deprecation msgs fallout"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9e12382aaf0239a8eae14ba10907749f10fc8899", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/9e12382aaf0239a8eae14ba10907749f10fc8899", "committedDate": "2020-07-14T17:02:42Z", "message": "Update more deprecation logs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f3fec33cdbbd6864142eff75c037b59d273bf6a3", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/f3fec33cdbbd6864142eff75c037b59d273bf6a3", "committedDate": "2020-07-14T17:03:24Z", "message": "Merge branch 'master' into remove_put_mapping_priv"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2441, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}