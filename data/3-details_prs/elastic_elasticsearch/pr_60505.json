{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYwMDEyODM4", "number": 60505, "title": " Add recovery state tracking for Searchable Snapshots", "bodyText": "This pull request adds recovery state tracking for Searchable Snapshots.\nIn order to track recoveries for searchable snapshot backed indices, this pull\nrequest adds a new type of RecoveryState.\nThis newRecoveryState instance that's able to deal with the\nsmall differences that arise during the use of Searchable snapshots.\nThose differences can be summarized as follows:\n\nThe Directory implementation that's provided by SearchableSnapshots mark the\nsnapshot files as reused during recovery. In order to keep track of the\nrecovery process as the cache is pre-warmed, those files shouldn't be marked\nas reused.\nOnce the shard is created, the cache starts its pre-warming phase, meaning that\nwe should keep track of those downloads during that process and tie the recovery\nto this pre-warming phase. The shard is considered recovered once this pre-warming\nphase has finished.", "createdAt": "2020-07-31T10:31:09Z", "url": "https://github.com/elastic/elasticsearch/pull/60505", "merged": true, "mergeCommit": {"oid": "9b71cdea7e338e3567c44e45213c8cdc9f4a4c5b"}, "closed": true, "closedAt": "2020-08-05T12:42:55Z", "author": {"login": "fcofdez"}, "timelineItems": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc6SL9xgH2gAyNDYwMDEyODM4OjM1MmUzN2I1MGYxOWZiNDRlYzNjOWM0MjM4NGFmM2M5MGUyYzc2YjU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc750jIAFqTQ2MTU4OTQ2NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "352e37b50f19fb44ec3c9c42384af3c90e2c76b5", "author": {"user": {"login": "fcofdez", "name": "Francisco Fern\u00e1ndez Casta\u00f1o"}}, "url": "https://github.com/elastic/elasticsearch/commit/352e37b50f19fb44ec3c9c42384af3c90e2c76b5", "committedDate": "2020-07-31T11:05:03Z", "message": "Keep track of recovery stats during searchable snapshots cache pre-warm"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "428c96664cefe9d195eb33beefdd2414c9766465", "author": {"user": {"login": "fcofdez", "name": "Francisco Fern\u00e1ndez Casta\u00f1o"}}, "url": "https://github.com/elastic/elasticsearch/commit/428c96664cefe9d195eb33beefdd2414c9766465", "committedDate": "2020-07-31T10:29:50Z", "message": "Keep track of recovery stats during searchable snapshots cache pre-warm"}, "afterCommit": {"oid": "352e37b50f19fb44ec3c9c42384af3c90e2c76b5", "author": {"user": {"login": "fcofdez", "name": "Francisco Fern\u00e1ndez Casta\u00f1o"}}, "url": "https://github.com/elastic/elasticsearch/commit/352e37b50f19fb44ec3c9c42384af3c90e2c76b5", "committedDate": "2020-07-31T11:05:03Z", "message": "Keep track of recovery stats during searchable snapshots cache pre-warm"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b301b6fe8b4ff444950a47ef2d949752f6b9081a", "author": {"user": {"login": "fcofdez", "name": "Francisco Fern\u00e1ndez Casta\u00f1o"}}, "url": "https://github.com/elastic/elasticsearch/commit/b301b6fe8b4ff444950a47ef2d949752f6b9081a", "committedDate": "2020-07-31T12:03:51Z", "message": "Fix visibility issue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "614c4754ab9a29ad8056c7bf23c71c64d0a6b705", "author": {"user": {"login": "fcofdez", "name": "Francisco Fern\u00e1ndez Casta\u00f1o"}}, "url": "https://github.com/elastic/elasticsearch/commit/614c4754ab9a29ad8056c7bf23c71c64d0a6b705", "committedDate": "2020-07-31T12:49:07Z", "message": "Do not output file details by default"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1a6ce58dfe8ce55b4b96c396069abc2a593d3a4a", "author": {"user": {"login": "elasticmachine", "name": "Elastic Machine"}}, "url": "https://github.com/elastic/elasticsearch/commit/1a6ce58dfe8ce55b4b96c396069abc2a593d3a4a", "committedDate": "2020-08-02T11:32:44Z", "message": "Merge branch 'master' into searchable-snapshots-recovery-state"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5ODIyMDQ0", "url": "https://github.com/elastic/elasticsearch/pull/60505#pullrequestreview-459822044", "createdAt": "2020-08-03T07:59:18Z", "commit": {"oid": "1a6ce58dfe8ce55b4b96c396069abc2a593d3a4a"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QwNzo1OToxOFrOG6vw7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QwODo0OTo1M1rOG6xSmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI1MzE2Nw==", "bodyText": "what's the point of this private method? It's just delegating a single call, yet introducing an unnecessary abstraction", "url": "https://github.com/elastic/elasticsearch/pull/60505#discussion_r464253167", "createdAt": "2020-08-03T07:59:18Z", "author": {"login": "ywelsch"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/SearchableSnapshotDirectory.java", "diffHunk": "@@ -387,58 +395,73 @@ private void cleanExistingRegularShardFiles() {\n         }\n     }\n \n+    private void onPreWarmFinished() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a6ce58dfe8ce55b4b96c396069abc2a593d3a4a"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI1NjU4Ng==", "bodyText": "Inline this into prewarmCache? Especially as it's duplicating the iteration logic down below.", "url": "https://github.com/elastic/elasticsearch/pull/60505#discussion_r464256586", "createdAt": "2020-08-03T08:06:41Z", "author": {"login": "ywelsch"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/SearchableSnapshotDirectory.java", "diffHunk": "@@ -455,6 +478,19 @@ private void prewarmNext(final Executor executor, final BlockingQueue<Tuple<Acti\n         }\n     }\n \n+    private void addRecoveryFileDetails() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a6ce58dfe8ce55b4b96c396069abc2a593d3a4a"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI2MTQ1NA==", "bodyText": "KeptOpen?", "url": "https://github.com/elastic/elasticsearch/pull/60505#discussion_r464261454", "createdAt": "2020-08-03T08:17:09Z", "author": {"login": "ywelsch"}, "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/index/store/SearchableSnapshotDirectoryTests.java", "diffHunk": "@@ -736,6 +765,74 @@ public void testRequiresAdditionalSettings() {\n         }\n     }\n \n+    public void testRecoveryStateIsKeepOpenAfterPreWarmFailures() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a6ce58dfe8ce55b4b96c396069abc2a593d3a4a"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI2NTEwMQ==", "bodyText": "With the change in behavior of this PR, rename this perhaps to \"snapshot_prewarm\".", "url": "https://github.com/elastic/elasticsearch/pull/60505#discussion_r464265101", "createdAt": "2020-08-03T08:24:29Z", "author": {"login": "ywelsch"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/searchablesnapshots/SearchableSnapshotsConstants.java", "diffHunk": "@@ -30,6 +30,8 @@\n \n     public static final String SNAPSHOT_DIRECTORY_FACTORY_KEY = \"snapshot\";\n \n+    public static final String SNAPSHOT_RECOVERY_STATE_FACTORY_KEY = \"on_demand\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a6ce58dfe8ce55b4b96c396069abc2a593d3a4a"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI3MDY1OQ==", "bodyText": "This assumes that noone is touching the index setting index.recovery.type. Perhaps we should also throw an explicit exception here when assertions are not enabled?", "url": "https://github.com/elastic/elasticsearch/pull/60505#discussion_r464270659", "createdAt": "2020-08-03T08:35:14Z", "author": {"login": "ywelsch"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/SearchableSnapshotDirectory.java", "diffHunk": "@@ -176,7 +180,9 @@ protected final boolean assertCurrentThreadMayLoadSnapshot() {\n      *\n      * @return true if the snapshot was loaded by executing this method, false otherwise\n      */\n-    public boolean loadSnapshot() {\n+    public boolean loadSnapshot(RecoveryState recoveryState) {\n+        assert recoveryState != null;\n+        assert recoveryState instanceof SearchableSnapshotRecoveryState;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a6ce58dfe8ce55b4b96c396069abc2a593d3a4a"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI3NDQwOQ==", "bodyText": "maybe just choose a random subset of  these, and then check later that fileDetails does  not contain any of the subset  chosen? THis test  here would currently be trivially satisfied if the code was to just ignore all files whenever excluded files existed.", "url": "https://github.com/elastic/elasticsearch/pull/60505#discussion_r464274409", "createdAt": "2020-08-03T08:42:46Z", "author": {"login": "ywelsch"}, "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/index/store/SearchableSnapshotDirectoryTests.java", "diffHunk": "@@ -736,6 +765,74 @@ public void testRequiresAdditionalSettings() {\n         }\n     }\n \n+    public void testRecoveryStateIsKeepOpenAfterPreWarmFailures() throws Exception {\n+        FileSystem fileSystem = PathUtils.getDefaultFileSystem();\n+        FaultyReadsFileSystem disruptFileSystemProvider = new FaultyReadsFileSystem(fileSystem);\n+        fileSystem = disruptFileSystemProvider.getFileSystem(null);\n+        PathUtilsForTesting.installMock(fileSystem);\n+\n+        try {\n+            SearchableSnapshotRecoveryState recoveryState = createRecoveryState();\n+            testDirectories(true, true, recoveryState, Settings.EMPTY, (directory, snapshotDirectory) -> {\n+                ThreadPoolExecutor executor = (ThreadPoolExecutor) snapshotDirectory.cacheFetchAsyncExecutor();\n+                assertBusy(() -> {\n+                    assertThat(executor.getActiveCount(), equalTo(0));\n+                    assertThat(executor.getQueue().size(), equalTo(0));\n+                });\n+\n+                assertThat(recoveryState.getStage(), equalTo(RecoveryState.Stage.FINALIZE));\n+                // All pre-warm tasks failed\n+                assertThat(recoveryState.getIndex().recoveredBytes(), equalTo(0L));\n+            });\n+        } finally {\n+            PathUtilsForTesting.teardown();\n+        }\n+    }\n+\n+    public void testRecoveryStateIsEmptyWhenTheCacheIsNotPreWarmed() throws Exception {\n+        SearchableSnapshotRecoveryState recoveryState = createRecoveryState();\n+        testDirectories(true, false, recoveryState, Settings.EMPTY, (directory, snapshotDirectory) -> {\n+            assertThat(recoveryState.getStage(), equalTo(RecoveryState.Stage.DONE));\n+            assertThat(recoveryState.getIndex().recoveredBytes(), equalTo(0L));\n+            assertThat(recoveryState.getIndex().totalRecoverFiles(), equalTo(0));\n+        });\n+    }\n+\n+    public void testNonCachedFilesAreExcludedFromRecoveryState() throws Exception {\n+        SearchableSnapshotRecoveryState recoveryState = createRecoveryState();\n+\n+        List<String> allFileExtensions = List.of(\n+            \"fdt\",\n+            \"fdx\",\n+            \"nvd\",\n+            \"dvd\",\n+            \"tip\",\n+            \"cfs\",\n+            \"dim\",\n+            \"fnm\",\n+            \"dvm\",\n+            \"tmd\",\n+            \"doc\",\n+            \"tim\",\n+            \"pos\",\n+            \"cfe\",\n+            \"fdm\",\n+            \"nvm\"\n+        );\n+        Settings settings = Settings.builder().putList(SNAPSHOT_CACHE_EXCLUDED_FILE_TYPES_SETTING.getKey(), allFileExtensions).build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a6ce58dfe8ce55b4b96c396069abc2a593d3a4a"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI3NzIwMA==", "bodyText": "is this info-level logging still needed?", "url": "https://github.com/elastic/elasticsearch/pull/60505#discussion_r464277200", "createdAt": "2020-08-03T08:48:03Z", "author": {"login": "ywelsch"}, "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/xpack/searchablesnapshots/SearchableSnapshotsIntegTests.java", "diffHunk": "@@ -703,6 +700,29 @@ private void assertRecovered(String indexName, TotalHits originalAllHits, TotalH\n         }\n     }\n \n+    private void assertRecoveryStats(String indexName, boolean preWarmEnabled) {\n+        int shardCount = getNumShards(indexName).totalNumShards;\n+        final RecoveryResponse recoveryResponse = client().admin().indices().prepareRecoveries(indexName).get();\n+        assertThat(recoveryResponse.shardRecoveryStates().get(indexName).size(), equalTo(shardCount));\n+\n+        for (List<RecoveryState> recoveryStates : recoveryResponse.shardRecoveryStates().values()) {\n+            for (RecoveryState recoveryState : recoveryStates) {\n+                logger.info(\"Checking {}[{}]\", recoveryState.getShardId(), recoveryState.getPrimary() ? \"p\" : \"r\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a6ce58dfe8ce55b4b96c396069abc2a593d3a4a"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI3Nzk3NQ==", "bodyText": "That's not true anymore with the latest approach? Shouldn't it always be DONE?", "url": "https://github.com/elastic/elasticsearch/pull/60505#discussion_r464277975", "createdAt": "2020-08-03T08:49:32Z", "author": {"login": "ywelsch"}, "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/xpack/searchablesnapshots/SearchableSnapshotsIntegTests.java", "diffHunk": "@@ -703,6 +700,29 @@ private void assertRecovered(String indexName, TotalHits originalAllHits, TotalH\n         }\n     }\n \n+    private void assertRecoveryStats(String indexName, boolean preWarmEnabled) {\n+        int shardCount = getNumShards(indexName).totalNumShards;\n+        final RecoveryResponse recoveryResponse = client().admin().indices().prepareRecoveries(indexName).get();\n+        assertThat(recoveryResponse.shardRecoveryStates().get(indexName).size(), equalTo(shardCount));\n+\n+        for (List<RecoveryState> recoveryStates : recoveryResponse.shardRecoveryStates().values()) {\n+            for (RecoveryState recoveryState : recoveryStates) {\n+                logger.info(\"Checking {}[{}]\", recoveryState.getShardId(), recoveryState.getPrimary() ? \"p\" : \"r\");\n+                ByteSizeValue cacheSize = getCacheSizeForShard(recoveryState.getShardId());\n+                boolean largeCache = cacheSize.compareTo(new ByteSizeValue(1, ByteSizeUnit.MB)) >= 0;\n+                assertThat(\n+                    Strings.toString(recoveryState),\n+                    recoveryState.getIndex().recoveredFileCount(),\n+                    preWarmEnabled && largeCache ? greaterThan(0) : greaterThanOrEqualTo(0)\n+                );\n+\n+                // Since the cache size is variable, the pre-warm phase might fail as some of the files can be evicted\n+                // while a part is pre-fetched, in that case the recovery state is left as FINALIZE.\n+                assertThat(recoveryState.getStage(), anyOf(equalTo(RecoveryState.Stage.DONE), equalTo(RecoveryState.Stage.FINALIZE)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a6ce58dfe8ce55b4b96c396069abc2a593d3a4a"}, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI3ODE2OQ==", "bodyText": "Is still relevant with the latest approach?", "url": "https://github.com/elastic/elasticsearch/pull/60505#discussion_r464278169", "createdAt": "2020-08-03T08:49:53Z", "author": {"login": "ywelsch"}, "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/xpack/searchablesnapshots/SearchableSnapshotsIntegTests.java", "diffHunk": "@@ -703,6 +700,29 @@ private void assertRecovered(String indexName, TotalHits originalAllHits, TotalH\n         }\n     }\n \n+    private void assertRecoveryStats(String indexName, boolean preWarmEnabled) {\n+        int shardCount = getNumShards(indexName).totalNumShards;\n+        final RecoveryResponse recoveryResponse = client().admin().indices().prepareRecoveries(indexName).get();\n+        assertThat(recoveryResponse.shardRecoveryStates().get(indexName).size(), equalTo(shardCount));\n+\n+        for (List<RecoveryState> recoveryStates : recoveryResponse.shardRecoveryStates().values()) {\n+            for (RecoveryState recoveryState : recoveryStates) {\n+                logger.info(\"Checking {}[{}]\", recoveryState.getShardId(), recoveryState.getPrimary() ? \"p\" : \"r\");\n+                ByteSizeValue cacheSize = getCacheSizeForShard(recoveryState.getShardId());\n+                boolean largeCache = cacheSize.compareTo(new ByteSizeValue(1, ByteSizeUnit.MB)) >= 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a6ce58dfe8ce55b4b96c396069abc2a593d3a4a"}, "originalPosition": 163}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "46b07633c84432eb970fc8b04a401c4ae5f736f6", "author": {"user": {"login": "fcofdez", "name": "Francisco Fern\u00e1ndez Casta\u00f1o"}}, "url": "https://github.com/elastic/elasticsearch/commit/46b07633c84432eb970fc8b04a401c4ae5f736f6", "committedDate": "2020-08-03T13:36:34Z", "message": "Address review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "467693798cdbec046126e58bf0aadc4fb05f9e78", "author": {"user": {"login": "fcofdez", "name": "Francisco Fern\u00e1ndez Casta\u00f1o"}}, "url": "https://github.com/elastic/elasticsearch/commit/467693798cdbec046126e58bf0aadc4fb05f9e78", "committedDate": "2020-08-03T13:37:05Z", "message": "Merge remote-tracking branch 'origin/master' into searchable-snapshots-recovery-state"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b2989f667ca763500b9c6311ec03af81aeb2ef38", "author": {"user": {"login": "fcofdez", "name": "Francisco Fern\u00e1ndez Casta\u00f1o"}}, "url": "https://github.com/elastic/elasticsearch/commit/b2989f667ca763500b9c6311ec03af81aeb2ef38", "committedDate": "2020-08-03T13:57:40Z", "message": "Fix stlye errors"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwNjQwOTY1", "url": "https://github.com/elastic/elasticsearch/pull/60505#pullrequestreview-460640965", "createdAt": "2020-08-04T09:18:12Z", "commit": {"oid": "b2989f667ca763500b9c6311ec03af81aeb2ef38"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwOToxODoxMlrOG7YOow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwOToyNzo1OFrOG7Yklg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkxNjEzMQ==", "bodyText": "In case where file.metadata().hashEqualsContents(), I wonder if we should just mark those files as recovered (reused = true) (as they are subsequently available), i.e. recoveryState.getIndex().addFileDetail(file.physicalName(), file.length(), true);.", "url": "https://github.com/elastic/elasticsearch/pull/60505#discussion_r464916131", "createdAt": "2020-08-04T09:18:12Z", "author": {"login": "ywelsch"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/SearchableSnapshotDirectory.java", "diffHunk": "@@ -388,57 +398,70 @@ private void cleanExistingRegularShardFiles() {\n     }\n \n     private void prewarmCache() {\n-        if (prewarmCache) {\n-            final BlockingQueue<Tuple<ActionListener<Void>, CheckedRunnable<Exception>>> queue = new LinkedBlockingQueue<>();\n-            final Executor executor = prewarmExecutor();\n+        if (prewarmCache == false) {\n+            recoveryState.preWarmFinished();\n+            return;\n+        }\n \n-            for (BlobStoreIndexShardSnapshot.FileInfo file : snapshot().indexFiles()) {\n-                if (file.metadata().hashEqualsContents() || isExcludedFromCache(file.physicalName())) {\n-                    continue;\n-                }\n-                try {\n-                    final IndexInput input = openInput(file.physicalName(), CachedBlobContainerIndexInput.CACHE_WARMING_CONTEXT);\n-                    assert input instanceof CachedBlobContainerIndexInput : \"expected cached index input but got \" + input.getClass();\n-\n-                    final int numberOfParts = Math.toIntExact(file.numberOfParts());\n-                    final GroupedActionListener<Void> listener = new GroupedActionListener<>(\n-                        ActionListener.wrap(voids -> input.close(), e -> IOUtils.closeWhileHandlingException(input)),\n-                        numberOfParts\n-                    );\n-\n-                    for (int p = 0; p < numberOfParts; p++) {\n-                        final int part = p;\n-                        queue.add(Tuple.tuple(listener, () -> {\n-                            ensureOpen();\n-\n-                            logger.trace(\"{} warming cache for [{}] part [{}/{}]\", shardId, file.physicalName(), part + 1, numberOfParts);\n-                            final long startTimeInNanos = statsCurrentTimeNanosSupplier.getAsLong();\n-                            ((CachedBlobContainerIndexInput) input).prefetchPart(part);\n-\n-                            logger.trace(\n-                                () -> new ParameterizedMessage(\n-                                    \"{} part [{}/{}] of [{}] warmed in [{}] ms\",\n-                                    shardId,\n-                                    part + 1,\n-                                    numberOfParts,\n-                                    file.physicalName(),\n-                                    TimeValue.timeValueNanos(statsCurrentTimeNanosSupplier.getAsLong() - startTimeInNanos).millis()\n-                                )\n-                            );\n-                        }));\n-                    }\n-                } catch (IOException e) {\n-                    logger.warn(() -> new ParameterizedMessage(\"{} unable to prewarm file [{}]\", shardId, file.physicalName()), e);\n+        final BlockingQueue<Tuple<ActionListener<Void>, CheckedRunnable<Exception>>> queue = new LinkedBlockingQueue<>();\n+        final Executor executor = prewarmExecutor();\n+\n+        final GroupedActionListener<Void> completionListener = new GroupedActionListener<>(\n+            ActionListener.wrap(voids -> recoveryState.preWarmFinished(), e -> {}), // Ignore pre-warm errors\n+            snapshot().totalFileCount()\n+        );\n+\n+        for (BlobStoreIndexShardSnapshot.FileInfo file : snapshot().indexFiles()) {\n+            if (file.metadata().hashEqualsContents() || isExcludedFromCache(file.physicalName())) {\n+                recoveryState.ignoreFile(file.physicalName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2989f667ca763500b9c6311ec03af81aeb2ef38"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkxODAzOQ==", "bodyText": "should we throw an exception here if the stage is currently not FINALIZE, i.e. validateCurrentStage(FINALIZE)?", "url": "https://github.com/elastic/elasticsearch/pull/60505#discussion_r464918039", "createdAt": "2020-08-04T09:21:33Z", "author": {"login": "ywelsch"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/indices/recovery/SearchableSnapshotRecoveryState.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.indices.recovery;\n+\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.common.Nullable;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+public final class SearchableSnapshotRecoveryState extends RecoveryState {\n+    private boolean preWarmFinished;\n+\n+    public SearchableSnapshotRecoveryState(ShardRouting shardRouting, DiscoveryNode targetNode, @Nullable DiscoveryNode sourceNode) {\n+        super(shardRouting, targetNode, sourceNode, new Index());\n+    }\n+\n+    @Override\n+    public synchronized RecoveryState setStage(Stage stage) {\n+        // The transition to the final state was done by #prewarmCompleted, just ignore the transition\n+        if (getStage() == Stage.DONE) {\n+            return this;\n+        }\n+\n+        // Pre-warm is still running, hold the state transition\n+        // until the pre-warm process finishes\n+        if (preWarmFinished == false && stage == Stage.DONE) {\n+            return this;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2989f667ca763500b9c6311ec03af81aeb2ef38"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkxOTI0Mg==", "bodyText": "do we not need to implement this method, which  gets called when a peer recovery retries?", "url": "https://github.com/elastic/elasticsearch/pull/60505#discussion_r464919242", "createdAt": "2020-08-04T09:23:41Z", "author": {"login": "ywelsch"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/indices/recovery/SearchableSnapshotRecoveryState.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.indices.recovery;\n+\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.common.Nullable;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+public final class SearchableSnapshotRecoveryState extends RecoveryState {\n+    private boolean preWarmFinished;\n+\n+    public SearchableSnapshotRecoveryState(ShardRouting shardRouting, DiscoveryNode targetNode, @Nullable DiscoveryNode sourceNode) {\n+        super(shardRouting, targetNode, sourceNode, new Index());\n+    }\n+\n+    @Override\n+    public synchronized RecoveryState setStage(Stage stage) {\n+        // The transition to the final state was done by #prewarmCompleted, just ignore the transition\n+        if (getStage() == Stage.DONE) {\n+            return this;\n+        }\n+\n+        // Pre-warm is still running, hold the state transition\n+        // until the pre-warm process finishes\n+        if (preWarmFinished == false && stage == Stage.DONE) {\n+            return this;\n+        }\n+\n+        return super.setStage(stage);\n+    }\n+\n+    public synchronized void preWarmFinished() {\n+        // For small shards it's possible that the\n+        // cache is pre-warmed before the stage has transitioned\n+        // to FINALIZE, so the transition to the final state is delayed until\n+        // the recovery process catches up.\n+        if (getStage() == Stage.FINALIZE) {\n+            super.setStage(Stage.DONE);\n+        }\n+\n+        SearchableSnapshotRecoveryState.Index index = (Index) getIndex();\n+        index.stopTimer();\n+        preWarmFinished = true;\n+    }\n+\n+    public synchronized void ignoreFile(String name) {\n+        SearchableSnapshotRecoveryState.Index index = (Index) getIndex();\n+        index.addFileToIgnore(name);\n+    }\n+\n+    private static final class Index extends RecoveryState.Index {\n+        // We ignore the files that won't be part of the pre-warming\n+        // phase since the information for those files won't be\n+        // updated and marking them as reused might be confusing,\n+        // as they are fetched on-demand from the underlying repository.\n+        private final Set<String> filesToIgnore = new HashSet<>();\n+\n+        private Index() {\n+            super(new SearchableSnapshotRecoveryFilesDetails());\n+            // We start loading data just at the beginning\n+            super.start();\n+        }\n+\n+        private synchronized void addFileToIgnore(String name) {\n+            filesToIgnore.add(name);\n+        }\n+\n+        @Override\n+        public synchronized void addFileDetail(String name, long length, boolean reused) {\n+            if (filesToIgnore.contains(name)) {\n+                return;\n+            }\n+\n+            super.addFileDetail(name, length, reused);\n+        }\n+\n+        // We have to bypass all the calls to the timer\n+        @Override\n+        public synchronized void start() {}\n+\n+        @Override\n+        public synchronized void stop() {}\n+\n+        @Override\n+        public synchronized void reset() {}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2989f667ca763500b9c6311ec03af81aeb2ef38"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkyMDY2MA==", "bodyText": "This means that the reused flag is not overridden, but based on what it was initially set?", "url": "https://github.com/elastic/elasticsearch/pull/60505#discussion_r464920660", "createdAt": "2020-08-04T09:26:03Z", "author": {"login": "ywelsch"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/indices/recovery/SearchableSnapshotRecoveryState.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.indices.recovery;\n+\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.common.Nullable;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+public final class SearchableSnapshotRecoveryState extends RecoveryState {\n+    private boolean preWarmFinished;\n+\n+    public SearchableSnapshotRecoveryState(ShardRouting shardRouting, DiscoveryNode targetNode, @Nullable DiscoveryNode sourceNode) {\n+        super(shardRouting, targetNode, sourceNode, new Index());\n+    }\n+\n+    @Override\n+    public synchronized RecoveryState setStage(Stage stage) {\n+        // The transition to the final state was done by #prewarmCompleted, just ignore the transition\n+        if (getStage() == Stage.DONE) {\n+            return this;\n+        }\n+\n+        // Pre-warm is still running, hold the state transition\n+        // until the pre-warm process finishes\n+        if (preWarmFinished == false && stage == Stage.DONE) {\n+            return this;\n+        }\n+\n+        return super.setStage(stage);\n+    }\n+\n+    public synchronized void preWarmFinished() {\n+        // For small shards it's possible that the\n+        // cache is pre-warmed before the stage has transitioned\n+        // to FINALIZE, so the transition to the final state is delayed until\n+        // the recovery process catches up.\n+        if (getStage() == Stage.FINALIZE) {\n+            super.setStage(Stage.DONE);\n+        }\n+\n+        SearchableSnapshotRecoveryState.Index index = (Index) getIndex();\n+        index.stopTimer();\n+        preWarmFinished = true;\n+    }\n+\n+    public synchronized void ignoreFile(String name) {\n+        SearchableSnapshotRecoveryState.Index index = (Index) getIndex();\n+        index.addFileToIgnore(name);\n+    }\n+\n+    private static final class Index extends RecoveryState.Index {\n+        // We ignore the files that won't be part of the pre-warming\n+        // phase since the information for those files won't be\n+        // updated and marking them as reused might be confusing,\n+        // as they are fetched on-demand from the underlying repository.\n+        private final Set<String> filesToIgnore = new HashSet<>();\n+\n+        private Index() {\n+            super(new SearchableSnapshotRecoveryFilesDetails());\n+            // We start loading data just at the beginning\n+            super.start();\n+        }\n+\n+        private synchronized void addFileToIgnore(String name) {\n+            filesToIgnore.add(name);\n+        }\n+\n+        @Override\n+        public synchronized void addFileDetail(String name, long length, boolean reused) {\n+            if (filesToIgnore.contains(name)) {\n+                return;\n+            }\n+\n+            super.addFileDetail(name, length, reused);\n+        }\n+\n+        // We have to bypass all the calls to the timer\n+        @Override\n+        public synchronized void start() {}\n+\n+        @Override\n+        public synchronized void stop() {}\n+\n+        @Override\n+        public synchronized void reset() {}\n+\n+        private synchronized void stopTimer() {\n+            super.stop();\n+        }\n+    }\n+\n+    private static class SearchableSnapshotRecoveryFilesDetails extends RecoveryFilesDetails {\n+        @Override\n+        public void addFileDetails(String name, long length, boolean reused) {\n+            // We allow reporting the same file details multiple times as we populate the file\n+            // details before the recovery is executed and therefore we ignore the rest\n+            // of the calls for the same files.\n+            fileDetails.computeIfAbsent(name, n -> new FileDetail(name, length, reused));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2989f667ca763500b9c6311ec03af81aeb2ef38"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkyMTc1MA==", "bodyText": "simpler to just assertFalse(fileHasExcludedType)", "url": "https://github.com/elastic/elasticsearch/pull/60505#discussion_r464921750", "createdAt": "2020-08-04T09:27:58Z", "author": {"login": "ywelsch"}, "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/index/store/SearchableSnapshotDirectoryTests.java", "diffHunk": "@@ -736,6 +765,79 @@ public void testRequiresAdditionalSettings() {\n         }\n     }\n \n+    public void testRecoveryStateIsKeptOpenAfterPreWarmFailures() throws Exception {\n+        FileSystem fileSystem = PathUtils.getDefaultFileSystem();\n+        FaultyReadsFileSystem disruptFileSystemProvider = new FaultyReadsFileSystem(fileSystem);\n+        fileSystem = disruptFileSystemProvider.getFileSystem(null);\n+        PathUtilsForTesting.installMock(fileSystem);\n+\n+        try {\n+            SearchableSnapshotRecoveryState recoveryState = createRecoveryState();\n+            testDirectories(true, true, recoveryState, Settings.EMPTY, (directory, snapshotDirectory) -> {\n+                ThreadPoolExecutor executor = (ThreadPoolExecutor) snapshotDirectory.cacheFetchAsyncExecutor();\n+                assertBusy(() -> {\n+                    assertThat(executor.getActiveCount(), equalTo(0));\n+                    assertThat(executor.getQueue().size(), equalTo(0));\n+                });\n+\n+                assertThat(recoveryState.getStage(), equalTo(RecoveryState.Stage.FINALIZE));\n+                // All pre-warm tasks failed\n+                assertThat(recoveryState.getIndex().recoveredBytes(), equalTo(0L));\n+            });\n+        } finally {\n+            PathUtilsForTesting.teardown();\n+        }\n+    }\n+\n+    public void testRecoveryStateIsEmptyWhenTheCacheIsNotPreWarmed() throws Exception {\n+        SearchableSnapshotRecoveryState recoveryState = createRecoveryState();\n+        testDirectories(true, false, recoveryState, Settings.EMPTY, (directory, snapshotDirectory) -> {\n+            assertThat(recoveryState.getStage(), equalTo(RecoveryState.Stage.DONE));\n+            assertThat(recoveryState.getIndex().recoveredBytes(), equalTo(0L));\n+            assertThat(recoveryState.getIndex().totalRecoverFiles(), equalTo(0));\n+        });\n+    }\n+\n+    public void testNonCachedFilesAreExcludedFromRecoveryState() throws Exception {\n+        SearchableSnapshotRecoveryState recoveryState = createRecoveryState();\n+\n+        List<String> allFileExtensions = List.of(\n+            \"fdt\",\n+            \"fdx\",\n+            \"nvd\",\n+            \"dvd\",\n+            \"tip\",\n+            \"cfs\",\n+            \"dim\",\n+            \"fnm\",\n+            \"dvm\",\n+            \"tmd\",\n+            \"doc\",\n+            \"tim\",\n+            \"pos\",\n+            \"cfe\",\n+            \"fdm\",\n+            \"nvm\"\n+        );\n+        List<String> fileTypesExcludedFromCaching = randomSubsetOf(allFileExtensions);\n+        Settings settings = Settings.builder()\n+            .putList(SNAPSHOT_CACHE_EXCLUDED_FILE_TYPES_SETTING.getKey(), fileTypesExcludedFromCaching)\n+            .build();\n+        testDirectories(true, true, recoveryState, settings, (directory, snapshotDirectory) -> {\n+            ThreadPoolExecutor executor = (ThreadPoolExecutor) snapshotDirectory.prewarmExecutor();\n+            assertBusy(() -> {\n+                assertThat(executor.getActiveCount(), equalTo(0));\n+                assertThat(executor.getQueue().size(), equalTo(0));\n+            });\n+\n+            assertThat(recoveryState.getStage(), equalTo(RecoveryState.Stage.DONE));\n+            for (RecoveryState.FileDetail fileDetail : recoveryState.getIndex().fileDetails()) {\n+                boolean fileHasExcludedType = fileTypesExcludedFromCaching.stream().anyMatch(type -> fileDetail.name().endsWith(type));\n+                assertThat(fileHasExcludedType, equalTo(false));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2989f667ca763500b9c6311ec03af81aeb2ef38"}, "originalPosition": 185}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "becd151ef0bf8b3be05a7829dd151026af4ca251", "author": {"user": {"login": "fcofdez", "name": "Francisco Fern\u00e1ndez Casta\u00f1o"}}, "url": "https://github.com/elastic/elasticsearch/commit/becd151ef0bf8b3be05a7829dd151026af4ca251", "committedDate": "2020-08-04T12:24:49Z", "message": "Address review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4985df57111f66815afa5ad17dc67eafa02af33d", "author": {"user": {"login": "fcofdez", "name": "Francisco Fern\u00e1ndez Casta\u00f1o"}}, "url": "https://github.com/elastic/elasticsearch/commit/4985df57111f66815afa5ad17dc67eafa02af33d", "committedDate": "2020-08-04T12:24:59Z", "message": "Merge remote-tracking branch 'origin/master' into searchable-snapshots-recovery-state"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eda436e0981d3a4ab31aa0684ff1830f4f49d820", "author": {"user": {"login": "fcofdez", "name": "Francisco Fern\u00e1ndez Casta\u00f1o"}}, "url": "https://github.com/elastic/elasticsearch/commit/eda436e0981d3a4ab31aa0684ff1830f4f49d820", "committedDate": "2020-08-05T10:43:17Z", "message": "Add test for reused files and add stronger assertions for"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "50ab07bf5e2fc1c511adb249fc571aa5f77f3f6d", "author": {"user": {"login": "fcofdez", "name": "Francisco Fern\u00e1ndez Casta\u00f1o"}}, "url": "https://github.com/elastic/elasticsearch/commit/50ab07bf5e2fc1c511adb249fc571aa5f77f3f6d", "committedDate": "2020-08-05T10:43:50Z", "message": "Merge remote-tracking branch 'origin/master' into searchable-snapshots-recovery-state"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxNTg5NDY0", "url": "https://github.com/elastic/elasticsearch/pull/60505#pullrequestreview-461589464", "createdAt": "2020-08-05T11:49:36Z", "commit": {"oid": "50ab07bf5e2fc1c511adb249fc571aa5f77f3f6d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3552, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}