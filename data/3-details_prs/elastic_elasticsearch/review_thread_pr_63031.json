{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk0OTg5NzU5", "number": 63031, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQwODoyMTo1NVrOEo7Adg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQwODoyNDowNVrOEo7DoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMzQ1MjcwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/DataTiersUsageTransportAction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQwODoyMTo1NVrOHaSikw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQwODoyMTo1NVrOHaSikw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzMyODc4Nw==", "bodyText": "As said above, I don't think we should mix the data role with the data tiers.", "url": "https://github.com/elastic/elasticsearch/pull/63031#discussion_r497328787", "createdAt": "2020-09-30T08:21:55Z", "author": {"login": "andreidan"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/DataTiersUsageTransportAction.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.cluster.node.stats.NodeStats;\n+import org.elasticsearch.action.admin.cluster.node.stats.NodesStatsResponse;\n+import org.elasticsearch.action.admin.indices.stats.CommonStatsFlags;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.node.DiscoveryNodeRole;\n+import org.elasticsearch.cluster.routing.RoutingNode;\n+import org.elasticsearch.cluster.routing.RoutingNodes;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.index.Index;\n+import org.elasticsearch.index.store.StoreStats;\n+import org.elasticsearch.protocol.xpack.XPackUsageRequest;\n+import org.elasticsearch.search.aggregations.metrics.TDigestState;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.core.action.XPackUsageFeatureAction;\n+import org.elasticsearch.xpack.core.action.XPackUsageFeatureResponse;\n+import org.elasticsearch.xpack.core.action.XPackUsageFeatureTransportAction;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n+\n+public class DataTiersUsageTransportAction extends XPackUsageFeatureTransportAction {\n+\n+    private final Client client;\n+\n+    @Inject\n+    public DataTiersUsageTransportAction(TransportService transportService, ClusterService clusterService,\n+                                         ThreadPool threadPool, ActionFilters actionFilters,\n+                                         IndexNameExpressionResolver indexNameExpressionResolver, Client client) {\n+        super(XPackUsageFeatureAction.DATA_TIERS.name(), transportService, clusterService,\n+            threadPool, actionFilters, indexNameExpressionResolver);\n+        this.client = client;\n+    }\n+\n+    @Override\n+    protected void masterOperation(Task task, XPackUsageRequest request, ClusterState state,\n+                                   ActionListener<XPackUsageFeatureResponse> listener) {\n+        client.admin().cluster().prepareNodesStats()\n+            .all()\n+            .setIndices(CommonStatsFlags.ALL)\n+            .execute(ActionListener.wrap(nodesStatsResponse -> {\n+                final RoutingNodes routingNodes = state.getRoutingNodes();\n+\n+                // First separate the nodes into separate tiers, note that nodes *may* be duplicated\n+                Map<String, List<NodeStats>> tierSpecificNodeStats = separateTiers(nodesStatsResponse);\n+\n+                // Generate tier specific stats for the nodes\n+                Map<String, DataTiersFeatureSetUsage.TierSpecificStats> tierSpecificStats = tierSpecificNodeStats.entrySet()\n+                    .stream().collect(Collectors.toMap(Map.Entry::getKey, ns -> calculateStats(ns.getValue(), routingNodes)));\n+\n+                listener.onResponse(new XPackUsageFeatureResponse(new DataTiersFeatureSetUsage(tierSpecificStats)));\n+            }, listener::onFailure));\n+    }\n+\n+    private static Map<String, List<NodeStats>> separateTiers(NodesStatsResponse nodesStatsResponse) {\n+        Map<String, List<NodeStats>> responses = new HashMap<>();\n+        DataTier.ALL_DATA_TIERS.forEach(tier ->\n+            responses.put(tier, nodesStatsResponse.getNodes().stream()\n+                .filter(stats -> stats.getNode().getRoles().stream()\n+                    .map(DiscoveryNodeRole::roleName)\n+                    .anyMatch(rn -> rn.equals(tier)))\n+                .collect(Collectors.toList())));\n+        // Also manually add the \"data\" role so we calculate statistics for it\n+        responses.put(DiscoveryNodeRole.DATA_ROLE.roleName(), nodesStatsResponse.getNodes().stream()\n+            .filter(stats -> stats.getNode().getRoles().stream().anyMatch(rn -> rn.equals(DiscoveryNodeRole.DATA_ROLE)))\n+            .collect(Collectors.toList()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2e2acb2c72d0ba9595e1ea5a41529c80e1cd8c9"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMzQ1Nzc4OnYy", "diffSide": "RIGHT", "path": "docs/reference/rest-api/usage.asciidoc", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQwODoyMzoxN1rOHaSlvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxOTo1ODo1NFrOHatMHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzMyOTU5OA==", "bodyText": "I don't think we should be reporting the data role under data_tiers. Trying to do tier routing etc. on the data role will fail. I'd rather not have this here as it could be confusing.\nI can see how this could be useful to have, but maybe it should be under another \"data\" or \"data_role\" object.\nWhat do you think?", "url": "https://github.com/elastic/elasticsearch/pull/63031#discussion_r497329598", "createdAt": "2020-09-30T08:23:17Z", "author": {"login": "andreidan"}, "path": "docs/reference/rest-api/usage.asciidoc", "diffHunk": "@@ -285,6 +285,70 @@ GET /_xpack/usage\n     \"enabled\" : true,\n     \"data_streams\" : 0,\n     \"indices_count\" : 0\n+  },\n+  \"data_tiers\" : {\n+    \"available\" : true,\n+    \"enabled\" : true,\n+    \"data_warm\" : {\n+      \"node_count\" : 0,\n+      \"index_count\" : 0,\n+      \"total_shard_count\" : 0,\n+      \"primary_shard_count\" : 0,\n+      \"doc_count\" : 0,\n+      \"total_size_bytes\" : 0,\n+      \"primary_size_bytes\" : 0,\n+      \"primary_shard_size_avg_bytes\" : 0,\n+      \"primary_shard_size_median_bytes\" : 0,\n+      \"primary_shard_size_mad_bytes\" : 0\n+    },\n+    \"data\" : {\n+      \"node_count\" : 1,\n+      \"index_count\" : 0,\n+      \"total_shard_count\" : 0,\n+      \"primary_shard_count\" : 0,\n+      \"doc_count\" : 0,\n+      \"total_size_bytes\" : 0,\n+      \"primary_size_bytes\" : 0,\n+      \"primary_shard_size_avg_bytes\" : 0,\n+      \"primary_shard_size_median_bytes\" : 0,\n+      \"primary_shard_size_mad_bytes\" : 0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2e2acb2c72d0ba9595e1ea5a41529c80e1cd8c9"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc1NjM5Nw==", "bodyText": "Technically it's not a tier, but what I was trying to capture was a way of determining whether the plain \"data\" role was being used in a deployment (ie, the user left it as the default setting).\nI'm not sure what a better format would be for presenting it though, I don't want to stick it in \"non_data_tier\" for example, because it still contains data and I wouldn't want to count master-only or ingest-only nodes as part of the tier.\nI'm open to suggestions though, just not sure of the best way to present it that can still retain the (useful) information", "url": "https://github.com/elastic/elasticsearch/pull/63031#discussion_r497756397", "createdAt": "2020-09-30T19:41:42Z", "author": {"login": "dakrone"}, "path": "docs/reference/rest-api/usage.asciidoc", "diffHunk": "@@ -285,6 +285,70 @@ GET /_xpack/usage\n     \"enabled\" : true,\n     \"data_streams\" : 0,\n     \"indices_count\" : 0\n+  },\n+  \"data_tiers\" : {\n+    \"available\" : true,\n+    \"enabled\" : true,\n+    \"data_warm\" : {\n+      \"node_count\" : 0,\n+      \"index_count\" : 0,\n+      \"total_shard_count\" : 0,\n+      \"primary_shard_count\" : 0,\n+      \"doc_count\" : 0,\n+      \"total_size_bytes\" : 0,\n+      \"primary_size_bytes\" : 0,\n+      \"primary_shard_size_avg_bytes\" : 0,\n+      \"primary_shard_size_median_bytes\" : 0,\n+      \"primary_shard_size_mad_bytes\" : 0\n+    },\n+    \"data\" : {\n+      \"node_count\" : 1,\n+      \"index_count\" : 0,\n+      \"total_shard_count\" : 0,\n+      \"primary_shard_count\" : 0,\n+      \"doc_count\" : 0,\n+      \"total_size_bytes\" : 0,\n+      \"primary_size_bytes\" : 0,\n+      \"primary_shard_size_avg_bytes\" : 0,\n+      \"primary_shard_size_median_bytes\" : 0,\n+      \"primary_shard_size_mad_bytes\" : 0", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzMyOTU5OA=="}, "originalCommit": {"oid": "b2e2acb2c72d0ba9595e1ea5a41529c80e1cd8c9"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc2NTQwNg==", "bodyText": "What do you think of reporting the usage as data_roles instead of data_tiers? (there is no data_role role, as the non tiered role is called data so this should't be confusing)\neg.\n \"data_roles\" : { \n    \"data\": {\n        ...\n      },\n    \"data_hot\": {\n        ... \n      }\n      ...\n    }", "url": "https://github.com/elastic/elasticsearch/pull/63031#discussion_r497765406", "createdAt": "2020-09-30T19:58:54Z", "author": {"login": "andreidan"}, "path": "docs/reference/rest-api/usage.asciidoc", "diffHunk": "@@ -285,6 +285,70 @@ GET /_xpack/usage\n     \"enabled\" : true,\n     \"data_streams\" : 0,\n     \"indices_count\" : 0\n+  },\n+  \"data_tiers\" : {\n+    \"available\" : true,\n+    \"enabled\" : true,\n+    \"data_warm\" : {\n+      \"node_count\" : 0,\n+      \"index_count\" : 0,\n+      \"total_shard_count\" : 0,\n+      \"primary_shard_count\" : 0,\n+      \"doc_count\" : 0,\n+      \"total_size_bytes\" : 0,\n+      \"primary_size_bytes\" : 0,\n+      \"primary_shard_size_avg_bytes\" : 0,\n+      \"primary_shard_size_median_bytes\" : 0,\n+      \"primary_shard_size_mad_bytes\" : 0\n+    },\n+    \"data\" : {\n+      \"node_count\" : 1,\n+      \"index_count\" : 0,\n+      \"total_shard_count\" : 0,\n+      \"primary_shard_count\" : 0,\n+      \"doc_count\" : 0,\n+      \"total_size_bytes\" : 0,\n+      \"primary_size_bytes\" : 0,\n+      \"primary_shard_size_avg_bytes\" : 0,\n+      \"primary_shard_size_median_bytes\" : 0,\n+      \"primary_shard_size_mad_bytes\" : 0", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzMyOTU5OA=="}, "originalCommit": {"oid": "b2e2acb2c72d0ba9595e1ea5a41529c80e1cd8c9"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMzQ1OTkwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/DataTiersUsageTransportAction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQwODoyMzo1MVrOHaSnEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQyMDo0Mjo1NFrOHauk3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzMyOTkzNw==", "bodyText": "shall we unit test these static methods?", "url": "https://github.com/elastic/elasticsearch/pull/63031#discussion_r497329937", "createdAt": "2020-09-30T08:23:51Z", "author": {"login": "andreidan"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/DataTiersUsageTransportAction.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.cluster.node.stats.NodeStats;\n+import org.elasticsearch.action.admin.cluster.node.stats.NodesStatsResponse;\n+import org.elasticsearch.action.admin.indices.stats.CommonStatsFlags;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.node.DiscoveryNodeRole;\n+import org.elasticsearch.cluster.routing.RoutingNode;\n+import org.elasticsearch.cluster.routing.RoutingNodes;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.index.Index;\n+import org.elasticsearch.index.store.StoreStats;\n+import org.elasticsearch.protocol.xpack.XPackUsageRequest;\n+import org.elasticsearch.search.aggregations.metrics.TDigestState;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.core.action.XPackUsageFeatureAction;\n+import org.elasticsearch.xpack.core.action.XPackUsageFeatureResponse;\n+import org.elasticsearch.xpack.core.action.XPackUsageFeatureTransportAction;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n+\n+public class DataTiersUsageTransportAction extends XPackUsageFeatureTransportAction {\n+\n+    private final Client client;\n+\n+    @Inject\n+    public DataTiersUsageTransportAction(TransportService transportService, ClusterService clusterService,\n+                                         ThreadPool threadPool, ActionFilters actionFilters,\n+                                         IndexNameExpressionResolver indexNameExpressionResolver, Client client) {\n+        super(XPackUsageFeatureAction.DATA_TIERS.name(), transportService, clusterService,\n+            threadPool, actionFilters, indexNameExpressionResolver);\n+        this.client = client;\n+    }\n+\n+    @Override\n+    protected void masterOperation(Task task, XPackUsageRequest request, ClusterState state,\n+                                   ActionListener<XPackUsageFeatureResponse> listener) {\n+        client.admin().cluster().prepareNodesStats()\n+            .all()\n+            .setIndices(CommonStatsFlags.ALL)\n+            .execute(ActionListener.wrap(nodesStatsResponse -> {\n+                final RoutingNodes routingNodes = state.getRoutingNodes();\n+\n+                // First separate the nodes into separate tiers, note that nodes *may* be duplicated\n+                Map<String, List<NodeStats>> tierSpecificNodeStats = separateTiers(nodesStatsResponse);\n+\n+                // Generate tier specific stats for the nodes\n+                Map<String, DataTiersFeatureSetUsage.TierSpecificStats> tierSpecificStats = tierSpecificNodeStats.entrySet()\n+                    .stream().collect(Collectors.toMap(Map.Entry::getKey, ns -> calculateStats(ns.getValue(), routingNodes)));\n+\n+                listener.onResponse(new XPackUsageFeatureResponse(new DataTiersFeatureSetUsage(tierSpecificStats)));\n+            }, listener::onFailure));\n+    }\n+\n+    private static Map<String, List<NodeStats>> separateTiers(NodesStatsResponse nodesStatsResponse) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2e2acb2c72d0ba9595e1ea5a41529c80e1cd8c9"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc4ODEyNA==", "bodyText": "I added a unit test for this one (and the MAD calculation), the larger one would require so much boilerplate and/or mocking as to be pretty useless as a unit test (hence the integration test for it)", "url": "https://github.com/elastic/elasticsearch/pull/63031#discussion_r497788124", "createdAt": "2020-09-30T20:42:54Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/DataTiersUsageTransportAction.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.cluster.node.stats.NodeStats;\n+import org.elasticsearch.action.admin.cluster.node.stats.NodesStatsResponse;\n+import org.elasticsearch.action.admin.indices.stats.CommonStatsFlags;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.node.DiscoveryNodeRole;\n+import org.elasticsearch.cluster.routing.RoutingNode;\n+import org.elasticsearch.cluster.routing.RoutingNodes;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.index.Index;\n+import org.elasticsearch.index.store.StoreStats;\n+import org.elasticsearch.protocol.xpack.XPackUsageRequest;\n+import org.elasticsearch.search.aggregations.metrics.TDigestState;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.core.action.XPackUsageFeatureAction;\n+import org.elasticsearch.xpack.core.action.XPackUsageFeatureResponse;\n+import org.elasticsearch.xpack.core.action.XPackUsageFeatureTransportAction;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n+\n+public class DataTiersUsageTransportAction extends XPackUsageFeatureTransportAction {\n+\n+    private final Client client;\n+\n+    @Inject\n+    public DataTiersUsageTransportAction(TransportService transportService, ClusterService clusterService,\n+                                         ThreadPool threadPool, ActionFilters actionFilters,\n+                                         IndexNameExpressionResolver indexNameExpressionResolver, Client client) {\n+        super(XPackUsageFeatureAction.DATA_TIERS.name(), transportService, clusterService,\n+            threadPool, actionFilters, indexNameExpressionResolver);\n+        this.client = client;\n+    }\n+\n+    @Override\n+    protected void masterOperation(Task task, XPackUsageRequest request, ClusterState state,\n+                                   ActionListener<XPackUsageFeatureResponse> listener) {\n+        client.admin().cluster().prepareNodesStats()\n+            .all()\n+            .setIndices(CommonStatsFlags.ALL)\n+            .execute(ActionListener.wrap(nodesStatsResponse -> {\n+                final RoutingNodes routingNodes = state.getRoutingNodes();\n+\n+                // First separate the nodes into separate tiers, note that nodes *may* be duplicated\n+                Map<String, List<NodeStats>> tierSpecificNodeStats = separateTiers(nodesStatsResponse);\n+\n+                // Generate tier specific stats for the nodes\n+                Map<String, DataTiersFeatureSetUsage.TierSpecificStats> tierSpecificStats = tierSpecificNodeStats.entrySet()\n+                    .stream().collect(Collectors.toMap(Map.Entry::getKey, ns -> calculateStats(ns.getValue(), routingNodes)));\n+\n+                listener.onResponse(new XPackUsageFeatureResponse(new DataTiersFeatureSetUsage(tierSpecificStats)));\n+            }, listener::onFailure));\n+    }\n+\n+    private static Map<String, List<NodeStats>> separateTiers(NodesStatsResponse nodesStatsResponse) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzMyOTkzNw=="}, "originalCommit": {"oid": "b2e2acb2c72d0ba9595e1ea5a41529c80e1cd8c9"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMzQ2MDgxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/DataTiersUsageTransportAction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQwODoyNDowNVrOHaSnow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQwODoyNDowNVrOHaSnow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzMzMDA4Mw==", "bodyText": "can we please verify this with unit tests?", "url": "https://github.com/elastic/elasticsearch/pull/63031#discussion_r497330083", "createdAt": "2020-09-30T08:24:05Z", "author": {"login": "andreidan"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/DataTiersUsageTransportAction.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.cluster.node.stats.NodeStats;\n+import org.elasticsearch.action.admin.cluster.node.stats.NodesStatsResponse;\n+import org.elasticsearch.action.admin.indices.stats.CommonStatsFlags;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.node.DiscoveryNodeRole;\n+import org.elasticsearch.cluster.routing.RoutingNode;\n+import org.elasticsearch.cluster.routing.RoutingNodes;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.index.Index;\n+import org.elasticsearch.index.store.StoreStats;\n+import org.elasticsearch.protocol.xpack.XPackUsageRequest;\n+import org.elasticsearch.search.aggregations.metrics.TDigestState;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.core.action.XPackUsageFeatureAction;\n+import org.elasticsearch.xpack.core.action.XPackUsageFeatureResponse;\n+import org.elasticsearch.xpack.core.action.XPackUsageFeatureTransportAction;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n+\n+public class DataTiersUsageTransportAction extends XPackUsageFeatureTransportAction {\n+\n+    private final Client client;\n+\n+    @Inject\n+    public DataTiersUsageTransportAction(TransportService transportService, ClusterService clusterService,\n+                                         ThreadPool threadPool, ActionFilters actionFilters,\n+                                         IndexNameExpressionResolver indexNameExpressionResolver, Client client) {\n+        super(XPackUsageFeatureAction.DATA_TIERS.name(), transportService, clusterService,\n+            threadPool, actionFilters, indexNameExpressionResolver);\n+        this.client = client;\n+    }\n+\n+    @Override\n+    protected void masterOperation(Task task, XPackUsageRequest request, ClusterState state,\n+                                   ActionListener<XPackUsageFeatureResponse> listener) {\n+        client.admin().cluster().prepareNodesStats()\n+            .all()\n+            .setIndices(CommonStatsFlags.ALL)\n+            .execute(ActionListener.wrap(nodesStatsResponse -> {\n+                final RoutingNodes routingNodes = state.getRoutingNodes();\n+\n+                // First separate the nodes into separate tiers, note that nodes *may* be duplicated\n+                Map<String, List<NodeStats>> tierSpecificNodeStats = separateTiers(nodesStatsResponse);\n+\n+                // Generate tier specific stats for the nodes\n+                Map<String, DataTiersFeatureSetUsage.TierSpecificStats> tierSpecificStats = tierSpecificNodeStats.entrySet()\n+                    .stream().collect(Collectors.toMap(Map.Entry::getKey, ns -> calculateStats(ns.getValue(), routingNodes)));\n+\n+                listener.onResponse(new XPackUsageFeatureResponse(new DataTiersFeatureSetUsage(tierSpecificStats)));\n+            }, listener::onFailure));\n+    }\n+\n+    private static Map<String, List<NodeStats>> separateTiers(NodesStatsResponse nodesStatsResponse) {\n+        Map<String, List<NodeStats>> responses = new HashMap<>();\n+        DataTier.ALL_DATA_TIERS.forEach(tier ->\n+            responses.put(tier, nodesStatsResponse.getNodes().stream()\n+                .filter(stats -> stats.getNode().getRoles().stream()\n+                    .map(DiscoveryNodeRole::roleName)\n+                    .anyMatch(rn -> rn.equals(tier)))\n+                .collect(Collectors.toList())));\n+        // Also manually add the \"data\" role so we calculate statistics for it\n+        responses.put(DiscoveryNodeRole.DATA_ROLE.roleName(), nodesStatsResponse.getNodes().stream()\n+            .filter(stats -> stats.getNode().getRoles().stream().anyMatch(rn -> rn.equals(DiscoveryNodeRole.DATA_ROLE)))\n+            .collect(Collectors.toList()));\n+        return responses;\n+    }\n+\n+    private DataTiersFeatureSetUsage.TierSpecificStats calculateStats(List<NodeStats> nodesStats, RoutingNodes routingNodes) {\n+        int nodeCount = 0;\n+        int indexCount = 0;\n+        int totalShardCount = 0;\n+        long totalByteCount = 0;\n+        long docCount = 0;\n+        final AtomicInteger primaryShardCount = new AtomicInteger(0);\n+        final AtomicLong primaryByteCount = new AtomicLong(0);\n+        final TDigestState valueSketch = new TDigestState(1000);\n+        for (NodeStats nodeStats : nodesStats) {\n+            nodeCount++;\n+            totalByteCount += nodeStats.getIndices().getStore().getSizeInBytes();\n+            docCount += nodeStats.getIndices().getDocs().getCount();\n+            String nodeId = nodeStats.getNode().getId();\n+            final RoutingNode node = routingNodes.node(nodeId);\n+            if (node != null) {\n+                totalShardCount += node.shardsWithState(ShardRoutingState.STARTED).size();\n+                Set<Index> indicesOnNode = node.shardsWithState(ShardRoutingState.STARTED).stream()\n+                    .map(ShardRouting::index)\n+                    .collect(Collectors.toSet());\n+                indexCount += indicesOnNode.size();\n+                indicesOnNode.forEach(index -> {\n+                    nodeStats.getIndices().getShardStats(index).stream()\n+                        .filter(shardStats -> shardStats.getPrimary().getStore() != null)\n+                        .forEach(shardStats -> {\n+                            StoreStats primaryStoreStats = shardStats.getPrimary().getStore();\n+                            // If storeStats is null, it means this is not a replica\n+                            primaryShardCount.incrementAndGet();\n+                            long primarySize = primaryStoreStats.getSizeInBytes();\n+                            primaryByteCount.addAndGet(primarySize);\n+                            valueSketch.add(primarySize);\n+                        });\n+                });\n+            }\n+        }\n+        long primaryShardSizeMedian = (long) valueSketch.quantile(0.5);\n+        long primaryShardSizeMAD = computeMedianAbsoluteDeviation(valueSketch);\n+        return new DataTiersFeatureSetUsage.TierSpecificStats(nodeCount, indexCount, totalShardCount, primaryShardCount.get(), docCount,\n+            totalByteCount, primaryByteCount.get(), primaryShardSizeMedian, primaryShardSizeMAD);\n+    }\n+\n+    private static long computeMedianAbsoluteDeviation(TDigestState valuesSketch) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2e2acb2c72d0ba9595e1ea5a41529c80e1cd8c9"}, "originalPosition": 132}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3268, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}