{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIxNTY5ODM0", "number": 65054, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQxMDozOTozM1rOE5ZFRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxMjoyNDozMlrOE7hQsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NjE1MjM2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/DefaultSearchContext.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQxMDozOTozM1rOHz0jog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQxMTo0NjozNVrOHz5EBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDEwMDUxNA==", "bodyText": "looks like if you do indexService.mapperService() you can go ahead and remove mapperService() from SearchContext.", "url": "https://github.com/elastic/elasticsearch/pull/65054#discussion_r524100514", "createdAt": "2020-11-16T10:39:33Z", "author": {"login": "javanna"}, "path": "server/src/main/java/org/elasticsearch/search/DefaultSearchContext.java", "diffHunk": "@@ -706,6 +706,11 @@ public QuerySearchResult queryResult() {\n         return queryResult;\n     }\n \n+    @Override\n+    public NestedDocuments getNestedDocuments() {\n+        return new NestedDocuments(mapperService(), bitsetFilterCache()::getBitSetProducer);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b016321b706115122b75cc0db50a26d0759a5ee0"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDE3NDM0Mg==", "bodyText": "Done! Good spot.", "url": "https://github.com/elastic/elasticsearch/pull/65054#discussion_r524174342", "createdAt": "2020-11-16T11:46:35Z", "author": {"login": "romseygeek"}, "path": "server/src/main/java/org/elasticsearch/search/DefaultSearchContext.java", "diffHunk": "@@ -706,6 +706,11 @@ public QuerySearchResult queryResult() {\n         return queryResult;\n     }\n \n+    @Override\n+    public NestedDocuments getNestedDocuments() {\n+        return new NestedDocuments(mapperService(), bitsetFilterCache()::getBitSetProducer);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDEwMDUxNA=="}, "originalCommit": {"oid": "b016321b706115122b75cc0db50a26d0759a5ee0"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODQ2Mzg0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/NestedDocuments.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxMjoyNDozMlrOH3NoPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxMjoyNDozMlrOH3NoPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY1NzAyMw==", "bodyText": "We don't really need a bitset here ? The child filter always move forward so we can build the Scorer instead and save some memory. That's what the current impl does so I'd prefer that we keep this logic.", "url": "https://github.com/elastic/elasticsearch/pull/65054#discussion_r527657023", "createdAt": "2020-11-20T12:24:32Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/search/NestedDocuments.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.search;\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.join.BitSetProducer;\n+import org.apache.lucene.util.BitSet;\n+import org.elasticsearch.common.lucene.search.Queries;\n+import org.elasticsearch.index.mapper.MapperService;\n+import org.elasticsearch.index.mapper.ObjectMapper;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+/**\n+ * Manages loading information about nested documents\n+ */\n+public class NestedDocuments {\n+\n+    private final Map<String, BitSetProducer> parentObjectFilters = new HashMap<>();\n+    private final BitSetProducer parentDocumentFilter;\n+    private final MapperService mapperService;\n+\n+    /**\n+     * Create a new NestedDocuments object for an index\n+     * @param mapperService     the index's MapperService\n+     * @param filterProducer    a function to build BitSetProducers from filter queries\n+     */\n+    public NestedDocuments(MapperService mapperService, Function<Query, BitSetProducer> filterProducer) {\n+        this.mapperService = mapperService;\n+        if (mapperService.hasNested() == false) {\n+            this.parentDocumentFilter = null;\n+        } else {\n+            this.parentDocumentFilter = filterProducer.apply(Queries.newNonNestedFilter());\n+            for (ObjectMapper mapper : mapperService.documentMapper().mappers().objectMappers().values()) {\n+                if (mapper.nested().isNested() == false) {\n+                    continue;\n+                }\n+                parentObjectFilters.put(mapper.name(),\n+                    filterProducer.apply(mapper.nestedTypeFilter()));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns a LeafNestedDocuments for an index segment\n+     */\n+    public LeafNestedDocuments getLeafNestedDocuments(LeafReaderContext ctx) throws IOException {\n+        if (parentDocumentFilter == null) {\n+            return LeafNestedDocuments.NO_NESTED_MAPPERS;\n+        }\n+        return new HasNestedDocuments(ctx);\n+    }\n+\n+    /**\n+     * Given an object path, returns whether or not any of its parents are plain objects\n+     */\n+    public boolean hasNonNestedParent(String path) {\n+        return mapperService.documentMapper().hasNonNestedParent(path);\n+    }\n+\n+    private class HasNestedDocuments implements LeafNestedDocuments {\n+\n+        final LeafReaderContext ctx;\n+        final BitSet parentFilter;\n+        final Map<String, BitSet> objectFilters = new HashMap<>();\n+\n+        int doc = -1;\n+        int rootDoc = -1;\n+        SearchHit.NestedIdentity nestedIdentity = null;\n+\n+        private HasNestedDocuments(LeafReaderContext ctx) throws IOException {\n+            this.ctx = ctx;\n+            this.parentFilter = parentDocumentFilter.getBitSet(ctx);\n+            for (Map.Entry<String, BitSetProducer> filter : parentObjectFilters.entrySet()) {\n+                BitSet bits = filter.getValue().getBitSet(ctx);\n+                if (bits != null) {\n+                    objectFilters.put(filter.getKey(), bits);\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public SearchHit.NestedIdentity advance(int doc) {\n+            assert doc >= 0 && doc < ctx.reader().maxDoc();\n+            if (parentFilter.get(doc)) {\n+                // parent doc, no nested identity\n+                this.nestedIdentity = null;\n+                this.doc = doc;\n+                this.rootDoc = doc;\n+                return null;\n+            } else {\n+                this.doc = doc;\n+                this.rootDoc = parentFilter.nextSetBit(doc);\n+                return this.nestedIdentity = loadNestedIdentity();\n+            }\n+        }\n+\n+        @Override\n+        public int doc() {\n+            assert doc != -1 : \"Called doc() when unpositioned\";\n+            return doc;\n+        }\n+\n+        @Override\n+        public int rootDoc() {\n+            assert doc != -1 : \"Called rootDoc() when unpositioned\";\n+            return rootDoc;\n+        }\n+\n+        @Override\n+        public SearchHit.NestedIdentity nestedIdentity() {\n+            assert doc != -1 : \"Called nestedIdentity() when unpositioned\";\n+            return nestedIdentity;\n+        }\n+\n+        private SearchHit.NestedIdentity loadNestedIdentity() {\n+            String path = null;\n+            for (Map.Entry<String, BitSet> objectFilter : objectFilters.entrySet()) {\n+                if (objectFilter.getValue().get(doc)) {\n+                    if (path == null || path.length() > objectFilter.getKey().length()) {\n+                        path = objectFilter.getKey();\n+                    }\n+                }\n+            }\n+            if (path == null) {\n+                throw new IllegalStateException(\"Cannot find object path for document \" + doc);\n+            }\n+            SearchHit.NestedIdentity ni = null;\n+            int currentLevelDoc = doc;\n+            int parentNameLength;\n+            while (path != null) {\n+                String parent = mapperService.documentMapper().getNestedParent(path);\n+                BitSet childBitSet = objectFilters.get(path);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60ddaf754922eba21785a1ac7272bcf0207c6b06"}, "originalPosition": 154}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3020, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}