{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU1MTY4ODk0", "number": 60050, "reviewThreads": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMDozMjo0OFrOERZJmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQyMTo1NzowN1rOEkQTNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NjczMzA3OnYy", "diffSide": "RIGHT", "path": "docs/reference/mapping/types/numeric.asciidoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMDozMjo0OFrOG2E6lw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMDozMjo0OFrOG2E6lw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM1NjgyMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Accepts `true` (default) and `false`. Not applicable for unsigned_long.\n          \n          \n            \n                Accepts `true` (default) and `false`. Not applicable for `unsigned_long`.", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r459356823", "createdAt": "2020-07-23T10:32:48Z", "author": {"login": "jpountz"}, "path": "docs/reference/mapping/types/numeric.asciidoc", "diffHunk": "@@ -115,7 +116,7 @@ The following parameters are accepted by numeric types:\n <<coerce,`coerce`>>::\n \n     Try to convert strings to numbers and truncate fractions for integers.\n-    Accepts `true` (default) and `false`.\n+    Accepts `true` (default) and `false`. Not applicable for unsigned_long.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dffd748747fabf2be412e878db904db907caa6e1"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NjczNDA2OnYy", "diffSide": "RIGHT", "path": "docs/reference/mapping/types/unsigned_long.asciidoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMDozMzoxN1rOG2E7Sw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMDozMzoxN1rOG2E7Sw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM1NzAwMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            At index-time, an indexed value is converted to the singed long range:\n          \n          \n            \n            At index-time, an indexed value is converted to the signed long range:", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r459357003", "createdAt": "2020-07-23T10:33:17Z", "author": {"login": "jpountz"}, "path": "docs/reference/mapping/types/unsigned_long.asciidoc", "diffHunk": "@@ -0,0 +1,147 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+\n+[[unsigned-long]]\n+=== Unsigned long data type\n+++++\n+<titleabbrev>Unsigned long</titleabbrev>\n+++++\n+\n+Unsigned long is a numeric field type that represents an unsigned 64-bit\n+integer with a minimum value of 0 and a maximum value of +2^64^-1+\n+(from 0 to 18446744073709551615).\n+\n+At index-time, an indexed value is converted to the singed long range:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dffd748747fabf2be412e878db904db907caa6e1"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NjczNTE5OnYy", "diffSide": "RIGHT", "path": "docs/reference/mapping/types/unsigned_long.asciidoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMDozMzozM1rOG2E76w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMDozMzozM1rOG2E76w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM1NzE2Mw==", "bodyText": "I'm unsure whether this implementation detail is worth sharing.", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r459357163", "createdAt": "2020-07-23T10:33:33Z", "author": {"login": "jpountz"}, "path": "docs/reference/mapping/types/unsigned_long.asciidoc", "diffHunk": "@@ -0,0 +1,147 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+\n+[[unsigned-long]]\n+=== Unsigned long data type\n+++++\n+<titleabbrev>Unsigned long</titleabbrev>\n+++++\n+\n+Unsigned long is a numeric field type that represents an unsigned 64-bit\n+integer with a minimum value of 0 and a maximum value of +2^64^-1+\n+(from 0 to 18446744073709551615).\n+\n+At index-time, an indexed value is converted to the singed long range:\n+[- 9223372036854775808, 9223372036854775807] by subtracting +2^63^+ from it\n+and stored as a singed long taking 8 bytes.\n+At query-time, the same conversion is done on query terms.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dffd748747fabf2be412e878db904db907caa6e1"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NjczODc4OnYy", "diffSide": "RIGHT", "path": "docs/reference/mapping/types/unsigned_long.asciidoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMDozNDo0MVrOG2E-CA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMDozNDo0MVrOG2E-CA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM1NzcwNA==", "bodyText": "In Elasticsearch range queries with the from/to notation, the \"to\" bound is exclusive, while I think it's inclusive in your example here. Maybe be explicit by saying \"to XYZ included\" ?", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r459357704", "createdAt": "2020-07-23T10:34:41Z", "author": {"login": "jpountz"}, "path": "docs/reference/mapping/types/unsigned_long.asciidoc", "diffHunk": "@@ -0,0 +1,147 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+\n+[[unsigned-long]]\n+=== Unsigned long data type\n+++++\n+<titleabbrev>Unsigned long</titleabbrev>\n+++++\n+\n+Unsigned long is a numeric field type that represents an unsigned 64-bit\n+integer with a minimum value of 0 and a maximum value of +2^64^-1+\n+(from 0 to 18446744073709551615).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dffd748747fabf2be412e878db904db907caa6e1"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2Njc0MzE5OnYy", "diffSide": "RIGHT", "path": "docs/reference/mapping/types/unsigned_long.asciidoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMDozNjoxNlrOG2FAyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMDozNjoxNlrOG2FAyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM1ODQxMA==", "bodyText": "Clarify what happens in that case?", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r459358410", "createdAt": "2020-07-23T10:36:16Z", "author": {"login": "jpountz"}, "path": "docs/reference/mapping/types/unsigned_long.asciidoc", "diffHunk": "@@ -0,0 +1,147 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+\n+[[unsigned-long]]\n+=== Unsigned long data type\n+++++\n+<titleabbrev>Unsigned long</titleabbrev>\n+++++\n+\n+Unsigned long is a numeric field type that represents an unsigned 64-bit\n+integer with a minimum value of 0 and a maximum value of +2^64^-1+\n+(from 0 to 18446744073709551615).\n+\n+At index-time, an indexed value is converted to the singed long range:\n+[- 9223372036854775808, 9223372036854775807] by subtracting +2^63^+ from it\n+and stored as a singed long taking 8 bytes.\n+At query-time, the same conversion is done on query terms.\n+\n+[source,console]\n+--------------------------------------------------\n+PUT my_index\n+{\n+  \"mappings\": {\n+    \"properties\": {\n+      \"my_counter\": {\n+        \"type\": \"unsigned_long\"\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+\n+Unsigned long can be indexed in a numeric or string form,\n+representing integer values in the range [0, 18446744073709551615].\n+They can't have a decimal part.\n+\n+[source,console]\n+--------------------------------\n+POST /my_index/_bulk?refresh\n+{\"index\":{\"_id\":1}}\n+{\"my_counter\": 0}\n+{\"index\":{\"_id\":2}}\n+{\"my_counter\": 9223372036854775808}\n+{\"index\":{\"_id\":3}}\n+{\"my_counter\": 18446744073709551614}\n+{\"index\":{\"_id\":4}}\n+{\"my_counter\": 18446744073709551615}\n+--------------------------------\n+//TEST[continued]\n+\n+Term queries accept any numbers in a numeric or string form.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"term\" : {\n+            \"my_counter\" : 18446744073709551615\n+        }\n+    }\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+Range queries can contain ranges with decimal parts.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dffd748747fabf2be412e878db904db907caa6e1"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2Njc0ODA0OnYy", "diffSide": "RIGHT", "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/json/JsonXContentParser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMDozNzo0OFrOG2FDtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMDozNzo0OFrOG2FDtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM1OTE1Nw==", "bodyText": "do we really need to have support for unsigned longs at such a low level, or could we implement parsing of unsigned longs in the field mapper directly?", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r459359157", "createdAt": "2020-07-23T10:37:48Z", "author": {"login": "jpountz"}, "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/json/JsonXContentParser.java", "diffHunk": "@@ -166,6 +167,26 @@ public long doLongValue() throws IOException {\n         return parser.getLongValue();\n     }\n \n+    @Override\n+    protected long doUnsignedLongValue() throws IOException {\n+        JsonParser.NumberType numberType = parser.getNumberType();\n+        if ((numberType == JsonParser.NumberType.INT) || (numberType == JsonParser.NumberType.LONG)) {\n+            long longValue = parser.getLongValue();\n+            if (longValue < 0) {\n+                throw new IllegalArgumentException(\"Value [\" + longValue + \"] is out of range for unsigned long.\");\n+            }\n+            return longValue;\n+        } else if (numberType == JsonParser.NumberType.BIG_INTEGER) {\n+            BigInteger bigIntegerValue = parser.getBigIntegerValue();\n+            if (bigIntegerValue.compareTo(BIGINTEGER_MAX_UNSIGNED_LONG_VALUE) > 0 || bigIntegerValue.compareTo(BigInteger.ZERO) < 0) {\n+                throw new IllegalArgumentException(\"Value [\" + bigIntegerValue + \"] is out of range for unsigned long\");\n+            }\n+            return bigIntegerValue.longValue();\n+        } else { // for all other value types including numbers with decimal parts\n+            throw new IllegalArgumentException(\"For input string: [\" + parser.getValueAsString() + \"].\");\n+        }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dffd748747fabf2be412e878db904db907caa6e1"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2Njc4MTU2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/mapper-unsigned-long/src/main/java/org/elasticsearch/xpack/unsignedlong/UnsignedLongFieldMapper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMDo0ODo1OFrOG2FYGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMDo0ODo1OFrOG2FYGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM2NDM3OQ==", "bodyText": "without context I'd guess that this is doing a cast, maybe make the method name more explicit, e.g. unsignedToSortableSignedLong", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r459364379", "createdAt": "2020-07-23T10:48:58Z", "author": {"login": "jpountz"}, "path": "x-pack/plugin/mapper-unsigned-long/src/main/java/org/elasticsearch/xpack/unsignedlong/UnsignedLongFieldMapper.java", "diffHunk": "@@ -0,0 +1,519 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.unsignedlong;\n+\n+import com.fasterxml.jackson.core.JsonParseException;\n+import com.fasterxml.jackson.core.exc.InputCoercionException;\n+import org.apache.lucene.document.Field;\n+import org.apache.lucene.document.FieldType;\n+import org.apache.lucene.document.LongPoint;\n+import org.apache.lucene.document.SortedNumericDocValuesField;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.BoostQuery;\n+import org.apache.lucene.search.DocValuesFieldExistsQuery;\n+import org.apache.lucene.search.IndexOrDocValuesQuery;\n+import org.apache.lucene.search.IndexSortSortedNumericDocValuesRangeQuery;\n+import org.apache.lucene.search.MatchNoDocsQuery;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.TermQuery;\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.common.Explicit;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.support.XContentMapValues;\n+import org.elasticsearch.index.fielddata.IndexFieldData;\n+import org.elasticsearch.index.fielddata.IndexNumericFieldData;\n+import org.elasticsearch.index.fielddata.plain.SortedNumericIndexFieldData;\n+import org.elasticsearch.index.mapper.FieldMapper;\n+import org.elasticsearch.index.mapper.FieldNamesFieldMapper;\n+import org.elasticsearch.index.mapper.Mapper;\n+import org.elasticsearch.index.mapper.MapperParsingException;\n+import org.elasticsearch.index.mapper.NumberFieldMapper;\n+import org.elasticsearch.index.mapper.ParseContext;\n+import org.elasticsearch.index.mapper.SimpleMappedFieldType;\n+import org.elasticsearch.index.mapper.TextSearchInfo;\n+import org.elasticsearch.index.mapper.TypeParsers;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.search.DocValueFormat;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.time.ZoneId;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+public class UnsignedLongFieldMapper extends FieldMapper {\n+    protected static long MASK_2_63 = 0x8000000000000000L;\n+    private static BigInteger BIGINTEGER_2_64_MINUS_ONE = BigInteger.ONE.shiftLeft(64).subtract(BigInteger.ONE); // 2^64 -1\n+    private static BigDecimal BIGDECIMAL_2_64_MINUS_ONE = new BigDecimal(BIGINTEGER_2_64_MINUS_ONE);\n+\n+    public static final String CONTENT_TYPE = \"unsigned_long\";\n+    // use the same default as numbers\n+    private static final FieldType FIELD_TYPE = new FieldType();\n+    static {\n+        FIELD_TYPE.setIndexOptions(IndexOptions.DOCS);\n+    }\n+\n+    public static class Builder extends FieldMapper.Builder<Builder> {\n+\n+        private Boolean ignoreMalformed;\n+        private String nullValue;\n+\n+        public Builder(String name) {\n+            super(name, FIELD_TYPE);\n+            builder = this;\n+        }\n+\n+        public Builder ignoreMalformed(boolean ignoreMalformed) {\n+            this.ignoreMalformed = ignoreMalformed;\n+            return builder;\n+        }\n+\n+        @Override\n+        public Builder indexOptions(IndexOptions indexOptions) {\n+            throw new MapperParsingException(\"index_options not allowed in field [\" + name + \"] of type [\" + CONTENT_TYPE + \"]\");\n+        }\n+\n+        protected Explicit<Boolean> ignoreMalformed(BuilderContext context) {\n+            if (ignoreMalformed != null) {\n+                return new Explicit<>(ignoreMalformed, true);\n+            }\n+            if (context.indexSettings() != null) {\n+                return new Explicit<>(IGNORE_MALFORMED_SETTING.get(context.indexSettings()), false);\n+            }\n+            return NumberFieldMapper.Defaults.IGNORE_MALFORMED;\n+        }\n+\n+        public Builder nullValue(String nullValue) {\n+            this.nullValue = nullValue;\n+            return this;\n+        }\n+\n+        @Override\n+        public UnsignedLongFieldMapper build(BuilderContext context) {\n+            UnsignedLongFieldType type = new UnsignedLongFieldType(buildFullName(context), indexed, hasDocValues, meta);\n+            return new UnsignedLongFieldMapper(\n+                name,\n+                fieldType,\n+                type,\n+                ignoreMalformed(context),\n+                multiFieldsBuilder.build(this, context),\n+                copyTo,\n+                nullValue\n+            );\n+        }\n+    }\n+\n+    public static class TypeParser implements Mapper.TypeParser {\n+        @Override\n+        public Mapper.Builder<?> parse(String name, Map<String, Object> node, ParserContext parserContext) throws MapperParsingException {\n+            Builder builder = new Builder(name);\n+            TypeParsers.parseField(builder, name, node, parserContext);\n+            for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(); iterator.hasNext();) {\n+                Map.Entry<String, Object> entry = iterator.next();\n+                String propName = entry.getKey();\n+                Object propNode = entry.getValue();\n+                if (propName.equals(\"null_value\")) {\n+                    if (propNode == null) {\n+                        throw new MapperParsingException(\"Property [null_value] cannot be null.\");\n+                    }\n+                    parseUnsignedLong(propNode); // confirm that null_value is a proper unsigned_long\n+                    String nullValue = (propNode instanceof BytesRef) ? ((BytesRef) propNode).utf8ToString() : propNode.toString();\n+                    builder.nullValue(nullValue);\n+                    iterator.remove();\n+                } else if (propName.equals(\"ignore_malformed\")) {\n+                    builder.ignoreMalformed(XContentMapValues.nodeBooleanValue(propNode, name + \".ignore_malformed\"));\n+                    iterator.remove();\n+                }\n+            }\n+            return builder;\n+        }\n+    }\n+\n+    public static final class UnsignedLongFieldType extends SimpleMappedFieldType {\n+\n+        public UnsignedLongFieldType(String name, boolean indexed, boolean hasDocValues, Map<String, String> meta) {\n+            super(name, indexed, hasDocValues, TextSearchInfo.SIMPLE_MATCH_ONLY, meta);\n+        }\n+\n+        public UnsignedLongFieldType(String name) {\n+            this(name, true, true, Collections.emptyMap());\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return CONTENT_TYPE;\n+        }\n+\n+        @Override\n+        public Query existsQuery(QueryShardContext context) {\n+            if (hasDocValues()) {\n+                return new DocValuesFieldExistsQuery(name());\n+            } else {\n+                return new TermQuery(new Term(FieldNamesFieldMapper.NAME, name()));\n+            }\n+        }\n+\n+        @Override\n+        public Query termQuery(Object value, QueryShardContext context) {\n+            failIfNotIndexed();\n+            Long longValue = parseTerm(value);\n+            if (longValue == null) {\n+                return new MatchNoDocsQuery();\n+            }\n+            Query query = LongPoint.newExactQuery(name(), convertToSignedLong(longValue));\n+            if (boost() != 1f) {\n+                query = new BoostQuery(query, boost());\n+            }\n+            return query;\n+        }\n+\n+        @Override\n+        public Query termsQuery(List<?> values, QueryShardContext context) {\n+            failIfNotIndexed();\n+            long[] lvalues = new long[values.size()];\n+            int upTo = 0;\n+            for (int i = 0; i < values.size(); i++) {\n+                Object value = values.get(i);\n+                Long longValue = parseTerm(value);\n+                if (longValue != null) {\n+                    lvalues[upTo++] = convertToSignedLong(longValue);\n+                }\n+            }\n+            if (upTo == 0) {\n+                return new MatchNoDocsQuery();\n+            }\n+            if (upTo != lvalues.length) {\n+                lvalues = Arrays.copyOf(lvalues, upTo);\n+            }\n+            Query query = LongPoint.newSetQuery(name(), lvalues);\n+            if (boost() != 1f) {\n+                query = new BoostQuery(query, boost());\n+            }\n+            return query;\n+        }\n+\n+        @Override\n+        public Query rangeQuery(Object lowerTerm, Object upperTerm, boolean includeLower, boolean includeUpper, QueryShardContext context) {\n+            failIfNotIndexed();\n+            long l = Long.MIN_VALUE;\n+            long u = Long.MAX_VALUE;\n+            if (lowerTerm != null) {\n+                Long lt = parseLowerRangeTerm(lowerTerm, includeLower);\n+                if (lt == null) return new MatchNoDocsQuery();\n+                l = convertToSignedLong(lt);\n+            }\n+            if (upperTerm != null) {\n+                Long ut = parseUpperRangeTerm(upperTerm, includeUpper);\n+                if (ut == null) return new MatchNoDocsQuery();\n+                u = convertToSignedLong(ut);\n+            }\n+            if (l > u) return new MatchNoDocsQuery();\n+\n+            Query query = LongPoint.newRangeQuery(name(), l, u);\n+            if (hasDocValues()) {\n+                Query dvQuery = SortedNumericDocValuesField.newSlowRangeQuery(name(), l, u);\n+                query = new IndexOrDocValuesQuery(query, dvQuery);\n+                if (context.indexSortedOnField(name())) {\n+                    query = new IndexSortSortedNumericDocValuesRangeQuery(name(), l, u, query);\n+                }\n+            }\n+            if (boost() != 1f) {\n+                query = new BoostQuery(query, boost());\n+            }\n+            return query;\n+        }\n+\n+        @Override\n+        public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName) {\n+            failIfNoDocValues();\n+            return (cache, breakerService, mapperService) -> {\n+                final IndexNumericFieldData signedLongValues = new SortedNumericIndexFieldData.Builder(\n+                    name(),\n+                    IndexNumericFieldData.NumericType.LONG\n+                ).build(cache, breakerService, mapperService);\n+                return new UnsignedLongIndexFieldData(signedLongValues);\n+            };\n+        }\n+\n+        @Override\n+        public Object valueForDisplay(Object value) {\n+            if (value == null) {\n+                return null;\n+            }\n+            return convertToOriginal(((Number) value).longValue());\n+        }\n+\n+        @Override\n+        public DocValueFormat docValueFormat(String format, ZoneId timeZone) {\n+            if (timeZone != null) {\n+                throw new IllegalArgumentException(\n+                    \"Field [\" + name() + \"] of type [\" + typeName() + \"] does not support custom time zones\"\n+                );\n+            }\n+            if (format == null) {\n+                return DocValueFormat.RAW;\n+            } else {\n+                return new DocValueFormat.Decimal(format);\n+            }\n+        }\n+\n+        @Override\n+        public Function<byte[], Number> pointReaderIfPossible() {\n+            if (isSearchable()) {\n+                return (value) -> LongPoint.decodeDimension(value, 0);\n+            }\n+            return null;\n+        }\n+\n+        /**\n+         * Parses value to unsigned long for Term Query\n+         * @param value to to parse\n+         * @return parsed value, if a value represents an unsigned long in the range [0, 18446744073709551615]\n+         *         null, if a value represents some other number\n+         *         throws an exception if a value is wrongly formatted number\n+         */\n+        protected static Long parseTerm(Object value) {\n+            if (value instanceof Number) {\n+                if ((value instanceof Long) || (value instanceof Integer) || (value instanceof Short) || (value instanceof Byte)) {\n+                    long lv = ((Number) value).longValue();\n+                    if (lv >= 0) {\n+                        return lv;\n+                    }\n+                } else if (value instanceof BigInteger) {\n+                    BigInteger bigIntegerValue = (BigInteger) value;\n+                    if (bigIntegerValue.compareTo(BigInteger.ZERO) >= 0 && bigIntegerValue.compareTo(BIGINTEGER_2_64_MINUS_ONE) <= 0) {\n+                        return bigIntegerValue.longValue();\n+                    }\n+                }\n+            } else {\n+                String stringValue = (value instanceof BytesRef) ? ((BytesRef) value).utf8ToString() : value.toString();\n+                try {\n+                    return Long.parseUnsignedLong(stringValue);\n+                } catch (NumberFormatException e) {\n+                    // try again in case a number was negative or contained decimal\n+                    Double.parseDouble(stringValue); // throws an exception if it is an improper number\n+                }\n+            }\n+            return null; // any other number: decimal or beyond the range of unsigned long\n+        }\n+\n+        /**\n+         * Parses a lower term for a range query\n+         * @param value to parse\n+         * @param include whether a value should be included\n+         * @return parsed value to long considering include parameter\n+         *      0, if value is less than 0\n+         *      a value truncated to long, if value is in range [0, 18446744073709551615]\n+         *      null, if value is higher than the maximum allowed value for unsigned long\n+         *      throws an exception is value represents wrongly formatted number\n+         */\n+        protected static Long parseLowerRangeTerm(Object value, boolean include) {\n+            if ((value instanceof Long) || (value instanceof Integer) || (value instanceof Short) || (value instanceof Byte)) {\n+                long longValue = ((Number) value).longValue();\n+                if (longValue < 0) return 0L; // limit lowerTerm to min value for unsigned long: 0\n+                if (include == false) { // start from the next value\n+                    // for unsigned long, the next value for Long.MAX_VALUE is -9223372036854775808L\n+                    longValue = longValue == Long.MAX_VALUE ? Long.MIN_VALUE : ++longValue;\n+                }\n+                return longValue;\n+            }\n+            String stringValue = (value instanceof BytesRef) ? ((BytesRef) value).utf8ToString() : value.toString();\n+            final BigDecimal bigDecimalValue = new BigDecimal(stringValue);  // throws an exception if it is an improper number\n+            if (bigDecimalValue.compareTo(BigDecimal.ZERO) <= 0) {\n+                return 0L; // for values <=0, set lowerTerm to 0\n+            }\n+            int c = bigDecimalValue.compareTo(BIGDECIMAL_2_64_MINUS_ONE);\n+            if (c > 0 || (c == 0 && include == false)) {\n+                return null; // lowerTerm is beyond maximum value\n+            }\n+            long longValue = bigDecimalValue.longValue();\n+            boolean hasDecimal = (bigDecimalValue.scale() > 0 && bigDecimalValue.stripTrailingZeros().scale() > 0);\n+            if (include == false || hasDecimal) {\n+                ++longValue;\n+            }\n+            return longValue;\n+        }\n+\n+        /**\n+         * Parses an upper term for a range query\n+         * @param value to parse\n+         * @param include whether a value should be included\n+         * @return parsed value to long considering include parameter\n+         *      null, if value is less that 0, as value is lower than the minimum allowed value for unsigned long\n+         *      a value truncated to long if value is in range [0, 18446744073709551615]\n+         *      -1 (unsigned long of 18446744073709551615) for values greater than 18446744073709551615\n+         *      throws an exception is value represents wrongly formatted number\n+         */\n+        protected static Long parseUpperRangeTerm(Object value, boolean include) {\n+            if ((value instanceof Long) || (value instanceof Integer) || (value instanceof Short) || (value instanceof Byte)) {\n+                long longValue = ((Number) value).longValue();\n+                if ((longValue < 0) || (longValue == 0 && include == false)) return null; // upperTerm is below minimum\n+                longValue = include ? longValue : --longValue;\n+                return longValue;\n+            }\n+            String stringValue = (value instanceof BytesRef) ? ((BytesRef) value).utf8ToString() : value.toString();\n+            final BigDecimal bigDecimalValue = new BigDecimal(stringValue);  // throws an exception if it is an improper number\n+            int c = bigDecimalValue.compareTo(BigDecimal.ZERO);\n+            if (c < 0 || (c == 0 && include == false)) {\n+                return null; // upperTerm is below minimum\n+            }\n+            if (bigDecimalValue.compareTo(BIGDECIMAL_2_64_MINUS_ONE) > 0) {\n+                return -1L; // limit upperTerm to max value for unsigned long: 18446744073709551615\n+            }\n+            long longValue = bigDecimalValue.longValue();\n+            boolean hasDecimal = (bigDecimalValue.scale() > 0 && bigDecimalValue.stripTrailingZeros().scale() > 0);\n+            if (include == false && hasDecimal == false) {\n+                --longValue;\n+            }\n+            return longValue;\n+        }\n+    }\n+\n+    private Explicit<Boolean> ignoreMalformed;\n+    private final String nullValue;\n+    private final Long nullValueNumeric;\n+\n+    private UnsignedLongFieldMapper(\n+        String simpleName,\n+        FieldType fieldType,\n+        UnsignedLongFieldType mappedFieldType,\n+        Explicit<Boolean> ignoreMalformed,\n+        MultiFields multiFields,\n+        CopyTo copyTo,\n+        String nullValue\n+    ) {\n+        super(simpleName, fieldType, mappedFieldType, multiFields, copyTo);\n+        this.nullValue = nullValue;\n+        this.nullValueNumeric = nullValue == null ? null : convertToSignedLong(parseUnsignedLong(nullValue));\n+        this.ignoreMalformed = ignoreMalformed;\n+    }\n+\n+    @Override\n+    public UnsignedLongFieldType fieldType() {\n+        return (UnsignedLongFieldType) super.fieldType();\n+    }\n+\n+    @Override\n+    protected String contentType() {\n+        return CONTENT_TYPE;\n+    }\n+\n+    @Override\n+    protected UnsignedLongFieldMapper clone() {\n+        return (UnsignedLongFieldMapper) super.clone();\n+    }\n+\n+    @Override\n+    protected void parseCreateField(ParseContext context) throws IOException {\n+        XContentParser parser = context.parser();\n+        Long numericValue;\n+        if (context.externalValueSet()) {\n+            numericValue = parseUnsignedLong(context.externalValue());\n+        } else if (parser.currentToken() == XContentParser.Token.VALUE_NULL) {\n+            numericValue = null;\n+        } else if (parser.currentToken() == XContentParser.Token.VALUE_STRING && parser.textLength() == 0) {\n+            numericValue = null;\n+        } else {\n+            try {\n+                numericValue = parser.unsignedLongValue();\n+            } catch (InputCoercionException | IllegalArgumentException | JsonParseException e) {\n+                if (ignoreMalformed.value() && parser.currentToken().isValue()) {\n+                    context.addIgnoredField(mappedFieldType.name());\n+                    return;\n+                } else {\n+                    throw e;\n+                }\n+            }\n+        }\n+        if (numericValue == null) {\n+            numericValue = nullValueNumeric;\n+            if (numericValue == null) return;\n+        } else {\n+            numericValue = convertToSignedLong(numericValue);\n+        }\n+\n+        boolean docValued = fieldType().hasDocValues();\n+        boolean indexed = fieldType().isSearchable();\n+        boolean stored = fieldType.stored();\n+\n+        List<Field> fields = NumberFieldMapper.NumberType.LONG.createFields(fieldType().name(), numericValue, indexed, docValued, stored);\n+        context.doc().addAll(fields);\n+        if (docValued == false && (indexed || stored)) {\n+            createFieldNamesField(context);\n+        }\n+    }\n+\n+    @Override\n+    protected void mergeOptions(FieldMapper other, List<String> conflicts) {\n+        UnsignedLongFieldMapper mergeWith = (UnsignedLongFieldMapper) other;\n+        if (mergeWith.ignoreMalformed.explicit()) {\n+            this.ignoreMalformed = mergeWith.ignoreMalformed;\n+        }\n+    }\n+\n+    @Override\n+    protected void doXContentBody(XContentBuilder builder, boolean includeDefaults, Params params) throws IOException {\n+        super.doXContentBody(builder, includeDefaults, params);\n+\n+        if (includeDefaults || ignoreMalformed.explicit()) {\n+            builder.field(\"ignore_malformed\", ignoreMalformed.value());\n+        }\n+        if (nullValue != null) {\n+            builder.field(\"null_value\", nullValue);\n+        }\n+    }\n+\n+    /**\n+     * Parse object to unsigned long\n+     * @param value must represent an unsigned long in rage [0;18446744073709551615] or an exception will be thrown\n+     */\n+    private static long parseUnsignedLong(Object value) {\n+        if ((value instanceof Long) || (value instanceof Integer) || (value instanceof Short) || (value instanceof Byte)) {\n+            long lv = ((Number) value).longValue();\n+            if (lv < 0) {\n+                throw new IllegalArgumentException(\"Value [\" + lv + \"] is out of range for unsigned long.\");\n+            }\n+            return lv;\n+        }\n+        String stringValue = (value instanceof BytesRef) ? ((BytesRef) value).utf8ToString() : value.toString();\n+        try {\n+            return Long.parseUnsignedLong(stringValue);\n+        } catch (NumberFormatException e) {\n+            throw new IllegalArgumentException(\"For input string: \\\"\" + stringValue + \"\\\"\");\n+        }\n+    }\n+\n+    /**\n+     * Convert an unsigned long to the singed long by subtract 2^63 from it\n+     * @param value \u2013 unsigned long value in the range [0; 2^64-1], values greater than 2^63-1 are negative\n+     * @return signed long value in the range [-2^63; 2^63-1]\n+     */\n+    private static long convertToSignedLong(long value) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dffd748747fabf2be412e878db904db907caa6e1"}, "originalPosition": 502}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyOTEyMzMyOnYy", "diffSide": "RIGHT", "path": "docs/reference/mapping/types/unsigned_long.asciidoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QxMDoyNDo0N1rOHN53NQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QxMDoyNDo0N1rOHN53NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDM0MTU1Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            and must be avoided. If there is a need for a such kind of sorting, script based\n          \n          \n            \n            and must be avoided. If there is a need for such kind of sorting, script based", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r484341557", "createdAt": "2020-09-07T10:24:47Z", "author": {"login": "jimczi"}, "path": "docs/reference/mapping/types/unsigned_long.asciidoc", "diffHunk": "@@ -0,0 +1,156 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+\n+[[unsigned-long]]\n+=== Unsigned long data type\n+++++\n+<titleabbrev>Unsigned long</titleabbrev>\n+++++\n+\n+Unsigned long is a numeric field type that represents an unsigned 64-bit\n+integer with a minimum value of 0 and a maximum value of +2^64^-1+\n+(from 0 to 18446744073709551615 inclusive).\n+\n+[source,console]\n+--------------------------------------------------\n+PUT my_index\n+{\n+  \"mappings\": {\n+    \"properties\": {\n+      \"my_counter\": {\n+        \"type\": \"unsigned_long\"\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+\n+Unsigned long can be indexed in a numeric or string form,\n+representing integer values in the range [0, 18446744073709551615].\n+They can't have a decimal part.\n+\n+[source,console]\n+--------------------------------\n+POST /my_index/_bulk?refresh\n+{\"index\":{\"_id\":1}}\n+{\"my_counter\": 0}\n+{\"index\":{\"_id\":2}}\n+{\"my_counter\": 9223372036854775808}\n+{\"index\":{\"_id\":3}}\n+{\"my_counter\": 18446744073709551614}\n+{\"index\":{\"_id\":4}}\n+{\"my_counter\": 18446744073709551615}\n+--------------------------------\n+//TEST[continued]\n+\n+Term queries accept any numbers in a numeric or string form.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"term\" : {\n+            \"my_counter\" : 18446744073709551615\n+        }\n+    }\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+Range query terms can contain values with decimal parts.\n+In this case {es} converts them to integer values:\n+`gte` and `gt` terms are converted to the nearest integer up inclusive,\n+and `lt` and `lte` ranges are converted to the nearest integer down inclusive.\n+\n+It is recommended to pass ranges as strings to ensure they are parsed\n+without any loss of precision.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"range\" : {\n+            \"my_counter\" : {\n+                \"gte\" : \"9223372036854775808.5\",\n+                \"lte\" : \"18446744073709551615\"\n+            }\n+        }\n+    }\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+\n+For queries with sort on an `unsigned_long` field,\n+for a particular document {es} returns a sort value of the type `Long`\n+if the value of this document is within the range of long values,\n+or of the type `BigIntger` if the value exceeds this range.\n+\n+WARNING: Not all {es} clients can properly handle big integer values.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"match_all\" : {}\n+    },\n+    \"sort\" : {\"my_counter\" : \"desc\"}\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+Similarly to sort values, script values of an `unsigned_long` field\n+produce `BigInteger` or `Long` values. The same values: `BigInteger` or\n+`Long` are returned as keys for `terms` aggregation.\n+\n+==== Queries with mixed numeric types\n+\n+Search queries across several numeric types one of which `unsigned_long` are supported,\n+except queries with sort. Thus, a sort query across two indexes where the same field\n+is `unsigned_long` in one index, and `long` in another, doesn't produce correct results\n+and must be avoided. If there is a need for a such kind of sorting, script based", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e903940c82c2e9e494465f5a1e8633b1bd834d53"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyOTEyNzEyOnYy", "diffSide": "RIGHT", "path": "docs/reference/mapping/types/unsigned_long.asciidoc", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QxMDoyNTo0OFrOHN55Yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwODo0NDowN1rOHPpa5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDM0MjExNQ==", "bodyText": "We handle long => double conversion in the terms aggregation so I wonder if that's true ?", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r484342115", "createdAt": "2020-09-07T10:25:48Z", "author": {"login": "jimczi"}, "path": "docs/reference/mapping/types/unsigned_long.asciidoc", "diffHunk": "@@ -0,0 +1,156 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+\n+[[unsigned-long]]\n+=== Unsigned long data type\n+++++\n+<titleabbrev>Unsigned long</titleabbrev>\n+++++\n+\n+Unsigned long is a numeric field type that represents an unsigned 64-bit\n+integer with a minimum value of 0 and a maximum value of +2^64^-1+\n+(from 0 to 18446744073709551615 inclusive).\n+\n+[source,console]\n+--------------------------------------------------\n+PUT my_index\n+{\n+  \"mappings\": {\n+    \"properties\": {\n+      \"my_counter\": {\n+        \"type\": \"unsigned_long\"\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+\n+Unsigned long can be indexed in a numeric or string form,\n+representing integer values in the range [0, 18446744073709551615].\n+They can't have a decimal part.\n+\n+[source,console]\n+--------------------------------\n+POST /my_index/_bulk?refresh\n+{\"index\":{\"_id\":1}}\n+{\"my_counter\": 0}\n+{\"index\":{\"_id\":2}}\n+{\"my_counter\": 9223372036854775808}\n+{\"index\":{\"_id\":3}}\n+{\"my_counter\": 18446744073709551614}\n+{\"index\":{\"_id\":4}}\n+{\"my_counter\": 18446744073709551615}\n+--------------------------------\n+//TEST[continued]\n+\n+Term queries accept any numbers in a numeric or string form.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"term\" : {\n+            \"my_counter\" : 18446744073709551615\n+        }\n+    }\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+Range query terms can contain values with decimal parts.\n+In this case {es} converts them to integer values:\n+`gte` and `gt` terms are converted to the nearest integer up inclusive,\n+and `lt` and `lte` ranges are converted to the nearest integer down inclusive.\n+\n+It is recommended to pass ranges as strings to ensure they are parsed\n+without any loss of precision.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"range\" : {\n+            \"my_counter\" : {\n+                \"gte\" : \"9223372036854775808.5\",\n+                \"lte\" : \"18446744073709551615\"\n+            }\n+        }\n+    }\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+\n+For queries with sort on an `unsigned_long` field,\n+for a particular document {es} returns a sort value of the type `Long`\n+if the value of this document is within the range of long values,\n+or of the type `BigIntger` if the value exceeds this range.\n+\n+WARNING: Not all {es} clients can properly handle big integer values.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"match_all\" : {}\n+    },\n+    \"sort\" : {\"my_counter\" : \"desc\"}\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+Similarly to sort values, script values of an `unsigned_long` field\n+produce `BigInteger` or `Long` values. The same values: `BigInteger` or\n+`Long` are returned as keys for `terms` aggregation.\n+\n+==== Queries with mixed numeric types\n+\n+Search queries across several numeric types one of which `unsigned_long` are supported,\n+except queries with sort. Thus, a sort query across two indexes where the same field\n+is `unsigned_long` in one index, and `long` in another, doesn't produce correct results\n+and must be avoided. If there is a need for a such kind of sorting, script based\n+sorting can be used instead.\n+Aggregations across several numeric types one of which `unsigned_long` are supported,\n+except a terms aggregation.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e903940c82c2e9e494465f5a1e8633b1bd834d53"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE2NzE4MA==", "bodyText": "@jimczi Indeed,  I have modified the code in 9e057c0 to support terms agg on mixed numeric types with unsigned_long", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r485167180", "createdAt": "2020-09-08T20:07:14Z", "author": {"login": "mayya-sharipova"}, "path": "docs/reference/mapping/types/unsigned_long.asciidoc", "diffHunk": "@@ -0,0 +1,156 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+\n+[[unsigned-long]]\n+=== Unsigned long data type\n+++++\n+<titleabbrev>Unsigned long</titleabbrev>\n+++++\n+\n+Unsigned long is a numeric field type that represents an unsigned 64-bit\n+integer with a minimum value of 0 and a maximum value of +2^64^-1+\n+(from 0 to 18446744073709551615 inclusive).\n+\n+[source,console]\n+--------------------------------------------------\n+PUT my_index\n+{\n+  \"mappings\": {\n+    \"properties\": {\n+      \"my_counter\": {\n+        \"type\": \"unsigned_long\"\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+\n+Unsigned long can be indexed in a numeric or string form,\n+representing integer values in the range [0, 18446744073709551615].\n+They can't have a decimal part.\n+\n+[source,console]\n+--------------------------------\n+POST /my_index/_bulk?refresh\n+{\"index\":{\"_id\":1}}\n+{\"my_counter\": 0}\n+{\"index\":{\"_id\":2}}\n+{\"my_counter\": 9223372036854775808}\n+{\"index\":{\"_id\":3}}\n+{\"my_counter\": 18446744073709551614}\n+{\"index\":{\"_id\":4}}\n+{\"my_counter\": 18446744073709551615}\n+--------------------------------\n+//TEST[continued]\n+\n+Term queries accept any numbers in a numeric or string form.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"term\" : {\n+            \"my_counter\" : 18446744073709551615\n+        }\n+    }\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+Range query terms can contain values with decimal parts.\n+In this case {es} converts them to integer values:\n+`gte` and `gt` terms are converted to the nearest integer up inclusive,\n+and `lt` and `lte` ranges are converted to the nearest integer down inclusive.\n+\n+It is recommended to pass ranges as strings to ensure they are parsed\n+without any loss of precision.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"range\" : {\n+            \"my_counter\" : {\n+                \"gte\" : \"9223372036854775808.5\",\n+                \"lte\" : \"18446744073709551615\"\n+            }\n+        }\n+    }\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+\n+For queries with sort on an `unsigned_long` field,\n+for a particular document {es} returns a sort value of the type `Long`\n+if the value of this document is within the range of long values,\n+or of the type `BigIntger` if the value exceeds this range.\n+\n+WARNING: Not all {es} clients can properly handle big integer values.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"match_all\" : {}\n+    },\n+    \"sort\" : {\"my_counter\" : \"desc\"}\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+Similarly to sort values, script values of an `unsigned_long` field\n+produce `BigInteger` or `Long` values. The same values: `BigInteger` or\n+`Long` are returned as keys for `terms` aggregation.\n+\n+==== Queries with mixed numeric types\n+\n+Search queries across several numeric types one of which `unsigned_long` are supported,\n+except queries with sort. Thus, a sort query across two indexes where the same field\n+is `unsigned_long` in one index, and `long` in another, doesn't produce correct results\n+and must be avoided. If there is a need for a such kind of sorting, script based\n+sorting can be used instead.\n+Aggregations across several numeric types one of which `unsigned_long` are supported,\n+except a terms aggregation.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDM0MjExNQ=="}, "originalCommit": {"oid": "e903940c82c2e9e494465f5a1e8633b1bd834d53"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE2OTMxOA==", "bodyText": "++, thanks", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r486169318", "createdAt": "2020-09-10T08:44:07Z", "author": {"login": "jimczi"}, "path": "docs/reference/mapping/types/unsigned_long.asciidoc", "diffHunk": "@@ -0,0 +1,156 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+\n+[[unsigned-long]]\n+=== Unsigned long data type\n+++++\n+<titleabbrev>Unsigned long</titleabbrev>\n+++++\n+\n+Unsigned long is a numeric field type that represents an unsigned 64-bit\n+integer with a minimum value of 0 and a maximum value of +2^64^-1+\n+(from 0 to 18446744073709551615 inclusive).\n+\n+[source,console]\n+--------------------------------------------------\n+PUT my_index\n+{\n+  \"mappings\": {\n+    \"properties\": {\n+      \"my_counter\": {\n+        \"type\": \"unsigned_long\"\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+\n+Unsigned long can be indexed in a numeric or string form,\n+representing integer values in the range [0, 18446744073709551615].\n+They can't have a decimal part.\n+\n+[source,console]\n+--------------------------------\n+POST /my_index/_bulk?refresh\n+{\"index\":{\"_id\":1}}\n+{\"my_counter\": 0}\n+{\"index\":{\"_id\":2}}\n+{\"my_counter\": 9223372036854775808}\n+{\"index\":{\"_id\":3}}\n+{\"my_counter\": 18446744073709551614}\n+{\"index\":{\"_id\":4}}\n+{\"my_counter\": 18446744073709551615}\n+--------------------------------\n+//TEST[continued]\n+\n+Term queries accept any numbers in a numeric or string form.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"term\" : {\n+            \"my_counter\" : 18446744073709551615\n+        }\n+    }\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+Range query terms can contain values with decimal parts.\n+In this case {es} converts them to integer values:\n+`gte` and `gt` terms are converted to the nearest integer up inclusive,\n+and `lt` and `lte` ranges are converted to the nearest integer down inclusive.\n+\n+It is recommended to pass ranges as strings to ensure they are parsed\n+without any loss of precision.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"range\" : {\n+            \"my_counter\" : {\n+                \"gte\" : \"9223372036854775808.5\",\n+                \"lte\" : \"18446744073709551615\"\n+            }\n+        }\n+    }\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+\n+For queries with sort on an `unsigned_long` field,\n+for a particular document {es} returns a sort value of the type `Long`\n+if the value of this document is within the range of long values,\n+or of the type `BigIntger` if the value exceeds this range.\n+\n+WARNING: Not all {es} clients can properly handle big integer values.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"match_all\" : {}\n+    },\n+    \"sort\" : {\"my_counter\" : \"desc\"}\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+Similarly to sort values, script values of an `unsigned_long` field\n+produce `BigInteger` or `Long` values. The same values: `BigInteger` or\n+`Long` are returned as keys for `terms` aggregation.\n+\n+==== Queries with mixed numeric types\n+\n+Search queries across several numeric types one of which `unsigned_long` are supported,\n+except queries with sort. Thus, a sort query across two indexes where the same field\n+is `unsigned_long` in one index, and `long` in another, doesn't produce correct results\n+and must be avoided. If there is a need for a such kind of sorting, script based\n+sorting can be used instead.\n+Aggregations across several numeric types one of which `unsigned_long` are supported,\n+except a terms aggregation.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDM0MjExNQ=="}, "originalCommit": {"oid": "e903940c82c2e9e494465f5a1e8633b1bd834d53"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyOTEzMzUxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/DocValueFormat.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QxMDoyNzo1MFrOHN59Sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxOToxMTo0OFrOHOqhiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDM0MzExNA==", "bodyText": "These variables should be final and static ?", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r484343114", "createdAt": "2020-09-07T10:27:50Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/search/DocValueFormat.java", "diffHunk": "@@ -48,6 +49,8 @@\n \n /** A formatter for values as returned by the fielddata/doc-values APIs. */\n public interface DocValueFormat extends NamedWriteable {\n+    long MASK_2_63 = 0x8000000000000000L;\n+    BigInteger BIGINTEGER_2_64_MINUS_ONE = BigInteger.ONE.shiftLeft(64).subtract(BigInteger.ONE); // 2^64 -1", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e903940c82c2e9e494465f5a1e8633b1bd834d53"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEwNDIwNQ==", "bodyText": "@jimczi Thanks Jim, I get a hint from Intellij that final static declarations are unnecessary here, as interface variables are by default final and static.", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r485104205", "createdAt": "2020-09-08T18:06:51Z", "author": {"login": "mayya-sharipova"}, "path": "server/src/main/java/org/elasticsearch/search/DocValueFormat.java", "diffHunk": "@@ -48,6 +49,8 @@\n \n /** A formatter for values as returned by the fielddata/doc-values APIs. */\n public interface DocValueFormat extends NamedWriteable {\n+    long MASK_2_63 = 0x8000000000000000L;\n+    BigInteger BIGINTEGER_2_64_MINUS_ONE = BigInteger.ONE.shiftLeft(64).subtract(BigInteger.ONE); // 2^64 -1", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDM0MzExNA=="}, "originalCommit": {"oid": "e903940c82c2e9e494465f5a1e8633b1bd834d53"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEzODgyNQ==", "bodyText": "oh that's an interface, right. Sorry for the noise", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r485138825", "createdAt": "2020-09-08T19:11:48Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/search/DocValueFormat.java", "diffHunk": "@@ -48,6 +49,8 @@\n \n /** A formatter for values as returned by the fielddata/doc-values APIs. */\n public interface DocValueFormat extends NamedWriteable {\n+    long MASK_2_63 = 0x8000000000000000L;\n+    BigInteger BIGINTEGER_2_64_MINUS_ONE = BigInteger.ONE.shiftLeft(64).subtract(BigInteger.ONE); // 2^64 -1", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDM0MzExNA=="}, "originalCommit": {"oid": "e903940c82c2e9e494465f5a1e8633b1bd834d53"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyOTE1NTcxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/common/io/stream/StreamOutput.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QxMDozNDo0OVrOHN6KRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDowNToyNFrOHOsMtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDM0NjQzOA==", "bodyText": "Can you fix the indentation of the blocks ?", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r484346438", "createdAt": "2020-09-07T10:34:49Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/common/io/stream/StreamOutput.java", "diffHunk": "@@ -826,7 +827,14 @@ public final void writeOptionalInstant(@Nullable Instant instant) throws IOExcep\n                             o.writeByte((byte) 25);\n                         }\n                         o.writeCollection((Set<?>) v, StreamOutput::writeGenericValue);\n-                    }\n+                    }),\n+            entry(\n+                // TODO: improve serialization of BigInteger\n+                BigInteger.class,\n+                (o, v) -> {\n+                    o.writeByte((byte) 26);\n+                    o.writeString(v.toString());\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e903940c82c2e9e494465f5a1e8633b1bd834d53"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE2NjI2Mw==", "bodyText": "Addressed in 9e057c0", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r485166263", "createdAt": "2020-09-08T20:05:24Z", "author": {"login": "mayya-sharipova"}, "path": "server/src/main/java/org/elasticsearch/common/io/stream/StreamOutput.java", "diffHunk": "@@ -826,7 +827,14 @@ public final void writeOptionalInstant(@Nullable Instant instant) throws IOExcep\n                             o.writeByte((byte) 25);\n                         }\n                         o.writeCollection((Set<?>) v, StreamOutput::writeGenericValue);\n-                    }\n+                    }),\n+            entry(\n+                // TODO: improve serialization of BigInteger\n+                BigInteger.class,\n+                (o, v) -> {\n+                    o.writeByte((byte) 26);\n+                    o.writeString(v.toString());\n+                }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDM0NjQzOA=="}, "originalCommit": {"oid": "e903940c82c2e9e494465f5a1e8633b1bd834d53"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyOTE3OTY4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/mapper-unsigned-long/src/main/java/org/elasticsearch/xpack/unsignedlong/UnsignedLongScriptDocValues.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QxMDo0MjoyM1rOHN6Ykg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwODo0NDozN1rOHPpcMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDM1MDA5OA==", "bodyText": "We'd need to provide the doc value format but that could be done in the ScriptDocValues.Long directly ?", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r484350098", "createdAt": "2020-09-07T10:42:23Z", "author": {"login": "jimczi"}, "path": "x-pack/plugin/mapper-unsigned-long/src/main/java/org/elasticsearch/xpack/unsignedlong/UnsignedLongScriptDocValues.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.unsignedlong;\n+\n+import org.apache.lucene.index.SortedNumericDocValues;\n+import org.apache.lucene.util.ArrayUtil;\n+import org.elasticsearch.index.fielddata.ScriptDocValues;\n+import org.elasticsearch.search.DocValueFormat;\n+\n+import java.io.IOException;\n+\n+public class UnsignedLongScriptDocValues extends ScriptDocValues<Number> {\n+    private final SortedNumericDocValues in;\n+    private Number[] values = new Number[0];\n+    private int count;\n+\n+    /**\n+     * Standard constructor.\n+     */\n+    public UnsignedLongScriptDocValues(SortedNumericDocValues in) {\n+        this.in = in;\n+    }\n+\n+    @Override\n+    public void setNextDocId(int docId) throws IOException {\n+        if (in.advanceExact(docId)) {\n+            resize(in.docValueCount());\n+            for (int i = 0; i < count; i++) {\n+                values[i] = (Number) DocValueFormat.UNSIGNED_LONG_SHIFTED.format(in.nextValue());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e903940c82c2e9e494465f5a1e8633b1bd834d53"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE2MDU2Mw==", "bodyText": "@jimczi  Thanks for the feedback. I am not very clear what you are suggesting here. Are you suggesting to use ScriptDocValues.Longs instead of creating a new class?   If yes, I have opted to create a new class, as ScriptDocValues.Longs hold values in a array  long[] values, while we need an array of Number[] values as sometimes produced values can be of type long and other times of type BigInteger.", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r485160563", "createdAt": "2020-09-08T19:54:12Z", "author": {"login": "mayya-sharipova"}, "path": "x-pack/plugin/mapper-unsigned-long/src/main/java/org/elasticsearch/xpack/unsignedlong/UnsignedLongScriptDocValues.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.unsignedlong;\n+\n+import org.apache.lucene.index.SortedNumericDocValues;\n+import org.apache.lucene.util.ArrayUtil;\n+import org.elasticsearch.index.fielddata.ScriptDocValues;\n+import org.elasticsearch.search.DocValueFormat;\n+\n+import java.io.IOException;\n+\n+public class UnsignedLongScriptDocValues extends ScriptDocValues<Number> {\n+    private final SortedNumericDocValues in;\n+    private Number[] values = new Number[0];\n+    private int count;\n+\n+    /**\n+     * Standard constructor.\n+     */\n+    public UnsignedLongScriptDocValues(SortedNumericDocValues in) {\n+        this.in = in;\n+    }\n+\n+    @Override\n+    public void setNextDocId(int docId) throws IOException {\n+        if (in.advanceExact(docId)) {\n+            resize(in.docValueCount());\n+            for (int i = 0; i < count; i++) {\n+                values[i] = (Number) DocValueFormat.UNSIGNED_LONG_SHIFTED.format(in.nextValue());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDM1MDA5OA=="}, "originalCommit": {"oid": "e903940c82c2e9e494465f5a1e8633b1bd834d53"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE2ODc4NA==", "bodyText": "So today ScriptDocValues.Long returns a Long but it could return a Number instead and rely on a provided doc values format to do the conversion to a number. In the normal case we would conver to a Long but if the provided doc values format is the unsigned_long then it can also return a BigInteger in some cases.\nI am not sure it's a good idea so feel free to keep the code separated if you prefer. In any case I don't think we need to rely on a Number[] array. We can store the unsigned long in a plain long[] array and do the conversion to Number lazily when getValue or get(int) are called.", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r485168784", "createdAt": "2020-09-08T20:10:29Z", "author": {"login": "jimczi"}, "path": "x-pack/plugin/mapper-unsigned-long/src/main/java/org/elasticsearch/xpack/unsignedlong/UnsignedLongScriptDocValues.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.unsignedlong;\n+\n+import org.apache.lucene.index.SortedNumericDocValues;\n+import org.apache.lucene.util.ArrayUtil;\n+import org.elasticsearch.index.fielddata.ScriptDocValues;\n+import org.elasticsearch.search.DocValueFormat;\n+\n+import java.io.IOException;\n+\n+public class UnsignedLongScriptDocValues extends ScriptDocValues<Number> {\n+    private final SortedNumericDocValues in;\n+    private Number[] values = new Number[0];\n+    private int count;\n+\n+    /**\n+     * Standard constructor.\n+     */\n+    public UnsignedLongScriptDocValues(SortedNumericDocValues in) {\n+        this.in = in;\n+    }\n+\n+    @Override\n+    public void setNextDocId(int docId) throws IOException {\n+        if (in.advanceExact(docId)) {\n+            resize(in.docValueCount());\n+            for (int i = 0; i < count; i++) {\n+                values[i] = (Number) DocValueFormat.UNSIGNED_LONG_SHIFTED.format(in.nextValue());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDM1MDA5OA=="}, "originalCommit": {"oid": "e903940c82c2e9e494465f5a1e8633b1bd834d53"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg5NTUxOQ==", "bodyText": "@jimczi  Thanks Jim, this is a good idea. I explored using Longs but it turned out it involves more modifications as Longs::getValue expects long.  Instead, I followed your 2nd idea to used long[] for values in UnsignedLongScriptDocValues.java   and this is addressed in 2b567c9.", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r485895519", "createdAt": "2020-09-09T20:14:36Z", "author": {"login": "mayya-sharipova"}, "path": "x-pack/plugin/mapper-unsigned-long/src/main/java/org/elasticsearch/xpack/unsignedlong/UnsignedLongScriptDocValues.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.unsignedlong;\n+\n+import org.apache.lucene.index.SortedNumericDocValues;\n+import org.apache.lucene.util.ArrayUtil;\n+import org.elasticsearch.index.fielddata.ScriptDocValues;\n+import org.elasticsearch.search.DocValueFormat;\n+\n+import java.io.IOException;\n+\n+public class UnsignedLongScriptDocValues extends ScriptDocValues<Number> {\n+    private final SortedNumericDocValues in;\n+    private Number[] values = new Number[0];\n+    private int count;\n+\n+    /**\n+     * Standard constructor.\n+     */\n+    public UnsignedLongScriptDocValues(SortedNumericDocValues in) {\n+        this.in = in;\n+    }\n+\n+    @Override\n+    public void setNextDocId(int docId) throws IOException {\n+        if (in.advanceExact(docId)) {\n+            resize(in.docValueCount());\n+            for (int i = 0; i < count; i++) {\n+                values[i] = (Number) DocValueFormat.UNSIGNED_LONG_SHIFTED.format(in.nextValue());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDM1MDA5OA=="}, "originalCommit": {"oid": "e903940c82c2e9e494465f5a1e8633b1bd834d53"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE2OTY1MA==", "bodyText": "++, thanks", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r486169650", "createdAt": "2020-09-10T08:44:37Z", "author": {"login": "jimczi"}, "path": "x-pack/plugin/mapper-unsigned-long/src/main/java/org/elasticsearch/xpack/unsignedlong/UnsignedLongScriptDocValues.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.unsignedlong;\n+\n+import org.apache.lucene.index.SortedNumericDocValues;\n+import org.apache.lucene.util.ArrayUtil;\n+import org.elasticsearch.index.fielddata.ScriptDocValues;\n+import org.elasticsearch.search.DocValueFormat;\n+\n+import java.io.IOException;\n+\n+public class UnsignedLongScriptDocValues extends ScriptDocValues<Number> {\n+    private final SortedNumericDocValues in;\n+    private Number[] values = new Number[0];\n+    private int count;\n+\n+    /**\n+     * Standard constructor.\n+     */\n+    public UnsignedLongScriptDocValues(SortedNumericDocValues in) {\n+        this.in = in;\n+    }\n+\n+    @Override\n+    public void setNextDocId(int docId) throws IOException {\n+        if (in.advanceExact(docId)) {\n+            resize(in.docValueCount());\n+            for (int i = 0; i < count; i++) {\n+                values[i] = (Number) DocValueFormat.UNSIGNED_LONG_SHIFTED.format(in.nextValue());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDM1MDA5OA=="}, "originalCommit": {"oid": "e903940c82c2e9e494465f5a1e8633b1bd834d53"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzMzU4OTM2OnYy", "diffSide": "RIGHT", "path": "docs/reference/mapping/types.asciidoc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNTozODozMFrOHOjFKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDozMToyN1rOHOs--Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAxNjg3NQ==", "bodyText": "What would you think of including this in the top-level numeric types page instead of creating a separate page ? It seems nice to combine all numeric field types so it's easy to find and compare them. We just did this for the keyword type family.", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r485016875", "createdAt": "2020-09-08T15:38:30Z", "author": {"login": "jtibshirani"}, "path": "docs/reference/mapping/types.asciidoc", "diffHunk": "@@ -9,7 +9,7 @@ document:\n === Core data types\n \n string::         <<text,`text`>>, <<keyword,`keyword`>> and <<wildcard,`wildcard`>>\n-<<number>>::     `long`, `integer`, `short`, `byte`, `double`, `float`, `half_float`, `scaled_float`\n+<<number>>::     `long`, `integer`, `short`, `byte`, `double`, `float`, `half_float`, `scaled_float`, <<unsigned-long,`unsigned_long`>>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e903940c82c2e9e494465f5a1e8633b1bd834d53"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3OTEyOQ==", "bodyText": "@jtibshirani Good suggestion, addressed in ab54a23", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r485179129", "createdAt": "2020-09-08T20:31:27Z", "author": {"login": "mayya-sharipova"}, "path": "docs/reference/mapping/types.asciidoc", "diffHunk": "@@ -9,7 +9,7 @@ document:\n === Core data types\n \n string::         <<text,`text`>>, <<keyword,`keyword`>> and <<wildcard,`wildcard`>>\n-<<number>>::     `long`, `integer`, `short`, `byte`, `double`, `float`, `half_float`, `scaled_float`\n+<<number>>::     `long`, `integer`, `short`, `byte`, `double`, `float`, `half_float`, `scaled_float`, <<unsigned-long,`unsigned_long`>>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAxNjg3NQ=="}, "originalCommit": {"oid": "e903940c82c2e9e494465f5a1e8633b1bd834d53"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzMzY3NTAyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/mapper-unsigned-long/src/main/java/org/elasticsearch/xpack/unsignedlong/UnsignedLongFieldMapper.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNTo1ODoyNVrOHOj5bg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDo0MDozNVrOHOtQjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAzMDI1NA==", "bodyText": "I didn't review this logic in detail, but I was curious if we considered having this extend NumberFieldType ?", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r485030254", "createdAt": "2020-09-08T15:58:25Z", "author": {"login": "jtibshirani"}, "path": "x-pack/plugin/mapper-unsigned-long/src/main/java/org/elasticsearch/xpack/unsignedlong/UnsignedLongFieldMapper.java", "diffHunk": "@@ -0,0 +1,561 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.unsignedlong;\n+\n+import com.fasterxml.jackson.core.JsonParseException;\n+import com.fasterxml.jackson.core.exc.InputCoercionException;\n+import org.apache.lucene.document.Field;\n+import org.apache.lucene.document.FieldType;\n+import org.apache.lucene.document.LongPoint;\n+import org.apache.lucene.document.SortedNumericDocValuesField;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.BoostQuery;\n+import org.apache.lucene.search.DocValuesFieldExistsQuery;\n+import org.apache.lucene.search.IndexOrDocValuesQuery;\n+import org.apache.lucene.search.IndexSortSortedNumericDocValuesRangeQuery;\n+import org.apache.lucene.search.MatchNoDocsQuery;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.TermQuery;\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.common.Explicit;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.support.XContentMapValues;\n+import org.elasticsearch.index.fielddata.IndexFieldData;\n+import org.elasticsearch.index.fielddata.IndexNumericFieldData;\n+import org.elasticsearch.index.fielddata.plain.SortedNumericIndexFieldData;\n+import org.elasticsearch.index.mapper.FieldMapper;\n+import org.elasticsearch.index.mapper.FieldNamesFieldMapper;\n+import org.elasticsearch.index.mapper.Mapper;\n+import org.elasticsearch.index.mapper.MapperParsingException;\n+import org.elasticsearch.index.mapper.NumberFieldMapper;\n+import org.elasticsearch.index.mapper.ParseContext;\n+import org.elasticsearch.index.mapper.SimpleMappedFieldType;\n+import org.elasticsearch.index.mapper.TextSearchInfo;\n+import org.elasticsearch.index.mapper.TypeParsers;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.search.DocValueFormat;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.time.ZoneId;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+public class UnsignedLongFieldMapper extends FieldMapper {\n+    protected static long MASK_2_63 = 0x8000000000000000L;\n+    private static BigInteger BIGINTEGER_2_64_MINUS_ONE = BigInteger.ONE.shiftLeft(64).subtract(BigInteger.ONE); // 2^64 -1\n+    private static BigDecimal BIGDECIMAL_2_64_MINUS_ONE = new BigDecimal(BIGINTEGER_2_64_MINUS_ONE);\n+\n+    public static final String CONTENT_TYPE = \"unsigned_long\";\n+    // use the same default as numbers\n+    private static final FieldType FIELD_TYPE = new FieldType();\n+    static {\n+        FIELD_TYPE.setIndexOptions(IndexOptions.DOCS);\n+    }\n+\n+    public static class Builder extends FieldMapper.Builder<Builder> {\n+\n+        private Boolean ignoreMalformed;\n+        private String nullValue;\n+\n+        public Builder(String name) {\n+            super(name, FIELD_TYPE);\n+            builder = this;\n+        }\n+\n+        public Builder ignoreMalformed(boolean ignoreMalformed) {\n+            this.ignoreMalformed = ignoreMalformed;\n+            return builder;\n+        }\n+\n+        @Override\n+        public Builder indexOptions(IndexOptions indexOptions) {\n+            throw new MapperParsingException(\"index_options not allowed in field [\" + name + \"] of type [\" + CONTENT_TYPE + \"]\");\n+        }\n+\n+        protected Explicit<Boolean> ignoreMalformed(BuilderContext context) {\n+            if (ignoreMalformed != null) {\n+                return new Explicit<>(ignoreMalformed, true);\n+            }\n+            if (context.indexSettings() != null) {\n+                return new Explicit<>(IGNORE_MALFORMED_SETTING.get(context.indexSettings()), false);\n+            }\n+            return NumberFieldMapper.Defaults.IGNORE_MALFORMED;\n+        }\n+\n+        public Builder nullValue(String nullValue) {\n+            this.nullValue = nullValue;\n+            return this;\n+        }\n+\n+        @Override\n+        public UnsignedLongFieldMapper build(BuilderContext context) {\n+            UnsignedLongFieldType type = new UnsignedLongFieldType(buildFullName(context), indexed, hasDocValues, meta);\n+            return new UnsignedLongFieldMapper(\n+                name,\n+                fieldType,\n+                type,\n+                ignoreMalformed(context),\n+                multiFieldsBuilder.build(this, context),\n+                copyTo,\n+                nullValue\n+            );\n+        }\n+    }\n+\n+    public static class TypeParser implements Mapper.TypeParser {\n+        @Override\n+        public Mapper.Builder<?> parse(String name, Map<String, Object> node, ParserContext parserContext) throws MapperParsingException {\n+            Builder builder = new Builder(name);\n+            TypeParsers.parseField(builder, name, node, parserContext);\n+            for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(); iterator.hasNext();) {\n+                Map.Entry<String, Object> entry = iterator.next();\n+                String propName = entry.getKey();\n+                Object propNode = entry.getValue();\n+                if (propName.equals(\"null_value\")) {\n+                    if (propNode == null) {\n+                        throw new MapperParsingException(\"Property [null_value] cannot be null.\");\n+                    }\n+                    parseUnsignedLong(propNode); // confirm that null_value is a proper unsigned_long\n+                    String nullValue = (propNode instanceof BytesRef) ? ((BytesRef) propNode).utf8ToString() : propNode.toString();\n+                    builder.nullValue(nullValue);\n+                    iterator.remove();\n+                } else if (propName.equals(\"ignore_malformed\")) {\n+                    builder.ignoreMalformed(XContentMapValues.nodeBooleanValue(propNode, name + \".ignore_malformed\"));\n+                    iterator.remove();\n+                }\n+            }\n+            return builder;\n+        }\n+    }\n+\n+    public static final class UnsignedLongFieldType extends SimpleMappedFieldType {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e903940c82c2e9e494465f5a1e8633b1bd834d53"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE2ODI2Mw==", "bodyText": "@jtibshirani Thanks for the feedback, it did not make sense for me to extend NumberFieldType as logic for almost every query needs to be overwritten.", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r485168263", "createdAt": "2020-09-08T20:09:27Z", "author": {"login": "mayya-sharipova"}, "path": "x-pack/plugin/mapper-unsigned-long/src/main/java/org/elasticsearch/xpack/unsignedlong/UnsignedLongFieldMapper.java", "diffHunk": "@@ -0,0 +1,561 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.unsignedlong;\n+\n+import com.fasterxml.jackson.core.JsonParseException;\n+import com.fasterxml.jackson.core.exc.InputCoercionException;\n+import org.apache.lucene.document.Field;\n+import org.apache.lucene.document.FieldType;\n+import org.apache.lucene.document.LongPoint;\n+import org.apache.lucene.document.SortedNumericDocValuesField;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.BoostQuery;\n+import org.apache.lucene.search.DocValuesFieldExistsQuery;\n+import org.apache.lucene.search.IndexOrDocValuesQuery;\n+import org.apache.lucene.search.IndexSortSortedNumericDocValuesRangeQuery;\n+import org.apache.lucene.search.MatchNoDocsQuery;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.TermQuery;\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.common.Explicit;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.support.XContentMapValues;\n+import org.elasticsearch.index.fielddata.IndexFieldData;\n+import org.elasticsearch.index.fielddata.IndexNumericFieldData;\n+import org.elasticsearch.index.fielddata.plain.SortedNumericIndexFieldData;\n+import org.elasticsearch.index.mapper.FieldMapper;\n+import org.elasticsearch.index.mapper.FieldNamesFieldMapper;\n+import org.elasticsearch.index.mapper.Mapper;\n+import org.elasticsearch.index.mapper.MapperParsingException;\n+import org.elasticsearch.index.mapper.NumberFieldMapper;\n+import org.elasticsearch.index.mapper.ParseContext;\n+import org.elasticsearch.index.mapper.SimpleMappedFieldType;\n+import org.elasticsearch.index.mapper.TextSearchInfo;\n+import org.elasticsearch.index.mapper.TypeParsers;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.search.DocValueFormat;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.time.ZoneId;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+public class UnsignedLongFieldMapper extends FieldMapper {\n+    protected static long MASK_2_63 = 0x8000000000000000L;\n+    private static BigInteger BIGINTEGER_2_64_MINUS_ONE = BigInteger.ONE.shiftLeft(64).subtract(BigInteger.ONE); // 2^64 -1\n+    private static BigDecimal BIGDECIMAL_2_64_MINUS_ONE = new BigDecimal(BIGINTEGER_2_64_MINUS_ONE);\n+\n+    public static final String CONTENT_TYPE = \"unsigned_long\";\n+    // use the same default as numbers\n+    private static final FieldType FIELD_TYPE = new FieldType();\n+    static {\n+        FIELD_TYPE.setIndexOptions(IndexOptions.DOCS);\n+    }\n+\n+    public static class Builder extends FieldMapper.Builder<Builder> {\n+\n+        private Boolean ignoreMalformed;\n+        private String nullValue;\n+\n+        public Builder(String name) {\n+            super(name, FIELD_TYPE);\n+            builder = this;\n+        }\n+\n+        public Builder ignoreMalformed(boolean ignoreMalformed) {\n+            this.ignoreMalformed = ignoreMalformed;\n+            return builder;\n+        }\n+\n+        @Override\n+        public Builder indexOptions(IndexOptions indexOptions) {\n+            throw new MapperParsingException(\"index_options not allowed in field [\" + name + \"] of type [\" + CONTENT_TYPE + \"]\");\n+        }\n+\n+        protected Explicit<Boolean> ignoreMalformed(BuilderContext context) {\n+            if (ignoreMalformed != null) {\n+                return new Explicit<>(ignoreMalformed, true);\n+            }\n+            if (context.indexSettings() != null) {\n+                return new Explicit<>(IGNORE_MALFORMED_SETTING.get(context.indexSettings()), false);\n+            }\n+            return NumberFieldMapper.Defaults.IGNORE_MALFORMED;\n+        }\n+\n+        public Builder nullValue(String nullValue) {\n+            this.nullValue = nullValue;\n+            return this;\n+        }\n+\n+        @Override\n+        public UnsignedLongFieldMapper build(BuilderContext context) {\n+            UnsignedLongFieldType type = new UnsignedLongFieldType(buildFullName(context), indexed, hasDocValues, meta);\n+            return new UnsignedLongFieldMapper(\n+                name,\n+                fieldType,\n+                type,\n+                ignoreMalformed(context),\n+                multiFieldsBuilder.build(this, context),\n+                copyTo,\n+                nullValue\n+            );\n+        }\n+    }\n+\n+    public static class TypeParser implements Mapper.TypeParser {\n+        @Override\n+        public Mapper.Builder<?> parse(String name, Map<String, Object> node, ParserContext parserContext) throws MapperParsingException {\n+            Builder builder = new Builder(name);\n+            TypeParsers.parseField(builder, name, node, parserContext);\n+            for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(); iterator.hasNext();) {\n+                Map.Entry<String, Object> entry = iterator.next();\n+                String propName = entry.getKey();\n+                Object propNode = entry.getValue();\n+                if (propName.equals(\"null_value\")) {\n+                    if (propNode == null) {\n+                        throw new MapperParsingException(\"Property [null_value] cannot be null.\");\n+                    }\n+                    parseUnsignedLong(propNode); // confirm that null_value is a proper unsigned_long\n+                    String nullValue = (propNode instanceof BytesRef) ? ((BytesRef) propNode).utf8ToString() : propNode.toString();\n+                    builder.nullValue(nullValue);\n+                    iterator.remove();\n+                } else if (propName.equals(\"ignore_malformed\")) {\n+                    builder.ignoreMalformed(XContentMapValues.nodeBooleanValue(propNode, name + \".ignore_malformed\"));\n+                    iterator.remove();\n+                }\n+            }\n+            return builder;\n+        }\n+    }\n+\n+    public static final class UnsignedLongFieldType extends SimpleMappedFieldType {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAzMDI1NA=="}, "originalCommit": {"oid": "e903940c82c2e9e494465f5a1e8633b1bd834d53"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MzYyOQ==", "bodyText": "Thanks for the explanation.", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r485183629", "createdAt": "2020-09-08T20:40:35Z", "author": {"login": "jtibshirani"}, "path": "x-pack/plugin/mapper-unsigned-long/src/main/java/org/elasticsearch/xpack/unsignedlong/UnsignedLongFieldMapper.java", "diffHunk": "@@ -0,0 +1,561 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.unsignedlong;\n+\n+import com.fasterxml.jackson.core.JsonParseException;\n+import com.fasterxml.jackson.core.exc.InputCoercionException;\n+import org.apache.lucene.document.Field;\n+import org.apache.lucene.document.FieldType;\n+import org.apache.lucene.document.LongPoint;\n+import org.apache.lucene.document.SortedNumericDocValuesField;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.BoostQuery;\n+import org.apache.lucene.search.DocValuesFieldExistsQuery;\n+import org.apache.lucene.search.IndexOrDocValuesQuery;\n+import org.apache.lucene.search.IndexSortSortedNumericDocValuesRangeQuery;\n+import org.apache.lucene.search.MatchNoDocsQuery;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.TermQuery;\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.common.Explicit;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.support.XContentMapValues;\n+import org.elasticsearch.index.fielddata.IndexFieldData;\n+import org.elasticsearch.index.fielddata.IndexNumericFieldData;\n+import org.elasticsearch.index.fielddata.plain.SortedNumericIndexFieldData;\n+import org.elasticsearch.index.mapper.FieldMapper;\n+import org.elasticsearch.index.mapper.FieldNamesFieldMapper;\n+import org.elasticsearch.index.mapper.Mapper;\n+import org.elasticsearch.index.mapper.MapperParsingException;\n+import org.elasticsearch.index.mapper.NumberFieldMapper;\n+import org.elasticsearch.index.mapper.ParseContext;\n+import org.elasticsearch.index.mapper.SimpleMappedFieldType;\n+import org.elasticsearch.index.mapper.TextSearchInfo;\n+import org.elasticsearch.index.mapper.TypeParsers;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.search.DocValueFormat;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.time.ZoneId;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+public class UnsignedLongFieldMapper extends FieldMapper {\n+    protected static long MASK_2_63 = 0x8000000000000000L;\n+    private static BigInteger BIGINTEGER_2_64_MINUS_ONE = BigInteger.ONE.shiftLeft(64).subtract(BigInteger.ONE); // 2^64 -1\n+    private static BigDecimal BIGDECIMAL_2_64_MINUS_ONE = new BigDecimal(BIGINTEGER_2_64_MINUS_ONE);\n+\n+    public static final String CONTENT_TYPE = \"unsigned_long\";\n+    // use the same default as numbers\n+    private static final FieldType FIELD_TYPE = new FieldType();\n+    static {\n+        FIELD_TYPE.setIndexOptions(IndexOptions.DOCS);\n+    }\n+\n+    public static class Builder extends FieldMapper.Builder<Builder> {\n+\n+        private Boolean ignoreMalformed;\n+        private String nullValue;\n+\n+        public Builder(String name) {\n+            super(name, FIELD_TYPE);\n+            builder = this;\n+        }\n+\n+        public Builder ignoreMalformed(boolean ignoreMalformed) {\n+            this.ignoreMalformed = ignoreMalformed;\n+            return builder;\n+        }\n+\n+        @Override\n+        public Builder indexOptions(IndexOptions indexOptions) {\n+            throw new MapperParsingException(\"index_options not allowed in field [\" + name + \"] of type [\" + CONTENT_TYPE + \"]\");\n+        }\n+\n+        protected Explicit<Boolean> ignoreMalformed(BuilderContext context) {\n+            if (ignoreMalformed != null) {\n+                return new Explicit<>(ignoreMalformed, true);\n+            }\n+            if (context.indexSettings() != null) {\n+                return new Explicit<>(IGNORE_MALFORMED_SETTING.get(context.indexSettings()), false);\n+            }\n+            return NumberFieldMapper.Defaults.IGNORE_MALFORMED;\n+        }\n+\n+        public Builder nullValue(String nullValue) {\n+            this.nullValue = nullValue;\n+            return this;\n+        }\n+\n+        @Override\n+        public UnsignedLongFieldMapper build(BuilderContext context) {\n+            UnsignedLongFieldType type = new UnsignedLongFieldType(buildFullName(context), indexed, hasDocValues, meta);\n+            return new UnsignedLongFieldMapper(\n+                name,\n+                fieldType,\n+                type,\n+                ignoreMalformed(context),\n+                multiFieldsBuilder.build(this, context),\n+                copyTo,\n+                nullValue\n+            );\n+        }\n+    }\n+\n+    public static class TypeParser implements Mapper.TypeParser {\n+        @Override\n+        public Mapper.Builder<?> parse(String name, Map<String, Object> node, ParserContext parserContext) throws MapperParsingException {\n+            Builder builder = new Builder(name);\n+            TypeParsers.parseField(builder, name, node, parserContext);\n+            for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(); iterator.hasNext();) {\n+                Map.Entry<String, Object> entry = iterator.next();\n+                String propName = entry.getKey();\n+                Object propNode = entry.getValue();\n+                if (propName.equals(\"null_value\")) {\n+                    if (propNode == null) {\n+                        throw new MapperParsingException(\"Property [null_value] cannot be null.\");\n+                    }\n+                    parseUnsignedLong(propNode); // confirm that null_value is a proper unsigned_long\n+                    String nullValue = (propNode instanceof BytesRef) ? ((BytesRef) propNode).utf8ToString() : propNode.toString();\n+                    builder.nullValue(nullValue);\n+                    iterator.remove();\n+                } else if (propName.equals(\"ignore_malformed\")) {\n+                    builder.ignoreMalformed(XContentMapValues.nodeBooleanValue(propNode, name + \".ignore_malformed\"));\n+                    iterator.remove();\n+                }\n+            }\n+            return builder;\n+        }\n+    }\n+\n+    public static final class UnsignedLongFieldType extends SimpleMappedFieldType {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAzMDI1NA=="}, "originalCommit": {"oid": "e903940c82c2e9e494465f5a1e8633b1bd834d53"}, "originalPosition": 143}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MTAxMjgxOnYy", "diffSide": "RIGHT", "path": "docs/reference/mapping/types/unsigned_long.asciidoc", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwODo0MTo1M1rOHPpVUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwODo0MTo1M1rOHPpVUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE2Nzg5MA==", "bodyText": "That's a bit scary to add as a warning ;). I would change {es} with something like rest clients need to handle big integer values in json to support this field type correctly or something along those lines ?", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r486167890", "createdAt": "2020-09-10T08:41:53Z", "author": {"login": "jimczi"}, "path": "docs/reference/mapping/types/unsigned_long.asciidoc", "diffHunk": "@@ -0,0 +1,115 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+\n+[[unsigned-long]]\n+=== Unsigned long data type\n+Unsigned long is a numeric field type that represents an unsigned 64-bit\n+integer with a minimum value of 0 and a maximum value of +2^64^-1+\n+(from 0 to 18446744073709551615 inclusive).\n+\n+[source,console]\n+--------------------------------------------------\n+PUT my_index\n+{\n+  \"mappings\": {\n+    \"properties\": {\n+      \"my_counter\": {\n+        \"type\": \"unsigned_long\"\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+\n+Unsigned long can be indexed in a numeric or string form,\n+representing integer values in the range [0, 18446744073709551615].\n+They can't have a decimal part.\n+\n+[source,console]\n+--------------------------------\n+POST /my_index/_bulk?refresh\n+{\"index\":{\"_id\":1}}\n+{\"my_counter\": 0}\n+{\"index\":{\"_id\":2}}\n+{\"my_counter\": 9223372036854775808}\n+{\"index\":{\"_id\":3}}\n+{\"my_counter\": 18446744073709551614}\n+{\"index\":{\"_id\":4}}\n+{\"my_counter\": 18446744073709551615}\n+--------------------------------\n+//TEST[continued]\n+\n+Term queries accept any numbers in a numeric or string form.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"term\" : {\n+            \"my_counter\" : 18446744073709551615\n+        }\n+    }\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+Range query terms can contain values with decimal parts.\n+In this case {es} converts them to integer values:\n+`gte` and `gt` terms are converted to the nearest integer up inclusive,\n+and `lt` and `lte` ranges are converted to the nearest integer down inclusive.\n+\n+It is recommended to pass ranges as strings to ensure they are parsed\n+without any loss of precision.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"range\" : {\n+            \"my_counter\" : {\n+                \"gte\" : \"9223372036854775808.5\",\n+                \"lte\" : \"18446744073709551615\"\n+            }\n+        }\n+    }\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+\n+For queries with sort on an `unsigned_long` field,\n+for a particular document {es} returns a sort value of the type `Long`\n+if the value of this document is within the range of long values,\n+or of the type `BigInteger` if the value exceeds this range.\n+\n+WARNING: Not all {es} clients can properly handle big integer values.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b567c961f4dc9331ef7eef25c4c9c8b271a67c8"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MTAxNzA0OnYy", "diffSide": "RIGHT", "path": "docs/reference/mapping/types/unsigned_long.asciidoc", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwODo0Mjo1OFrOHPpYEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwODo0Mjo1OFrOHPpYEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE2ODU5Mw==", "bodyText": "I'd say produce a Number that represents a long or a BigInteger...", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r486168593", "createdAt": "2020-09-10T08:42:58Z", "author": {"login": "jimczi"}, "path": "docs/reference/mapping/types/unsigned_long.asciidoc", "diffHunk": "@@ -0,0 +1,115 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+\n+[[unsigned-long]]\n+=== Unsigned long data type\n+Unsigned long is a numeric field type that represents an unsigned 64-bit\n+integer with a minimum value of 0 and a maximum value of +2^64^-1+\n+(from 0 to 18446744073709551615 inclusive).\n+\n+[source,console]\n+--------------------------------------------------\n+PUT my_index\n+{\n+  \"mappings\": {\n+    \"properties\": {\n+      \"my_counter\": {\n+        \"type\": \"unsigned_long\"\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+\n+Unsigned long can be indexed in a numeric or string form,\n+representing integer values in the range [0, 18446744073709551615].\n+They can't have a decimal part.\n+\n+[source,console]\n+--------------------------------\n+POST /my_index/_bulk?refresh\n+{\"index\":{\"_id\":1}}\n+{\"my_counter\": 0}\n+{\"index\":{\"_id\":2}}\n+{\"my_counter\": 9223372036854775808}\n+{\"index\":{\"_id\":3}}\n+{\"my_counter\": 18446744073709551614}\n+{\"index\":{\"_id\":4}}\n+{\"my_counter\": 18446744073709551615}\n+--------------------------------\n+//TEST[continued]\n+\n+Term queries accept any numbers in a numeric or string form.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"term\" : {\n+            \"my_counter\" : 18446744073709551615\n+        }\n+    }\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+Range query terms can contain values with decimal parts.\n+In this case {es} converts them to integer values:\n+`gte` and `gt` terms are converted to the nearest integer up inclusive,\n+and `lt` and `lte` ranges are converted to the nearest integer down inclusive.\n+\n+It is recommended to pass ranges as strings to ensure they are parsed\n+without any loss of precision.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"range\" : {\n+            \"my_counter\" : {\n+                \"gte\" : \"9223372036854775808.5\",\n+                \"lte\" : \"18446744073709551615\"\n+            }\n+        }\n+    }\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+\n+For queries with sort on an `unsigned_long` field,\n+for a particular document {es} returns a sort value of the type `Long`\n+if the value of this document is within the range of long values,\n+or of the type `BigInteger` if the value exceeds this range.\n+\n+WARNING: Not all {es} clients can properly handle big integer values.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"match_all\" : {}\n+    },\n+    \"sort\" : {\"my_counter\" : \"desc\"}\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+Similarly to sort values, script values of an `unsigned_long` field\n+produce `BigInteger` or `Long` values. The same values: `BigInteger` or", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b567c961f4dc9331ef7eef25c4c9c8b271a67c8"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MzkyMTQwOnYy", "diffSide": "RIGHT", "path": "docs/reference/mapping/types/unsigned_long.asciidoc", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxNzozMjo1M1rOHRfoaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQyMTowOToyMVrOHTEUDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEwNjA4OA==", "bodyText": "Small comment, we could say 'Searches with mixed numeric types' to be more precise (since this section mentions aggs too).", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r488106088", "createdAt": "2020-09-14T17:32:53Z", "author": {"login": "jtibshirani"}, "path": "docs/reference/mapping/types/unsigned_long.asciidoc", "diffHunk": "@@ -0,0 +1,116 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+\n+[[unsigned-long]]\n+=== Unsigned long data type\n+Unsigned long is a numeric field type that represents an unsigned 64-bit\n+integer with a minimum value of 0 and a maximum value of +2^64^-1+\n+(from 0 to 18446744073709551615 inclusive).\n+\n+[source,console]\n+--------------------------------------------------\n+PUT my_index\n+{\n+  \"mappings\": {\n+    \"properties\": {\n+      \"my_counter\": {\n+        \"type\": \"unsigned_long\"\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+\n+Unsigned long can be indexed in a numeric or string form,\n+representing integer values in the range [0, 18446744073709551615].\n+They can't have a decimal part.\n+\n+[source,console]\n+--------------------------------\n+POST /my_index/_bulk?refresh\n+{\"index\":{\"_id\":1}}\n+{\"my_counter\": 0}\n+{\"index\":{\"_id\":2}}\n+{\"my_counter\": 9223372036854775808}\n+{\"index\":{\"_id\":3}}\n+{\"my_counter\": 18446744073709551614}\n+{\"index\":{\"_id\":4}}\n+{\"my_counter\": 18446744073709551615}\n+--------------------------------\n+//TEST[continued]\n+\n+Term queries accept any numbers in a numeric or string form.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"term\" : {\n+            \"my_counter\" : 18446744073709551615\n+        }\n+    }\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+Range query terms can contain values with decimal parts.\n+In this case {es} converts them to integer values:\n+`gte` and `gt` terms are converted to the nearest integer up inclusive,\n+and `lt` and `lte` ranges are converted to the nearest integer down inclusive.\n+\n+It is recommended to pass ranges as strings to ensure they are parsed\n+without any loss of precision.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"range\" : {\n+            \"my_counter\" : {\n+                \"gte\" : \"9223372036854775808.5\",\n+                \"lte\" : \"18446744073709551615\"\n+            }\n+        }\n+    }\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+\n+For queries with sort on an `unsigned_long` field,\n+for a particular document {es} returns a sort value of the type `long`\n+if the value of this document is within the range of long values,\n+or of the type `BigInteger` if the value exceeds this range.\n+\n+NOTE: Rest clients need to be able to handle big integer values\n+in json to support this field type correctly.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"match_all\" : {}\n+    },\n+    \"sort\" : {\"my_counter\" : \"desc\"}\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+Similarly to sort values, script values of an `unsigned_long` field\n+return a number representing a `long` or `BigInteger`.\n+The same values: `long` or `BigInteger` are used for `terms` aggregations.\n+\n+==== Queries with mixed numeric types", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07470b5006ed3aac8a635a2953424f635ccd46c0"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTczNDQzMw==", "bodyText": "I was actually thinking about the heading \"Queries with mixed numeric types\" !", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r489734433", "createdAt": "2020-09-16T20:27:24Z", "author": {"login": "jtibshirani"}, "path": "docs/reference/mapping/types/unsigned_long.asciidoc", "diffHunk": "@@ -0,0 +1,116 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+\n+[[unsigned-long]]\n+=== Unsigned long data type\n+Unsigned long is a numeric field type that represents an unsigned 64-bit\n+integer with a minimum value of 0 and a maximum value of +2^64^-1+\n+(from 0 to 18446744073709551615 inclusive).\n+\n+[source,console]\n+--------------------------------------------------\n+PUT my_index\n+{\n+  \"mappings\": {\n+    \"properties\": {\n+      \"my_counter\": {\n+        \"type\": \"unsigned_long\"\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+\n+Unsigned long can be indexed in a numeric or string form,\n+representing integer values in the range [0, 18446744073709551615].\n+They can't have a decimal part.\n+\n+[source,console]\n+--------------------------------\n+POST /my_index/_bulk?refresh\n+{\"index\":{\"_id\":1}}\n+{\"my_counter\": 0}\n+{\"index\":{\"_id\":2}}\n+{\"my_counter\": 9223372036854775808}\n+{\"index\":{\"_id\":3}}\n+{\"my_counter\": 18446744073709551614}\n+{\"index\":{\"_id\":4}}\n+{\"my_counter\": 18446744073709551615}\n+--------------------------------\n+//TEST[continued]\n+\n+Term queries accept any numbers in a numeric or string form.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"term\" : {\n+            \"my_counter\" : 18446744073709551615\n+        }\n+    }\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+Range query terms can contain values with decimal parts.\n+In this case {es} converts them to integer values:\n+`gte` and `gt` terms are converted to the nearest integer up inclusive,\n+and `lt` and `lte` ranges are converted to the nearest integer down inclusive.\n+\n+It is recommended to pass ranges as strings to ensure they are parsed\n+without any loss of precision.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"range\" : {\n+            \"my_counter\" : {\n+                \"gte\" : \"9223372036854775808.5\",\n+                \"lte\" : \"18446744073709551615\"\n+            }\n+        }\n+    }\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+\n+For queries with sort on an `unsigned_long` field,\n+for a particular document {es} returns a sort value of the type `long`\n+if the value of this document is within the range of long values,\n+or of the type `BigInteger` if the value exceeds this range.\n+\n+NOTE: Rest clients need to be able to handle big integer values\n+in json to support this field type correctly.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"match_all\" : {}\n+    },\n+    \"sort\" : {\"my_counter\" : \"desc\"}\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+Similarly to sort values, script values of an `unsigned_long` field\n+return a number representing a `long` or `BigInteger`.\n+The same values: `long` or `BigInteger` are used for `terms` aggregations.\n+\n+==== Queries with mixed numeric types", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEwNjA4OA=="}, "originalCommit": {"oid": "07470b5006ed3aac8a635a2953424f635ccd46c0"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc1NTY2Mg==", "bodyText": "Addressed in 17912bc", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r489755662", "createdAt": "2020-09-16T21:09:21Z", "author": {"login": "mayya-sharipova"}, "path": "docs/reference/mapping/types/unsigned_long.asciidoc", "diffHunk": "@@ -0,0 +1,116 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+\n+[[unsigned-long]]\n+=== Unsigned long data type\n+Unsigned long is a numeric field type that represents an unsigned 64-bit\n+integer with a minimum value of 0 and a maximum value of +2^64^-1+\n+(from 0 to 18446744073709551615 inclusive).\n+\n+[source,console]\n+--------------------------------------------------\n+PUT my_index\n+{\n+  \"mappings\": {\n+    \"properties\": {\n+      \"my_counter\": {\n+        \"type\": \"unsigned_long\"\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+\n+Unsigned long can be indexed in a numeric or string form,\n+representing integer values in the range [0, 18446744073709551615].\n+They can't have a decimal part.\n+\n+[source,console]\n+--------------------------------\n+POST /my_index/_bulk?refresh\n+{\"index\":{\"_id\":1}}\n+{\"my_counter\": 0}\n+{\"index\":{\"_id\":2}}\n+{\"my_counter\": 9223372036854775808}\n+{\"index\":{\"_id\":3}}\n+{\"my_counter\": 18446744073709551614}\n+{\"index\":{\"_id\":4}}\n+{\"my_counter\": 18446744073709551615}\n+--------------------------------\n+//TEST[continued]\n+\n+Term queries accept any numbers in a numeric or string form.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"term\" : {\n+            \"my_counter\" : 18446744073709551615\n+        }\n+    }\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+Range query terms can contain values with decimal parts.\n+In this case {es} converts them to integer values:\n+`gte` and `gt` terms are converted to the nearest integer up inclusive,\n+and `lt` and `lte` ranges are converted to the nearest integer down inclusive.\n+\n+It is recommended to pass ranges as strings to ensure they are parsed\n+without any loss of precision.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"range\" : {\n+            \"my_counter\" : {\n+                \"gte\" : \"9223372036854775808.5\",\n+                \"lte\" : \"18446744073709551615\"\n+            }\n+        }\n+    }\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+\n+For queries with sort on an `unsigned_long` field,\n+for a particular document {es} returns a sort value of the type `long`\n+if the value of this document is within the range of long values,\n+or of the type `BigInteger` if the value exceeds this range.\n+\n+NOTE: Rest clients need to be able to handle big integer values\n+in json to support this field type correctly.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"match_all\" : {}\n+    },\n+    \"sort\" : {\"my_counter\" : \"desc\"}\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+Similarly to sort values, script values of an `unsigned_long` field\n+return a number representing a `long` or `BigInteger`.\n+The same values: `long` or `BigInteger` are used for `terms` aggregations.\n+\n+==== Queries with mixed numeric types", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEwNjA4OA=="}, "originalCommit": {"oid": "07470b5006ed3aac8a635a2953424f635ccd46c0"}, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MzkyMjQ2OnYy", "diffSide": "RIGHT", "path": "docs/reference/mapping/types/unsigned_long.asciidoc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxNzozMzoxMFrOHRfpBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQyMTowOTowMFrOHTETTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEwNjI0NA==", "bodyText": "Really small comment, I think we usually capitalize REST and JSON.", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r488106244", "createdAt": "2020-09-14T17:33:10Z", "author": {"login": "jtibshirani"}, "path": "docs/reference/mapping/types/unsigned_long.asciidoc", "diffHunk": "@@ -0,0 +1,116 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+\n+[[unsigned-long]]\n+=== Unsigned long data type\n+Unsigned long is a numeric field type that represents an unsigned 64-bit\n+integer with a minimum value of 0 and a maximum value of +2^64^-1+\n+(from 0 to 18446744073709551615 inclusive).\n+\n+[source,console]\n+--------------------------------------------------\n+PUT my_index\n+{\n+  \"mappings\": {\n+    \"properties\": {\n+      \"my_counter\": {\n+        \"type\": \"unsigned_long\"\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+\n+Unsigned long can be indexed in a numeric or string form,\n+representing integer values in the range [0, 18446744073709551615].\n+They can't have a decimal part.\n+\n+[source,console]\n+--------------------------------\n+POST /my_index/_bulk?refresh\n+{\"index\":{\"_id\":1}}\n+{\"my_counter\": 0}\n+{\"index\":{\"_id\":2}}\n+{\"my_counter\": 9223372036854775808}\n+{\"index\":{\"_id\":3}}\n+{\"my_counter\": 18446744073709551614}\n+{\"index\":{\"_id\":4}}\n+{\"my_counter\": 18446744073709551615}\n+--------------------------------\n+//TEST[continued]\n+\n+Term queries accept any numbers in a numeric or string form.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"term\" : {\n+            \"my_counter\" : 18446744073709551615\n+        }\n+    }\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+Range query terms can contain values with decimal parts.\n+In this case {es} converts them to integer values:\n+`gte` and `gt` terms are converted to the nearest integer up inclusive,\n+and `lt` and `lte` ranges are converted to the nearest integer down inclusive.\n+\n+It is recommended to pass ranges as strings to ensure they are parsed\n+without any loss of precision.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"range\" : {\n+            \"my_counter\" : {\n+                \"gte\" : \"9223372036854775808.5\",\n+                \"lte\" : \"18446744073709551615\"\n+            }\n+        }\n+    }\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+\n+For queries with sort on an `unsigned_long` field,\n+for a particular document {es} returns a sort value of the type `long`\n+if the value of this document is within the range of long values,\n+or of the type `BigInteger` if the value exceeds this range.\n+\n+NOTE: Rest clients need to be able to handle big integer values", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07470b5006ed3aac8a635a2953424f635ccd46c0"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc1NTQ3MQ==", "bodyText": "Addressed in 17912bc", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r489755471", "createdAt": "2020-09-16T21:09:00Z", "author": {"login": "mayya-sharipova"}, "path": "docs/reference/mapping/types/unsigned_long.asciidoc", "diffHunk": "@@ -0,0 +1,116 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+\n+[[unsigned-long]]\n+=== Unsigned long data type\n+Unsigned long is a numeric field type that represents an unsigned 64-bit\n+integer with a minimum value of 0 and a maximum value of +2^64^-1+\n+(from 0 to 18446744073709551615 inclusive).\n+\n+[source,console]\n+--------------------------------------------------\n+PUT my_index\n+{\n+  \"mappings\": {\n+    \"properties\": {\n+      \"my_counter\": {\n+        \"type\": \"unsigned_long\"\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+\n+Unsigned long can be indexed in a numeric or string form,\n+representing integer values in the range [0, 18446744073709551615].\n+They can't have a decimal part.\n+\n+[source,console]\n+--------------------------------\n+POST /my_index/_bulk?refresh\n+{\"index\":{\"_id\":1}}\n+{\"my_counter\": 0}\n+{\"index\":{\"_id\":2}}\n+{\"my_counter\": 9223372036854775808}\n+{\"index\":{\"_id\":3}}\n+{\"my_counter\": 18446744073709551614}\n+{\"index\":{\"_id\":4}}\n+{\"my_counter\": 18446744073709551615}\n+--------------------------------\n+//TEST[continued]\n+\n+Term queries accept any numbers in a numeric or string form.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"term\" : {\n+            \"my_counter\" : 18446744073709551615\n+        }\n+    }\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+Range query terms can contain values with decimal parts.\n+In this case {es} converts them to integer values:\n+`gte` and `gt` terms are converted to the nearest integer up inclusive,\n+and `lt` and `lte` ranges are converted to the nearest integer down inclusive.\n+\n+It is recommended to pass ranges as strings to ensure they are parsed\n+without any loss of precision.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"range\" : {\n+            \"my_counter\" : {\n+                \"gte\" : \"9223372036854775808.5\",\n+                \"lte\" : \"18446744073709551615\"\n+            }\n+        }\n+    }\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+\n+For queries with sort on an `unsigned_long` field,\n+for a particular document {es} returns a sort value of the type `long`\n+if the value of this document is within the range of long values,\n+or of the type `BigInteger` if the value exceeds this range.\n+\n+NOTE: Rest clients need to be able to handle big integer values", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEwNjI0NA=="}, "originalCommit": {"oid": "07470b5006ed3aac8a635a2953424f635ccd46c0"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1Mzk1MjUxOnYy", "diffSide": "RIGHT", "path": "docs/reference/mapping/types/unsigned_long.asciidoc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxNzo0MjowMlrOHRf7jA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQyMTowOTozN1rOHTEUqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODExMDk4OA==", "bodyText": "I think it'd be clearer to call out the Java type here: \"return a Number representing a Long or BigInteger\".", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r488110988", "createdAt": "2020-09-14T17:42:02Z", "author": {"login": "jtibshirani"}, "path": "docs/reference/mapping/types/unsigned_long.asciidoc", "diffHunk": "@@ -0,0 +1,116 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+\n+[[unsigned-long]]\n+=== Unsigned long data type\n+Unsigned long is a numeric field type that represents an unsigned 64-bit\n+integer with a minimum value of 0 and a maximum value of +2^64^-1+\n+(from 0 to 18446744073709551615 inclusive).\n+\n+[source,console]\n+--------------------------------------------------\n+PUT my_index\n+{\n+  \"mappings\": {\n+    \"properties\": {\n+      \"my_counter\": {\n+        \"type\": \"unsigned_long\"\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+\n+Unsigned long can be indexed in a numeric or string form,\n+representing integer values in the range [0, 18446744073709551615].\n+They can't have a decimal part.\n+\n+[source,console]\n+--------------------------------\n+POST /my_index/_bulk?refresh\n+{\"index\":{\"_id\":1}}\n+{\"my_counter\": 0}\n+{\"index\":{\"_id\":2}}\n+{\"my_counter\": 9223372036854775808}\n+{\"index\":{\"_id\":3}}\n+{\"my_counter\": 18446744073709551614}\n+{\"index\":{\"_id\":4}}\n+{\"my_counter\": 18446744073709551615}\n+--------------------------------\n+//TEST[continued]\n+\n+Term queries accept any numbers in a numeric or string form.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"term\" : {\n+            \"my_counter\" : 18446744073709551615\n+        }\n+    }\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+Range query terms can contain values with decimal parts.\n+In this case {es} converts them to integer values:\n+`gte` and `gt` terms are converted to the nearest integer up inclusive,\n+and `lt` and `lte` ranges are converted to the nearest integer down inclusive.\n+\n+It is recommended to pass ranges as strings to ensure they are parsed\n+without any loss of precision.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"range\" : {\n+            \"my_counter\" : {\n+                \"gte\" : \"9223372036854775808.5\",\n+                \"lte\" : \"18446744073709551615\"\n+            }\n+        }\n+    }\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+\n+For queries with sort on an `unsigned_long` field,\n+for a particular document {es} returns a sort value of the type `long`\n+if the value of this document is within the range of long values,\n+or of the type `BigInteger` if the value exceeds this range.\n+\n+NOTE: Rest clients need to be able to handle big integer values\n+in json to support this field type correctly.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"match_all\" : {}\n+    },\n+    \"sort\" : {\"my_counter\" : \"desc\"}\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+Similarly to sort values, script values of an `unsigned_long` field", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07470b5006ed3aac8a635a2953424f635ccd46c0"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc1NTgxNw==", "bodyText": "Addressed in 17912bc", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r489755817", "createdAt": "2020-09-16T21:09:37Z", "author": {"login": "mayya-sharipova"}, "path": "docs/reference/mapping/types/unsigned_long.asciidoc", "diffHunk": "@@ -0,0 +1,116 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+\n+[[unsigned-long]]\n+=== Unsigned long data type\n+Unsigned long is a numeric field type that represents an unsigned 64-bit\n+integer with a minimum value of 0 and a maximum value of +2^64^-1+\n+(from 0 to 18446744073709551615 inclusive).\n+\n+[source,console]\n+--------------------------------------------------\n+PUT my_index\n+{\n+  \"mappings\": {\n+    \"properties\": {\n+      \"my_counter\": {\n+        \"type\": \"unsigned_long\"\n+      }\n+    }\n+  }\n+}\n+--------------------------------------------------\n+\n+Unsigned long can be indexed in a numeric or string form,\n+representing integer values in the range [0, 18446744073709551615].\n+They can't have a decimal part.\n+\n+[source,console]\n+--------------------------------\n+POST /my_index/_bulk?refresh\n+{\"index\":{\"_id\":1}}\n+{\"my_counter\": 0}\n+{\"index\":{\"_id\":2}}\n+{\"my_counter\": 9223372036854775808}\n+{\"index\":{\"_id\":3}}\n+{\"my_counter\": 18446744073709551614}\n+{\"index\":{\"_id\":4}}\n+{\"my_counter\": 18446744073709551615}\n+--------------------------------\n+//TEST[continued]\n+\n+Term queries accept any numbers in a numeric or string form.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"term\" : {\n+            \"my_counter\" : 18446744073709551615\n+        }\n+    }\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+Range query terms can contain values with decimal parts.\n+In this case {es} converts them to integer values:\n+`gte` and `gt` terms are converted to the nearest integer up inclusive,\n+and `lt` and `lte` ranges are converted to the nearest integer down inclusive.\n+\n+It is recommended to pass ranges as strings to ensure they are parsed\n+without any loss of precision.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"range\" : {\n+            \"my_counter\" : {\n+                \"gte\" : \"9223372036854775808.5\",\n+                \"lte\" : \"18446744073709551615\"\n+            }\n+        }\n+    }\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+\n+For queries with sort on an `unsigned_long` field,\n+for a particular document {es} returns a sort value of the type `long`\n+if the value of this document is within the range of long values,\n+or of the type `BigInteger` if the value exceeds this range.\n+\n+NOTE: Rest clients need to be able to handle big integer values\n+in json to support this field type correctly.\n+\n+[source,console]\n+--------------------------------\n+GET /my_index/_search\n+{\n+    \"query\": {\n+        \"match_all\" : {}\n+    },\n+    \"sort\" : {\"my_counter\" : \"desc\"}\n+}\n+--------------------------------\n+//TEST[continued]\n+\n+Similarly to sort values, script values of an `unsigned_long` field", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODExMDk4OA=="}, "originalCommit": {"oid": "07470b5006ed3aac8a635a2953424f635ccd46c0"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2NDM2NTYxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/search/SearchPhaseController.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQyMTowNzo0NFrOHTERCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQyMDoxODowM1rOHVg7sQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc1NDg4OQ==", "bodyText": "Checking my understanding -- are all shards guaranteed to have the same number of sort formats (even if some sort fields are unmapped)?", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r489754889", "createdAt": "2020-09-16T21:07:44Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/action/search/SearchPhaseController.java", "diffHunk": "@@ -485,6 +486,36 @@ private static InternalAggregations reduceAggs(InternalAggregation.ReduceContext\n             performFinalReduce ? aggReduceContextBuilder.forFinalReduction() : aggReduceContextBuilder.forPartialReduction());\n     }\n \n+    /**\n+     * Checks that query results from all shards have consistent unsigned_long format.\n+     * Sort queries on a field that has long type in one index, and unsigned_long in another index\n+     * don't work correctly. Throw an error if this kind of sorting is detected.\n+     * //TODO: instead of throwing error, find a way to sort long and unsigned_long together\n+     */\n+    private static void checkSameUnsignedLongSortFormat(Collection<? extends SearchPhaseResult> queryResults) {\n+        boolean[] ulFormats = null;\n+        boolean firstResult = true;\n+        for (SearchPhaseResult entry : queryResults) {\n+            DocValueFormat[] formats = entry.queryResult().sortValueFormats();\n+            if (formats == null) return;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2eef4c4ca9997dddface371cfad3b1671fd438b"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDE0NzEyMA==", "bodyText": "@jtibshirani Indeed, all shards are guaranteed to have the same number of sort formats. If a field is unmapped on a shard, we will get a shard failure, unless we specifically map an unmapped field to something else.", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r490147120", "createdAt": "2020-09-17T10:44:52Z", "author": {"login": "mayya-sharipova"}, "path": "server/src/main/java/org/elasticsearch/action/search/SearchPhaseController.java", "diffHunk": "@@ -485,6 +486,36 @@ private static InternalAggregations reduceAggs(InternalAggregation.ReduceContext\n             performFinalReduce ? aggReduceContextBuilder.forFinalReduction() : aggReduceContextBuilder.forPartialReduction());\n     }\n \n+    /**\n+     * Checks that query results from all shards have consistent unsigned_long format.\n+     * Sort queries on a field that has long type in one index, and unsigned_long in another index\n+     * don't work correctly. Throw an error if this kind of sorting is detected.\n+     * //TODO: instead of throwing error, find a way to sort long and unsigned_long together\n+     */\n+    private static void checkSameUnsignedLongSortFormat(Collection<? extends SearchPhaseResult> queryResults) {\n+        boolean[] ulFormats = null;\n+        boolean firstResult = true;\n+        for (SearchPhaseResult entry : queryResults) {\n+            DocValueFormat[] formats = entry.queryResult().sortValueFormats();\n+            if (formats == null) return;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc1NDg4OQ=="}, "originalCommit": {"oid": "b2eef4c4ca9997dddface371cfad3b1671fd438b"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDE0ODEwMA==", "bodyText": "Also wondering if @jimczi is ok with this final check I've added in SearchPhaseController", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r490148100", "createdAt": "2020-09-17T10:46:53Z", "author": {"login": "mayya-sharipova"}, "path": "server/src/main/java/org/elasticsearch/action/search/SearchPhaseController.java", "diffHunk": "@@ -485,6 +486,36 @@ private static InternalAggregations reduceAggs(InternalAggregation.ReduceContext\n             performFinalReduce ? aggReduceContextBuilder.forFinalReduction() : aggReduceContextBuilder.forPartialReduction());\n     }\n \n+    /**\n+     * Checks that query results from all shards have consistent unsigned_long format.\n+     * Sort queries on a field that has long type in one index, and unsigned_long in another index\n+     * don't work correctly. Throw an error if this kind of sorting is detected.\n+     * //TODO: instead of throwing error, find a way to sort long and unsigned_long together\n+     */\n+    private static void checkSameUnsignedLongSortFormat(Collection<? extends SearchPhaseResult> queryResults) {\n+        boolean[] ulFormats = null;\n+        boolean firstResult = true;\n+        for (SearchPhaseResult entry : queryResults) {\n+            DocValueFormat[] formats = entry.queryResult().sortValueFormats();\n+            if (formats == null) return;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc1NDg4OQ=="}, "originalCommit": {"oid": "b2eef4c4ca9997dddface371cfad3b1671fd438b"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMyMTcxMw==", "bodyText": "++, that makes sense to me. You can maybe rename the function validateMergeSortValueFormats or something along those lines ?", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r492321713", "createdAt": "2020-09-21T20:18:03Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/action/search/SearchPhaseController.java", "diffHunk": "@@ -485,6 +486,36 @@ private static InternalAggregations reduceAggs(InternalAggregation.ReduceContext\n             performFinalReduce ? aggReduceContextBuilder.forFinalReduction() : aggReduceContextBuilder.forPartialReduction());\n     }\n \n+    /**\n+     * Checks that query results from all shards have consistent unsigned_long format.\n+     * Sort queries on a field that has long type in one index, and unsigned_long in another index\n+     * don't work correctly. Throw an error if this kind of sorting is detected.\n+     * //TODO: instead of throwing error, find a way to sort long and unsigned_long together\n+     */\n+    private static void checkSameUnsignedLongSortFormat(Collection<? extends SearchPhaseResult> queryResults) {\n+        boolean[] ulFormats = null;\n+        boolean firstResult = true;\n+        for (SearchPhaseResult entry : queryResults) {\n+            DocValueFormat[] formats = entry.queryResult().sortValueFormats();\n+            if (formats == null) return;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc1NDg4OQ=="}, "originalCommit": {"oid": "b2eef4c4ca9997dddface371cfad3b1671fd438b"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2NDUxMjUzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/search/SearchPhaseController.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQyMTo1NzowN1rOHTFo9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQyMTo1NzowN1rOHTFo9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc3NzM5Nw==", "bodyText": "This TODO makes sense. It's unfortunate that we need to do a special check here, but it feels worth it to me to avoid silently returning incorrect results.", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r489777397", "createdAt": "2020-09-16T21:57:07Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/action/search/SearchPhaseController.java", "diffHunk": "@@ -485,6 +486,36 @@ private static InternalAggregations reduceAggs(InternalAggregation.ReduceContext\n             performFinalReduce ? aggReduceContextBuilder.forFinalReduction() : aggReduceContextBuilder.forPartialReduction());\n     }\n \n+    /**\n+     * Checks that query results from all shards have consistent unsigned_long format.\n+     * Sort queries on a field that has long type in one index, and unsigned_long in another index\n+     * don't work correctly. Throw an error if this kind of sorting is detected.\n+     * //TODO: instead of throwing error, find a way to sort long and unsigned_long together", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7652e6671ce385c670231cc15292500311a8a785"}, "originalPosition": 16}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2104, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}