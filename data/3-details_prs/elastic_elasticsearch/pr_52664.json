{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc4NDc2NDk5", "number": 52664, "title": "EQL: Expand verification tests", "bodyText": "Expand verification tests\nFix some error messaging consistency in EqlParser\nRelated to #51873\n@costin Could you take a look and let me know if this is what you were looking for that github issue.\nThanks!", "createdAt": "2020-02-21T21:17:43Z", "url": "https://github.com/elastic/elasticsearch/pull/52664", "merged": true, "mergeCommit": {"oid": "8e02bc3b324efcbb0068550de16df9ff38ddb895"}, "closed": true, "closedAt": "2020-02-24T17:48:21Z", "author": {"login": "aleksmaus"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcGmYo8AH2gAyMzc4NDc2NDk5OmYxMmI1Zjk4OTAwZGQxYWU5NTQ3OGUyZjU3OWYzMWEyYTNmMzliZDY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcHe7G-AH2gAyMzc4NDc2NDk5OmM5ZTRjMWYwN2MyYmNlZDBkZWUyNjY1M2I4NzEyYTJiNWU1MTk5YzQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "f12b5f98900dd1ae95478e2f579f31a2a3f39bd6", "author": {"user": {"login": "aleksmaus", "name": "Aleksandr Maus"}}, "url": "https://github.com/elastic/elasticsearch/commit/f12b5f98900dd1ae95478e2f579f31a2a3f39bd6", "committedDate": "2020-02-21T21:12:56Z", "message": "EQL: Expand verification tests\n\nFix some error messaging consistency in EqlParser\n\nRelated to https://github.com/elastic/elasticsearch/issues/51873"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "30b29463dd4ac494a99207b6557525316a537532", "author": {"user": {"login": "aleksmaus", "name": "Aleksandr Maus"}}, "url": "https://github.com/elastic/elasticsearch/commit/30b29463dd4ac494a99207b6557525316a537532", "committedDate": "2020-02-21T22:06:01Z", "message": "Merge branch 'master' into feature/eql_verification_expanded"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzMjE4NzQ2", "url": "https://github.com/elastic/elasticsearch/pull/52664#pullrequestreview-363218746", "createdAt": "2020-02-24T08:21:59Z", "commit": {"oid": "30b29463dd4ac494a99207b6557525316a537532"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQwODoyMTo1OVrOFtYNgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQwODoyNToyNlrOFtYRww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEyNjkxNA==", "bodyText": "Single line, please.", "url": "https://github.com/elastic/elasticsearch/pull/52664#discussion_r383126914", "createdAt": "2020-02-24T08:21:59Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/analysis/VerifierTests.java", "diffHunk": "@@ -58,8 +81,280 @@ public void testMisspelledColumnWithMultipleOptions() {\n         assertEquals(\"1:11: Unknown column [pib], did you mean any of [pid, ppid]?\", error(\"foo where pib == 1\"));\n     }\n \n+    public void testPipesUnsupported() {\n+        assertEquals(\"1:20: Pipes are not supported\", errorParsing(\"process where true | head 6\"));\n+    }\n \n-    private static Map<String, EsField> loadEqlMapping(String name) {\n-        return TypesTests.loadMapping(name);\n+    public void testProcessRelationshipsUnsupported() {\n+        assertEquals(\"2:7: Process relationships are not supported\",\n+                errorParsing(\"process where opcode=1 and process_name == \\\"csrss.exe\\\"\\n\" +\n+                        \"  and descendant of [file where file_name == \\\"csrss.exe\\\" and opcode=0]\"));\n+        assertEquals(\"2:7: Process relationships are not supported\",\n+                errorParsing(\"process where process_name=\\\"svchost.exe\\\"\\n\" +\n+                        \"  and child of [file where file_name=\\\"svchost.exe\\\" and opcode=0]\"));\n+    }\n+\n+    public void testSequencesUnsupported() {\n+        assertEquals(\"1:1: Sequence is not supported\", errorParsing(\"sequence\\n\" +\n+                \"  [process where serial_event_id = 1]\\n\" +\n+                \"  [process where serial_event_id = 2]\"));\n+    }\n+\n+    public void testJoinUnsupported() {\n+        assertEquals(\"1:1: Join is not supported\", errorParsing(\"join by user_name\\n\" +\n+                \"  [process where opcode in (1,3) and process_name=\\\"smss.exe\\\"]\\n\" +\n+                \"  [process where opcode in (1,3) and process_name == \\\"python.exe\\\"]\"));\n+    }\n+\n+    // Some functions fail with \"Unsupported\" message at the parse stage\n+    public void testArrayFunctionsUnsupported() {\n+        assertEquals(\"1:16: Unsupported function [arrayContains]\",\n+                errorParsing(\"registry where arrayContains(bytes_written_string_list, 'En')\"));\n+        assertEquals(\"1:16: Unsupported function [arraySearch]\",\n+                errorParsing(\"registry where arraySearch(bytes_written_string_list, a, a == 'en-us')\"));\n+        assertEquals(\"1:16: Unsupported function [arrayCount]\",\n+                errorParsing(\"registry where arrayCount(bytes_written_string_list, s, s == '*-us') == 1\"));\n+    }\n+\n+    // Some functions fail with \"Unknown\" message at the parse stage\n+    // TODO (@costin): Should we make the error messaging consistent?\n+    public void testFunctionParsingUnknown() {\n+        assertEquals(\"1:15: Unknown function [matchLite]\",\n+                errorParsing(\"process where matchLite(?'.*?net1\\\\s+localgroup\\\\s+.*?', command_line)\"));\n+        assertEquals(\"1:15: Unknown function [safe]\",\n+                errorParsing(\"network where safe(divide(process_name, process_name))\"));\n+    }\n+\n+    // Test the known EQL functions that are not supported\n+    public void testFunctionVerificationUnknown() {\n+        assertEquals(\"1:26: Unknown function [substring]\",\n+                error(\"foo where user_domain == substring('abcdfeg', 0, 5)\"));\n+        assertEquals(\"1:25: Unknown function [endsWith]\",\n+                error(\"file where opcode=0 and endsWith(file_name, 'loREr.exe')\"));\n+        assertEquals(\"1:25: Unknown function [startsWith]\",\n+                error(\"file where opcode=0 and startsWith(file_name, 'explORER.EXE')\"));\n+        assertEquals(\"1:25: Unknown function [stringContains]\",\n+                error(\"file where opcode=0 and stringContains('ABCDEFGHIexplorer.exeJKLMNOP', file_name)\"));\n+        assertEquals(\"1:25: Unknown function [indexOf]\",\n+                error(\"file where opcode=0 and indexOf(file_name, 'plore') == 2\"));\n+        assertEquals(\"1:15: Unknown function [add]\",\n+                error(\"process where add(serial_event_id, 0) == 1\"));\n+        assertEquals(\"1:15: Unknown function [subtract]\",\n+                error(\"process where subtract(serial_event_id, -5) == 6\"));\n+        assertEquals(\"1:15: Unknown function [multiply]\",\n+                error(\"process where multiply(6, serial_event_id) == 30\"));\n+        assertEquals(\"1:15: Unknown function [divide]\",\n+                error(\"process where divide(30, 4.0) == 7.5\"));\n+        assertEquals(\"1:34: Unknown function [number]\",\n+                error(\"process where serial_event_id == number('5')\"));\n+        assertEquals(\"1:15: Unknown function [concat]\",\n+                error(\"process where concat(serial_event_id, ':', process_name, opcode) == '5:winINIT.exe3'\"));\n+        assertEquals(\"1:15: Unknown function [between]\",\n+                error(\"process where between(process_name, \\\"s\\\", \\\"e\\\") == \\\"yst\\\"\"));\n+        assertEquals(\"1:15: Unknown function [cidrMatch]\",\n+                error(\"network where cidrMatch(source_address, \\\"192.168.0.0/16\\\", \\\"10.6.48.157/8\\\")\"));\n+        assertEquals(\"1:22: Unknown function [between]\",\n+                error(\"process where length(between(process_name, 'g', 'e')) > 0\"));\n+    }\n+\n+    // Test unsupported array indexes\n+    public void testArrayIndexesUnsupported() {\n+        assertEquals(\"1:84: Array indexes are not supported\",\n+                errorParsing(\"registry where length(bytes_written_string_list) > 0 and bytes_written_string_list[0] == 'EN-us\"));\n+    }\n+\n+    // Test valid/supported queries\n+    public void testQueryOk() {\n+        // Mismatched type, still ok\n+        accept(\"process where serial_event_id = 'abcdef'\");\n+\n+        // Equals condition\n+        accept(\"process where serial_event_id = 1\");\n+\n+        // Less then condition\n+        accept(\"process where serial_event_id < 4\");\n+\n+        // Greater than\n+        accept(\"process where exit_code > -1\");\n+        accept(\"process where -1 < exit_code\");\n+\n+        // Or and And/And Not\n+        accept(\"process where process_name == \\\"impossible name\\\" or (serial_event_id < 4.5 and serial_event_id >= 3.1)\");\n+        accept(\"process where (serial_event_id<=8 and not serial_event_id > 7) and (opcode=3 and opcode>2)\");\n+\n+        // In statement\n+        accept(\"process where not (exit_code > -1)\\n\" +\n+                \"  and serial_event_id in (58, 64, 69, 74, 80, 85, 90, 93, 94)\");\n+\n+        // Combination\n+        accept(\"file where serial_event_id == 82 and (true == (process_name in ('svchost.EXE', 'bad.exe', 'bad2.exe')))\");\n+\n+        // String handling\n+        accept(\"process where process_path == \\\"*\\\\\\\\MACHINE\\\\\\\\SAM\\\\\\\\SAM\\\\\\\\*\\\\\\\\Account\\\\\\\\Us*ers\\\\\\\\00*03E9\\\\\\\\F\\\"\");\n+\n+        // Arithmetic operators\n+        accept(\"file where serial_event_id - 1 == 81\");\n+        accept(\"file where serial_event_id + 1 == 83\");\n+        accept(\"file where serial_event_id * 2 == 164\");\n+        accept(\"file where serial_event_id / 2 == 41\");\n+        accept(\"file where serial_event_id % 40 == 2\");\n+    }\n+\n+    // Test mapping that doesn't have property event_type defined\n+    public void testMissingEventType() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-missing-event-type.json\");\n+        assertEquals(\"1:1: Unknown column [event_type]\", error(idxr, \"foo where true\"));\n+    }\n+\n+    public void testAliasErrors() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-alias.json\");\n+\n+        // Check unsupported\n+        assertEquals(\"1:11: Cannot use field [user_name_alias] with unsupported type [alias]\",\n+                error(idxr, \"foo where user_name_alias == 'bob'\"));\n+\n+        // Check alias name typo\n+        assertEquals(\"1:11: Unknown column [user_name_alia], did you mean any of [user_name, user_domain]?\",\n+                error(idxr, \"foo where user_name_alia == 'bob'\"));\n+    }\n+\n+    // Test all elasticsearch numeric field types\n+    public void testNumeric() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-numeric.json\");\n+        accept(idxr, \"foo where long_field == 0\");\n+        accept(idxr, \"foo where integer_field == \" +\n+                \"0\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "30b29463dd4ac494a99207b6557525316a537532"}, "originalPosition": 206}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEyNzQ0Ng==", "bodyText": "Please, remove extra empty line.", "url": "https://github.com/elastic/elasticsearch/pull/52664#discussion_r383127446", "createdAt": "2020-02-24T08:23:41Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/analysis/VerifierTests.java", "diffHunk": "@@ -58,8 +81,280 @@ public void testMisspelledColumnWithMultipleOptions() {\n         assertEquals(\"1:11: Unknown column [pib], did you mean any of [pid, ppid]?\", error(\"foo where pib == 1\"));\n     }\n \n+    public void testPipesUnsupported() {\n+        assertEquals(\"1:20: Pipes are not supported\", errorParsing(\"process where true | head 6\"));\n+    }\n \n-    private static Map<String, EsField> loadEqlMapping(String name) {\n-        return TypesTests.loadMapping(name);\n+    public void testProcessRelationshipsUnsupported() {\n+        assertEquals(\"2:7: Process relationships are not supported\",\n+                errorParsing(\"process where opcode=1 and process_name == \\\"csrss.exe\\\"\\n\" +\n+                        \"  and descendant of [file where file_name == \\\"csrss.exe\\\" and opcode=0]\"));\n+        assertEquals(\"2:7: Process relationships are not supported\",\n+                errorParsing(\"process where process_name=\\\"svchost.exe\\\"\\n\" +\n+                        \"  and child of [file where file_name=\\\"svchost.exe\\\" and opcode=0]\"));\n+    }\n+\n+    public void testSequencesUnsupported() {\n+        assertEquals(\"1:1: Sequence is not supported\", errorParsing(\"sequence\\n\" +\n+                \"  [process where serial_event_id = 1]\\n\" +\n+                \"  [process where serial_event_id = 2]\"));\n+    }\n+\n+    public void testJoinUnsupported() {\n+        assertEquals(\"1:1: Join is not supported\", errorParsing(\"join by user_name\\n\" +\n+                \"  [process where opcode in (1,3) and process_name=\\\"smss.exe\\\"]\\n\" +\n+                \"  [process where opcode in (1,3) and process_name == \\\"python.exe\\\"]\"));\n+    }\n+\n+    // Some functions fail with \"Unsupported\" message at the parse stage\n+    public void testArrayFunctionsUnsupported() {\n+        assertEquals(\"1:16: Unsupported function [arrayContains]\",\n+                errorParsing(\"registry where arrayContains(bytes_written_string_list, 'En')\"));\n+        assertEquals(\"1:16: Unsupported function [arraySearch]\",\n+                errorParsing(\"registry where arraySearch(bytes_written_string_list, a, a == 'en-us')\"));\n+        assertEquals(\"1:16: Unsupported function [arrayCount]\",\n+                errorParsing(\"registry where arrayCount(bytes_written_string_list, s, s == '*-us') == 1\"));\n+    }\n+\n+    // Some functions fail with \"Unknown\" message at the parse stage\n+    // TODO (@costin): Should we make the error messaging consistent?\n+    public void testFunctionParsingUnknown() {\n+        assertEquals(\"1:15: Unknown function [matchLite]\",\n+                errorParsing(\"process where matchLite(?'.*?net1\\\\s+localgroup\\\\s+.*?', command_line)\"));\n+        assertEquals(\"1:15: Unknown function [safe]\",\n+                errorParsing(\"network where safe(divide(process_name, process_name))\"));\n+    }\n+\n+    // Test the known EQL functions that are not supported\n+    public void testFunctionVerificationUnknown() {\n+        assertEquals(\"1:26: Unknown function [substring]\",\n+                error(\"foo where user_domain == substring('abcdfeg', 0, 5)\"));\n+        assertEquals(\"1:25: Unknown function [endsWith]\",\n+                error(\"file where opcode=0 and endsWith(file_name, 'loREr.exe')\"));\n+        assertEquals(\"1:25: Unknown function [startsWith]\",\n+                error(\"file where opcode=0 and startsWith(file_name, 'explORER.EXE')\"));\n+        assertEquals(\"1:25: Unknown function [stringContains]\",\n+                error(\"file where opcode=0 and stringContains('ABCDEFGHIexplorer.exeJKLMNOP', file_name)\"));\n+        assertEquals(\"1:25: Unknown function [indexOf]\",\n+                error(\"file where opcode=0 and indexOf(file_name, 'plore') == 2\"));\n+        assertEquals(\"1:15: Unknown function [add]\",\n+                error(\"process where add(serial_event_id, 0) == 1\"));\n+        assertEquals(\"1:15: Unknown function [subtract]\",\n+                error(\"process where subtract(serial_event_id, -5) == 6\"));\n+        assertEquals(\"1:15: Unknown function [multiply]\",\n+                error(\"process where multiply(6, serial_event_id) == 30\"));\n+        assertEquals(\"1:15: Unknown function [divide]\",\n+                error(\"process where divide(30, 4.0) == 7.5\"));\n+        assertEquals(\"1:34: Unknown function [number]\",\n+                error(\"process where serial_event_id == number('5')\"));\n+        assertEquals(\"1:15: Unknown function [concat]\",\n+                error(\"process where concat(serial_event_id, ':', process_name, opcode) == '5:winINIT.exe3'\"));\n+        assertEquals(\"1:15: Unknown function [between]\",\n+                error(\"process where between(process_name, \\\"s\\\", \\\"e\\\") == \\\"yst\\\"\"));\n+        assertEquals(\"1:15: Unknown function [cidrMatch]\",\n+                error(\"network where cidrMatch(source_address, \\\"192.168.0.0/16\\\", \\\"10.6.48.157/8\\\")\"));\n+        assertEquals(\"1:22: Unknown function [between]\",\n+                error(\"process where length(between(process_name, 'g', 'e')) > 0\"));\n+    }\n+\n+    // Test unsupported array indexes\n+    public void testArrayIndexesUnsupported() {\n+        assertEquals(\"1:84: Array indexes are not supported\",\n+                errorParsing(\"registry where length(bytes_written_string_list) > 0 and bytes_written_string_list[0] == 'EN-us\"));\n+    }\n+\n+    // Test valid/supported queries\n+    public void testQueryOk() {\n+        // Mismatched type, still ok\n+        accept(\"process where serial_event_id = 'abcdef'\");\n+\n+        // Equals condition\n+        accept(\"process where serial_event_id = 1\");\n+\n+        // Less then condition\n+        accept(\"process where serial_event_id < 4\");\n+\n+        // Greater than\n+        accept(\"process where exit_code > -1\");\n+        accept(\"process where -1 < exit_code\");\n+\n+        // Or and And/And Not\n+        accept(\"process where process_name == \\\"impossible name\\\" or (serial_event_id < 4.5 and serial_event_id >= 3.1)\");\n+        accept(\"process where (serial_event_id<=8 and not serial_event_id > 7) and (opcode=3 and opcode>2)\");\n+\n+        // In statement\n+        accept(\"process where not (exit_code > -1)\\n\" +\n+                \"  and serial_event_id in (58, 64, 69, 74, 80, 85, 90, 93, 94)\");\n+\n+        // Combination\n+        accept(\"file where serial_event_id == 82 and (true == (process_name in ('svchost.EXE', 'bad.exe', 'bad2.exe')))\");\n+\n+        // String handling\n+        accept(\"process where process_path == \\\"*\\\\\\\\MACHINE\\\\\\\\SAM\\\\\\\\SAM\\\\\\\\*\\\\\\\\Account\\\\\\\\Us*ers\\\\\\\\00*03E9\\\\\\\\F\\\"\");\n+\n+        // Arithmetic operators\n+        accept(\"file where serial_event_id - 1 == 81\");\n+        accept(\"file where serial_event_id + 1 == 83\");\n+        accept(\"file where serial_event_id * 2 == 164\");\n+        accept(\"file where serial_event_id / 2 == 41\");\n+        accept(\"file where serial_event_id % 40 == 2\");\n+    }\n+\n+    // Test mapping that doesn't have property event_type defined\n+    public void testMissingEventType() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-missing-event-type.json\");\n+        assertEquals(\"1:1: Unknown column [event_type]\", error(idxr, \"foo where true\"));\n+    }\n+\n+    public void testAliasErrors() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-alias.json\");\n+\n+        // Check unsupported\n+        assertEquals(\"1:11: Cannot use field [user_name_alias] with unsupported type [alias]\",\n+                error(idxr, \"foo where user_name_alias == 'bob'\"));\n+\n+        // Check alias name typo\n+        assertEquals(\"1:11: Unknown column [user_name_alia], did you mean any of [user_name, user_domain]?\",\n+                error(idxr, \"foo where user_name_alia == 'bob'\"));\n+    }\n+\n+    // Test all elasticsearch numeric field types\n+    public void testNumeric() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-numeric.json\");\n+        accept(idxr, \"foo where long_field == 0\");\n+        accept(idxr, \"foo where integer_field == \" +\n+                \"0\");\n+        accept(idxr, \"foo where short_field == 0\");\n+        accept(idxr, \"foo where byte_field == 0\");\n+        accept(idxr, \"foo where double_field == 0\");\n+        accept(idxr, \"foo where float_field == 0\");\n+        accept(idxr, \"foo where half_float_field == 0\");\n+        accept(idxr, \"foo where scaled_float_field == 0\");\n+\n+        // Test query against unsupported field type int\n+        assertEquals(\"1:11: Cannot use field [wrong_int_type_field] with unsupported type [int]\",\n+                error(idxr, \"foo where wrong_int_type_field == 0\"));\n+    }\n+\n+    public void testNoDoc() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-nodoc.json\");\n+        accept(idxr, \"foo where description_nodoc == ''\");\n+        // TODO: add sort test on nodoc field once we have pipes support\n+    }\n+\n+    public void testDate() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-date.json\");\n+        accept(idxr, \"foo where date == ''\");\n+        accept(idxr, \"foo where date == '2020-02-02'\");\n+        accept(idxr, \"foo where date == '2020-02-41'\");\n+        accept(idxr, \"foo where date == '20200241'\");\n+\n+        accept(idxr, \"foo where date_with_format == ''\");\n+        accept(idxr, \"foo where date_with_format == '2020-02-02'\");\n+        accept(idxr, \"foo where date_with_format == '2020-02-41'\");\n+        accept(idxr, \"foo where date_with_format == '20200241'\");\n+\n+        accept(idxr, \"foo where date_with_multi_format == ''\");\n+        accept(idxr, \"foo where date_with_multi_format == '2020-02-02'\");\n+        accept(idxr, \"foo where date_with_multi_format == '2020-02-41'\");\n+        accept(idxr, \"foo where date_with_multi_format == '20200241'\");\n+        accept(idxr, \"foo where date_with_multi_format == '11:12:13'\");\n+\n+        // Test query against unsupported field type date_nanos\n+        assertEquals(\"1:11: Cannot use field [date_nanos_field] with unsupported type [date_nanos]\",\n+                error(idxr, \"foo where date_nanos_field == ''\"));\n+    }\n+\n+    public void testBoolean() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-boolean.json\");\n+        accept(idxr, \"foo where boolean_field == true\");\n+        accept(idxr, \"foo where boolean_field == 'bar'\");\n+        accept(idxr, \"foo where boolean_field == 0\");\n+        accept(idxr, \"foo where boolean_field == 123456\");\n+    }\n+\n+    public void testBinary() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-binary.json\");\n+        accept(idxr, \"foo where blob == ''\");\n+        accept(idxr, \"foo where blob == 'bar'\");\n+        accept(idxr, \"foo where blob == 0\");\n+        accept(idxr, \"foo where blob == 123456\");\n+    }\n+\n+    public void testRange() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-range.json\");\n+        assertEquals(\"1:11: Cannot use field [integer_range_field] with unsupported type [integer_range]\",\n+                error(idxr, \"foo where integer_range_field == ''\"));\n+        assertEquals(\"1:11: Cannot use field [float_range_field] with unsupported type [float_range]\",\n+                error(idxr, \"foo where float_range_field == ''\"));\n+        assertEquals(\"1:11: Cannot use field [long_range_field] with unsupported type [long_range]\",\n+                error(idxr, \"foo where long_range_field == ''\"));\n+        assertEquals(\"1:11: Cannot use field [double_range_field] with unsupported type [double_range]\",\n+                error(idxr, \"foo where double_range_field == ''\"));\n+        assertEquals(\"1:11: Cannot use field [date_range_field] with unsupported type [date_range]\",\n+                error(idxr, \"foo where date_range_field == ''\"));\n+        assertEquals(\"1:11: Cannot use field [ip_range_field] with unsupported type [ip_range]\",\n+                error(idxr, \"foo where ip_range_field == ''\"));\n+    }\n+\n+    public void testObject() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-object.json\");\n+        accept(idxr, \"foo where endgame.pid == 0\");\n+\n+        assertEquals(\"1:11: Unknown column [endgame.pi], did you mean [endgame.pid]?\",\n+                error(idxr, \"foo where endgame.pi == 0\"));\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "30b29463dd4ac494a99207b6557525316a537532"}, "originalPosition": 286}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEyNzgyNw==", "bodyText": "I think this error message is wrong, unless EQL plans to support MATCH/QUERY predicates.", "url": "https://github.com/elastic/elasticsearch/pull/52664#discussion_r383127827", "createdAt": "2020-02-24T08:24:56Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/analysis/VerifierTests.java", "diffHunk": "@@ -58,8 +81,280 @@ public void testMisspelledColumnWithMultipleOptions() {\n         assertEquals(\"1:11: Unknown column [pib], did you mean any of [pid, ppid]?\", error(\"foo where pib == 1\"));\n     }\n \n+    public void testPipesUnsupported() {\n+        assertEquals(\"1:20: Pipes are not supported\", errorParsing(\"process where true | head 6\"));\n+    }\n \n-    private static Map<String, EsField> loadEqlMapping(String name) {\n-        return TypesTests.loadMapping(name);\n+    public void testProcessRelationshipsUnsupported() {\n+        assertEquals(\"2:7: Process relationships are not supported\",\n+                errorParsing(\"process where opcode=1 and process_name == \\\"csrss.exe\\\"\\n\" +\n+                        \"  and descendant of [file where file_name == \\\"csrss.exe\\\" and opcode=0]\"));\n+        assertEquals(\"2:7: Process relationships are not supported\",\n+                errorParsing(\"process where process_name=\\\"svchost.exe\\\"\\n\" +\n+                        \"  and child of [file where file_name=\\\"svchost.exe\\\" and opcode=0]\"));\n+    }\n+\n+    public void testSequencesUnsupported() {\n+        assertEquals(\"1:1: Sequence is not supported\", errorParsing(\"sequence\\n\" +\n+                \"  [process where serial_event_id = 1]\\n\" +\n+                \"  [process where serial_event_id = 2]\"));\n+    }\n+\n+    public void testJoinUnsupported() {\n+        assertEquals(\"1:1: Join is not supported\", errorParsing(\"join by user_name\\n\" +\n+                \"  [process where opcode in (1,3) and process_name=\\\"smss.exe\\\"]\\n\" +\n+                \"  [process where opcode in (1,3) and process_name == \\\"python.exe\\\"]\"));\n+    }\n+\n+    // Some functions fail with \"Unsupported\" message at the parse stage\n+    public void testArrayFunctionsUnsupported() {\n+        assertEquals(\"1:16: Unsupported function [arrayContains]\",\n+                errorParsing(\"registry where arrayContains(bytes_written_string_list, 'En')\"));\n+        assertEquals(\"1:16: Unsupported function [arraySearch]\",\n+                errorParsing(\"registry where arraySearch(bytes_written_string_list, a, a == 'en-us')\"));\n+        assertEquals(\"1:16: Unsupported function [arrayCount]\",\n+                errorParsing(\"registry where arrayCount(bytes_written_string_list, s, s == '*-us') == 1\"));\n+    }\n+\n+    // Some functions fail with \"Unknown\" message at the parse stage\n+    // TODO (@costin): Should we make the error messaging consistent?\n+    public void testFunctionParsingUnknown() {\n+        assertEquals(\"1:15: Unknown function [matchLite]\",\n+                errorParsing(\"process where matchLite(?'.*?net1\\\\s+localgroup\\\\s+.*?', command_line)\"));\n+        assertEquals(\"1:15: Unknown function [safe]\",\n+                errorParsing(\"network where safe(divide(process_name, process_name))\"));\n+    }\n+\n+    // Test the known EQL functions that are not supported\n+    public void testFunctionVerificationUnknown() {\n+        assertEquals(\"1:26: Unknown function [substring]\",\n+                error(\"foo where user_domain == substring('abcdfeg', 0, 5)\"));\n+        assertEquals(\"1:25: Unknown function [endsWith]\",\n+                error(\"file where opcode=0 and endsWith(file_name, 'loREr.exe')\"));\n+        assertEquals(\"1:25: Unknown function [startsWith]\",\n+                error(\"file where opcode=0 and startsWith(file_name, 'explORER.EXE')\"));\n+        assertEquals(\"1:25: Unknown function [stringContains]\",\n+                error(\"file where opcode=0 and stringContains('ABCDEFGHIexplorer.exeJKLMNOP', file_name)\"));\n+        assertEquals(\"1:25: Unknown function [indexOf]\",\n+                error(\"file where opcode=0 and indexOf(file_name, 'plore') == 2\"));\n+        assertEquals(\"1:15: Unknown function [add]\",\n+                error(\"process where add(serial_event_id, 0) == 1\"));\n+        assertEquals(\"1:15: Unknown function [subtract]\",\n+                error(\"process where subtract(serial_event_id, -5) == 6\"));\n+        assertEquals(\"1:15: Unknown function [multiply]\",\n+                error(\"process where multiply(6, serial_event_id) == 30\"));\n+        assertEquals(\"1:15: Unknown function [divide]\",\n+                error(\"process where divide(30, 4.0) == 7.5\"));\n+        assertEquals(\"1:34: Unknown function [number]\",\n+                error(\"process where serial_event_id == number('5')\"));\n+        assertEquals(\"1:15: Unknown function [concat]\",\n+                error(\"process where concat(serial_event_id, ':', process_name, opcode) == '5:winINIT.exe3'\"));\n+        assertEquals(\"1:15: Unknown function [between]\",\n+                error(\"process where between(process_name, \\\"s\\\", \\\"e\\\") == \\\"yst\\\"\"));\n+        assertEquals(\"1:15: Unknown function [cidrMatch]\",\n+                error(\"network where cidrMatch(source_address, \\\"192.168.0.0/16\\\", \\\"10.6.48.157/8\\\")\"));\n+        assertEquals(\"1:22: Unknown function [between]\",\n+                error(\"process where length(between(process_name, 'g', 'e')) > 0\"));\n+    }\n+\n+    // Test unsupported array indexes\n+    public void testArrayIndexesUnsupported() {\n+        assertEquals(\"1:84: Array indexes are not supported\",\n+                errorParsing(\"registry where length(bytes_written_string_list) > 0 and bytes_written_string_list[0] == 'EN-us\"));\n+    }\n+\n+    // Test valid/supported queries\n+    public void testQueryOk() {\n+        // Mismatched type, still ok\n+        accept(\"process where serial_event_id = 'abcdef'\");\n+\n+        // Equals condition\n+        accept(\"process where serial_event_id = 1\");\n+\n+        // Less then condition\n+        accept(\"process where serial_event_id < 4\");\n+\n+        // Greater than\n+        accept(\"process where exit_code > -1\");\n+        accept(\"process where -1 < exit_code\");\n+\n+        // Or and And/And Not\n+        accept(\"process where process_name == \\\"impossible name\\\" or (serial_event_id < 4.5 and serial_event_id >= 3.1)\");\n+        accept(\"process where (serial_event_id<=8 and not serial_event_id > 7) and (opcode=3 and opcode>2)\");\n+\n+        // In statement\n+        accept(\"process where not (exit_code > -1)\\n\" +\n+                \"  and serial_event_id in (58, 64, 69, 74, 80, 85, 90, 93, 94)\");\n+\n+        // Combination\n+        accept(\"file where serial_event_id == 82 and (true == (process_name in ('svchost.EXE', 'bad.exe', 'bad2.exe')))\");\n+\n+        // String handling\n+        accept(\"process where process_path == \\\"*\\\\\\\\MACHINE\\\\\\\\SAM\\\\\\\\SAM\\\\\\\\*\\\\\\\\Account\\\\\\\\Us*ers\\\\\\\\00*03E9\\\\\\\\F\\\"\");\n+\n+        // Arithmetic operators\n+        accept(\"file where serial_event_id - 1 == 81\");\n+        accept(\"file where serial_event_id + 1 == 83\");\n+        accept(\"file where serial_event_id * 2 == 164\");\n+        accept(\"file where serial_event_id / 2 == 41\");\n+        accept(\"file where serial_event_id % 40 == 2\");\n+    }\n+\n+    // Test mapping that doesn't have property event_type defined\n+    public void testMissingEventType() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-missing-event-type.json\");\n+        assertEquals(\"1:1: Unknown column [event_type]\", error(idxr, \"foo where true\"));\n+    }\n+\n+    public void testAliasErrors() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-alias.json\");\n+\n+        // Check unsupported\n+        assertEquals(\"1:11: Cannot use field [user_name_alias] with unsupported type [alias]\",\n+                error(idxr, \"foo where user_name_alias == 'bob'\"));\n+\n+        // Check alias name typo\n+        assertEquals(\"1:11: Unknown column [user_name_alia], did you mean any of [user_name, user_domain]?\",\n+                error(idxr, \"foo where user_name_alia == 'bob'\"));\n+    }\n+\n+    // Test all elasticsearch numeric field types\n+    public void testNumeric() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-numeric.json\");\n+        accept(idxr, \"foo where long_field == 0\");\n+        accept(idxr, \"foo where integer_field == \" +\n+                \"0\");\n+        accept(idxr, \"foo where short_field == 0\");\n+        accept(idxr, \"foo where byte_field == 0\");\n+        accept(idxr, \"foo where double_field == 0\");\n+        accept(idxr, \"foo where float_field == 0\");\n+        accept(idxr, \"foo where half_float_field == 0\");\n+        accept(idxr, \"foo where scaled_float_field == 0\");\n+\n+        // Test query against unsupported field type int\n+        assertEquals(\"1:11: Cannot use field [wrong_int_type_field] with unsupported type [int]\",\n+                error(idxr, \"foo where wrong_int_type_field == 0\"));\n+    }\n+\n+    public void testNoDoc() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-nodoc.json\");\n+        accept(idxr, \"foo where description_nodoc == ''\");\n+        // TODO: add sort test on nodoc field once we have pipes support\n+    }\n+\n+    public void testDate() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-date.json\");\n+        accept(idxr, \"foo where date == ''\");\n+        accept(idxr, \"foo where date == '2020-02-02'\");\n+        accept(idxr, \"foo where date == '2020-02-41'\");\n+        accept(idxr, \"foo where date == '20200241'\");\n+\n+        accept(idxr, \"foo where date_with_format == ''\");\n+        accept(idxr, \"foo where date_with_format == '2020-02-02'\");\n+        accept(idxr, \"foo where date_with_format == '2020-02-41'\");\n+        accept(idxr, \"foo where date_with_format == '20200241'\");\n+\n+        accept(idxr, \"foo where date_with_multi_format == ''\");\n+        accept(idxr, \"foo where date_with_multi_format == '2020-02-02'\");\n+        accept(idxr, \"foo where date_with_multi_format == '2020-02-41'\");\n+        accept(idxr, \"foo where date_with_multi_format == '20200241'\");\n+        accept(idxr, \"foo where date_with_multi_format == '11:12:13'\");\n+\n+        // Test query against unsupported field type date_nanos\n+        assertEquals(\"1:11: Cannot use field [date_nanos_field] with unsupported type [date_nanos]\",\n+                error(idxr, \"foo where date_nanos_field == ''\"));\n+    }\n+\n+    public void testBoolean() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-boolean.json\");\n+        accept(idxr, \"foo where boolean_field == true\");\n+        accept(idxr, \"foo where boolean_field == 'bar'\");\n+        accept(idxr, \"foo where boolean_field == 0\");\n+        accept(idxr, \"foo where boolean_field == 123456\");\n+    }\n+\n+    public void testBinary() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-binary.json\");\n+        accept(idxr, \"foo where blob == ''\");\n+        accept(idxr, \"foo where blob == 'bar'\");\n+        accept(idxr, \"foo where blob == 0\");\n+        accept(idxr, \"foo where blob == 123456\");\n+    }\n+\n+    public void testRange() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-range.json\");\n+        assertEquals(\"1:11: Cannot use field [integer_range_field] with unsupported type [integer_range]\",\n+                error(idxr, \"foo where integer_range_field == ''\"));\n+        assertEquals(\"1:11: Cannot use field [float_range_field] with unsupported type [float_range]\",\n+                error(idxr, \"foo where float_range_field == ''\"));\n+        assertEquals(\"1:11: Cannot use field [long_range_field] with unsupported type [long_range]\",\n+                error(idxr, \"foo where long_range_field == ''\"));\n+        assertEquals(\"1:11: Cannot use field [double_range_field] with unsupported type [double_range]\",\n+                error(idxr, \"foo where double_range_field == ''\"));\n+        assertEquals(\"1:11: Cannot use field [date_range_field] with unsupported type [date_range]\",\n+                error(idxr, \"foo where date_range_field == ''\"));\n+        assertEquals(\"1:11: Cannot use field [ip_range_field] with unsupported type [ip_range]\",\n+                error(idxr, \"foo where ip_range_field == ''\"));\n+    }\n+\n+    public void testObject() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-object.json\");\n+        accept(idxr, \"foo where endgame.pid == 0\");\n+\n+        assertEquals(\"1:11: Unknown column [endgame.pi], did you mean [endgame.pid]?\",\n+                error(idxr, \"foo where endgame.pi == 0\"));\n+\n+    }\n+\n+    public void testNested() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-nested.json\");\n+        accept(idxr, \"foo where processes.pid == 0\");\n+\n+        assertEquals(\"1:11: Unknown column [processe.pid], did you mean any of [processes.pid, processes.path, processes.path.keyword]?\",\n+                error(idxr, \"foo where processe.pid == 0\"));\n+    }\n+\n+    public void testGeo() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-geo.json\");\n+        assertEquals(\"1:11: Cannot use field [location] with unsupported type [geo_point]\",\n+                error(idxr, \"foo where location == 0\"));\n+        assertEquals(\"1:11: Cannot use field [site] with unsupported type [geo_shape]\",\n+                error(idxr, \"foo where site == 0\"));\n+    }\n+\n+    public void testIP() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-ip.json\");\n+        accept(idxr, \"foo where ip_addr == 0\");\n+    }\n+\n+    public void testJoin() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-join.json\");\n+        accept(idxr, \"foo where serial_event_id == 0\");\n+    }\n+\n+    public void testMultiField() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-multi-field.json\");\n+        accept(idxr, \"foo where multi_field.raw == 'bar'\");\n+\n+        assertEquals(\"1:11: [multi_field.english == 'bar'] cannot operate on first argument field of data type [text]: \" +\n+                        \"No keyword/multi-field defined exact matches for [english]; define one or use MATCH/QUERY instead\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "30b29463dd4ac494a99207b6557525316a537532"}, "originalPosition": 320}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEyODAwMw==", "bodyText": "Same here about MATCH/QUERY predicates.", "url": "https://github.com/elastic/elasticsearch/pull/52664#discussion_r383128003", "createdAt": "2020-02-24T08:25:26Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/analysis/VerifierTests.java", "diffHunk": "@@ -58,8 +81,280 @@ public void testMisspelledColumnWithMultipleOptions() {\n         assertEquals(\"1:11: Unknown column [pib], did you mean any of [pid, ppid]?\", error(\"foo where pib == 1\"));\n     }\n \n+    public void testPipesUnsupported() {\n+        assertEquals(\"1:20: Pipes are not supported\", errorParsing(\"process where true | head 6\"));\n+    }\n \n-    private static Map<String, EsField> loadEqlMapping(String name) {\n-        return TypesTests.loadMapping(name);\n+    public void testProcessRelationshipsUnsupported() {\n+        assertEquals(\"2:7: Process relationships are not supported\",\n+                errorParsing(\"process where opcode=1 and process_name == \\\"csrss.exe\\\"\\n\" +\n+                        \"  and descendant of [file where file_name == \\\"csrss.exe\\\" and opcode=0]\"));\n+        assertEquals(\"2:7: Process relationships are not supported\",\n+                errorParsing(\"process where process_name=\\\"svchost.exe\\\"\\n\" +\n+                        \"  and child of [file where file_name=\\\"svchost.exe\\\" and opcode=0]\"));\n+    }\n+\n+    public void testSequencesUnsupported() {\n+        assertEquals(\"1:1: Sequence is not supported\", errorParsing(\"sequence\\n\" +\n+                \"  [process where serial_event_id = 1]\\n\" +\n+                \"  [process where serial_event_id = 2]\"));\n+    }\n+\n+    public void testJoinUnsupported() {\n+        assertEquals(\"1:1: Join is not supported\", errorParsing(\"join by user_name\\n\" +\n+                \"  [process where opcode in (1,3) and process_name=\\\"smss.exe\\\"]\\n\" +\n+                \"  [process where opcode in (1,3) and process_name == \\\"python.exe\\\"]\"));\n+    }\n+\n+    // Some functions fail with \"Unsupported\" message at the parse stage\n+    public void testArrayFunctionsUnsupported() {\n+        assertEquals(\"1:16: Unsupported function [arrayContains]\",\n+                errorParsing(\"registry where arrayContains(bytes_written_string_list, 'En')\"));\n+        assertEquals(\"1:16: Unsupported function [arraySearch]\",\n+                errorParsing(\"registry where arraySearch(bytes_written_string_list, a, a == 'en-us')\"));\n+        assertEquals(\"1:16: Unsupported function [arrayCount]\",\n+                errorParsing(\"registry where arrayCount(bytes_written_string_list, s, s == '*-us') == 1\"));\n+    }\n+\n+    // Some functions fail with \"Unknown\" message at the parse stage\n+    // TODO (@costin): Should we make the error messaging consistent?\n+    public void testFunctionParsingUnknown() {\n+        assertEquals(\"1:15: Unknown function [matchLite]\",\n+                errorParsing(\"process where matchLite(?'.*?net1\\\\s+localgroup\\\\s+.*?', command_line)\"));\n+        assertEquals(\"1:15: Unknown function [safe]\",\n+                errorParsing(\"network where safe(divide(process_name, process_name))\"));\n+    }\n+\n+    // Test the known EQL functions that are not supported\n+    public void testFunctionVerificationUnknown() {\n+        assertEquals(\"1:26: Unknown function [substring]\",\n+                error(\"foo where user_domain == substring('abcdfeg', 0, 5)\"));\n+        assertEquals(\"1:25: Unknown function [endsWith]\",\n+                error(\"file where opcode=0 and endsWith(file_name, 'loREr.exe')\"));\n+        assertEquals(\"1:25: Unknown function [startsWith]\",\n+                error(\"file where opcode=0 and startsWith(file_name, 'explORER.EXE')\"));\n+        assertEquals(\"1:25: Unknown function [stringContains]\",\n+                error(\"file where opcode=0 and stringContains('ABCDEFGHIexplorer.exeJKLMNOP', file_name)\"));\n+        assertEquals(\"1:25: Unknown function [indexOf]\",\n+                error(\"file where opcode=0 and indexOf(file_name, 'plore') == 2\"));\n+        assertEquals(\"1:15: Unknown function [add]\",\n+                error(\"process where add(serial_event_id, 0) == 1\"));\n+        assertEquals(\"1:15: Unknown function [subtract]\",\n+                error(\"process where subtract(serial_event_id, -5) == 6\"));\n+        assertEquals(\"1:15: Unknown function [multiply]\",\n+                error(\"process where multiply(6, serial_event_id) == 30\"));\n+        assertEquals(\"1:15: Unknown function [divide]\",\n+                error(\"process where divide(30, 4.0) == 7.5\"));\n+        assertEquals(\"1:34: Unknown function [number]\",\n+                error(\"process where serial_event_id == number('5')\"));\n+        assertEquals(\"1:15: Unknown function [concat]\",\n+                error(\"process where concat(serial_event_id, ':', process_name, opcode) == '5:winINIT.exe3'\"));\n+        assertEquals(\"1:15: Unknown function [between]\",\n+                error(\"process where between(process_name, \\\"s\\\", \\\"e\\\") == \\\"yst\\\"\"));\n+        assertEquals(\"1:15: Unknown function [cidrMatch]\",\n+                error(\"network where cidrMatch(source_address, \\\"192.168.0.0/16\\\", \\\"10.6.48.157/8\\\")\"));\n+        assertEquals(\"1:22: Unknown function [between]\",\n+                error(\"process where length(between(process_name, 'g', 'e')) > 0\"));\n+    }\n+\n+    // Test unsupported array indexes\n+    public void testArrayIndexesUnsupported() {\n+        assertEquals(\"1:84: Array indexes are not supported\",\n+                errorParsing(\"registry where length(bytes_written_string_list) > 0 and bytes_written_string_list[0] == 'EN-us\"));\n+    }\n+\n+    // Test valid/supported queries\n+    public void testQueryOk() {\n+        // Mismatched type, still ok\n+        accept(\"process where serial_event_id = 'abcdef'\");\n+\n+        // Equals condition\n+        accept(\"process where serial_event_id = 1\");\n+\n+        // Less then condition\n+        accept(\"process where serial_event_id < 4\");\n+\n+        // Greater than\n+        accept(\"process where exit_code > -1\");\n+        accept(\"process where -1 < exit_code\");\n+\n+        // Or and And/And Not\n+        accept(\"process where process_name == \\\"impossible name\\\" or (serial_event_id < 4.5 and serial_event_id >= 3.1)\");\n+        accept(\"process where (serial_event_id<=8 and not serial_event_id > 7) and (opcode=3 and opcode>2)\");\n+\n+        // In statement\n+        accept(\"process where not (exit_code > -1)\\n\" +\n+                \"  and serial_event_id in (58, 64, 69, 74, 80, 85, 90, 93, 94)\");\n+\n+        // Combination\n+        accept(\"file where serial_event_id == 82 and (true == (process_name in ('svchost.EXE', 'bad.exe', 'bad2.exe')))\");\n+\n+        // String handling\n+        accept(\"process where process_path == \\\"*\\\\\\\\MACHINE\\\\\\\\SAM\\\\\\\\SAM\\\\\\\\*\\\\\\\\Account\\\\\\\\Us*ers\\\\\\\\00*03E9\\\\\\\\F\\\"\");\n+\n+        // Arithmetic operators\n+        accept(\"file where serial_event_id - 1 == 81\");\n+        accept(\"file where serial_event_id + 1 == 83\");\n+        accept(\"file where serial_event_id * 2 == 164\");\n+        accept(\"file where serial_event_id / 2 == 41\");\n+        accept(\"file where serial_event_id % 40 == 2\");\n+    }\n+\n+    // Test mapping that doesn't have property event_type defined\n+    public void testMissingEventType() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-missing-event-type.json\");\n+        assertEquals(\"1:1: Unknown column [event_type]\", error(idxr, \"foo where true\"));\n+    }\n+\n+    public void testAliasErrors() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-alias.json\");\n+\n+        // Check unsupported\n+        assertEquals(\"1:11: Cannot use field [user_name_alias] with unsupported type [alias]\",\n+                error(idxr, \"foo where user_name_alias == 'bob'\"));\n+\n+        // Check alias name typo\n+        assertEquals(\"1:11: Unknown column [user_name_alia], did you mean any of [user_name, user_domain]?\",\n+                error(idxr, \"foo where user_name_alia == 'bob'\"));\n+    }\n+\n+    // Test all elasticsearch numeric field types\n+    public void testNumeric() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-numeric.json\");\n+        accept(idxr, \"foo where long_field == 0\");\n+        accept(idxr, \"foo where integer_field == \" +\n+                \"0\");\n+        accept(idxr, \"foo where short_field == 0\");\n+        accept(idxr, \"foo where byte_field == 0\");\n+        accept(idxr, \"foo where double_field == 0\");\n+        accept(idxr, \"foo where float_field == 0\");\n+        accept(idxr, \"foo where half_float_field == 0\");\n+        accept(idxr, \"foo where scaled_float_field == 0\");\n+\n+        // Test query against unsupported field type int\n+        assertEquals(\"1:11: Cannot use field [wrong_int_type_field] with unsupported type [int]\",\n+                error(idxr, \"foo where wrong_int_type_field == 0\"));\n+    }\n+\n+    public void testNoDoc() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-nodoc.json\");\n+        accept(idxr, \"foo where description_nodoc == ''\");\n+        // TODO: add sort test on nodoc field once we have pipes support\n+    }\n+\n+    public void testDate() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-date.json\");\n+        accept(idxr, \"foo where date == ''\");\n+        accept(idxr, \"foo where date == '2020-02-02'\");\n+        accept(idxr, \"foo where date == '2020-02-41'\");\n+        accept(idxr, \"foo where date == '20200241'\");\n+\n+        accept(idxr, \"foo where date_with_format == ''\");\n+        accept(idxr, \"foo where date_with_format == '2020-02-02'\");\n+        accept(idxr, \"foo where date_with_format == '2020-02-41'\");\n+        accept(idxr, \"foo where date_with_format == '20200241'\");\n+\n+        accept(idxr, \"foo where date_with_multi_format == ''\");\n+        accept(idxr, \"foo where date_with_multi_format == '2020-02-02'\");\n+        accept(idxr, \"foo where date_with_multi_format == '2020-02-41'\");\n+        accept(idxr, \"foo where date_with_multi_format == '20200241'\");\n+        accept(idxr, \"foo where date_with_multi_format == '11:12:13'\");\n+\n+        // Test query against unsupported field type date_nanos\n+        assertEquals(\"1:11: Cannot use field [date_nanos_field] with unsupported type [date_nanos]\",\n+                error(idxr, \"foo where date_nanos_field == ''\"));\n+    }\n+\n+    public void testBoolean() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-boolean.json\");\n+        accept(idxr, \"foo where boolean_field == true\");\n+        accept(idxr, \"foo where boolean_field == 'bar'\");\n+        accept(idxr, \"foo where boolean_field == 0\");\n+        accept(idxr, \"foo where boolean_field == 123456\");\n+    }\n+\n+    public void testBinary() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-binary.json\");\n+        accept(idxr, \"foo where blob == ''\");\n+        accept(idxr, \"foo where blob == 'bar'\");\n+        accept(idxr, \"foo where blob == 0\");\n+        accept(idxr, \"foo where blob == 123456\");\n+    }\n+\n+    public void testRange() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-range.json\");\n+        assertEquals(\"1:11: Cannot use field [integer_range_field] with unsupported type [integer_range]\",\n+                error(idxr, \"foo where integer_range_field == ''\"));\n+        assertEquals(\"1:11: Cannot use field [float_range_field] with unsupported type [float_range]\",\n+                error(idxr, \"foo where float_range_field == ''\"));\n+        assertEquals(\"1:11: Cannot use field [long_range_field] with unsupported type [long_range]\",\n+                error(idxr, \"foo where long_range_field == ''\"));\n+        assertEquals(\"1:11: Cannot use field [double_range_field] with unsupported type [double_range]\",\n+                error(idxr, \"foo where double_range_field == ''\"));\n+        assertEquals(\"1:11: Cannot use field [date_range_field] with unsupported type [date_range]\",\n+                error(idxr, \"foo where date_range_field == ''\"));\n+        assertEquals(\"1:11: Cannot use field [ip_range_field] with unsupported type [ip_range]\",\n+                error(idxr, \"foo where ip_range_field == ''\"));\n+    }\n+\n+    public void testObject() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-object.json\");\n+        accept(idxr, \"foo where endgame.pid == 0\");\n+\n+        assertEquals(\"1:11: Unknown column [endgame.pi], did you mean [endgame.pid]?\",\n+                error(idxr, \"foo where endgame.pi == 0\"));\n+\n+    }\n+\n+    public void testNested() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-nested.json\");\n+        accept(idxr, \"foo where processes.pid == 0\");\n+\n+        assertEquals(\"1:11: Unknown column [processe.pid], did you mean any of [processes.pid, processes.path, processes.path.keyword]?\",\n+                error(idxr, \"foo where processe.pid == 0\"));\n+    }\n+\n+    public void testGeo() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-geo.json\");\n+        assertEquals(\"1:11: Cannot use field [location] with unsupported type [geo_point]\",\n+                error(idxr, \"foo where location == 0\"));\n+        assertEquals(\"1:11: Cannot use field [site] with unsupported type [geo_shape]\",\n+                error(idxr, \"foo where site == 0\"));\n+    }\n+\n+    public void testIP() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-ip.json\");\n+        accept(idxr, \"foo where ip_addr == 0\");\n+    }\n+\n+    public void testJoin() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-join.json\");\n+        accept(idxr, \"foo where serial_event_id == 0\");\n+    }\n+\n+    public void testMultiField() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-multi-field.json\");\n+        accept(idxr, \"foo where multi_field.raw == 'bar'\");\n+\n+        assertEquals(\"1:11: [multi_field.english == 'bar'] cannot operate on first argument field of data type [text]: \" +\n+                        \"No keyword/multi-field defined exact matches for [english]; define one or use MATCH/QUERY instead\",\n+                error(idxr, \"foo where multi_field.english == 'bar'\"));\n+\n+        accept(idxr, \"foo where multi_field_options.raw == 'bar'\");\n+        accept(idxr, \"foo where multi_field_options.key == 'bar'\");\n+\n+        accept(idxr, \"foo where multi_field_ambiguous.one == 'bar'\");\n+        accept(idxr, \"foo where multi_field_ambiguous.two == 'bar'\");\n+        assertEquals(\"1:11: [multi_field_ambiguous.normalized == 'bar'] cannot operate on first argument field of data type [keyword]: \" +\n+                        \"Normalized keyword field cannot be used for exact match operations\",\n+                error(idxr, \"foo where multi_field_ambiguous.normalized == 'bar'\"));\n+\n+        assertEquals(\"1:11: [multi_field_nested.dep_name == 'bar'] cannot operate on first argument field of data type [text]: \" +\n+                        \"No keyword/multi-field defined exact matches for [dep_name]; define one or use MATCH/QUERY instead\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "30b29463dd4ac494a99207b6557525316a537532"}, "originalPosition": 333}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzNDAzNDYz", "url": "https://github.com/elastic/elasticsearch/pull/52664#pullrequestreview-363403463", "createdAt": "2020-02-24T13:54:47Z", "commit": {"oid": "30b29463dd4ac494a99207b6557525316a537532"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "948f45835e36acde9d2807b556199fcc8315a6cf", "author": {"user": {"login": "aleksmaus", "name": "Aleksandr Maus"}}, "url": "https://github.com/elastic/elasticsearch/commit/948f45835e36acde9d2807b556199fcc8315a6cf", "committedDate": "2020-02-24T14:00:49Z", "message": "Address code review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzNDIyMjcy", "url": "https://github.com/elastic/elasticsearch/pull/52664#pullrequestreview-363422272", "createdAt": "2020-02-24T14:21:35Z", "commit": {"oid": "948f45835e36acde9d2807b556199fcc8315a6cf"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bce5c56090bf3075e1758622d71290a841d5ce50", "author": {"user": {"login": "aleksmaus", "name": "Aleksandr Maus"}}, "url": "https://github.com/elastic/elasticsearch/commit/bce5c56090bf3075e1758622d71290a841d5ce50", "committedDate": "2020-02-24T14:40:43Z", "message": "Add the test for bad query that starts with number"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c9e4c1f07c2bced0dee26653b8712a2b5e5199c4", "author": {"user": {"login": "aleksmaus", "name": "Aleksandr Maus"}}, "url": "https://github.com/elastic/elasticsearch/commit/c9e4c1f07c2bced0dee26653b8712a2b5e5199c4", "committedDate": "2020-02-24T15:05:16Z", "message": "Merge branch 'master' into feature/eql_verification_expanded"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2300, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}