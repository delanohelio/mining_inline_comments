{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ0ODM3Mzk2", "number": 59082, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxNToxNzo0N1rOELu0PA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxNToyMDoyOVrOELu4xA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwNzM2ODI4OnYy", "diffSide": "RIGHT", "path": "test/framework/src/main/java/org/elasticsearch/snapshots/AbstractSnapshotIntegTestCase.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxNToxNzo0N1rOGtbzmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwODo0MjowOVrOGt0xJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDI5NDY4MA==", "bodyText": "I like this a lot better than:\ndataNodeClient().admin().cluster().prepareState().get().getState();\n+ busy assert.\nOften times the tests use this kind of waiting when the busy assert will fail for a bit and then waste a second or two until the next run because of exponential back-off (over the large number of tests that do this kind of waiting for a certain CS it's well worth taking this approach IMO, especially with the concurrent snapshot ITs adding a large number of new tests that need this thing).\nAlso, the client() approach can (in disruption ITs) randomly go for the client of an isolated node and then waste effort and time for retrying in the transport master node action.", "url": "https://github.com/elastic/elasticsearch/pull/59082#discussion_r450294680", "createdAt": "2020-07-06T15:17:47Z", "author": {"login": "original-brownbear"}, "path": "test/framework/src/main/java/org/elasticsearch/snapshots/AbstractSnapshotIntegTestCase.java", "diffHunk": "@@ -366,4 +374,36 @@ protected long getCountForIndex(String indexName) {\n     protected void assertDocCount(String index, long count) {\n         assertEquals(getCountForIndex(index), count);\n     }\n+\n+    protected void awaitNoMoreRunningOperations(String viaNode) throws Exception {\n+        logger.info(\"--> verify no more operations in the cluster state\");\n+        awaitClusterState(viaNode, state -> state.custom(SnapshotsInProgress.TYPE, SnapshotsInProgress.EMPTY).entries().isEmpty() &&\n+                state.custom(SnapshotDeletionsInProgress.TYPE, SnapshotDeletionsInProgress.EMPTY).hasDeletionsInProgress() == false);\n+    }\n+\n+    private void awaitClusterState(String viaNode, Predicate<ClusterState> statePredicate) throws Exception {\n+        final ClusterService clusterService = internalCluster().getInstance(ClusterService.class, viaNode);\n+        final ThreadPool threadPool = internalCluster().getInstance(ThreadPool.class, viaNode);\n+        final ClusterStateObserver observer = new ClusterStateObserver(clusterService, logger, threadPool.getThreadContext());\n+        if (statePredicate.test(observer.setAndGetObservedState()) == false) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0c17c0f5e4f76c09289d461f9c4ed80cc4d2daec"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDY3NDk4Ng==", "bodyText": "I understand the motivation; I'm wondering if it should always wait for next change?", "url": "https://github.com/elastic/elasticsearch/pull/59082#discussion_r450674986", "createdAt": "2020-07-07T07:51:15Z", "author": {"login": "tlrx"}, "path": "test/framework/src/main/java/org/elasticsearch/snapshots/AbstractSnapshotIntegTestCase.java", "diffHunk": "@@ -366,4 +374,36 @@ protected long getCountForIndex(String indexName) {\n     protected void assertDocCount(String index, long count) {\n         assertEquals(getCountForIndex(index), count);\n     }\n+\n+    protected void awaitNoMoreRunningOperations(String viaNode) throws Exception {\n+        logger.info(\"--> verify no more operations in the cluster state\");\n+        awaitClusterState(viaNode, state -> state.custom(SnapshotsInProgress.TYPE, SnapshotsInProgress.EMPTY).entries().isEmpty() &&\n+                state.custom(SnapshotDeletionsInProgress.TYPE, SnapshotDeletionsInProgress.EMPTY).hasDeletionsInProgress() == false);\n+    }\n+\n+    private void awaitClusterState(String viaNode, Predicate<ClusterState> statePredicate) throws Exception {\n+        final ClusterService clusterService = internalCluster().getInstance(ClusterService.class, viaNode);\n+        final ThreadPool threadPool = internalCluster().getInstance(ThreadPool.class, viaNode);\n+        final ClusterStateObserver observer = new ClusterStateObserver(clusterService, logger, threadPool.getThreadContext());\n+        if (statePredicate.test(observer.setAndGetObservedState()) == false) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDI5NDY4MA=="}, "originalCommit": {"oid": "0c17c0f5e4f76c09289d461f9c4ed80cc4d2daec"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDY4NzAzMA==", "bodyText": "I think waiting for the next change would make it very hard to avoid races. We often have this pattern:\n\ndo operation\nwait for no more operations running\n\nIf the first step completes before we start waiting we dead-lock. And this is just one example, the concurrent snapshotting tests make use of this logic in other spots where similar races could occur", "url": "https://github.com/elastic/elasticsearch/pull/59082#discussion_r450687030", "createdAt": "2020-07-07T08:14:10Z", "author": {"login": "original-brownbear"}, "path": "test/framework/src/main/java/org/elasticsearch/snapshots/AbstractSnapshotIntegTestCase.java", "diffHunk": "@@ -366,4 +374,36 @@ protected long getCountForIndex(String indexName) {\n     protected void assertDocCount(String index, long count) {\n         assertEquals(getCountForIndex(index), count);\n     }\n+\n+    protected void awaitNoMoreRunningOperations(String viaNode) throws Exception {\n+        logger.info(\"--> verify no more operations in the cluster state\");\n+        awaitClusterState(viaNode, state -> state.custom(SnapshotsInProgress.TYPE, SnapshotsInProgress.EMPTY).entries().isEmpty() &&\n+                state.custom(SnapshotDeletionsInProgress.TYPE, SnapshotDeletionsInProgress.EMPTY).hasDeletionsInProgress() == false);\n+    }\n+\n+    private void awaitClusterState(String viaNode, Predicate<ClusterState> statePredicate) throws Exception {\n+        final ClusterService clusterService = internalCluster().getInstance(ClusterService.class, viaNode);\n+        final ThreadPool threadPool = internalCluster().getInstance(ThreadPool.class, viaNode);\n+        final ClusterStateObserver observer = new ClusterStateObserver(clusterService, logger, threadPool.getThreadContext());\n+        if (statePredicate.test(observer.setAndGetObservedState()) == false) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDI5NDY4MA=="}, "originalCommit": {"oid": "0c17c0f5e4f76c09289d461f9c4ed80cc4d2daec"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDY5OTMzNA==", "bodyText": "Ok. I was wondering if something similar could happen: 1. do operation and 2. check cluster state on a data node that has not yet processed the updated cluster state", "url": "https://github.com/elastic/elasticsearch/pull/59082#discussion_r450699334", "createdAt": "2020-07-07T08:35:13Z", "author": {"login": "tlrx"}, "path": "test/framework/src/main/java/org/elasticsearch/snapshots/AbstractSnapshotIntegTestCase.java", "diffHunk": "@@ -366,4 +374,36 @@ protected long getCountForIndex(String indexName) {\n     protected void assertDocCount(String index, long count) {\n         assertEquals(getCountForIndex(index), count);\n     }\n+\n+    protected void awaitNoMoreRunningOperations(String viaNode) throws Exception {\n+        logger.info(\"--> verify no more operations in the cluster state\");\n+        awaitClusterState(viaNode, state -> state.custom(SnapshotsInProgress.TYPE, SnapshotsInProgress.EMPTY).entries().isEmpty() &&\n+                state.custom(SnapshotDeletionsInProgress.TYPE, SnapshotDeletionsInProgress.EMPTY).hasDeletionsInProgress() == false);\n+    }\n+\n+    private void awaitClusterState(String viaNode, Predicate<ClusterState> statePredicate) throws Exception {\n+        final ClusterService clusterService = internalCluster().getInstance(ClusterService.class, viaNode);\n+        final ThreadPool threadPool = internalCluster().getInstance(ThreadPool.class, viaNode);\n+        final ClusterStateObserver observer = new ClusterStateObserver(clusterService, logger, threadPool.getThreadContext());\n+        if (statePredicate.test(observer.setAndGetObservedState()) == false) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDI5NDY4MA=="}, "originalCommit": {"oid": "0c17c0f5e4f76c09289d461f9c4ed80cc4d2daec"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDcwMTYzMA==", "bodyText": "\ud83d\udc4d yea that was an issue in the concurrency tests, in the end it just requires ensuring that stuff actually started by some other means before waiting for it to go away :)", "url": "https://github.com/elastic/elasticsearch/pull/59082#discussion_r450701630", "createdAt": "2020-07-07T08:38:58Z", "author": {"login": "original-brownbear"}, "path": "test/framework/src/main/java/org/elasticsearch/snapshots/AbstractSnapshotIntegTestCase.java", "diffHunk": "@@ -366,4 +374,36 @@ protected long getCountForIndex(String indexName) {\n     protected void assertDocCount(String index, long count) {\n         assertEquals(getCountForIndex(index), count);\n     }\n+\n+    protected void awaitNoMoreRunningOperations(String viaNode) throws Exception {\n+        logger.info(\"--> verify no more operations in the cluster state\");\n+        awaitClusterState(viaNode, state -> state.custom(SnapshotsInProgress.TYPE, SnapshotsInProgress.EMPTY).entries().isEmpty() &&\n+                state.custom(SnapshotDeletionsInProgress.TYPE, SnapshotDeletionsInProgress.EMPTY).hasDeletionsInProgress() == false);\n+    }\n+\n+    private void awaitClusterState(String viaNode, Predicate<ClusterState> statePredicate) throws Exception {\n+        final ClusterService clusterService = internalCluster().getInstance(ClusterService.class, viaNode);\n+        final ThreadPool threadPool = internalCluster().getInstance(ThreadPool.class, viaNode);\n+        final ClusterStateObserver observer = new ClusterStateObserver(clusterService, logger, threadPool.getThreadContext());\n+        if (statePredicate.test(observer.setAndGetObservedState()) == false) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDI5NDY4MA=="}, "originalCommit": {"oid": "0c17c0f5e4f76c09289d461f9c4ed80cc4d2daec"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDcwMzY1Mw==", "bodyText": "Good! Thanks", "url": "https://github.com/elastic/elasticsearch/pull/59082#discussion_r450703653", "createdAt": "2020-07-07T08:42:09Z", "author": {"login": "tlrx"}, "path": "test/framework/src/main/java/org/elasticsearch/snapshots/AbstractSnapshotIntegTestCase.java", "diffHunk": "@@ -366,4 +374,36 @@ protected long getCountForIndex(String indexName) {\n     protected void assertDocCount(String index, long count) {\n         assertEquals(getCountForIndex(index), count);\n     }\n+\n+    protected void awaitNoMoreRunningOperations(String viaNode) throws Exception {\n+        logger.info(\"--> verify no more operations in the cluster state\");\n+        awaitClusterState(viaNode, state -> state.custom(SnapshotsInProgress.TYPE, SnapshotsInProgress.EMPTY).entries().isEmpty() &&\n+                state.custom(SnapshotDeletionsInProgress.TYPE, SnapshotDeletionsInProgress.EMPTY).hasDeletionsInProgress() == false);\n+    }\n+\n+    private void awaitClusterState(String viaNode, Predicate<ClusterState> statePredicate) throws Exception {\n+        final ClusterService clusterService = internalCluster().getInstance(ClusterService.class, viaNode);\n+        final ThreadPool threadPool = internalCluster().getInstance(ThreadPool.class, viaNode);\n+        final ClusterStateObserver observer = new ClusterStateObserver(clusterService, logger, threadPool.getThreadContext());\n+        if (statePredicate.test(observer.setAndGetObservedState()) == false) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDI5NDY4MA=="}, "originalCommit": {"oid": "0c17c0f5e4f76c09289d461f9c4ed80cc4d2daec"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwNzM3Mzc4OnYy", "diffSide": "LEFT", "path": "x-pack/plugin/ilm/src/test/java/org/elasticsearch/xpack/slm/SLMSnapshotBlockingIntegTests.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxNToxOTowN1rOGtb3Eg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxNToxOTowN1rOGtb3Eg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDI5NTU3MA==", "bodyText": "All of these methods were just copies from AbstractSnapshotIntegTestCase that's why no other changes to the code were needed here.", "url": "https://github.com/elastic/elasticsearch/pull/59082#discussion_r450295570", "createdAt": "2020-07-06T15:19:07Z", "author": {"login": "original-brownbear"}, "path": "x-pack/plugin/ilm/src/test/java/org/elasticsearch/xpack/slm/SLMSnapshotBlockingIntegTests.java", "diffHunk": "@@ -522,49 +487,4 @@ private String executePolicy(String policyId) {\n             return \"bad\";\n         }\n     }\n-\n-    public static String blockMasterFromFinalizingSnapshotOnIndexFile(final String repositoryName) {\n-        final String masterName = internalCluster().getMasterName();\n-        ((MockRepository)internalCluster().getInstance(RepositoriesService.class, masterName)\n-            .repository(repositoryName)).setBlockOnWriteIndexFile(true);\n-        return masterName;\n-    }\n-\n-    public static String unblockRepo(final String repositoryName) {\n-        final String masterName = internalCluster().getMasterName();\n-        ((MockRepository)internalCluster().getInstance(RepositoriesService.class, masterName)\n-            .repository(repositoryName)).unblock();\n-        return masterName;\n-    }\n-\n-    public static void blockAllDataNodes(String repository) {\n-        for(RepositoriesService repositoriesService : internalCluster().getDataNodeInstances(RepositoriesService.class)) {\n-            ((MockRepository)repositoriesService.repository(repository)).blockOnDataFiles(true);\n-        }\n-    }\n-\n-    public static void unblockAllDataNodes(String repository) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0c17c0f5e4f76c09289d461f9c4ed80cc4d2daec"}, "originalPosition": 202}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwNzM3OTg4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ilm/src/test/java/org/elasticsearch/xpack/slm/SLMSnapshotBlockingIntegTests.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxNToyMDoyOVrOGtb6xQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxNToyMDoyOVrOGtb6xQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDI5NjUxNw==", "bodyText": "Needed to add a new wait here because the AbstractSnapshotIntegTestCase does some repo consistency checks in after the tests (well worth it to have these here anyway) which will break if there's still work done in the cluster (which may be the case in this test).", "url": "https://github.com/elastic/elasticsearch/pull/59082#discussion_r450296517", "createdAt": "2020-07-06T15:20:29Z", "author": {"login": "original-brownbear"}, "path": "x-pack/plugin/ilm/src/test/java/org/elasticsearch/xpack/slm/SLMSnapshotBlockingIntegTests.java", "diffHunk": "@@ -381,18 +368,14 @@ private void testUnsuccessfulSnapshotRetention(boolean partialSuccess) throws Ex\n                 assertEquals(SnapshotState.SUCCESS, snapshotInfo.state());\n             });\n         }\n+        awaitNoMoreRunningOperations(internalCluster().getMasterName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0c17c0f5e4f76c09289d461f9c4ed80cc4d2daec"}, "originalPosition": 129}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2062, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}