{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkxODYwNjc5", "number": 53917, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMVQxMzo0Nzo1MVrODqFYVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMVQxMzo1MjoxMlrODqFZGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1NDU0OTMzOnYy", "diffSide": "LEFT", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/BaseSearchableSnapshotDirectory.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMVQxMzo0Nzo1MVrOF5pkGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMVQxMzo0Nzo1MVrOF5pkGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTk5NDEzOA==", "bodyText": "This class has been merged down with SearchableSnapshotDirectory (it was useful to me for the 2 previous PRs)", "url": "https://github.com/elastic/elasticsearch/pull/53917#discussion_r395994138", "createdAt": "2020-03-21T13:47:51Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/BaseSearchableSnapshotDirectory.java", "diffHunk": "@@ -1,109 +0,0 @@\n-/*\n- * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n- * or more contributor license agreements. Licensed under the Elastic License;\n- * you may not use this file except in compliance with the Elastic License.\n- */\n-package org.elasticsearch.index.store;\n-\n-import org.apache.lucene.store.BaseDirectory;\n-import org.apache.lucene.store.IOContext;\n-import org.apache.lucene.store.IndexOutput;\n-import org.apache.lucene.store.SingleInstanceLockFactory;\n-import org.elasticsearch.common.blobstore.BlobContainer;\n-import org.elasticsearch.index.snapshots.blobstore.BlobStoreIndexShardSnapshot;\n-import org.elasticsearch.index.snapshots.blobstore.BlobStoreIndexShardSnapshot.FileInfo;\n-\n-import java.io.FileNotFoundException;\n-import java.io.IOException;\n-import java.util.Collection;\n-import java.util.Objects;\n-import java.util.Set;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-\n-public abstract class BaseSearchableSnapshotDirectory extends BaseDirectory {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87658bb1fb817f40f767b2b9716b20b33dff1958"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1NDU0OTkxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/SearchableSnapshotDirectory.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMVQxMzo0OTowMVrOF5pkZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMVQxMzo0OTowMVrOF5pkZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTk5NDIxMg==", "bodyText": "Comes from the now removed CacheDirectory and made public as cache classes are in a different package", "url": "https://github.com/elastic/elasticsearch/pull/53917#discussion_r395994212", "createdAt": "2020-03-21T13:49:01Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/SearchableSnapshotDirectory.java", "diffHunk": "@@ -42,17 +60,175 @@\n  * shard files and what it stored in the snapshot the {@link BlobStoreIndexShardSnapshot} is used to map a physical file name as expected by\n  * Lucene with the one (or the ones) corresponding blob(s) in the snapshot.\n  */\n-public class SearchableSnapshotDirectory extends BaseSearchableSnapshotDirectory {\n+public class SearchableSnapshotDirectory extends BaseDirectory {\n \n-    SearchableSnapshotDirectory(final BlobStoreIndexShardSnapshot snapshot, final BlobContainer blobContainer) {\n-        super(blobContainer, snapshot);\n+    private final BlobStoreIndexShardSnapshot snapshot;\n+    private final BlobContainer blobContainer;\n+    private final SnapshotId snapshotId;\n+    private final IndexId indexId;\n+    private final ShardId shardId;\n+    private final LongSupplier statsCurrentTimeNanosSupplier;\n+    private final Map<String, IndexInputStats> stats;\n+    private final CacheService cacheService;\n+    private final boolean useCache;\n+    private final Path cacheDir;\n+    private final AtomicBoolean closed;\n+\n+    public SearchableSnapshotDirectory(\n+        BlobContainer blobContainer,\n+        BlobStoreIndexShardSnapshot snapshot,\n+        SnapshotId snapshotId,\n+        IndexId indexId,\n+        ShardId shardId,\n+        Settings indexSettings,\n+        LongSupplier currentTimeNanosSupplier,\n+        CacheService cacheService,\n+        Path cacheDir\n+    ) {\n+        super(new SingleInstanceLockFactory());\n+        this.snapshot = Objects.requireNonNull(snapshot);\n+        this.blobContainer = Objects.requireNonNull(blobContainer);\n+        this.snapshotId = Objects.requireNonNull(snapshotId);\n+        this.indexId = Objects.requireNonNull(indexId);\n+        this.shardId = Objects.requireNonNull(shardId);\n+        this.stats = ConcurrentCollections.newConcurrentMapWithAggressiveConcurrency();\n+        this.statsCurrentTimeNanosSupplier = Objects.requireNonNull(currentTimeNanosSupplier);\n+        this.cacheService = Objects.requireNonNull(cacheService);\n+        this.cacheDir = Objects.requireNonNull(cacheDir);\n+        this.closed = new AtomicBoolean(false);\n+        this.useCache = SNAPSHOT_CACHE_ENABLED_SETTING.get(indexSettings);\n+    }\n+\n+    public BlobContainer blobContainer() {\n+        return blobContainer;\n+    }\n+\n+    public SnapshotId getSnapshotId() {\n+        return snapshotId;\n+    }\n+\n+    public IndexId getIndexId() {\n+        return indexId;\n+    }\n+\n+    public ShardId getShardId() {\n+        return shardId;\n+    }\n+\n+    public Map<String, IndexInputStats> getStats() {\n+        return Collections.unmodifiableMap(stats);\n+    }\n+\n+    @Nullable\n+    public IndexInputStats getStats(String fileName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87658bb1fb817f40f767b2b9716b20b33dff1958"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1NDU1MDIzOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/SearchableSnapshotDirectory.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMVQxMzo0OTo1MlrOF5pkjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMVQxMzo0OTo1MlrOF5pkjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTk5NDI1NA==", "bodyText": "I'd like to rename this one to DirectBufferedIndexInput and to clean it up a bit in a follow up PR", "url": "https://github.com/elastic/elasticsearch/pull/53917#discussion_r395994254", "createdAt": "2020-03-21T13:49:52Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/SearchableSnapshotDirectory.java", "diffHunk": "@@ -42,17 +60,175 @@\n  * shard files and what it stored in the snapshot the {@link BlobStoreIndexShardSnapshot} is used to map a physical file name as expected by\n  * Lucene with the one (or the ones) corresponding blob(s) in the snapshot.\n  */\n-public class SearchableSnapshotDirectory extends BaseSearchableSnapshotDirectory {\n+public class SearchableSnapshotDirectory extends BaseDirectory {\n \n-    SearchableSnapshotDirectory(final BlobStoreIndexShardSnapshot snapshot, final BlobContainer blobContainer) {\n-        super(blobContainer, snapshot);\n+    private final BlobStoreIndexShardSnapshot snapshot;\n+    private final BlobContainer blobContainer;\n+    private final SnapshotId snapshotId;\n+    private final IndexId indexId;\n+    private final ShardId shardId;\n+    private final LongSupplier statsCurrentTimeNanosSupplier;\n+    private final Map<String, IndexInputStats> stats;\n+    private final CacheService cacheService;\n+    private final boolean useCache;\n+    private final Path cacheDir;\n+    private final AtomicBoolean closed;\n+\n+    public SearchableSnapshotDirectory(\n+        BlobContainer blobContainer,\n+        BlobStoreIndexShardSnapshot snapshot,\n+        SnapshotId snapshotId,\n+        IndexId indexId,\n+        ShardId shardId,\n+        Settings indexSettings,\n+        LongSupplier currentTimeNanosSupplier,\n+        CacheService cacheService,\n+        Path cacheDir\n+    ) {\n+        super(new SingleInstanceLockFactory());\n+        this.snapshot = Objects.requireNonNull(snapshot);\n+        this.blobContainer = Objects.requireNonNull(blobContainer);\n+        this.snapshotId = Objects.requireNonNull(snapshotId);\n+        this.indexId = Objects.requireNonNull(indexId);\n+        this.shardId = Objects.requireNonNull(shardId);\n+        this.stats = ConcurrentCollections.newConcurrentMapWithAggressiveConcurrency();\n+        this.statsCurrentTimeNanosSupplier = Objects.requireNonNull(currentTimeNanosSupplier);\n+        this.cacheService = Objects.requireNonNull(cacheService);\n+        this.cacheDir = Objects.requireNonNull(cacheDir);\n+        this.closed = new AtomicBoolean(false);\n+        this.useCache = SNAPSHOT_CACHE_ENABLED_SETTING.get(indexSettings);\n+    }\n+\n+    public BlobContainer blobContainer() {\n+        return blobContainer;\n+    }\n+\n+    public SnapshotId getSnapshotId() {\n+        return snapshotId;\n+    }\n+\n+    public IndexId getIndexId() {\n+        return indexId;\n+    }\n+\n+    public ShardId getShardId() {\n+        return shardId;\n+    }\n+\n+    public Map<String, IndexInputStats> getStats() {\n+        return Collections.unmodifiableMap(stats);\n+    }\n+\n+    @Nullable\n+    public IndexInputStats getStats(String fileName) {\n+        return stats.get(fileName);\n+    }\n+\n+    public long statsCurrentTimeNanos() {\n+        return statsCurrentTimeNanosSupplier.getAsLong();\n+    }\n+\n+    private BlobStoreIndexShardSnapshot.FileInfo fileInfo(final String name) throws FileNotFoundException {\n+        return snapshot.indexFiles()\n+            .stream()\n+            .filter(fileInfo -> fileInfo.physicalName().equals(name))\n+            .findFirst()\n+            .orElseThrow(() -> new FileNotFoundException(name));\n+    }\n+\n+    @Override\n+    public final String[] listAll() {\n+        ensureOpen();\n+        return snapshot.indexFiles()\n+            .stream()\n+            .map(BlobStoreIndexShardSnapshot.FileInfo::physicalName)\n+            .sorted(String::compareTo)\n+            .toArray(String[]::new);\n+    }\n+\n+    @Override\n+    public final long fileLength(final String name) throws IOException {\n+        ensureOpen();\n+        return fileInfo(name).length();\n+    }\n+\n+    @Override\n+    public Set<String> getPendingDeletions() {\n+        throw unsupportedException();\n+    }\n+\n+    @Override\n+    public void sync(Collection<String> names) {\n+        throw unsupportedException();\n+    }\n+\n+    @Override\n+    public void syncMetaData() {\n+        throw unsupportedException();\n+    }\n+\n+    @Override\n+    public void deleteFile(String name) {\n+        throw unsupportedException();\n+    }\n+\n+    @Override\n+    public IndexOutput createOutput(String name, IOContext context) {\n+        throw unsupportedException();\n+    }\n+\n+    @Override\n+    public IndexOutput createTempOutput(String prefix, String suffix, IOContext context) {\n+        throw unsupportedException();\n+    }\n+\n+    @Override\n+    public void rename(String source, String dest) {\n+        throw unsupportedException();\n+    }\n+\n+    private static UnsupportedOperationException unsupportedException() {\n+        assert false : \"this operation is not supported and should have not be called\";\n+        return new UnsupportedOperationException(\"Searchable snapshot directory does not support this operation\");\n+    }\n+\n+    @Override\n+    public final void close() {\n+        if (closed.compareAndSet(false, true)) {\n+            isOpen = false;\n+            // Ideally we could let the cache evict/remove cached files by itself after the\n+            // directory has been closed.\n+            clearCache();\n+        }\n+    }\n+\n+    public void clearCache() {\n+        cacheService.removeFromCache(cacheKey -> cacheKey.belongsTo(snapshotId, indexId, shardId));\n+    }\n+\n+    protected IndexInputStats createIndexInputStats(final long fileLength) {\n+        return new IndexInputStats(fileLength);\n+    }\n+\n+    public CacheKey createCacheKey(String fileName) {\n+        return new CacheKey(snapshotId, indexId, shardId, fileName);\n+    }\n+\n+    public CacheFile getCacheFile(CacheKey cacheKey, long fileLength) throws Exception {\n+        return cacheService.get(cacheKey, fileLength, cacheDir);\n     }\n \n     @Override\n     public IndexInput openInput(final String name, final IOContext context) throws IOException {\n         ensureOpen();\n-        return new SearchableSnapshotIndexInput(blobContainer, fileInfo(name), context, blobContainer.readBlobPreferredLength(),\n-            BufferedIndexInput.BUFFER_SIZE);\n+        final BlobStoreIndexShardSnapshot.FileInfo fileInfo = fileInfo(name);\n+        final IndexInputStats inputStats = stats.computeIfAbsent(name, n -> createIndexInputStats(fileInfo.length()));\n+        if (useCache) {\n+            return new CacheBufferedIndexInput(this, fileInfo, context, inputStats);\n+        } else {\n+            long preferredLength = blobContainer.readBlobPreferredLength();\n+            return new SearchableSnapshotIndexInput(blobContainer, fileInfo, context, preferredLength, BufferedIndexInput.BUFFER_SIZE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87658bb1fb817f40f767b2b9716b20b33dff1958"}, "originalPosition": 220}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1NDU1MDc5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/cache/CacheBufferedIndexInput.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMVQxMzo1MDo0N1rOF5pk2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMVQxMzo1MDo0N1rOF5pk2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTk5NDMyOQ==", "bodyText": "Has to be public now it's instantiated by SearchableSnapshotDirectory from a different package.", "url": "https://github.com/elastic/elasticsearch/pull/53917#discussion_r395994329", "createdAt": "2020-03-21T13:50:47Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/cache/CacheBufferedIndexInput.java", "diffHunk": "@@ -47,13 +48,13 @@\n     // last seek position is kept around in order to detect forward/backward seeks for stats\n     private long lastSeekPosition;\n \n-    CacheBufferedIndexInput(CacheDirectory directory, FileInfo fileInfo, IOContext context, IndexInputStats stats) {\n+    public CacheBufferedIndexInput(SearchableSnapshotDirectory directory, FileInfo fileInfo, IOContext context, IndexInputStats stats) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87658bb1fb817f40f767b2b9716b20b33dff1958"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1NDU1MDg4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/cache/CacheFile.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMVQxMzo1MTowMVrOF5pk5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMVQxMzo1MTowMVrOF5pk5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTk5NDM0MQ==", "bodyText": "Same here.", "url": "https://github.com/elastic/elasticsearch/pull/53917#discussion_r395994341", "createdAt": "2020-03-21T13:51:01Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/cache/CacheFile.java", "diffHunk": "@@ -27,7 +27,7 @@\n import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.locks.ReentrantReadWriteLock;\n \n-class CacheFile {\n+public class CacheFile {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87658bb1fb817f40f767b2b9716b20b33dff1958"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1NDU1MDkyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/cache/CacheKey.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMVQxMzo1MToxMFrOF5pk6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMVQxMzo1MToxMFrOF5pk6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTk5NDM0NQ==", "bodyText": "And same here.", "url": "https://github.com/elastic/elasticsearch/pull/53917#discussion_r395994345", "createdAt": "2020-03-21T13:51:10Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/cache/CacheKey.java", "diffHunk": "@@ -18,7 +18,7 @@\n     private final ShardId shardId;\n     private final String fileName;\n \n-    CacheKey(SnapshotId snapshotId, IndexId indexId, ShardId shardId, String fileName) {\n+    public CacheKey(SnapshotId snapshotId, IndexId indexId, ShardId shardId, String fileName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87658bb1fb817f40f767b2b9716b20b33dff1958"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1NDU1MTMxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/index/store/SearchableSnapshotDirectoryTests.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMVQxMzo1MjoxMlrOF5plKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMVQxMzo1MjoxMlrOF5plKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTk5NDQwOQ==", "bodyText": "This test comes from the now removed CacheDirectoryTests class with very few adjustments for the SearchableSnapshotDirectory instantiation.", "url": "https://github.com/elastic/elasticsearch/pull/53917#discussion_r395994409", "createdAt": "2020-03-21T13:52:12Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/index/store/SearchableSnapshotDirectoryTests.java", "diffHunk": "@@ -380,10 +405,86 @@ private void testIndexInputs(final CheckedBiConsumer<IndexInput, IndexInput, Exc\n         });\n     }\n \n+    public void testClearCache() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87658bb1fb817f40f767b2b9716b20b33dff1958"}, "originalPosition": 75}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4189, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}