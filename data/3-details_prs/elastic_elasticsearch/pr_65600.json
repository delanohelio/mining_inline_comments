{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI5NTQwMzQ4", "number": 65600, "title": "Add xpack info and usage endpoints for runtime fields", "bodyText": "Relates to #59332", "createdAt": "2020-11-30T13:11:40Z", "url": "https://github.com/elastic/elasticsearch/pull/65600", "merged": true, "mergeCommit": {"oid": "20d6fbcd551cc9b9cf1dbb45fac062b101dfa4a8"}, "closed": true, "closedAt": "2020-12-08T09:15:09Z", "author": {"login": "javanna"}, "timelineItems": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdgE5ojgH2gAyNTI5NTQwMzQ4OjBlMDI1NDJhOWZmYmZiMDYwZTQwMDBjOGY5NjYwZWYwOWFhYjc2NWU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdkFVJeAH2gAyNTI5NTQwMzQ4OmM5NzZhNDZkNjg3ODI2YzliMDM2NjFlYzEwMjRmNTY3NjljNGE3ZTE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "0e02542a9ffbfb060e4000c8f9660ef09aab765e", "author": {"user": {"login": "javanna", "name": "Luca Cavanna"}}, "url": "https://github.com/elastic/elasticsearch/commit/0e02542a9ffbfb060e4000c8f9660ef09aab765e", "committedDate": "2020-11-25T21:05:23Z", "message": "Add xpack info and usage endpoints for runtime fields"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4bfe5105a25f5c1df40bb49532403fe9c7bf7b28", "author": {"user": {"login": "javanna", "name": "Luca Cavanna"}}, "url": "https://github.com/elastic/elasticsearch/commit/4bfe5105a25f5c1df40bb49532403fe9c7bf7b28", "committedDate": "2020-11-30T12:59:57Z", "message": "wip"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "782a558385199f337a0f76b3d9ef1f49bf257520", "author": {"user": {"login": "javanna", "name": "Luca Cavanna"}}, "url": "https://github.com/elastic/elasticsearch/commit/782a558385199f337a0f76b3d9ef1f49bf257520", "committedDate": "2020-11-30T13:00:20Z", "message": "Merge branch 'master' into enhancement/runtime_fields_telemetry"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5773c0bd0c921c22136d04e55942ff751215f050", "author": {"user": {"login": "javanna", "name": "Luca Cavanna"}}, "url": "https://github.com/elastic/elasticsearch/commit/5773c0bd0c921c22136d04e55942ff751215f050", "committedDate": "2020-11-30T13:09:06Z", "message": "iter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "82979ec030e88234eaac340b22937dcbb2ba44fe", "author": {"user": {"login": "javanna", "name": "Luca Cavanna"}}, "url": "https://github.com/elastic/elasticsearch/commit/82979ec030e88234eaac340b22937dcbb2ba44fe", "committedDate": "2020-11-30T13:18:24Z", "message": "spotless"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQwOTA0ODM1", "url": "https://github.com/elastic/elasticsearch/pull/65600#pullrequestreview-540904835", "createdAt": "2020-11-30T13:26:27Z", "commit": {"oid": "82979ec030e88234eaac340b22937dcbb2ba44fe"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxMzoyNjoyN1rOH76_SA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxMzoyNjoyN1rOH76_SA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjU5NDUwNA==", "bodyText": "We have MappingVisitor which already implements some of this, although it looks in properties rather than runtime - might be worth extending or re-using some of that?", "url": "https://github.com/elastic/elasticsearch/pull/65600#discussion_r532594504", "createdAt": "2020-11-30T13:26:27Z", "author": {"login": "romseygeek"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/runtimefields/RuntimeFieldsFeatureSetUsage.java", "diffHunk": "@@ -0,0 +1,272 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.runtimefields;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.metadata.MappingMetadata;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.xpack.core.XPackFeatureSet;\n+import org.elasticsearch.xpack.core.XPackField;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class RuntimeFieldsFeatureSetUsage extends XPackFeatureSet.Usage {\n+\n+    public static RuntimeFieldsFeatureSetUsage fromMetadata(Iterable<IndexMetadata> metadata) {\n+        Map<String, RuntimeFieldStats> fieldTypes = new HashMap<>();\n+        for (IndexMetadata indexMetadata : metadata) {\n+            if (indexMetadata.isSystem()) {\n+                // Don't include system indices in statistics about mappings, we care about the user's indices.\n+                continue;\n+            }\n+            Set<String> indexFieldTypes = new HashSet<>();\n+            MappingMetadata mappingMetadata = indexMetadata.mapping();\n+            if (mappingMetadata != null) {\n+                Object runtimeObject = mappingMetadata.getSourceAsMap().get(\"runtime\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82979ec030e88234eaac340b22937dcbb2ba44fe"}, "originalPosition": 43}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "295826641939488e46074883d37582afb542e055", "author": {"user": {"login": "javanna", "name": "Luca Cavanna"}}, "url": "https://github.com/elastic/elasticsearch/commit/295826641939488e46074883d37582afb542e055", "committedDate": "2020-11-30T13:36:38Z", "message": "docs failures"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxMTY3MjA4", "url": "https://github.com/elastic/elasticsearch/pull/65600#pullrequestreview-541167208", "createdAt": "2020-11-30T18:10:59Z", "commit": {"oid": "295826641939488e46074883d37582afb542e055"}, "state": "APPROVED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxODoxMTowMFrOH8HdzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxODoxNzoyNVrOH8Hs7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc5ODkyNQ==", "bodyText": "\ud83d\udc4d\nWhile you are here could you make them one per line and alphabetical order? I know it is a pain but it'll push everyone who comes after you to be neat and tidy.", "url": "https://github.com/elastic/elasticsearch/pull/65600#discussion_r532798925", "createdAt": "2020-11-30T18:11:00Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/action/XPackUsageFeatureAction.java", "diffHunk": "@@ -47,17 +44,13 @@\n     public static final XPackUsageFeatureAction DATA_STREAMS = new XPackUsageFeatureAction(XPackField.DATA_STREAMS);\n     public static final XPackUsageFeatureAction DATA_TIERS = new XPackUsageFeatureAction(XPackField.DATA_TIERS);\n     public static final XPackUsageFeatureAction AGGREGATE_METRIC = new XPackUsageFeatureAction(XPackField.AGGREGATE_METRIC);\n+    public static final XPackUsageFeatureAction RUNTIME_FIELDS = new XPackUsageFeatureAction(XPackField.RUNTIME_FIELDS);\n \n-    public static final List<XPackUsageFeatureAction> ALL;\n-    static {\n-        final List<XPackUsageFeatureAction> actions = new ArrayList<>();\n-        actions.addAll(Arrays.asList(\n-            SECURITY, MONITORING, WATCHER, GRAPH, MACHINE_LEARNING, LOGSTASH, EQL, SQL, ROLLUP, INDEX_LIFECYCLE, SNAPSHOT_LIFECYCLE, CCR,\n-            TRANSFORM, VECTORS, VOTING_ONLY, FROZEN_INDICES, SPATIAL, ANALYTICS, DATA_STREAMS, SEARCHABLE_SNAPSHOTS, DATA_TIERS,\n-            AGGREGATE_METRIC\n-        ));\n-        ALL = Collections.unmodifiableList(actions);\n-    }\n+    static final List<XPackUsageFeatureAction> ALL = List.of(\n+        SECURITY, MONITORING, WATCHER, GRAPH, MACHINE_LEARNING, LOGSTASH, EQL, SQL, ROLLUP, INDEX_LIFECYCLE, SNAPSHOT_LIFECYCLE, CCR,\n+        TRANSFORM, VECTORS, VOTING_ONLY, FROZEN_INDICES, SPATIAL, ANALYTICS, DATA_STREAMS, SEARCHABLE_SNAPSHOTS, DATA_TIERS,\n+        AGGREGATE_METRIC, RUNTIME_FIELDS", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "295826641939488e46074883d37582afb542e055"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc5OTU1OA==", "bodyText": "I figure if we see the need later we'll add a visitor but that this works fine for now.", "url": "https://github.com/elastic/elasticsearch/pull/65600#discussion_r532799558", "createdAt": "2020-11-30T18:12:01Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/runtimefields/RuntimeFieldsFeatureSetUsage.java", "diffHunk": "@@ -0,0 +1,272 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.runtimefields;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.metadata.MappingMetadata;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.xpack.core.XPackFeatureSet;\n+import org.elasticsearch.xpack.core.XPackField;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class RuntimeFieldsFeatureSetUsage extends XPackFeatureSet.Usage {\n+\n+    public static RuntimeFieldsFeatureSetUsage fromMetadata(Iterable<IndexMetadata> metadata) {\n+        Map<String, RuntimeFieldStats> fieldTypes = new HashMap<>();\n+        for (IndexMetadata indexMetadata : metadata) {\n+            if (indexMetadata.isSystem()) {\n+                // Don't include system indices in statistics about mappings, we care about the user's indices.\n+                continue;\n+            }\n+            Set<String> indexFieldTypes = new HashSet<>();\n+            MappingMetadata mappingMetadata = indexMetadata.mapping();\n+            if (mappingMetadata != null) {\n+                Object runtimeObject = mappingMetadata.getSourceAsMap().get(\"runtime\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjU5NDUwNA=="}, "originalCommit": {"oid": "82979ec030e88234eaac340b22937dcbb2ba44fe"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgwMDEwNQ==", "bodyText": "If you cast to Map<?, ?> you don't need to suppress and .values will still return Object. You can't .put on the map but you don't need to.", "url": "https://github.com/elastic/elasticsearch/pull/65600#discussion_r532800105", "createdAt": "2020-11-30T18:12:55Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/runtimefields/RuntimeFieldsFeatureSetUsage.java", "diffHunk": "@@ -0,0 +1,272 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.runtimefields;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.metadata.MappingMetadata;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.xpack.core.XPackFeatureSet;\n+import org.elasticsearch.xpack.core.XPackField;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class RuntimeFieldsFeatureSetUsage extends XPackFeatureSet.Usage {\n+\n+    public static RuntimeFieldsFeatureSetUsage fromMetadata(Iterable<IndexMetadata> metadata) {\n+        Map<String, RuntimeFieldStats> fieldTypes = new HashMap<>();\n+        for (IndexMetadata indexMetadata : metadata) {\n+            if (indexMetadata.isSystem()) {\n+                // Don't include system indices in statistics about mappings, we care about the user's indices.\n+                continue;\n+            }\n+            Set<String> indexFieldTypes = new HashSet<>();\n+            MappingMetadata mappingMetadata = indexMetadata.mapping();\n+            if (mappingMetadata != null) {\n+                Object runtimeObject = mappingMetadata.getSourceAsMap().get(\"runtime\");\n+                if (runtimeObject instanceof Map) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    Map<String, Object> runtimeMappings = (Map<String, Object>) runtimeObject;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "295826641939488e46074883d37582afb542e055"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgwMDE2Nw==", "bodyText": "Just a sneaky way to save a line.", "url": "https://github.com/elastic/elasticsearch/pull/65600#discussion_r532800167", "createdAt": "2020-11-30T18:13:02Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/runtimefields/RuntimeFieldsFeatureSetUsage.java", "diffHunk": "@@ -0,0 +1,272 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.runtimefields;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.metadata.MappingMetadata;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.xpack.core.XPackFeatureSet;\n+import org.elasticsearch.xpack.core.XPackField;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class RuntimeFieldsFeatureSetUsage extends XPackFeatureSet.Usage {\n+\n+    public static RuntimeFieldsFeatureSetUsage fromMetadata(Iterable<IndexMetadata> metadata) {\n+        Map<String, RuntimeFieldStats> fieldTypes = new HashMap<>();\n+        for (IndexMetadata indexMetadata : metadata) {\n+            if (indexMetadata.isSystem()) {\n+                // Don't include system indices in statistics about mappings, we care about the user's indices.\n+                continue;\n+            }\n+            Set<String> indexFieldTypes = new HashSet<>();\n+            MappingMetadata mappingMetadata = indexMetadata.mapping();\n+            if (mappingMetadata != null) {\n+                Object runtimeObject = mappingMetadata.getSourceAsMap().get(\"runtime\");\n+                if (runtimeObject instanceof Map) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    Map<String, Object> runtimeMappings = (Map<String, Object>) runtimeObject;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgwMDEwNQ=="}, "originalCommit": {"oid": "295826641939488e46074883d37582afb542e055"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgwMTA3Ng==", "bodyText": "Is there any chance you could flip this so it continues if mappingMetadata is null. I find quick continues to be easier to short cut in my head when reading. With these indenting ifs I have to scroll down and check if there is an else.", "url": "https://github.com/elastic/elasticsearch/pull/65600#discussion_r532801076", "createdAt": "2020-11-30T18:14:35Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/runtimefields/RuntimeFieldsFeatureSetUsage.java", "diffHunk": "@@ -0,0 +1,272 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.runtimefields;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.metadata.MappingMetadata;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.xpack.core.XPackFeatureSet;\n+import org.elasticsearch.xpack.core.XPackField;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class RuntimeFieldsFeatureSetUsage extends XPackFeatureSet.Usage {\n+\n+    public static RuntimeFieldsFeatureSetUsage fromMetadata(Iterable<IndexMetadata> metadata) {\n+        Map<String, RuntimeFieldStats> fieldTypes = new HashMap<>();\n+        for (IndexMetadata indexMetadata : metadata) {\n+            if (indexMetadata.isSystem()) {\n+                // Don't include system indices in statistics about mappings, we care about the user's indices.\n+                continue;\n+            }\n+            Set<String> indexFieldTypes = new HashSet<>();\n+            MappingMetadata mappingMetadata = indexMetadata.mapping();\n+            if (mappingMetadata != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "295826641939488e46074883d37582afb542e055"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgwMTcxNg==", "bodyText": "If script isn't an instanceof Map can it be a String? Would we get the short form here?", "url": "https://github.com/elastic/elasticsearch/pull/65600#discussion_r532801716", "createdAt": "2020-11-30T18:15:37Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/runtimefields/RuntimeFieldsFeatureSetUsage.java", "diffHunk": "@@ -0,0 +1,272 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.runtimefields;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.metadata.MappingMetadata;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.xpack.core.XPackFeatureSet;\n+import org.elasticsearch.xpack.core.XPackField;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class RuntimeFieldsFeatureSetUsage extends XPackFeatureSet.Usage {\n+\n+    public static RuntimeFieldsFeatureSetUsage fromMetadata(Iterable<IndexMetadata> metadata) {\n+        Map<String, RuntimeFieldStats> fieldTypes = new HashMap<>();\n+        for (IndexMetadata indexMetadata : metadata) {\n+            if (indexMetadata.isSystem()) {\n+                // Don't include system indices in statistics about mappings, we care about the user's indices.\n+                continue;\n+            }\n+            Set<String> indexFieldTypes = new HashSet<>();\n+            MappingMetadata mappingMetadata = indexMetadata.mapping();\n+            if (mappingMetadata != null) {\n+                Object runtimeObject = mappingMetadata.getSourceAsMap().get(\"runtime\");\n+                if (runtimeObject instanceof Map) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    Map<String, Object> runtimeMappings = (Map<String, Object>) runtimeObject;\n+                    for (Object runtimeFieldMappingObject : runtimeMappings.values()) {\n+                        if (runtimeFieldMappingObject instanceof Map) {\n+                            @SuppressWarnings(\"unchecked\")\n+                            Map<String, Object> runtimeFieldMapping = (Map<String, Object>) runtimeFieldMappingObject;\n+                            Object typeObject = runtimeFieldMapping.get(\"type\");\n+                            if (typeObject != null) {\n+                                String type = typeObject.toString();\n+                                RuntimeFieldStats stats = fieldTypes.computeIfAbsent(type, RuntimeFieldStats::new);\n+                                stats.count++;\n+                                if (indexFieldTypes.add(type)) {\n+                                    stats.indexCount++;\n+                                }\n+                                Object scriptObject = runtimeFieldMapping.get(\"script\");\n+                                if (scriptObject == null) {\n+                                    stats.scriptLessCount++;\n+                                } else if (scriptObject instanceof Map) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "295826641939488e46074883d37582afb542e055"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgwMjIzNQ==", "bodyText": "Any reason not to use a List in the response? I know we sometimes use List and sometimes arrays but I've never been sure why.", "url": "https://github.com/elastic/elasticsearch/pull/65600#discussion_r532802235", "createdAt": "2020-11-30T18:16:28Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/runtimefields/RuntimeFieldsFeatureSetUsage.java", "diffHunk": "@@ -0,0 +1,272 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.runtimefields;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.metadata.MappingMetadata;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.xpack.core.XPackFeatureSet;\n+import org.elasticsearch.xpack.core.XPackField;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class RuntimeFieldsFeatureSetUsage extends XPackFeatureSet.Usage {\n+\n+    public static RuntimeFieldsFeatureSetUsage fromMetadata(Iterable<IndexMetadata> metadata) {\n+        Map<String, RuntimeFieldStats> fieldTypes = new HashMap<>();\n+        for (IndexMetadata indexMetadata : metadata) {\n+            if (indexMetadata.isSystem()) {\n+                // Don't include system indices in statistics about mappings, we care about the user's indices.\n+                continue;\n+            }\n+            Set<String> indexFieldTypes = new HashSet<>();\n+            MappingMetadata mappingMetadata = indexMetadata.mapping();\n+            if (mappingMetadata != null) {\n+                Object runtimeObject = mappingMetadata.getSourceAsMap().get(\"runtime\");\n+                if (runtimeObject instanceof Map) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    Map<String, Object> runtimeMappings = (Map<String, Object>) runtimeObject;\n+                    for (Object runtimeFieldMappingObject : runtimeMappings.values()) {\n+                        if (runtimeFieldMappingObject instanceof Map) {\n+                            @SuppressWarnings(\"unchecked\")\n+                            Map<String, Object> runtimeFieldMapping = (Map<String, Object>) runtimeFieldMappingObject;\n+                            Object typeObject = runtimeFieldMapping.get(\"type\");\n+                            if (typeObject != null) {\n+                                String type = typeObject.toString();\n+                                RuntimeFieldStats stats = fieldTypes.computeIfAbsent(type, RuntimeFieldStats::new);\n+                                stats.count++;\n+                                if (indexFieldTypes.add(type)) {\n+                                    stats.indexCount++;\n+                                }\n+                                Object scriptObject = runtimeFieldMapping.get(\"script\");\n+                                if (scriptObject == null) {\n+                                    stats.scriptLessCount++;\n+                                } else if (scriptObject instanceof Map) {\n+                                    @SuppressWarnings(\"unchecked\")\n+                                    Map<String, Object> script = (Map<String, Object>) scriptObject;\n+                                    Object sourceObject = script.get(\"source\");\n+                                    if (sourceObject != null) {\n+                                        String scriptSource = sourceObject.toString();\n+                                        int chars = scriptSource.length();\n+                                        long lines = scriptSource.lines().count();\n+                                        int docUsages = countOccurrences(scriptSource, \"doc[\\\\[\\\\.]\");\n+                                        int sourceUsages = countOccurrences(scriptSource, \"params\\\\._source\");\n+                                        stats.update(chars, lines, sourceUsages, docUsages);\n+                                    }\n+                                    Object langObject = script.get(\"lang\");\n+                                    if (langObject != null) {\n+                                        stats.scriptLangs.add(langObject.toString());\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        RuntimeFieldStats[] runtimeFieldStats = fieldTypes.values().toArray(new RuntimeFieldStats[0]);\n+        Arrays.sort(runtimeFieldStats, Comparator.comparing(RuntimeFieldStats::type));\n+        return new RuntimeFieldsFeatureSetUsage(runtimeFieldStats);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "295826641939488e46074883d37582afb542e055"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgwMjc5Ng==", "bodyText": "= 0 is the default, right?", "url": "https://github.com/elastic/elasticsearch/pull/65600#discussion_r532802796", "createdAt": "2020-11-30T18:17:25Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/runtimefields/RuntimeFieldsFeatureSetUsage.java", "diffHunk": "@@ -0,0 +1,272 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.runtimefields;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.metadata.MappingMetadata;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.xpack.core.XPackFeatureSet;\n+import org.elasticsearch.xpack.core.XPackField;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class RuntimeFieldsFeatureSetUsage extends XPackFeatureSet.Usage {\n+\n+    public static RuntimeFieldsFeatureSetUsage fromMetadata(Iterable<IndexMetadata> metadata) {\n+        Map<String, RuntimeFieldStats> fieldTypes = new HashMap<>();\n+        for (IndexMetadata indexMetadata : metadata) {\n+            if (indexMetadata.isSystem()) {\n+                // Don't include system indices in statistics about mappings, we care about the user's indices.\n+                continue;\n+            }\n+            Set<String> indexFieldTypes = new HashSet<>();\n+            MappingMetadata mappingMetadata = indexMetadata.mapping();\n+            if (mappingMetadata != null) {\n+                Object runtimeObject = mappingMetadata.getSourceAsMap().get(\"runtime\");\n+                if (runtimeObject instanceof Map) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    Map<String, Object> runtimeMappings = (Map<String, Object>) runtimeObject;\n+                    for (Object runtimeFieldMappingObject : runtimeMappings.values()) {\n+                        if (runtimeFieldMappingObject instanceof Map) {\n+                            @SuppressWarnings(\"unchecked\")\n+                            Map<String, Object> runtimeFieldMapping = (Map<String, Object>) runtimeFieldMappingObject;\n+                            Object typeObject = runtimeFieldMapping.get(\"type\");\n+                            if (typeObject != null) {\n+                                String type = typeObject.toString();\n+                                RuntimeFieldStats stats = fieldTypes.computeIfAbsent(type, RuntimeFieldStats::new);\n+                                stats.count++;\n+                                if (indexFieldTypes.add(type)) {\n+                                    stats.indexCount++;\n+                                }\n+                                Object scriptObject = runtimeFieldMapping.get(\"script\");\n+                                if (scriptObject == null) {\n+                                    stats.scriptLessCount++;\n+                                } else if (scriptObject instanceof Map) {\n+                                    @SuppressWarnings(\"unchecked\")\n+                                    Map<String, Object> script = (Map<String, Object>) scriptObject;\n+                                    Object sourceObject = script.get(\"source\");\n+                                    if (sourceObject != null) {\n+                                        String scriptSource = sourceObject.toString();\n+                                        int chars = scriptSource.length();\n+                                        long lines = scriptSource.lines().count();\n+                                        int docUsages = countOccurrences(scriptSource, \"doc[\\\\[\\\\.]\");\n+                                        int sourceUsages = countOccurrences(scriptSource, \"params\\\\._source\");\n+                                        stats.update(chars, lines, sourceUsages, docUsages);\n+                                    }\n+                                    Object langObject = script.get(\"lang\");\n+                                    if (langObject != null) {\n+                                        stats.scriptLangs.add(langObject.toString());\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        RuntimeFieldStats[] runtimeFieldStats = fieldTypes.values().toArray(new RuntimeFieldStats[0]);\n+        Arrays.sort(runtimeFieldStats, Comparator.comparing(RuntimeFieldStats::type));\n+        return new RuntimeFieldsFeatureSetUsage(runtimeFieldStats);\n+    }\n+\n+    private final RuntimeFieldStats[] stats;\n+\n+    RuntimeFieldsFeatureSetUsage(RuntimeFieldStats[] stats) {\n+        super(XPackField.RUNTIME_FIELDS, true, true);\n+        this.stats = stats;\n+    }\n+\n+    public RuntimeFieldsFeatureSetUsage(StreamInput in) throws IOException {\n+        super(in);\n+        this.stats = in.readArray(RuntimeFieldStats::new, RuntimeFieldStats[]::new);\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        super.writeTo(out);\n+        out.writeArray(stats);\n+    }\n+\n+    RuntimeFieldStats[] getRuntimeFieldStats() {\n+        return stats;\n+    }\n+\n+    @Override\n+    protected void innerXContent(XContentBuilder builder, Params params) throws IOException {\n+        super.innerXContent(builder, params);\n+        builder.startArray(\"field_types\");\n+        for (RuntimeFieldStats stats : stats) {\n+            stats.toXContent(builder, params);\n+        }\n+        builder.endArray();\n+    }\n+\n+    @Override\n+    public Version getMinimalSupportedVersion() {\n+        return Version.V_7_11_0;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        RuntimeFieldsFeatureSetUsage that = (RuntimeFieldsFeatureSetUsage) o;\n+        return Arrays.equals(stats, that.stats);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Arrays.hashCode(stats);\n+    }\n+\n+    private static int countOccurrences(String script, String keyword) {\n+        int occurrences = 0;\n+        Pattern pattern = Pattern.compile(keyword);\n+        Matcher matcher = pattern.matcher(script);\n+        while (matcher.find()) {\n+            occurrences++;\n+        }\n+        return occurrences;\n+    }\n+\n+    static final class RuntimeFieldStats implements Writeable, ToXContentObject {\n+        private final String type;\n+        private int count = 0;\n+        private int indexCount = 0;\n+        private final Set<String> scriptLangs;\n+        private long scriptLessCount = 0;\n+        private long maxLines = 0;\n+        private long totalLines = 0;\n+        private long maxChars = 0;\n+        private long totalChars = 0;\n+        private long maxSourceUsages = 0;\n+        private long totalSourceUsages = 0;\n+        private long maxDocUsages = 0;\n+        private long totalDocUsages = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "295826641939488e46074883d37582afb542e055"}, "originalPosition": 167}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxMjkzNzg1", "url": "https://github.com/elastic/elasticsearch/pull/65600#pullrequestreview-541293785", "createdAt": "2020-11-30T21:05:29Z", "commit": {"oid": "295826641939488e46074883d37582afb542e055"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQyMTowNToyOVrOH8Nz9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQyMTowNToyOVrOH8Nz9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkwMjkwMg==", "bodyText": "I think its worth double checking if this matches stuff like doc\\. I never can remember the escaping rules for character classes.", "url": "https://github.com/elastic/elasticsearch/pull/65600#discussion_r532902902", "createdAt": "2020-11-30T21:05:29Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/runtimefields/RuntimeFieldsFeatureSetUsage.java", "diffHunk": "@@ -0,0 +1,272 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.runtimefields;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.metadata.MappingMetadata;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.xpack.core.XPackFeatureSet;\n+import org.elasticsearch.xpack.core.XPackField;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class RuntimeFieldsFeatureSetUsage extends XPackFeatureSet.Usage {\n+\n+    public static RuntimeFieldsFeatureSetUsage fromMetadata(Iterable<IndexMetadata> metadata) {\n+        Map<String, RuntimeFieldStats> fieldTypes = new HashMap<>();\n+        for (IndexMetadata indexMetadata : metadata) {\n+            if (indexMetadata.isSystem()) {\n+                // Don't include system indices in statistics about mappings, we care about the user's indices.\n+                continue;\n+            }\n+            Set<String> indexFieldTypes = new HashSet<>();\n+            MappingMetadata mappingMetadata = indexMetadata.mapping();\n+            if (mappingMetadata != null) {\n+                Object runtimeObject = mappingMetadata.getSourceAsMap().get(\"runtime\");\n+                if (runtimeObject instanceof Map) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    Map<String, Object> runtimeMappings = (Map<String, Object>) runtimeObject;\n+                    for (Object runtimeFieldMappingObject : runtimeMappings.values()) {\n+                        if (runtimeFieldMappingObject instanceof Map) {\n+                            @SuppressWarnings(\"unchecked\")\n+                            Map<String, Object> runtimeFieldMapping = (Map<String, Object>) runtimeFieldMappingObject;\n+                            Object typeObject = runtimeFieldMapping.get(\"type\");\n+                            if (typeObject != null) {\n+                                String type = typeObject.toString();\n+                                RuntimeFieldStats stats = fieldTypes.computeIfAbsent(type, RuntimeFieldStats::new);\n+                                stats.count++;\n+                                if (indexFieldTypes.add(type)) {\n+                                    stats.indexCount++;\n+                                }\n+                                Object scriptObject = runtimeFieldMapping.get(\"script\");\n+                                if (scriptObject == null) {\n+                                    stats.scriptLessCount++;\n+                                } else if (scriptObject instanceof Map) {\n+                                    @SuppressWarnings(\"unchecked\")\n+                                    Map<String, Object> script = (Map<String, Object>) scriptObject;\n+                                    Object sourceObject = script.get(\"source\");\n+                                    if (sourceObject != null) {\n+                                        String scriptSource = sourceObject.toString();\n+                                        int chars = scriptSource.length();\n+                                        long lines = scriptSource.lines().count();\n+                                        int docUsages = countOccurrences(scriptSource, \"doc[\\\\[\\\\.]\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "295826641939488e46074883d37582afb542e055"}, "originalPosition": 70}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c45f6cd6bbd6bc3288a80e2165df62eaa1bfc249", "author": {"user": {"login": "javanna", "name": "Luca Cavanna"}}, "url": "https://github.com/elastic/elasticsearch/commit/c45f6cd6bbd6bc3288a80e2165df62eaa1bfc249", "committedDate": "2020-12-01T09:05:18Z", "message": "Merge branch 'master' into enhancement/runtime_fields_telemetry"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b8447c39accd010536e1e5a0bf22cccb1016c298", "author": {"user": {"login": "javanna", "name": "Luca Cavanna"}}, "url": "https://github.com/elastic/elasticsearch/commit/b8447c39accd010536e1e5a0bf22cccb1016c298", "committedDate": "2020-12-01T10:19:38Z", "message": "iter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "16854e38568815d87e125dea671a12158adae53e", "author": {"user": {"login": "javanna", "name": "Luca Cavanna"}}, "url": "https://github.com/elastic/elasticsearch/commit/16854e38568815d87e125dea671a12158adae53e", "committedDate": "2020-12-07T09:28:37Z", "message": "Merge branch 'master' into enhancement/runtime_fields_telemetry"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7a870e85789cab0d6cdc4e4440dbcd6c9bcdad60", "author": {"user": {"login": "javanna", "name": "Luca Cavanna"}}, "url": "https://github.com/elastic/elasticsearch/commit/7a870e85789cab0d6cdc4e4440dbcd6c9bcdad60", "committedDate": "2020-12-07T22:45:38Z", "message": "iter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c976a46d687826c9b03661ec1024f56769c4a7e1", "author": {"user": {"login": "javanna", "name": "Luca Cavanna"}}, "url": "https://github.com/elastic/elasticsearch/commit/c976a46d687826c9b03661ec1024f56769c4a7e1", "committedDate": "2020-12-08T07:51:08Z", "message": "Merge branch 'master' into enhancement/runtime_fields_telemetry"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4364, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}