{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkyNzQ0MzE3", "number": 62906, "title": "Introduce runtime section in mappings", "bodyText": "The runtime section is at the same level as the existing properties section. Its purpose is to hold runtime fields only. With the introduction of the runtime section, a runtime field can be defined by specifying its type (previously called runtime_type) and script.\nPUT /my-index/_mappings\n{\n    \"runtime\" : {\n        \"day_of_week\" : {\n            \"type\" : \"keyword\",\n            \"script\" : {\n                \"source\" : \"emit(doc['timestamp'].value.dayOfWeekEnum.getDisplayName(TextStyle.FULL, Locale.ROOT))\"\n            }\n        }\n    },\n    \"properties\" : {\n        \"timestamp\" : {\n            \"type\" : \"date\"\n        }\n    }\n}\n\nFields defined in the runtime section can be updated at any time as they are not present in the lucene index. They get replaced entirely when they get updated.\nThanks to the introduction of the runtime section, runtime fields override existing mapped fields defined with the same name, similarly to runtime fields defined in the search request.\nNote that the get field mappings API does not return runtime fields as it iterates through the mappers directly, which have no visibility over runtime fields.\nRelates to #59332", "createdAt": "2020-09-24T23:10:47Z", "url": "https://github.com/elastic/elasticsearch/pull/62906", "merged": true, "mergeCommit": {"oid": "3101293165acc0db8ef0f9e499eb498a4be4d23a"}, "closed": true, "closedAt": "2020-11-12T14:56:05Z", "author": {"login": "javanna"}, "timelineItems": {"totalCount": 36, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdNFzJ3gFqTQ5NzExMjIwOQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdby_SLAH2gAyNDkyNzQ0MzE3OjU2N2ZmODIwNTAxNjM0MDBjMjhhNDQxZTVkMGFhZjM4M2FhOTRmMmE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3MTEyMjA5", "url": "https://github.com/elastic/elasticsearch/pull/62906#pullrequestreview-497112209", "createdAt": "2020-09-27T21:23:39Z", "commit": {"oid": "d7cbcceca39894a77516a033f7f380da7de238ee"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3MzMyNTkx", "url": "https://github.com/elastic/elasticsearch/pull/62906#pullrequestreview-497332591", "createdAt": "2020-09-28T09:21:08Z", "commit": {"oid": "d7cbcceca39894a77516a033f7f380da7de238ee"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwOToyMTowOFrOHY1XLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwOToyMTowOFrOHY1XLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgwMjE1OA==", "bodyText": "How does this work when parsing documents? We presumably want to ensure that an incoming doc is parsed using the non-runtime version of the mapper if this exists?", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r495802158", "createdAt": "2020-09-28T09:21:08Z", "author": {"login": "romseygeek"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/MappingLookup.java", "diffHunk": "@@ -51,26 +51,36 @@ private static void put(Map<String, Analyzer> analyzers, String key, Analyzer va\n \n     public static MappingLookup fromMapping(Mapping mapping, Analyzer defaultIndex) {\n         List<ObjectMapper> newObjectMappers = new ArrayList<>();\n-        List<FieldMapper> newFieldMappers = new ArrayList<>();\n+        Map<String, FieldMapper> newFieldMappers = new HashMap<>();\n         List<FieldAliasMapper> newFieldAliasMappers = new ArrayList<>();\n+\n+        collect(mapping.root, newObjectMappers, newFieldMappers, newFieldAliasMappers);\n+\n+        //add runtime fields and replace concrete fields with runtime fields with the same name\n+        for (RuntimeFieldMapper runtimeMapper : mapping.root.runtimeMappers()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7cbcceca39894a77516a033f7f380da7de238ee"}, "originalPosition": 11}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dd5f648d77a15238def61e9aa53f19cd950d2224", "author": {"user": {"login": "javanna", "name": "Luca Cavanna"}}, "url": "https://github.com/elastic/elasticsearch/commit/dd5f648d77a15238def61e9aa53f19cd950d2224", "committedDate": "2020-11-10T16:47:06Z", "message": "Add support for runtime section in the mappings\n\nThe runtime section is at the same level as the existing properties section. Its purpose is to hold runtime fields only. With the introduction of the runtime section, a runtime field can be defined by specifying its type (previously called runtime_type) and script.\n\nFields defined in the runtime section can be updated at any time as they are not present in the lucene index. They get replaced entirely when they get updated.\n\nThanks to the introduction of the runtime section, runtime fields can override existing mapped fields defined with the same name, similarly to runtime fields defined in the search request."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d7cbcceca39894a77516a033f7f380da7de238ee", "author": {"user": {"login": "javanna", "name": "Luca Cavanna"}}, "url": "https://github.com/elastic/elasticsearch/commit/d7cbcceca39894a77516a033f7f380da7de238ee", "committedDate": "2020-09-24T23:09:02Z", "message": "Merge branch 'master' into enhancement/mapping_runtime_section"}, "afterCommit": {"oid": "dd5f648d77a15238def61e9aa53f19cd950d2224", "author": {"user": {"login": "javanna", "name": "Luca Cavanna"}}, "url": "https://github.com/elastic/elasticsearch/commit/dd5f648d77a15238def61e9aa53f19cd950d2224", "committedDate": "2020-11-10T16:47:06Z", "message": "Add support for runtime section in the mappings\n\nThe runtime section is at the same level as the existing properties section. Its purpose is to hold runtime fields only. With the introduction of the runtime section, a runtime field can be defined by specifying its type (previously called runtime_type) and script.\n\nFields defined in the runtime section can be updated at any time as they are not present in the lucene index. They get replaced entirely when they get updated.\n\nThanks to the introduction of the runtime section, runtime fields can override existing mapped fields defined with the same name, similarly to runtime fields defined in the search request."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8bad8dbe0da3a8cf55da9ba9e7691f52e22d36e7", "author": {"user": {"login": "javanna", "name": "Luca Cavanna"}}, "url": "https://github.com/elastic/elasticsearch/commit/8bad8dbe0da3a8cf55da9ba9e7691f52e22d36e7", "committedDate": "2020-11-10T17:12:17Z", "message": "iter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5f059980a75d49dd6f454eb1dfe39e65d843d56e", "author": {"user": {"login": "javanna", "name": "Luca Cavanna"}}, "url": "https://github.com/elastic/elasticsearch/commit/5f059980a75d49dd6f454eb1dfe39e65d843d56e", "committedDate": "2020-11-10T19:08:45Z", "message": "fix PermissionsIT"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "740425f91789c927e1722b80a8a25ad93aefb8bf", "author": {"user": {"login": "javanna", "name": "Luca Cavanna"}}, "url": "https://github.com/elastic/elasticsearch/commit/740425f91789c927e1722b80a8a25ad93aefb8bf", "committedDate": "2020-11-11T10:33:14Z", "message": "Merge branch 'master' into enhancement/mapping_runtime_section"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ae573321e1f91aae349b44f3a4cd01dd955033e1", "author": {"user": {"login": "javanna", "name": "Luca Cavanna"}}, "url": "https://github.com/elastic/elasticsearch/commit/ae573321e1f91aae349b44f3a4cd01dd955033e1", "committedDate": "2020-11-11T10:34:12Z", "message": "Merge branch 'master' into enhancement/mapping_runtime_section"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI4MDU1ODY5", "url": "https://github.com/elastic/elasticsearch/pull/62906#pullrequestreview-528055869", "createdAt": "2020-11-11T10:40:16Z", "commit": {"oid": "ae573321e1f91aae349b44f3a4cd01dd955033e1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxMDo0MDoxNlrOHxHrnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxMDo0MDoxNlrOHxHrnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI2ODEyNQ==", "bodyText": "I am not a big fan of this public static method here, but I think it's important to share it between QueryShardContext and RootObjectMapper", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r521268125", "createdAt": "2020-11-11T10:40:16Z", "author": {"login": "javanna"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/RuntimeFieldType.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.elasticsearch.common.xcontent.ToXContentFragment;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+\n+/**\n+ * Base implementation for a runtime field that can be defined as part of the runtime section of the index mappings\n+ */\n+public abstract class RuntimeFieldType extends MappedFieldType implements ToXContentFragment {\n+\n+    protected RuntimeFieldType(String name, Map<String, String> meta) {\n+        super(name, false, false, false, TextSearchInfo.SIMPLE_MATCH_WITHOUT_TERMS, meta);\n+    }\n+\n+    @Override\n+    public final XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject(name());\n+        builder.field(\"type\", typeName());\n+        boolean includeDefaults = params.paramAsBoolean(\"include_defaults\", false);\n+        doXContentBody(builder, includeDefaults);\n+        builder.endObject();\n+        return builder;\n+    }\n+\n+    /**\n+     * Prints out the parameters that subclasses expose\n+     */\n+    protected abstract void doXContentBody(XContentBuilder builder, boolean includeDefaults) throws IOException;\n+\n+    /**\n+     * Parser for a runtime field. Creates the appropriate {@link RuntimeFieldType} for a runtime field,\n+     * as defined in the runtime section of the index mappings.\n+     */\n+    public interface Parser {\n+        RuntimeFieldType parse(String name, Map<String, Object> node, Mapper.TypeParser.ParserContext parserContext)\n+            throws MapperParsingException;\n+    }\n+\n+    public static void parseRuntimeFields(Map<String, Object> node,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae573321e1f91aae349b44f3a4cd01dd955033e1"}, "originalPosition": 64}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI4MDU2MjU3", "url": "https://github.com/elastic/elasticsearch/pull/62906#pullrequestreview-528056257", "createdAt": "2020-11-11T10:40:54Z", "commit": {"oid": "ae573321e1f91aae349b44f3a4cd01dd955033e1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxMDo0MDo1NFrOHxHs1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxMDo0MDo1NFrOHxHs1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI2ODQzOQ==", "bodyText": "this was moved from RuntimeFieldMapperTests", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r521268439", "createdAt": "2020-11-11T10:40:54Z", "author": {"login": "javanna"}, "path": "server/src/test/java/org/elasticsearch/index/IndexSortSettingsTests.java", "diffHunk": "@@ -129,4 +144,50 @@ public void testInvalidMissing() {\n         assertThat(exc.getMessage(), containsString(\"Illegal missing value:[default],\" +\n             \" must be one of [_last, _first]\"));\n     }\n+\n+    public void testIndexSorting() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae573321e1f91aae349b44f3a4cd01dd955033e1"}, "originalPosition": 36}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI4MDYwNDU4", "url": "https://github.com/elastic/elasticsearch/pull/62906#pullrequestreview-528060458", "createdAt": "2020-11-11T10:47:03Z", "commit": {"oid": "ae573321e1f91aae349b44f3a4cd01dd955033e1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxMDo0NzowM1rOHxH5xg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxMDo0NzowM1rOHxH5xg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI3MTc1MA==", "bodyText": "these three tests I borrowed from MapperTestCase , they were previously run as part of RuntimeFieldMapperTests", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r521271750", "createdAt": "2020-11-11T10:47:03Z", "author": {"login": "javanna"}, "path": "x-pack/plugin/runtime-fields/src/test/java/org/elasticsearch/xpack/runtimefields/mapper/AbstractScriptFieldTypeTestCase.java", "diffHunk": "@@ -6,29 +6,173 @@\n \n package org.elasticsearch.xpack.runtimefields.mapper;\n \n+import org.apache.lucene.analysis.standard.StandardAnalyzer;\n import org.apache.lucene.index.IndexReader;\n import org.apache.lucene.search.Query;\n import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.common.CheckedConsumer;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.compress.CompressedXContent;\n import org.elasticsearch.common.geo.ShapeRelation;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.common.xcontent.XContentHelper;\n+import org.elasticsearch.common.xcontent.json.JsonXContent;\n+import org.elasticsearch.index.IndexSettings;\n+import org.elasticsearch.index.analysis.AnalyzerScope;\n+import org.elasticsearch.index.analysis.IndexAnalyzers;\n+import org.elasticsearch.index.analysis.NamedAnalyzer;\n import org.elasticsearch.index.mapper.MappedFieldType;\n+import org.elasticsearch.index.mapper.MapperParsingException;\n+import org.elasticsearch.index.mapper.MapperService;\n import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.index.similarity.SimilarityService;\n+import org.elasticsearch.indices.IndicesModule;\n+import org.elasticsearch.indices.mapper.MapperRegistry;\n+import org.elasticsearch.plugins.MapperPlugin;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.plugins.ScriptPlugin;\n+import org.elasticsearch.script.ScriptContext;\n+import org.elasticsearch.script.ScriptEngine;\n+import org.elasticsearch.script.ScriptModule;\n+import org.elasticsearch.script.ScriptService;\n import org.elasticsearch.search.lookup.SearchLookup;\n import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.runtimefields.RuntimeFields;\n \n import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n import java.util.function.BiConsumer;\n \n+import static java.util.stream.Collectors.toList;\n import static org.hamcrest.Matchers.equalTo;\n import static org.mockito.Matchers.anyString;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.when;\n \n-abstract class AbstractScriptFieldTypeTestCase extends ESTestCase {\n+public abstract class AbstractScriptFieldTypeTestCase extends ESTestCase {\n+\n+    private static final ToXContent.Params INCLUDE_DEFAULTS = new ToXContent.MapParams(Map.of(\"include_defaults\", \"true\"));\n+\n     protected abstract MappedFieldType simpleMappedFieldType() throws IOException;\n \n     protected abstract MappedFieldType loopFieldType() throws IOException;\n \n-    protected abstract String runtimeType();\n+    protected abstract String typeName();\n+\n+    public final void testMinimalSerializesToItself() throws IOException {\n+        XContentBuilder orig = JsonXContent.contentBuilder().startObject();\n+        createMapperService(runtimeFieldMapping(this::minimalMapping)).documentMapper().mapping().toXContent(orig, ToXContent.EMPTY_PARAMS);\n+        orig.endObject();\n+        XContentBuilder parsedFromOrig = JsonXContent.contentBuilder().startObject();\n+        createMapperService(orig).documentMapper().mapping().toXContent(parsedFromOrig, ToXContent.EMPTY_PARAMS);\n+        parsedFromOrig.endObject();\n+        assertEquals(Strings.toString(orig), Strings.toString(parsedFromOrig));\n+    }\n+\n+    public final void testMeta() throws IOException {\n+        XContentBuilder mapping = runtimeFieldMapping(b -> {\n+            minimalMapping(b);\n+            b.field(\"meta\", Collections.singletonMap(\"foo\", \"bar\"));\n+        });\n+        MapperService mapperService = createMapperService(mapping);\n+        assertEquals(\n+            XContentHelper.convertToMap(BytesReference.bytes(mapping), false, mapping.contentType()).v2(),\n+            XContentHelper.convertToMap(mapperService.documentMapper().mappingSource().uncompressed(), false, mapping.contentType()).v2()\n+        );\n+\n+        mapping = runtimeFieldMapping(this::minimalMapping);\n+        merge(mapperService, mapping);\n+        assertEquals(\n+            XContentHelper.convertToMap(BytesReference.bytes(mapping), false, mapping.contentType()).v2(),\n+            XContentHelper.convertToMap(mapperService.documentMapper().mappingSource().uncompressed(), false, mapping.contentType()).v2()\n+        );\n+\n+        mapping = runtimeFieldMapping(b -> {\n+            minimalMapping(b);\n+            b.field(\"meta\", Collections.singletonMap(\"baz\", \"quux\"));\n+        });\n+        merge(mapperService, mapping);\n+        assertEquals(\n+            XContentHelper.convertToMap(BytesReference.bytes(mapping), false, mapping.contentType()).v2(),\n+            XContentHelper.convertToMap(mapperService.documentMapper().mappingSource().uncompressed(), false, mapping.contentType()).v2()\n+        );\n+    }\n+\n+    public final void testMinimalMappingToMaximal() throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae573321e1f91aae349b44f3a4cd01dd955033e1"}, "originalPosition": 108}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI4MDYwNzA1", "url": "https://github.com/elastic/elasticsearch/pull/62906#pullrequestreview-528060705", "createdAt": "2020-11-11T10:47:25Z", "commit": {"oid": "ae573321e1f91aae349b44f3a4cd01dd955033e1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxMDo0NzoyNVrOHxH6jw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxMDo0NzoyNVrOHxH6jw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI3MTk1MQ==", "bodyText": "these were moved from RuntimeFieldMapperTests", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r521271951", "createdAt": "2020-11-11T10:47:25Z", "author": {"login": "javanna"}, "path": "x-pack/plugin/runtime-fields/src/test/java/org/elasticsearch/xpack/runtimefields/mapper/AbstractScriptFieldTypeTestCase.java", "diffHunk": "@@ -6,29 +6,173 @@\n \n package org.elasticsearch.xpack.runtimefields.mapper;\n \n+import org.apache.lucene.analysis.standard.StandardAnalyzer;\n import org.apache.lucene.index.IndexReader;\n import org.apache.lucene.search.Query;\n import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.common.CheckedConsumer;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.compress.CompressedXContent;\n import org.elasticsearch.common.geo.ShapeRelation;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.common.xcontent.XContentHelper;\n+import org.elasticsearch.common.xcontent.json.JsonXContent;\n+import org.elasticsearch.index.IndexSettings;\n+import org.elasticsearch.index.analysis.AnalyzerScope;\n+import org.elasticsearch.index.analysis.IndexAnalyzers;\n+import org.elasticsearch.index.analysis.NamedAnalyzer;\n import org.elasticsearch.index.mapper.MappedFieldType;\n+import org.elasticsearch.index.mapper.MapperParsingException;\n+import org.elasticsearch.index.mapper.MapperService;\n import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.index.similarity.SimilarityService;\n+import org.elasticsearch.indices.IndicesModule;\n+import org.elasticsearch.indices.mapper.MapperRegistry;\n+import org.elasticsearch.plugins.MapperPlugin;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.plugins.ScriptPlugin;\n+import org.elasticsearch.script.ScriptContext;\n+import org.elasticsearch.script.ScriptEngine;\n+import org.elasticsearch.script.ScriptModule;\n+import org.elasticsearch.script.ScriptService;\n import org.elasticsearch.search.lookup.SearchLookup;\n import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.runtimefields.RuntimeFields;\n \n import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n import java.util.function.BiConsumer;\n \n+import static java.util.stream.Collectors.toList;\n import static org.hamcrest.Matchers.equalTo;\n import static org.mockito.Matchers.anyString;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.when;\n \n-abstract class AbstractScriptFieldTypeTestCase extends ESTestCase {\n+public abstract class AbstractScriptFieldTypeTestCase extends ESTestCase {\n+\n+    private static final ToXContent.Params INCLUDE_DEFAULTS = new ToXContent.MapParams(Map.of(\"include_defaults\", \"true\"));\n+\n     protected abstract MappedFieldType simpleMappedFieldType() throws IOException;\n \n     protected abstract MappedFieldType loopFieldType() throws IOException;\n \n-    protected abstract String runtimeType();\n+    protected abstract String typeName();\n+\n+    public final void testMinimalSerializesToItself() throws IOException {\n+        XContentBuilder orig = JsonXContent.contentBuilder().startObject();\n+        createMapperService(runtimeFieldMapping(this::minimalMapping)).documentMapper().mapping().toXContent(orig, ToXContent.EMPTY_PARAMS);\n+        orig.endObject();\n+        XContentBuilder parsedFromOrig = JsonXContent.contentBuilder().startObject();\n+        createMapperService(orig).documentMapper().mapping().toXContent(parsedFromOrig, ToXContent.EMPTY_PARAMS);\n+        parsedFromOrig.endObject();\n+        assertEquals(Strings.toString(orig), Strings.toString(parsedFromOrig));\n+    }\n+\n+    public final void testMeta() throws IOException {\n+        XContentBuilder mapping = runtimeFieldMapping(b -> {\n+            minimalMapping(b);\n+            b.field(\"meta\", Collections.singletonMap(\"foo\", \"bar\"));\n+        });\n+        MapperService mapperService = createMapperService(mapping);\n+        assertEquals(\n+            XContentHelper.convertToMap(BytesReference.bytes(mapping), false, mapping.contentType()).v2(),\n+            XContentHelper.convertToMap(mapperService.documentMapper().mappingSource().uncompressed(), false, mapping.contentType()).v2()\n+        );\n+\n+        mapping = runtimeFieldMapping(this::minimalMapping);\n+        merge(mapperService, mapping);\n+        assertEquals(\n+            XContentHelper.convertToMap(BytesReference.bytes(mapping), false, mapping.contentType()).v2(),\n+            XContentHelper.convertToMap(mapperService.documentMapper().mappingSource().uncompressed(), false, mapping.contentType()).v2()\n+        );\n+\n+        mapping = runtimeFieldMapping(b -> {\n+            minimalMapping(b);\n+            b.field(\"meta\", Collections.singletonMap(\"baz\", \"quux\"));\n+        });\n+        merge(mapperService, mapping);\n+        assertEquals(\n+            XContentHelper.convertToMap(BytesReference.bytes(mapping), false, mapping.contentType()).v2(),\n+            XContentHelper.convertToMap(mapperService.documentMapper().mappingSource().uncompressed(), false, mapping.contentType()).v2()\n+        );\n+    }\n+\n+    public final void testMinimalMappingToMaximal() throws IOException {\n+        XContentBuilder orig = JsonXContent.contentBuilder().startObject();\n+        createMapperService(runtimeFieldMapping(this::minimalMapping)).documentMapper().mapping().toXContent(orig, INCLUDE_DEFAULTS);\n+        orig.endObject();\n+        XContentBuilder parsedFromOrig = JsonXContent.contentBuilder().startObject();\n+        createMapperService(orig).documentMapper().mapping().toXContent(parsedFromOrig, INCLUDE_DEFAULTS);\n+        parsedFromOrig.endObject();\n+        assertEquals(Strings.toString(orig), Strings.toString(parsedFromOrig));\n+    }\n+\n+    public void testScriptIsRequired() throws Exception {\n+        XContentBuilder mapping = runtimeFieldMapping(b -> { b.field(\"type\", typeName()); });\n+        MapperParsingException exception = expectThrows(MapperParsingException.class, () -> createMapperService(mapping));\n+        assertEquals(\"Failed to parse mapping: script must be specified for runtime field [field]\", exception.getMessage());\n+    }\n+\n+    public void testCopyToIsNotSupported() throws IOException {\n+        XContentBuilder mapping = runtimeFieldMapping(b -> {\n+            minimalMapping(b);\n+            b.field(\"copy_to\", \"target\");\n+        });\n+        MapperParsingException exception = expectThrows(MapperParsingException.class, () -> createMapperService(mapping));\n+        assertEquals(\"Failed to parse mapping: runtime field [field] does not support [copy_to]\", exception.getMessage());\n+    }\n+\n+    public void testMultiFieldsIsNotSupported() throws IOException {\n+        XContentBuilder mapping = runtimeFieldMapping(b -> {\n+            minimalMapping(b);\n+            b.startObject(\"fields\").startObject(\"test\").field(\"type\", \"keyword\").endObject().endObject();\n+        });\n+        MapperParsingException exception = expectThrows(MapperParsingException.class, () -> createMapperService(mapping));\n+        assertEquals(\"Failed to parse mapping: runtime field [field] does not support [fields]\", exception.getMessage());\n+    }\n+\n+    public void testStoredScriptsAreNotSupported() throws Exception {\n+        XContentBuilder mapping = runtimeFieldMapping(b -> {\n+            b.field(\"type\", typeName());\n+            b.startObject(\"script\").field(\"id\", \"test\").endObject();\n+        });\n+        MapperParsingException exception = expectThrows(MapperParsingException.class, () -> createMapperService(mapping));\n+        assertEquals(\"Failed to parse mapping: stored scripts are not supported for runtime field [field]\", exception.getMessage());\n+    }\n+\n+    public void testFieldCaps() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae573321e1f91aae349b44f3a4cd01dd955033e1"}, "originalPosition": 151}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI4MDYyMzkw", "url": "https://github.com/elastic/elasticsearch/pull/62906#pullrequestreview-528062390", "createdAt": "2020-11-11T10:49:32Z", "commit": {"oid": "ae573321e1f91aae349b44f3a4cd01dd955033e1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxMDo0OTozMlrOHxH-7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxMDo0OTozMlrOHxH-7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI3MzA3MQ==", "bodyText": "these were moved from RuntimeFieldMapperTests", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r521273071", "createdAt": "2020-11-11T10:49:32Z", "author": {"login": "javanna"}, "path": "x-pack/plugin/runtime-fields/src/test/java/org/elasticsearch/xpack/runtimefields/mapper/DateScriptFieldTypeTests.java", "diffHunk": "@@ -63,8 +67,43 @@\n import static org.hamcrest.Matchers.closeTo;\n import static org.hamcrest.Matchers.containsString;\n import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.instanceOf;\n \n public class DateScriptFieldTypeTests extends AbstractNonTextScriptFieldTypeTestCase {\n+\n+    public void testDateWithFormat() throws IOException {\n+        CheckedSupplier<XContentBuilder, IOException> mapping = () -> runtimeFieldMapping(b -> {\n+            minimalMapping(b);\n+            b.field(\"format\", \"yyyy-MM-dd\");\n+        });\n+        MapperService mapperService = createMapperService(mapping.get());\n+        MappedFieldType fieldType = mapperService.fieldType(\"field\");\n+        assertThat(fieldType, instanceOf(DateScriptFieldType.class));\n+        assertEquals(Strings.toString(mapping.get()), Strings.toString(mapperService.documentMapper()));\n+    }\n+\n+    public void testDateWithLocale() throws IOException {\n+        CheckedSupplier<XContentBuilder, IOException> mapping = () -> runtimeFieldMapping(b -> {\n+            minimalMapping(b);\n+            b.field(\"locale\", \"en_GB\");\n+        });\n+        MapperService mapperService = createMapperService(mapping.get());\n+        MappedFieldType fieldType = mapperService.fieldType(\"field\");\n+        assertThat(fieldType, instanceOf(DateScriptFieldType.class));\n+        assertEquals(Strings.toString(mapping.get()), Strings.toString(mapperService.documentMapper()));\n+    }\n+\n+    public void testDateWithLocaleAndFormat() throws IOException {\n+        CheckedSupplier<XContentBuilder, IOException> mapping = () -> runtimeFieldMapping(b -> {\n+            minimalMapping(b);\n+            b.field(\"format\", \"yyyy-MM-dd\").field(\"locale\", \"en_GB\");\n+        });\n+        MapperService mapperService = createMapperService(mapping.get());\n+        MappedFieldType fieldType = mapperService.fieldType(\"field\");\n+        assertThat(fieldType, instanceOf(DateScriptFieldType.class));\n+        assertEquals(Strings.toString(mapping.get()), Strings.toString(mapperService.documentMapper()));\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae573321e1f91aae349b44f3a4cd01dd955033e1"}, "originalPosition": 56}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "353dcd8366b702fb77af4e1a4ed41f3324f9795e", "author": {"user": {"login": "javanna", "name": "Luca Cavanna"}}, "url": "https://github.com/elastic/elasticsearch/commit/353dcd8366b702fb77af4e1a4ed41f3324f9795e", "committedDate": "2020-11-11T10:51:39Z", "message": "iter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "357f821d18cd05b5a1a6e3f44140cf98e49886b0", "author": {"user": {"login": "javanna", "name": "Luca Cavanna"}}, "url": "https://github.com/elastic/elasticsearch/commit/357f821d18cd05b5a1a6e3f44140cf98e49886b0", "committedDate": "2020-11-11T10:52:32Z", "message": "import"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI4MDg2NDgw", "url": "https://github.com/elastic/elasticsearch/pull/62906#pullrequestreview-528086480", "createdAt": "2020-11-11T11:24:38Z", "commit": {"oid": "357f821d18cd05b5a1a6e3f44140cf98e49886b0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxMToyNDozOVrOHxJG-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxMToyNDozOVrOHxJG-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI5MTUxMg==", "bodyText": "Dumb question: is there a reason this can't extend MappingServiceTestCase?", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r521291512", "createdAt": "2020-11-11T11:24:39Z", "author": {"login": "romseygeek"}, "path": "x-pack/plugin/runtime-fields/src/test/java/org/elasticsearch/xpack/runtimefields/mapper/AbstractScriptFieldTypeTestCase.java", "diffHunk": "@@ -6,29 +6,170 @@\n \n package org.elasticsearch.xpack.runtimefields.mapper;\n \n+import org.apache.lucene.analysis.standard.StandardAnalyzer;\n import org.apache.lucene.index.IndexReader;\n import org.apache.lucene.search.Query;\n import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.common.CheckedConsumer;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.compress.CompressedXContent;\n import org.elasticsearch.common.geo.ShapeRelation;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.common.xcontent.XContentHelper;\n+import org.elasticsearch.common.xcontent.json.JsonXContent;\n+import org.elasticsearch.index.IndexSettings;\n+import org.elasticsearch.index.analysis.AnalyzerScope;\n+import org.elasticsearch.index.analysis.IndexAnalyzers;\n+import org.elasticsearch.index.analysis.NamedAnalyzer;\n import org.elasticsearch.index.mapper.MappedFieldType;\n+import org.elasticsearch.index.mapper.MapperParsingException;\n+import org.elasticsearch.index.mapper.MapperService;\n import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.index.similarity.SimilarityService;\n+import org.elasticsearch.indices.IndicesModule;\n+import org.elasticsearch.indices.mapper.MapperRegistry;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.plugins.ScriptPlugin;\n+import org.elasticsearch.script.ScriptContext;\n+import org.elasticsearch.script.ScriptEngine;\n+import org.elasticsearch.script.ScriptModule;\n+import org.elasticsearch.script.ScriptService;\n import org.elasticsearch.search.lookup.SearchLookup;\n import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.runtimefields.RuntimeFields;\n \n import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n import java.util.function.BiConsumer;\n \n import static org.hamcrest.Matchers.equalTo;\n import static org.mockito.Matchers.anyString;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.when;\n \n-abstract class AbstractScriptFieldTypeTestCase extends ESTestCase {\n+public abstract class AbstractScriptFieldTypeTestCase extends ESTestCase {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "357f821d18cd05b5a1a6e3f44140cf98e49886b0"}, "originalPosition": 55}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "78445671b96d4ca81054e46dfa916310cf9d2328", "author": {"user": {"login": "javanna", "name": "Luca Cavanna"}}, "url": "https://github.com/elastic/elasticsearch/commit/78445671b96d4ca81054e46dfa916310cf9d2328", "committedDate": "2020-11-11T12:43:21Z", "message": "fix tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI4MTc4MTUy", "url": "https://github.com/elastic/elasticsearch/pull/62906#pullrequestreview-528178152", "createdAt": "2020-11-11T13:38:42Z", "commit": {"oid": "78445671b96d4ca81054e46dfa916310cf9d2328"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxMzozODo0MlrOHxNgFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxMzo1OTo1NlrOHxOUkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM2MzQ3OA==", "bodyText": "Nice!", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r521363478", "createdAt": "2020-11-11T13:38:42Z", "author": {"login": "nik9000"}, "path": "server/src/test/java/org/elasticsearch/index/IndexSortSettingsTests.java", "diffHunk": "@@ -129,4 +144,50 @@ public void testInvalidMissing() {\n         assertThat(exc.getMessage(), containsString(\"Illegal missing value:[default],\" +\n             \" must be one of [_last, _first]\"));\n     }\n+\n+    public void testIndexSorting() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI2ODQzOQ=="}, "originalCommit": {"oid": "ae573321e1f91aae349b44f3a4cd01dd955033e1"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM2NTI4NQ==", "bodyText": "I think extending MapperServiceTestCase will get you these \"for free\".", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r521365285", "createdAt": "2020-11-11T13:41:33Z", "author": {"login": "nik9000"}, "path": "server/src/test/java/org/elasticsearch/index/mapper/RootObjectMapperTests.java", "diffHunk": "@@ -19,25 +19,68 @@\n \n package org.elasticsearch.index.mapper;\n \n+import org.apache.lucene.analysis.standard.StandardAnalyzer;\n+import org.apache.lucene.search.Query;\n import org.elasticsearch.Version;\n import org.elasticsearch.cluster.metadata.IndexMetadata;\n import org.elasticsearch.common.Strings;\n import org.elasticsearch.common.compress.CompressedXContent;\n import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n import org.elasticsearch.common.xcontent.XContentBuilder;\n import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.index.IndexSettings;\n+import org.elasticsearch.index.analysis.AnalyzerScope;\n+import org.elasticsearch.index.analysis.IndexAnalyzers;\n+import org.elasticsearch.index.analysis.NamedAnalyzer;\n import org.elasticsearch.index.mapper.MapperService.MergeReason;\n-import org.elasticsearch.test.ESSingleNodeTestCase;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.index.similarity.SimilarityService;\n+import org.elasticsearch.indices.IndicesModule;\n+import org.elasticsearch.plugins.MapperPlugin;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.search.lookup.SearchLookup;\n+import org.elasticsearch.test.ESTestCase;\n \n import java.io.IOException;\n import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n \n import static org.elasticsearch.test.VersionUtils.randomVersionBetween;\n import static org.hamcrest.Matchers.containsString;\n import static org.hamcrest.Matchers.equalTo;\n import static org.hamcrest.Matchers.instanceOf;\n \n-public class RootObjectMapperTests extends ESSingleNodeTestCase {\n+public class RootObjectMapperTests extends ESTestCase {\n+\n+    private static MapperService createMapperService() {\n+        return createMapperService(Version.CURRENT);\n+    }\n+\n+    private static MapperService createMapperService(Version indexCreatedVersion) {\n+        return createMapperService(indexCreatedVersion, Collections.emptyList());\n+    }\n+\n+    private static MapperService createMapperService(List<MapperPlugin> mapperPlugins) {\n+        return createMapperService(Version.CURRENT, mapperPlugins);\n+    }\n+\n+    private static MapperService createMapperService(Version indexCreatedVersion, List<MapperPlugin> mapperPlugins) {\n+        Settings settings = Settings.builder().put(\"index.number_of_shards\", 1).put(\"index.number_of_replicas\", 0)\n+            .put(\"index.version.created\", indexCreatedVersion).build();\n+        IndexMetadata indexMetadata = IndexMetadata.builder(\"index\").settings(settings).build();\n+        IndexSettings indexSettings = new IndexSettings(indexMetadata, Settings.EMPTY);\n+        IndexAnalyzers indexAnalyzers = new IndexAnalyzers(\n+            Map.of(\"default\", new NamedAnalyzer(\"default\", AnalyzerScope.INDEX, new StandardAnalyzer())), Map.of(), Map.of());\n+        IndicesModule indicesModule = new IndicesModule(mapperPlugins);\n+        SimilarityService similarityService = new SimilarityService(indexSettings, null, Collections.emptyMap());\n+        return new MapperService(indexSettings, indexAnalyzers, NamedXContentRegistry.EMPTY, similarityService,\n+            indicesModule.getMapperRegistry(), () -> {\n+                throw new UnsupportedOperationException();\n+            }, () -> true, null);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78445671b96d4ca81054e46dfa916310cf9d2328"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM2NzIzMg==", "bodyText": "Could you do it more like:\nXcontentbuidler b = ;\nb.startObject().startObject(\"_doc\").startObject(\"runtime\");\nb.startObject(\"f1\").field(\"type\", \"test\").field(\"prop1\", \"value1\").endObject();\n...\n\nI think grouping the fields onto one line each makes them easier to read.", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r521367232", "createdAt": "2020-11-11T13:44:42Z", "author": {"login": "nik9000"}, "path": "server/src/test/java/org/elasticsearch/index/mapper/RootObjectMapperTests.java", "diffHunk": "@@ -465,13 +503,216 @@ public void testIllegalDynamicTemplate7DotXIndex() throws Exception {\n         }\n         mapping.endObject();\n         Version createdVersion = randomVersionBetween(random(), Version.V_7_0_0, Version.V_7_7_0);\n-        Settings indexSettings = Settings.builder()\n-            .put(IndexMetadata.SETTING_INDEX_VERSION_CREATED.getKey(), createdVersion)\n-            .build();\n-        MapperService mapperService = createIndex(\"test\", indexSettings).mapperService();\n+        MapperService mapperService = createMapperService(createdVersion);\n         DocumentMapper mapper = mapperService.merge(\"type\", new CompressedXContent(Strings.toString(mapping)), MergeReason.MAPPING_UPDATE);\n         assertThat(mapper.mappingSource().toString(), containsString(\"\\\"type\\\":\\\"string\\\"\"));\n         assertWarnings(\"dynamic template [my_template] has invalid content [{\\\"match_mapping_type\\\":\\\"string\\\",\\\"mapping\\\":{\\\"type\\\":\" +\n             \"\\\"string\\\"}}], caused by [No mapper found for type [string]]\");\n     }\n+\n+    public void testRuntimeSection() throws IOException {\n+        MapperService mapperService = createMapperService(Collections.singletonList(new RuntimeFieldPlugin()));\n+        MergeReason reason = randomFrom(MergeReason.MAPPING_UPDATE, MergeReason.INDEX_TEMPLATE);\n+        String mapping = Strings.toString(XContentFactory.jsonBuilder()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78445671b96d4ca81054e46dfa916310cf9d2328"}, "originalPosition": 209}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM2ODIyNg==", "bodyText": "The mapping method on MapperServiceTestCase is a helper for test cases that make the mapping. It always spits out properties which you don't want, but it might be useful to look at and adapt just to save a little copy and pasting on these mappings.", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r521368226", "createdAt": "2020-11-11T13:46:17Z", "author": {"login": "nik9000"}, "path": "server/src/test/java/org/elasticsearch/index/mapper/RootObjectMapperTests.java", "diffHunk": "@@ -465,13 +503,216 @@ public void testIllegalDynamicTemplate7DotXIndex() throws Exception {\n         }\n         mapping.endObject();\n         Version createdVersion = randomVersionBetween(random(), Version.V_7_0_0, Version.V_7_7_0);\n-        Settings indexSettings = Settings.builder()\n-            .put(IndexMetadata.SETTING_INDEX_VERSION_CREATED.getKey(), createdVersion)\n-            .build();\n-        MapperService mapperService = createIndex(\"test\", indexSettings).mapperService();\n+        MapperService mapperService = createMapperService(createdVersion);\n         DocumentMapper mapper = mapperService.merge(\"type\", new CompressedXContent(Strings.toString(mapping)), MergeReason.MAPPING_UPDATE);\n         assertThat(mapper.mappingSource().toString(), containsString(\"\\\"type\\\":\\\"string\\\"\"));\n         assertWarnings(\"dynamic template [my_template] has invalid content [{\\\"match_mapping_type\\\":\\\"string\\\",\\\"mapping\\\":{\\\"type\\\":\" +\n             \"\\\"string\\\"}}], caused by [No mapper found for type [string]]\");\n     }\n+\n+    public void testRuntimeSection() throws IOException {\n+        MapperService mapperService = createMapperService(Collections.singletonList(new RuntimeFieldPlugin()));\n+        MergeReason reason = randomFrom(MergeReason.MAPPING_UPDATE, MergeReason.INDEX_TEMPLATE);\n+        String mapping = Strings.toString(XContentFactory.jsonBuilder()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM2NzIzMg=="}, "originalCommit": {"oid": "78445671b96d4ca81054e46dfa916310cf9d2328"}, "originalPosition": 209}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM3MTM0MA==", "bodyText": "If you do Map.ofEntries and then do a Map.entry for each pair the formatter will \"do the right thing\" to keep these a little more readable. I think.", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r521371340", "createdAt": "2020-11-11T13:51:08Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/RuntimeFields.java", "diffHunk": "@@ -6,29 +6,55 @@\n \n package org.elasticsearch.xpack.runtimefields;\n \n-import org.elasticsearch.index.mapper.Mapper;\n+import org.elasticsearch.index.mapper.BooleanFieldMapper;\n+import org.elasticsearch.index.mapper.DateFieldMapper;\n+import org.elasticsearch.index.mapper.GeoPointFieldMapper;\n+import org.elasticsearch.index.mapper.IpFieldMapper;\n+import org.elasticsearch.index.mapper.KeywordFieldMapper;\n+import org.elasticsearch.index.mapper.NumberFieldMapper;\n+import org.elasticsearch.index.mapper.RuntimeFieldType;\n import org.elasticsearch.plugins.MapperPlugin;\n import org.elasticsearch.plugins.Plugin;\n import org.elasticsearch.plugins.ScriptPlugin;\n import org.elasticsearch.script.ScriptContext;\n import org.elasticsearch.xpack.runtimefields.mapper.BooleanFieldScript;\n+import org.elasticsearch.xpack.runtimefields.mapper.BooleanScriptFieldType;\n import org.elasticsearch.xpack.runtimefields.mapper.DateFieldScript;\n+import org.elasticsearch.xpack.runtimefields.mapper.DateScriptFieldType;\n import org.elasticsearch.xpack.runtimefields.mapper.DoubleFieldScript;\n+import org.elasticsearch.xpack.runtimefields.mapper.DoubleScriptFieldType;\n import org.elasticsearch.xpack.runtimefields.mapper.GeoPointFieldScript;\n+import org.elasticsearch.xpack.runtimefields.mapper.GeoPointScriptFieldType;\n import org.elasticsearch.xpack.runtimefields.mapper.IpFieldScript;\n+import org.elasticsearch.xpack.runtimefields.mapper.IpScriptFieldType;\n+import org.elasticsearch.xpack.runtimefields.mapper.KeywordScriptFieldType;\n import org.elasticsearch.xpack.runtimefields.mapper.LongFieldScript;\n-import org.elasticsearch.xpack.runtimefields.mapper.RuntimeFieldMapper;\n+import org.elasticsearch.xpack.runtimefields.mapper.LongScriptFieldType;\n import org.elasticsearch.xpack.runtimefields.mapper.StringFieldScript;\n \n-import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n \n public final class RuntimeFields extends Plugin implements MapperPlugin, ScriptPlugin {\n \n     @Override\n-    public Map<String, Mapper.TypeParser> getMappers() {\n-        return Collections.singletonMap(RuntimeFieldMapper.CONTENT_TYPE, RuntimeFieldMapper.PARSER);\n+    public Map<String, RuntimeFieldType.Parser> getRuntimeFieldTypes() {\n+        return Map.of(\n+            BooleanFieldMapper.CONTENT_TYPE,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78445671b96d4ca81054e46dfa916310cf9d2328"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM3MjEyOA==", "bodyText": "Would it be more clear if we made the subclasses override doXContentBody?", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r521372128", "createdAt": "2020-11-11T13:52:26Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/mapper/AbstractScriptFieldType.java", "diffHunk": "@@ -12,52 +12,58 @@\n import org.apache.lucene.search.spans.SpanMultiTermQueryWrapper;\n import org.apache.lucene.search.spans.SpanQuery;\n import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.common.CheckedBiConsumer;\n import org.elasticsearch.common.TriFunction;\n import org.elasticsearch.common.geo.ShapeRelation;\n import org.elasticsearch.common.time.DateMathParser;\n import org.elasticsearch.common.unit.Fuzziness;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.mapper.ContentPath;\n import org.elasticsearch.index.mapper.DocValueFetcher;\n+import org.elasticsearch.index.mapper.FieldMapper;\n import org.elasticsearch.index.mapper.MappedFieldType;\n-import org.elasticsearch.index.mapper.TextSearchInfo;\n+import org.elasticsearch.index.mapper.Mapper;\n+import org.elasticsearch.index.mapper.MapperParsingException;\n+import org.elasticsearch.index.mapper.RuntimeFieldType;\n import org.elasticsearch.index.mapper.ValueFetcher;\n import org.elasticsearch.index.query.QueryShardContext;\n import org.elasticsearch.script.Script;\n+import org.elasticsearch.script.ScriptType;\n import org.elasticsearch.search.lookup.SearchLookup;\n \n+import java.io.IOException;\n import java.time.ZoneId;\n+import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n \n import static org.elasticsearch.search.SearchService.ALLOW_EXPENSIVE_QUERIES;\n \n /**\n  * Abstract base {@linkplain MappedFieldType} for scripted fields.\n  */\n-abstract class AbstractScriptFieldType<LeafFactory> extends MappedFieldType {\n+abstract class AbstractScriptFieldType<LeafFactory> extends RuntimeFieldType {\n     protected final Script script;\n     private final TriFunction<String, Map<String, Object>, SearchLookup, LeafFactory> factory;\n+    private final CheckedBiConsumer<XContentBuilder, Boolean, IOException> toXContent;\n+\n+    AbstractScriptFieldType(String name, TriFunction<String, Map<String, Object>, SearchLookup, LeafFactory> factory, Builder builder) {\n+        this(name, factory, builder.script.getValue(), builder.meta.getValue(), builder::toXContent);\n+    }\n \n     AbstractScriptFieldType(\n         String name,\n-        Script script,\n         TriFunction<String, Map<String, Object>, SearchLookup, LeafFactory> factory,\n-        Map<String, String> meta\n+        Script script,\n+        Map<String, String> meta,\n+        CheckedBiConsumer<XContentBuilder, Boolean, IOException> toXContent\n     ) {\n-        super(name, false, false, false, TextSearchInfo.SIMPLE_MATCH_WITHOUT_TERMS, meta);\n-        this.script = script;\n+        super(name, meta);\n         this.factory = factory;\n-    }\n-\n-    protected abstract String runtimeType();\n-\n-    @Override\n-    public final String typeName() {\n-        return RuntimeFieldMapper.CONTENT_TYPE;\n-    }\n-\n-    @Override\n-    public final String familyTypeName() {\n-        return runtimeType();\n+        this.script = script;\n+        this.toXContent = toXContent;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78445671b96d4ca81054e46dfa916310cf9d2328"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM3Mjg4NQ==", "bodyText": "I'd just do MappedFieldType or even RuntimeFieldType on the link, just to keep it a little shorter. I think it is ok to import classes just so javadoc can see them.", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r521372885", "createdAt": "2020-11-11T13:53:41Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/mapper/AbstractScriptFieldType.java", "diffHunk": "@@ -174,46 +180,115 @@ public SpanQuery spanPrefixQuery(String value, SpanMultiTermQueryWrapper.SpanRew\n     private String unsupported(String query, String supported) {\n         return String.format(\n             Locale.ROOT,\n-            \"Can only use %s queries on %s fields - not on [%s] which is of type [%s] with runtime_type [%s]\",\n+            \"Can only use %s queries on %s fields - not on [%s] which is a runtime field of type [%s]\",\n             query,\n             supported,\n             name(),\n-            RuntimeFieldMapper.CONTENT_TYPE,\n-            runtimeType()\n+            typeName()\n         );\n     }\n \n     protected final void checkAllowExpensiveQueries(QueryShardContext context) {\n         if (context.allowExpensiveQueries() == false) {\n             throw new ElasticsearchException(\n-                \"queries cannot be executed against [\"\n-                    + RuntimeFieldMapper.CONTENT_TYPE\n-                    + \"] fields while [\"\n-                    + ALLOW_EXPENSIVE_QUERIES.getKey()\n-                    + \"] is set to [false].\"\n+                \"queries cannot be executed against runtime fields while [\" + ALLOW_EXPENSIVE_QUERIES.getKey() + \"] is set to [false].\"\n             );\n         }\n     }\n \n-    /**\n-     * The format that this field should use. The default implementation is\n-     * {@code null} because most fields don't support formats.\n-     */\n-    protected String format() {\n-        return null;\n+    @Override\n+    public ValueFetcher valueFetcher(QueryShardContext context, SearchLookup lookup, String format) {\n+        return new DocValueFetcher(docValueFormat(format, null), lookup.doc().getForField(this));\n+    }\n+\n+    @Override\n+    protected final void doXContentBody(XContentBuilder builder, boolean includeDefaults) throws IOException {\n+        toXContent.accept(builder, includeDefaults);\n     }\n \n     /**\n-     * The locale that this field's format should use. The default\n-     * implementation is {@code null} because most fields don't\n-     * support formats.\n+     *  For runtime fields the {@link RuntimeFieldType.Parser} returns directly the {@link org.elasticsearch.index.mapper.MappedFieldType}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78445671b96d4ca81054e46dfa916310cf9d2328"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM3Mzc3NQ==", "bodyText": "Is this something we should keep doing forever or just a way to get this in without making 123213214 changes? Like, should we stop doing this in a follow up change?", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r521373775", "createdAt": "2020-11-11T13:55:09Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/mapper/AbstractScriptFieldType.java", "diffHunk": "@@ -174,46 +180,115 @@ public SpanQuery spanPrefixQuery(String value, SpanMultiTermQueryWrapper.SpanRew\n     private String unsupported(String query, String supported) {\n         return String.format(\n             Locale.ROOT,\n-            \"Can only use %s queries on %s fields - not on [%s] which is of type [%s] with runtime_type [%s]\",\n+            \"Can only use %s queries on %s fields - not on [%s] which is a runtime field of type [%s]\",\n             query,\n             supported,\n             name(),\n-            RuntimeFieldMapper.CONTENT_TYPE,\n-            runtimeType()\n+            typeName()\n         );\n     }\n \n     protected final void checkAllowExpensiveQueries(QueryShardContext context) {\n         if (context.allowExpensiveQueries() == false) {\n             throw new ElasticsearchException(\n-                \"queries cannot be executed against [\"\n-                    + RuntimeFieldMapper.CONTENT_TYPE\n-                    + \"] fields while [\"\n-                    + ALLOW_EXPENSIVE_QUERIES.getKey()\n-                    + \"] is set to [false].\"\n+                \"queries cannot be executed against runtime fields while [\" + ALLOW_EXPENSIVE_QUERIES.getKey() + \"] is set to [false].\"\n             );\n         }\n     }\n \n-    /**\n-     * The format that this field should use. The default implementation is\n-     * {@code null} because most fields don't support formats.\n-     */\n-    protected String format() {\n-        return null;\n+    @Override\n+    public ValueFetcher valueFetcher(QueryShardContext context, SearchLookup lookup, String format) {\n+        return new DocValueFetcher(docValueFormat(format, null), lookup.doc().getForField(this));\n+    }\n+\n+    @Override\n+    protected final void doXContentBody(XContentBuilder builder, boolean includeDefaults) throws IOException {\n+        toXContent.accept(builder, includeDefaults);\n     }\n \n     /**\n-     * The locale that this field's format should use. The default\n-     * implementation is {@code null} because most fields don't\n-     * support formats.\n+     *  For runtime fields the {@link RuntimeFieldType.Parser} returns directly the {@link org.elasticsearch.index.mapper.MappedFieldType}.\n+     *  Internally we still create a {@link Builder} so we reuse the {@link FieldMapper.Parameter} infrastructure,\n+     *  but {@link Builder#init(FieldMapper)} and {@link Builder#build(ContentPath)} are never called as\n+     *  {@link RuntimeFieldTypeParser#parse(String, Map, Mapper.TypeParser.ParserContext)} calls\n+     *  {@link Builder#parse(String, Mapper.TypeParser.ParserContext, Map)} and returns the corresponding\n+     *  {@link org.elasticsearch.index.mapper.MappedFieldType}.\n      */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78445671b96d4ca81054e46dfa916310cf9d2328"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM3NjkxNA==", "bodyText": "Maybe keep the traditional properties at the top? I think the runtime properties will tend to consume the traditional ones so I'd try to read the traditional ones first.", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r521376914", "createdAt": "2020-11-11T13:59:56Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/src/test/resources/rest-api-spec/test/runtime_fields/10_keyword.yml", "diffHunk": "@@ -8,49 +8,46 @@ setup:\n             number_of_shards: 1\n             number_of_replicas: 0\n           mappings:\n-            properties:\n-              timestamp:\n-                type: date\n-              temperature:\n-                type: long\n-              voltage:\n-                type: double\n-              node:\n-                type: keyword\n-                store: true\n+            runtime:\n               day_of_week:\n-                type: runtime\n-                runtime_type: keyword\n+                type: keyword\n                 script: |\n                   emit(doc['timestamp'].value.dayOfWeekEnum.getDisplayName(TextStyle.FULL, Locale.ROOT));\n               # Test fetching from _source\n               day_of_week_from_source:\n-                type: runtime\n-                runtime_type: keyword\n+                type: keyword\n                 script: |\n                   Instant instant = Instant.ofEpochMilli(params._source.timestamp);\n                   ZonedDateTime dt = ZonedDateTime.ofInstant(instant, ZoneId.of(\"UTC\"));\n                   emit(dt.dayOfWeek.getDisplayName(TextStyle.FULL, Locale.ROOT));\n               # Test fetching many values\n               day_of_week_letters:\n-                type: runtime\n-                runtime_type: keyword\n+                type: keyword\n                 script: |\n                   for (String dow: doc['day_of_week']) {\n                     for (int i = 0; i < dow.length(); i++) {\n                       emit(dow.charAt(i).toString());\n                     }\n                   }\n               prefixed_node:\n-                type: runtime\n-                runtime_type: keyword\n+                type: keyword\n                 script:\n                   source: |\n                     for (String node : params._fields.node.values) {\n                       emit(params.prefix + node);\n                     }\n                   params:\n                     prefix: node_\n+            properties:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78445671b96d4ca81054e46dfa916310cf9d2328"}, "originalPosition": 52}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "58c07f75a80d1b24b89dbc75ad5c4012be1e509c", "author": {"user": {"login": "javanna", "name": "Luca Cavanna"}}, "url": "https://github.com/elastic/elasticsearch/commit/58c07f75a80d1b24b89dbc75ad5c4012be1e509c", "committedDate": "2020-11-11T14:55:05Z", "message": "iter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "131f83c2d8902c206b114188c3115e75905fb19c", "author": {"user": {"login": "javanna", "name": "Luca Cavanna"}}, "url": "https://github.com/elastic/elasticsearch/commit/131f83c2d8902c206b114188c3115e75905fb19c", "committedDate": "2020-11-11T16:21:13Z", "message": "iter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "99988214ce08190f435894fe2d3fac6716086af9", "author": {"user": {"login": "javanna", "name": "Luca Cavanna"}}, "url": "https://github.com/elastic/elasticsearch/commit/99988214ce08190f435894fe2d3fac6716086af9", "committedDate": "2020-11-11T16:21:42Z", "message": "Merge branch 'master' into enhancement/mapping_runtime_section"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "380a1333d431a1ce042da8762833943b54be1fb9", "author": {"user": {"login": "javanna", "name": "Luca Cavanna"}}, "url": "https://github.com/elastic/elasticsearch/commit/380a1333d431a1ce042da8762833943b54be1fb9", "committedDate": "2020-11-11T16:22:36Z", "message": "spotless"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c4edd4d3b4d32b9f98db80ca57f8f8a9be1ec6e", "author": {"user": {"login": "javanna", "name": "Luca Cavanna"}}, "url": "https://github.com/elastic/elasticsearch/commit/6c4edd4d3b4d32b9f98db80ca57f8f8a9be1ec6e", "committedDate": "2020-11-11T16:29:48Z", "message": "formatting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b53bf037eb98fe12ad629974ef00a54b5e37410e", "author": {"user": {"login": "javanna", "name": "Luca Cavanna"}}, "url": "https://github.com/elastic/elasticsearch/commit/b53bf037eb98fe12ad629974ef00a54b5e37410e", "committedDate": "2020-11-11T17:46:52Z", "message": "fix test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1701c2e5b798286649454556afb74d94eb976a67", "author": {"user": {"login": "javanna", "name": "Luca Cavanna"}}, "url": "https://github.com/elastic/elasticsearch/commit/1701c2e5b798286649454556afb74d94eb976a67", "committedDate": "2020-11-11T19:16:24Z", "message": "Merge branch 'master' into enhancement/mapping_runtime_section"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3e64d012b35a4df374f6bbf8fa2da79b95ea7587", "author": {"user": {"login": "javanna", "name": "Luca Cavanna"}}, "url": "https://github.com/elastic/elasticsearch/commit/3e64d012b35a4df374f6bbf8fa2da79b95ea7587", "committedDate": "2020-11-12T09:12:50Z", "message": "Merge branch 'master' into enhancement/mapping_runtime_section"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "21a2f47e0458cb3fd93df7f8d529871e8336057c", "author": {"user": {"login": "javanna", "name": "Luca Cavanna"}}, "url": "https://github.com/elastic/elasticsearch/commit/21a2f47e0458cb3fd93df7f8d529871e8336057c", "committedDate": "2020-11-12T09:36:43Z", "message": "fix test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI4OTQ1NTcz", "url": "https://github.com/elastic/elasticsearch/pull/62906#pullrequestreview-528945573", "createdAt": "2020-11-12T10:24:24Z", "commit": {"oid": "21a2f47e0458cb3fd93df7f8d529871e8336057c"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxMDoyNDoyNFrOHx0K3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxMDo1NzozNFrOHx1bng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTk5NzAyMQ==", "bodyText": "This is an interesting one.  I'm not really sure what sourcePaths should return for runtime fields - I feel like maybe it should be an empty set?  The ValueFetcher isn't using sourcePaths to load data for these fields, so maybe it doesn't matter.", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r521997021", "createdAt": "2020-11-12T10:24:24Z", "author": {"login": "romseygeek"}, "path": "server/src/test/java/org/elasticsearch/index/mapper/FieldTypeLookupTests.java", "diffHunk": "@@ -101,28 +104,94 @@ public void testSourcePathsWithCopyTo() {\n             .copyTo(\"field\")\n             .build(new ContentPath());\n \n-        FieldTypeLookup lookup = new FieldTypeLookup(Arrays.asList(field, otherField), emptyList());\n+        FieldTypeLookup lookup = new FieldTypeLookup(Arrays.asList(field, otherField), emptyList(), emptyList());\n \n         assertEquals(Set.of(\"other_field\", \"field\"), lookup.sourcePaths(\"field\"));\n         assertEquals(Set.of(\"other_field\", \"field\"), lookup.sourcePaths(\"field.subfield1\"));\n     }\n \n     public void testIteratorImmutable() {\n         MockFieldMapper f1 = new MockFieldMapper(\"foo\");\n-        FieldTypeLookup lookup = new FieldTypeLookup(Collections.singletonList(f1), emptyList());\n-\n-        try {\n-            Iterator<MappedFieldType> itr = lookup.iterator();\n-            assertTrue(itr.hasNext());\n-            assertEquals(f1.fieldType(), itr.next());\n-            itr.remove();\n-            fail(\"remove should have failed\");\n-        } catch (UnsupportedOperationException e) {\n-            // expected\n+        FieldTypeLookup lookup = new FieldTypeLookup(Collections.singletonList(f1), emptyList(), emptyList());\n+\n+        Iterator<MappedFieldType> itr = lookup.iterator();\n+        assertTrue(itr.hasNext());\n+        assertEquals(f1.fieldType(), itr.next());\n+        expectThrows(UnsupportedOperationException.class, itr::remove);\n+    }\n+\n+    public void testRuntimeFieldsLookup() {\n+        MockFieldMapper concrete = new MockFieldMapper(\"concrete\");\n+        TestRuntimeField runtime = new TestRuntimeField(\"runtime\");\n+\n+        FieldTypeLookup fieldTypeLookup = new FieldTypeLookup(List.of(concrete), emptyList(), List.of(runtime));\n+        assertThat(fieldTypeLookup.get(\"concrete\"), instanceOf(MockFieldMapper.FakeFieldType.class));\n+        assertThat(fieldTypeLookup.get(\"runtime\"), instanceOf(TestRuntimeField.class));\n+        assertEquals(2, size(fieldTypeLookup.iterator()));\n+    }\n+\n+    public void testRuntimeFieldOverrides() {\n+        MockFieldMapper field = new MockFieldMapper(\"field\");\n+        MockFieldMapper subfield = new MockFieldMapper(\"object.subfield\");\n+        MockFieldMapper concrete = new MockFieldMapper(\"concrete\");\n+        TestRuntimeField fieldOverride = new TestRuntimeField(\"field\");\n+        TestRuntimeField subfieldOverride = new TestRuntimeField(\"object.subfield\");\n+        TestRuntimeField runtime = new TestRuntimeField(\"runtime\");\n+\n+        FieldTypeLookup fieldTypeLookup = new FieldTypeLookup(List.of(field, concrete, subfield), emptyList(),\n+            List.of(fieldOverride, runtime, subfieldOverride));\n+        assertThat(fieldTypeLookup.get(\"field\"), instanceOf(TestRuntimeField.class));\n+        assertThat(fieldTypeLookup.get(\"object.subfield\"), instanceOf(TestRuntimeField.class));\n+        assertThat(fieldTypeLookup.get(\"concrete\"), instanceOf(MockFieldMapper.FakeFieldType.class));\n+        assertThat(fieldTypeLookup.get(\"runtime\"), instanceOf(TestRuntimeField.class));\n+        assertEquals(4, size(fieldTypeLookup.iterator()));\n+    }\n+\n+    public void testRuntimeFieldsSimpleMatchToFullName() {\n+        MockFieldMapper field1 = new MockFieldMapper(\"field1\");\n+        MockFieldMapper concrete = new MockFieldMapper(\"concrete\");\n+        TestRuntimeField field2 = new TestRuntimeField(\"field2\");\n+        TestRuntimeField subfield = new TestRuntimeField(\"object.subfield\");\n+\n+        FieldTypeLookup fieldTypeLookup = new FieldTypeLookup(List.of(field1, concrete), emptyList(), List.of(field2, subfield));\n+        {\n+            Set<String> matches = fieldTypeLookup.simpleMatchToFullName(\"fie*\");\n+            assertEquals(2, matches.size());\n+            assertTrue(matches.contains(\"field1\"));\n+            assertTrue(matches.contains(\"field2\"));\n+        }\n+        {\n+            Set<String> matches = fieldTypeLookup.simpleMatchToFullName(\"object.sub*\");\n+            assertEquals(1, matches.size());\n+            assertTrue(matches.contains(\"object.subfield\"));\n+        }\n+    }\n+\n+    public void testRuntimeFieldsSourcePaths() {\n+        MockFieldMapper field1 = new MockFieldMapper(\"field1\");\n+        MockFieldMapper concrete = new MockFieldMapper(\"concrete\");\n+        TestRuntimeField field2 = new TestRuntimeField(\"field2\");\n+        TestRuntimeField subfield = new TestRuntimeField(\"object.subfield\");\n+\n+        FieldTypeLookup fieldTypeLookup = new FieldTypeLookup(List.of(field1, concrete), emptyList(), List.of(field2, subfield));\n+        {\n+            Set<String> sourcePaths = fieldTypeLookup.sourcePaths(\"field1\");\n+            assertEquals(1, sourcePaths.size());\n+            assertTrue(sourcePaths.contains(\"field1\"));\n+        }\n+        {\n+            Set<String> sourcePaths = fieldTypeLookup.sourcePaths(\"field2\");\n+            assertEquals(1, sourcePaths.size());\n+            assertTrue(sourcePaths.contains(\"field2\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21a2f47e0458cb3fd93df7f8d529871e8336057c"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjAxNjc5OA==", "bodyText": "Can we add a test to see what happens when you merge in a concrete field as well?", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r522016798", "createdAt": "2020-11-12T10:56:09Z", "author": {"login": "romseygeek"}, "path": "server/src/test/java/org/elasticsearch/index/mapper/RootObjectMapperTests.java", "diffHunk": "@@ -465,13 +447,127 @@ public void testIllegalDynamicTemplate7DotXIndex() throws Exception {\n         }\n         mapping.endObject();\n         Version createdVersion = randomVersionBetween(random(), Version.V_7_0_0, Version.V_7_7_0);\n-        Settings indexSettings = Settings.builder()\n-            .put(IndexMetadata.SETTING_INDEX_VERSION_CREATED.getKey(), createdVersion)\n-            .build();\n-        MapperService mapperService = createIndex(\"test\", indexSettings).mapperService();\n-        DocumentMapper mapper = mapperService.merge(\"type\", new CompressedXContent(Strings.toString(mapping)), MergeReason.MAPPING_UPDATE);\n-        assertThat(mapper.mappingSource().toString(), containsString(\"\\\"type\\\":\\\"string\\\"\"));\n+        MapperService mapperService = createMapperService(createdVersion, mapping);\n+        assertThat(mapperService.documentMapper().mappingSource().toString(), containsString(\"\\\"type\\\":\\\"string\\\"\"));\n         assertWarnings(\"dynamic template [my_template] has invalid content [{\\\"match_mapping_type\\\":\\\"string\\\",\\\"mapping\\\":{\\\"type\\\":\" +\n             \"\\\"string\\\"}}], caused by [No mapper found for type [string]]\");\n     }\n+\n+    @Override\n+    protected Collection<? extends Plugin> getPlugins() {\n+        return Collections.singletonList(new RuntimeFieldPlugin());\n+    }\n+\n+    public void testRuntimeSection() throws IOException {\n+        String mapping = Strings.toString(runtimeMapping(builder -> {\n+            builder.startObject(\"field1\").field(\"type\", \"test\").field(\"prop1\", \"value1\").endObject();\n+            builder.startObject(\"field2\").field(\"type\", \"test\").field(\"prop2\", \"value2\").endObject();\n+            builder.startObject(\"field3\").field(\"type\", \"test\").endObject();\n+        }));\n+        MapperService mapperService = createMapperService(mapping);\n+        assertEquals(mapping, mapperService.documentMapper().mappingSource().toString());\n+    }\n+\n+    public void testRuntimeSectionMerge() throws IOException {\n+        MapperService mapperService;\n+        {\n+            String mapping = Strings.toString(runtimeMapping(builder -> {\n+                builder.startObject(\"field1\").field(\"type\", \"test\").field(\"prop1\", \"first version\").endObject();\n+                builder.startObject(\"field2\").field(\"type\", \"test\").endObject();\n+            }));\n+            mapperService = createMapperService(mapping);\n+            assertEquals(mapping, mapperService.documentMapper().mappingSource().toString());\n+        }\n+        {\n+            String mapping = Strings.toString(runtimeMapping(\n+                builder -> builder.startObject(\"field1\").field(\"type\", \"test\").field(\"prop2\", \"second version\").endObject()));\n+            merge(mapperService, mapping);\n+            RuntimeField field1 = (RuntimeField)mapperService.fieldType(\"field1\");\n+            assertNull(field1.prop1);\n+            assertEquals(\"second version\", field1.prop2);\n+            RuntimeField field2 = (RuntimeField)mapperService.fieldType(\"field2\");\n+            assertNull(field2.prop1);\n+            assertNull(field2.prop2);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21a2f47e0458cb3fd93df7f8d529871e8336057c"}, "originalPosition": 463}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjAxNzY5NA==", "bodyText": "Much nicer to only have this on the DateFieldType, thanks!", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r522017694", "createdAt": "2020-11-12T10:57:34Z", "author": {"login": "romseygeek"}, "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/mapper/AbstractScriptFieldType.java", "diffHunk": "@@ -174,46 +180,115 @@ public SpanQuery spanPrefixQuery(String value, SpanMultiTermQueryWrapper.SpanRew\n     private String unsupported(String query, String supported) {\n         return String.format(\n             Locale.ROOT,\n-            \"Can only use %s queries on %s fields - not on [%s] which is of type [%s] with runtime_type [%s]\",\n+            \"Can only use %s queries on %s fields - not on [%s] which is a runtime field of type [%s]\",\n             query,\n             supported,\n             name(),\n-            RuntimeFieldMapper.CONTENT_TYPE,\n-            runtimeType()\n+            typeName()\n         );\n     }\n \n     protected final void checkAllowExpensiveQueries(QueryShardContext context) {\n         if (context.allowExpensiveQueries() == false) {\n             throw new ElasticsearchException(\n-                \"queries cannot be executed against [\"\n-                    + RuntimeFieldMapper.CONTENT_TYPE\n-                    + \"] fields while [\"\n-                    + ALLOW_EXPENSIVE_QUERIES.getKey()\n-                    + \"] is set to [false].\"\n+                \"queries cannot be executed against runtime fields while [\" + ALLOW_EXPENSIVE_QUERIES.getKey() + \"] is set to [false].\"\n             );\n         }\n     }\n \n-    /**\n-     * The format that this field should use. The default implementation is\n-     * {@code null} because most fields don't support formats.\n-     */\n-    protected String format() {\n-        return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21a2f47e0458cb3fd93df7f8d529871e8336057c"}, "originalPosition": 121}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9b38b205c112fbdf272109102e5eafd6b2fd2cb5", "author": {"user": {"login": "javanna", "name": "Luca Cavanna"}}, "url": "https://github.com/elastic/elasticsearch/commit/9b38b205c112fbdf272109102e5eafd6b2fd2cb5", "committedDate": "2020-11-12T11:36:04Z", "message": "expand tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7fc73eb2f0195cf58680e0da3e4852ba55f8be01", "author": {"user": {"login": "javanna", "name": "Luca Cavanna"}}, "url": "https://github.com/elastic/elasticsearch/commit/7fc73eb2f0195cf58680e0da3e4852ba55f8be01", "committedDate": "2020-11-12T13:00:24Z", "message": "Merge branch 'master' into enhancement/mapping_runtime_section"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4b8361e7a30eca598c4c3caf3f7fa80613461ae1", "author": {"user": {"login": "javanna", "name": "Luca Cavanna"}}, "url": "https://github.com/elastic/elasticsearch/commit/4b8361e7a30eca598c4c3caf3f7fa80613461ae1", "committedDate": "2020-11-12T13:05:59Z", "message": "add comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e081564ba0174044f052a53b8285bff67e4df37f", "author": {"user": {"login": "javanna", "name": "Luca Cavanna"}}, "url": "https://github.com/elastic/elasticsearch/commit/e081564ba0174044f052a53b8285bff67e4df37f", "committedDate": "2020-11-12T13:11:00Z", "message": "fix test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI5MDc1OTcy", "url": "https://github.com/elastic/elasticsearch/pull/62906#pullrequestreview-529075972", "createdAt": "2020-11-12T13:17:57Z", "commit": {"oid": "e081564ba0174044f052a53b8285bff67e4df37f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxMzoxNzo1N1rOHx6Vxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxMzoxNzo1N1rOHx6Vxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA5ODExOQ==", "bodyText": "@nik9000 this is for you I think :)", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r522098119", "createdAt": "2020-11-12T13:17:57Z", "author": {"login": "javanna"}, "path": "x-pack/plugin/runtime-fields/qa/core-with-search/src/yamlRestTest/java/org/elasticsearch/xpack/runtimefields/test/search/CoreTestsWithSearchRuntimeFieldsIT.java", "diffHunk": "@@ -116,20 +111,22 @@ protected boolean modifySearch(ApiCallSection search) {\n                         return mergeMappings(new String[] { \"*\" });\n                     }\n                     String[] patterns = Arrays.stream(index.split(\",\")).map(m -> m.equals(\"_all\") ? \"*\" : m).toArray(String[]::new);\n+                    // TODO this is always false?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e081564ba0174044f052a53b8285bff67e4df37f"}, "originalPosition": 45}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI4MzQ4Mjc2", "url": "https://github.com/elastic/elasticsearch/pull/62906#pullrequestreview-528348276", "createdAt": "2020-11-11T16:44:48Z", "commit": {"oid": "6c4edd4d3b4d32b9f98db80ca57f8f8a9be1ec6e"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxNjo0NDo0OFrOHxVWHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxMzo0MjozMFrOHx7R9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ5MTk5OA==", "bodyText": "OH! I see you even said it. I should read more closely!", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r521491998", "createdAt": "2020-11-11T16:44:48Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/mapper/AbstractScriptFieldType.java", "diffHunk": "@@ -174,46 +180,115 @@ public SpanQuery spanPrefixQuery(String value, SpanMultiTermQueryWrapper.SpanRew\n     private String unsupported(String query, String supported) {\n         return String.format(\n             Locale.ROOT,\n-            \"Can only use %s queries on %s fields - not on [%s] which is of type [%s] with runtime_type [%s]\",\n+            \"Can only use %s queries on %s fields - not on [%s] which is a runtime field of type [%s]\",\n             query,\n             supported,\n             name(),\n-            RuntimeFieldMapper.CONTENT_TYPE,\n-            runtimeType()\n+            typeName()\n         );\n     }\n \n     protected final void checkAllowExpensiveQueries(QueryShardContext context) {\n         if (context.allowExpensiveQueries() == false) {\n             throw new ElasticsearchException(\n-                \"queries cannot be executed against [\"\n-                    + RuntimeFieldMapper.CONTENT_TYPE\n-                    + \"] fields while [\"\n-                    + ALLOW_EXPENSIVE_QUERIES.getKey()\n-                    + \"] is set to [false].\"\n+                \"queries cannot be executed against runtime fields while [\" + ALLOW_EXPENSIVE_QUERIES.getKey() + \"] is set to [false].\"\n             );\n         }\n     }\n \n-    /**\n-     * The format that this field should use. The default implementation is\n-     * {@code null} because most fields don't support formats.\n-     */\n-    protected String format() {\n-        return null;\n+    @Override\n+    public ValueFetcher valueFetcher(QueryShardContext context, SearchLookup lookup, String format) {\n+        return new DocValueFetcher(docValueFormat(format, null), lookup.doc().getForField(this));\n+    }\n+\n+    @Override\n+    protected final void doXContentBody(XContentBuilder builder, boolean includeDefaults) throws IOException {\n+        toXContent.accept(builder, includeDefaults);\n     }\n \n     /**\n-     * The locale that this field's format should use. The default\n-     * implementation is {@code null} because most fields don't\n-     * support formats.\n+     *  For runtime fields the {@link RuntimeFieldType.Parser} returns directly the {@link org.elasticsearch.index.mapper.MappedFieldType}.\n+     *  Internally we still create a {@link Builder} so we reuse the {@link FieldMapper.Parameter} infrastructure,\n+     *  but {@link Builder#init(FieldMapper)} and {@link Builder#build(ContentPath)} are never called as\n+     *  {@link RuntimeFieldTypeParser#parse(String, Map, Mapper.TypeParser.ParserContext)} calls\n+     *  {@link Builder#parse(String, Mapper.TypeParser.ParserContext, Map)} and returns the corresponding\n+     *  {@link org.elasticsearch.index.mapper.MappedFieldType}.\n      */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM3Mzc3NQ=="}, "originalCommit": {"oid": "78445671b96d4ca81054e46dfa916310cf9d2328"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjExMDgwMQ==", "bodyText": "I figure there is a chance runtime fields will use the source path, yeah. But at least for now they don't so it doesn't really matter. I guess emptySet is more correct, but, yeah, it doesn't really matter.", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r522110801", "createdAt": "2020-11-12T13:38:22Z", "author": {"login": "nik9000"}, "path": "server/src/test/java/org/elasticsearch/index/mapper/FieldTypeLookupTests.java", "diffHunk": "@@ -101,28 +104,94 @@ public void testSourcePathsWithCopyTo() {\n             .copyTo(\"field\")\n             .build(new ContentPath());\n \n-        FieldTypeLookup lookup = new FieldTypeLookup(Arrays.asList(field, otherField), emptyList());\n+        FieldTypeLookup lookup = new FieldTypeLookup(Arrays.asList(field, otherField), emptyList(), emptyList());\n \n         assertEquals(Set.of(\"other_field\", \"field\"), lookup.sourcePaths(\"field\"));\n         assertEquals(Set.of(\"other_field\", \"field\"), lookup.sourcePaths(\"field.subfield1\"));\n     }\n \n     public void testIteratorImmutable() {\n         MockFieldMapper f1 = new MockFieldMapper(\"foo\");\n-        FieldTypeLookup lookup = new FieldTypeLookup(Collections.singletonList(f1), emptyList());\n-\n-        try {\n-            Iterator<MappedFieldType> itr = lookup.iterator();\n-            assertTrue(itr.hasNext());\n-            assertEquals(f1.fieldType(), itr.next());\n-            itr.remove();\n-            fail(\"remove should have failed\");\n-        } catch (UnsupportedOperationException e) {\n-            // expected\n+        FieldTypeLookup lookup = new FieldTypeLookup(Collections.singletonList(f1), emptyList(), emptyList());\n+\n+        Iterator<MappedFieldType> itr = lookup.iterator();\n+        assertTrue(itr.hasNext());\n+        assertEquals(f1.fieldType(), itr.next());\n+        expectThrows(UnsupportedOperationException.class, itr::remove);\n+    }\n+\n+    public void testRuntimeFieldsLookup() {\n+        MockFieldMapper concrete = new MockFieldMapper(\"concrete\");\n+        TestRuntimeField runtime = new TestRuntimeField(\"runtime\");\n+\n+        FieldTypeLookup fieldTypeLookup = new FieldTypeLookup(List.of(concrete), emptyList(), List.of(runtime));\n+        assertThat(fieldTypeLookup.get(\"concrete\"), instanceOf(MockFieldMapper.FakeFieldType.class));\n+        assertThat(fieldTypeLookup.get(\"runtime\"), instanceOf(TestRuntimeField.class));\n+        assertEquals(2, size(fieldTypeLookup.iterator()));\n+    }\n+\n+    public void testRuntimeFieldOverrides() {\n+        MockFieldMapper field = new MockFieldMapper(\"field\");\n+        MockFieldMapper subfield = new MockFieldMapper(\"object.subfield\");\n+        MockFieldMapper concrete = new MockFieldMapper(\"concrete\");\n+        TestRuntimeField fieldOverride = new TestRuntimeField(\"field\");\n+        TestRuntimeField subfieldOverride = new TestRuntimeField(\"object.subfield\");\n+        TestRuntimeField runtime = new TestRuntimeField(\"runtime\");\n+\n+        FieldTypeLookup fieldTypeLookup = new FieldTypeLookup(List.of(field, concrete, subfield), emptyList(),\n+            List.of(fieldOverride, runtime, subfieldOverride));\n+        assertThat(fieldTypeLookup.get(\"field\"), instanceOf(TestRuntimeField.class));\n+        assertThat(fieldTypeLookup.get(\"object.subfield\"), instanceOf(TestRuntimeField.class));\n+        assertThat(fieldTypeLookup.get(\"concrete\"), instanceOf(MockFieldMapper.FakeFieldType.class));\n+        assertThat(fieldTypeLookup.get(\"runtime\"), instanceOf(TestRuntimeField.class));\n+        assertEquals(4, size(fieldTypeLookup.iterator()));\n+    }\n+\n+    public void testRuntimeFieldsSimpleMatchToFullName() {\n+        MockFieldMapper field1 = new MockFieldMapper(\"field1\");\n+        MockFieldMapper concrete = new MockFieldMapper(\"concrete\");\n+        TestRuntimeField field2 = new TestRuntimeField(\"field2\");\n+        TestRuntimeField subfield = new TestRuntimeField(\"object.subfield\");\n+\n+        FieldTypeLookup fieldTypeLookup = new FieldTypeLookup(List.of(field1, concrete), emptyList(), List.of(field2, subfield));\n+        {\n+            Set<String> matches = fieldTypeLookup.simpleMatchToFullName(\"fie*\");\n+            assertEquals(2, matches.size());\n+            assertTrue(matches.contains(\"field1\"));\n+            assertTrue(matches.contains(\"field2\"));\n+        }\n+        {\n+            Set<String> matches = fieldTypeLookup.simpleMatchToFullName(\"object.sub*\");\n+            assertEquals(1, matches.size());\n+            assertTrue(matches.contains(\"object.subfield\"));\n+        }\n+    }\n+\n+    public void testRuntimeFieldsSourcePaths() {\n+        MockFieldMapper field1 = new MockFieldMapper(\"field1\");\n+        MockFieldMapper concrete = new MockFieldMapper(\"concrete\");\n+        TestRuntimeField field2 = new TestRuntimeField(\"field2\");\n+        TestRuntimeField subfield = new TestRuntimeField(\"object.subfield\");\n+\n+        FieldTypeLookup fieldTypeLookup = new FieldTypeLookup(List.of(field1, concrete), emptyList(), List.of(field2, subfield));\n+        {\n+            Set<String> sourcePaths = fieldTypeLookup.sourcePaths(\"field1\");\n+            assertEquals(1, sourcePaths.size());\n+            assertTrue(sourcePaths.contains(\"field1\"));\n+        }\n+        {\n+            Set<String> sourcePaths = fieldTypeLookup.sourcePaths(\"field2\");\n+            assertEquals(1, sourcePaths.size());\n+            assertTrue(sourcePaths.contains(\"field2\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTk5NzAyMQ=="}, "originalCommit": {"oid": "21a2f47e0458cb3fd93df7f8d529871e8336057c"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjExMTE0Nw==", "bodyText": "This one got harder to read!", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r522111147", "createdAt": "2020-11-12T13:38:55Z", "author": {"login": "nik9000"}, "path": "server/src/test/java/org/elasticsearch/index/mapper/RootObjectMapperTests.java", "diffHunk": "@@ -150,51 +153,50 @@ public void testDynamicTemplates() throws Exception {\n                         .endArray()\n                     .endObject()\n                 .endObject());\n-        MapperService mapperService = createIndex(\"test\").mapperService();\n-        DocumentMapper mapper = mapperService.merge(\"type\", new CompressedXContent(mapping), MergeReason.MAPPING_UPDATE);\n-        assertEquals(mapping, mapper.mappingSource().toString());\n+        MapperService mapperService = createMapperService(mapping);\n+        assertEquals(mapping, mapperService.documentMapper().mappingSource().toString());\n \n         // no update if templates are not set explicitly\n         String mapping2 = Strings.toString(XContentFactory.jsonBuilder()\n                 .startObject()\n-                .startObject(\"type\")\n+                .startObject(MapperService.SINGLE_MAPPING_NAME)\n                 .endObject()\n             .endObject());\n-        mapper = mapperService.merge(\"type\", new CompressedXContent(mapping2), MergeReason.MAPPING_UPDATE);\n-        assertEquals(mapping, mapper.mappingSource().toString());\n+        merge(mapperService, mapping2);\n+        assertEquals(mapping, mapperService.documentMapper().mappingSource().toString());\n \n         String mapping3 = Strings.toString(XContentFactory.jsonBuilder()\n                 .startObject()\n-                .startObject(\"type\")\n-                    .field(\"dynamic_templates\", Arrays.asList())\n+                .startObject(MapperService.SINGLE_MAPPING_NAME)\n+                    .field(\"dynamic_templates\", Collections.emptyList())\n                 .endObject()\n             .endObject());\n-        mapper = mapperService.merge(\"type\", new CompressedXContent(mapping3), MergeReason.MAPPING_UPDATE);\n-        assertEquals(mapping3, mapper.mappingSource().toString());\n+        merge(mapperService, mapping3);\n+        assertEquals(mapping3, mapperService.documentMapper().mappingSource().toString());\n     }\n \n     public void testDynamicTemplatesForIndexTemplate() throws IOException {\n         String mapping = Strings.toString(XContentFactory.jsonBuilder().startObject()\n             .startArray(\"dynamic_templates\")\n-                .startObject()\n-                    .startObject(\"first_template\")\n-                        .field(\"path_match\", \"first\")\n-                        .startObject(\"mapping\")\n-                            .field(\"type\", \"keyword\")\n-                        .endObject()\n-                    .endObject()\n-                .endObject()\n-                .startObject()\n-                    .startObject(\"second_template\")\n-                        .field(\"path_match\", \"second\")\n-                        .startObject(\"mapping\")\n-                            .field(\"type\", \"keyword\")\n-                        .endObject()\n-                    .endObject()\n-                .endObject()\n+            .startObject()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e081564ba0174044f052a53b8285bff67e4df37f"}, "originalPosition": 220}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjExMTg0MA==", "bodyText": "Thanks!", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r522111840", "createdAt": "2020-11-12T13:39:56Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/runtime-fields/qa/build.gradle", "diffHunk": "@@ -1,4 +1,4 @@\n-// Shared infratructure\n+// Shared infrastructure", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e081564ba0174044f052a53b8285bff67e4df37f"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjExMzI0NA==", "bodyText": "ooops. I think I mean length == 1. I can take a look in a follow up.", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r522113244", "createdAt": "2020-11-12T13:42:08Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/runtime-fields/qa/core-with-search/src/yamlRestTest/java/org/elasticsearch/xpack/runtimefields/test/search/CoreTestsWithSearchRuntimeFieldsIT.java", "diffHunk": "@@ -116,20 +111,22 @@ protected boolean modifySearch(ApiCallSection search) {\n                         return mergeMappings(new String[] { \"*\" });\n                     }\n                     String[] patterns = Arrays.stream(index.split(\",\")).map(m -> m.equals(\"_all\") ? \"*\" : m).toArray(String[]::new);\n+                    // TODO this is always false?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA5ODExOQ=="}, "originalCommit": {"oid": "e081564ba0174044f052a53b8285bff67e4df37f"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjExMzUyNQ==", "bodyText": "\u2764\ufe0f", "url": "https://github.com/elastic/elasticsearch/pull/62906#discussion_r522113525", "createdAt": "2020-11-12T13:42:30Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/RuntimeFields.java", "diffHunk": "@@ -6,29 +6,48 @@\n \n package org.elasticsearch.xpack.runtimefields;\n \n-import org.elasticsearch.index.mapper.Mapper;\n+import org.elasticsearch.index.mapper.BooleanFieldMapper;\n+import org.elasticsearch.index.mapper.DateFieldMapper;\n+import org.elasticsearch.index.mapper.GeoPointFieldMapper;\n+import org.elasticsearch.index.mapper.IpFieldMapper;\n+import org.elasticsearch.index.mapper.KeywordFieldMapper;\n+import org.elasticsearch.index.mapper.NumberFieldMapper;\n+import org.elasticsearch.index.mapper.RuntimeFieldType;\n import org.elasticsearch.plugins.MapperPlugin;\n import org.elasticsearch.plugins.Plugin;\n import org.elasticsearch.plugins.ScriptPlugin;\n import org.elasticsearch.script.ScriptContext;\n import org.elasticsearch.xpack.runtimefields.mapper.BooleanFieldScript;\n+import org.elasticsearch.xpack.runtimefields.mapper.BooleanScriptFieldType;\n import org.elasticsearch.xpack.runtimefields.mapper.DateFieldScript;\n+import org.elasticsearch.xpack.runtimefields.mapper.DateScriptFieldType;\n import org.elasticsearch.xpack.runtimefields.mapper.DoubleFieldScript;\n+import org.elasticsearch.xpack.runtimefields.mapper.DoubleScriptFieldType;\n import org.elasticsearch.xpack.runtimefields.mapper.GeoPointFieldScript;\n+import org.elasticsearch.xpack.runtimefields.mapper.GeoPointScriptFieldType;\n import org.elasticsearch.xpack.runtimefields.mapper.IpFieldScript;\n+import org.elasticsearch.xpack.runtimefields.mapper.IpScriptFieldType;\n+import org.elasticsearch.xpack.runtimefields.mapper.KeywordScriptFieldType;\n import org.elasticsearch.xpack.runtimefields.mapper.LongFieldScript;\n-import org.elasticsearch.xpack.runtimefields.mapper.RuntimeFieldMapper;\n+import org.elasticsearch.xpack.runtimefields.mapper.LongScriptFieldType;\n import org.elasticsearch.xpack.runtimefields.mapper.StringFieldScript;\n \n-import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n \n public final class RuntimeFields extends Plugin implements MapperPlugin, ScriptPlugin {\n \n     @Override\n-    public Map<String, Mapper.TypeParser> getMappers() {\n-        return Collections.singletonMap(RuntimeFieldMapper.CONTENT_TYPE, RuntimeFieldMapper.PARSER);\n+    public Map<String, RuntimeFieldType.Parser> getRuntimeFieldTypes() {\n+        return Map.ofEntries(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e081564ba0174044f052a53b8285bff67e4df37f"}, "originalPosition": 42}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI5MDk2ODMx", "url": "https://github.com/elastic/elasticsearch/pull/62906#pullrequestreview-529096831", "createdAt": "2020-11-12T13:43:22Z", "commit": {"oid": "e081564ba0174044f052a53b8285bff67e4df37f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "567ff82050163400c28a441e5d0aaf383aa94f2a", "author": {"user": {"login": "javanna", "name": "Luca Cavanna"}}, "url": "https://github.com/elastic/elasticsearch/commit/567ff82050163400c28a441e5d0aaf383aa94f2a", "committedDate": "2020-11-12T13:57:34Z", "message": "restore formatting"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4618, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}