{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcyNTAxNjgw", "number": 61467, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMzoyNjo1MVrOEbkITg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxOTo1NToxNFrOEmwoMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MzM4OTU4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/common/Rounding.java", "isResolved": false, "comments": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMzoyNjo1MVrOHFkNPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxODowMjo1NVrOHRgp-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU5ODE0MA==", "bodyText": "would it be doable to detect timezones that don't work with this optimization at runtime instead of maintaining an allowlist?", "url": "https://github.com/elastic/elasticsearch/pull/61467#discussion_r475598140", "createdAt": "2020-08-24T13:26:51Z", "author": {"login": "jpountz"}, "path": "server/src/main/java/org/elasticsearch/common/Rounding.java", "diffHunk": "@@ -401,8 +404,22 @@ private LocalDateTime truncateLocalDateTime(LocalDateTime localDateTime) {\n             }\n         }\n \n+        /**\n+         * Time zones with two midnights get \"funny\" non-continuous rounding\n+         * that isn't compatible with the pre-computed array rounding.\n+         */\n+        private static final Set<String> HAS_TWO_MIDNIGHTS = Set.of(\"America/Moncton\", \"America/St_Johns\", \"Canada/Newfoundland\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7687e30291243995cffeb7d633a93bf798c29f57"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTYwMTkyMQ==", "bodyText": "I can't think of a way to do right now. At least, not a good way.", "url": "https://github.com/elastic/elasticsearch/pull/61467#discussion_r475601921", "createdAt": "2020-08-24T13:32:49Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/common/Rounding.java", "diffHunk": "@@ -401,8 +404,22 @@ private LocalDateTime truncateLocalDateTime(LocalDateTime localDateTime) {\n             }\n         }\n \n+        /**\n+         * Time zones with two midnights get \"funny\" non-continuous rounding\n+         * that isn't compatible with the pre-computed array rounding.\n+         */\n+        private static final Set<String> HAS_TWO_MIDNIGHTS = Set.of(\"America/Moncton\", \"America/St_Johns\", \"Canada/Newfoundland\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU5ODE0MA=="}, "originalCommit": {"oid": "7687e30291243995cffeb7d633a93bf798c29f57"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU3OTc5MQ==", "bodyText": "I thought Canada was changing time at 2 am, on another side, some other known time zones such as Asia/Gaza for example seems to indeed have 2 mightnights. I did some quick and dirty test and I have got a slightly different list for timezones in my JVM:\nAmerica/Asuncion 2020-03-22T00:00 -> 2020-03-21T23:00\nAmerica/Havana 2020-11-01T01:00 -> 2020-11-01T00:00\nAmerica/Santiago 2020-04-05T00:00 -> 2020-04-04T23:00\nAmerica/Scoresbysund 2020-10-25T01:00 -> 2020-10-25T00:00\nAsia/Amman 2020-10-30T01:00 -> 2020-10-30T00:00\nAsia/Beirut 2020-10-25T00:00 -> 2020-10-24T23:00\nAsia/Damascus 2020-10-30T00:00 -> 2020-10-29T23:00\nAsia/Gaza 2020-10-31T01:00 -> 2020-10-31T00:00\nAsia/Hebron 2020-10-31T01:00 -> 2020-10-31T00:00\nAsia/Tehran 2020-09-21T00:00 -> 2020-09-20T23:00\nAtlantic/Azores 2020-10-25T01:00 -> 2020-10-25T00:00\nChile/Continental 2020-04-05T00:00 -> 2020-04-04T23:00\nCuba 2020-11-01T01:00 -> 2020-11-01T00:00\nIran 2020-09-21T00:00 -> 2020-09-20T23:00", "url": "https://github.com/elastic/elasticsearch/pull/61467#discussion_r477579791", "createdAt": "2020-08-26T20:47:35Z", "author": {"login": "imotov"}, "path": "server/src/main/java/org/elasticsearch/common/Rounding.java", "diffHunk": "@@ -401,8 +404,22 @@ private LocalDateTime truncateLocalDateTime(LocalDateTime localDateTime) {\n             }\n         }\n \n+        /**\n+         * Time zones with two midnights get \"funny\" non-continuous rounding\n+         * that isn't compatible with the pre-computed array rounding.\n+         */\n+        private static final Set<String> HAS_TWO_MIDNIGHTS = Set.of(\"America/Moncton\", \"America/St_Johns\", \"Canada/Newfoundland\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU5ODE0MA=="}, "originalCommit": {"oid": "7687e30291243995cffeb7d633a93bf798c29f57"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU4MjkwNA==", "bodyText": "Very nice!", "url": "https://github.com/elastic/elasticsearch/pull/61467#discussion_r477582904", "createdAt": "2020-08-26T20:54:02Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/common/Rounding.java", "diffHunk": "@@ -401,8 +404,22 @@ private LocalDateTime truncateLocalDateTime(LocalDateTime localDateTime) {\n             }\n         }\n \n+        /**\n+         * Time zones with two midnights get \"funny\" non-continuous rounding\n+         * that isn't compatible with the pre-computed array rounding.\n+         */\n+        private static final Set<String> HAS_TWO_MIDNIGHTS = Set.of(\"America/Moncton\", \"America/St_Johns\", \"Canada/Newfoundland\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU5ODE0MA=="}, "originalCommit": {"oid": "7687e30291243995cffeb7d633a93bf798c29f57"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzYwMDk5Mw==", "bodyText": "Is this really only a problem when there are two midnights, or is it a more general problem when the time goes back due to daylight savings, and you just need special values of offset to make the bug occur if the transition is not around midnight?", "url": "https://github.com/elastic/elasticsearch/pull/61467#discussion_r477600993", "createdAt": "2020-08-26T21:30:30Z", "author": {"login": "jpountz"}, "path": "server/src/main/java/org/elasticsearch/common/Rounding.java", "diffHunk": "@@ -401,8 +404,22 @@ private LocalDateTime truncateLocalDateTime(LocalDateTime localDateTime) {\n             }\n         }\n \n+        /**\n+         * Time zones with two midnights get \"funny\" non-continuous rounding\n+         * that isn't compatible with the pre-computed array rounding.\n+         */\n+        private static final Set<String> HAS_TWO_MIDNIGHTS = Set.of(\"America/Moncton\", \"America/St_Johns\", \"Canada/Newfoundland\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU5ODE0MA=="}, "originalCommit": {"oid": "7687e30291243995cffeb7d633a93bf798c29f57"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzY2NDgyOA==", "bodyText": "@nik9000 please correct me if I am wrong, but the way I understand it, it is the way we truncate it to midnight that is causing the issues, I played with it a bit more and it looks like atStartOfDay will truncate 2020-03-22T00:00 to 22nd, but it will truncate the moment after it to 21st, which can cause all sorts of issues. For example:\n        // America/Asuncion 2020-03-22T00:00 -> 2020-03-21T23:00\n        TimeZone tz = TimeZone.getTimeZone(\"America/Asuncion\");\n        ZoneRules rules = tz.toZoneId().getRules();\n        ZoneOffsetTransitionRule fallback = rules.getTransitionRules().get(0);\n        ZoneOffsetTransition transition = fallback.createTransition(2020);\n        System.out.println(\"Before: \" + transition.getDateTimeBefore().toLocalDate().atStartOfDay());\n        System.out.println(\"After:  \" + transition.getDateTimeAfter().toLocalDate().atStartOfDay());\n\nwill give us\nBefore: 2020-03-22T00:00\nAfter:  2020-03-21T00:00\n\nThe same thing for America/New_York will return\nBefore: 2020-03-08T00:00\nAfter:  2020-03-08T00:00", "url": "https://github.com/elastic/elasticsearch/pull/61467#discussion_r477664828", "createdAt": "2020-08-26T23:22:19Z", "author": {"login": "imotov"}, "path": "server/src/main/java/org/elasticsearch/common/Rounding.java", "diffHunk": "@@ -401,8 +404,22 @@ private LocalDateTime truncateLocalDateTime(LocalDateTime localDateTime) {\n             }\n         }\n \n+        /**\n+         * Time zones with two midnights get \"funny\" non-continuous rounding\n+         * that isn't compatible with the pre-computed array rounding.\n+         */\n+        private static final Set<String> HAS_TWO_MIDNIGHTS = Set.of(\"America/Moncton\", \"America/St_Johns\", \"Canada/Newfoundland\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU5ODE0MA=="}, "originalCommit": {"oid": "7687e30291243995cffeb7d633a93bf798c29f57"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzY4NzY4OQ==", "bodyText": "the way I understand it, it is the way we truncate it to midnight that is causing the issues, I played with it a bit more and it looks like atStartOfDay will truncate 2020-03-22T00:00 to 22nd, but it will truncate the moment after it to 21st, which can cause all sorts of issues.\n\nThis is pretty much what I saw, yes. In the one time zone I dug into deeply I saw a single instant gets rounded a day ahead of all of the instants around it. Its weird but it is what we have. If we didn't do that then we could use the array based rounding everywhere.\nI'll dig more tomorrow into your examples. The ones I found I did by randomized testing and the one that I dug into deeply was a problem with having two midnights. I should be able to answer much more precisely what the problem is when I have a closer look.\n\nIs this really only a problem when there are two midnights, or is it a more general problem when the time goes back due to daylight savings, and you just need special values of offset to make the bug occur if the transition is not around midnight?\n\noffset is pretty much incompatible with daylight savings time. At least, it doesn't work as advertised. See #56305 for some investigation.", "url": "https://github.com/elastic/elasticsearch/pull/61467#discussion_r477687689", "createdAt": "2020-08-26T23:39:05Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/common/Rounding.java", "diffHunk": "@@ -401,8 +404,22 @@ private LocalDateTime truncateLocalDateTime(LocalDateTime localDateTime) {\n             }\n         }\n \n+        /**\n+         * Time zones with two midnights get \"funny\" non-continuous rounding\n+         * that isn't compatible with the pre-computed array rounding.\n+         */\n+        private static final Set<String> HAS_TWO_MIDNIGHTS = Set.of(\"America/Moncton\", \"America/St_Johns\", \"Canada/Newfoundland\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU5ODE0MA=="}, "originalCommit": {"oid": "7687e30291243995cffeb7d633a93bf798c29f57"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY2NzI5NQ==", "bodyText": "Ok! I think it isn't that they have two midnights, it is that transitioned a minute after midnight:\nTransition[Gap at 2006-04-02T00:01-03:30 to -02:30]\n\nThis causes rounding to output:\n1162088880000  1162002600000\n1162088940000  1162002600000\n1162089000000  1162089000000   <---- This minute is in \"tomorrow\"\n1162089060000  1162002600000   <----- But this minute is in \"yesterday\"!\n1162089120000  1162002600000\n1162089180000  1162002600000\n1162089240000  1162002600000\n1162089300000  1162002600000\n\nIt is this kind of \"forwards and backwards\" dance that my simple array based rounding can't handle. I'll see if I can detect it.", "url": "https://github.com/elastic/elasticsearch/pull/61467#discussion_r478667295", "createdAt": "2020-08-27T20:09:31Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/common/Rounding.java", "diffHunk": "@@ -401,8 +404,22 @@ private LocalDateTime truncateLocalDateTime(LocalDateTime localDateTime) {\n             }\n         }\n \n+        /**\n+         * Time zones with two midnights get \"funny\" non-continuous rounding\n+         * that isn't compatible with the pre-computed array rounding.\n+         */\n+        private static final Set<String> HAS_TWO_MIDNIGHTS = Set.of(\"America/Moncton\", \"America/St_Johns\", \"Canada/Newfoundland\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU5ODE0MA=="}, "originalCommit": {"oid": "7687e30291243995cffeb7d633a93bf798c29f57"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY4OTU0MA==", "bodyText": "Even if offsets are not working as advertised with DST, I worry that they would behave differently again with this optimization. It would be safer to disable this optimization whenever there are transitions that make the time go backwards in the local time in the time range of the index?", "url": "https://github.com/elastic/elasticsearch/pull/61467#discussion_r478689540", "createdAt": "2020-08-27T20:54:00Z", "author": {"login": "jpountz"}, "path": "server/src/main/java/org/elasticsearch/common/Rounding.java", "diffHunk": "@@ -401,8 +404,22 @@ private LocalDateTime truncateLocalDateTime(LocalDateTime localDateTime) {\n             }\n         }\n \n+        /**\n+         * Time zones with two midnights get \"funny\" non-continuous rounding\n+         * that isn't compatible with the pre-computed array rounding.\n+         */\n+        private static final Set<String> HAS_TWO_MIDNIGHTS = Set.of(\"America/Moncton\", \"America/St_Johns\", \"Canada/Newfoundland\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU5ODE0MA=="}, "originalCommit": {"oid": "7687e30291243995cffeb7d633a93bf798c29f57"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDE4MjUzOA==", "bodyText": "I've pushed a change that disables the optimization if the range falls in one of the times when DST drags you back to \"yesterday\". And I've pushed a test that checks those times.\nAs it stands now, I don't think the offset feature of date rounding will effect this optimization.", "url": "https://github.com/elastic/elasticsearch/pull/61467#discussion_r480182538", "createdAt": "2020-08-31T14:49:59Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/common/Rounding.java", "diffHunk": "@@ -401,8 +404,22 @@ private LocalDateTime truncateLocalDateTime(LocalDateTime localDateTime) {\n             }\n         }\n \n+        /**\n+         * Time zones with two midnights get \"funny\" non-continuous rounding\n+         * that isn't compatible with the pre-computed array rounding.\n+         */\n+        private static final Set<String> HAS_TWO_MIDNIGHTS = Set.of(\"America/Moncton\", \"America/St_Johns\", \"Canada/Newfoundland\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU5ODE0MA=="}, "originalCommit": {"oid": "7687e30291243995cffeb7d633a93bf798c29f57"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA2MTE5Ng==", "bodyText": "I've played with offset to double check and can't cause issues with it. However do you think we could detect timezones that don't work dynamically instead of relying on a static list? E.g. could we iterate transitions in the considered interval and check whether there's one that brings us to a different day?", "url": "https://github.com/elastic/elasticsearch/pull/61467#discussion_r483061196", "createdAt": "2020-09-03T15:21:08Z", "author": {"login": "jpountz"}, "path": "server/src/main/java/org/elasticsearch/common/Rounding.java", "diffHunk": "@@ -401,8 +404,22 @@ private LocalDateTime truncateLocalDateTime(LocalDateTime localDateTime) {\n             }\n         }\n \n+        /**\n+         * Time zones with two midnights get \"funny\" non-continuous rounding\n+         * that isn't compatible with the pre-computed array rounding.\n+         */\n+        private static final Set<String> HAS_TWO_MIDNIGHTS = Set.of(\"America/Moncton\", \"America/St_Johns\", \"Canada/Newfoundland\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU5ODE0MA=="}, "originalCommit": {"oid": "7687e30291243995cffeb7d633a93bf798c29f57"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA3MjMzNw==", "bodyText": "We could use something like the test case uses to find candidates, but it'd require loading all of the time zone rules on startup. I'm hoping that the test can prevent us from having to do that by being very careful about this list.", "url": "https://github.com/elastic/elasticsearch/pull/61467#discussion_r483072337", "createdAt": "2020-09-03T15:36:41Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/common/Rounding.java", "diffHunk": "@@ -401,8 +404,22 @@ private LocalDateTime truncateLocalDateTime(LocalDateTime localDateTime) {\n             }\n         }\n \n+        /**\n+         * Time zones with two midnights get \"funny\" non-continuous rounding\n+         * that isn't compatible with the pre-computed array rounding.\n+         */\n+        private static final Set<String> HAS_TWO_MIDNIGHTS = Set.of(\"America/Moncton\", \"America/St_Johns\", \"Canada/Newfoundland\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU5ODE0MA=="}, "originalCommit": {"oid": "7687e30291243995cffeb7d633a93bf798c29f57"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk0ODYwMg==", "bodyText": "Actually I wasn't thinking about testing all timezones up-front on startup, I was more thinking of doing the test when building the Rounding object by only looking at transitions of the considered timezone.", "url": "https://github.com/elastic/elasticsearch/pull/61467#discussion_r487948602", "createdAt": "2020-09-14T14:03:34Z", "author": {"login": "jpountz"}, "path": "server/src/main/java/org/elasticsearch/common/Rounding.java", "diffHunk": "@@ -401,8 +404,22 @@ private LocalDateTime truncateLocalDateTime(LocalDateTime localDateTime) {\n             }\n         }\n \n+        /**\n+         * Time zones with two midnights get \"funny\" non-continuous rounding\n+         * that isn't compatible with the pre-computed array rounding.\n+         */\n+        private static final Set<String> HAS_TWO_MIDNIGHTS = Set.of(\"America/Moncton\", \"America/St_Johns\", \"Canada/Newfoundland\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU5ODE0MA=="}, "originalCommit": {"oid": "7687e30291243995cffeb7d633a93bf798c29f57"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk1MzEyNA==", "bodyText": "Hmmmm - the assert that I have below sort of asserts that. But it isn't nearly as strong. I'll think about it!", "url": "https://github.com/elastic/elasticsearch/pull/61467#discussion_r487953124", "createdAt": "2020-09-14T14:07:14Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/common/Rounding.java", "diffHunk": "@@ -401,8 +404,22 @@ private LocalDateTime truncateLocalDateTime(LocalDateTime localDateTime) {\n             }\n         }\n \n+        /**\n+         * Time zones with two midnights get \"funny\" non-continuous rounding\n+         * that isn't compatible with the pre-computed array rounding.\n+         */\n+        private static final Set<String> HAS_TWO_MIDNIGHTS = Set.of(\"America/Moncton\", \"America/St_Johns\", \"Canada/Newfoundland\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU5ODE0MA=="}, "originalCommit": {"oid": "7687e30291243995cffeb7d633a93bf798c29f57"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEyMjg3NA==", "bodyText": "@jpountz I've pushed a change that does this.", "url": "https://github.com/elastic/elasticsearch/pull/61467#discussion_r488122874", "createdAt": "2020-09-14T18:02:55Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/common/Rounding.java", "diffHunk": "@@ -401,8 +404,22 @@ private LocalDateTime truncateLocalDateTime(LocalDateTime localDateTime) {\n             }\n         }\n \n+        /**\n+         * Time zones with two midnights get \"funny\" non-continuous rounding\n+         * that isn't compatible with the pre-computed array rounding.\n+         */\n+        private static final Set<String> HAS_TWO_MIDNIGHTS = Set.of(\"America/Moncton\", \"America/St_Johns\", \"Canada/Newfoundland\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU5ODE0MA=="}, "originalCommit": {"oid": "7687e30291243995cffeb7d633a93bf798c29f57"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MzM5NTA5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/common/Rounding.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMzoyODoxN1rOHFkQeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNDoyMjozMlrOHFnVJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU5ODk2OQ==", "bodyText": "is this change fixing an existing bug?", "url": "https://github.com/elastic/elasticsearch/pull/61467#discussion_r475598969", "createdAt": "2020-08-24T13:28:17Z", "author": {"login": "jpountz"}, "path": "server/src/main/java/org/elasticsearch/common/Rounding.java", "diffHunk": "@@ -1015,7 +1031,7 @@ public byte id() {\n \n         @Override\n         public Prepared prepare(long minUtcMillis, long maxUtcMillis) {\n-            return wrapPreparedRounding(delegate.prepare(minUtcMillis, maxUtcMillis));\n+            return wrapPreparedRounding(delegate.prepare(minUtcMillis - offset, maxUtcMillis - offset));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7687e30291243995cffeb7d633a93bf798c29f57"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTYwMTk2Nw==", "bodyText": "Yes, but I think the bug is worse with this change.", "url": "https://github.com/elastic/elasticsearch/pull/61467#discussion_r475601967", "createdAt": "2020-08-24T13:32:52Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/common/Rounding.java", "diffHunk": "@@ -1015,7 +1031,7 @@ public byte id() {\n \n         @Override\n         public Prepared prepare(long minUtcMillis, long maxUtcMillis) {\n-            return wrapPreparedRounding(delegate.prepare(minUtcMillis, maxUtcMillis));\n+            return wrapPreparedRounding(delegate.prepare(minUtcMillis - offset, maxUtcMillis - offset));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU5ODk2OQ=="}, "originalCommit": {"oid": "7687e30291243995cffeb7d633a93bf798c29f57"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTY0OTMxOA==", "bodyText": "The new assertions in the ArrayRounding fail without this.", "url": "https://github.com/elastic/elasticsearch/pull/61467#discussion_r475649318", "createdAt": "2020-08-24T14:22:32Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/common/Rounding.java", "diffHunk": "@@ -1015,7 +1031,7 @@ public byte id() {\n \n         @Override\n         public Prepared prepare(long minUtcMillis, long maxUtcMillis) {\n-            return wrapPreparedRounding(delegate.prepare(minUtcMillis, maxUtcMillis));\n+            return wrapPreparedRounding(delegate.prepare(minUtcMillis - offset, maxUtcMillis - offset));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU5ODk2OQ=="}, "originalCommit": {"oid": "7687e30291243995cffeb7d633a93bf798c29f57"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MzQwMjMyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/common/Rounding.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMzoyOTo1NVrOHFkUtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMzozMzozNlrOHFkd9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTYwMDA1Mw==", "bodyText": "make it final?", "url": "https://github.com/elastic/elasticsearch/pull/61467#discussion_r475600053", "createdAt": "2020-08-24T13:29:55Z", "author": {"login": "jpountz"}, "path": "server/src/main/java/org/elasticsearch/common/Rounding.java", "diffHunk": "@@ -1085,4 +1101,54 @@ public static Rounding read(StreamInput in) throws IOException {\n                 throw new ElasticsearchException(\"unknown rounding id [\" + id + \"]\");\n         }\n     }\n+\n+    /**\n+     * Attempt to build a {@link Prepared} implementation that relies on pre-calcuated\n+     * \"round down\" points. If there would be more than {@code max} points then return\n+     * the original implementation, otherwise return the new, faster implementation.\n+     */\n+    static Prepared maybeUseArray(Prepared orig, long minUtcMillis, long maxUtcMillis, int max) {\n+        long[] values = new long[1];\n+        long rounded = orig.round(minUtcMillis);\n+        int i = 0;\n+        values[i++] = rounded;\n+        while ((rounded = orig.nextRoundingValue(rounded)) <= maxUtcMillis) {\n+            if (i >= max) {\n+                return orig;\n+            }\n+            assert values[i - 1] == orig.round(rounded - 1);\n+            values = ArrayUtil.grow(values, i + 1);\n+            values[i++]= rounded;\n+        }\n+        return new ArrayRounding(values, i, orig);\n+    }\n+\n+    /**\n+     * Implementation of {@link Prepared} using pre-calculated \"round down\" points.\n+     */\n+    private static class ArrayRounding implements Prepared {\n+        private final long[] values;\n+        private int max;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7687e30291243995cffeb7d633a93bf798c29f57"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTYwMjQyMQ==", "bodyText": "\ud83d\udc4d. I have no idea why I didn't do that the first time around.", "url": "https://github.com/elastic/elasticsearch/pull/61467#discussion_r475602421", "createdAt": "2020-08-24T13:33:36Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/common/Rounding.java", "diffHunk": "@@ -1085,4 +1101,54 @@ public static Rounding read(StreamInput in) throws IOException {\n                 throw new ElasticsearchException(\"unknown rounding id [\" + id + \"]\");\n         }\n     }\n+\n+    /**\n+     * Attempt to build a {@link Prepared} implementation that relies on pre-calcuated\n+     * \"round down\" points. If there would be more than {@code max} points then return\n+     * the original implementation, otherwise return the new, faster implementation.\n+     */\n+    static Prepared maybeUseArray(Prepared orig, long minUtcMillis, long maxUtcMillis, int max) {\n+        long[] values = new long[1];\n+        long rounded = orig.round(minUtcMillis);\n+        int i = 0;\n+        values[i++] = rounded;\n+        while ((rounded = orig.nextRoundingValue(rounded)) <= maxUtcMillis) {\n+            if (i >= max) {\n+                return orig;\n+            }\n+            assert values[i - 1] == orig.round(rounded - 1);\n+            values = ArrayUtil.grow(values, i + 1);\n+            values[i++]= rounded;\n+        }\n+        return new ArrayRounding(values, i, orig);\n+    }\n+\n+    /**\n+     * Implementation of {@link Prepared} using pre-calculated \"round down\" points.\n+     */\n+    private static class ArrayRounding implements Prepared {\n+        private final long[] values;\n+        private int max;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTYwMDA1Mw=="}, "originalCommit": {"oid": "7687e30291243995cffeb7d633a93bf798c29f57"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MzQwMzE5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/common/Rounding.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMzozMDoxMVrOHFkVTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMzozNzoyNVrOHFkqYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTYwMDIwNQ==", "bodyText": "maybe assert that idx is neither -1 nor -1 - max?", "url": "https://github.com/elastic/elasticsearch/pull/61467#discussion_r475600205", "createdAt": "2020-08-24T13:30:11Z", "author": {"login": "jpountz"}, "path": "server/src/main/java/org/elasticsearch/common/Rounding.java", "diffHunk": "@@ -1085,4 +1101,54 @@ public static Rounding read(StreamInput in) throws IOException {\n                 throw new ElasticsearchException(\"unknown rounding id [\" + id + \"]\");\n         }\n     }\n+\n+    /**\n+     * Attempt to build a {@link Prepared} implementation that relies on pre-calcuated\n+     * \"round down\" points. If there would be more than {@code max} points then return\n+     * the original implementation, otherwise return the new, faster implementation.\n+     */\n+    static Prepared maybeUseArray(Prepared orig, long minUtcMillis, long maxUtcMillis, int max) {\n+        long[] values = new long[1];\n+        long rounded = orig.round(minUtcMillis);\n+        int i = 0;\n+        values[i++] = rounded;\n+        while ((rounded = orig.nextRoundingValue(rounded)) <= maxUtcMillis) {\n+            if (i >= max) {\n+                return orig;\n+            }\n+            assert values[i - 1] == orig.round(rounded - 1);\n+            values = ArrayUtil.grow(values, i + 1);\n+            values[i++]= rounded;\n+        }\n+        return new ArrayRounding(values, i, orig);\n+    }\n+\n+    /**\n+     * Implementation of {@link Prepared} using pre-calculated \"round down\" points.\n+     */\n+    private static class ArrayRounding implements Prepared {\n+        private final long[] values;\n+        private int max;\n+        private final Prepared delegate;\n+\n+        private ArrayRounding(long[] values, int max, Prepared delegate) {\n+            this.values = values;\n+            this.max = max;\n+            this.delegate = delegate;\n+        }\n+\n+        @Override\n+        public long round(long utcMillis) {\n+            int idx = Arrays.binarySearch(values, 0, max, utcMillis);\n+            if (idx < 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7687e30291243995cffeb7d633a93bf798c29f57"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTYwNTYwMg==", "bodyText": "Sure!", "url": "https://github.com/elastic/elasticsearch/pull/61467#discussion_r475605602", "createdAt": "2020-08-24T13:37:25Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/common/Rounding.java", "diffHunk": "@@ -1085,4 +1101,54 @@ public static Rounding read(StreamInput in) throws IOException {\n                 throw new ElasticsearchException(\"unknown rounding id [\" + id + \"]\");\n         }\n     }\n+\n+    /**\n+     * Attempt to build a {@link Prepared} implementation that relies on pre-calcuated\n+     * \"round down\" points. If there would be more than {@code max} points then return\n+     * the original implementation, otherwise return the new, faster implementation.\n+     */\n+    static Prepared maybeUseArray(Prepared orig, long minUtcMillis, long maxUtcMillis, int max) {\n+        long[] values = new long[1];\n+        long rounded = orig.round(minUtcMillis);\n+        int i = 0;\n+        values[i++] = rounded;\n+        while ((rounded = orig.nextRoundingValue(rounded)) <= maxUtcMillis) {\n+            if (i >= max) {\n+                return orig;\n+            }\n+            assert values[i - 1] == orig.round(rounded - 1);\n+            values = ArrayUtil.grow(values, i + 1);\n+            values[i++]= rounded;\n+        }\n+        return new ArrayRounding(values, i, orig);\n+    }\n+\n+    /**\n+     * Implementation of {@link Prepared} using pre-calculated \"round down\" points.\n+     */\n+    private static class ArrayRounding implements Prepared {\n+        private final long[] values;\n+        private int max;\n+        private final Prepared delegate;\n+\n+        private ArrayRounding(long[] values, int max, Prepared delegate) {\n+            this.values = values;\n+            this.max = max;\n+            this.delegate = delegate;\n+        }\n+\n+        @Override\n+        public long round(long utcMillis) {\n+            int idx = Arrays.binarySearch(values, 0, max, utcMillis);\n+            if (idx < 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTYwMDIwNQ=="}, "originalCommit": {"oid": "7687e30291243995cffeb7d633a93bf798c29f57"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4NTc0ODMzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/common/Rounding.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQyMDo1MDowM1rOHHdOtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQyMDo1MDowM1rOHHdOtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU4MDk4Mg==", "bodyText": "This will need to implement new methods added in #61369.", "url": "https://github.com/elastic/elasticsearch/pull/61467#discussion_r477580982", "createdAt": "2020-08-26T20:50:03Z", "author": {"login": "imotov"}, "path": "server/src/main/java/org/elasticsearch/common/Rounding.java", "diffHunk": "@@ -1085,4 +1101,57 @@ public static Rounding read(StreamInput in) throws IOException {\n                 throw new ElasticsearchException(\"unknown rounding id [\" + id + \"]\");\n         }\n     }\n+\n+    /**\n+     * Attempt to build a {@link Prepared} implementation that relies on pre-calcuated\n+     * \"round down\" points. If there would be more than {@code max} points then return\n+     * the original implementation, otherwise return the new, faster implementation.\n+     */\n+    static Prepared maybeUseArray(Prepared orig, long minUtcMillis, long maxUtcMillis, int max) {\n+        long[] values = new long[1];\n+        long rounded = orig.round(minUtcMillis);\n+        int i = 0;\n+        values[i++] = rounded;\n+        while ((rounded = orig.nextRoundingValue(rounded)) <= maxUtcMillis) {\n+            if (i >= max) {\n+                return orig;\n+            }\n+            assert values[i - 1] == orig.round(rounded - 1);\n+            values = ArrayUtil.grow(values, i + 1);\n+            values[i++]= rounded;\n+        }\n+        return new ArrayRounding(values, i, orig);\n+    }\n+\n+    /**\n+     * Implementation of {@link Prepared} using pre-calculated \"round down\" points.\n+     */\n+    private static class ArrayRounding implements Prepared {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c13740b5d975d2e19a1521f4fdd6d9de754ee9d1"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNTEyNzQxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/common/Rounding.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNjo1NToyN1rOHL4Zfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMzoyMjozOVrOHRThIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjIyMDQxNA==", "bodyText": "Nit - It looks like this maps timezone name to milliseconds since epoch for when the zone changed to use a different transition time.  Can you just add a comment clarifying that's how the map is structured?  It seems unlikely we'd need to add to it, but just in case we do, it'd help to have a reference for how to do so handy.", "url": "https://github.com/elastic/elasticsearch/pull/61467#discussion_r482220414", "createdAt": "2020-09-02T16:55:27Z", "author": {"login": "not-napoleon"}, "path": "server/src/main/java/org/elasticsearch/common/Rounding.java", "diffHunk": "@@ -467,8 +470,33 @@ private LocalDateTime truncateLocalDateTime(LocalDateTime localDateTime) {\n             }\n         }\n \n+        /**\n+         * Time zones have a daylight savings time transition after midnight that\n+         * transitions back before midnight break the array-based rounding so\n+         * we don't use it for them during those transitions. Luckily they are\n+         * fairly rare and a while in the past. Note: we can use the array based\n+         * rounding if the transition is <strong>at</strong> midnight. Just not\n+         * if it is <strong>after</strong> it.\n+         */\n+        private static final Map<String, Long> FORWARDS_BACKWRADS_ZONES = Map.ofEntries(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a7ef49a6b0a65dcb8f86996401f5885883be745"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwNzYxOA==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/elastic/elasticsearch/pull/61467#discussion_r487907618", "createdAt": "2020-09-14T13:22:39Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/common/Rounding.java", "diffHunk": "@@ -467,8 +470,33 @@ private LocalDateTime truncateLocalDateTime(LocalDateTime localDateTime) {\n             }\n         }\n \n+        /**\n+         * Time zones have a daylight savings time transition after midnight that\n+         * transitions back before midnight break the array-based rounding so\n+         * we don't use it for them during those transitions. Luckily they are\n+         * fairly rare and a while in the past. Note: we can use the array based\n+         * rounding if the transition is <strong>at</strong> midnight. Just not\n+         * if it is <strong>after</strong> it.\n+         */\n+        private static final Map<String, Long> FORWARDS_BACKWRADS_ZONES = Map.ofEntries(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjIyMDQxNA=="}, "originalCommit": {"oid": "7a7ef49a6b0a65dcb8f86996401f5885883be745"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNTI1OTgwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/common/Rounding.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNzoyNjoyMFrOHL5woQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMzoyMjo0NFrOHRThWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI0MjcyMQ==", "bodyText": "It's not super clear to me what this assert is guarding against.  Can you add a comment please?", "url": "https://github.com/elastic/elasticsearch/pull/61467#discussion_r482242721", "createdAt": "2020-09-02T17:26:20Z", "author": {"login": "not-napoleon"}, "path": "server/src/main/java/org/elasticsearch/common/Rounding.java", "diffHunk": "@@ -1186,4 +1213,62 @@ public static Rounding read(StreamInput in) throws IOException {\n                 throw new ElasticsearchException(\"unknown rounding id [\" + id + \"]\");\n         }\n     }\n+\n+    /**\n+     * Attempt to build a {@link Prepared} implementation that relies on pre-calcuated\n+     * \"round down\" points. If there would be more than {@code max} points then return\n+     * the original implementation, otherwise return the new, faster implementation.\n+     */\n+    static Prepared maybeUseArray(Prepared orig, long minUtcMillis, long maxUtcMillis, int max) {\n+        long[] values = new long[1];\n+        long rounded = orig.round(minUtcMillis);\n+        int i = 0;\n+        values[i++] = rounded;\n+        while ((rounded = orig.nextRoundingValue(rounded)) <= maxUtcMillis) {\n+            if (i >= max) {\n+                return orig;\n+            }\n+            assert values[i - 1] == orig.round(rounded - 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a7ef49a6b0a65dcb8f86996401f5885883be745"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwNzY3Mg==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/elastic/elasticsearch/pull/61467#discussion_r487907672", "createdAt": "2020-09-14T13:22:44Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/common/Rounding.java", "diffHunk": "@@ -1186,4 +1213,62 @@ public static Rounding read(StreamInput in) throws IOException {\n                 throw new ElasticsearchException(\"unknown rounding id [\" + id + \"]\");\n         }\n     }\n+\n+    /**\n+     * Attempt to build a {@link Prepared} implementation that relies on pre-calcuated\n+     * \"round down\" points. If there would be more than {@code max} points then return\n+     * the original implementation, otherwise return the new, faster implementation.\n+     */\n+    static Prepared maybeUseArray(Prepared orig, long minUtcMillis, long maxUtcMillis, int max) {\n+        long[] values = new long[1];\n+        long rounded = orig.round(minUtcMillis);\n+        int i = 0;\n+        values[i++] = rounded;\n+        while ((rounded = orig.nextRoundingValue(rounded)) <= maxUtcMillis) {\n+            if (i >= max) {\n+                return orig;\n+            }\n+            assert values[i - 1] == orig.round(rounded - 1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI0MjcyMQ=="}, "originalCommit": {"oid": "7a7ef49a6b0a65dcb8f86996401f5885883be745"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1ODU1NTI4OnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/elasticsearch/common/LocalTimeOffsetTests.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxNzowNTowOFrOHSLdrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQyMDoyODo0MFrOHSTXEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODgyNDIzNw==", "bodyText": "This test fails in CI but not for me locally! I'm looking into it. Might be the specific JVM or something.", "url": "https://github.com/elastic/elasticsearch/pull/61467#discussion_r488824237", "createdAt": "2020-09-15T17:05:08Z", "author": {"login": "nik9000"}, "path": "server/src/test/java/org/elasticsearch/common/LocalTimeOffsetTests.java", "diffHunk": "@@ -241,6 +246,25 @@ public void testGap() {\n         assertThat(gapOffset.localToUtc(localSkippedTime, useValueForGap(gapValue)), equalTo(gapValue));\n     }\n \n+    public void testKnownMovesBackToPreviousDay() {\n+        assertKnownMovesBacktoPreviousDay(\"America/Goose_Bay\", \"2010-11-07T03:01:00\");\n+        assertKnownMovesBacktoPreviousDay(\"America/Moncton\", \"2006-10-29T03:01:00\");\n+        assertKnownMovesBacktoPreviousDay(\"America/Moncton\", \"2005-10-29T03:01:00\");\n+        assertKnownMovesBacktoPreviousDay(\"America/St_Johns\", \"2010-11-07T02:31:00\");\n+        assertKnownMovesBacktoPreviousDay(\"Canada/Newfoundland\", \"2010-11-07T02:31:00\");\n+        assertKnownMovesBacktoPreviousDay(\"Pacific/Guam\", \"1969-01-25T13:01:00\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35ef1c4e6f8757dcde5f47ba19678d9a9cd9a493"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODg3OTI2OA==", "bodyText": "As far as I understand this list constantly changes, so it might be different between versions of JVM and OSes.", "url": "https://github.com/elastic/elasticsearch/pull/61467#discussion_r488879268", "createdAt": "2020-09-15T18:32:45Z", "author": {"login": "imotov"}, "path": "server/src/test/java/org/elasticsearch/common/LocalTimeOffsetTests.java", "diffHunk": "@@ -241,6 +246,25 @@ public void testGap() {\n         assertThat(gapOffset.localToUtc(localSkippedTime, useValueForGap(gapValue)), equalTo(gapValue));\n     }\n \n+    public void testKnownMovesBackToPreviousDay() {\n+        assertKnownMovesBacktoPreviousDay(\"America/Goose_Bay\", \"2010-11-07T03:01:00\");\n+        assertKnownMovesBacktoPreviousDay(\"America/Moncton\", \"2006-10-29T03:01:00\");\n+        assertKnownMovesBacktoPreviousDay(\"America/Moncton\", \"2005-10-29T03:01:00\");\n+        assertKnownMovesBacktoPreviousDay(\"America/St_Johns\", \"2010-11-07T02:31:00\");\n+        assertKnownMovesBacktoPreviousDay(\"Canada/Newfoundland\", \"2010-11-07T02:31:00\");\n+        assertKnownMovesBacktoPreviousDay(\"Pacific/Guam\", \"1969-01-25T13:01:00\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODgyNDIzNw=="}, "originalCommit": {"oid": "35ef1c4e6f8757dcde5f47ba19678d9a9cd9a493"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk1MzYxOA==", "bodyText": "I had sort of thought the past was relatively well established, but it looks like it is a Java 12+ thing....", "url": "https://github.com/elastic/elasticsearch/pull/61467#discussion_r488953618", "createdAt": "2020-09-15T20:28:40Z", "author": {"login": "nik9000"}, "path": "server/src/test/java/org/elasticsearch/common/LocalTimeOffsetTests.java", "diffHunk": "@@ -241,6 +246,25 @@ public void testGap() {\n         assertThat(gapOffset.localToUtc(localSkippedTime, useValueForGap(gapValue)), equalTo(gapValue));\n     }\n \n+    public void testKnownMovesBackToPreviousDay() {\n+        assertKnownMovesBacktoPreviousDay(\"America/Goose_Bay\", \"2010-11-07T03:01:00\");\n+        assertKnownMovesBacktoPreviousDay(\"America/Moncton\", \"2006-10-29T03:01:00\");\n+        assertKnownMovesBacktoPreviousDay(\"America/Moncton\", \"2005-10-29T03:01:00\");\n+        assertKnownMovesBacktoPreviousDay(\"America/St_Johns\", \"2010-11-07T02:31:00\");\n+        assertKnownMovesBacktoPreviousDay(\"Canada/Newfoundland\", \"2010-11-07T02:31:00\");\n+        assertKnownMovesBacktoPreviousDay(\"Pacific/Guam\", \"1969-01-25T13:01:00\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODgyNDIzNw=="}, "originalCommit": {"oid": "35ef1c4e6f8757dcde5f47ba19678d9a9cd9a493"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5MDc4MDY2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/common/LocalTimeOffset.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxOTo1NToxNFrOHW-rCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxMjo0Mjo1MlrOHXYyEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg1NzU0NA==", "bodyText": "should we check getHour() too for safety? Eg. if such a thing existed as moving from 1AM to 11PM the day before it looks like we'd still consider that the transition doesn't move back to the previous day with this code?", "url": "https://github.com/elastic/elasticsearch/pull/61467#discussion_r493857544", "createdAt": "2020-09-23T19:55:14Z", "author": {"login": "jpountz"}, "path": "server/src/main/java/org/elasticsearch/common/LocalTimeOffset.java", "diffHunk": "@@ -505,7 +558,25 @@ protected static Transition buildTransition(ZoneOffsetTransition transition, Loc\n             }\n             long firstOverlappingLocalTime = utcStart + offsetAfterMillis;\n             long firstNonOverlappingLocalTime = utcStart + offsetBeforeMillis;\n-            return new Overlap(offsetAfterMillis, previous, utcStart, firstOverlappingLocalTime, firstNonOverlappingLocalTime);\n+            return new Overlap(\n+                offsetAfterMillis,\n+                previous,\n+                utcStart,\n+                firstOverlappingLocalTime,\n+                firstNonOverlappingLocalTime,\n+                movesBackToPreviousDay(transition)\n+            );\n+        }\n+\n+        private static boolean movesBackToPreviousDay(ZoneOffsetTransition transition) {\n+            if (transition.getDateTimeBefore().getDayOfMonth() == transition.getDateTimeAfter().getDayOfMonth()) {\n+                return false;\n+            }\n+            if (transition.getDateTimeBefore().getMinute() == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1e286ebba0ce02bb37d3ee4ef8696852e6aec7b"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI3OTUxNQ==", "bodyText": "Yeah!", "url": "https://github.com/elastic/elasticsearch/pull/61467#discussion_r494279515", "createdAt": "2020-09-24T12:35:00Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/common/LocalTimeOffset.java", "diffHunk": "@@ -505,7 +558,25 @@ protected static Transition buildTransition(ZoneOffsetTransition transition, Loc\n             }\n             long firstOverlappingLocalTime = utcStart + offsetAfterMillis;\n             long firstNonOverlappingLocalTime = utcStart + offsetBeforeMillis;\n-            return new Overlap(offsetAfterMillis, previous, utcStart, firstOverlappingLocalTime, firstNonOverlappingLocalTime);\n+            return new Overlap(\n+                offsetAfterMillis,\n+                previous,\n+                utcStart,\n+                firstOverlappingLocalTime,\n+                firstNonOverlappingLocalTime,\n+                movesBackToPreviousDay(transition)\n+            );\n+        }\n+\n+        private static boolean movesBackToPreviousDay(ZoneOffsetTransition transition) {\n+            if (transition.getDateTimeBefore().getDayOfMonth() == transition.getDateTimeAfter().getDayOfMonth()) {\n+                return false;\n+            }\n+            if (transition.getDateTimeBefore().getMinute() == 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg1NzU0NA=="}, "originalCommit": {"oid": "f1e286ebba0ce02bb37d3ee4ef8696852e6aec7b"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI4NTMyOQ==", "bodyText": "I pushed a change that makes sure the \"NANO_OF_DAY\" is 0. That seems fairly good at covering it", "url": "https://github.com/elastic/elasticsearch/pull/61467#discussion_r494285329", "createdAt": "2020-09-24T12:42:52Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/common/LocalTimeOffset.java", "diffHunk": "@@ -505,7 +558,25 @@ protected static Transition buildTransition(ZoneOffsetTransition transition, Loc\n             }\n             long firstOverlappingLocalTime = utcStart + offsetAfterMillis;\n             long firstNonOverlappingLocalTime = utcStart + offsetBeforeMillis;\n-            return new Overlap(offsetAfterMillis, previous, utcStart, firstOverlappingLocalTime, firstNonOverlappingLocalTime);\n+            return new Overlap(\n+                offsetAfterMillis,\n+                previous,\n+                utcStart,\n+                firstOverlappingLocalTime,\n+                firstNonOverlappingLocalTime,\n+                movesBackToPreviousDay(transition)\n+            );\n+        }\n+\n+        private static boolean movesBackToPreviousDay(ZoneOffsetTransition transition) {\n+            if (transition.getDateTimeBefore().getDayOfMonth() == transition.getDateTimeAfter().getDayOfMonth()) {\n+                return false;\n+            }\n+            if (transition.getDateTimeBefore().getMinute() == 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg1NzU0NA=="}, "originalCommit": {"oid": "f1e286ebba0ce02bb37d3ee4ef8696852e6aec7b"}, "originalPosition": 145}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 807, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}