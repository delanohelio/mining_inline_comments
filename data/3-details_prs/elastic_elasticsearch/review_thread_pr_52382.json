{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc1NTQ4MDIw", "number": 52382, "reviewThreads": {"totalCount": 24, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNlQxODoxNzo0N1rODgOgdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxNjozNTo1MVrODozFzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MTE4NzExOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/mapper/GeoShapeIndexer.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNlQxODoxNzo0N1rOFqUoFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQxMjoyNjozM1rOFrmNGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTkyMjQ1Mg==", "bodyText": "I think this is wrong. GeoShapeIndexer works on geo_shape fields and CIRCLE is not a supported geometry for indexing.", "url": "https://github.com/elastic/elasticsearch/pull/52382#discussion_r379922452", "createdAt": "2020-02-16T18:17:47Z", "author": {"login": "iverase"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/GeoShapeIndexer.java", "diffHunk": "@@ -79,7 +79,10 @@ public Geometry prepareForIndexing(Geometry geometry) {\n         return geometry.visit(new GeometryVisitor<>() {\n             @Override\n             public Geometry visit(Circle circle) {\n-                throw new UnsupportedOperationException(\"CIRCLE geometry is not supported\");\n+                double[] latlon = new double[]{circle.getX(), circle.getY()};\n+                normalizePoint(latlon);\n+                double radius = circle.getRadiusMeters();\n+                return new Circle(latlon[0], latlon[1], radius);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a81c7c195325da4c3d2d1ae7028034998ab071ff"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDEyNjg0Mg==", "bodyText": "Sorry, I had misunderstood that, I've rolled back the change", "url": "https://github.com/elastic/elasticsearch/pull/52382#discussion_r380126842", "createdAt": "2020-02-17T11:24:26Z", "author": {"login": "djptek"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/GeoShapeIndexer.java", "diffHunk": "@@ -79,7 +79,10 @@ public Geometry prepareForIndexing(Geometry geometry) {\n         return geometry.visit(new GeometryVisitor<>() {\n             @Override\n             public Geometry visit(Circle circle) {\n-                throw new UnsupportedOperationException(\"CIRCLE geometry is not supported\");\n+                double[] latlon = new double[]{circle.getX(), circle.getY()};\n+                normalizePoint(latlon);\n+                double radius = circle.getRadiusMeters();\n+                return new Circle(latlon[0], latlon[1], radius);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTkyMjQ1Mg=="}, "originalCommit": {"oid": "a81c7c195325da4c3d2d1ae7028034998ab071ff"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE0MjA2MA==", "bodyText": "I understand now why you did this. I think we need to find a different solution, for example we should not be calling this class before creating the geo_shape query but another processor. Note that this processor is in charge for example in break a polygon when it crosses the dateline.", "url": "https://github.com/elastic/elasticsearch/pull/52382#discussion_r380142060", "createdAt": "2020-02-17T12:01:01Z", "author": {"login": "iverase"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/GeoShapeIndexer.java", "diffHunk": "@@ -79,7 +79,10 @@ public Geometry prepareForIndexing(Geometry geometry) {\n         return geometry.visit(new GeometryVisitor<>() {\n             @Override\n             public Geometry visit(Circle circle) {\n-                throw new UnsupportedOperationException(\"CIRCLE geometry is not supported\");\n+                double[] latlon = new double[]{circle.getX(), circle.getY()};\n+                normalizePoint(latlon);\n+                double radius = circle.getRadiusMeters();\n+                return new Circle(latlon[0], latlon[1], radius);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTkyMjQ1Mg=="}, "originalCommit": {"oid": "a81c7c195325da4c3d2d1ae7028034998ab071ff"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDIzMTM5Mg==", "bodyText": "I opened a PR to help this implementation", "url": "https://github.com/elastic/elasticsearch/pull/52382#discussion_r380231392", "createdAt": "2020-02-17T15:02:43Z", "author": {"login": "iverase"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/GeoShapeIndexer.java", "diffHunk": "@@ -79,7 +79,10 @@ public Geometry prepareForIndexing(Geometry geometry) {\n         return geometry.visit(new GeometryVisitor<>() {\n             @Override\n             public Geometry visit(Circle circle) {\n-                throw new UnsupportedOperationException(\"CIRCLE geometry is not supported\");\n+                double[] latlon = new double[]{circle.getX(), circle.getY()};\n+                normalizePoint(latlon);\n+                double radius = circle.getRadiusMeters();\n+                return new Circle(latlon[0], latlon[1], radius);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTkyMjQ1Mg=="}, "originalCommit": {"oid": "a81c7c195325da4c3d2d1ae7028034998ab071ff"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTI1OTAzMg==", "bodyText": "PR Merged", "url": "https://github.com/elastic/elasticsearch/pull/52382#discussion_r381259032", "createdAt": "2020-02-19T12:26:33Z", "author": {"login": "djptek"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/GeoShapeIndexer.java", "diffHunk": "@@ -79,7 +79,10 @@ public Geometry prepareForIndexing(Geometry geometry) {\n         return geometry.visit(new GeometryVisitor<>() {\n             @Override\n             public Geometry visit(Circle circle) {\n-                throw new UnsupportedOperationException(\"CIRCLE geometry is not supported\");\n+                double[] latlon = new double[]{circle.getX(), circle.getY()};\n+                normalizePoint(latlon);\n+                double radius = circle.getRadiusMeters();\n+                return new Circle(latlon[0], latlon[1], radius);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTkyMjQ1Mg=="}, "originalCommit": {"oid": "a81c7c195325da4c3d2d1ae7028034998ab071ff"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MTE4ODAxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/query/GeoShapeQueryBuilder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNlQxODoxOTozMVrOFqUohw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxMjoyMzoxOVrOFqin0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTkyMjU2Nw==", "bodyText": "We cannot hardcode those values. This method is called for geo_shape and shape queries, therefore we use queryFieldType() to get the underlaying fields. I think the solution here is to change the signature of queryFieldType() method to return an arrays of fields.", "url": "https://github.com/elastic/elasticsearch/pull/52382#discussion_r379922567", "createdAt": "2020-02-16T18:19:31Z", "author": {"login": "iverase"}, "path": "server/src/main/java/org/elasticsearch/index/query/GeoShapeQueryBuilder.java", "diffHunk": "@@ -197,9 +198,13 @@ protected GeoShapeQueryBuilder newShapeQueryBuilder(String fieldName, Supplier<G\n \n     @Override\n     public Query buildShapeQuery(QueryShardContext context, MappedFieldType fieldType) {\n-        if (fieldType.typeName().equals(GeoShapeFieldMapper.CONTENT_TYPE) == false) {\n+        if (fieldType.typeName().equals(GeoShapeFieldMapper.CONTENT_TYPE) == false &&\n+            fieldType.typeName().equals(GeoPointFieldMapper.CONTENT_TYPE) == false) {\n             throw new QueryShardException(context,\n-                \"Field [\" + fieldName + \"] is not of type [\" + queryFieldType() + \"] but of type [\" + fieldType.typeName() + \"]\");\n+                \"Field [\" + fieldName + \"] is of unsupported type [\" + fieldType.typeName() + \"]. [\"\n+                + NAME + \"] query supports the following types [\"\n+                + GeoShapeFieldMapper.CONTENT_TYPE + \", \"\n+                + GeoPointFieldMapper.CONTENT_TYPE + \"]\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a81c7c195325da4c3d2d1ae7028034998ab071ff"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE1MTc2MA==", "bodyText": "Agree, there is already List validContentTypes() so I have encapsulated the supported types there to avoid doing anything drastic with Reflection. queryFieldType is essentially redundant, so I changed the signature to List, pointed this to ValidContentTypes() and then deprecated.", "url": "https://github.com/elastic/elasticsearch/pull/52382#discussion_r380151760", "createdAt": "2020-02-17T12:23:19Z", "author": {"login": "djptek"}, "path": "server/src/main/java/org/elasticsearch/index/query/GeoShapeQueryBuilder.java", "diffHunk": "@@ -197,9 +198,13 @@ protected GeoShapeQueryBuilder newShapeQueryBuilder(String fieldName, Supplier<G\n \n     @Override\n     public Query buildShapeQuery(QueryShardContext context, MappedFieldType fieldType) {\n-        if (fieldType.typeName().equals(GeoShapeFieldMapper.CONTENT_TYPE) == false) {\n+        if (fieldType.typeName().equals(GeoShapeFieldMapper.CONTENT_TYPE) == false &&\n+            fieldType.typeName().equals(GeoPointFieldMapper.CONTENT_TYPE) == false) {\n             throw new QueryShardException(context,\n-                \"Field [\" + fieldName + \"] is not of type [\" + queryFieldType() + \"] but of type [\" + fieldType.typeName() + \"]\");\n+                \"Field [\" + fieldName + \"] is of unsupported type [\" + fieldType.typeName() + \"]. [\"\n+                + NAME + \"] query supports the following types [\"\n+                + GeoShapeFieldMapper.CONTENT_TYPE + \", \"\n+                + GeoPointFieldMapper.CONTENT_TYPE + \"]\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTkyMjU2Nw=="}, "originalCommit": {"oid": "a81c7c195325da4c3d2d1ae7028034998ab071ff"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MTE4OTExOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/query/VectorGeoShapeQueryProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNlQxODoyMDo0OFrOFqUpCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxMjozMDo1MlrOFqi00A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTkyMjY5Nw==", "bodyText": "geo_shape queries over geo_shape fields do not support circle queries. It should be an error.", "url": "https://github.com/elastic/elasticsearch/pull/52382#discussion_r379922697", "createdAt": "2020-02-16T18:20:48Z", "author": {"login": "iverase"}, "path": "server/src/main/java/org/elasticsearch/index/query/VectorGeoShapeQueryProcessor.java", "diffHunk": "@@ -86,7 +87,9 @@ protected Query getVectorQueryFromShape(Geometry queryShape, String fieldName, S\n \n         @Override\n         public Query visit(Circle circle) {\n-            throw new QueryShardException(context, \"Field [\" + fieldName + \"] found and unknown shape Circle\");\n+            // use Point visitor", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a81c7c195325da4c3d2d1ae7028034998ab071ff"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE1NTA4OA==", "bodyText": "Sorry, I had misunderstood that, I've rolled back the change", "url": "https://github.com/elastic/elasticsearch/pull/52382#discussion_r380155088", "createdAt": "2020-02-17T12:30:52Z", "author": {"login": "djptek"}, "path": "server/src/main/java/org/elasticsearch/index/query/VectorGeoShapeQueryProcessor.java", "diffHunk": "@@ -86,7 +87,9 @@ protected Query getVectorQueryFromShape(Geometry queryShape, String fieldName, S\n \n         @Override\n         public Query visit(Circle circle) {\n-            throw new QueryShardException(context, \"Field [\" + fieldName + \"] found and unknown shape Circle\");\n+            // use Point visitor", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTkyMjY5Nw=="}, "originalCommit": {"oid": "a81c7c195325da4c3d2d1ae7028034998ab071ff"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MTE4OTY0OnYy", "diffSide": "RIGHT", "path": "docs/reference/query-dsl/geo-shape-query.asciidoc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNlQxODoyMTozMlrOFqUpRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxNTozNDowOFrOFqogSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTkyMjc1Nw==", "bodyText": "is it needed this change?", "url": "https://github.com/elastic/elasticsearch/pull/52382#discussion_r379922757", "createdAt": "2020-02-16T18:21:32Z", "author": {"login": "iverase"}, "path": "docs/reference/query-dsl/geo-shape-query.asciidoc", "diffHunk": "@@ -31,7 +31,7 @@ PUT /example\n {\n     \"mappings\": {\n         \"properties\": {\n-            \"location\": {\n+            \"geo\": {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a81c7c195325da4c3d2d1ae7028034998ab071ff"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI0ODEzOA==", "bodyText": "no, I can roll that back. I made the change to reflect that a shape does not necessarily have to be a location", "url": "https://github.com/elastic/elasticsearch/pull/52382#discussion_r380248138", "createdAt": "2020-02-17T15:34:08Z", "author": {"login": "djptek"}, "path": "docs/reference/query-dsl/geo-shape-query.asciidoc", "diffHunk": "@@ -31,7 +31,7 @@ PUT /example\n {\n     \"mappings\": {\n         \"properties\": {\n-            \"location\": {\n+            \"geo\": {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTkyMjc1Nw=="}, "originalCommit": {"oid": "a81c7c195325da4c3d2d1ae7028034998ab071ff"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MTE5MDAwOnYy", "diffSide": "RIGHT", "path": "docs/reference/query-dsl/geo-shape-query.asciidoc", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNlQxODoyMjoyMlrOFqUpbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxNjowMjozMFrOFqpbjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTkyMjc5OQ==", "bodyText": "This looks wrong? why are we changing this?", "url": "https://github.com/elastic/elasticsearch/pull/52382#discussion_r379922799", "createdAt": "2020-02-16T18:22:22Z", "author": {"login": "iverase"}, "path": "docs/reference/query-dsl/geo-shape-query.asciidoc", "diffHunk": "@@ -56,24 +56,17 @@ The following query will find the point using the Elasticsearch's\n --------------------------------------------------\n GET /example/_search\n {\n-    \"query\":{\n-        \"bool\": {\n-            \"must\": {\n-                \"match_all\": {}\n-            },\n-            \"filter\": {\n-                \"geo_shape\": {\n-                    \"location\": {\n-                        \"shape\": {\n-                            \"type\": \"envelope\",\n-                            \"coordinates\" : [[13.0, 53.0], [14.0, 52.0]]\n-                        },\n-                        \"relation\": \"within\"\n-                    }\n-                }\n-            }\n-        }\n+  \"query\": {\n+    \"geo_shape\": {\n+      \"geo\": {\n+        \"shape\": {\n+          \"type\": \"envelope\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a81c7c195325da4c3d2d1ae7028034998ab071ff"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE1ODIxNQ==", "bodyText": "I tested & it works. I proposed this change because enclosing the query within:\n            \"must\": {\n                \"match_all\": {}\n            },\n            \"filter\": {\n...\n}}}}```  \n\nis not needed, and in the documentation this distracts from the DSL query syntax.\n\nI can rollback &/or move to a new PR please confirm", "url": "https://github.com/elastic/elasticsearch/pull/52382#discussion_r380158215", "createdAt": "2020-02-17T12:38:08Z", "author": {"login": "djptek"}, "path": "docs/reference/query-dsl/geo-shape-query.asciidoc", "diffHunk": "@@ -56,24 +56,17 @@ The following query will find the point using the Elasticsearch's\n --------------------------------------------------\n GET /example/_search\n {\n-    \"query\":{\n-        \"bool\": {\n-            \"must\": {\n-                \"match_all\": {}\n-            },\n-            \"filter\": {\n-                \"geo_shape\": {\n-                    \"location\": {\n-                        \"shape\": {\n-                            \"type\": \"envelope\",\n-                            \"coordinates\" : [[13.0, 53.0], [14.0, 52.0]]\n-                        },\n-                        \"relation\": \"within\"\n-                    }\n-                }\n-            }\n-        }\n+  \"query\": {\n+    \"geo_shape\": {\n+      \"geo\": {\n+        \"shape\": {\n+          \"type\": \"envelope\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTkyMjc5OQ=="}, "originalCommit": {"oid": "a81c7c195325da4c3d2d1ae7028034998ab071ff"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDIzMjAzOQ==", "bodyText": "We can do that in a follow up PR, let's just add the new changes so it is easy to review.", "url": "https://github.com/elastic/elasticsearch/pull/52382#discussion_r380232039", "createdAt": "2020-02-17T15:03:58Z", "author": {"login": "iverase"}, "path": "docs/reference/query-dsl/geo-shape-query.asciidoc", "diffHunk": "@@ -56,24 +56,17 @@ The following query will find the point using the Elasticsearch's\n --------------------------------------------------\n GET /example/_search\n {\n-    \"query\":{\n-        \"bool\": {\n-            \"must\": {\n-                \"match_all\": {}\n-            },\n-            \"filter\": {\n-                \"geo_shape\": {\n-                    \"location\": {\n-                        \"shape\": {\n-                            \"type\": \"envelope\",\n-                            \"coordinates\" : [[13.0, 53.0], [14.0, 52.0]]\n-                        },\n-                        \"relation\": \"within\"\n-                    }\n-                }\n-            }\n-        }\n+  \"query\": {\n+    \"geo_shape\": {\n+      \"geo\": {\n+        \"shape\": {\n+          \"type\": \"envelope\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTkyMjc5OQ=="}, "originalCommit": {"oid": "a81c7c195325da4c3d2d1ae7028034998ab071ff"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI2MzMxMA==", "bodyText": "restored", "url": "https://github.com/elastic/elasticsearch/pull/52382#discussion_r380263310", "createdAt": "2020-02-17T16:02:30Z", "author": {"login": "djptek"}, "path": "docs/reference/query-dsl/geo-shape-query.asciidoc", "diffHunk": "@@ -56,24 +56,17 @@ The following query will find the point using the Elasticsearch's\n --------------------------------------------------\n GET /example/_search\n {\n-    \"query\":{\n-        \"bool\": {\n-            \"must\": {\n-                \"match_all\": {}\n-            },\n-            \"filter\": {\n-                \"geo_shape\": {\n-                    \"location\": {\n-                        \"shape\": {\n-                            \"type\": \"envelope\",\n-                            \"coordinates\" : [[13.0, 53.0], [14.0, 52.0]]\n-                        },\n-                        \"relation\": \"within\"\n-                    }\n-                }\n-            }\n-        }\n+  \"query\": {\n+    \"geo_shape\": {\n+      \"geo\": {\n+        \"shape\": {\n+          \"type\": \"envelope\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTkyMjc5OQ=="}, "originalCommit": {"oid": "a81c7c195325da4c3d2d1ae7028034998ab071ff"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MzI3NzQwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/query/GeoShapeQueryBuilder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxNToxOToxMlrOFqoBnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxNToxOToxMlrOFqoBnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI0MDI4NQ==", "bodyText": "+1", "url": "https://github.com/elastic/elasticsearch/pull/52382#discussion_r380240285", "createdAt": "2020-02-17T15:19:12Z", "author": {"login": "iverase"}, "path": "server/src/main/java/org/elasticsearch/index/query/GeoShapeQueryBuilder.java", "diffHunk": "@@ -169,12 +170,13 @@ public SpatialStrategy strategy() {\n \n     @Override\n     protected List validContentTypes() {\n-        return Arrays.asList(GeoShapeFieldMapper.CONTENT_TYPE);\n+        return Arrays.asList(GeoShapeFieldMapper.CONTENT_TYPE, GeoPointFieldMapper.CONTENT_TYPE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fe901ae92e2a53ba34bb2cae992175cef2ab11c"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MzI4NjM1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/query/AbstractGeometryQueryBuilder.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxNToyMTo1NVrOFqoHHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QyMTo0MDo0NFrOFqwNxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI0MTY5NA==", "bodyText": "You cannot change the signature of the method and deprecate it. In any case I think this an internal API so we probably can just remove the method all together (I will check).", "url": "https://github.com/elastic/elasticsearch/pull/52382#discussion_r380241694", "createdAt": "2020-02-17T15:21:55Z", "author": {"login": "iverase"}, "path": "server/src/main/java/org/elasticsearch/index/query/AbstractGeometryQueryBuilder.java", "diffHunk": "@@ -341,7 +341,8 @@ public boolean ignoreUnmapped() {\n     /** builds the appropriate lucene shape query */\n     protected abstract Query buildShapeQuery(QueryShardContext context, MappedFieldType fieldType);\n     /** returns expected content type for this query */\n-    protected abstract String queryFieldType();\n+    @Deprecated\n+    protected abstract List queryFieldType();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fe901ae92e2a53ba34bb2cae992175cef2ab11c"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI0OTUzOQ==", "bodyText": "It is only used in the place where I have replaced it so I will remove for simplicity", "url": "https://github.com/elastic/elasticsearch/pull/52382#discussion_r380249539", "createdAt": "2020-02-17T15:36:37Z", "author": {"login": "djptek"}, "path": "server/src/main/java/org/elasticsearch/index/query/AbstractGeometryQueryBuilder.java", "diffHunk": "@@ -341,7 +341,8 @@ public boolean ignoreUnmapped() {\n     /** builds the appropriate lucene shape query */\n     protected abstract Query buildShapeQuery(QueryShardContext context, MappedFieldType fieldType);\n     /** returns expected content type for this query */\n-    protected abstract String queryFieldType();\n+    @Deprecated\n+    protected abstract List queryFieldType();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI0MTY5NA=="}, "originalCommit": {"oid": "8fe901ae92e2a53ba34bb2cae992175cef2ab11c"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI1NTExNg==", "bodyText": "It used used as well in the XPack spatial module, you need to reflect these changes there as well.", "url": "https://github.com/elastic/elasticsearch/pull/52382#discussion_r380255116", "createdAt": "2020-02-17T15:46:50Z", "author": {"login": "iverase"}, "path": "server/src/main/java/org/elasticsearch/index/query/AbstractGeometryQueryBuilder.java", "diffHunk": "@@ -341,7 +341,8 @@ public boolean ignoreUnmapped() {\n     /** builds the appropriate lucene shape query */\n     protected abstract Query buildShapeQuery(QueryShardContext context, MappedFieldType fieldType);\n     /** returns expected content type for this query */\n-    protected abstract String queryFieldType();\n+    @Deprecated\n+    protected abstract List queryFieldType();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI0MTY5NA=="}, "originalCommit": {"oid": "8fe901ae92e2a53ba34bb2cae992175cef2ab11c"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM3NDQ3MA==", "bodyText": "Thanks, that's fixed now, I hadn't grepped through X-Pack", "url": "https://github.com/elastic/elasticsearch/pull/52382#discussion_r380374470", "createdAt": "2020-02-17T21:40:44Z", "author": {"login": "djptek"}, "path": "server/src/main/java/org/elasticsearch/index/query/AbstractGeometryQueryBuilder.java", "diffHunk": "@@ -341,7 +341,8 @@ public boolean ignoreUnmapped() {\n     /** builds the appropriate lucene shape query */\n     protected abstract Query buildShapeQuery(QueryShardContext context, MappedFieldType fieldType);\n     /** returns expected content type for this query */\n-    protected abstract String queryFieldType();\n+    @Deprecated\n+    protected abstract List queryFieldType();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI0MTY5NA=="}, "originalCommit": {"oid": "8fe901ae92e2a53ba34bb2cae992175cef2ab11c"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NDg4OTMzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/query/VectorGeoPointShapeQueryProcessor.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxMzo1NzoyMFrOFsUPmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMTo0Mzo1OFrOFu9ZnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAxMzMzOQ==", "bodyText": "We should not be using here the GeoShapeIndexer. Instead we should be calling the GeoPolygon decomposer in the visitor.", "url": "https://github.com/elastic/elasticsearch/pull/52382#discussion_r382013339", "createdAt": "2020-02-20T13:57:20Z", "author": {"login": "iverase"}, "path": "server/src/main/java/org/elasticsearch/index/query/VectorGeoPointShapeQueryProcessor.java", "diffHunk": "@@ -0,0 +1,167 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.query;\n+\n+import org.apache.lucene.document.LatLonPoint;\n+import org.apache.lucene.geo.Polygon;\n+import org.apache.lucene.search.BooleanClause;\n+import org.apache.lucene.search.BooleanQuery;\n+import org.apache.lucene.search.MatchNoDocsQuery;\n+import org.apache.lucene.search.Query;\n+import org.elasticsearch.common.geo.GeoShapeType;\n+import org.elasticsearch.common.geo.ShapeRelation;\n+import org.elasticsearch.geometry.Circle;\n+import org.elasticsearch.geometry.Geometry;\n+import org.elasticsearch.geometry.GeometryCollection;\n+import org.elasticsearch.geometry.GeometryVisitor;\n+import org.elasticsearch.geometry.LinearRing;\n+import org.elasticsearch.geometry.MultiLine;\n+import org.elasticsearch.geometry.MultiPoint;\n+import org.elasticsearch.geometry.MultiPolygon;\n+import org.elasticsearch.geometry.Point;\n+import org.elasticsearch.geometry.Rectangle;\n+import org.elasticsearch.geometry.ShapeType;\n+import org.elasticsearch.index.mapper.AbstractGeometryFieldMapper;\n+import org.elasticsearch.index.mapper.GeoPointFieldMapper;\n+import org.elasticsearch.index.mapper.GeoShapeIndexer;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+\n+import static org.elasticsearch.index.mapper.GeoShapeIndexer.toLucenePolygon;\n+\n+public class VectorGeoPointShapeQueryProcessor implements AbstractGeometryFieldMapper.QueryProcessor {\n+\n+    @Override\n+    public Query process(Geometry shape, String fieldName, ShapeRelation relation, QueryShardContext context) {\n+        validateIsGeoPointFieldType(fieldName, context);\n+        // geo points only support intersects\n+        if (relation != ShapeRelation.INTERSECTS) {\n+            throw new QueryShardException(context,\n+                relation+ \" query relation not supported for Field [\" + fieldName + \"].\");\n+        }\n+        // wrap geoQuery as a ConstantScoreQuery\n+        return getVectorQueryFromShape(shape, fieldName, relation, context);\n+    }\n+\n+    private void validateIsGeoPointFieldType(String fieldName, QueryShardContext context) {\n+        MappedFieldType fieldType = context.fieldMapper(fieldName);\n+        if (fieldType instanceof GeoPointFieldMapper.GeoPointFieldType == false) {\n+            throw new QueryShardException(context, \"Expected \" + GeoPointFieldMapper.CONTENT_TYPE\n+                + \" field type for Field [\" + fieldName + \"] but found \" + fieldType.typeName());\n+        }\n+    }\n+\n+    protected Query getVectorQueryFromShape(\n+        Geometry queryShape, String fieldName, ShapeRelation relation, QueryShardContext context) {\n+        GeoShapeIndexer geometryIndexer = new GeoShapeIndexer(true, fieldName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13afa49d20edaab2a411d1f47297b9eb8e6080eb"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjA4OTg5MQ==", "bodyText": "OK, I'm working on that", "url": "https://github.com/elastic/elasticsearch/pull/52382#discussion_r382089891", "createdAt": "2020-02-20T15:53:04Z", "author": {"login": "djptek"}, "path": "server/src/main/java/org/elasticsearch/index/query/VectorGeoPointShapeQueryProcessor.java", "diffHunk": "@@ -0,0 +1,167 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.query;\n+\n+import org.apache.lucene.document.LatLonPoint;\n+import org.apache.lucene.geo.Polygon;\n+import org.apache.lucene.search.BooleanClause;\n+import org.apache.lucene.search.BooleanQuery;\n+import org.apache.lucene.search.MatchNoDocsQuery;\n+import org.apache.lucene.search.Query;\n+import org.elasticsearch.common.geo.GeoShapeType;\n+import org.elasticsearch.common.geo.ShapeRelation;\n+import org.elasticsearch.geometry.Circle;\n+import org.elasticsearch.geometry.Geometry;\n+import org.elasticsearch.geometry.GeometryCollection;\n+import org.elasticsearch.geometry.GeometryVisitor;\n+import org.elasticsearch.geometry.LinearRing;\n+import org.elasticsearch.geometry.MultiLine;\n+import org.elasticsearch.geometry.MultiPoint;\n+import org.elasticsearch.geometry.MultiPolygon;\n+import org.elasticsearch.geometry.Point;\n+import org.elasticsearch.geometry.Rectangle;\n+import org.elasticsearch.geometry.ShapeType;\n+import org.elasticsearch.index.mapper.AbstractGeometryFieldMapper;\n+import org.elasticsearch.index.mapper.GeoPointFieldMapper;\n+import org.elasticsearch.index.mapper.GeoShapeIndexer;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+\n+import static org.elasticsearch.index.mapper.GeoShapeIndexer.toLucenePolygon;\n+\n+public class VectorGeoPointShapeQueryProcessor implements AbstractGeometryFieldMapper.QueryProcessor {\n+\n+    @Override\n+    public Query process(Geometry shape, String fieldName, ShapeRelation relation, QueryShardContext context) {\n+        validateIsGeoPointFieldType(fieldName, context);\n+        // geo points only support intersects\n+        if (relation != ShapeRelation.INTERSECTS) {\n+            throw new QueryShardException(context,\n+                relation+ \" query relation not supported for Field [\" + fieldName + \"].\");\n+        }\n+        // wrap geoQuery as a ConstantScoreQuery\n+        return getVectorQueryFromShape(shape, fieldName, relation, context);\n+    }\n+\n+    private void validateIsGeoPointFieldType(String fieldName, QueryShardContext context) {\n+        MappedFieldType fieldType = context.fieldMapper(fieldName);\n+        if (fieldType instanceof GeoPointFieldMapper.GeoPointFieldType == false) {\n+            throw new QueryShardException(context, \"Expected \" + GeoPointFieldMapper.CONTENT_TYPE\n+                + \" field type for Field [\" + fieldName + \"] but found \" + fieldType.typeName());\n+        }\n+    }\n+\n+    protected Query getVectorQueryFromShape(\n+        Geometry queryShape, String fieldName, ShapeRelation relation, QueryShardContext context) {\n+        GeoShapeIndexer geometryIndexer = new GeoShapeIndexer(true, fieldName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAxMzMzOQ=="}, "originalCommit": {"oid": "13afa49d20edaab2a411d1f47297b9eb8e6080eb"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc4NDc5Nw==", "bodyText": "@iverase GeoShapeIndexer removed from method, now calling GeoPolygonDecomposer.decomposePolygon (for Polygon only)\n\n3 x tests added\n\nGeoShapeQueryTests.testPolygonSpanningDateline()\nGeoShapeQueryTests.testMultiPolygonSpanningDateline()\nGeoShapeQueryTests.testRectangleSpanningDateline()", "url": "https://github.com/elastic/elasticsearch/pull/52382#discussion_r384784797", "createdAt": "2020-02-26T21:43:58Z", "author": {"login": "djptek"}, "path": "server/src/main/java/org/elasticsearch/index/query/VectorGeoPointShapeQueryProcessor.java", "diffHunk": "@@ -0,0 +1,167 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.query;\n+\n+import org.apache.lucene.document.LatLonPoint;\n+import org.apache.lucene.geo.Polygon;\n+import org.apache.lucene.search.BooleanClause;\n+import org.apache.lucene.search.BooleanQuery;\n+import org.apache.lucene.search.MatchNoDocsQuery;\n+import org.apache.lucene.search.Query;\n+import org.elasticsearch.common.geo.GeoShapeType;\n+import org.elasticsearch.common.geo.ShapeRelation;\n+import org.elasticsearch.geometry.Circle;\n+import org.elasticsearch.geometry.Geometry;\n+import org.elasticsearch.geometry.GeometryCollection;\n+import org.elasticsearch.geometry.GeometryVisitor;\n+import org.elasticsearch.geometry.LinearRing;\n+import org.elasticsearch.geometry.MultiLine;\n+import org.elasticsearch.geometry.MultiPoint;\n+import org.elasticsearch.geometry.MultiPolygon;\n+import org.elasticsearch.geometry.Point;\n+import org.elasticsearch.geometry.Rectangle;\n+import org.elasticsearch.geometry.ShapeType;\n+import org.elasticsearch.index.mapper.AbstractGeometryFieldMapper;\n+import org.elasticsearch.index.mapper.GeoPointFieldMapper;\n+import org.elasticsearch.index.mapper.GeoShapeIndexer;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+\n+import static org.elasticsearch.index.mapper.GeoShapeIndexer.toLucenePolygon;\n+\n+public class VectorGeoPointShapeQueryProcessor implements AbstractGeometryFieldMapper.QueryProcessor {\n+\n+    @Override\n+    public Query process(Geometry shape, String fieldName, ShapeRelation relation, QueryShardContext context) {\n+        validateIsGeoPointFieldType(fieldName, context);\n+        // geo points only support intersects\n+        if (relation != ShapeRelation.INTERSECTS) {\n+            throw new QueryShardException(context,\n+                relation+ \" query relation not supported for Field [\" + fieldName + \"].\");\n+        }\n+        // wrap geoQuery as a ConstantScoreQuery\n+        return getVectorQueryFromShape(shape, fieldName, relation, context);\n+    }\n+\n+    private void validateIsGeoPointFieldType(String fieldName, QueryShardContext context) {\n+        MappedFieldType fieldType = context.fieldMapper(fieldName);\n+        if (fieldType instanceof GeoPointFieldMapper.GeoPointFieldType == false) {\n+            throw new QueryShardException(context, \"Expected \" + GeoPointFieldMapper.CONTENT_TYPE\n+                + \" field type for Field [\" + fieldName + \"] but found \" + fieldType.typeName());\n+        }\n+    }\n+\n+    protected Query getVectorQueryFromShape(\n+        Geometry queryShape, String fieldName, ShapeRelation relation, QueryShardContext context) {\n+        GeoShapeIndexer geometryIndexer = new GeoShapeIndexer(true, fieldName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAxMzMzOQ=="}, "originalCommit": {"oid": "13afa49d20edaab2a411d1f47297b9eb8e6080eb"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NDAwMjkwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/query/VectorGeoPointShapeQueryProcessor.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwNzoyODoxNFrOFvHlrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxOTowODo0MVrOFv_vHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk1MTcyNg==", "bodyText": "I think we should move this logic inside the visitor and decompose the polygons in the methods visit(MultiPolygon multiPolygon) and visit(Polygon polygon). Note that the query accepts an array and therefore the boolean query is not necessary.", "url": "https://github.com/elastic/elasticsearch/pull/52382#discussion_r384951726", "createdAt": "2020-02-27T07:28:14Z", "author": {"login": "iverase"}, "path": "server/src/main/java/org/elasticsearch/index/query/VectorGeoPointShapeQueryProcessor.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.query;\n+\n+import org.apache.lucene.document.LatLonPoint;\n+import org.apache.lucene.search.BooleanClause;\n+import org.apache.lucene.search.BooleanQuery;\n+import org.apache.lucene.search.MatchNoDocsQuery;\n+import org.apache.lucene.search.Query;\n+import org.elasticsearch.common.geo.GeoPolygonDecomposer;\n+import org.elasticsearch.common.geo.GeoShapeType;\n+import org.elasticsearch.common.geo.ShapeRelation;\n+import org.elasticsearch.geometry.Circle;\n+import org.elasticsearch.geometry.Geometry;\n+import org.elasticsearch.geometry.GeometryCollection;\n+import org.elasticsearch.geometry.GeometryVisitor;\n+import org.elasticsearch.geometry.LinearRing;\n+import org.elasticsearch.geometry.MultiLine;\n+import org.elasticsearch.geometry.MultiPoint;\n+import org.elasticsearch.geometry.MultiPolygon;\n+import org.elasticsearch.geometry.Point;\n+import org.elasticsearch.geometry.Polygon;\n+import org.elasticsearch.geometry.Rectangle;\n+import org.elasticsearch.geometry.ShapeType;\n+import org.elasticsearch.index.mapper.AbstractGeometryFieldMapper;\n+import org.elasticsearch.index.mapper.GeoPointFieldMapper;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+\n+import java.util.ArrayList;\n+\n+import static org.elasticsearch.index.mapper.GeoShapeIndexer.toLucenePolygon;\n+\n+public class VectorGeoPointShapeQueryProcessor implements AbstractGeometryFieldMapper.QueryProcessor {\n+\n+    @Override\n+    public Query process(Geometry shape, String fieldName, ShapeRelation relation, QueryShardContext context) {\n+        validateIsGeoPointFieldType(fieldName, context);\n+        // geo points only support intersects\n+        if (relation != ShapeRelation.INTERSECTS) {\n+            throw new QueryShardException(context,\n+                relation+ \" query relation not supported for Field [\" + fieldName + \"].\");\n+        }\n+        // wrap geoQuery as a ConstantScoreQuery\n+        return getVectorQueryFromShape(shape, fieldName, relation, context);\n+    }\n+\n+    private void validateIsGeoPointFieldType(String fieldName, QueryShardContext context) {\n+        MappedFieldType fieldType = context.fieldMapper(fieldName);\n+        if (fieldType instanceof GeoPointFieldMapper.GeoPointFieldType == false) {\n+            throw new QueryShardException(context, \"Expected \" + GeoPointFieldMapper.CONTENT_TYPE\n+                + \" field type for Field [\" + fieldName + \"] but found \" + fieldType.typeName());\n+        }\n+    }\n+\n+    protected Query getVectorQueryFromShape(\n+        Geometry queryShape, String fieldName, ShapeRelation relation, QueryShardContext context) {\n+        ShapeVisitor shapeVisitor = new ShapeVisitor(context, fieldName, relation);\n+        if (queryShape.type().equals(ShapeType.POLYGON)) {\n+            ArrayList<org.elasticsearch.geometry.Polygon> collector = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83bdc937d79d09bbfb730a5a4ef5a8daadec23fc"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI2NTU0Nw==", "bodyText": "I removed GeoPolygonDecomposer.decomposePolygon() prior to pushing this down & tests passed OK where I had expected a fail.  I added an additional point to GeoShapeQueryTests.testPolygonSpanningDateline() to validate that a polygon spanning the dateline matched intersecting documents on both sides and did not match non-intersecting documents on both sides - the test is currently passing without decomposePolygon() , I'm looking into how and why", "url": "https://github.com/elastic/elasticsearch/pull/52382#discussion_r385265547", "createdAt": "2020-02-27T17:38:53Z", "author": {"login": "djptek"}, "path": "server/src/main/java/org/elasticsearch/index/query/VectorGeoPointShapeQueryProcessor.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.query;\n+\n+import org.apache.lucene.document.LatLonPoint;\n+import org.apache.lucene.search.BooleanClause;\n+import org.apache.lucene.search.BooleanQuery;\n+import org.apache.lucene.search.MatchNoDocsQuery;\n+import org.apache.lucene.search.Query;\n+import org.elasticsearch.common.geo.GeoPolygonDecomposer;\n+import org.elasticsearch.common.geo.GeoShapeType;\n+import org.elasticsearch.common.geo.ShapeRelation;\n+import org.elasticsearch.geometry.Circle;\n+import org.elasticsearch.geometry.Geometry;\n+import org.elasticsearch.geometry.GeometryCollection;\n+import org.elasticsearch.geometry.GeometryVisitor;\n+import org.elasticsearch.geometry.LinearRing;\n+import org.elasticsearch.geometry.MultiLine;\n+import org.elasticsearch.geometry.MultiPoint;\n+import org.elasticsearch.geometry.MultiPolygon;\n+import org.elasticsearch.geometry.Point;\n+import org.elasticsearch.geometry.Polygon;\n+import org.elasticsearch.geometry.Rectangle;\n+import org.elasticsearch.geometry.ShapeType;\n+import org.elasticsearch.index.mapper.AbstractGeometryFieldMapper;\n+import org.elasticsearch.index.mapper.GeoPointFieldMapper;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+\n+import java.util.ArrayList;\n+\n+import static org.elasticsearch.index.mapper.GeoShapeIndexer.toLucenePolygon;\n+\n+public class VectorGeoPointShapeQueryProcessor implements AbstractGeometryFieldMapper.QueryProcessor {\n+\n+    @Override\n+    public Query process(Geometry shape, String fieldName, ShapeRelation relation, QueryShardContext context) {\n+        validateIsGeoPointFieldType(fieldName, context);\n+        // geo points only support intersects\n+        if (relation != ShapeRelation.INTERSECTS) {\n+            throw new QueryShardException(context,\n+                relation+ \" query relation not supported for Field [\" + fieldName + \"].\");\n+        }\n+        // wrap geoQuery as a ConstantScoreQuery\n+        return getVectorQueryFromShape(shape, fieldName, relation, context);\n+    }\n+\n+    private void validateIsGeoPointFieldType(String fieldName, QueryShardContext context) {\n+        MappedFieldType fieldType = context.fieldMapper(fieldName);\n+        if (fieldType instanceof GeoPointFieldMapper.GeoPointFieldType == false) {\n+            throw new QueryShardException(context, \"Expected \" + GeoPointFieldMapper.CONTENT_TYPE\n+                + \" field type for Field [\" + fieldName + \"] but found \" + fieldType.typeName());\n+        }\n+    }\n+\n+    protected Query getVectorQueryFromShape(\n+        Geometry queryShape, String fieldName, ShapeRelation relation, QueryShardContext context) {\n+        ShapeVisitor shapeVisitor = new ShapeVisitor(context, fieldName, relation);\n+        if (queryShape.type().equals(ShapeType.POLYGON)) {\n+            ArrayList<org.elasticsearch.geometry.Polygon> collector = new ArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk1MTcyNg=="}, "originalCommit": {"oid": "83bdc937d79d09bbfb730a5a4ef5a8daadec23fc"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI5NTA1OA==", "bodyText": "I guess it is because the method lives in GeoShapeQueryTests so it is only testing geo_shape field. Try to move it down to geoQueryTests (you might need to change the way you are indexing the points)", "url": "https://github.com/elastic/elasticsearch/pull/52382#discussion_r385295058", "createdAt": "2020-02-27T18:34:53Z", "author": {"login": "iverase"}, "path": "server/src/main/java/org/elasticsearch/index/query/VectorGeoPointShapeQueryProcessor.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.query;\n+\n+import org.apache.lucene.document.LatLonPoint;\n+import org.apache.lucene.search.BooleanClause;\n+import org.apache.lucene.search.BooleanQuery;\n+import org.apache.lucene.search.MatchNoDocsQuery;\n+import org.apache.lucene.search.Query;\n+import org.elasticsearch.common.geo.GeoPolygonDecomposer;\n+import org.elasticsearch.common.geo.GeoShapeType;\n+import org.elasticsearch.common.geo.ShapeRelation;\n+import org.elasticsearch.geometry.Circle;\n+import org.elasticsearch.geometry.Geometry;\n+import org.elasticsearch.geometry.GeometryCollection;\n+import org.elasticsearch.geometry.GeometryVisitor;\n+import org.elasticsearch.geometry.LinearRing;\n+import org.elasticsearch.geometry.MultiLine;\n+import org.elasticsearch.geometry.MultiPoint;\n+import org.elasticsearch.geometry.MultiPolygon;\n+import org.elasticsearch.geometry.Point;\n+import org.elasticsearch.geometry.Polygon;\n+import org.elasticsearch.geometry.Rectangle;\n+import org.elasticsearch.geometry.ShapeType;\n+import org.elasticsearch.index.mapper.AbstractGeometryFieldMapper;\n+import org.elasticsearch.index.mapper.GeoPointFieldMapper;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+\n+import java.util.ArrayList;\n+\n+import static org.elasticsearch.index.mapper.GeoShapeIndexer.toLucenePolygon;\n+\n+public class VectorGeoPointShapeQueryProcessor implements AbstractGeometryFieldMapper.QueryProcessor {\n+\n+    @Override\n+    public Query process(Geometry shape, String fieldName, ShapeRelation relation, QueryShardContext context) {\n+        validateIsGeoPointFieldType(fieldName, context);\n+        // geo points only support intersects\n+        if (relation != ShapeRelation.INTERSECTS) {\n+            throw new QueryShardException(context,\n+                relation+ \" query relation not supported for Field [\" + fieldName + \"].\");\n+        }\n+        // wrap geoQuery as a ConstantScoreQuery\n+        return getVectorQueryFromShape(shape, fieldName, relation, context);\n+    }\n+\n+    private void validateIsGeoPointFieldType(String fieldName, QueryShardContext context) {\n+        MappedFieldType fieldType = context.fieldMapper(fieldName);\n+        if (fieldType instanceof GeoPointFieldMapper.GeoPointFieldType == false) {\n+            throw new QueryShardException(context, \"Expected \" + GeoPointFieldMapper.CONTENT_TYPE\n+                + \" field type for Field [\" + fieldName + \"] but found \" + fieldType.typeName());\n+        }\n+    }\n+\n+    protected Query getVectorQueryFromShape(\n+        Geometry queryShape, String fieldName, ShapeRelation relation, QueryShardContext context) {\n+        ShapeVisitor shapeVisitor = new ShapeVisitor(context, fieldName, relation);\n+        if (queryShape.type().equals(ShapeType.POLYGON)) {\n+            ArrayList<org.elasticsearch.geometry.Polygon> collector = new ArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk1MTcyNg=="}, "originalCommit": {"oid": "83bdc937d79d09bbfb730a5a4ef5a8daadec23fc"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTYwMjY4Mg==", "bodyText": "Tests were in GeoShapeGeoShape, I've pushed up, working on the refactor now", "url": "https://github.com/elastic/elasticsearch/pull/52382#discussion_r385602682", "createdAt": "2020-02-28T09:55:29Z", "author": {"login": "djptek"}, "path": "server/src/main/java/org/elasticsearch/index/query/VectorGeoPointShapeQueryProcessor.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.query;\n+\n+import org.apache.lucene.document.LatLonPoint;\n+import org.apache.lucene.search.BooleanClause;\n+import org.apache.lucene.search.BooleanQuery;\n+import org.apache.lucene.search.MatchNoDocsQuery;\n+import org.apache.lucene.search.Query;\n+import org.elasticsearch.common.geo.GeoPolygonDecomposer;\n+import org.elasticsearch.common.geo.GeoShapeType;\n+import org.elasticsearch.common.geo.ShapeRelation;\n+import org.elasticsearch.geometry.Circle;\n+import org.elasticsearch.geometry.Geometry;\n+import org.elasticsearch.geometry.GeometryCollection;\n+import org.elasticsearch.geometry.GeometryVisitor;\n+import org.elasticsearch.geometry.LinearRing;\n+import org.elasticsearch.geometry.MultiLine;\n+import org.elasticsearch.geometry.MultiPoint;\n+import org.elasticsearch.geometry.MultiPolygon;\n+import org.elasticsearch.geometry.Point;\n+import org.elasticsearch.geometry.Polygon;\n+import org.elasticsearch.geometry.Rectangle;\n+import org.elasticsearch.geometry.ShapeType;\n+import org.elasticsearch.index.mapper.AbstractGeometryFieldMapper;\n+import org.elasticsearch.index.mapper.GeoPointFieldMapper;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+\n+import java.util.ArrayList;\n+\n+import static org.elasticsearch.index.mapper.GeoShapeIndexer.toLucenePolygon;\n+\n+public class VectorGeoPointShapeQueryProcessor implements AbstractGeometryFieldMapper.QueryProcessor {\n+\n+    @Override\n+    public Query process(Geometry shape, String fieldName, ShapeRelation relation, QueryShardContext context) {\n+        validateIsGeoPointFieldType(fieldName, context);\n+        // geo points only support intersects\n+        if (relation != ShapeRelation.INTERSECTS) {\n+            throw new QueryShardException(context,\n+                relation+ \" query relation not supported for Field [\" + fieldName + \"].\");\n+        }\n+        // wrap geoQuery as a ConstantScoreQuery\n+        return getVectorQueryFromShape(shape, fieldName, relation, context);\n+    }\n+\n+    private void validateIsGeoPointFieldType(String fieldName, QueryShardContext context) {\n+        MappedFieldType fieldType = context.fieldMapper(fieldName);\n+        if (fieldType instanceof GeoPointFieldMapper.GeoPointFieldType == false) {\n+            throw new QueryShardException(context, \"Expected \" + GeoPointFieldMapper.CONTENT_TYPE\n+                + \" field type for Field [\" + fieldName + \"] but found \" + fieldType.typeName());\n+        }\n+    }\n+\n+    protected Query getVectorQueryFromShape(\n+        Geometry queryShape, String fieldName, ShapeRelation relation, QueryShardContext context) {\n+        ShapeVisitor shapeVisitor = new ShapeVisitor(context, fieldName, relation);\n+        if (queryShape.type().equals(ShapeType.POLYGON)) {\n+            ArrayList<org.elasticsearch.geometry.Polygon> collector = new ArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk1MTcyNg=="}, "originalCommit": {"oid": "83bdc937d79d09bbfb730a5a4ef5a8daadec23fc"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg3MTY0Ng==", "bodyText": "Done - by the way, in VectorGeoPointShapeQueryProcessor.ShapeVisitor the methods\nvisit(MultiPolygon multiPolygon)\nvisit(Polygon polygon)\nare both using (successfully)\norg.apache.lucene.geo.Polygon\nThis is the right level to introduce the Lucene classes, correct?", "url": "https://github.com/elastic/elasticsearch/pull/52382#discussion_r385871646", "createdAt": "2020-02-28T19:08:41Z", "author": {"login": "djptek"}, "path": "server/src/main/java/org/elasticsearch/index/query/VectorGeoPointShapeQueryProcessor.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.query;\n+\n+import org.apache.lucene.document.LatLonPoint;\n+import org.apache.lucene.search.BooleanClause;\n+import org.apache.lucene.search.BooleanQuery;\n+import org.apache.lucene.search.MatchNoDocsQuery;\n+import org.apache.lucene.search.Query;\n+import org.elasticsearch.common.geo.GeoPolygonDecomposer;\n+import org.elasticsearch.common.geo.GeoShapeType;\n+import org.elasticsearch.common.geo.ShapeRelation;\n+import org.elasticsearch.geometry.Circle;\n+import org.elasticsearch.geometry.Geometry;\n+import org.elasticsearch.geometry.GeometryCollection;\n+import org.elasticsearch.geometry.GeometryVisitor;\n+import org.elasticsearch.geometry.LinearRing;\n+import org.elasticsearch.geometry.MultiLine;\n+import org.elasticsearch.geometry.MultiPoint;\n+import org.elasticsearch.geometry.MultiPolygon;\n+import org.elasticsearch.geometry.Point;\n+import org.elasticsearch.geometry.Polygon;\n+import org.elasticsearch.geometry.Rectangle;\n+import org.elasticsearch.geometry.ShapeType;\n+import org.elasticsearch.index.mapper.AbstractGeometryFieldMapper;\n+import org.elasticsearch.index.mapper.GeoPointFieldMapper;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+\n+import java.util.ArrayList;\n+\n+import static org.elasticsearch.index.mapper.GeoShapeIndexer.toLucenePolygon;\n+\n+public class VectorGeoPointShapeQueryProcessor implements AbstractGeometryFieldMapper.QueryProcessor {\n+\n+    @Override\n+    public Query process(Geometry shape, String fieldName, ShapeRelation relation, QueryShardContext context) {\n+        validateIsGeoPointFieldType(fieldName, context);\n+        // geo points only support intersects\n+        if (relation != ShapeRelation.INTERSECTS) {\n+            throw new QueryShardException(context,\n+                relation+ \" query relation not supported for Field [\" + fieldName + \"].\");\n+        }\n+        // wrap geoQuery as a ConstantScoreQuery\n+        return getVectorQueryFromShape(shape, fieldName, relation, context);\n+    }\n+\n+    private void validateIsGeoPointFieldType(String fieldName, QueryShardContext context) {\n+        MappedFieldType fieldType = context.fieldMapper(fieldName);\n+        if (fieldType instanceof GeoPointFieldMapper.GeoPointFieldType == false) {\n+            throw new QueryShardException(context, \"Expected \" + GeoPointFieldMapper.CONTENT_TYPE\n+                + \" field type for Field [\" + fieldName + \"] but found \" + fieldType.typeName());\n+        }\n+    }\n+\n+    protected Query getVectorQueryFromShape(\n+        Geometry queryShape, String fieldName, ShapeRelation relation, QueryShardContext context) {\n+        ShapeVisitor shapeVisitor = new ShapeVisitor(context, fieldName, relation);\n+        if (queryShape.type().equals(ShapeType.POLYGON)) {\n+            ArrayList<org.elasticsearch.geometry.Polygon> collector = new ArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk1MTcyNg=="}, "originalCommit": {"oid": "83bdc937d79d09bbfb730a5a4ef5a8daadec23fc"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NDU4NjUzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/query/GeoShapeQueryBuilder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxMDozNTowOVrOFvNHbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxNjowMjo0NlrOFvXBpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA0MjI4Ng==", "bodyText": "For readability we prefer == false rather than !", "url": "https://github.com/elastic/elasticsearch/pull/52382#discussion_r385042286", "createdAt": "2020-02-27T10:35:09Z", "author": {"login": "iverase"}, "path": "server/src/main/java/org/elasticsearch/index/query/GeoShapeQueryBuilder.java", "diffHunk": "@@ -197,9 +193,11 @@ protected GeoShapeQueryBuilder newShapeQueryBuilder(String fieldName, Supplier<G\n \n     @Override\n     public Query buildShapeQuery(QueryShardContext context, MappedFieldType fieldType) {\n-        if (fieldType.typeName().equals(GeoShapeFieldMapper.CONTENT_TYPE) == false) {\n+        if (!validContentTypes().contains(fieldType.typeName())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83bdc937d79d09bbfb730a5a4ef5a8daadec23fc"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTIwNDY0Nw==", "bodyText": "OK, done", "url": "https://github.com/elastic/elasticsearch/pull/52382#discussion_r385204647", "createdAt": "2020-02-27T16:02:46Z", "author": {"login": "djptek"}, "path": "server/src/main/java/org/elasticsearch/index/query/GeoShapeQueryBuilder.java", "diffHunk": "@@ -197,9 +193,11 @@ protected GeoShapeQueryBuilder newShapeQueryBuilder(String fieldName, Supplier<G\n \n     @Override\n     public Query buildShapeQuery(QueryShardContext context, MappedFieldType fieldType) {\n-        if (fieldType.typeName().equals(GeoShapeFieldMapper.CONTENT_TYPE) == false) {\n+        if (!validContentTypes().contains(fieldType.typeName())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA0MjI4Ng=="}, "originalCommit": {"oid": "83bdc937d79d09bbfb730a5a4ef5a8daadec23fc"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4ODI1MTg1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/query/ShapeQueryBuilder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxMDoxNDozNlrOFvv5zA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxMDo1ODo0M1rOFvxK7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTYxMjIzNg==", "bodyText": "== false", "url": "https://github.com/elastic/elasticsearch/pull/52382#discussion_r385612236", "createdAt": "2020-02-28T10:14:36Z", "author": {"login": "iverase"}, "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/query/ShapeQueryBuilder.java", "diffHunk": "@@ -100,23 +100,19 @@ protected ShapeQueryBuilder newShapeQueryBuilder(String fieldName, Supplier<Geom\n         return new ShapeQueryBuilder(fieldName, shapeSupplier, indexedShapeId);\n     }\n \n-    @Override\n-    public String queryFieldType() {\n-        return ShapeFieldMapper.CONTENT_TYPE;\n-    }\n-\n     @Override\n     @SuppressWarnings({ \"rawtypes\" })\n-    protected List validContentTypes() {\n+    protected List<String> validContentTypes(){\n         return Arrays.asList(ShapeFieldMapper.CONTENT_TYPE);\n     }\n \n     @Override\n     @SuppressWarnings({ \"rawtypes\" })\n     public Query buildShapeQuery(QueryShardContext context, MappedFieldType fieldType) {\n-        if (fieldType.typeName().equals(ShapeFieldMapper.CONTENT_TYPE) == false) {\n+        if (!validContentTypes().contains(fieldType.typeName())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc609787df1ce3eec2f9cece66220ccf813b631d"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTYzMzAwNg==", "bodyText": "Done", "url": "https://github.com/elastic/elasticsearch/pull/52382#discussion_r385633006", "createdAt": "2020-02-28T10:58:43Z", "author": {"login": "djptek"}, "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/query/ShapeQueryBuilder.java", "diffHunk": "@@ -100,23 +100,19 @@ protected ShapeQueryBuilder newShapeQueryBuilder(String fieldName, Supplier<Geom\n         return new ShapeQueryBuilder(fieldName, shapeSupplier, indexedShapeId);\n     }\n \n-    @Override\n-    public String queryFieldType() {\n-        return ShapeFieldMapper.CONTENT_TYPE;\n-    }\n-\n     @Override\n     @SuppressWarnings({ \"rawtypes\" })\n-    protected List validContentTypes() {\n+    protected List<String> validContentTypes(){\n         return Arrays.asList(ShapeFieldMapper.CONTENT_TYPE);\n     }\n \n     @Override\n     @SuppressWarnings({ \"rawtypes\" })\n     public Query buildShapeQuery(QueryShardContext context, MappedFieldType fieldType) {\n-        if (fieldType.typeName().equals(ShapeFieldMapper.CONTENT_TYPE) == false) {\n+        if (!validContentTypes().contains(fieldType.typeName())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTYxMjIzNg=="}, "originalCommit": {"oid": "fc609787df1ce3eec2f9cece66220ccf813b631d"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5MDg4MDMzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/query/VectorGeoPointShapeQueryProcessor.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOVQwOTowOTo1MFrOFwIciw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOVQyMjozOTo1N1rOFwLRWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAxNDM0Nw==", "bodyText": "The second loop is not necessary. You can just create one collector and pass the same array to the decomposer.", "url": "https://github.com/elastic/elasticsearch/pull/52382#discussion_r386014347", "createdAt": "2020-02-29T09:09:50Z", "author": {"login": "iverase"}, "path": "server/src/main/java/org/elasticsearch/index/query/VectorGeoPointShapeQueryProcessor.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.query;\n+\n+import org.apache.lucene.document.LatLonPoint;\n+import org.apache.lucene.search.BooleanClause;\n+import org.apache.lucene.search.BooleanQuery;\n+import org.apache.lucene.search.Query;\n+import org.elasticsearch.common.geo.GeoPolygonDecomposer;\n+import org.elasticsearch.common.geo.GeoShapeType;\n+import org.elasticsearch.common.geo.ShapeRelation;\n+import org.elasticsearch.geometry.Circle;\n+import org.elasticsearch.geometry.Geometry;\n+import org.elasticsearch.geometry.GeometryCollection;\n+import org.elasticsearch.geometry.GeometryVisitor;\n+import org.elasticsearch.geometry.LinearRing;\n+import org.elasticsearch.geometry.MultiLine;\n+import org.elasticsearch.geometry.MultiPoint;\n+import org.elasticsearch.geometry.MultiPolygon;\n+import org.elasticsearch.geometry.Point;\n+import org.elasticsearch.geometry.Rectangle;\n+import org.elasticsearch.geometry.ShapeType;\n+import org.elasticsearch.index.mapper.AbstractGeometryFieldMapper;\n+import org.elasticsearch.index.mapper.GeoPointFieldMapper;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+\n+import java.util.ArrayList;\n+\n+import static org.elasticsearch.index.mapper.GeoShapeIndexer.toLucenePolygon;\n+\n+public class VectorGeoPointShapeQueryProcessor implements AbstractGeometryFieldMapper.QueryProcessor {\n+\n+    @Override\n+    public Query process(Geometry shape, String fieldName, ShapeRelation relation, QueryShardContext context) {\n+        validateIsGeoPointFieldType(fieldName, context);\n+        // geo points only support intersects\n+        if (relation != ShapeRelation.INTERSECTS) {\n+            throw new QueryShardException(context,\n+                relation+ \" query relation not supported for Field [\" + fieldName + \"].\");\n+        }\n+        // wrap geoQuery as a ConstantScoreQuery\n+        return getVectorQueryFromShape(shape, fieldName, relation, context);\n+    }\n+\n+    private void validateIsGeoPointFieldType(String fieldName, QueryShardContext context) {\n+        MappedFieldType fieldType = context.fieldMapper(fieldName);\n+        if (fieldType instanceof GeoPointFieldMapper.GeoPointFieldType == false) {\n+            throw new QueryShardException(context, \"Expected \" + GeoPointFieldMapper.CONTENT_TYPE\n+                + \" field type for Field [\" + fieldName + \"] but found \" + fieldType.typeName());\n+        }\n+    }\n+\n+    protected Query getVectorQueryFromShape(\n+        Geometry queryShape, String fieldName, ShapeRelation relation, QueryShardContext context) {\n+        ShapeVisitor shapeVisitor = new ShapeVisitor(context, fieldName, relation);\n+        return queryShape.visit(shapeVisitor);\n+    }\n+\n+    private class ShapeVisitor implements GeometryVisitor<Query, RuntimeException> {\n+        QueryShardContext context;\n+        MappedFieldType fieldType;\n+        String fieldName;\n+        ShapeRelation relation;\n+\n+        ShapeVisitor(QueryShardContext context, String fieldName, ShapeRelation relation) {\n+            this.context = context;\n+            this.fieldType = context.fieldMapper(fieldName);\n+            this.fieldName = fieldName;\n+            this.relation = relation;\n+        }\n+\n+        @Override\n+        public Query visit(Circle circle) {\n+            return LatLonPoint.newDistanceQuery(fieldName, circle.getLat(), circle.getLon(), circle.getRadiusMeters());\n+        }\n+\n+        @Override\n+        public Query visit(GeometryCollection<?> collection) {\n+            BooleanQuery.Builder bqb = new BooleanQuery.Builder();\n+            visit(bqb, collection);\n+            return bqb.build();\n+        }\n+\n+        private void visit(BooleanQuery.Builder bqb, GeometryCollection<?> collection) {\n+            BooleanClause.Occur occur = BooleanClause.Occur.FILTER;\n+            for (Geometry shape : collection) {\n+                bqb.add(shape.visit(this), occur);\n+            }\n+        }\n+\n+        @Override\n+        public Query visit(org.elasticsearch.geometry.Line line) {\n+            throw new QueryShardException(context, \"Field [\" + fieldName + \"] does not support \"\n+                + GeoShapeType.LINESTRING + \" queries\");\n+        }\n+\n+        @Override\n+        // don't think this is called directly\n+        public Query visit(LinearRing ring) {\n+            throw new QueryShardException(context, \"Field [\" + fieldName + \"] does not support \"\n+                + ShapeType.LINEARRING + \" queries\");\n+        }\n+\n+        @Override\n+        public Query visit(MultiLine multiLine) {\n+            throw new QueryShardException(context, \"Field [\" + fieldName + \"] does not support \"\n+                + GeoShapeType.MULTILINESTRING + \" queries\");\n+        }\n+\n+        @Override\n+        public Query visit(MultiPoint multiPoint) {\n+            throw new QueryShardException(context, \"Field [\" + fieldName + \"] does not support \"\n+                + GeoShapeType.MULTIPOINT + \" queries\");\n+        }\n+\n+        @Override\n+        public Query visit(MultiPolygon multiPolygon) {\n+            ArrayList<org.apache.lucene.geo.Polygon> polygonArrayList = new ArrayList<>();\n+            for (int i = 0; i < multiPolygon.size(); i++) {\n+                ArrayList<org.elasticsearch.geometry.Polygon> collector = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b98a6a9d300613cdcb184ac6be1d2eca488b24be"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAxNjYyMg==", "bodyText": "I took a look inside the decomposer and saw that could work - my concern was that a future modification to the decomposer could potentially modify rather than append to the collector. I've moved the second loop out to unpack the collector to an array via toLucenePolygon()", "url": "https://github.com/elastic/elasticsearch/pull/52382#discussion_r386016622", "createdAt": "2020-02-29T09:51:30Z", "author": {"login": "djptek"}, "path": "server/src/main/java/org/elasticsearch/index/query/VectorGeoPointShapeQueryProcessor.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.query;\n+\n+import org.apache.lucene.document.LatLonPoint;\n+import org.apache.lucene.search.BooleanClause;\n+import org.apache.lucene.search.BooleanQuery;\n+import org.apache.lucene.search.Query;\n+import org.elasticsearch.common.geo.GeoPolygonDecomposer;\n+import org.elasticsearch.common.geo.GeoShapeType;\n+import org.elasticsearch.common.geo.ShapeRelation;\n+import org.elasticsearch.geometry.Circle;\n+import org.elasticsearch.geometry.Geometry;\n+import org.elasticsearch.geometry.GeometryCollection;\n+import org.elasticsearch.geometry.GeometryVisitor;\n+import org.elasticsearch.geometry.LinearRing;\n+import org.elasticsearch.geometry.MultiLine;\n+import org.elasticsearch.geometry.MultiPoint;\n+import org.elasticsearch.geometry.MultiPolygon;\n+import org.elasticsearch.geometry.Point;\n+import org.elasticsearch.geometry.Rectangle;\n+import org.elasticsearch.geometry.ShapeType;\n+import org.elasticsearch.index.mapper.AbstractGeometryFieldMapper;\n+import org.elasticsearch.index.mapper.GeoPointFieldMapper;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+\n+import java.util.ArrayList;\n+\n+import static org.elasticsearch.index.mapper.GeoShapeIndexer.toLucenePolygon;\n+\n+public class VectorGeoPointShapeQueryProcessor implements AbstractGeometryFieldMapper.QueryProcessor {\n+\n+    @Override\n+    public Query process(Geometry shape, String fieldName, ShapeRelation relation, QueryShardContext context) {\n+        validateIsGeoPointFieldType(fieldName, context);\n+        // geo points only support intersects\n+        if (relation != ShapeRelation.INTERSECTS) {\n+            throw new QueryShardException(context,\n+                relation+ \" query relation not supported for Field [\" + fieldName + \"].\");\n+        }\n+        // wrap geoQuery as a ConstantScoreQuery\n+        return getVectorQueryFromShape(shape, fieldName, relation, context);\n+    }\n+\n+    private void validateIsGeoPointFieldType(String fieldName, QueryShardContext context) {\n+        MappedFieldType fieldType = context.fieldMapper(fieldName);\n+        if (fieldType instanceof GeoPointFieldMapper.GeoPointFieldType == false) {\n+            throw new QueryShardException(context, \"Expected \" + GeoPointFieldMapper.CONTENT_TYPE\n+                + \" field type for Field [\" + fieldName + \"] but found \" + fieldType.typeName());\n+        }\n+    }\n+\n+    protected Query getVectorQueryFromShape(\n+        Geometry queryShape, String fieldName, ShapeRelation relation, QueryShardContext context) {\n+        ShapeVisitor shapeVisitor = new ShapeVisitor(context, fieldName, relation);\n+        return queryShape.visit(shapeVisitor);\n+    }\n+\n+    private class ShapeVisitor implements GeometryVisitor<Query, RuntimeException> {\n+        QueryShardContext context;\n+        MappedFieldType fieldType;\n+        String fieldName;\n+        ShapeRelation relation;\n+\n+        ShapeVisitor(QueryShardContext context, String fieldName, ShapeRelation relation) {\n+            this.context = context;\n+            this.fieldType = context.fieldMapper(fieldName);\n+            this.fieldName = fieldName;\n+            this.relation = relation;\n+        }\n+\n+        @Override\n+        public Query visit(Circle circle) {\n+            return LatLonPoint.newDistanceQuery(fieldName, circle.getLat(), circle.getLon(), circle.getRadiusMeters());\n+        }\n+\n+        @Override\n+        public Query visit(GeometryCollection<?> collection) {\n+            BooleanQuery.Builder bqb = new BooleanQuery.Builder();\n+            visit(bqb, collection);\n+            return bqb.build();\n+        }\n+\n+        private void visit(BooleanQuery.Builder bqb, GeometryCollection<?> collection) {\n+            BooleanClause.Occur occur = BooleanClause.Occur.FILTER;\n+            for (Geometry shape : collection) {\n+                bqb.add(shape.visit(this), occur);\n+            }\n+        }\n+\n+        @Override\n+        public Query visit(org.elasticsearch.geometry.Line line) {\n+            throw new QueryShardException(context, \"Field [\" + fieldName + \"] does not support \"\n+                + GeoShapeType.LINESTRING + \" queries\");\n+        }\n+\n+        @Override\n+        // don't think this is called directly\n+        public Query visit(LinearRing ring) {\n+            throw new QueryShardException(context, \"Field [\" + fieldName + \"] does not support \"\n+                + ShapeType.LINEARRING + \" queries\");\n+        }\n+\n+        @Override\n+        public Query visit(MultiLine multiLine) {\n+            throw new QueryShardException(context, \"Field [\" + fieldName + \"] does not support \"\n+                + GeoShapeType.MULTILINESTRING + \" queries\");\n+        }\n+\n+        @Override\n+        public Query visit(MultiPoint multiPoint) {\n+            throw new QueryShardException(context, \"Field [\" + fieldName + \"] does not support \"\n+                + GeoShapeType.MULTIPOINT + \" queries\");\n+        }\n+\n+        @Override\n+        public Query visit(MultiPolygon multiPolygon) {\n+            ArrayList<org.apache.lucene.geo.Polygon> polygonArrayList = new ArrayList<>();\n+            for (int i = 0; i < multiPolygon.size(); i++) {\n+                ArrayList<org.elasticsearch.geometry.Polygon> collector = new ArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAxNDM0Nw=="}, "originalCommit": {"oid": "b98a6a9d300613cdcb184ac6be1d2eca488b24be"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAzNTY4NA==", "bodyText": "The idea to have a collector is that, you do not need to create many lists. Actually I think the decomposer has a method that accepts a Muti-polygon so even this loop is not necessary?", "url": "https://github.com/elastic/elasticsearch/pull/52382#discussion_r386035684", "createdAt": "2020-02-29T15:37:20Z", "author": {"login": "iverase"}, "path": "server/src/main/java/org/elasticsearch/index/query/VectorGeoPointShapeQueryProcessor.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.query;\n+\n+import org.apache.lucene.document.LatLonPoint;\n+import org.apache.lucene.search.BooleanClause;\n+import org.apache.lucene.search.BooleanQuery;\n+import org.apache.lucene.search.Query;\n+import org.elasticsearch.common.geo.GeoPolygonDecomposer;\n+import org.elasticsearch.common.geo.GeoShapeType;\n+import org.elasticsearch.common.geo.ShapeRelation;\n+import org.elasticsearch.geometry.Circle;\n+import org.elasticsearch.geometry.Geometry;\n+import org.elasticsearch.geometry.GeometryCollection;\n+import org.elasticsearch.geometry.GeometryVisitor;\n+import org.elasticsearch.geometry.LinearRing;\n+import org.elasticsearch.geometry.MultiLine;\n+import org.elasticsearch.geometry.MultiPoint;\n+import org.elasticsearch.geometry.MultiPolygon;\n+import org.elasticsearch.geometry.Point;\n+import org.elasticsearch.geometry.Rectangle;\n+import org.elasticsearch.geometry.ShapeType;\n+import org.elasticsearch.index.mapper.AbstractGeometryFieldMapper;\n+import org.elasticsearch.index.mapper.GeoPointFieldMapper;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+\n+import java.util.ArrayList;\n+\n+import static org.elasticsearch.index.mapper.GeoShapeIndexer.toLucenePolygon;\n+\n+public class VectorGeoPointShapeQueryProcessor implements AbstractGeometryFieldMapper.QueryProcessor {\n+\n+    @Override\n+    public Query process(Geometry shape, String fieldName, ShapeRelation relation, QueryShardContext context) {\n+        validateIsGeoPointFieldType(fieldName, context);\n+        // geo points only support intersects\n+        if (relation != ShapeRelation.INTERSECTS) {\n+            throw new QueryShardException(context,\n+                relation+ \" query relation not supported for Field [\" + fieldName + \"].\");\n+        }\n+        // wrap geoQuery as a ConstantScoreQuery\n+        return getVectorQueryFromShape(shape, fieldName, relation, context);\n+    }\n+\n+    private void validateIsGeoPointFieldType(String fieldName, QueryShardContext context) {\n+        MappedFieldType fieldType = context.fieldMapper(fieldName);\n+        if (fieldType instanceof GeoPointFieldMapper.GeoPointFieldType == false) {\n+            throw new QueryShardException(context, \"Expected \" + GeoPointFieldMapper.CONTENT_TYPE\n+                + \" field type for Field [\" + fieldName + \"] but found \" + fieldType.typeName());\n+        }\n+    }\n+\n+    protected Query getVectorQueryFromShape(\n+        Geometry queryShape, String fieldName, ShapeRelation relation, QueryShardContext context) {\n+        ShapeVisitor shapeVisitor = new ShapeVisitor(context, fieldName, relation);\n+        return queryShape.visit(shapeVisitor);\n+    }\n+\n+    private class ShapeVisitor implements GeometryVisitor<Query, RuntimeException> {\n+        QueryShardContext context;\n+        MappedFieldType fieldType;\n+        String fieldName;\n+        ShapeRelation relation;\n+\n+        ShapeVisitor(QueryShardContext context, String fieldName, ShapeRelation relation) {\n+            this.context = context;\n+            this.fieldType = context.fieldMapper(fieldName);\n+            this.fieldName = fieldName;\n+            this.relation = relation;\n+        }\n+\n+        @Override\n+        public Query visit(Circle circle) {\n+            return LatLonPoint.newDistanceQuery(fieldName, circle.getLat(), circle.getLon(), circle.getRadiusMeters());\n+        }\n+\n+        @Override\n+        public Query visit(GeometryCollection<?> collection) {\n+            BooleanQuery.Builder bqb = new BooleanQuery.Builder();\n+            visit(bqb, collection);\n+            return bqb.build();\n+        }\n+\n+        private void visit(BooleanQuery.Builder bqb, GeometryCollection<?> collection) {\n+            BooleanClause.Occur occur = BooleanClause.Occur.FILTER;\n+            for (Geometry shape : collection) {\n+                bqb.add(shape.visit(this), occur);\n+            }\n+        }\n+\n+        @Override\n+        public Query visit(org.elasticsearch.geometry.Line line) {\n+            throw new QueryShardException(context, \"Field [\" + fieldName + \"] does not support \"\n+                + GeoShapeType.LINESTRING + \" queries\");\n+        }\n+\n+        @Override\n+        // don't think this is called directly\n+        public Query visit(LinearRing ring) {\n+            throw new QueryShardException(context, \"Field [\" + fieldName + \"] does not support \"\n+                + ShapeType.LINEARRING + \" queries\");\n+        }\n+\n+        @Override\n+        public Query visit(MultiLine multiLine) {\n+            throw new QueryShardException(context, \"Field [\" + fieldName + \"] does not support \"\n+                + GeoShapeType.MULTILINESTRING + \" queries\");\n+        }\n+\n+        @Override\n+        public Query visit(MultiPoint multiPoint) {\n+            throw new QueryShardException(context, \"Field [\" + fieldName + \"] does not support \"\n+                + GeoShapeType.MULTIPOINT + \" queries\");\n+        }\n+\n+        @Override\n+        public Query visit(MultiPolygon multiPolygon) {\n+            ArrayList<org.apache.lucene.geo.Polygon> polygonArrayList = new ArrayList<>();\n+            for (int i = 0; i < multiPolygon.size(); i++) {\n+                ArrayList<org.elasticsearch.geometry.Polygon> collector = new ArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAxNDM0Nw=="}, "originalCommit": {"oid": "b98a6a9d300613cdcb184ac6be1d2eca488b24be"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjA2MDYzNA==", "bodyText": "my bad, I hadn't seen that one, I've moved that to  GeoPolygonDecomposer.decomposeMultiPolygon", "url": "https://github.com/elastic/elasticsearch/pull/52382#discussion_r386060634", "createdAt": "2020-02-29T22:39:57Z", "author": {"login": "djptek"}, "path": "server/src/main/java/org/elasticsearch/index/query/VectorGeoPointShapeQueryProcessor.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.query;\n+\n+import org.apache.lucene.document.LatLonPoint;\n+import org.apache.lucene.search.BooleanClause;\n+import org.apache.lucene.search.BooleanQuery;\n+import org.apache.lucene.search.Query;\n+import org.elasticsearch.common.geo.GeoPolygonDecomposer;\n+import org.elasticsearch.common.geo.GeoShapeType;\n+import org.elasticsearch.common.geo.ShapeRelation;\n+import org.elasticsearch.geometry.Circle;\n+import org.elasticsearch.geometry.Geometry;\n+import org.elasticsearch.geometry.GeometryCollection;\n+import org.elasticsearch.geometry.GeometryVisitor;\n+import org.elasticsearch.geometry.LinearRing;\n+import org.elasticsearch.geometry.MultiLine;\n+import org.elasticsearch.geometry.MultiPoint;\n+import org.elasticsearch.geometry.MultiPolygon;\n+import org.elasticsearch.geometry.Point;\n+import org.elasticsearch.geometry.Rectangle;\n+import org.elasticsearch.geometry.ShapeType;\n+import org.elasticsearch.index.mapper.AbstractGeometryFieldMapper;\n+import org.elasticsearch.index.mapper.GeoPointFieldMapper;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+\n+import java.util.ArrayList;\n+\n+import static org.elasticsearch.index.mapper.GeoShapeIndexer.toLucenePolygon;\n+\n+public class VectorGeoPointShapeQueryProcessor implements AbstractGeometryFieldMapper.QueryProcessor {\n+\n+    @Override\n+    public Query process(Geometry shape, String fieldName, ShapeRelation relation, QueryShardContext context) {\n+        validateIsGeoPointFieldType(fieldName, context);\n+        // geo points only support intersects\n+        if (relation != ShapeRelation.INTERSECTS) {\n+            throw new QueryShardException(context,\n+                relation+ \" query relation not supported for Field [\" + fieldName + \"].\");\n+        }\n+        // wrap geoQuery as a ConstantScoreQuery\n+        return getVectorQueryFromShape(shape, fieldName, relation, context);\n+    }\n+\n+    private void validateIsGeoPointFieldType(String fieldName, QueryShardContext context) {\n+        MappedFieldType fieldType = context.fieldMapper(fieldName);\n+        if (fieldType instanceof GeoPointFieldMapper.GeoPointFieldType == false) {\n+            throw new QueryShardException(context, \"Expected \" + GeoPointFieldMapper.CONTENT_TYPE\n+                + \" field type for Field [\" + fieldName + \"] but found \" + fieldType.typeName());\n+        }\n+    }\n+\n+    protected Query getVectorQueryFromShape(\n+        Geometry queryShape, String fieldName, ShapeRelation relation, QueryShardContext context) {\n+        ShapeVisitor shapeVisitor = new ShapeVisitor(context, fieldName, relation);\n+        return queryShape.visit(shapeVisitor);\n+    }\n+\n+    private class ShapeVisitor implements GeometryVisitor<Query, RuntimeException> {\n+        QueryShardContext context;\n+        MappedFieldType fieldType;\n+        String fieldName;\n+        ShapeRelation relation;\n+\n+        ShapeVisitor(QueryShardContext context, String fieldName, ShapeRelation relation) {\n+            this.context = context;\n+            this.fieldType = context.fieldMapper(fieldName);\n+            this.fieldName = fieldName;\n+            this.relation = relation;\n+        }\n+\n+        @Override\n+        public Query visit(Circle circle) {\n+            return LatLonPoint.newDistanceQuery(fieldName, circle.getLat(), circle.getLon(), circle.getRadiusMeters());\n+        }\n+\n+        @Override\n+        public Query visit(GeometryCollection<?> collection) {\n+            BooleanQuery.Builder bqb = new BooleanQuery.Builder();\n+            visit(bqb, collection);\n+            return bqb.build();\n+        }\n+\n+        private void visit(BooleanQuery.Builder bqb, GeometryCollection<?> collection) {\n+            BooleanClause.Occur occur = BooleanClause.Occur.FILTER;\n+            for (Geometry shape : collection) {\n+                bqb.add(shape.visit(this), occur);\n+            }\n+        }\n+\n+        @Override\n+        public Query visit(org.elasticsearch.geometry.Line line) {\n+            throw new QueryShardException(context, \"Field [\" + fieldName + \"] does not support \"\n+                + GeoShapeType.LINESTRING + \" queries\");\n+        }\n+\n+        @Override\n+        // don't think this is called directly\n+        public Query visit(LinearRing ring) {\n+            throw new QueryShardException(context, \"Field [\" + fieldName + \"] does not support \"\n+                + ShapeType.LINEARRING + \" queries\");\n+        }\n+\n+        @Override\n+        public Query visit(MultiLine multiLine) {\n+            throw new QueryShardException(context, \"Field [\" + fieldName + \"] does not support \"\n+                + GeoShapeType.MULTILINESTRING + \" queries\");\n+        }\n+\n+        @Override\n+        public Query visit(MultiPoint multiPoint) {\n+            throw new QueryShardException(context, \"Field [\" + fieldName + \"] does not support \"\n+                + GeoShapeType.MULTIPOINT + \" queries\");\n+        }\n+\n+        @Override\n+        public Query visit(MultiPolygon multiPolygon) {\n+            ArrayList<org.apache.lucene.geo.Polygon> polygonArrayList = new ArrayList<>();\n+            for (int i = 0; i < multiPolygon.size(); i++) {\n+                ArrayList<org.elasticsearch.geometry.Polygon> collector = new ArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAxNDM0Nw=="}, "originalCommit": {"oid": "b98a6a9d300613cdcb184ac6be1d2eca488b24be"}, "originalPosition": 137}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5MjcxMTk1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/query/VectorGeoShapeQueryProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQwOTowMDoyMlrOFwXunA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxNjoxNzo0MlrOFwlw6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjI2NDczMg==", "bodyText": "left over from merging?", "url": "https://github.com/elastic/elasticsearch/pull/52382#discussion_r386264732", "createdAt": "2020-03-02T09:00:22Z", "author": {"login": "iverase"}, "path": "server/src/main/java/org/elasticsearch/index/query/VectorGeoShapeQueryProcessor.java", "diffHunk": "@@ -1,4 +1,4 @@\n-/*\n+/*uto-merging server/src/main/java/org/elasticsearch/index/mapper/GeoPointFieldMapper.java", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "024175390fb0ca1a87c2bf271f94f1e9c4ca4366"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ5NDY5Nw==", "bodyText": "fixed, thx", "url": "https://github.com/elastic/elasticsearch/pull/52382#discussion_r386494697", "createdAt": "2020-03-02T16:17:42Z", "author": {"login": "djptek"}, "path": "server/src/main/java/org/elasticsearch/index/query/VectorGeoShapeQueryProcessor.java", "diffHunk": "@@ -1,4 +1,4 @@\n-/*\n+/*uto-merging server/src/main/java/org/elasticsearch/index/mapper/GeoPointFieldMapper.java", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjI2NDczMg=="}, "originalCommit": {"oid": "024175390fb0ca1a87c2bf271f94f1e9c4ca4366"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5ODcyNjgwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/mapper/GeoPointFieldMapper.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxODowOToyOVrOFxQ1ig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNFQxOToyOTo1OFrOF2bMrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIwMDM5NA==", "bodyText": "That feels a bit awkward. I think that should go into  AbstractGeometryFieldMapper.AbstractGeometryFieldType if we need to clone it. I think the reason it is not cloned there already is that we override it always in setupFileds anyway. But cloning it in AbstractGeometryFieldType seems like a logical thing to do here.", "url": "https://github.com/elastic/elasticsearch/pull/52382#discussion_r387200394", "createdAt": "2020-03-03T18:09:29Z", "author": {"login": "imotov"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/GeoPointFieldMapper.java", "diffHunk": "@@ -213,12 +216,13 @@ protected void parseCreateField(ParseContext context, List<IndexableField> field\n         throw new UnsupportedOperationException(\"Parsing is implemented in parse(), this method should NEVER be called\");\n     }\n \n-    public static class GeoPointFieldType extends MappedFieldType {\n+    public static class GeoPointFieldType extends AbstractGeometryFieldMapper.AbstractGeometryFieldType<Geometry, Geometry> {\n         public GeoPointFieldType() {\n         }\n \n         GeoPointFieldType(GeoPointFieldType ref) {\n             super(ref);\n+            this.geometryQueryBuilder  = ref.geometryQueryBuilder;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "110f58fa5c5be62e0a99c57eb6bf9dc0c441f963"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMwNzgzMg==", "bodyText": "OK, on it", "url": "https://github.com/elastic/elasticsearch/pull/52382#discussion_r387307832", "createdAt": "2020-03-03T21:36:21Z", "author": {"login": "djptek"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/GeoPointFieldMapper.java", "diffHunk": "@@ -213,12 +216,13 @@ protected void parseCreateField(ParseContext context, List<IndexableField> field\n         throw new UnsupportedOperationException(\"Parsing is implemented in parse(), this method should NEVER be called\");\n     }\n \n-    public static class GeoPointFieldType extends MappedFieldType {\n+    public static class GeoPointFieldType extends AbstractGeometryFieldMapper.AbstractGeometryFieldType<Geometry, Geometry> {\n         public GeoPointFieldType() {\n         }\n \n         GeoPointFieldType(GeoPointFieldType ref) {\n             super(ref);\n+            this.geometryQueryBuilder  = ref.geometryQueryBuilder;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIwMDM5NA=="}, "originalCommit": {"oid": "110f58fa5c5be62e0a99c57eb6bf9dc0c441f963"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzc5OTA4Mg==", "bodyText": "still working on the refactor, if #53099 is a better alternative I'm fine to go with that", "url": "https://github.com/elastic/elasticsearch/pull/52382#discussion_r387799082", "createdAt": "2020-03-04T16:52:53Z", "author": {"login": "djptek"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/GeoPointFieldMapper.java", "diffHunk": "@@ -213,12 +216,13 @@ protected void parseCreateField(ParseContext context, List<IndexableField> field\n         throw new UnsupportedOperationException(\"Parsing is implemented in parse(), this method should NEVER be called\");\n     }\n \n-    public static class GeoPointFieldType extends MappedFieldType {\n+    public static class GeoPointFieldType extends AbstractGeometryFieldMapper.AbstractGeometryFieldType<Geometry, Geometry> {\n         public GeoPointFieldType() {\n         }\n \n         GeoPointFieldType(GeoPointFieldType ref) {\n             super(ref);\n+            this.geometryQueryBuilder  = ref.geometryQueryBuilder;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIwMDM5NA=="}, "originalCommit": {"oid": "110f58fa5c5be62e0a99c57eb6bf9dc0c441f963"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTU4NTk3Mw==", "bodyText": "@imotov @iverase I'm putting the refactor on hold pending outcome of review on #53099 which looks preferable to me, for the following reason: it looks like I'd also have to add SearchableGeometryQueryBuilder, which makes the Geo related classes in index.query diverge further from how the rest of the queries are built", "url": "https://github.com/elastic/elasticsearch/pull/52382#discussion_r389585973", "createdAt": "2020-03-09T10:51:22Z", "author": {"login": "djptek"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/GeoPointFieldMapper.java", "diffHunk": "@@ -213,12 +216,13 @@ protected void parseCreateField(ParseContext context, List<IndexableField> field\n         throw new UnsupportedOperationException(\"Parsing is implemented in parse(), this method should NEVER be called\");\n     }\n \n-    public static class GeoPointFieldType extends MappedFieldType {\n+    public static class GeoPointFieldType extends AbstractGeometryFieldMapper.AbstractGeometryFieldType<Geometry, Geometry> {\n         public GeoPointFieldType() {\n         }\n \n         GeoPointFieldType(GeoPointFieldType ref) {\n             super(ref);\n+            this.geometryQueryBuilder  = ref.geometryQueryBuilder;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIwMDM5NA=="}, "originalCommit": {"oid": "110f58fa5c5be62e0a99c57eb6bf9dc0c441f963"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjYxMzAzNg==", "bodyText": "Refactored with help from a patch from @iversase thanks!", "url": "https://github.com/elastic/elasticsearch/pull/52382#discussion_r392613036", "createdAt": "2020-03-14T19:29:58Z", "author": {"login": "djptek"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/GeoPointFieldMapper.java", "diffHunk": "@@ -213,12 +216,13 @@ protected void parseCreateField(ParseContext context, List<IndexableField> field\n         throw new UnsupportedOperationException(\"Parsing is implemented in parse(), this method should NEVER be called\");\n     }\n \n-    public static class GeoPointFieldType extends MappedFieldType {\n+    public static class GeoPointFieldType extends AbstractGeometryFieldMapper.AbstractGeometryFieldType<Geometry, Geometry> {\n         public GeoPointFieldType() {\n         }\n \n         GeoPointFieldType(GeoPointFieldType ref) {\n             super(ref);\n+            this.geometryQueryBuilder  = ref.geometryQueryBuilder;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIwMDM5NA=="}, "originalCommit": {"oid": "110f58fa5c5be62e0a99c57eb6bf9dc0c441f963"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMDA5NTI4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/mapper/AbstractGeometryFieldMapper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwODozODo1OVrOF17aGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwODozODo1OVrOF17aGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA5MjE4Ng==", "bodyText": "@djptek this is my fault but I think is more correct to call it AbstractSearchableGeometryFieldType?", "url": "https://github.com/elastic/elasticsearch/pull/52382#discussion_r392092186", "createdAt": "2020-03-13T08:38:59Z", "author": {"login": "iverase"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/AbstractGeometryFieldMapper.java", "diffHunk": "@@ -272,14 +272,33 @@ protected Builder newBuilder(String name, Map<String, Object> params) {\n         }\n     }\n \n-    public abstract static class AbstractGeometryFieldType<Parsed, Processed> extends MappedFieldType {\n+    public abstract static class AbstractSearcheableGeometryFieldType extends MappedFieldType {\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ca69654bd24ae360e4c2734d6a7d554a315e3f8"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMDA5ODI2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/mapper/AbstractGeometryFieldMapper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwODo0MDoxNVrOF17b7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwODo0MDoxNVrOF17b7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA5MjY1Mg==", "bodyText": "In this subclass we can remove setGeometryQueryBuilder and geometryQueryBuilder methods?", "url": "https://github.com/elastic/elasticsearch/pull/52382#discussion_r392092652", "createdAt": "2020-03-13T08:40:15Z", "author": {"login": "iverase"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/AbstractGeometryFieldMapper.java", "diffHunk": "@@ -272,14 +272,33 @@ protected Builder newBuilder(String name, Map<String, Object> params) {\n         }\n     }\n \n-    public abstract static class AbstractGeometryFieldType<Parsed, Processed> extends MappedFieldType {\n+    public abstract static class AbstractSearcheableGeometryFieldType extends MappedFieldType {\n+\n+        protected QueryProcessor geometryQueryBuilder;\n+\n+        protected AbstractSearcheableGeometryFieldType() {\n+        }\n+\n+        protected AbstractSearcheableGeometryFieldType(AbstractSearcheableGeometryFieldType ref) {\n+            super(ref);\n+        }\n+        public void setGeometryQueryBuilder(QueryProcessor geometryQueryBuilder)  {\n+            this.geometryQueryBuilder = geometryQueryBuilder;\n+        }\n+\n+        public QueryProcessor geometryQueryBuilder() {\n+            return geometryQueryBuilder;\n+        }\n+    }\n+\n+    public abstract static class AbstractGeometryFieldType<Parsed, Processed> extends AbstractSearcheableGeometryFieldType {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ca69654bd24ae360e4c2734d6a7d554a315e3f8"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMjU4MzY3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/mapper/AbstractGeometryFieldMapper.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QyMTozMTozNVrOF2TzlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QyMjozMTozNlrOF2VKlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQ5MTkyNQ==", "bodyText": "Since GeoPointFieldMapper doesn't inherit from AbstractGeometryFieldMapper I would prefer AbstractSearchableGeometryFieldType to be in a separate file. It's not longer confined to AbstractGeometryFieldMapper and its derivatives, so doesn't make much sense making it an inner class. It would be also good to add some javadocs to it explaining the purpose of this class for future readers. Basically, something as simple as \"a base class for geometry types that supports shape query builder\" should help.", "url": "https://github.com/elastic/elasticsearch/pull/52382#discussion_r392491925", "createdAt": "2020-03-13T21:31:35Z", "author": {"login": "imotov"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/AbstractGeometryFieldMapper.java", "diffHunk": "@@ -272,14 +272,34 @@ protected Builder newBuilder(String name, Map<String, Object> params) {\n         }\n     }\n \n-    public abstract static class AbstractGeometryFieldType<Parsed, Processed> extends MappedFieldType {\n+    public abstract static class AbstractSearchableGeometryFieldType extends MappedFieldType {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4251742678c4a72da0ac74d2daa5a151383c14ad"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUxNDE5Nw==", "bodyText": "thanks @imotov that's done", "url": "https://github.com/elastic/elasticsearch/pull/52382#discussion_r392514197", "createdAt": "2020-03-13T22:31:36Z", "author": {"login": "djptek"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/AbstractGeometryFieldMapper.java", "diffHunk": "@@ -272,14 +272,34 @@ protected Builder newBuilder(String name, Map<String, Object> params) {\n         }\n     }\n \n-    public abstract static class AbstractGeometryFieldType<Parsed, Processed> extends MappedFieldType {\n+    public abstract static class AbstractSearchableGeometryFieldType extends MappedFieldType {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQ5MTkyNQ=="}, "originalCommit": {"oid": "4251742678c4a72da0ac74d2daa5a151383c14ad"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMzEyMDgzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/mapper/AbstractSearchableGeometryFieldType.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNFQwODo0OTo0NlrOF2YhWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNFQxMDo1OTo1NVrOF2Y95w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU2OTE3Ng==", "bodyText": "Shouldn't be move the query processor interface in this class as well?", "url": "https://github.com/elastic/elasticsearch/pull/52382#discussion_r392569176", "createdAt": "2020-03-14T08:49:46Z", "author": {"login": "iverase"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/AbstractSearchableGeometryFieldType.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+/**\n+ * a base class for geometry types that support shape query builder\n+ */\n+public abstract class AbstractSearchableGeometryFieldType extends MappedFieldType {\n+\n+    protected AbstractGeometryFieldMapper.QueryProcessor geometryQueryBuilder;\n+\n+    protected AbstractSearchableGeometryFieldType() {\n+    }\n+\n+    protected AbstractSearchableGeometryFieldType(AbstractSearchableGeometryFieldType ref) {\n+        super(ref);\n+    }\n+\n+    public void setGeometryQueryBuilder(AbstractGeometryFieldMapper.QueryProcessor geometryQueryBuilder)  {\n+        this.geometryQueryBuilder = geometryQueryBuilder;\n+    }\n+\n+    public AbstractGeometryFieldMapper.QueryProcessor geometryQueryBuilder() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6358862b0d8e12ecf6af59be7a065b12e9c72b2a"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU3NjQ4Nw==", "bodyText": "@iverase done", "url": "https://github.com/elastic/elasticsearch/pull/52382#discussion_r392576487", "createdAt": "2020-03-14T10:59:55Z", "author": {"login": "djptek"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/AbstractSearchableGeometryFieldType.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+/**\n+ * a base class for geometry types that support shape query builder\n+ */\n+public abstract class AbstractSearchableGeometryFieldType extends MappedFieldType {\n+\n+    protected AbstractGeometryFieldMapper.QueryProcessor geometryQueryBuilder;\n+\n+    protected AbstractSearchableGeometryFieldType() {\n+    }\n+\n+    protected AbstractSearchableGeometryFieldType(AbstractSearchableGeometryFieldType ref) {\n+        super(ref);\n+    }\n+\n+    public void setGeometryQueryBuilder(AbstractGeometryFieldMapper.QueryProcessor geometryQueryBuilder)  {\n+        this.geometryQueryBuilder = geometryQueryBuilder;\n+    }\n+\n+    public AbstractGeometryFieldMapper.QueryProcessor geometryQueryBuilder() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU2OTE3Ng=="}, "originalCommit": {"oid": "6358862b0d8e12ecf6af59be7a065b12e9c72b2a"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0MTAzNDQ0OnYy", "diffSide": "RIGHT", "path": "docs/reference/query-dsl/geo-shape-query.asciidoc", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxNjoyNzozMVrOF3kJjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxODowNzo0MVrOF3oIkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzgwODI3MQ==", "bodyText": "I think we will want to add a section explicitly listing which shape types are not supported for geo_point types:\n\nPOINT\nLINE\nMULTIPOINT\nMULTILINE\n\nAnd I think we can eventually add these as new LatLonPoint queries in Lucene by reusing our relate methods? Which would give us full parity. /cc @iverase", "url": "https://github.com/elastic/elasticsearch/pull/52382#discussion_r393808271", "createdAt": "2020-03-17T16:27:31Z", "author": {"login": "nknize"}, "path": "docs/reference/query-dsl/geo-shape-query.asciidoc", "diffHunk": "@@ -4,9 +4,9 @@\n <titleabbrev>Geo-shape</titleabbrev>\n ++++\n \n-Filter documents indexed using the `geo_shape` type.\n+Filter documents indexed using the `geo_shape` or `geo_point` type.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01548bb8db6184a9af8776e2a244c8726f958946"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg2MzAwMg==", "bodyText": "Added to Documentation", "url": "https://github.com/elastic/elasticsearch/pull/52382#discussion_r393863002", "createdAt": "2020-03-17T17:50:49Z", "author": {"login": "djptek"}, "path": "docs/reference/query-dsl/geo-shape-query.asciidoc", "diffHunk": "@@ -4,9 +4,9 @@\n <titleabbrev>Geo-shape</titleabbrev>\n ++++\n \n-Filter documents indexed using the `geo_shape` type.\n+Filter documents indexed using the `geo_shape` or `geo_point` type.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzgwODI3MQ=="}, "originalCommit": {"oid": "01548bb8db6184a9af8776e2a244c8726f958946"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg3MzU1NA==", "bodyText": "\ud83e\udd47", "url": "https://github.com/elastic/elasticsearch/pull/52382#discussion_r393873554", "createdAt": "2020-03-17T18:07:41Z", "author": {"login": "nknize"}, "path": "docs/reference/query-dsl/geo-shape-query.asciidoc", "diffHunk": "@@ -4,9 +4,9 @@\n <titleabbrev>Geo-shape</titleabbrev>\n ++++\n \n-Filter documents indexed using the `geo_shape` type.\n+Filter documents indexed using the `geo_shape` or `geo_point` type.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzgwODI3MQ=="}, "originalCommit": {"oid": "01548bb8db6184a9af8776e2a244c8726f958946"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0MTA0Mzc5OnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/elasticsearch/index/query/GeoShapeQueryBuilderGeoPointTests.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxNjoyOTo0OFrOF3kPyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxNjoyOTo0OFrOF3kPyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzgwOTg2Ng==", "bodyText": "I think we should we add testing for GeometryCollection. But I'm okay with it coming in a separate PR.", "url": "https://github.com/elastic/elasticsearch/pull/52382#discussion_r393809866", "createdAt": "2020-03-17T16:29:48Z", "author": {"login": "nknize"}, "path": "server/src/test/java/org/elasticsearch/index/query/GeoShapeQueryBuilderGeoPointTests.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.index.query;\n+\n+import org.elasticsearch.common.geo.ShapeRelation;\n+import org.elasticsearch.common.geo.builders.ShapeBuilder;\n+import org.elasticsearch.test.geo.RandomShapeGenerator;\n+\n+public class GeoShapeQueryBuilderGeoPointTests extends GeoShapeQueryBuilderTests {\n+\n+    protected String fieldName() {\n+        return GEO_POINT_FIELD_NAME;\n+    }\n+\n+    protected GeoShapeQueryBuilder doCreateTestQueryBuilder(boolean indexedShape) {\n+        RandomShapeGenerator.ShapeType shapeType = RandomShapeGenerator.ShapeType.POLYGON;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01548bb8db6184a9af8776e2a244c8726f958946"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0MTA0NjM2OnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/elasticsearch/index/query/GeoShapeQueryBuilderGeoShapeTests.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxNjozMDoyNFrOF3kReg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxNjozMDoyNFrOF3kReg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzgxMDI5OA==", "bodyText": "Lets add support here for GeometryCollection as well (separate PR is fine).", "url": "https://github.com/elastic/elasticsearch/pull/52382#discussion_r393810298", "createdAt": "2020-03-17T16:30:24Z", "author": {"login": "nknize"}, "path": "server/src/test/java/org/elasticsearch/index/query/GeoShapeQueryBuilderGeoShapeTests.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.index.query;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.geo.ShapeRelation;\n+import org.elasticsearch.common.geo.builders.ShapeBuilder;\n+import org.elasticsearch.test.geo.RandomShapeGenerator;\n+\n+public class GeoShapeQueryBuilderGeoShapeTests extends GeoShapeQueryBuilderTests {\n+\n+    protected String fieldName() {\n+        return GEO_SHAPE_FIELD_NAME;\n+    }\n+\n+    protected GeoShapeQueryBuilder doCreateTestQueryBuilder(boolean indexedShape) {\n+        RandomShapeGenerator.ShapeType shapeType = randomFrom(\n+            RandomShapeGenerator.ShapeType.POINT,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01548bb8db6184a9af8776e2a244c8726f958946"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0MTA1MTU5OnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/elasticsearch/search/geo/GeoPointShapeQueryTests.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxNjozMTo0OFrOF3kVFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxNzo1MDo1NVrOF3nfnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzgxMTIyMw==", "bodyText": "Same: lets add testing for GeometryCollection.", "url": "https://github.com/elastic/elasticsearch/pull/52382#discussion_r393811223", "createdAt": "2020-03-17T16:31:48Z", "author": {"login": "nknize"}, "path": "server/src/test/java/org/elasticsearch/search/geo/GeoPointShapeQueryTests.java", "diffHunk": "@@ -19,23 +19,158 @@\n \n package org.elasticsearch.search.geo;\n \n+import org.elasticsearch.action.search.SearchAction;\n+import org.elasticsearch.action.search.SearchPhaseExecutionException;\n+import org.elasticsearch.action.search.SearchRequestBuilder;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.geo.GeoShapeType;\n+import org.elasticsearch.common.geo.ShapeRelation;\n+import org.elasticsearch.common.geo.builders.CoordinatesBuilder;\n+import org.elasticsearch.common.geo.builders.LineStringBuilder;\n+import org.elasticsearch.common.geo.builders.MultiLineStringBuilder;\n+import org.elasticsearch.common.geo.builders.MultiPointBuilder;\n+import org.elasticsearch.common.geo.builders.PointBuilder;\n import org.elasticsearch.common.xcontent.XContentBuilder;\n import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.geometry.Line;\n+import org.elasticsearch.geometry.LinearRing;\n+import org.elasticsearch.geometry.MultiLine;\n+import org.elasticsearch.geometry.MultiPoint;\n+import org.elasticsearch.geometry.Point;\n+import org.elasticsearch.geometry.Rectangle;\n+import org.elasticsearch.index.query.GeoShapeQueryBuilder;\n+import org.elasticsearch.index.query.QueryBuilders;\n+\n+import static org.hamcrest.Matchers.containsString;\n \n public class GeoPointShapeQueryTests extends GeoQueryTests {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01548bb8db6184a9af8776e2a244c8726f958946"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg2MzA3MQ==", "bodyText": "Opened & self-assigned issue #53686", "url": "https://github.com/elastic/elasticsearch/pull/52382#discussion_r393863071", "createdAt": "2020-03-17T17:50:55Z", "author": {"login": "djptek"}, "path": "server/src/test/java/org/elasticsearch/search/geo/GeoPointShapeQueryTests.java", "diffHunk": "@@ -19,23 +19,158 @@\n \n package org.elasticsearch.search.geo;\n \n+import org.elasticsearch.action.search.SearchAction;\n+import org.elasticsearch.action.search.SearchPhaseExecutionException;\n+import org.elasticsearch.action.search.SearchRequestBuilder;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.geo.GeoShapeType;\n+import org.elasticsearch.common.geo.ShapeRelation;\n+import org.elasticsearch.common.geo.builders.CoordinatesBuilder;\n+import org.elasticsearch.common.geo.builders.LineStringBuilder;\n+import org.elasticsearch.common.geo.builders.MultiLineStringBuilder;\n+import org.elasticsearch.common.geo.builders.MultiPointBuilder;\n+import org.elasticsearch.common.geo.builders.PointBuilder;\n import org.elasticsearch.common.xcontent.XContentBuilder;\n import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.geometry.Line;\n+import org.elasticsearch.geometry.LinearRing;\n+import org.elasticsearch.geometry.MultiLine;\n+import org.elasticsearch.geometry.MultiPoint;\n+import org.elasticsearch.geometry.Point;\n+import org.elasticsearch.geometry.Rectangle;\n+import org.elasticsearch.index.query.GeoShapeQueryBuilder;\n+import org.elasticsearch.index.query.QueryBuilders;\n+\n+import static org.hamcrest.Matchers.containsString;\n \n public class GeoPointShapeQueryTests extends GeoQueryTests {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzgxMTIyMw=="}, "originalCommit": {"oid": "01548bb8db6184a9af8776e2a244c8726f958946"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0MTA2NTEyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/query/ShapeQueryBuilder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxNjozNToyMVrOF3keOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxNjozODozNlrOF3kmyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzgxMzU2Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (validContentTypes().contains(fieldType.typeName()) == false) {\n          \n          \n            \n                    List<String> validContentTypes = validContentTypes()\n          \n          \n            \n                    if (validContentTypes.contains(fieldType.typeName()) == false) {", "url": "https://github.com/elastic/elasticsearch/pull/52382#discussion_r393813563", "createdAt": "2020-03-17T16:35:21Z", "author": {"login": "nknize"}, "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/query/ShapeQueryBuilder.java", "diffHunk": "@@ -100,23 +100,19 @@ protected ShapeQueryBuilder newShapeQueryBuilder(String fieldName, Supplier<Geom\n         return new ShapeQueryBuilder(fieldName, shapeSupplier, indexedShapeId);\n     }\n \n-    @Override\n-    public String queryFieldType() {\n-        return ShapeFieldMapper.CONTENT_TYPE;\n-    }\n-\n     @Override\n     @SuppressWarnings({ \"rawtypes\" })\n-    protected List validContentTypes() {\n+    protected List<String> validContentTypes(){\n         return Arrays.asList(ShapeFieldMapper.CONTENT_TYPE);\n     }\n \n     @Override\n     @SuppressWarnings({ \"rawtypes\" })\n     public Query buildShapeQuery(QueryShardContext context, MappedFieldType fieldType) {\n-        if (fieldType.typeName().equals(ShapeFieldMapper.CONTENT_TYPE) == false) {\n+        if (validContentTypes().contains(fieldType.typeName()) == false) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01548bb8db6184a9af8776e2a244c8726f958946"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzgxNTc1NQ==", "bodyText": "I was afraid of this danger biting us. I'm not much a fan of validContentTypes() returning a new List instance for every call. So maybe we should consider making a static variable within each of the derived builders (that only calls this method once)? I'm okay changing that in a follow up PR, but lets change this method now to only call validContentTypes once.", "url": "https://github.com/elastic/elasticsearch/pull/52382#discussion_r393815755", "createdAt": "2020-03-17T16:38:36Z", "author": {"login": "nknize"}, "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/query/ShapeQueryBuilder.java", "diffHunk": "@@ -100,23 +100,19 @@ protected ShapeQueryBuilder newShapeQueryBuilder(String fieldName, Supplier<Geom\n         return new ShapeQueryBuilder(fieldName, shapeSupplier, indexedShapeId);\n     }\n \n-    @Override\n-    public String queryFieldType() {\n-        return ShapeFieldMapper.CONTENT_TYPE;\n-    }\n-\n     @Override\n     @SuppressWarnings({ \"rawtypes\" })\n-    protected List validContentTypes() {\n+    protected List<String> validContentTypes(){\n         return Arrays.asList(ShapeFieldMapper.CONTENT_TYPE);\n     }\n \n     @Override\n     @SuppressWarnings({ \"rawtypes\" })\n     public Query buildShapeQuery(QueryShardContext context, MappedFieldType fieldType) {\n-        if (fieldType.typeName().equals(ShapeFieldMapper.CONTENT_TYPE) == false) {\n+        if (validContentTypes().contains(fieldType.typeName()) == false) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzgxMzU2Mw=="}, "originalCommit": {"oid": "01548bb8db6184a9af8776e2a244c8726f958946"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0MTA2NzAxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/query/ShapeQueryBuilder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxNjozNTo1MlrOF3kfgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxNjozNTo1MlrOF3kfgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzgxMzg4OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            \"Field [\" + fieldName + \"] is not of type [\" + String.join(\" or \", validContentTypes())\n          \n          \n            \n                            \"Field [\" + fieldName + \"] is not of type [\" + String.join(\" or \", validContentTypes)", "url": "https://github.com/elastic/elasticsearch/pull/52382#discussion_r393813888", "createdAt": "2020-03-17T16:35:52Z", "author": {"login": "nknize"}, "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/query/ShapeQueryBuilder.java", "diffHunk": "@@ -100,23 +100,19 @@ protected ShapeQueryBuilder newShapeQueryBuilder(String fieldName, Supplier<Geom\n         return new ShapeQueryBuilder(fieldName, shapeSupplier, indexedShapeId);\n     }\n \n-    @Override\n-    public String queryFieldType() {\n-        return ShapeFieldMapper.CONTENT_TYPE;\n-    }\n-\n     @Override\n     @SuppressWarnings({ \"rawtypes\" })\n-    protected List validContentTypes() {\n+    protected List<String> validContentTypes(){\n         return Arrays.asList(ShapeFieldMapper.CONTENT_TYPE);\n     }\n \n     @Override\n     @SuppressWarnings({ \"rawtypes\" })\n     public Query buildShapeQuery(QueryShardContext context, MappedFieldType fieldType) {\n-        if (fieldType.typeName().equals(ShapeFieldMapper.CONTENT_TYPE) == false) {\n+        if (validContentTypes().contains(fieldType.typeName()) == false) {\n             throw new QueryShardException(context,\n-                \"Field [\" + fieldName + \"] is not of type [\" + queryFieldType() + \"] but of type [\" + fieldType.typeName() + \"]\");\n+                \"Field [\" + fieldName + \"] is not of type [\" + String.join(\" or \", validContentTypes())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01548bb8db6184a9af8776e2a244c8726f958946"}, "originalPosition": 23}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3906, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}