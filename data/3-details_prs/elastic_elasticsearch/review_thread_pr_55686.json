{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA4MDU1ODcz", "number": 55686, "reviewThreads": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNTozOTowNVrOD11dQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNjo1NTozNFrOD3SmJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3Nzc2OTYyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/template/post/SimulateIndexTemplateAction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNTozOTowNVrOGLdmQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNTozOTowNVrOGLdmQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY3MjQ0OQ==", "bodyText": "This could probably be\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final String NAME = \"indices:admin/index_template/simulate_index/post\";\n          \n          \n            \n                public static final String NAME = \"indices:admin/index_template/simulate_index\";", "url": "https://github.com/elastic/elasticsearch/pull/55686#discussion_r414672449", "createdAt": "2020-04-24T15:39:05Z", "author": {"login": "dakrone"}, "path": "server/src/main/java/org/elasticsearch/action/admin/indices/template/post/SimulateIndexTemplateAction.java", "diffHunk": "@@ -0,0 +1,33 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.admin.indices.template.post;\n+\n+import org.elasticsearch.action.ActionType;\n+\n+public class SimulateIndexTemplateAction extends ActionType<SimulateIndexTemplateResponse> {\n+\n+    public static final SimulateIndexTemplateAction INSTANCE = new SimulateIndexTemplateAction();\n+    public static final String NAME = \"indices:admin/index_template/simulate_index/post\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b98a59bd6fc8a36a3f57f6eb07a5c0f4c5a942e6"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3Nzc3NTQ5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/template/post/SimulateIndexTemplateRequest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNTo0MDoyNVrOGLdpwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNzoxNzo1NlrOGMul6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY3MzM0Ng==", "bodyText": "We've been collapsing the request and response objects into the action itself (for example in PutIndexTemplateV2Action), so if you want to, you can do that, otherwise a separate class is fine with me too.", "url": "https://github.com/elastic/elasticsearch/pull/55686#discussion_r414673346", "createdAt": "2020-04-24T15:40:25Z", "author": {"login": "dakrone"}, "path": "server/src/main/java/org/elasticsearch/action/admin/indices/template/post/SimulateIndexTemplateRequest.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.admin.indices.template.post;\n+\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.admin.indices.template.put.PutIndexTemplateV2Action;\n+import org.elasticsearch.action.support.master.MasterNodeReadRequest;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+\n+public class SimulateIndexTemplateRequest extends MasterNodeReadRequest<SimulateIndexTemplateRequest> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b98a59bd6fc8a36a3f57f6eb07a5c0f4c5a942e6"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY4ODU1Nw==", "bodyText": "I somehow found it hard to navigate to those classes, that's why I chose to have them standalone. I'd rather leave them like this if you don't have a strong opinion otherwise", "url": "https://github.com/elastic/elasticsearch/pull/55686#discussion_r415688557", "createdAt": "2020-04-27T10:16:32Z", "author": {"login": "andreidan"}, "path": "server/src/main/java/org/elasticsearch/action/admin/indices/template/post/SimulateIndexTemplateRequest.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.admin.indices.template.post;\n+\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.admin.indices.template.put.PutIndexTemplateV2Action;\n+import org.elasticsearch.action.support.master.MasterNodeReadRequest;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+\n+public class SimulateIndexTemplateRequest extends MasterNodeReadRequest<SimulateIndexTemplateRequest> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY3MzM0Ng=="}, "originalCommit": {"oid": "b98a59bd6fc8a36a3f57f6eb07a5c0f4c5a942e6"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk5OTQ2NA==", "bodyText": "That's totally fine with me", "url": "https://github.com/elastic/elasticsearch/pull/55686#discussion_r415999464", "createdAt": "2020-04-27T17:17:56Z", "author": {"login": "dakrone"}, "path": "server/src/main/java/org/elasticsearch/action/admin/indices/template/post/SimulateIndexTemplateRequest.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.admin.indices.template.post;\n+\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.admin.indices.template.put.PutIndexTemplateV2Action;\n+import org.elasticsearch.action.support.master.MasterNodeReadRequest;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+\n+public class SimulateIndexTemplateRequest extends MasterNodeReadRequest<SimulateIndexTemplateRequest> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY3MzM0Ng=="}, "originalCommit": {"oid": "b98a59bd6fc8a36a3f57f6eb07a5c0f4c5a942e6"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3OTI5MTUzOnYy", "diffSide": "RIGHT", "path": "rest-api-spec/src/main/resources/rest-api-spec/api/indices.simulate_index_template.json", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQyMjozMToxMFrOGLrahg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQyMjozMToxMFrOGLrahg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg5ODgyMg==", "bodyText": "Minor wording change\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                          \"description\":\"The name of the index (it will have to be a concrete index name)\"\n          \n          \n            \n                          \"description\":\"The name of the index (it must be a concrete index name)\"", "url": "https://github.com/elastic/elasticsearch/pull/55686#discussion_r414898822", "createdAt": "2020-04-24T22:31:10Z", "author": {"login": "dakrone"}, "path": "rest-api-spec/src/main/resources/rest-api-spec/api/indices.simulate_index_template.json", "diffHunk": "@@ -0,0 +1,35 @@\n+{\n+  \"indices.simulate_index_template\":{\n+    \"documentation\":{\n+      \"url\":\"https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html\",\n+      \"description\": \"Simulate matching the given index name against the index templates in the system\"\n+    },\n+    \"stability\":\"stable\",\n+    \"url\":{\n+      \"paths\":[\n+        {\n+          \"path\":\"/_index_template/_simulate_index/{name}\",\n+          \"methods\":[\n+            \"POST\"\n+          ],\n+          \"parts\":{\n+            \"name\":{\n+              \"type\":\"string\",\n+              \"description\":\"The name of the index (it will have to be a concrete index name)\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cbcc9770decf5ed6932fd4471786eb2fa710947b"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3OTMwOTc1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/template/post/SimulateIndexTemplateResponse.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQyMjozODo0MVrOGLrkaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxMjo0NDowNlrOGNSIjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkwMTM1Mw==", "bodyText": "I'm a little on the fence about this, on one hand it's good we tell users what overlap, on the other hand, maybe we don't want to keep this around for a long time with the phrase \"v1\" in it.\nWhat about including other V2 templates that could overlap here? And just calling it overlapping_templates? Or even expanding it to more information (that doesn't have to include the \"vN\" in the key name:\n\"overlapping\": [\n  { \n    \"name\": \"template_1\",\n    \"patterns\": [...],\n    \"priority\": 4,\n    \"type\": \"v1\"\n  }\n]\n\nWhat do you think? I'm wary of introducing the phrase \"v1\" for something we'll have to support for a very long time (past when \"v1\" templates are removed)", "url": "https://github.com/elastic/elasticsearch/pull/55686#discussion_r414901353", "createdAt": "2020-04-24T22:38:41Z", "author": {"login": "dakrone"}, "path": "server/src/main/java/org/elasticsearch/action/admin/indices/template/post/SimulateIndexTemplateResponse.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.admin.indices.template.post;\n+\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.cluster.metadata.Template;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * Contains the information on what V2 templates would match a given index.\n+ */\n+public class SimulateIndexTemplateResponse extends ActionResponse implements ToXContentObject {\n+\n+    private static final ParseField TEMPLATE = new ParseField(\"template\");\n+    private static final ParseField OVERLAPPING_V1_TEMPLATES = new ParseField(\"overlapping_v1_templates\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cbcc9770decf5ed6932fd4471786eb2fa710947b"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTcwNjY1Nw==", "bodyText": "I agree retiring the V1 concept will posses some problems. I do however question the utility of overlapping v2 templates though? (as, V2 templates don't overlap with V2 templates in the sense of some influencing the resulting mappings/settings of others, we have a clear winner)\nI think we might be offloading a bit of work to the user to make some sense of that field and filter out the V2 templates.\nWould it make sense to only call it \"overlapping\" and keep the current returned format and also keep only returning the V1 overlapping templates? Documenting this field accordingly.\nWhen V1 templates are retired this field will always be empty so the clients will also not break.", "url": "https://github.com/elastic/elasticsearch/pull/55686#discussion_r415706657", "createdAt": "2020-04-27T10:45:32Z", "author": {"login": "andreidan"}, "path": "server/src/main/java/org/elasticsearch/action/admin/indices/template/post/SimulateIndexTemplateResponse.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.admin.indices.template.post;\n+\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.cluster.metadata.Template;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * Contains the information on what V2 templates would match a given index.\n+ */\n+public class SimulateIndexTemplateResponse extends ActionResponse implements ToXContentObject {\n+\n+    private static final ParseField TEMPLATE = new ParseField(\"template\");\n+    private static final ParseField OVERLAPPING_V1_TEMPLATES = new ParseField(\"overlapping_v1_templates\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkwMTM1Mw=="}, "originalCommit": {"oid": "cbcc9770decf5ed6932fd4471786eb2fa710947b"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk5OTI1Mw==", "bodyText": "Would it make sense to only call it \"overlapping\" and keep the current returned format and also keep only returning the V1 overlapping templates? Documenting this field accordingly.\n\nHmm.. what about calling it \"overlapping\" and including both V1 and V2 templates in the list? Eventually no more V1 templates will be in the list, but it could still be useful to see V2 templates that would have matched the index.", "url": "https://github.com/elastic/elasticsearch/pull/55686#discussion_r415999253", "createdAt": "2020-04-27T17:17:42Z", "author": {"login": "dakrone"}, "path": "server/src/main/java/org/elasticsearch/action/admin/indices/template/post/SimulateIndexTemplateResponse.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.admin.indices.template.post;\n+\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.cluster.metadata.Template;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * Contains the information on what V2 templates would match a given index.\n+ */\n+public class SimulateIndexTemplateResponse extends ActionResponse implements ToXContentObject {\n+\n+    private static final ParseField TEMPLATE = new ParseField(\"template\");\n+    private static final ParseField OVERLAPPING_V1_TEMPLATES = new ParseField(\"overlapping_v1_templates\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkwMTM1Mw=="}, "originalCommit": {"oid": "cbcc9770decf5ed6932fd4471786eb2fa710947b"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU4MTc3Mg==", "bodyText": "Implemented this Lee, I think this is ready for review", "url": "https://github.com/elastic/elasticsearch/pull/55686#discussion_r416581772", "createdAt": "2020-04-28T12:44:06Z", "author": {"login": "andreidan"}, "path": "server/src/main/java/org/elasticsearch/action/admin/indices/template/post/SimulateIndexTemplateResponse.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.admin.indices.template.post;\n+\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.cluster.metadata.Template;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * Contains the information on what V2 templates would match a given index.\n+ */\n+public class SimulateIndexTemplateResponse extends ActionResponse implements ToXContentObject {\n+\n+    private static final ParseField TEMPLATE = new ParseField(\"template\");\n+    private static final ParseField OVERLAPPING_V1_TEMPLATES = new ParseField(\"overlapping_v1_templates\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkwMTM1Mw=="}, "originalCommit": {"oid": "cbcc9770decf5ed6932fd4471786eb2fa710947b"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3OTMxNTA0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/template/post/TransportSimulateIndexTemplateAction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQyMjo0MTowNVrOGLrnSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQyMjo0MTowNVrOGLrnSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkwMjA4OQ==", "bodyText": "I think we might want to put this logic in a static method in MetadataCreateIndexService (since I believe it does something similar) so that the simulation can reuse the real method.", "url": "https://github.com/elastic/elasticsearch/pull/55686#discussion_r414902089", "createdAt": "2020-04-24T22:41:05Z", "author": {"login": "dakrone"}, "path": "server/src/main/java/org/elasticsearch/action/admin/indices/template/post/TransportSimulateIndexTemplateAction.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.admin.indices.template.post;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.master.TransportMasterNodeReadAction;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.block.ClusterBlockLevel;\n+import org.elasticsearch.cluster.metadata.AliasMetadata;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.metadata.IndexTemplateV2;\n+import org.elasticsearch.cluster.metadata.MetadataIndexTemplateService;\n+import org.elasticsearch.cluster.metadata.Template;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.UUIDs;\n+import org.elasticsearch.common.compress.CompressedXContent;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.index.mapper.MapperService;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.elasticsearch.cluster.metadata.MetadataCreateIndexService.resolveV2Mappings;\n+import static org.elasticsearch.cluster.metadata.MetadataIndexTemplateService.findV2Template;\n+import static org.elasticsearch.cluster.metadata.MetadataIndexTemplateService.resolveSettings;\n+\n+public class TransportSimulateIndexTemplateAction\n+    extends TransportMasterNodeReadAction<SimulateIndexTemplateRequest, SimulateIndexTemplateResponse> {\n+\n+    private final MetadataIndexTemplateService indexTemplateService;\n+    private final NamedXContentRegistry xContentRegistry;\n+\n+    @Inject\n+    public TransportSimulateIndexTemplateAction(TransportService transportService, ClusterService clusterService,\n+                                                ThreadPool threadPool, MetadataIndexTemplateService indexTemplateService,\n+                                                ActionFilters actionFilters, IndexNameExpressionResolver indexNameExpressionResolver,\n+                                                NamedXContentRegistry xContentRegistry) {\n+        super(SimulateIndexTemplateAction.NAME, transportService, clusterService, threadPool, actionFilters,\n+            SimulateIndexTemplateRequest::new, indexNameExpressionResolver);\n+        this.indexTemplateService = indexTemplateService;\n+        this.xContentRegistry = xContentRegistry;\n+    }\n+\n+    @Override\n+    protected String executor() {\n+        return ThreadPool.Names.SAME;\n+    }\n+\n+    @Override\n+    protected SimulateIndexTemplateResponse read(StreamInput in) throws IOException {\n+        return new SimulateIndexTemplateResponse(in);\n+    }\n+\n+    @Override\n+    protected void masterOperation(Task task, SimulateIndexTemplateRequest request, ClusterState state,\n+                                   ActionListener<SimulateIndexTemplateResponse> listener) throws Exception {\n+        ClusterState simulateOnClusterState = state;\n+        if (request.getIndexTemplateRequest() != null) {\n+            // we'll \"locally\" add the template defined by the user in the cluster state (as if it existed in the system)\n+            String simulateTemplateToAdd = \"simulate_new_template_\" + UUIDs.randomBase64UUID();\n+            simulateOnClusterState = indexTemplateService.addIndexTemplateV2(state, request.getIndexTemplateRequest().create(),\n+                simulateTemplateToAdd, request.getIndexTemplateRequest().indexTemplate());\n+        }\n+\n+        String matchingTemplate = findV2Template(simulateOnClusterState.metadata(), request.getIndexName(), false);\n+        if (matchingTemplate == null) {\n+            listener.onResponse(new SimulateIndexTemplateResponse(null, null));\n+            return;\n+        }\n+        Settings settings = resolveSettings(simulateOnClusterState.metadata(), matchingTemplate);\n+\n+        // empty request mapping as the user can't specify any explicit mappings via the simulate api\n+        Map<String, Object> mappings = resolveV2Mappings(\"{}\", simulateOnClusterState, matchingTemplate, xContentRegistry);\n+        String mappingsJson = Strings.toString(XContentFactory.jsonBuilder()\n+            .startObject()\n+            .field(MapperService.SINGLE_MAPPING_NAME, mappings)\n+            .endObject());\n+\n+        List<Map<String, AliasMetadata>> resolvedAliases = MetadataIndexTemplateService.resolveAliases(simulateOnClusterState.metadata(),\n+            matchingTemplate);\n+        Map<String, AliasMetadata> aliases = new HashMap<>();\n+        for (Map<String, AliasMetadata> alias : resolvedAliases) {\n+            for (Map.Entry<String, AliasMetadata> aliasEntry : alias.entrySet()) {\n+                if (aliases.containsKey(aliasEntry.getKey()) == false) {\n+                    aliases.put(aliasEntry.getKey(), aliasEntry.getValue());\n+                }\n+            }\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cbcc9770decf5ed6932fd4471786eb2fa710947b"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3OTMyNTM2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataCreateIndexService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQyMjo0NToyMFrOGLrs3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQyMjo0NToyMFrOGLrs3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkwMzUxNg==", "bodyText": "Super minor, but the indentation for these lines is off now", "url": "https://github.com/elastic/elasticsearch/pull/55686#discussion_r414903516", "createdAt": "2020-04-24T22:45:20Z", "author": {"login": "dakrone"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataCreateIndexService.java", "diffHunk": "@@ -502,7 +502,7 @@ private ClusterState applyCreateIndexRequestWithV2Template(final ClusterState cu\n             Collections.singletonList(templateName), metadataTransformer);\n     }\n \n-    static Map<String, Object> resolveV2Mappings(final String requestMappings,\n+    public static Map<String, Object> resolveV2Mappings(final String requestMappings,\n                                                  final ClusterState currentState,\n                                                  final String templateName,\n                                                  final NamedXContentRegistry xContentRegistry) throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cbcc9770decf5ed6932fd4471786eb2fa710947b"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3OTMyNTYzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexTemplateService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQyMjo0NToyOFrOGLrtBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQyMjo0NToyOFrOGLrtBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkwMzU1OA==", "bodyText": "Same nit about indentation", "url": "https://github.com/elastic/elasticsearch/pull/55686#discussion_r414903558", "createdAt": "2020-04-24T22:45:28Z", "author": {"login": "dakrone"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexTemplateService.java", "diffHunk": "@@ -332,8 +332,7 @@ static void validateV2TemplateRequest(Metadata metadata, String name, IndexTempl\n         }\n     }\n \n-    // Package visible for testing\n-    ClusterState addIndexTemplateV2(final ClusterState currentState, final boolean create,\n+    public ClusterState addIndexTemplateV2(final ClusterState currentState, final boolean create,\n                                     final String name, final IndexTemplateV2 template) throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cbcc9770decf5ed6932fd4471786eb2fa710947b"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5MjQ2ODMzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/template/post/SimulateIndexTemplateResponse.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNDo1ODozOFrOGNYYNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNDo1ODozOFrOGNYYNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjY4NDA4NA==", "bodyText": "I think we need to change this to not use dynamically named keys, rather than:\n\"overlapping\": {\n   \"foo\": [\"bar\"],\n   \"baz\": [\"eggplant\"]\n}\nIt should probably be something like:\n\"overlapping\": [\n  {\n    \"name\": \"foo\",\n    \"index_patterns\": [\"bar\"]\n  },\n  {\n    \"name\": \"baz\",\n    \"index_patterns\": [\"eggplant\"]\n  }\n]", "url": "https://github.com/elastic/elasticsearch/pull/55686#discussion_r416684084", "createdAt": "2020-04-28T14:58:38Z", "author": {"login": "dakrone"}, "path": "server/src/main/java/org/elasticsearch/action/admin/indices/template/post/SimulateIndexTemplateResponse.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.admin.indices.template.post;\n+\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.cluster.metadata.Template;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * Contains the information on what V2 templates would match a given index.\n+ */\n+public class SimulateIndexTemplateResponse extends ActionResponse implements ToXContentObject {\n+\n+    private static final ParseField TEMPLATE = new ParseField(\"template\");\n+    private static final ParseField OVERLAPPING = new ParseField(\"overlapping\");\n+\n+    @Nullable\n+    // the resolved settings, mappings and aliases for the matched templates, if any\n+    private Template resolvedTemplate;\n+\n+    @Nullable\n+    // a map of template names and their index patterns that would overlap when matching the given index name\n+    private Map<String, List<String>> overlappingTemplates;\n+\n+    public SimulateIndexTemplateResponse(@Nullable Template resolvedTemplate, @Nullable Map<String, List<String>> overlappingTemplates) {\n+        this.resolvedTemplate = resolvedTemplate;\n+        this.overlappingTemplates = overlappingTemplates;\n+    }\n+\n+    public SimulateIndexTemplateResponse(StreamInput in) throws IOException {\n+        super(in);\n+        resolvedTemplate = in.readOptionalWriteable(Template::new);\n+        if (in.readBoolean()) {\n+            int overlappingTemplatesCount = in.readInt();\n+            overlappingTemplates = new HashMap<>(overlappingTemplatesCount, 1L);\n+            for (int i = 0; i < overlappingTemplatesCount; i++) {\n+                String templateName = in.readString();\n+                overlappingTemplates.put(templateName, in.readStringList());\n+            }\n+        } else {\n+            this.overlappingTemplates = null;\n+        }\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        out.writeOptionalWriteable(resolvedTemplate);\n+        if (overlappingTemplates != null) {\n+            out.writeBoolean(true);\n+            out.writeInt(overlappingTemplates.size());\n+            for (Map.Entry<String, List<String>> entry : overlappingTemplates.entrySet()) {\n+                out.writeString(entry.getKey());\n+                out.writeStringCollection(entry.getValue());\n+            }\n+        } else {\n+            out.writeBoolean(false);\n+        }\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject();\n+        if (this.resolvedTemplate != null) {\n+            builder.field(TEMPLATE.getPreferredName(), this.resolvedTemplate);\n+        }\n+        if (this.overlappingTemplates != null) {\n+            builder.field(OVERLAPPING.getPreferredName(), overlappingTemplates);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "651b578087625e222bd7c9d1a8825a8f2130a906"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5MjQ4NDI0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/template/post/TransportSimulateIndexTemplateAction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNTowMTo0OVrOGNYiOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNjoxMDowNVrOGNb08w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjY4NjY0OQ==", "bodyText": "I think this should put the results in a new map, otherwise we rely on findConflictingV1Templates returning a mutable Map", "url": "https://github.com/elastic/elasticsearch/pull/55686#discussion_r416686649", "createdAt": "2020-04-28T15:01:49Z", "author": {"login": "dakrone"}, "path": "server/src/main/java/org/elasticsearch/action/admin/indices/template/post/TransportSimulateIndexTemplateAction.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.admin.indices.template.post;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.master.TransportMasterNodeReadAction;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.block.ClusterBlockLevel;\n+import org.elasticsearch.cluster.metadata.AliasMetadata;\n+import org.elasticsearch.cluster.metadata.AliasValidator;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.metadata.IndexTemplateV2;\n+import org.elasticsearch.cluster.metadata.Metadata;\n+import org.elasticsearch.cluster.metadata.MetadataCreateIndexService;\n+import org.elasticsearch.cluster.metadata.MetadataIndexTemplateService;\n+import org.elasticsearch.cluster.metadata.Template;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.UUIDs;\n+import org.elasticsearch.common.compress.CompressedXContent;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.index.Index;\n+import org.elasticsearch.index.IndexService;\n+import org.elasticsearch.index.mapper.MapperService;\n+import org.elasticsearch.indices.IndicesService;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.cluster.metadata.MetadataCreateIndexService.resolveV2Mappings;\n+import static org.elasticsearch.cluster.metadata.MetadataIndexTemplateService.findConflictingV1Templates;\n+import static org.elasticsearch.cluster.metadata.MetadataIndexTemplateService.findConflictingV2Templates;\n+import static org.elasticsearch.cluster.metadata.MetadataIndexTemplateService.findV2Template;\n+import static org.elasticsearch.cluster.metadata.MetadataIndexTemplateService.resolveSettings;\n+import static org.elasticsearch.indices.cluster.IndicesClusterStateService.AllocatedIndices.IndexRemovalReason.NO_LONGER_ASSIGNED;\n+\n+public class TransportSimulateIndexTemplateAction\n+    extends TransportMasterNodeReadAction<SimulateIndexTemplateRequest, SimulateIndexTemplateResponse> {\n+\n+    private final MetadataIndexTemplateService indexTemplateService;\n+    private final NamedXContentRegistry xContentRegistry;\n+    private final IndicesService indicesService;\n+    private AliasValidator aliasValidator;\n+\n+    @Inject\n+    public TransportSimulateIndexTemplateAction(TransportService transportService, ClusterService clusterService,\n+                                                ThreadPool threadPool, MetadataIndexTemplateService indexTemplateService,\n+                                                ActionFilters actionFilters, IndexNameExpressionResolver indexNameExpressionResolver,\n+                                                NamedXContentRegistry xContentRegistry, IndicesService indicesService) {\n+        super(SimulateIndexTemplateAction.NAME, transportService, clusterService, threadPool, actionFilters,\n+            SimulateIndexTemplateRequest::new, indexNameExpressionResolver);\n+        this.indexTemplateService = indexTemplateService;\n+        this.xContentRegistry = xContentRegistry;\n+        this.indicesService = indicesService;\n+        this.aliasValidator = new AliasValidator();\n+    }\n+\n+    @Override\n+    protected String executor() {\n+        return ThreadPool.Names.SAME;\n+    }\n+\n+    @Override\n+    protected SimulateIndexTemplateResponse read(StreamInput in) throws IOException {\n+        return new SimulateIndexTemplateResponse(in);\n+    }\n+\n+    @Override\n+    protected void masterOperation(Task task, SimulateIndexTemplateRequest request, ClusterState state,\n+                                   ActionListener<SimulateIndexTemplateResponse> listener) throws Exception {\n+        ClusterState simulateOnClusterState = state;\n+        if (request.getIndexTemplateRequest() != null) {\n+            // we'll \"locally\" add the template defined by the user in the cluster state (as if it existed in the system)\n+            String simulateTemplateToAdd = \"simulate_new_template_\" + UUIDs.randomBase64UUID();\n+            simulateOnClusterState = indexTemplateService.addIndexTemplateV2(state, request.getIndexTemplateRequest().create(),\n+                simulateTemplateToAdd, request.getIndexTemplateRequest().indexTemplate());\n+        }\n+\n+        String matchingTemplate = findV2Template(simulateOnClusterState.metadata(), request.getIndexName(), false);\n+        if (matchingTemplate == null) {\n+            listener.onResponse(new SimulateIndexTemplateResponse(null, null));\n+            return;\n+        }\n+        Settings settings = resolveSettings(simulateOnClusterState.metadata(), matchingTemplate);\n+\n+        // empty request mapping as the user can't specify any explicit mappings via the simulate api\n+        Map<String, Object> mappings = resolveV2Mappings(\"{}\", simulateOnClusterState, matchingTemplate, xContentRegistry);\n+        String mappingsJson = Strings.toString(XContentFactory.jsonBuilder()\n+            .startObject()\n+            .field(MapperService.SINGLE_MAPPING_NAME, mappings)\n+            .endObject());\n+\n+        List<Map<String, AliasMetadata>> resolvedAliases = MetadataIndexTemplateService.resolveAliases(simulateOnClusterState.metadata(),\n+            matchingTemplate);\n+\n+        // create the index with dummy settings in the cluster state so we can parse and validate the aliases\n+        Settings dummySettings = Settings.builder()\n+            .put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT)\n+            .put(settings)\n+            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)\n+            .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)\n+            .put(IndexMetadata.SETTING_INDEX_UUID, UUIDs.randomBase64UUID())\n+            .build();\n+        final IndexMetadata indexMetadata = IndexMetadata.builder(request.getIndexName()).settings(dummySettings).build();\n+\n+        simulateOnClusterState = ClusterState.builder(simulateOnClusterState)\n+            .metadata(Metadata.builder(simulateOnClusterState.metadata())\n+                .put(indexMetadata, true)\n+                .build())\n+            .build();\n+\n+        IndexService tempIndexService = indicesService.createIndex(indexMetadata, Collections.emptyList(), false);\n+        final Index index = tempIndexService.index();\n+        try (Closeable dummy = () -> tempIndexService.close(\"temp\", false)) {\n+            List<AliasMetadata> aliases = MetadataCreateIndexService.resolveAndValidateAliases(request.getIndexName(), Set.of(),\n+                resolvedAliases, simulateOnClusterState.metadata(), aliasValidator, xContentRegistry,\n+                // the context is only used for validation so it's fine to pass fake values for the\n+                // shard id and the current timestamp\n+                tempIndexService.newQueryShardContext(0, null, () -> 0L, null));\n+\n+            IndexTemplateV2 templateV2 = simulateOnClusterState.metadata().templatesV2().get(matchingTemplate);\n+            assert templateV2 != null : \"the matched template must exist\";\n+\n+            Map<String, List<String>> overlapping = findConflictingV1Templates(simulateOnClusterState, matchingTemplate,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "651b578087625e222bd7c9d1a8825a8f2130a906"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc0MDU5NQ==", "bodyText": "ah good shout, I had allocations on my mind", "url": "https://github.com/elastic/elasticsearch/pull/55686#discussion_r416740595", "createdAt": "2020-04-28T16:10:05Z", "author": {"login": "andreidan"}, "path": "server/src/main/java/org/elasticsearch/action/admin/indices/template/post/TransportSimulateIndexTemplateAction.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.admin.indices.template.post;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.master.TransportMasterNodeReadAction;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.block.ClusterBlockLevel;\n+import org.elasticsearch.cluster.metadata.AliasMetadata;\n+import org.elasticsearch.cluster.metadata.AliasValidator;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.metadata.IndexTemplateV2;\n+import org.elasticsearch.cluster.metadata.Metadata;\n+import org.elasticsearch.cluster.metadata.MetadataCreateIndexService;\n+import org.elasticsearch.cluster.metadata.MetadataIndexTemplateService;\n+import org.elasticsearch.cluster.metadata.Template;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.UUIDs;\n+import org.elasticsearch.common.compress.CompressedXContent;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.index.Index;\n+import org.elasticsearch.index.IndexService;\n+import org.elasticsearch.index.mapper.MapperService;\n+import org.elasticsearch.indices.IndicesService;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.cluster.metadata.MetadataCreateIndexService.resolveV2Mappings;\n+import static org.elasticsearch.cluster.metadata.MetadataIndexTemplateService.findConflictingV1Templates;\n+import static org.elasticsearch.cluster.metadata.MetadataIndexTemplateService.findConflictingV2Templates;\n+import static org.elasticsearch.cluster.metadata.MetadataIndexTemplateService.findV2Template;\n+import static org.elasticsearch.cluster.metadata.MetadataIndexTemplateService.resolveSettings;\n+import static org.elasticsearch.indices.cluster.IndicesClusterStateService.AllocatedIndices.IndexRemovalReason.NO_LONGER_ASSIGNED;\n+\n+public class TransportSimulateIndexTemplateAction\n+    extends TransportMasterNodeReadAction<SimulateIndexTemplateRequest, SimulateIndexTemplateResponse> {\n+\n+    private final MetadataIndexTemplateService indexTemplateService;\n+    private final NamedXContentRegistry xContentRegistry;\n+    private final IndicesService indicesService;\n+    private AliasValidator aliasValidator;\n+\n+    @Inject\n+    public TransportSimulateIndexTemplateAction(TransportService transportService, ClusterService clusterService,\n+                                                ThreadPool threadPool, MetadataIndexTemplateService indexTemplateService,\n+                                                ActionFilters actionFilters, IndexNameExpressionResolver indexNameExpressionResolver,\n+                                                NamedXContentRegistry xContentRegistry, IndicesService indicesService) {\n+        super(SimulateIndexTemplateAction.NAME, transportService, clusterService, threadPool, actionFilters,\n+            SimulateIndexTemplateRequest::new, indexNameExpressionResolver);\n+        this.indexTemplateService = indexTemplateService;\n+        this.xContentRegistry = xContentRegistry;\n+        this.indicesService = indicesService;\n+        this.aliasValidator = new AliasValidator();\n+    }\n+\n+    @Override\n+    protected String executor() {\n+        return ThreadPool.Names.SAME;\n+    }\n+\n+    @Override\n+    protected SimulateIndexTemplateResponse read(StreamInput in) throws IOException {\n+        return new SimulateIndexTemplateResponse(in);\n+    }\n+\n+    @Override\n+    protected void masterOperation(Task task, SimulateIndexTemplateRequest request, ClusterState state,\n+                                   ActionListener<SimulateIndexTemplateResponse> listener) throws Exception {\n+        ClusterState simulateOnClusterState = state;\n+        if (request.getIndexTemplateRequest() != null) {\n+            // we'll \"locally\" add the template defined by the user in the cluster state (as if it existed in the system)\n+            String simulateTemplateToAdd = \"simulate_new_template_\" + UUIDs.randomBase64UUID();\n+            simulateOnClusterState = indexTemplateService.addIndexTemplateV2(state, request.getIndexTemplateRequest().create(),\n+                simulateTemplateToAdd, request.getIndexTemplateRequest().indexTemplate());\n+        }\n+\n+        String matchingTemplate = findV2Template(simulateOnClusterState.metadata(), request.getIndexName(), false);\n+        if (matchingTemplate == null) {\n+            listener.onResponse(new SimulateIndexTemplateResponse(null, null));\n+            return;\n+        }\n+        Settings settings = resolveSettings(simulateOnClusterState.metadata(), matchingTemplate);\n+\n+        // empty request mapping as the user can't specify any explicit mappings via the simulate api\n+        Map<String, Object> mappings = resolveV2Mappings(\"{}\", simulateOnClusterState, matchingTemplate, xContentRegistry);\n+        String mappingsJson = Strings.toString(XContentFactory.jsonBuilder()\n+            .startObject()\n+            .field(MapperService.SINGLE_MAPPING_NAME, mappings)\n+            .endObject());\n+\n+        List<Map<String, AliasMetadata>> resolvedAliases = MetadataIndexTemplateService.resolveAliases(simulateOnClusterState.metadata(),\n+            matchingTemplate);\n+\n+        // create the index with dummy settings in the cluster state so we can parse and validate the aliases\n+        Settings dummySettings = Settings.builder()\n+            .put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT)\n+            .put(settings)\n+            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)\n+            .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)\n+            .put(IndexMetadata.SETTING_INDEX_UUID, UUIDs.randomBase64UUID())\n+            .build();\n+        final IndexMetadata indexMetadata = IndexMetadata.builder(request.getIndexName()).settings(dummySettings).build();\n+\n+        simulateOnClusterState = ClusterState.builder(simulateOnClusterState)\n+            .metadata(Metadata.builder(simulateOnClusterState.metadata())\n+                .put(indexMetadata, true)\n+                .build())\n+            .build();\n+\n+        IndexService tempIndexService = indicesService.createIndex(indexMetadata, Collections.emptyList(), false);\n+        final Index index = tempIndexService.index();\n+        try (Closeable dummy = () -> tempIndexService.close(\"temp\", false)) {\n+            List<AliasMetadata> aliases = MetadataCreateIndexService.resolveAndValidateAliases(request.getIndexName(), Set.of(),\n+                resolvedAliases, simulateOnClusterState.metadata(), aliasValidator, xContentRegistry,\n+                // the context is only used for validation so it's fine to pass fake values for the\n+                // shard id and the current timestamp\n+                tempIndexService.newQueryShardContext(0, null, () -> 0L, null));\n+\n+            IndexTemplateV2 templateV2 = simulateOnClusterState.metadata().templatesV2().get(matchingTemplate);\n+            assert templateV2 != null : \"the matched template must exist\";\n+\n+            Map<String, List<String>> overlapping = findConflictingV1Templates(simulateOnClusterState, matchingTemplate,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjY4NjY0OQ=="}, "originalCommit": {"oid": "651b578087625e222bd7c9d1a8825a8f2130a906"}, "originalPosition": 158}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5MjQ5MTY4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/template/post/TransportSimulateIndexTemplateAction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNTowMzozNVrOGNYnKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNjoxMjo1MlrOGNb84w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjY4NzkxNA==", "bodyText": "In subsequent work (doesn't have to be this PR) maybe we can extract this into a helper method, creating an IndexService for the simulation here makes me a little uneasy for a long-term solution.", "url": "https://github.com/elastic/elasticsearch/pull/55686#discussion_r416687914", "createdAt": "2020-04-28T15:03:35Z", "author": {"login": "dakrone"}, "path": "server/src/main/java/org/elasticsearch/action/admin/indices/template/post/TransportSimulateIndexTemplateAction.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.admin.indices.template.post;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.master.TransportMasterNodeReadAction;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.block.ClusterBlockLevel;\n+import org.elasticsearch.cluster.metadata.AliasMetadata;\n+import org.elasticsearch.cluster.metadata.AliasValidator;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.metadata.IndexTemplateV2;\n+import org.elasticsearch.cluster.metadata.Metadata;\n+import org.elasticsearch.cluster.metadata.MetadataCreateIndexService;\n+import org.elasticsearch.cluster.metadata.MetadataIndexTemplateService;\n+import org.elasticsearch.cluster.metadata.Template;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.UUIDs;\n+import org.elasticsearch.common.compress.CompressedXContent;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.index.Index;\n+import org.elasticsearch.index.IndexService;\n+import org.elasticsearch.index.mapper.MapperService;\n+import org.elasticsearch.indices.IndicesService;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.cluster.metadata.MetadataCreateIndexService.resolveV2Mappings;\n+import static org.elasticsearch.cluster.metadata.MetadataIndexTemplateService.findConflictingV1Templates;\n+import static org.elasticsearch.cluster.metadata.MetadataIndexTemplateService.findConflictingV2Templates;\n+import static org.elasticsearch.cluster.metadata.MetadataIndexTemplateService.findV2Template;\n+import static org.elasticsearch.cluster.metadata.MetadataIndexTemplateService.resolveSettings;\n+import static org.elasticsearch.indices.cluster.IndicesClusterStateService.AllocatedIndices.IndexRemovalReason.NO_LONGER_ASSIGNED;\n+\n+public class TransportSimulateIndexTemplateAction\n+    extends TransportMasterNodeReadAction<SimulateIndexTemplateRequest, SimulateIndexTemplateResponse> {\n+\n+    private final MetadataIndexTemplateService indexTemplateService;\n+    private final NamedXContentRegistry xContentRegistry;\n+    private final IndicesService indicesService;\n+    private AliasValidator aliasValidator;\n+\n+    @Inject\n+    public TransportSimulateIndexTemplateAction(TransportService transportService, ClusterService clusterService,\n+                                                ThreadPool threadPool, MetadataIndexTemplateService indexTemplateService,\n+                                                ActionFilters actionFilters, IndexNameExpressionResolver indexNameExpressionResolver,\n+                                                NamedXContentRegistry xContentRegistry, IndicesService indicesService) {\n+        super(SimulateIndexTemplateAction.NAME, transportService, clusterService, threadPool, actionFilters,\n+            SimulateIndexTemplateRequest::new, indexNameExpressionResolver);\n+        this.indexTemplateService = indexTemplateService;\n+        this.xContentRegistry = xContentRegistry;\n+        this.indicesService = indicesService;\n+        this.aliasValidator = new AliasValidator();\n+    }\n+\n+    @Override\n+    protected String executor() {\n+        return ThreadPool.Names.SAME;\n+    }\n+\n+    @Override\n+    protected SimulateIndexTemplateResponse read(StreamInput in) throws IOException {\n+        return new SimulateIndexTemplateResponse(in);\n+    }\n+\n+    @Override\n+    protected void masterOperation(Task task, SimulateIndexTemplateRequest request, ClusterState state,\n+                                   ActionListener<SimulateIndexTemplateResponse> listener) throws Exception {\n+        ClusterState simulateOnClusterState = state;\n+        if (request.getIndexTemplateRequest() != null) {\n+            // we'll \"locally\" add the template defined by the user in the cluster state (as if it existed in the system)\n+            String simulateTemplateToAdd = \"simulate_new_template_\" + UUIDs.randomBase64UUID();\n+            simulateOnClusterState = indexTemplateService.addIndexTemplateV2(state, request.getIndexTemplateRequest().create(),\n+                simulateTemplateToAdd, request.getIndexTemplateRequest().indexTemplate());\n+        }\n+\n+        String matchingTemplate = findV2Template(simulateOnClusterState.metadata(), request.getIndexName(), false);\n+        if (matchingTemplate == null) {\n+            listener.onResponse(new SimulateIndexTemplateResponse(null, null));\n+            return;\n+        }\n+        Settings settings = resolveSettings(simulateOnClusterState.metadata(), matchingTemplate);\n+\n+        // empty request mapping as the user can't specify any explicit mappings via the simulate api\n+        Map<String, Object> mappings = resolveV2Mappings(\"{}\", simulateOnClusterState, matchingTemplate, xContentRegistry);\n+        String mappingsJson = Strings.toString(XContentFactory.jsonBuilder()\n+            .startObject()\n+            .field(MapperService.SINGLE_MAPPING_NAME, mappings)\n+            .endObject());\n+\n+        List<Map<String, AliasMetadata>> resolvedAliases = MetadataIndexTemplateService.resolveAliases(simulateOnClusterState.metadata(),\n+            matchingTemplate);\n+\n+        // create the index with dummy settings in the cluster state so we can parse and validate the aliases\n+        Settings dummySettings = Settings.builder()\n+            .put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT)\n+            .put(settings)\n+            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)\n+            .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)\n+            .put(IndexMetadata.SETTING_INDEX_UUID, UUIDs.randomBase64UUID())\n+            .build();\n+        final IndexMetadata indexMetadata = IndexMetadata.builder(request.getIndexName()).settings(dummySettings).build();\n+\n+        simulateOnClusterState = ClusterState.builder(simulateOnClusterState)\n+            .metadata(Metadata.builder(simulateOnClusterState.metadata())\n+                .put(indexMetadata, true)\n+                .build())\n+            .build();\n+\n+        IndexService tempIndexService = indicesService.createIndex(indexMetadata, Collections.emptyList(), false);\n+        final Index index = tempIndexService.index();\n+        try (Closeable dummy = () -> tempIndexService.close(\"temp\", false)) {\n+            List<AliasMetadata> aliases = MetadataCreateIndexService.resolveAndValidateAliases(request.getIndexName(), Set.of(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "651b578087625e222bd7c9d1a8825a8f2130a906"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc0MjYyNw==", "bodyText": "completely agree, this is clunky and rather error-prone (easy to forget to close etc)", "url": "https://github.com/elastic/elasticsearch/pull/55686#discussion_r416742627", "createdAt": "2020-04-28T16:12:52Z", "author": {"login": "andreidan"}, "path": "server/src/main/java/org/elasticsearch/action/admin/indices/template/post/TransportSimulateIndexTemplateAction.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.admin.indices.template.post;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.master.TransportMasterNodeReadAction;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.block.ClusterBlockLevel;\n+import org.elasticsearch.cluster.metadata.AliasMetadata;\n+import org.elasticsearch.cluster.metadata.AliasValidator;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.metadata.IndexTemplateV2;\n+import org.elasticsearch.cluster.metadata.Metadata;\n+import org.elasticsearch.cluster.metadata.MetadataCreateIndexService;\n+import org.elasticsearch.cluster.metadata.MetadataIndexTemplateService;\n+import org.elasticsearch.cluster.metadata.Template;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.UUIDs;\n+import org.elasticsearch.common.compress.CompressedXContent;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.index.Index;\n+import org.elasticsearch.index.IndexService;\n+import org.elasticsearch.index.mapper.MapperService;\n+import org.elasticsearch.indices.IndicesService;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.cluster.metadata.MetadataCreateIndexService.resolveV2Mappings;\n+import static org.elasticsearch.cluster.metadata.MetadataIndexTemplateService.findConflictingV1Templates;\n+import static org.elasticsearch.cluster.metadata.MetadataIndexTemplateService.findConflictingV2Templates;\n+import static org.elasticsearch.cluster.metadata.MetadataIndexTemplateService.findV2Template;\n+import static org.elasticsearch.cluster.metadata.MetadataIndexTemplateService.resolveSettings;\n+import static org.elasticsearch.indices.cluster.IndicesClusterStateService.AllocatedIndices.IndexRemovalReason.NO_LONGER_ASSIGNED;\n+\n+public class TransportSimulateIndexTemplateAction\n+    extends TransportMasterNodeReadAction<SimulateIndexTemplateRequest, SimulateIndexTemplateResponse> {\n+\n+    private final MetadataIndexTemplateService indexTemplateService;\n+    private final NamedXContentRegistry xContentRegistry;\n+    private final IndicesService indicesService;\n+    private AliasValidator aliasValidator;\n+\n+    @Inject\n+    public TransportSimulateIndexTemplateAction(TransportService transportService, ClusterService clusterService,\n+                                                ThreadPool threadPool, MetadataIndexTemplateService indexTemplateService,\n+                                                ActionFilters actionFilters, IndexNameExpressionResolver indexNameExpressionResolver,\n+                                                NamedXContentRegistry xContentRegistry, IndicesService indicesService) {\n+        super(SimulateIndexTemplateAction.NAME, transportService, clusterService, threadPool, actionFilters,\n+            SimulateIndexTemplateRequest::new, indexNameExpressionResolver);\n+        this.indexTemplateService = indexTemplateService;\n+        this.xContentRegistry = xContentRegistry;\n+        this.indicesService = indicesService;\n+        this.aliasValidator = new AliasValidator();\n+    }\n+\n+    @Override\n+    protected String executor() {\n+        return ThreadPool.Names.SAME;\n+    }\n+\n+    @Override\n+    protected SimulateIndexTemplateResponse read(StreamInput in) throws IOException {\n+        return new SimulateIndexTemplateResponse(in);\n+    }\n+\n+    @Override\n+    protected void masterOperation(Task task, SimulateIndexTemplateRequest request, ClusterState state,\n+                                   ActionListener<SimulateIndexTemplateResponse> listener) throws Exception {\n+        ClusterState simulateOnClusterState = state;\n+        if (request.getIndexTemplateRequest() != null) {\n+            // we'll \"locally\" add the template defined by the user in the cluster state (as if it existed in the system)\n+            String simulateTemplateToAdd = \"simulate_new_template_\" + UUIDs.randomBase64UUID();\n+            simulateOnClusterState = indexTemplateService.addIndexTemplateV2(state, request.getIndexTemplateRequest().create(),\n+                simulateTemplateToAdd, request.getIndexTemplateRequest().indexTemplate());\n+        }\n+\n+        String matchingTemplate = findV2Template(simulateOnClusterState.metadata(), request.getIndexName(), false);\n+        if (matchingTemplate == null) {\n+            listener.onResponse(new SimulateIndexTemplateResponse(null, null));\n+            return;\n+        }\n+        Settings settings = resolveSettings(simulateOnClusterState.metadata(), matchingTemplate);\n+\n+        // empty request mapping as the user can't specify any explicit mappings via the simulate api\n+        Map<String, Object> mappings = resolveV2Mappings(\"{}\", simulateOnClusterState, matchingTemplate, xContentRegistry);\n+        String mappingsJson = Strings.toString(XContentFactory.jsonBuilder()\n+            .startObject()\n+            .field(MapperService.SINGLE_MAPPING_NAME, mappings)\n+            .endObject());\n+\n+        List<Map<String, AliasMetadata>> resolvedAliases = MetadataIndexTemplateService.resolveAliases(simulateOnClusterState.metadata(),\n+            matchingTemplate);\n+\n+        // create the index with dummy settings in the cluster state so we can parse and validate the aliases\n+        Settings dummySettings = Settings.builder()\n+            .put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT)\n+            .put(settings)\n+            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)\n+            .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)\n+            .put(IndexMetadata.SETTING_INDEX_UUID, UUIDs.randomBase64UUID())\n+            .build();\n+        final IndexMetadata indexMetadata = IndexMetadata.builder(request.getIndexName()).settings(dummySettings).build();\n+\n+        simulateOnClusterState = ClusterState.builder(simulateOnClusterState)\n+            .metadata(Metadata.builder(simulateOnClusterState.metadata())\n+                .put(indexMetadata, true)\n+                .build())\n+            .build();\n+\n+        IndexService tempIndexService = indicesService.createIndex(indexMetadata, Collections.emptyList(), false);\n+        final Index index = tempIndexService.index();\n+        try (Closeable dummy = () -> tempIndexService.close(\"temp\", false)) {\n+            List<AliasMetadata> aliases = MetadataCreateIndexService.resolveAndValidateAliases(request.getIndexName(), Set.of(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjY4NzkxNA=="}, "originalCommit": {"oid": "651b578087625e222bd7c9d1a8825a8f2130a906"}, "originalPosition": 149}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5MjQ5NTY3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/template/post/TransportSimulateIndexTemplateAction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNTowNDoyM1rOGNYppA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNTowNDoyM1rOGNYppA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjY4ODU0OA==", "bodyText": "I think the string here can be changed to indicate this is being removed because of a simulation rather than validating template aliases", "url": "https://github.com/elastic/elasticsearch/pull/55686#discussion_r416688548", "createdAt": "2020-04-28T15:04:23Z", "author": {"login": "dakrone"}, "path": "server/src/main/java/org/elasticsearch/action/admin/indices/template/post/TransportSimulateIndexTemplateAction.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.admin.indices.template.post;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.master.TransportMasterNodeReadAction;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.block.ClusterBlockLevel;\n+import org.elasticsearch.cluster.metadata.AliasMetadata;\n+import org.elasticsearch.cluster.metadata.AliasValidator;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.metadata.IndexTemplateV2;\n+import org.elasticsearch.cluster.metadata.Metadata;\n+import org.elasticsearch.cluster.metadata.MetadataCreateIndexService;\n+import org.elasticsearch.cluster.metadata.MetadataIndexTemplateService;\n+import org.elasticsearch.cluster.metadata.Template;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.UUIDs;\n+import org.elasticsearch.common.compress.CompressedXContent;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.index.Index;\n+import org.elasticsearch.index.IndexService;\n+import org.elasticsearch.index.mapper.MapperService;\n+import org.elasticsearch.indices.IndicesService;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.cluster.metadata.MetadataCreateIndexService.resolveV2Mappings;\n+import static org.elasticsearch.cluster.metadata.MetadataIndexTemplateService.findConflictingV1Templates;\n+import static org.elasticsearch.cluster.metadata.MetadataIndexTemplateService.findConflictingV2Templates;\n+import static org.elasticsearch.cluster.metadata.MetadataIndexTemplateService.findV2Template;\n+import static org.elasticsearch.cluster.metadata.MetadataIndexTemplateService.resolveSettings;\n+import static org.elasticsearch.indices.cluster.IndicesClusterStateService.AllocatedIndices.IndexRemovalReason.NO_LONGER_ASSIGNED;\n+\n+public class TransportSimulateIndexTemplateAction\n+    extends TransportMasterNodeReadAction<SimulateIndexTemplateRequest, SimulateIndexTemplateResponse> {\n+\n+    private final MetadataIndexTemplateService indexTemplateService;\n+    private final NamedXContentRegistry xContentRegistry;\n+    private final IndicesService indicesService;\n+    private AliasValidator aliasValidator;\n+\n+    @Inject\n+    public TransportSimulateIndexTemplateAction(TransportService transportService, ClusterService clusterService,\n+                                                ThreadPool threadPool, MetadataIndexTemplateService indexTemplateService,\n+                                                ActionFilters actionFilters, IndexNameExpressionResolver indexNameExpressionResolver,\n+                                                NamedXContentRegistry xContentRegistry, IndicesService indicesService) {\n+        super(SimulateIndexTemplateAction.NAME, transportService, clusterService, threadPool, actionFilters,\n+            SimulateIndexTemplateRequest::new, indexNameExpressionResolver);\n+        this.indexTemplateService = indexTemplateService;\n+        this.xContentRegistry = xContentRegistry;\n+        this.indicesService = indicesService;\n+        this.aliasValidator = new AliasValidator();\n+    }\n+\n+    @Override\n+    protected String executor() {\n+        return ThreadPool.Names.SAME;\n+    }\n+\n+    @Override\n+    protected SimulateIndexTemplateResponse read(StreamInput in) throws IOException {\n+        return new SimulateIndexTemplateResponse(in);\n+    }\n+\n+    @Override\n+    protected void masterOperation(Task task, SimulateIndexTemplateRequest request, ClusterState state,\n+                                   ActionListener<SimulateIndexTemplateResponse> listener) throws Exception {\n+        ClusterState simulateOnClusterState = state;\n+        if (request.getIndexTemplateRequest() != null) {\n+            // we'll \"locally\" add the template defined by the user in the cluster state (as if it existed in the system)\n+            String simulateTemplateToAdd = \"simulate_new_template_\" + UUIDs.randomBase64UUID();\n+            simulateOnClusterState = indexTemplateService.addIndexTemplateV2(state, request.getIndexTemplateRequest().create(),\n+                simulateTemplateToAdd, request.getIndexTemplateRequest().indexTemplate());\n+        }\n+\n+        String matchingTemplate = findV2Template(simulateOnClusterState.metadata(), request.getIndexName(), false);\n+        if (matchingTemplate == null) {\n+            listener.onResponse(new SimulateIndexTemplateResponse(null, null));\n+            return;\n+        }\n+        Settings settings = resolveSettings(simulateOnClusterState.metadata(), matchingTemplate);\n+\n+        // empty request mapping as the user can't specify any explicit mappings via the simulate api\n+        Map<String, Object> mappings = resolveV2Mappings(\"{}\", simulateOnClusterState, matchingTemplate, xContentRegistry);\n+        String mappingsJson = Strings.toString(XContentFactory.jsonBuilder()\n+            .startObject()\n+            .field(MapperService.SINGLE_MAPPING_NAME, mappings)\n+            .endObject());\n+\n+        List<Map<String, AliasMetadata>> resolvedAliases = MetadataIndexTemplateService.resolveAliases(simulateOnClusterState.metadata(),\n+            matchingTemplate);\n+\n+        // create the index with dummy settings in the cluster state so we can parse and validate the aliases\n+        Settings dummySettings = Settings.builder()\n+            .put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT)\n+            .put(settings)\n+            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)\n+            .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)\n+            .put(IndexMetadata.SETTING_INDEX_UUID, UUIDs.randomBase64UUID())\n+            .build();\n+        final IndexMetadata indexMetadata = IndexMetadata.builder(request.getIndexName()).settings(dummySettings).build();\n+\n+        simulateOnClusterState = ClusterState.builder(simulateOnClusterState)\n+            .metadata(Metadata.builder(simulateOnClusterState.metadata())\n+                .put(indexMetadata, true)\n+                .build())\n+            .build();\n+\n+        IndexService tempIndexService = indicesService.createIndex(indexMetadata, Collections.emptyList(), false);\n+        final Index index = tempIndexService.index();\n+        try (Closeable dummy = () -> tempIndexService.close(\"temp\", false)) {\n+            List<AliasMetadata> aliases = MetadataCreateIndexService.resolveAndValidateAliases(request.getIndexName(), Set.of(),\n+                resolvedAliases, simulateOnClusterState.metadata(), aliasValidator, xContentRegistry,\n+                // the context is only used for validation so it's fine to pass fake values for the\n+                // shard id and the current timestamp\n+                tempIndexService.newQueryShardContext(0, null, () -> 0L, null));\n+\n+            IndexTemplateV2 templateV2 = simulateOnClusterState.metadata().templatesV2().get(matchingTemplate);\n+            assert templateV2 != null : \"the matched template must exist\";\n+\n+            Map<String, List<String>> overlapping = findConflictingV1Templates(simulateOnClusterState, matchingTemplate,\n+                templateV2.indexPatterns());\n+            overlapping.putAll(findConflictingV2Templates(simulateOnClusterState, matchingTemplate, templateV2.indexPatterns()));\n+\n+            Template template = new Template(settings, mappingsJson == null ? null : new CompressedXContent(mappingsJson),\n+                aliases.stream().collect(Collectors.toMap(AliasMetadata::getAlias, Function.identity())));\n+            listener.onResponse(new SimulateIndexTemplateResponse(template, overlapping));\n+        } finally {\n+            if (index != null) {\n+                indicesService.removeIndex(index, NO_LONGER_ASSIGNED, \"created to validate template aliases\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "651b578087625e222bd7c9d1a8825a8f2130a906"}, "originalPosition": 167}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5MzAyOTUxOnYy", "diffSide": "RIGHT", "path": "rest-api-spec/src/main/resources/rest-api-spec/test/indices.simulate_index_template/10_basic.yml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNjo1NTozNFrOGNdxqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNzoxNzoxMlrOGNepKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc3MjUyMQ==", "bodyText": "Can you add a test that uses composed_of so we can ensure that resolving the component template settings works correctly?", "url": "https://github.com/elastic/elasticsearch/pull/55686#discussion_r416772521", "createdAt": "2020-04-28T16:55:34Z", "author": {"login": "dakrone"}, "path": "rest-api-spec/src/main/resources/rest-api-spec/test/indices.simulate_index_template/10_basic.yml", "diffHunk": "@@ -0,0 +1,166 @@\n+---\n+\"Simulate index template without new template in the body\":\n+  - skip:\n+      version: \" - 7.99.99\"\n+      reason: \"simulate index template API has not been backported\"\n+      features: allowed_warnings\n+\n+  - do:\n+      allowed_warnings:\n+        - \"index template [test] has index patterns [te*] matching patterns from existing older templates [global] with patterns (global => [*]); this template [test] will take precedence during new index creation\"\n+      indices.put_index_template:\n+        name: test\n+        body:\n+          index_patterns: te*\n+          template:\n+            settings:\n+              number_of_shards:   1\n+              number_of_replicas: 0\n+            mappings:\n+              properties:\n+                field:\n+                  type: keyword\n+\n+  - do:\n+      indices.simulate_index_template:\n+        name: test\n+\n+  - match: {template.settings.index.number_of_shards: \"1\"}\n+  - match: {template.settings.index.number_of_replicas: \"0\"}\n+  - match: {template.mappings._doc.properties.field.type: \"keyword\"}\n+  - match: {overlapping: {}}\n+\n+---\n+\"Simulate index template specifying a new template\":", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a6582c0edab2ffd5c918ed5bc72d9cad7a71d25"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc4NjcyOA==", "bodyText": "Done, thanks for the suggestion", "url": "https://github.com/elastic/elasticsearch/pull/55686#discussion_r416786728", "createdAt": "2020-04-28T17:17:12Z", "author": {"login": "andreidan"}, "path": "rest-api-spec/src/main/resources/rest-api-spec/test/indices.simulate_index_template/10_basic.yml", "diffHunk": "@@ -0,0 +1,166 @@\n+---\n+\"Simulate index template without new template in the body\":\n+  - skip:\n+      version: \" - 7.99.99\"\n+      reason: \"simulate index template API has not been backported\"\n+      features: allowed_warnings\n+\n+  - do:\n+      allowed_warnings:\n+        - \"index template [test] has index patterns [te*] matching patterns from existing older templates [global] with patterns (global => [*]); this template [test] will take precedence during new index creation\"\n+      indices.put_index_template:\n+        name: test\n+        body:\n+          index_patterns: te*\n+          template:\n+            settings:\n+              number_of_shards:   1\n+              number_of_replicas: 0\n+            mappings:\n+              properties:\n+                field:\n+                  type: keyword\n+\n+  - do:\n+      indices.simulate_index_template:\n+        name: test\n+\n+  - match: {template.settings.index.number_of_shards: \"1\"}\n+  - match: {template.settings.index.number_of_replicas: \"0\"}\n+  - match: {template.mappings._doc.properties.field.type: \"keyword\"}\n+  - match: {overlapping: {}}\n+\n+---\n+\"Simulate index template specifying a new template\":", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc3MjUyMQ=="}, "originalCommit": {"oid": "7a6582c0edab2ffd5c918ed5bc72d9cad7a71d25"}, "originalPosition": 34}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2699, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}