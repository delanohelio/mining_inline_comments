{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg0NjY0NTIz", "number": 53214, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwNzowODoxOFrODlsqWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwNzowODoxOFrODlsqWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwODU1NjQyOnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/elasticsearch/search/aggregations/bucket/missing/MissingAggregatorTests.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwNzowODoxOFrOFyu9TA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQyMzoxNToxNFrOFzKMuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc0MjQ3Ng==", "bodyText": "Note: in some of the aggregator tests similar to this one (where there's a second field we expect to be absent sometimes), we don't pass a field type for the second field like above. If the test is missing the second field type, that field can't be read even if an aggregator was erroneously trying to collect it", "url": "https://github.com/elastic/elasticsearch/pull/53214#discussion_r388742476", "createdAt": "2020-03-06T07:08:18Z", "author": {"login": "andyb-elastic"}, "path": "server/src/test/java/org/elasticsearch/search/aggregations/bucket/missing/MissingAggregatorTests.java", "diffHunk": "@@ -28,81 +28,115 @@\n import org.apache.lucene.search.IndexSearcher;\n import org.apache.lucene.search.Query;\n import org.apache.lucene.store.Directory;\n+import org.apache.lucene.util.BytesRef;\n import org.elasticsearch.common.lucene.search.Queries;\n import org.elasticsearch.index.mapper.MappedFieldType;\n import org.elasticsearch.index.mapper.NumberFieldMapper;\n+import org.elasticsearch.index.mapper.NumberFieldMapper.NumberType;\n import org.elasticsearch.index.mapper.RangeFieldMapper;\n import org.elasticsearch.index.mapper.RangeType;\n import org.elasticsearch.search.aggregations.AggregatorTestCase;\n import org.elasticsearch.search.aggregations.support.AggregationInspectionHelper;\n \n import java.io.IOException;\n-import java.util.Collections;\n+import java.util.Collection;\n+import java.util.List;\n import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.BiConsumer;\n import java.util.function.Consumer;\n \n+import static java.util.Collections.singleton;\n+\n \n public class MissingAggregatorTests extends AggregatorTestCase {\n     public void testMatchNoDocs() throws IOException {\n         int numDocs = randomIntBetween(10, 200);\n+        final MappedFieldType fieldType = new NumberFieldMapper.Builder(\"_name\", NumberType.LONG).fieldType();\n+        fieldType.setName(\"field\");\n         testBothCases(numDocs,\n-            \"field\",\n+            fieldType.name(),\n             Queries.newMatchAllQuery(),\n-            doc -> doc.add(new SortedNumericDocValuesField(\"field\", randomLong())),\n+            builder -> {},\n+            (index, doc) -> doc.add(new SortedNumericDocValuesField(fieldType.name(), randomLong())),\n             internalMissing -> {\n                 assertEquals(internalMissing.getDocCount(), 0);\n                 assertFalse(AggregationInspectionHelper.hasValue(internalMissing));\n-            });\n+            },\n+            singleton(fieldType));\n     }\n \n     public void testMatchAllDocs() throws IOException {\n         int numDocs = randomIntBetween(10, 200);\n+\n+        final MappedFieldType fieldType = new NumberFieldMapper.Builder(\"_name\", NumberType.LONG).fieldType();\n+        fieldType.setName(\"field\");\n+        final MappedFieldType anotherFieldType = new NumberFieldMapper.Builder(\"_name\", NumberType.LONG).fieldType();\n+        anotherFieldType.setName(\"another_field\");\n+\n         testBothCases(numDocs,\n-            \"field\",\n+            fieldType.name(),\n             Queries.newMatchAllQuery(),\n-            doc -> doc.add(new SortedNumericDocValuesField(\"another_field\", randomLong())),\n+            builder -> {},\n+            (index, doc) -> doc.add(new SortedNumericDocValuesField(anotherFieldType.name(), randomLong())),\n             internalMissing -> {\n                 assertEquals(internalMissing.getDocCount(), numDocs);\n                 assertTrue(AggregationInspectionHelper.hasValue(internalMissing));\n-            });\n+            },\n+            List.of(fieldType, anotherFieldType));\n     }\n \n     public void testMatchSparse() throws IOException {\n         int numDocs = randomIntBetween(100, 200);\n         final AtomicInteger count = new AtomicInteger();\n+\n+        final MappedFieldType fieldType = new NumberFieldMapper.Builder(\"_name\", NumberType.LONG).fieldType();\n+        fieldType.setName(\"field\");\n+        final MappedFieldType anotherFieldType = new NumberFieldMapper.Builder(\"_name\", NumberType.LONG).fieldType();\n+        anotherFieldType.setName(\"another_field\");\n+\n         testBothCases(numDocs,\n-            \"field\",\n+            fieldType.name(),\n             Queries.newMatchAllQuery(),\n-            doc -> {\n+            builder -> {},\n+            (index, doc) -> {\n                 if (randomBoolean()) {\n-                    doc.add(new SortedNumericDocValuesField(\"another_field\", randomLong()));\n+                    doc.add(new SortedNumericDocValuesField(anotherFieldType.name(), randomLong()));\n                     count.incrementAndGet();\n                 } else {\n-                    doc.add(new SortedNumericDocValuesField(\"field\", randomLong()));\n+                    doc.add(new SortedNumericDocValuesField(fieldType.name(), randomLong()));\n                 }\n             },\n             internalMissing -> {\n                 assertEquals(internalMissing.getDocCount(), count.get());\n                 count.set(0);\n                 assertTrue(AggregationInspectionHelper.hasValue(internalMissing));\n-            });\n+            },\n+            List.of(fieldType, anotherFieldType));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "474f4e58e7b73773790509a1c797d2c290a08445"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE2OTkwNw==", "bodyText": "We should fix that, could you open a ticket so we don't forget please?", "url": "https://github.com/elastic/elasticsearch/pull/53214#discussion_r389169907", "createdAt": "2020-03-06T22:13:58Z", "author": {"login": "not-napoleon"}, "path": "server/src/test/java/org/elasticsearch/search/aggregations/bucket/missing/MissingAggregatorTests.java", "diffHunk": "@@ -28,81 +28,115 @@\n import org.apache.lucene.search.IndexSearcher;\n import org.apache.lucene.search.Query;\n import org.apache.lucene.store.Directory;\n+import org.apache.lucene.util.BytesRef;\n import org.elasticsearch.common.lucene.search.Queries;\n import org.elasticsearch.index.mapper.MappedFieldType;\n import org.elasticsearch.index.mapper.NumberFieldMapper;\n+import org.elasticsearch.index.mapper.NumberFieldMapper.NumberType;\n import org.elasticsearch.index.mapper.RangeFieldMapper;\n import org.elasticsearch.index.mapper.RangeType;\n import org.elasticsearch.search.aggregations.AggregatorTestCase;\n import org.elasticsearch.search.aggregations.support.AggregationInspectionHelper;\n \n import java.io.IOException;\n-import java.util.Collections;\n+import java.util.Collection;\n+import java.util.List;\n import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.BiConsumer;\n import java.util.function.Consumer;\n \n+import static java.util.Collections.singleton;\n+\n \n public class MissingAggregatorTests extends AggregatorTestCase {\n     public void testMatchNoDocs() throws IOException {\n         int numDocs = randomIntBetween(10, 200);\n+        final MappedFieldType fieldType = new NumberFieldMapper.Builder(\"_name\", NumberType.LONG).fieldType();\n+        fieldType.setName(\"field\");\n         testBothCases(numDocs,\n-            \"field\",\n+            fieldType.name(),\n             Queries.newMatchAllQuery(),\n-            doc -> doc.add(new SortedNumericDocValuesField(\"field\", randomLong())),\n+            builder -> {},\n+            (index, doc) -> doc.add(new SortedNumericDocValuesField(fieldType.name(), randomLong())),\n             internalMissing -> {\n                 assertEquals(internalMissing.getDocCount(), 0);\n                 assertFalse(AggregationInspectionHelper.hasValue(internalMissing));\n-            });\n+            },\n+            singleton(fieldType));\n     }\n \n     public void testMatchAllDocs() throws IOException {\n         int numDocs = randomIntBetween(10, 200);\n+\n+        final MappedFieldType fieldType = new NumberFieldMapper.Builder(\"_name\", NumberType.LONG).fieldType();\n+        fieldType.setName(\"field\");\n+        final MappedFieldType anotherFieldType = new NumberFieldMapper.Builder(\"_name\", NumberType.LONG).fieldType();\n+        anotherFieldType.setName(\"another_field\");\n+\n         testBothCases(numDocs,\n-            \"field\",\n+            fieldType.name(),\n             Queries.newMatchAllQuery(),\n-            doc -> doc.add(new SortedNumericDocValuesField(\"another_field\", randomLong())),\n+            builder -> {},\n+            (index, doc) -> doc.add(new SortedNumericDocValuesField(anotherFieldType.name(), randomLong())),\n             internalMissing -> {\n                 assertEquals(internalMissing.getDocCount(), numDocs);\n                 assertTrue(AggregationInspectionHelper.hasValue(internalMissing));\n-            });\n+            },\n+            List.of(fieldType, anotherFieldType));\n     }\n \n     public void testMatchSparse() throws IOException {\n         int numDocs = randomIntBetween(100, 200);\n         final AtomicInteger count = new AtomicInteger();\n+\n+        final MappedFieldType fieldType = new NumberFieldMapper.Builder(\"_name\", NumberType.LONG).fieldType();\n+        fieldType.setName(\"field\");\n+        final MappedFieldType anotherFieldType = new NumberFieldMapper.Builder(\"_name\", NumberType.LONG).fieldType();\n+        anotherFieldType.setName(\"another_field\");\n+\n         testBothCases(numDocs,\n-            \"field\",\n+            fieldType.name(),\n             Queries.newMatchAllQuery(),\n-            doc -> {\n+            builder -> {},\n+            (index, doc) -> {\n                 if (randomBoolean()) {\n-                    doc.add(new SortedNumericDocValuesField(\"another_field\", randomLong()));\n+                    doc.add(new SortedNumericDocValuesField(anotherFieldType.name(), randomLong()));\n                     count.incrementAndGet();\n                 } else {\n-                    doc.add(new SortedNumericDocValuesField(\"field\", randomLong()));\n+                    doc.add(new SortedNumericDocValuesField(fieldType.name(), randomLong()));\n                 }\n             },\n             internalMissing -> {\n                 assertEquals(internalMissing.getDocCount(), count.get());\n                 count.set(0);\n                 assertTrue(AggregationInspectionHelper.hasValue(internalMissing));\n-            });\n+            },\n+            List.of(fieldType, anotherFieldType));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc0MjQ3Ng=="}, "originalCommit": {"oid": "474f4e58e7b73773790509a1c797d2c290a08445"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE4ODc5Mw==", "bodyText": "I opened #53250", "url": "https://github.com/elastic/elasticsearch/pull/53214#discussion_r389188793", "createdAt": "2020-03-06T23:15:14Z", "author": {"login": "andyb-elastic"}, "path": "server/src/test/java/org/elasticsearch/search/aggregations/bucket/missing/MissingAggregatorTests.java", "diffHunk": "@@ -28,81 +28,115 @@\n import org.apache.lucene.search.IndexSearcher;\n import org.apache.lucene.search.Query;\n import org.apache.lucene.store.Directory;\n+import org.apache.lucene.util.BytesRef;\n import org.elasticsearch.common.lucene.search.Queries;\n import org.elasticsearch.index.mapper.MappedFieldType;\n import org.elasticsearch.index.mapper.NumberFieldMapper;\n+import org.elasticsearch.index.mapper.NumberFieldMapper.NumberType;\n import org.elasticsearch.index.mapper.RangeFieldMapper;\n import org.elasticsearch.index.mapper.RangeType;\n import org.elasticsearch.search.aggregations.AggregatorTestCase;\n import org.elasticsearch.search.aggregations.support.AggregationInspectionHelper;\n \n import java.io.IOException;\n-import java.util.Collections;\n+import java.util.Collection;\n+import java.util.List;\n import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.BiConsumer;\n import java.util.function.Consumer;\n \n+import static java.util.Collections.singleton;\n+\n \n public class MissingAggregatorTests extends AggregatorTestCase {\n     public void testMatchNoDocs() throws IOException {\n         int numDocs = randomIntBetween(10, 200);\n+        final MappedFieldType fieldType = new NumberFieldMapper.Builder(\"_name\", NumberType.LONG).fieldType();\n+        fieldType.setName(\"field\");\n         testBothCases(numDocs,\n-            \"field\",\n+            fieldType.name(),\n             Queries.newMatchAllQuery(),\n-            doc -> doc.add(new SortedNumericDocValuesField(\"field\", randomLong())),\n+            builder -> {},\n+            (index, doc) -> doc.add(new SortedNumericDocValuesField(fieldType.name(), randomLong())),\n             internalMissing -> {\n                 assertEquals(internalMissing.getDocCount(), 0);\n                 assertFalse(AggregationInspectionHelper.hasValue(internalMissing));\n-            });\n+            },\n+            singleton(fieldType));\n     }\n \n     public void testMatchAllDocs() throws IOException {\n         int numDocs = randomIntBetween(10, 200);\n+\n+        final MappedFieldType fieldType = new NumberFieldMapper.Builder(\"_name\", NumberType.LONG).fieldType();\n+        fieldType.setName(\"field\");\n+        final MappedFieldType anotherFieldType = new NumberFieldMapper.Builder(\"_name\", NumberType.LONG).fieldType();\n+        anotherFieldType.setName(\"another_field\");\n+\n         testBothCases(numDocs,\n-            \"field\",\n+            fieldType.name(),\n             Queries.newMatchAllQuery(),\n-            doc -> doc.add(new SortedNumericDocValuesField(\"another_field\", randomLong())),\n+            builder -> {},\n+            (index, doc) -> doc.add(new SortedNumericDocValuesField(anotherFieldType.name(), randomLong())),\n             internalMissing -> {\n                 assertEquals(internalMissing.getDocCount(), numDocs);\n                 assertTrue(AggregationInspectionHelper.hasValue(internalMissing));\n-            });\n+            },\n+            List.of(fieldType, anotherFieldType));\n     }\n \n     public void testMatchSparse() throws IOException {\n         int numDocs = randomIntBetween(100, 200);\n         final AtomicInteger count = new AtomicInteger();\n+\n+        final MappedFieldType fieldType = new NumberFieldMapper.Builder(\"_name\", NumberType.LONG).fieldType();\n+        fieldType.setName(\"field\");\n+        final MappedFieldType anotherFieldType = new NumberFieldMapper.Builder(\"_name\", NumberType.LONG).fieldType();\n+        anotherFieldType.setName(\"another_field\");\n+\n         testBothCases(numDocs,\n-            \"field\",\n+            fieldType.name(),\n             Queries.newMatchAllQuery(),\n-            doc -> {\n+            builder -> {},\n+            (index, doc) -> {\n                 if (randomBoolean()) {\n-                    doc.add(new SortedNumericDocValuesField(\"another_field\", randomLong()));\n+                    doc.add(new SortedNumericDocValuesField(anotherFieldType.name(), randomLong()));\n                     count.incrementAndGet();\n                 } else {\n-                    doc.add(new SortedNumericDocValuesField(\"field\", randomLong()));\n+                    doc.add(new SortedNumericDocValuesField(fieldType.name(), randomLong()));\n                 }\n             },\n             internalMissing -> {\n                 assertEquals(internalMissing.getDocCount(), count.get());\n                 count.set(0);\n                 assertTrue(AggregationInspectionHelper.hasValue(internalMissing));\n-            });\n+            },\n+            List.of(fieldType, anotherFieldType));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc0MjQ3Ng=="}, "originalCommit": {"oid": "474f4e58e7b73773790509a1c797d2c290a08445"}, "originalPosition": 99}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3451, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}