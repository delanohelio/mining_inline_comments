{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk5NzM2MTg5", "number": 63455, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxMjo0MDoxNVrOEvSzFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxMjo0MDoxNVrOEvSzFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MDI2NTE5OnYy", "diffSide": "RIGHT", "path": "server/src/internalClusterTest/java/org/elasticsearch/cluster/ClusterHealthIT.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxMjo0MDoxNVrOHkMVrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxNDoyMDoxMVrOHkQ8tw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzcxMjk0Mw==", "bodyText": "Just for my understanding: We took more than 1 minute here to get 20 (empty) shards to recover? Isn't that indicative of some other issue?", "url": "https://github.com/elastic/elasticsearch/pull/63455#discussion_r507712943", "createdAt": "2020-10-19T12:40:15Z", "author": {"login": "original-brownbear"}, "path": "server/src/internalClusterTest/java/org/elasticsearch/cluster/ClusterHealthIT.java", "diffHunk": "@@ -308,21 +309,27 @@ public void clusterStateProcessed(String source, ClusterState oldState, ClusterS\n         }\n     }\n \n-    @AwaitsFix(bugUrl = \"https://github.com/elastic/elasticsearch/issues/62690\")\n     public void testHealthOnMasterFailover() throws Exception {\n         final String node = internalCluster().startDataOnlyNode();\n-        boolean withIndex = randomBoolean();\n+        final boolean withIndex = randomBoolean();\n         if (withIndex) {\n             // Create index with many shards to provoke the health request to wait (for green) while master is being shut down.\n             // Notice that this is set to 0 after the test completed starting a number of health requests and master restarts.\n             // This ensures that the cluster is yellow when the health request is made, making the health request wait on the observer,\n             // triggering a call to observer.onClusterServiceClose when master is shutdown.\n-            createIndex(\"test\", Settings.builder().put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, randomIntBetween(0, 10)).build());\n+            createIndex(\"test\",\n+                Settings.builder()\n+                .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, randomIntBetween(0, 10))\n+                    // avoid full recoveries of index, just wait for replica to reappear\n+                .put(UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.getKey(), \"5m\")\n+                .build());\n+            ensureGreen(\"test\");\n         }\n         final List<ActionFuture<ClusterHealthResponse>> responseFutures = new ArrayList<>();\n         // Run a few health requests concurrent to master fail-overs against a data-node to make sure master failover is handled\n         // without exceptions\n-        for (int i = 0; i < 20; ++i) {\n+        final int iterations = withIndex ? 10 : 20;\n+        for (int i = 0; i < iterations; ++i) {\n             responseFutures.add(client(node).admin().cluster().prepareHealth().setWaitForEvents(Priority.LANGUID)\n                 .setWaitForGreenStatus().setMasterNodeTimeout(TimeValue.timeValueMinutes(1)).execute());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1ef9d35bf2a19ba4409cd62fa02ecd303257a823"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzc4ODQ3MQ==", "bodyText": "That time could include the 10 master restarts as well as some recovery time. The health call may not be able to respond until the settings are updated below.", "url": "https://github.com/elastic/elasticsearch/pull/63455#discussion_r507788471", "createdAt": "2020-10-19T14:20:11Z", "author": {"login": "henningandersen"}, "path": "server/src/internalClusterTest/java/org/elasticsearch/cluster/ClusterHealthIT.java", "diffHunk": "@@ -308,21 +309,27 @@ public void clusterStateProcessed(String source, ClusterState oldState, ClusterS\n         }\n     }\n \n-    @AwaitsFix(bugUrl = \"https://github.com/elastic/elasticsearch/issues/62690\")\n     public void testHealthOnMasterFailover() throws Exception {\n         final String node = internalCluster().startDataOnlyNode();\n-        boolean withIndex = randomBoolean();\n+        final boolean withIndex = randomBoolean();\n         if (withIndex) {\n             // Create index with many shards to provoke the health request to wait (for green) while master is being shut down.\n             // Notice that this is set to 0 after the test completed starting a number of health requests and master restarts.\n             // This ensures that the cluster is yellow when the health request is made, making the health request wait on the observer,\n             // triggering a call to observer.onClusterServiceClose when master is shutdown.\n-            createIndex(\"test\", Settings.builder().put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, randomIntBetween(0, 10)).build());\n+            createIndex(\"test\",\n+                Settings.builder()\n+                .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, randomIntBetween(0, 10))\n+                    // avoid full recoveries of index, just wait for replica to reappear\n+                .put(UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.getKey(), \"5m\")\n+                .build());\n+            ensureGreen(\"test\");\n         }\n         final List<ActionFuture<ClusterHealthResponse>> responseFutures = new ArrayList<>();\n         // Run a few health requests concurrent to master fail-overs against a data-node to make sure master failover is handled\n         // without exceptions\n-        for (int i = 0; i < 20; ++i) {\n+        final int iterations = withIndex ? 10 : 20;\n+        for (int i = 0; i < iterations; ++i) {\n             responseFutures.add(client(node).admin().cluster().prepareHealth().setWaitForEvents(Priority.LANGUID)\n                 .setWaitForGreenStatus().setMasterNodeTimeout(TimeValue.timeValueMinutes(1)).execute());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzcxMjk0Mw=="}, "originalCommit": {"oid": "1ef9d35bf2a19ba4409cd62fa02ecd303257a823"}, "originalPosition": 38}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3035, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}