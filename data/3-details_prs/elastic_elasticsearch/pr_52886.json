{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgwODM1MjE4", "number": 52886, "title": "Create API Key on behalf of other user", "bodyText": "This change adds a \"grant API key action\"\nPOST /_security/api_key/grant\nthat creates a new API key using the privileges of one user (\"the\nsystem user\") to execute the action, but creates the API key with\nthe roles of the second user (\"the end user\").\nThis allows a system (such as Kibana) to create API keys representing\nthe identity and access of an authenticated user without requiring\nthat user to have permission to create API keys on their own.\nRelates: #48716", "createdAt": "2020-02-27T12:56:09Z", "url": "https://github.com/elastic/elasticsearch/pull/52886", "merged": true, "mergeCommit": {"oid": "150735c29c80762fa39743db738f52f126fd9a2c"}, "closed": true, "closedAt": "2020-03-12T05:57:45Z", "author": {"login": "tvernum"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcIa1TpAH2gAyMzgwODM1MjE4OmY0Y2JlMTRlMWI3ODcxMTU1MTYxZDA4ZWMxYTIzOTkwNTM0YzcwNmI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcM0SDEgH2gAyMzgwODM1MjE4OjA0MzM5YzZhNTJlOGYyMjVlNjhjMTRhYjY2MDM5YTk2ZGVhNDNhNjY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "f4cbe14e1b7871155161d08ec1a23990534c706b", "author": {"user": {"login": "tvernum", "name": "Tim Vernum"}}, "url": "https://github.com/elastic/elasticsearch/commit/f4cbe14e1b7871155161d08ec1a23990534c706b", "committedDate": "2020-02-27T12:53:14Z", "message": "Create API Key on behalf of other user\n\nThis change adds a \"grant API key action\"\n\n   POST /_security/api_key/grant\n\nthat creates a new API key using the privileges of one user (\"the\nsystem user\") to execute the action, but creates the API key with\nthe roles of the second user (\"the end user\").\n\nThis allows a system (such as Kibana) to create API keys representing\nthe identity and access of an authenticated user without requiring\nthat user to have permission to create API keys on their own."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "21c16fff2c58f16e66e127cd3cfe61bb5956d31f", "author": {"user": {"login": "tvernum", "name": "Tim Vernum"}}, "url": "https://github.com/elastic/elasticsearch/commit/21c16fff2c58f16e66e127cd3cfe61bb5956d31f", "committedDate": "2020-02-27T13:03:14Z", "message": "Revert formatting change"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "17d292f52d9fd1d9ff51a1944cf230d2df28c955", "author": {"user": {"login": "tvernum", "name": "Tim Vernum"}}, "url": "https://github.com/elastic/elasticsearch/commit/17d292f52d9fd1d9ff51a1944cf230d2df28c955", "committedDate": "2020-02-27T13:09:07Z", "message": "Revert unnecessary changes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2NDI0MzMz", "url": "https://github.com/elastic/elasticsearch/pull/52886#pullrequestreview-366424333", "createdAt": "2020-02-28T14:13:16Z", "commit": {"oid": "17d292f52d9fd1d9ff51a1944cf230d2df28c955"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNDoxMzoxN1rOFv2Q3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNToyMToxNVrOFv4k8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTcxNjQ0Ng==", "bodyText": "use a local var for the type since we use it multiple times below", "url": "https://github.com/elastic/elasticsearch/pull/52886#discussion_r385716446", "createdAt": "2020-02-28T14:13:17Z", "author": {"login": "jkakavas"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/action/GrantApiKeyRequest.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.action;\n+\n+import org.elasticsearch.action.ActionRequest;\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.support.WriteRequest;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.settings.SecureString;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.action.ValidateActions.addValidationError;\n+\n+/**\n+ * Request class used for the creation of an API key on behalf of another user.\n+ * Logically this is similar to {@link CreateApiKeyRequest}, but is for cases when the user that has permission to call this action\n+ * is different to the user for whom the API key should be created\n+ */\n+public final class GrantApiKeyRequest extends ActionRequest {\n+\n+    public static final WriteRequest.RefreshPolicy DEFAULT_REFRESH_POLICY = WriteRequest.RefreshPolicy.WAIT_UNTIL;\n+    public static final String PASSWORD_GRANT_TYPE = \"password\";\n+    public static final String ACCESS_TOKEN_GRANT_TYPE = \"access_token\";\n+\n+    /**\n+     * Fields related to the end user authentication\n+     */\n+    public static class Grant implements Writeable {\n+        private String type;\n+        private String username;\n+        private SecureString password;\n+        private SecureString accessToken;\n+\n+        public Grant() {\n+        }\n+\n+        public Grant(StreamInput in) throws IOException {\n+            this.type = in.readString();\n+            this.username = in.readOptionalString();\n+            this.password = in.readOptionalSecureString();\n+            this.accessToken = in.readOptionalSecureString();\n+        }\n+\n+        public void writeTo(StreamOutput out) throws IOException {\n+            out.writeString(type);\n+            out.writeOptionalString(username);\n+            out.writeOptionalSecureString(password);\n+            out.writeOptionalSecureString(accessToken);\n+        }\n+\n+        public String getType() {\n+            return type;\n+        }\n+\n+        public String getUsername() {\n+            return username;\n+        }\n+\n+        public SecureString getPassword() {\n+            return password;\n+        }\n+\n+        public SecureString getAccessToken() {\n+            return accessToken;\n+        }\n+\n+        public void setType(String type) {\n+            this.type = type;\n+        }\n+\n+        public void setUsername(String username) {\n+            this.username = username;\n+        }\n+\n+        public void setPassword(SecureString password) {\n+            this.password = password;\n+        }\n+\n+        public void setAccessToken(SecureString accessToken) {\n+            this.accessToken = accessToken;\n+        }\n+    }\n+\n+    private final Grant grant;\n+    private CreateApiKeyRequest apiKey;\n+    private WriteRequest.RefreshPolicy refreshPolicy;\n+\n+    public GrantApiKeyRequest() {\n+        this.grant = new Grant();\n+        this.apiKey = new CreateApiKeyRequest();\n+        this.refreshPolicy = DEFAULT_REFRESH_POLICY;\n+    }\n+\n+    public GrantApiKeyRequest(StreamInput in) throws IOException {\n+        super(in);\n+        this.grant = new Grant(in);\n+        this.apiKey = new CreateApiKeyRequest(in);\n+        this.refreshPolicy = WriteRequest.RefreshPolicy.readFrom(in);\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        super.writeTo(out);\n+        grant.writeTo(out);\n+        apiKey.writeTo(out);\n+        refreshPolicy.writeTo(out);\n+    }\n+\n+    public WriteRequest.RefreshPolicy getRefreshPolicy() {\n+        return refreshPolicy;\n+    }\n+\n+    public void setRefreshPolicy(WriteRequest.RefreshPolicy refreshPolicy) {\n+        this.refreshPolicy = Objects.requireNonNull(refreshPolicy, \"refresh policy may not be null\");\n+    }\n+\n+    public Grant getGrant() {\n+        return grant;\n+    }\n+\n+    public CreateApiKeyRequest getApiKeyRequest() {\n+        return apiKey;\n+    }\n+\n+    public void setApiKeyRequest(CreateApiKeyRequest apiKeyRequest) {\n+        this.apiKey = Objects.requireNonNull(apiKeyRequest, \"Cannot set a null api_key\");\n+    }\n+\n+    @Override\n+    public ActionRequestValidationException validate() {\n+        ActionRequestValidationException validationException = apiKey.validate();\n+        if (grant.type == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17d292f52d9fd1d9ff51a1944cf230d2df28c955"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTcyOTMyNw==", "bodyText": "should we add one with access_token grant since we're at it?", "url": "https://github.com/elastic/elasticsearch/pull/52886#discussion_r385729327", "createdAt": "2020-02-28T14:37:20Z", "author": {"login": "jkakavas"}, "path": "x-pack/plugin/security/qa/security-basic/src/test/java/org/elasticsearch/xpack/security/apikey/ApiKeyRestIT.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.apikey;\n+\n+import org.elasticsearch.client.Request;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.client.Response;\n+import org.elasticsearch.client.security.support.ApiKey;\n+import org.elasticsearch.common.settings.SecureString;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.test.XContentTestUtils;\n+import org.elasticsearch.xpack.core.security.authc.support.UsernamePasswordToken;\n+import org.elasticsearch.xpack.security.SecurityInBasicRestTestCase;\n+import org.junit.After;\n+import org.junit.Before;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.notNullValue;\n+\n+/**\n+ * This IT runs in the \"security-basic\" QA test because it has a working cluster with\n+ * API keys enabled, and there's no reason to have a dedicated QA project for API keys.\n+ */\n+public class ApiKeyRestIT extends SecurityInBasicRestTestCase {\n+\n+    private static final String SYSTEM_USER = \"system_user\";\n+    private static final SecureString SYSTEM_USER_PASSWORD = new SecureString(\"sys-pass\".toCharArray());\n+    private static final String END_USER = \"end_user\";\n+    private static final SecureString END_USER_PASSWORD = new SecureString(\"user-pass\".toCharArray());\n+\n+    @Before\n+    public void createUsers() throws IOException {\n+        createUser(SYSTEM_USER, SYSTEM_USER_PASSWORD, List.of(\"system_role\"));\n+        createRole(\"system_role\", Set.of(\"manage_api_key\"));\n+        createUser(END_USER, END_USER_PASSWORD, List.of(\"user_role\"));\n+        createRole(\"user_role\", Set.of(\"monitor\"));\n+    }\n+\n+    @After\n+    public void cleanUp() throws IOException {\n+        deleteUser(\"system_user\");\n+        deleteUser(\"end_user\");\n+        deleteRole(\"system_role\");\n+        deleteRole(\"user_role\");\n+        invalidateApiKeysForUser(END_USER);\n+    }\n+\n+    public void testGrantApiKeyForOtherUser() throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17d292f52d9fd1d9ff51a1944cf230d2df28c955"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc0MDc2MA==", "bodyText": "is this needed ?", "url": "https://github.com/elastic/elasticsearch/pull/52886#discussion_r385740760", "createdAt": "2020-02-28T14:57:58Z", "author": {"login": "jkakavas"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/action/TransportGrantApiKeyAction.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.action;\n+\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.HandledTransportAction;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportMessage;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.core.security.action.CreateApiKeyResponse;\n+import org.elasticsearch.xpack.core.security.action.GrantApiKeyAction;\n+import org.elasticsearch.xpack.core.security.action.GrantApiKeyRequest;\n+import org.elasticsearch.xpack.core.security.authc.Authentication;\n+import org.elasticsearch.xpack.core.security.authc.support.UsernamePasswordToken;\n+import org.elasticsearch.xpack.security.authc.ApiKeyService;\n+import org.elasticsearch.xpack.security.authc.AuthenticationService;\n+import org.elasticsearch.xpack.security.authc.TokenService;\n+import org.elasticsearch.xpack.security.authc.support.ApiKeyGenerator;\n+import org.elasticsearch.xpack.security.authz.store.CompositeRolesStore;\n+\n+/**\n+ * Implementation of the action needed to create an API key on behalf of another user (using an OAuth style \"grant\")\n+ */\n+public final class TransportGrantApiKeyAction extends HandledTransportAction<GrantApiKeyRequest, CreateApiKeyResponse> {\n+\n+    private final ThreadContext threadContext;\n+    private final ApiKeyGenerator generator;\n+    private final AuthenticationService authenticationService;\n+    private final TokenService tokenService;\n+\n+    @Inject\n+    public TransportGrantApiKeyAction(TransportService transportService, ActionFilters actionFilters, ThreadPool threadPool,\n+                                      ApiKeyService apiKeyService, AuthenticationService authenticationService, TokenService tokenService,\n+                                      CompositeRolesStore rolesStore, NamedXContentRegistry xContentRegistry) {\n+        this(transportService, actionFilters, threadPool.getThreadContext(),\n+            new ApiKeyGenerator(apiKeyService, rolesStore, xContentRegistry), authenticationService, tokenService\n+        );\n+    }\n+\n+    // Constructor for testing\n+    TransportGrantApiKeyAction(TransportService transportService, ActionFilters actionFilters, ThreadContext threadContext,\n+                                      ApiKeyGenerator generator, AuthenticationService authenticationService, TokenService tokenService) {\n+        super(GrantApiKeyAction.NAME, transportService, actionFilters, GrantApiKeyRequest::new);\n+        this.threadContext = threadContext;\n+        this.generator = generator;\n+        this.authenticationService = authenticationService;\n+        this.tokenService = tokenService;\n+    }\n+\n+    @Override\n+    protected void doExecute(Task task, GrantApiKeyRequest request, ActionListener<CreateApiKeyResponse> listener) {\n+        try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {\n+            resolveAuthentication(request.getGrant(), request, ActionListener.wrap(\n+                authentication -> generator.generateApiKey(authentication, request.getApiKeyRequest(), listener),\n+                listener::onFailure\n+            ));\n+        }\n+    }\n+\n+    private void resolveAuthentication(GrantApiKeyRequest.Grant grant, TransportMessage message, ActionListener<Authentication> listener) {\n+        switch (grant.getType()) {\n+            case GrantApiKeyRequest.PASSWORD_GRANT_TYPE:\n+                final UsernamePasswordToken token = new UsernamePasswordToken(grant.getUsername(), grant.getPassword());\n+                authenticationService.authenticate(super.actionName, message, token, listener);\n+                return;\n+            case GrantApiKeyRequest.ACCESS_TOKEN_GRANT_TYPE:\n+                tokenService.authenticateToken(grant.getAccessToken(), listener);\n+                return;\n+            default:\n+                listener.onFailure(new ElasticsearchSecurityException(\"the grant type [{}] is not supported\", grant.getType()));\n+                return;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17d292f52d9fd1d9ff51a1944cf230d2df28c955"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1NDM1NA==", "bodyText": "This is called in ApiKeyService#createApiKey(). Is it intentional that we do it here too becayse getRoleDescriptors can be expensive ? If so can we also /instead inject the ApiKeyService in the Transport service and short circuit there ?", "url": "https://github.com/elastic/elasticsearch/pull/52886#discussion_r385754354", "createdAt": "2020-02-28T15:21:15Z", "author": {"login": "jkakavas"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/support/ApiKeyGenerator.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.authc.support;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.xpack.core.security.action.CreateApiKeyRequest;\n+import org.elasticsearch.xpack.core.security.action.CreateApiKeyResponse;\n+import org.elasticsearch.xpack.core.security.authc.Authentication;\n+import org.elasticsearch.xpack.core.security.authz.RoleDescriptor;\n+import org.elasticsearch.xpack.core.security.authz.support.DLSRoleQueryValidator;\n+import org.elasticsearch.xpack.security.authc.ApiKeyService;\n+import org.elasticsearch.xpack.security.authz.store.CompositeRolesStore;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+\n+public class ApiKeyGenerator {\n+\n+    private final ApiKeyService apiKeyService;\n+    private final CompositeRolesStore rolesStore;\n+    private final NamedXContentRegistry xContentRegistry;\n+\n+    public ApiKeyGenerator(ApiKeyService apiKeyService, CompositeRolesStore rolesStore, NamedXContentRegistry xContentRegistry) {\n+        this.apiKeyService = apiKeyService;\n+        this.rolesStore = rolesStore;\n+        this.xContentRegistry = xContentRegistry;\n+    }\n+\n+    public void generateApiKey(Authentication authentication, CreateApiKeyRequest request, ActionListener<CreateApiKeyResponse> listener) {\n+        if (authentication == null) {\n+            listener.onFailure(new ElasticsearchSecurityException(\"no authentication available to generate API key\"));\n+            return;\n+        }\n+        apiKeyService.ensureEnabled();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17d292f52d9fd1d9ff51a1944cf230d2df28c955"}, "originalPosition": 41}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "24e0fcccce77aba552b36ce71008354aa7d41271", "author": {"user": {"login": "tvernum", "name": "Tim Vernum"}}, "url": "https://github.com/elastic/elasticsearch/commit/24e0fcccce77aba552b36ce71008354aa7d41271", "committedDate": "2020-03-05T00:45:55Z", "message": "Merge branch 'master' into feature/48716-api-key-other-user"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f5808256c01fc4c0ce767b8ebc414be74162e584", "author": {"user": {"login": "tvernum", "name": "Tim Vernum"}}, "url": "https://github.com/elastic/elasticsearch/commit/f5808256c01fc4c0ce767b8ebc414be74162e584", "committedDate": "2020-03-05T01:12:34Z", "message": "Move API key test to new QA/security-trial project\n\nThis test was piggy-backing on the security-in-basic QA project we\nhad, but the grant-api-key endpoint has the ability to use tokens,\nwhich are not a basic licensed feature.\n\nThis creates a new QA project for security on trial licenses and run\nthe API key tests there"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5NDU3MTg1", "url": "https://github.com/elastic/elasticsearch/pull/52886#pullrequestreview-369457185", "createdAt": "2020-03-05T10:33:21Z", "commit": {"oid": "f5808256c01fc4c0ce767b8ebc414be74162e584"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMDozMzoyMVrOFyOR7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMDozMzoyMVrOFyOR7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIwNzA4NQ==", "bodyText": "I believe this new method should return the new fancy 400 exceptions when the token service is not enabled (since it's not used in the authentication chain).", "url": "https://github.com/elastic/elasticsearch/pull/52886#discussion_r388207085", "createdAt": "2020-03-05T10:33:21Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/TokenService.java", "diffHunk": "@@ -394,6 +394,32 @@ void getAndValidateToken(ThreadContext ctx, ActionListener<UserToken> listener)\n         }\n     }\n \n+    /**\n+     * Decodes the provided token, and validates it (for format, expiry and invalidation).\n+     * If valid, the token's {@link Authentication} (see {@link UserToken#getAuthentication()} is provided to the listener.\n+     * If the token is invalid (expired etc), then {@link ActionListener#onFailure(Exception)} will be called.\n+     * If tokens are not enabled, or the token does not exist, {@link ActionListener#onResponse} will be called with a\n+     * {@code null} authentication object.\n+     */\n+    public void authenticateToken(SecureString tokenString, ActionListener<Authentication> listener) {\n+        if (isEnabled()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5808256c01fc4c0ce767b8ebc414be74162e584"}, "originalPosition": 12}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5NDYwMTk3", "url": "https://github.com/elastic/elasticsearch/pull/52886#pullrequestreview-369460197", "createdAt": "2020-03-05T10:37:43Z", "commit": {"oid": "f5808256c01fc4c0ce767b8ebc414be74162e584"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMDozNzo0M1rOFyObnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMDozNzo0M1rOFyObnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIwOTU2NA==", "bodyText": "Also because this new method is not used in the authn chain, when a token fails decoding it's a client error.\nI believe:\nlistener.onFailure(new IllegalArgumentException());\n\nwould do, it would return 400 (currently this falls back to 500 in ApiKeyGenerator#generateApiKey).", "url": "https://github.com/elastic/elasticsearch/pull/52886#discussion_r388209564", "createdAt": "2020-03-05T10:37:43Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/TokenService.java", "diffHunk": "@@ -394,6 +394,32 @@ void getAndValidateToken(ThreadContext ctx, ActionListener<UserToken> listener)\n         }\n     }\n \n+    /**\n+     * Decodes the provided token, and validates it (for format, expiry and invalidation).\n+     * If valid, the token's {@link Authentication} (see {@link UserToken#getAuthentication()} is provided to the listener.\n+     * If the token is invalid (expired etc), then {@link ActionListener#onFailure(Exception)} will be called.\n+     * If tokens are not enabled, or the token does not exist, {@link ActionListener#onResponse} will be called with a\n+     * {@code null} authentication object.\n+     */\n+    public void authenticateToken(SecureString tokenString, ActionListener<Authentication> listener) {\n+        if (isEnabled()) {\n+            decodeToken(tokenString.toString(), ActionListener.wrap(userToken -> {\n+                if (userToken != null) {\n+                    checkIfTokenIsValid(userToken, ActionListener.wrap(\n+                        token -> {\n+                            listener.onResponse(token == null ? null : token.getAuthentication());\n+                        },\n+                        listener::onFailure\n+                    ));\n+                } else {\n+                    listener.onResponse(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5808256c01fc4c0ce767b8ebc414be74162e584"}, "originalPosition": 22}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5NDg0OTg1", "url": "https://github.com/elastic/elasticsearch/pull/52886#pullrequestreview-369484985", "createdAt": "2020-03-05T11:15:20Z", "commit": {"oid": "f5808256c01fc4c0ce767b8ebc414be74162e584"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMToxNToyMFrOFyPn9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMToxNToyMFrOFyPn9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIyOTExMA==", "bodyText": "The refresh_policy should be forwarded to the inner CreateApiKeyRequest to take effect.", "url": "https://github.com/elastic/elasticsearch/pull/52886#discussion_r388229110", "createdAt": "2020-03-05T11:15:20Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/rest/action/apikey/RestGrantApiKeyAction.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.rest.action.apikey;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.WriteRequest;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.settings.SecureString;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.license.XPackLicenseState;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.xpack.core.security.action.CreateApiKeyRequestBuilder;\n+import org.elasticsearch.xpack.core.security.action.CreateApiKeyResponse;\n+import org.elasticsearch.xpack.core.security.action.GrantApiKeyAction;\n+import org.elasticsearch.xpack.core.security.action.GrantApiKeyRequest;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static org.elasticsearch.rest.RestRequest.Method.POST;\n+import static org.elasticsearch.rest.RestRequest.Method.PUT;\n+\n+/**\n+ * Rest action to create an API key on behalf of another user. Loosely mimics the API of\n+ * {@link org.elasticsearch.xpack.security.rest.action.oauth2.RestGetTokenAction} combined with {@link RestCreateApiKeyAction}\n+ */\n+public final class RestGrantApiKeyAction extends ApiKeyBaseRestHandler {\n+\n+    final Logger logger = LogManager.getLogger();\n+\n+    static final ObjectParser<GrantApiKeyRequest, Void> PARSER = new ObjectParser<>(\"grant_api_key_request\", GrantApiKeyRequest::new);\n+    static {\n+        PARSER.declareString((req, str) -> req.getGrant().setType(str), new ParseField(\"grant_type\"));\n+        PARSER.declareString((req, str) -> req.getGrant().setUsername(str), new ParseField(\"username\"));\n+        PARSER.declareField((req, secStr) -> req.getGrant().setPassword(secStr), RestGrantApiKeyAction::getSecureString,\n+            new ParseField(\"password\"), ObjectParser.ValueType.STRING);\n+        PARSER.declareField((req, secStr) -> req.getGrant().setAccessToken(secStr), RestGrantApiKeyAction::getSecureString,\n+            new ParseField(\"access_token\"), ObjectParser.ValueType.STRING);\n+        PARSER.declareObject((req, api) -> req.setApiKeyRequest(api), (parser, ignore) -> CreateApiKeyRequestBuilder.parse(parser),\n+            new ParseField(\"api_key\"));\n+    }\n+\n+    private static SecureString getSecureString(XContentParser parser) throws IOException {\n+        return new SecureString(\n+            Arrays.copyOfRange(parser.textCharacters(), parser.textOffset(), parser.textOffset() + parser.textLength()));\n+    }\n+\n+    public RestGrantApiKeyAction(Settings settings, XPackLicenseState licenseState) {\n+        super(settings, licenseState);\n+    }\n+\n+    @Override\n+    public List<Route> routes() {\n+        return List.of(\n+            new Route(POST, \"/_security/api_key/grant\"),\n+            new Route(PUT, \"/_security/api_key/grant\"));\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"xpack_security_grant_api_key\";\n+    }\n+\n+    @Override\n+    protected RestChannelConsumer innerPrepareRequest(final RestRequest request, final NodeClient client) throws IOException {\n+        String refresh = request.param(\"refresh\");\n+        try (XContentParser parser = request.contentParser()) {\n+            final GrantApiKeyRequest grantRequest = PARSER.parse(parser, null);\n+            if (refresh != null) {\n+                grantRequest.setRefreshPolicy(WriteRequest.RefreshPolicy.parse(refresh));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5808256c01fc4c0ce767b8ebc414be74162e584"}, "originalPosition": 86}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5NDk1MzE3", "url": "https://github.com/elastic/elasticsearch/pull/52886#pullrequestreview-369495317", "createdAt": "2020-03-05T11:32:48Z", "commit": {"oid": "f5808256c01fc4c0ce767b8ebc414be74162e584"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMTozMjo0OFrOFyQIFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMTozMjo0OFrOFyQIFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIzNzMzMw==", "bodyText": "I like this wrapping to translate 401 to 403!\nAssuming this is the sole reason of existence for the inner class, in order to make it easier to read, I would make it more concise:\n            return channel -> client.execute(GrantApiKeyAction.INSTANCE, grantRequest,\n                    ActionListener.delegateResponse(new RestToXContentListener<>(channel),\n                            (l, e) -> {\n                                RestStatus status = ExceptionsHelper.status(e);\n                                if (status == RestStatus.UNAUTHORIZED) {\n                                    l.onFailure(new ElasticsearchSecurityException(\"Failed to authenticate api key grant\",\n                                            RestStatus.FORBIDDEN, e));\n                                } else {\n                                    l.onFailure(e);\n                                }\n                            }));", "url": "https://github.com/elastic/elasticsearch/pull/52886#discussion_r388237333", "createdAt": "2020-03-05T11:32:48Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/rest/action/apikey/RestGrantApiKeyAction.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.rest.action.apikey;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.WriteRequest;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.settings.SecureString;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.license.XPackLicenseState;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.xpack.core.security.action.CreateApiKeyRequestBuilder;\n+import org.elasticsearch.xpack.core.security.action.CreateApiKeyResponse;\n+import org.elasticsearch.xpack.core.security.action.GrantApiKeyAction;\n+import org.elasticsearch.xpack.core.security.action.GrantApiKeyRequest;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static org.elasticsearch.rest.RestRequest.Method.POST;\n+import static org.elasticsearch.rest.RestRequest.Method.PUT;\n+\n+/**\n+ * Rest action to create an API key on behalf of another user. Loosely mimics the API of\n+ * {@link org.elasticsearch.xpack.security.rest.action.oauth2.RestGetTokenAction} combined with {@link RestCreateApiKeyAction}\n+ */\n+public final class RestGrantApiKeyAction extends ApiKeyBaseRestHandler {\n+\n+    final Logger logger = LogManager.getLogger();\n+\n+    static final ObjectParser<GrantApiKeyRequest, Void> PARSER = new ObjectParser<>(\"grant_api_key_request\", GrantApiKeyRequest::new);\n+    static {\n+        PARSER.declareString((req, str) -> req.getGrant().setType(str), new ParseField(\"grant_type\"));\n+        PARSER.declareString((req, str) -> req.getGrant().setUsername(str), new ParseField(\"username\"));\n+        PARSER.declareField((req, secStr) -> req.getGrant().setPassword(secStr), RestGrantApiKeyAction::getSecureString,\n+            new ParseField(\"password\"), ObjectParser.ValueType.STRING);\n+        PARSER.declareField((req, secStr) -> req.getGrant().setAccessToken(secStr), RestGrantApiKeyAction::getSecureString,\n+            new ParseField(\"access_token\"), ObjectParser.ValueType.STRING);\n+        PARSER.declareObject((req, api) -> req.setApiKeyRequest(api), (parser, ignore) -> CreateApiKeyRequestBuilder.parse(parser),\n+            new ParseField(\"api_key\"));\n+    }\n+\n+    private static SecureString getSecureString(XContentParser parser) throws IOException {\n+        return new SecureString(\n+            Arrays.copyOfRange(parser.textCharacters(), parser.textOffset(), parser.textOffset() + parser.textLength()));\n+    }\n+\n+    public RestGrantApiKeyAction(Settings settings, XPackLicenseState licenseState) {\n+        super(settings, licenseState);\n+    }\n+\n+    @Override\n+    public List<Route> routes() {\n+        return List.of(\n+            new Route(POST, \"/_security/api_key/grant\"),\n+            new Route(PUT, \"/_security/api_key/grant\"));\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"xpack_security_grant_api_key\";\n+    }\n+\n+    @Override\n+    protected RestChannelConsumer innerPrepareRequest(final RestRequest request, final NodeClient client) throws IOException {\n+        String refresh = request.param(\"refresh\");\n+        try (XContentParser parser = request.contentParser()) {\n+            final GrantApiKeyRequest grantRequest = PARSER.parse(parser, null);\n+            if (refresh != null) {\n+                grantRequest.setRefreshPolicy(WriteRequest.RefreshPolicy.parse(refresh));\n+            }\n+            return channel -> client.execute(GrantApiKeyAction.INSTANCE, grantRequest, new ResponseListener(channel));\n+        }\n+    }\n+\n+    private class ResponseListener implements ActionListener<CreateApiKeyResponse> {\n+        private final RestChannel channel;\n+\n+        ResponseListener(RestChannel channel) {\n+            this.channel = channel;\n+        }\n+\n+        @Override\n+        public void onResponse(CreateApiKeyResponse response) {\n+            try (XContentBuilder builder = channel.newBuilder()) {\n+                channel.sendResponse(new BytesRestResponse(RestStatus.OK, response.toXContent(builder, channel.request())));\n+            } catch (IOException e) {\n+                sendFailure(e);\n+            }\n+        }\n+\n+        @Override\n+        public void onFailure(Exception e) {\n+            RestStatus status = ExceptionsHelper.status(e);\n+            if (status == RestStatus.UNAUTHORIZED) {\n+                sendFailure(new ElasticsearchSecurityException(\"Failed to authenticate api key grant\", RestStatus.FORBIDDEN, e));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5808256c01fc4c0ce767b8ebc414be74162e584"}, "originalPosition": 112}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5NTEwNjYx", "url": "https://github.com/elastic/elasticsearch/pull/52886#pullrequestreview-369510661", "createdAt": "2020-03-05T11:59:22Z", "commit": {"oid": "f5808256c01fc4c0ce767b8ebc414be74162e584"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5NjIyMzM2", "url": "https://github.com/elastic/elasticsearch/pull/52886#pullrequestreview-369622336", "createdAt": "2020-03-05T14:39:48Z", "commit": {"oid": "f5808256c01fc4c0ce767b8ebc414be74162e584"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dbd772635340c02f731b66c470fe659efa6af363", "author": {"user": {"login": "tvernum", "name": "Tim Vernum"}}, "url": "https://github.com/elastic/elasticsearch/commit/dbd772635340c02f731b66c470fe659efa6af363", "committedDate": "2020-03-11T11:54:35Z", "message": "Merge branch 'master' into feature/48716-api-key-other-user"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "036c402945d26e524cf435853fc611a852f23312", "author": {"user": {"login": "tvernum", "name": "Tim Vernum"}}, "url": "https://github.com/elastic/elasticsearch/commit/036c402945d26e524cf435853fc611a852f23312", "committedDate": "2020-03-11T12:05:02Z", "message": "Address feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8215d25085f6ae76cbbccbea6a76bb2c065ad62f", "author": {"user": {"login": "tvernum", "name": "Tim Vernum"}}, "url": "https://github.com/elastic/elasticsearch/commit/8215d25085f6ae76cbbccbea6a76bb2c065ad62f", "committedDate": "2020-03-12T04:13:51Z", "message": "Merge branch 'master' into feature/48716-api-key-other-user"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "04339c6a52e8f225e68c14ab66039a96dea43a66", "author": {"user": {"login": "tvernum", "name": "Tim Vernum"}}, "url": "https://github.com/elastic/elasticsearch/commit/04339c6a52e8f225e68c14ab66039a96dea43a66", "committedDate": "2020-03-12T04:47:57Z", "message": "Address more feedback"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2031, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}