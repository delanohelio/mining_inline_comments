{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg5MTIxMTc2", "number": 53587, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNToxODoxNlrODpjd1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNToxODoxNlrODpjd1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0ODk5Mjg3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/job/retention/EmptyStateIndexRemover.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNToxODoxNlrOF4zXcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNTo1NToyMFrOF41C5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTEwNjE2Mg==", "bodyText": "I think we can request here indices that match the write alias. Then we don't need to filter them as it will just return indices that have the alias.", "url": "https://github.com/elastic/elasticsearch/pull/53587#discussion_r395106162", "createdAt": "2020-03-19T15:18:16Z", "author": {"login": "dimitris-athanasiou"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/job/retention/EmptyStateIndexRemover.java", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.ml.job.retention;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.indices.delete.DeleteIndexRequest;\n+import org.elasticsearch.action.admin.indices.get.GetIndexRequest;\n+import org.elasticsearch.action.admin.indices.get.GetIndexResponse;\n+import org.elasticsearch.action.admin.indices.stats.IndexStats;\n+import org.elasticsearch.action.admin.indices.stats.IndicesStatsRequest;\n+import org.elasticsearch.client.OriginSettingClient;\n+import org.elasticsearch.common.util.set.Sets;\n+import org.elasticsearch.xpack.core.ml.job.persistence.AnomalyDetectorsIndex;\n+\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+\n+import static java.util.stream.Collectors.toSet;\n+\n+/**\n+ * This class deletes empty indices matching .ml-state* pattern that are not pointed at by the .ml-state-write alias.\n+ */\n+public class EmptyStateIndexRemover implements MlDataRemover {\n+    \n+    private final OriginSettingClient client;\n+\n+    public EmptyStateIndexRemover(OriginSettingClient client) {\n+        this.client = Objects.requireNonNull(client);\n+    }\n+\n+    @Override\n+    public void remove(ActionListener<Boolean> listener, Supplier<Boolean> isTimedOutSupplier) {\n+        try {\n+            if (isTimedOutSupplier.get()) {\n+                listener.onResponse(false);\n+                return;\n+            }\n+            getEmptyStateIndices(\n+                ActionListener.wrap(\n+                    emptyStateIndices -> {\n+                        if (emptyStateIndices.isEmpty()) {\n+                            listener.onResponse(true);\n+                            return;\n+                        }\n+                        getCurrentStateIndices(\n+                            ActionListener.wrap(\n+                                currentStateIndices -> {\n+                                    Set<String> stateIndicesToRemove = Sets.difference(emptyStateIndices, currentStateIndices);\n+                                    executeDeleteEmptyStateIndices(stateIndicesToRemove, listener);\n+                                },\n+                                listener::onFailure\n+                            )\n+                        );\n+                    },\n+                    listener::onFailure\n+                )\n+            );\n+        } catch (Exception e) {\n+            listener.onFailure(e);\n+        }\n+    }\n+\n+    private void getEmptyStateIndices(ActionListener<Set<String>> listener) {\n+        IndicesStatsRequest indicesStatsRequest = new IndicesStatsRequest().indices(AnomalyDetectorsIndex.jobStateIndexPattern());\n+        client.admin().indices().stats(\n+            indicesStatsRequest,\n+            ActionListener.wrap(\n+                indicesStatsResponse -> {\n+                    Set<String> emptyStateIndices =\n+                        indicesStatsResponse.getIndices().values().stream()\n+                            .filter(stats -> stats.getTotal().getDocs().getCount() == 0)\n+                            .map(IndexStats::getIndex)\n+                            .collect(toSet());\n+                    listener.onResponse(emptyStateIndices);\n+                },\n+                listener::onFailure\n+            )\n+        );\n+    }\n+\n+    private void getCurrentStateIndices(ActionListener<Set<String>> listener) {\n+        GetIndexRequest getIndexRequest = new GetIndexRequest().indices(AnomalyDetectorsIndex.jobStateIndexPattern());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "589db76b94f2fdf7a62effc978ed452e7255a377"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTEzMzY2OA==", "bodyText": "Done.", "url": "https://github.com/elastic/elasticsearch/pull/53587#discussion_r395133668", "createdAt": "2020-03-19T15:55:20Z", "author": {"login": "przemekwitek"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/job/retention/EmptyStateIndexRemover.java", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.ml.job.retention;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.indices.delete.DeleteIndexRequest;\n+import org.elasticsearch.action.admin.indices.get.GetIndexRequest;\n+import org.elasticsearch.action.admin.indices.get.GetIndexResponse;\n+import org.elasticsearch.action.admin.indices.stats.IndexStats;\n+import org.elasticsearch.action.admin.indices.stats.IndicesStatsRequest;\n+import org.elasticsearch.client.OriginSettingClient;\n+import org.elasticsearch.common.util.set.Sets;\n+import org.elasticsearch.xpack.core.ml.job.persistence.AnomalyDetectorsIndex;\n+\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+\n+import static java.util.stream.Collectors.toSet;\n+\n+/**\n+ * This class deletes empty indices matching .ml-state* pattern that are not pointed at by the .ml-state-write alias.\n+ */\n+public class EmptyStateIndexRemover implements MlDataRemover {\n+    \n+    private final OriginSettingClient client;\n+\n+    public EmptyStateIndexRemover(OriginSettingClient client) {\n+        this.client = Objects.requireNonNull(client);\n+    }\n+\n+    @Override\n+    public void remove(ActionListener<Boolean> listener, Supplier<Boolean> isTimedOutSupplier) {\n+        try {\n+            if (isTimedOutSupplier.get()) {\n+                listener.onResponse(false);\n+                return;\n+            }\n+            getEmptyStateIndices(\n+                ActionListener.wrap(\n+                    emptyStateIndices -> {\n+                        if (emptyStateIndices.isEmpty()) {\n+                            listener.onResponse(true);\n+                            return;\n+                        }\n+                        getCurrentStateIndices(\n+                            ActionListener.wrap(\n+                                currentStateIndices -> {\n+                                    Set<String> stateIndicesToRemove = Sets.difference(emptyStateIndices, currentStateIndices);\n+                                    executeDeleteEmptyStateIndices(stateIndicesToRemove, listener);\n+                                },\n+                                listener::onFailure\n+                            )\n+                        );\n+                    },\n+                    listener::onFailure\n+                )\n+            );\n+        } catch (Exception e) {\n+            listener.onFailure(e);\n+        }\n+    }\n+\n+    private void getEmptyStateIndices(ActionListener<Set<String>> listener) {\n+        IndicesStatsRequest indicesStatsRequest = new IndicesStatsRequest().indices(AnomalyDetectorsIndex.jobStateIndexPattern());\n+        client.admin().indices().stats(\n+            indicesStatsRequest,\n+            ActionListener.wrap(\n+                indicesStatsResponse -> {\n+                    Set<String> emptyStateIndices =\n+                        indicesStatsResponse.getIndices().values().stream()\n+                            .filter(stats -> stats.getTotal().getDocs().getCount() == 0)\n+                            .map(IndexStats::getIndex)\n+                            .collect(toSet());\n+                    listener.onResponse(emptyStateIndices);\n+                },\n+                listener::onFailure\n+            )\n+        );\n+    }\n+\n+    private void getCurrentStateIndices(ActionListener<Set<String>> listener) {\n+        GetIndexRequest getIndexRequest = new GetIndexRequest().indices(AnomalyDetectorsIndex.jobStateIndexPattern());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTEwNjE2Mg=="}, "originalCommit": {"oid": "589db76b94f2fdf7a62effc978ed452e7255a377"}, "originalPosition": 87}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3262, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}