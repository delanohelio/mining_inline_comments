{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc3NDk3Mzc5", "number": 52548, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwNTo0NTozOVrODhYlXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQyMDo1MTozMVrODhrNDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MzMyMzgxOnYy", "diffSide": "RIGHT", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/docker/DockerSupportPlugin.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwNTo0NTozOVrOFsF2sA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxODo1NToyNlrOFsfNMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc3NzU4NA==", "bodyText": "nit: This shouldn't start with <p>, as the first line of a javadoc is the short description.", "url": "https://github.com/elastic/elasticsearch/pull/52548#discussion_r381777584", "createdAt": "2020-02-20T05:45:39Z", "author": {"login": "rjernst"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/docker/DockerSupportPlugin.java", "diffHunk": "@@ -0,0 +1,61 @@\n+package org.elasticsearch.gradle.docker;\n+\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.Task;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n+import org.gradle.api.provider.Provider;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * <p>Plugin providing {@link DockerSupportService} for detecting Docker installations and determining requirements for Docker-based", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f32d4158d136cae5dbbd94de600dbed96fce88ad"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE5Mjk0Nw==", "bodyText": "Updated.", "url": "https://github.com/elastic/elasticsearch/pull/52548#discussion_r382192947", "createdAt": "2020-02-20T18:55:26Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/docker/DockerSupportPlugin.java", "diffHunk": "@@ -0,0 +1,61 @@\n+package org.elasticsearch.gradle.docker;\n+\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.Task;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n+import org.gradle.api.provider.Provider;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * <p>Plugin providing {@link DockerSupportService} for detecting Docker installations and determining requirements for Docker-based", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc3NzU4NA=="}, "originalCommit": {"oid": "f32d4158d136cae5dbbd94de600dbed96fce88ad"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MzMzMjE3OnYy", "diffSide": "RIGHT", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/docker/DockerSupportPlugin.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwNTo0Nzo0OFrOFsF67g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxODo1NTozM1rOFsfNYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc3ODY3MA==", "bodyText": "I know it is whacky, but <p> should basically be used as a paragraph break, without a closing tag, in javadocs. From oracle docs (https://www.oracle.com/technetwork/articles/java/index-137868.html):\n\nIf you have more than one paragraph in the doc comment, separate the paragraphs with a  paragraph tag", "url": "https://github.com/elastic/elasticsearch/pull/52548#discussion_r381778670", "createdAt": "2020-02-20T05:47:48Z", "author": {"login": "rjernst"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/docker/DockerSupportPlugin.java", "diffHunk": "@@ -0,0 +1,61 @@\n+package org.elasticsearch.gradle.docker;\n+\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.Task;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n+import org.gradle.api.provider.Provider;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * <p>Plugin providing {@link DockerSupportService} for detecting Docker installations and determining requirements for Docker-based\n+ * Elasticsearch build tasks.</p>\n+ *\n+ * <p>Additionally registers a task graph listener used to assert a compatible Docker installation exists when task requiring Docker are", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f32d4158d136cae5dbbd94de600dbed96fce88ad"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE5Mjk5NQ==", "bodyText": "Stupid javadocs. Done.", "url": "https://github.com/elastic/elasticsearch/pull/52548#discussion_r382192995", "createdAt": "2020-02-20T18:55:33Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/docker/DockerSupportPlugin.java", "diffHunk": "@@ -0,0 +1,61 @@\n+package org.elasticsearch.gradle.docker;\n+\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.Task;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n+import org.gradle.api.provider.Provider;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * <p>Plugin providing {@link DockerSupportService} for detecting Docker installations and determining requirements for Docker-based\n+ * Elasticsearch build tasks.</p>\n+ *\n+ * <p>Additionally registers a task graph listener used to assert a compatible Docker installation exists when task requiring Docker are", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc3ODY3MA=="}, "originalCommit": {"oid": "f32d4158d136cae5dbbd94de600dbed96fce88ad"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MzM0NDk5OnYy", "diffSide": "RIGHT", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/docker/DockerSupportPlugin.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwNTo1MTowNVrOFsGBZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxODo1NTo1OVrOFsfORg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc4MDMyNw==", "bodyText": "Why are we setting the property to a boolean string instead of an actual boolean?", "url": "https://github.com/elastic/elasticsearch/pull/52548#discussion_r381780327", "createdAt": "2020-02-20T05:51:05Z", "author": {"login": "rjernst"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/docker/DockerSupportPlugin.java", "diffHunk": "@@ -0,0 +1,61 @@\n+package org.elasticsearch.gradle.docker;\n+\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.Task;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n+import org.gradle.api.provider.Provider;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * <p>Plugin providing {@link DockerSupportService} for detecting Docker installations and determining requirements for Docker-based\n+ * Elasticsearch build tasks.</p>\n+ *\n+ * <p>Additionally registers a task graph listener used to assert a compatible Docker installation exists when task requiring Docker are\n+ * scheduled for execution. Tasks may declare a Docker requirement via an extra property. If a compatible Docker installation is not\n+ * available on the build system an exception will be thrown prior to task execution.</p>\n+ *\n+ * <pre>\n+ *     task myDockerTask {\n+ *         ext.requiresDocker = true\n+ *     }\n+ * </pre>\n+ */\n+public class DockerSupportPlugin implements Plugin<Project> {\n+    public static final String DOCKER_SUPPORT_SERVICE_NAME = \"dockerSupportService\";\n+    public static final String DOCKER_ON_LINUX_EXCLUSIONS_FILE = \".ci/dockerOnLinuxExclusions\";\n+    public static final String REQUIRES_DOCKER_ATTRIBUTE = \"requiresDocker\";\n+\n+    @Override\n+    public void apply(Project project) {\n+        if (project != project.getRootProject()) {\n+            throw new IllegalStateException(this.getClass().getName() + \" can only be applied to the root project.\");\n+        }\n+\n+        Provider<DockerSupportService> dockerSupportServiceProvider = project.getGradle()\n+            .getSharedServices()\n+            .registerIfAbsent(\n+                DOCKER_SUPPORT_SERVICE_NAME,\n+                DockerSupportService.class,\n+                spec -> spec.parameters(\n+                    params -> { params.setExclusionsFile(new File(project.getRootDir(), DOCKER_ON_LINUX_EXCLUSIONS_FILE)); }\n+                )\n+            );\n+\n+        // Ensure that if any tasks declare they require docker, we assert an available Docker installation exists\n+        project.getGradle().getTaskGraph().whenReady(graph -> {\n+            List<String> dockerTasks = graph.getAllTasks().stream().filter(task -> {\n+                ExtraPropertiesExtension ext = task.getExtensions().getExtraProperties();\n+                return ext.has(REQUIRES_DOCKER_ATTRIBUTE) && ext.get(REQUIRES_DOCKER_ATTRIBUTE).equals(\"true\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f32d4158d136cae5dbbd94de600dbed96fce88ad"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE5MzIyMg==", "bodyText": "We were indeed setting to a boolean but were checking for a String. I've fixed this.", "url": "https://github.com/elastic/elasticsearch/pull/52548#discussion_r382193222", "createdAt": "2020-02-20T18:55:59Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/docker/DockerSupportPlugin.java", "diffHunk": "@@ -0,0 +1,61 @@\n+package org.elasticsearch.gradle.docker;\n+\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.Task;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n+import org.gradle.api.provider.Provider;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * <p>Plugin providing {@link DockerSupportService} for detecting Docker installations and determining requirements for Docker-based\n+ * Elasticsearch build tasks.</p>\n+ *\n+ * <p>Additionally registers a task graph listener used to assert a compatible Docker installation exists when task requiring Docker are\n+ * scheduled for execution. Tasks may declare a Docker requirement via an extra property. If a compatible Docker installation is not\n+ * available on the build system an exception will be thrown prior to task execution.</p>\n+ *\n+ * <pre>\n+ *     task myDockerTask {\n+ *         ext.requiresDocker = true\n+ *     }\n+ * </pre>\n+ */\n+public class DockerSupportPlugin implements Plugin<Project> {\n+    public static final String DOCKER_SUPPORT_SERVICE_NAME = \"dockerSupportService\";\n+    public static final String DOCKER_ON_LINUX_EXCLUSIONS_FILE = \".ci/dockerOnLinuxExclusions\";\n+    public static final String REQUIRES_DOCKER_ATTRIBUTE = \"requiresDocker\";\n+\n+    @Override\n+    public void apply(Project project) {\n+        if (project != project.getRootProject()) {\n+            throw new IllegalStateException(this.getClass().getName() + \" can only be applied to the root project.\");\n+        }\n+\n+        Provider<DockerSupportService> dockerSupportServiceProvider = project.getGradle()\n+            .getSharedServices()\n+            .registerIfAbsent(\n+                DOCKER_SUPPORT_SERVICE_NAME,\n+                DockerSupportService.class,\n+                spec -> spec.parameters(\n+                    params -> { params.setExclusionsFile(new File(project.getRootDir(), DOCKER_ON_LINUX_EXCLUSIONS_FILE)); }\n+                )\n+            );\n+\n+        // Ensure that if any tasks declare they require docker, we assert an available Docker installation exists\n+        project.getGradle().getTaskGraph().whenReady(graph -> {\n+            List<String> dockerTasks = graph.getAllTasks().stream().filter(task -> {\n+                ExtraPropertiesExtension ext = task.getExtensions().getExtraProperties();\n+                return ext.has(REQUIRES_DOCKER_ATTRIBUTE) && ext.get(REQUIRES_DOCKER_ATTRIBUTE).equals(\"true\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc4MDMyNw=="}, "originalCommit": {"oid": "f32d4158d136cae5dbbd94de600dbed96fce88ad"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MzM2NTMyOnYy", "diffSide": "RIGHT", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/docker/DockerSupportService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwNTo1NTo1MlrOFsGLJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxODo1NjowN1rOFsfOlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc4MjgyMA==", "bodyText": "nit: since we are using asserts, maybe call use check or ensure terminology?", "url": "https://github.com/elastic/elasticsearch/pull/52548#discussion_r381782820", "createdAt": "2020-02-20T05:55:52Z", "author": {"login": "rjernst"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/docker/DockerSupportService.java", "diffHunk": "@@ -0,0 +1,375 @@\n+package org.elasticsearch.gradle.docker;\n+\n+import org.elasticsearch.gradle.Version;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.logging.Logger;\n+import org.gradle.api.logging.Logging;\n+import org.gradle.api.services.BuildService;\n+import org.gradle.api.services.BuildServiceParameters;\n+import org.gradle.process.ExecOperations;\n+import org.gradle.process.ExecResult;\n+\n+import javax.inject.Inject;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Build service for detecting available Docker installation and checking for compatibility with Elasticsearch Docker image build\n+ * requirements. This includes a minimum version requirement, as well as the ability to run privileged commands.\n+ */\n+public abstract class DockerSupportService implements BuildService<DockerSupportService.Parameters> {\n+\n+    private static Logger LOGGER = Logging.getLogger(DockerSupportService.class);\n+    // Defines the possible locations of the Docker CLI. These will be searched in order.\n+    private static String[] DOCKER_BINARIES = { \"/usr/bin/docker\", \"/usr/local/bin/docker\" };\n+    private static String[] DOCKER_COMPOSE_BINARIES = { \"/usr/local/bin/docker-compose\", \"/usr/bin/docker-compose\" };\n+    private static final Version MINIMUM_DOCKER_VERSION = Version.fromString(\"17.05.0\");\n+\n+    private final ExecOperations execOperations;\n+    private DockerAvailability dockerAvailability;\n+\n+    @Inject\n+    public DockerSupportService(ExecOperations execOperations) {\n+        this.execOperations = execOperations;\n+    }\n+\n+    /**\n+     * Searches for a functional Docker installation, and returns information about the search.\n+     *\n+     * @return the results of the search.\n+     */\n+    public DockerAvailability getDockerAvailability() {\n+        if (this.dockerAvailability == null) {\n+            String dockerPath = null;\n+            Result lastResult = null;\n+            Version version = null;\n+            boolean isVersionHighEnough = false;\n+            boolean isComposeAvailable = false;\n+\n+            // Check if the Docker binary exists\n+            final Optional<String> dockerBinary = getDockerPath();\n+            if (isBlacklistedOs() == false && dockerBinary.isPresent()) {\n+                dockerPath = dockerBinary.get();\n+\n+                // Since we use a multi-stage Docker build, check the Docker version meets minimum requirement\n+                lastResult = runCommand(dockerPath, \"version\", \"--format\", \"{{.Server.Version}}\");\n+\n+                if (lastResult.isSuccess()) {\n+                    version = Version.fromString(lastResult.stdout.trim(), Version.Mode.RELAXED);\n+\n+                    isVersionHighEnough = version.onOrAfter(MINIMUM_DOCKER_VERSION);\n+\n+                    if (isVersionHighEnough) {\n+                        // Check that we can execute a privileged command\n+                        lastResult = runCommand(dockerPath, \"images\");\n+\n+                        // If docker all checks out, see if docker-compose is available and working\n+                        Optional<String> composePath = getDockerComposePath();\n+                        if (lastResult.isSuccess() && composePath.isPresent()) {\n+                            isComposeAvailable = runCommand(composePath.get(), \"version\").isSuccess();\n+                        }\n+                    }\n+                }\n+            }\n+\n+            boolean isAvailable = isVersionHighEnough && lastResult != null && lastResult.isSuccess();\n+\n+            this.dockerAvailability = new DockerAvailability(\n+                isAvailable,\n+                isComposeAvailable,\n+                isVersionHighEnough,\n+                dockerPath,\n+                version,\n+                lastResult\n+            );\n+        }\n+\n+        return this.dockerAvailability;\n+    }\n+\n+    /**\n+     * Given a list of tasks that requires Docker, check whether Docker is available, otherwise throw an exception.\n+     *\n+     * @throws GradleException if Docker is not available. The exception message gives the reason.\n+     */\n+    void assertDockerIsAvailable(List<String> tasks) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f32d4158d136cae5dbbd94de600dbed96fce88ad"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE5MzMwMg==", "bodyText": "Renamed.", "url": "https://github.com/elastic/elasticsearch/pull/52548#discussion_r382193302", "createdAt": "2020-02-20T18:56:07Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/docker/DockerSupportService.java", "diffHunk": "@@ -0,0 +1,375 @@\n+package org.elasticsearch.gradle.docker;\n+\n+import org.elasticsearch.gradle.Version;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.logging.Logger;\n+import org.gradle.api.logging.Logging;\n+import org.gradle.api.services.BuildService;\n+import org.gradle.api.services.BuildServiceParameters;\n+import org.gradle.process.ExecOperations;\n+import org.gradle.process.ExecResult;\n+\n+import javax.inject.Inject;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Build service for detecting available Docker installation and checking for compatibility with Elasticsearch Docker image build\n+ * requirements. This includes a minimum version requirement, as well as the ability to run privileged commands.\n+ */\n+public abstract class DockerSupportService implements BuildService<DockerSupportService.Parameters> {\n+\n+    private static Logger LOGGER = Logging.getLogger(DockerSupportService.class);\n+    // Defines the possible locations of the Docker CLI. These will be searched in order.\n+    private static String[] DOCKER_BINARIES = { \"/usr/bin/docker\", \"/usr/local/bin/docker\" };\n+    private static String[] DOCKER_COMPOSE_BINARIES = { \"/usr/local/bin/docker-compose\", \"/usr/bin/docker-compose\" };\n+    private static final Version MINIMUM_DOCKER_VERSION = Version.fromString(\"17.05.0\");\n+\n+    private final ExecOperations execOperations;\n+    private DockerAvailability dockerAvailability;\n+\n+    @Inject\n+    public DockerSupportService(ExecOperations execOperations) {\n+        this.execOperations = execOperations;\n+    }\n+\n+    /**\n+     * Searches for a functional Docker installation, and returns information about the search.\n+     *\n+     * @return the results of the search.\n+     */\n+    public DockerAvailability getDockerAvailability() {\n+        if (this.dockerAvailability == null) {\n+            String dockerPath = null;\n+            Result lastResult = null;\n+            Version version = null;\n+            boolean isVersionHighEnough = false;\n+            boolean isComposeAvailable = false;\n+\n+            // Check if the Docker binary exists\n+            final Optional<String> dockerBinary = getDockerPath();\n+            if (isBlacklistedOs() == false && dockerBinary.isPresent()) {\n+                dockerPath = dockerBinary.get();\n+\n+                // Since we use a multi-stage Docker build, check the Docker version meets minimum requirement\n+                lastResult = runCommand(dockerPath, \"version\", \"--format\", \"{{.Server.Version}}\");\n+\n+                if (lastResult.isSuccess()) {\n+                    version = Version.fromString(lastResult.stdout.trim(), Version.Mode.RELAXED);\n+\n+                    isVersionHighEnough = version.onOrAfter(MINIMUM_DOCKER_VERSION);\n+\n+                    if (isVersionHighEnough) {\n+                        // Check that we can execute a privileged command\n+                        lastResult = runCommand(dockerPath, \"images\");\n+\n+                        // If docker all checks out, see if docker-compose is available and working\n+                        Optional<String> composePath = getDockerComposePath();\n+                        if (lastResult.isSuccess() && composePath.isPresent()) {\n+                            isComposeAvailable = runCommand(composePath.get(), \"version\").isSuccess();\n+                        }\n+                    }\n+                }\n+            }\n+\n+            boolean isAvailable = isVersionHighEnough && lastResult != null && lastResult.isSuccess();\n+\n+            this.dockerAvailability = new DockerAvailability(\n+                isAvailable,\n+                isComposeAvailable,\n+                isVersionHighEnough,\n+                dockerPath,\n+                version,\n+                lastResult\n+            );\n+        }\n+\n+        return this.dockerAvailability;\n+    }\n+\n+    /**\n+     * Given a list of tasks that requires Docker, check whether Docker is available, otherwise throw an exception.\n+     *\n+     * @throws GradleException if Docker is not available. The exception message gives the reason.\n+     */\n+    void assertDockerIsAvailable(List<String> tasks) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc4MjgyMA=="}, "originalCommit": {"oid": "f32d4158d136cae5dbbd94de600dbed96fce88ad"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MzM4ODQ2OnYy", "diffSide": "RIGHT", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/docker/DockerSupportService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwNjowMjowMVrOFsGW8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxODo1NjoxNlrOFsfO6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc4NTg0MQ==", "bodyText": "removing -> or removing?", "url": "https://github.com/elastic/elasticsearch/pull/52548#discussion_r381785841", "createdAt": "2020-02-20T06:02:01Z", "author": {"login": "rjernst"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/docker/DockerSupportService.java", "diffHunk": "@@ -0,0 +1,375 @@\n+package org.elasticsearch.gradle.docker;\n+\n+import org.elasticsearch.gradle.Version;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.logging.Logger;\n+import org.gradle.api.logging.Logging;\n+import org.gradle.api.services.BuildService;\n+import org.gradle.api.services.BuildServiceParameters;\n+import org.gradle.process.ExecOperations;\n+import org.gradle.process.ExecResult;\n+\n+import javax.inject.Inject;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Build service for detecting available Docker installation and checking for compatibility with Elasticsearch Docker image build\n+ * requirements. This includes a minimum version requirement, as well as the ability to run privileged commands.\n+ */\n+public abstract class DockerSupportService implements BuildService<DockerSupportService.Parameters> {\n+\n+    private static Logger LOGGER = Logging.getLogger(DockerSupportService.class);\n+    // Defines the possible locations of the Docker CLI. These will be searched in order.\n+    private static String[] DOCKER_BINARIES = { \"/usr/bin/docker\", \"/usr/local/bin/docker\" };\n+    private static String[] DOCKER_COMPOSE_BINARIES = { \"/usr/local/bin/docker-compose\", \"/usr/bin/docker-compose\" };\n+    private static final Version MINIMUM_DOCKER_VERSION = Version.fromString(\"17.05.0\");\n+\n+    private final ExecOperations execOperations;\n+    private DockerAvailability dockerAvailability;\n+\n+    @Inject\n+    public DockerSupportService(ExecOperations execOperations) {\n+        this.execOperations = execOperations;\n+    }\n+\n+    /**\n+     * Searches for a functional Docker installation, and returns information about the search.\n+     *\n+     * @return the results of the search.\n+     */\n+    public DockerAvailability getDockerAvailability() {\n+        if (this.dockerAvailability == null) {\n+            String dockerPath = null;\n+            Result lastResult = null;\n+            Version version = null;\n+            boolean isVersionHighEnough = false;\n+            boolean isComposeAvailable = false;\n+\n+            // Check if the Docker binary exists\n+            final Optional<String> dockerBinary = getDockerPath();\n+            if (isBlacklistedOs() == false && dockerBinary.isPresent()) {\n+                dockerPath = dockerBinary.get();\n+\n+                // Since we use a multi-stage Docker build, check the Docker version meets minimum requirement\n+                lastResult = runCommand(dockerPath, \"version\", \"--format\", \"{{.Server.Version}}\");\n+\n+                if (lastResult.isSuccess()) {\n+                    version = Version.fromString(lastResult.stdout.trim(), Version.Mode.RELAXED);\n+\n+                    isVersionHighEnough = version.onOrAfter(MINIMUM_DOCKER_VERSION);\n+\n+                    if (isVersionHighEnough) {\n+                        // Check that we can execute a privileged command\n+                        lastResult = runCommand(dockerPath, \"images\");\n+\n+                        // If docker all checks out, see if docker-compose is available and working\n+                        Optional<String> composePath = getDockerComposePath();\n+                        if (lastResult.isSuccess() && composePath.isPresent()) {\n+                            isComposeAvailable = runCommand(composePath.get(), \"version\").isSuccess();\n+                        }\n+                    }\n+                }\n+            }\n+\n+            boolean isAvailable = isVersionHighEnough && lastResult != null && lastResult.isSuccess();\n+\n+            this.dockerAvailability = new DockerAvailability(\n+                isAvailable,\n+                isComposeAvailable,\n+                isVersionHighEnough,\n+                dockerPath,\n+                version,\n+                lastResult\n+            );\n+        }\n+\n+        return this.dockerAvailability;\n+    }\n+\n+    /**\n+     * Given a list of tasks that requires Docker, check whether Docker is available, otherwise throw an exception.\n+     *\n+     * @throws GradleException if Docker is not available. The exception message gives the reason.\n+     */\n+    void assertDockerIsAvailable(List<String> tasks) {\n+        DockerAvailability availability = getDockerAvailability();\n+\n+        // Docker installation is available and compatible\n+        if (availability.isAvailable) {\n+            return;\n+        }\n+\n+        // No Docker binary was located\n+        if (availability.path == null) {\n+            final String message = String.format(\n+                Locale.ROOT,\n+                \"Docker (checked [%s]) is required to run the following task%s: \\n%s\",\n+                String.join(\", \", DOCKER_BINARIES),\n+                tasks.size() > 1 ? \"s\" : \"\",\n+                String.join(\"\\n\", tasks)\n+            );\n+            throwDockerRequiredException(message);\n+        }\n+\n+        // Docker binaries were located, but did not meet the minimum version requirement\n+        if (availability.lastCommand.isSuccess() && availability.isVersionHighEnough == false) {\n+            final String message = String.format(\n+                Locale.ROOT,\n+                \"building Docker images requires minimum Docker version of %s due to use of multi-stage builds yet was [%s]\",\n+                MINIMUM_DOCKER_VERSION,\n+                availability.version\n+            );\n+            throwDockerRequiredException(message);\n+        }\n+\n+        // Some other problem, print the error\n+        final String message = String.format(\n+            Locale.ROOT,\n+            \"a problem occurred while using Docker from [%s]%s yet it is required to run the following task%s: \\n%s\\n\"\n+                + \"the problem is that Docker exited with exit code [%d] with standard error output:\\n%s\",\n+            availability.path,\n+            availability.version == null ? \"\" : \" v\" + availability.version,\n+            tasks.size() > 1 ? \"s\" : \"\",\n+            String.join(\"\\n\", tasks),\n+            availability.lastCommand.exitCode,\n+            availability.lastCommand.stderr.trim()\n+        );\n+        throwDockerRequiredException(message);\n+    }\n+\n+    private boolean isBlacklistedOs() {\n+        // We don't attempt to check the current flavor and version of Linux unless we're\n+        // running in CI, because we don't want to stop people running the Docker tests in\n+        // their own environments if they really want to.\n+        if (BuildParams.isCi() == false) {\n+            return false;\n+        }\n+\n+        // Only some hosts in CI are configured with Docker. We attempt to work out the OS\n+        // and version, so that we know whether to expect to find Docker. We don't attempt\n+        // to probe for whether Docker is available, because that doesn't tell us whether\n+        // Docker is unavailable when it should be.\n+        final Path osRelease = Paths.get(\"/etc/os-release\");\n+\n+        if (Files.exists(osRelease)) {\n+            Map<String, String> values;\n+\n+            try {\n+                final List<String> osReleaseLines = Files.readAllLines(osRelease);\n+                values = parseOsRelease(osReleaseLines);\n+            } catch (IOException e) {\n+                throw new GradleException(\"Failed to read /etc/os-release\", e);\n+            }\n+\n+            final String id = deriveId(values);\n+            final boolean blacklisted = getLinuxExclusionList().contains(id);\n+\n+            if (blacklisted) {\n+                LOGGER.warn(\"Linux OS id [{}] is present in the Docker exclude list. Tasks requiring Docker will be disabled.\", id);\n+            }\n+\n+            return blacklisted;\n+        }\n+\n+        return false;\n+    }\n+\n+    private List<String> getLinuxExclusionList() {\n+        File exclusionsFile = getParameters().getExclusionsFile();\n+\n+        if (exclusionsFile.exists()) {\n+            try {\n+                return Files.readAllLines(exclusionsFile.toPath())\n+                    .stream()\n+                    .map(String::trim)\n+                    .filter(line -> (line.isEmpty() || line.startsWith(\"#\")) == false)\n+                    .collect(Collectors.toList());\n+            } catch (IOException e) {\n+                throw new GradleException(\"Failed to read \" + exclusionsFile.getAbsolutePath(), e);\n+            }\n+        } else {\n+            return Collections.emptyList();\n+        }\n+    }\n+\n+    // visible for testing\n+    static String deriveId(Map<String, String> values) {\n+        return values.get(\"ID\") + \"-\" + values.get(\"VERSION_ID\");\n+    }\n+\n+    // visible for testing\n+    static Map<String, String> parseOsRelease(final List<String> osReleaseLines) {\n+        final Map<String, String> values = new HashMap<>();\n+\n+        osReleaseLines.stream().map(String::trim).filter(line -> (line.isEmpty() || line.startsWith(\"#\")) == false).forEach(line -> {\n+            final String[] parts = line.split(\"=\", 2);\n+            final String key = parts[0];\n+            // remove optional leading and trailing quotes and whitespace\n+            final String value = parts[1].replaceAll(\"^['\\\"]?\\\\s*\", \"\").replaceAll(\"\\\\s*['\\\"]?$\", \"\");\n+\n+            values.put(key, value);\n+        });\n+\n+        return values;\n+    }\n+\n+    /**\n+     * Searches the entries in {@link #DOCKER_BINARIES} for the Docker CLI. This method does\n+     * not check whether the Docker installation appears usable, see {@link #getDockerAvailability()}\n+     * instead.\n+     *\n+     * @return the path to a CLI, if available.\n+     */\n+    private Optional<String> getDockerPath() {\n+        // Check if the Docker binary exists\n+        return List.of(DOCKER_BINARIES).stream().filter(path -> new File(path).exists()).findFirst();\n+    }\n+\n+    /**\n+     * Searches the entries in {@link #DOCKER_COMPOSE_BINARIES} for the Docker Compose CLI. This method does\n+     * not check whether the installation appears usable, see {@link #getDockerAvailability()} instead.\n+     *\n+     * @return the path to a CLI, if available.\n+     */\n+    private Optional<String> getDockerComposePath() {\n+        // Check if the Docker binary exists\n+        return List.of(DOCKER_COMPOSE_BINARIES).stream().filter(path -> new File(path).exists()).findFirst();\n+    }\n+\n+    private void throwDockerRequiredException(final String message) {\n+        throwDockerRequiredException(message, null);\n+    }\n+\n+    private void throwDockerRequiredException(final String message, Exception e) {\n+        throw new GradleException(\n+            message + \"\\nyou can address this by attending to the reported issue, \" + \"removing the offending tasks from being executed.\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f32d4158d136cae5dbbd94de600dbed96fce88ad"}, "originalPosition": 258}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE5MzM4Nw==", "bodyText": "I've reworded this message.", "url": "https://github.com/elastic/elasticsearch/pull/52548#discussion_r382193387", "createdAt": "2020-02-20T18:56:16Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/docker/DockerSupportService.java", "diffHunk": "@@ -0,0 +1,375 @@\n+package org.elasticsearch.gradle.docker;\n+\n+import org.elasticsearch.gradle.Version;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.logging.Logger;\n+import org.gradle.api.logging.Logging;\n+import org.gradle.api.services.BuildService;\n+import org.gradle.api.services.BuildServiceParameters;\n+import org.gradle.process.ExecOperations;\n+import org.gradle.process.ExecResult;\n+\n+import javax.inject.Inject;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Build service for detecting available Docker installation and checking for compatibility with Elasticsearch Docker image build\n+ * requirements. This includes a minimum version requirement, as well as the ability to run privileged commands.\n+ */\n+public abstract class DockerSupportService implements BuildService<DockerSupportService.Parameters> {\n+\n+    private static Logger LOGGER = Logging.getLogger(DockerSupportService.class);\n+    // Defines the possible locations of the Docker CLI. These will be searched in order.\n+    private static String[] DOCKER_BINARIES = { \"/usr/bin/docker\", \"/usr/local/bin/docker\" };\n+    private static String[] DOCKER_COMPOSE_BINARIES = { \"/usr/local/bin/docker-compose\", \"/usr/bin/docker-compose\" };\n+    private static final Version MINIMUM_DOCKER_VERSION = Version.fromString(\"17.05.0\");\n+\n+    private final ExecOperations execOperations;\n+    private DockerAvailability dockerAvailability;\n+\n+    @Inject\n+    public DockerSupportService(ExecOperations execOperations) {\n+        this.execOperations = execOperations;\n+    }\n+\n+    /**\n+     * Searches for a functional Docker installation, and returns information about the search.\n+     *\n+     * @return the results of the search.\n+     */\n+    public DockerAvailability getDockerAvailability() {\n+        if (this.dockerAvailability == null) {\n+            String dockerPath = null;\n+            Result lastResult = null;\n+            Version version = null;\n+            boolean isVersionHighEnough = false;\n+            boolean isComposeAvailable = false;\n+\n+            // Check if the Docker binary exists\n+            final Optional<String> dockerBinary = getDockerPath();\n+            if (isBlacklistedOs() == false && dockerBinary.isPresent()) {\n+                dockerPath = dockerBinary.get();\n+\n+                // Since we use a multi-stage Docker build, check the Docker version meets minimum requirement\n+                lastResult = runCommand(dockerPath, \"version\", \"--format\", \"{{.Server.Version}}\");\n+\n+                if (lastResult.isSuccess()) {\n+                    version = Version.fromString(lastResult.stdout.trim(), Version.Mode.RELAXED);\n+\n+                    isVersionHighEnough = version.onOrAfter(MINIMUM_DOCKER_VERSION);\n+\n+                    if (isVersionHighEnough) {\n+                        // Check that we can execute a privileged command\n+                        lastResult = runCommand(dockerPath, \"images\");\n+\n+                        // If docker all checks out, see if docker-compose is available and working\n+                        Optional<String> composePath = getDockerComposePath();\n+                        if (lastResult.isSuccess() && composePath.isPresent()) {\n+                            isComposeAvailable = runCommand(composePath.get(), \"version\").isSuccess();\n+                        }\n+                    }\n+                }\n+            }\n+\n+            boolean isAvailable = isVersionHighEnough && lastResult != null && lastResult.isSuccess();\n+\n+            this.dockerAvailability = new DockerAvailability(\n+                isAvailable,\n+                isComposeAvailable,\n+                isVersionHighEnough,\n+                dockerPath,\n+                version,\n+                lastResult\n+            );\n+        }\n+\n+        return this.dockerAvailability;\n+    }\n+\n+    /**\n+     * Given a list of tasks that requires Docker, check whether Docker is available, otherwise throw an exception.\n+     *\n+     * @throws GradleException if Docker is not available. The exception message gives the reason.\n+     */\n+    void assertDockerIsAvailable(List<String> tasks) {\n+        DockerAvailability availability = getDockerAvailability();\n+\n+        // Docker installation is available and compatible\n+        if (availability.isAvailable) {\n+            return;\n+        }\n+\n+        // No Docker binary was located\n+        if (availability.path == null) {\n+            final String message = String.format(\n+                Locale.ROOT,\n+                \"Docker (checked [%s]) is required to run the following task%s: \\n%s\",\n+                String.join(\", \", DOCKER_BINARIES),\n+                tasks.size() > 1 ? \"s\" : \"\",\n+                String.join(\"\\n\", tasks)\n+            );\n+            throwDockerRequiredException(message);\n+        }\n+\n+        // Docker binaries were located, but did not meet the minimum version requirement\n+        if (availability.lastCommand.isSuccess() && availability.isVersionHighEnough == false) {\n+            final String message = String.format(\n+                Locale.ROOT,\n+                \"building Docker images requires minimum Docker version of %s due to use of multi-stage builds yet was [%s]\",\n+                MINIMUM_DOCKER_VERSION,\n+                availability.version\n+            );\n+            throwDockerRequiredException(message);\n+        }\n+\n+        // Some other problem, print the error\n+        final String message = String.format(\n+            Locale.ROOT,\n+            \"a problem occurred while using Docker from [%s]%s yet it is required to run the following task%s: \\n%s\\n\"\n+                + \"the problem is that Docker exited with exit code [%d] with standard error output:\\n%s\",\n+            availability.path,\n+            availability.version == null ? \"\" : \" v\" + availability.version,\n+            tasks.size() > 1 ? \"s\" : \"\",\n+            String.join(\"\\n\", tasks),\n+            availability.lastCommand.exitCode,\n+            availability.lastCommand.stderr.trim()\n+        );\n+        throwDockerRequiredException(message);\n+    }\n+\n+    private boolean isBlacklistedOs() {\n+        // We don't attempt to check the current flavor and version of Linux unless we're\n+        // running in CI, because we don't want to stop people running the Docker tests in\n+        // their own environments if they really want to.\n+        if (BuildParams.isCi() == false) {\n+            return false;\n+        }\n+\n+        // Only some hosts in CI are configured with Docker. We attempt to work out the OS\n+        // and version, so that we know whether to expect to find Docker. We don't attempt\n+        // to probe for whether Docker is available, because that doesn't tell us whether\n+        // Docker is unavailable when it should be.\n+        final Path osRelease = Paths.get(\"/etc/os-release\");\n+\n+        if (Files.exists(osRelease)) {\n+            Map<String, String> values;\n+\n+            try {\n+                final List<String> osReleaseLines = Files.readAllLines(osRelease);\n+                values = parseOsRelease(osReleaseLines);\n+            } catch (IOException e) {\n+                throw new GradleException(\"Failed to read /etc/os-release\", e);\n+            }\n+\n+            final String id = deriveId(values);\n+            final boolean blacklisted = getLinuxExclusionList().contains(id);\n+\n+            if (blacklisted) {\n+                LOGGER.warn(\"Linux OS id [{}] is present in the Docker exclude list. Tasks requiring Docker will be disabled.\", id);\n+            }\n+\n+            return blacklisted;\n+        }\n+\n+        return false;\n+    }\n+\n+    private List<String> getLinuxExclusionList() {\n+        File exclusionsFile = getParameters().getExclusionsFile();\n+\n+        if (exclusionsFile.exists()) {\n+            try {\n+                return Files.readAllLines(exclusionsFile.toPath())\n+                    .stream()\n+                    .map(String::trim)\n+                    .filter(line -> (line.isEmpty() || line.startsWith(\"#\")) == false)\n+                    .collect(Collectors.toList());\n+            } catch (IOException e) {\n+                throw new GradleException(\"Failed to read \" + exclusionsFile.getAbsolutePath(), e);\n+            }\n+        } else {\n+            return Collections.emptyList();\n+        }\n+    }\n+\n+    // visible for testing\n+    static String deriveId(Map<String, String> values) {\n+        return values.get(\"ID\") + \"-\" + values.get(\"VERSION_ID\");\n+    }\n+\n+    // visible for testing\n+    static Map<String, String> parseOsRelease(final List<String> osReleaseLines) {\n+        final Map<String, String> values = new HashMap<>();\n+\n+        osReleaseLines.stream().map(String::trim).filter(line -> (line.isEmpty() || line.startsWith(\"#\")) == false).forEach(line -> {\n+            final String[] parts = line.split(\"=\", 2);\n+            final String key = parts[0];\n+            // remove optional leading and trailing quotes and whitespace\n+            final String value = parts[1].replaceAll(\"^['\\\"]?\\\\s*\", \"\").replaceAll(\"\\\\s*['\\\"]?$\", \"\");\n+\n+            values.put(key, value);\n+        });\n+\n+        return values;\n+    }\n+\n+    /**\n+     * Searches the entries in {@link #DOCKER_BINARIES} for the Docker CLI. This method does\n+     * not check whether the Docker installation appears usable, see {@link #getDockerAvailability()}\n+     * instead.\n+     *\n+     * @return the path to a CLI, if available.\n+     */\n+    private Optional<String> getDockerPath() {\n+        // Check if the Docker binary exists\n+        return List.of(DOCKER_BINARIES).stream().filter(path -> new File(path).exists()).findFirst();\n+    }\n+\n+    /**\n+     * Searches the entries in {@link #DOCKER_COMPOSE_BINARIES} for the Docker Compose CLI. This method does\n+     * not check whether the installation appears usable, see {@link #getDockerAvailability()} instead.\n+     *\n+     * @return the path to a CLI, if available.\n+     */\n+    private Optional<String> getDockerComposePath() {\n+        // Check if the Docker binary exists\n+        return List.of(DOCKER_COMPOSE_BINARIES).stream().filter(path -> new File(path).exists()).findFirst();\n+    }\n+\n+    private void throwDockerRequiredException(final String message) {\n+        throwDockerRequiredException(message, null);\n+    }\n+\n+    private void throwDockerRequiredException(final String message, Exception e) {\n+        throw new GradleException(\n+            message + \"\\nyou can address this by attending to the reported issue, \" + \"removing the offending tasks from being executed.\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc4NTg0MQ=="}, "originalCommit": {"oid": "f32d4158d136cae5dbbd94de600dbed96fce88ad"}, "originalPosition": 258}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MzQwMjYxOnYy", "diffSide": "RIGHT", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/test/DistroTestPlugin.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwNjowNToxMFrOFsGdlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxODo0MjoxOVrOFseycQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc4NzU0MQ==", "bodyText": "Why onlyIf here instead of using the requiresDocker property?", "url": "https://github.com/elastic/elasticsearch/pull/52548#discussion_r381787541", "createdAt": "2020-02-20T06:05:10Z", "author": {"login": "rjernst"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/test/DistroTestPlugin.java", "diffHunk": "@@ -324,8 +322,14 @@ public String toString() {\n         });\n     }\n \n-    private static TaskProvider<?> configureDistroTest(Project project, ElasticsearchDistribution distribution) {\n+    private static TaskProvider<?> configureDistroTest(\n+        Project project,\n+        ElasticsearchDistribution distribution,\n+        Provider<DockerSupportService> dockerSupport\n+    ) {\n         return project.getTasks().register(destructiveDistroTestTaskName(distribution), Test.class, t -> {\n+            // Disable Docker distribution tests unless a Docker installation is available\n+            t.onlyIf(t2 -> distribution.getType() != Type.DOCKER || dockerSupport.get().getDockerAvailability().isAvailable);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f32d4158d136cae5dbbd94de600dbed96fce88ad"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE4NjA5Nw==", "bodyText": "As discussed, using requiresDocker is strict. It fails the build if docker is unavailable. We want to simply skip that task in that scenario.", "url": "https://github.com/elastic/elasticsearch/pull/52548#discussion_r382186097", "createdAt": "2020-02-20T18:42:19Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/test/DistroTestPlugin.java", "diffHunk": "@@ -324,8 +322,14 @@ public String toString() {\n         });\n     }\n \n-    private static TaskProvider<?> configureDistroTest(Project project, ElasticsearchDistribution distribution) {\n+    private static TaskProvider<?> configureDistroTest(\n+        Project project,\n+        ElasticsearchDistribution distribution,\n+        Provider<DockerSupportService> dockerSupport\n+    ) {\n         return project.getTasks().register(destructiveDistroTestTaskName(distribution), Test.class, t -> {\n+            // Disable Docker distribution tests unless a Docker installation is available\n+            t.onlyIf(t2 -> distribution.getType() != Type.DOCKER || dockerSupport.get().getDockerAvailability().isAvailable);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc4NzU0MQ=="}, "originalCommit": {"oid": "f32d4158d136cae5dbbd94de600dbed96fce88ad"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NDA1MzM0OnYy", "diffSide": "RIGHT", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/docker/DockerSupportService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwOTozNjozN1rOFsMSIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxODowMzoyOVrOFsdksw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg4MjkxNA==", "bodyText": "We should stay away from terms like \"blacklist\" and \"whitelist\".\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private boolean isBlacklistedOs() {\n          \n          \n            \n                private boolean isExcludedOs() {", "url": "https://github.com/elastic/elasticsearch/pull/52548#discussion_r381882914", "createdAt": "2020-02-20T09:36:37Z", "author": {"login": "pugnascotia"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/docker/DockerSupportService.java", "diffHunk": "@@ -0,0 +1,375 @@\n+package org.elasticsearch.gradle.docker;\n+\n+import org.elasticsearch.gradle.Version;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.logging.Logger;\n+import org.gradle.api.logging.Logging;\n+import org.gradle.api.services.BuildService;\n+import org.gradle.api.services.BuildServiceParameters;\n+import org.gradle.process.ExecOperations;\n+import org.gradle.process.ExecResult;\n+\n+import javax.inject.Inject;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Build service for detecting available Docker installation and checking for compatibility with Elasticsearch Docker image build\n+ * requirements. This includes a minimum version requirement, as well as the ability to run privileged commands.\n+ */\n+public abstract class DockerSupportService implements BuildService<DockerSupportService.Parameters> {\n+\n+    private static Logger LOGGER = Logging.getLogger(DockerSupportService.class);\n+    // Defines the possible locations of the Docker CLI. These will be searched in order.\n+    private static String[] DOCKER_BINARIES = { \"/usr/bin/docker\", \"/usr/local/bin/docker\" };\n+    private static String[] DOCKER_COMPOSE_BINARIES = { \"/usr/local/bin/docker-compose\", \"/usr/bin/docker-compose\" };\n+    private static final Version MINIMUM_DOCKER_VERSION = Version.fromString(\"17.05.0\");\n+\n+    private final ExecOperations execOperations;\n+    private DockerAvailability dockerAvailability;\n+\n+    @Inject\n+    public DockerSupportService(ExecOperations execOperations) {\n+        this.execOperations = execOperations;\n+    }\n+\n+    /**\n+     * Searches for a functional Docker installation, and returns information about the search.\n+     *\n+     * @return the results of the search.\n+     */\n+    public DockerAvailability getDockerAvailability() {\n+        if (this.dockerAvailability == null) {\n+            String dockerPath = null;\n+            Result lastResult = null;\n+            Version version = null;\n+            boolean isVersionHighEnough = false;\n+            boolean isComposeAvailable = false;\n+\n+            // Check if the Docker binary exists\n+            final Optional<String> dockerBinary = getDockerPath();\n+            if (isBlacklistedOs() == false && dockerBinary.isPresent()) {\n+                dockerPath = dockerBinary.get();\n+\n+                // Since we use a multi-stage Docker build, check the Docker version meets minimum requirement\n+                lastResult = runCommand(dockerPath, \"version\", \"--format\", \"{{.Server.Version}}\");\n+\n+                if (lastResult.isSuccess()) {\n+                    version = Version.fromString(lastResult.stdout.trim(), Version.Mode.RELAXED);\n+\n+                    isVersionHighEnough = version.onOrAfter(MINIMUM_DOCKER_VERSION);\n+\n+                    if (isVersionHighEnough) {\n+                        // Check that we can execute a privileged command\n+                        lastResult = runCommand(dockerPath, \"images\");\n+\n+                        // If docker all checks out, see if docker-compose is available and working\n+                        Optional<String> composePath = getDockerComposePath();\n+                        if (lastResult.isSuccess() && composePath.isPresent()) {\n+                            isComposeAvailable = runCommand(composePath.get(), \"version\").isSuccess();\n+                        }\n+                    }\n+                }\n+            }\n+\n+            boolean isAvailable = isVersionHighEnough && lastResult != null && lastResult.isSuccess();\n+\n+            this.dockerAvailability = new DockerAvailability(\n+                isAvailable,\n+                isComposeAvailable,\n+                isVersionHighEnough,\n+                dockerPath,\n+                version,\n+                lastResult\n+            );\n+        }\n+\n+        return this.dockerAvailability;\n+    }\n+\n+    /**\n+     * Given a list of tasks that requires Docker, check whether Docker is available, otherwise throw an exception.\n+     *\n+     * @throws GradleException if Docker is not available. The exception message gives the reason.\n+     */\n+    void assertDockerIsAvailable(List<String> tasks) {\n+        DockerAvailability availability = getDockerAvailability();\n+\n+        // Docker installation is available and compatible\n+        if (availability.isAvailable) {\n+            return;\n+        }\n+\n+        // No Docker binary was located\n+        if (availability.path == null) {\n+            final String message = String.format(\n+                Locale.ROOT,\n+                \"Docker (checked [%s]) is required to run the following task%s: \\n%s\",\n+                String.join(\", \", DOCKER_BINARIES),\n+                tasks.size() > 1 ? \"s\" : \"\",\n+                String.join(\"\\n\", tasks)\n+            );\n+            throwDockerRequiredException(message);\n+        }\n+\n+        // Docker binaries were located, but did not meet the minimum version requirement\n+        if (availability.lastCommand.isSuccess() && availability.isVersionHighEnough == false) {\n+            final String message = String.format(\n+                Locale.ROOT,\n+                \"building Docker images requires minimum Docker version of %s due to use of multi-stage builds yet was [%s]\",\n+                MINIMUM_DOCKER_VERSION,\n+                availability.version\n+            );\n+            throwDockerRequiredException(message);\n+        }\n+\n+        // Some other problem, print the error\n+        final String message = String.format(\n+            Locale.ROOT,\n+            \"a problem occurred while using Docker from [%s]%s yet it is required to run the following task%s: \\n%s\\n\"\n+                + \"the problem is that Docker exited with exit code [%d] with standard error output:\\n%s\",\n+            availability.path,\n+            availability.version == null ? \"\" : \" v\" + availability.version,\n+            tasks.size() > 1 ? \"s\" : \"\",\n+            String.join(\"\\n\", tasks),\n+            availability.lastCommand.exitCode,\n+            availability.lastCommand.stderr.trim()\n+        );\n+        throwDockerRequiredException(message);\n+    }\n+\n+    private boolean isBlacklistedOs() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f32d4158d136cae5dbbd94de600dbed96fce88ad"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE2NjE5NQ==", "bodyText": "Agreed. I've renamed this.", "url": "https://github.com/elastic/elasticsearch/pull/52548#discussion_r382166195", "createdAt": "2020-02-20T18:03:29Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/docker/DockerSupportService.java", "diffHunk": "@@ -0,0 +1,375 @@\n+package org.elasticsearch.gradle.docker;\n+\n+import org.elasticsearch.gradle.Version;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.logging.Logger;\n+import org.gradle.api.logging.Logging;\n+import org.gradle.api.services.BuildService;\n+import org.gradle.api.services.BuildServiceParameters;\n+import org.gradle.process.ExecOperations;\n+import org.gradle.process.ExecResult;\n+\n+import javax.inject.Inject;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Build service for detecting available Docker installation and checking for compatibility with Elasticsearch Docker image build\n+ * requirements. This includes a minimum version requirement, as well as the ability to run privileged commands.\n+ */\n+public abstract class DockerSupportService implements BuildService<DockerSupportService.Parameters> {\n+\n+    private static Logger LOGGER = Logging.getLogger(DockerSupportService.class);\n+    // Defines the possible locations of the Docker CLI. These will be searched in order.\n+    private static String[] DOCKER_BINARIES = { \"/usr/bin/docker\", \"/usr/local/bin/docker\" };\n+    private static String[] DOCKER_COMPOSE_BINARIES = { \"/usr/local/bin/docker-compose\", \"/usr/bin/docker-compose\" };\n+    private static final Version MINIMUM_DOCKER_VERSION = Version.fromString(\"17.05.0\");\n+\n+    private final ExecOperations execOperations;\n+    private DockerAvailability dockerAvailability;\n+\n+    @Inject\n+    public DockerSupportService(ExecOperations execOperations) {\n+        this.execOperations = execOperations;\n+    }\n+\n+    /**\n+     * Searches for a functional Docker installation, and returns information about the search.\n+     *\n+     * @return the results of the search.\n+     */\n+    public DockerAvailability getDockerAvailability() {\n+        if (this.dockerAvailability == null) {\n+            String dockerPath = null;\n+            Result lastResult = null;\n+            Version version = null;\n+            boolean isVersionHighEnough = false;\n+            boolean isComposeAvailable = false;\n+\n+            // Check if the Docker binary exists\n+            final Optional<String> dockerBinary = getDockerPath();\n+            if (isBlacklistedOs() == false && dockerBinary.isPresent()) {\n+                dockerPath = dockerBinary.get();\n+\n+                // Since we use a multi-stage Docker build, check the Docker version meets minimum requirement\n+                lastResult = runCommand(dockerPath, \"version\", \"--format\", \"{{.Server.Version}}\");\n+\n+                if (lastResult.isSuccess()) {\n+                    version = Version.fromString(lastResult.stdout.trim(), Version.Mode.RELAXED);\n+\n+                    isVersionHighEnough = version.onOrAfter(MINIMUM_DOCKER_VERSION);\n+\n+                    if (isVersionHighEnough) {\n+                        // Check that we can execute a privileged command\n+                        lastResult = runCommand(dockerPath, \"images\");\n+\n+                        // If docker all checks out, see if docker-compose is available and working\n+                        Optional<String> composePath = getDockerComposePath();\n+                        if (lastResult.isSuccess() && composePath.isPresent()) {\n+                            isComposeAvailable = runCommand(composePath.get(), \"version\").isSuccess();\n+                        }\n+                    }\n+                }\n+            }\n+\n+            boolean isAvailable = isVersionHighEnough && lastResult != null && lastResult.isSuccess();\n+\n+            this.dockerAvailability = new DockerAvailability(\n+                isAvailable,\n+                isComposeAvailable,\n+                isVersionHighEnough,\n+                dockerPath,\n+                version,\n+                lastResult\n+            );\n+        }\n+\n+        return this.dockerAvailability;\n+    }\n+\n+    /**\n+     * Given a list of tasks that requires Docker, check whether Docker is available, otherwise throw an exception.\n+     *\n+     * @throws GradleException if Docker is not available. The exception message gives the reason.\n+     */\n+    void assertDockerIsAvailable(List<String> tasks) {\n+        DockerAvailability availability = getDockerAvailability();\n+\n+        // Docker installation is available and compatible\n+        if (availability.isAvailable) {\n+            return;\n+        }\n+\n+        // No Docker binary was located\n+        if (availability.path == null) {\n+            final String message = String.format(\n+                Locale.ROOT,\n+                \"Docker (checked [%s]) is required to run the following task%s: \\n%s\",\n+                String.join(\", \", DOCKER_BINARIES),\n+                tasks.size() > 1 ? \"s\" : \"\",\n+                String.join(\"\\n\", tasks)\n+            );\n+            throwDockerRequiredException(message);\n+        }\n+\n+        // Docker binaries were located, but did not meet the minimum version requirement\n+        if (availability.lastCommand.isSuccess() && availability.isVersionHighEnough == false) {\n+            final String message = String.format(\n+                Locale.ROOT,\n+                \"building Docker images requires minimum Docker version of %s due to use of multi-stage builds yet was [%s]\",\n+                MINIMUM_DOCKER_VERSION,\n+                availability.version\n+            );\n+            throwDockerRequiredException(message);\n+        }\n+\n+        // Some other problem, print the error\n+        final String message = String.format(\n+            Locale.ROOT,\n+            \"a problem occurred while using Docker from [%s]%s yet it is required to run the following task%s: \\n%s\\n\"\n+                + \"the problem is that Docker exited with exit code [%d] with standard error output:\\n%s\",\n+            availability.path,\n+            availability.version == null ? \"\" : \" v\" + availability.version,\n+            tasks.size() > 1 ? \"s\" : \"\",\n+            String.join(\"\\n\", tasks),\n+            availability.lastCommand.exitCode,\n+            availability.lastCommand.stderr.trim()\n+        );\n+        throwDockerRequiredException(message);\n+    }\n+\n+    private boolean isBlacklistedOs() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg4MjkxNA=="}, "originalCommit": {"oid": "f32d4158d136cae5dbbd94de600dbed96fce88ad"}, "originalPosition": 153}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NDA4NDA5OnYy", "diffSide": "RIGHT", "path": "distribution/docker/build.gradle", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwOTo0NToxN1rOFsMlCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxODowNDoyNFrOFsdmbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg4Nzc1Mw==", "bodyText": "Does this only skip testing? Docker is required for a successful overall build on supported OSs, no?", "url": "https://github.com/elastic/elasticsearch/pull/52548#discussion_r381887753", "createdAt": "2020-02-20T09:45:17Z", "author": {"login": "pugnascotia"}, "path": "distribution/docker/build.gradle", "diffHunk": "@@ -105,10 +106,19 @@ task copyKeystore(type: Sync) {\n   }\n }\n \n-preProcessFixture {\n-  if (TestFixturesPlugin.dockerComposeSupported()) {\n-    dependsOn assemble\n+elasticsearch_distributions {\n+  Flavor.values().each { distroFlavor ->\n+    \"docker_$distroFlavor\" {\n+      flavor = distroFlavor\n+      type = 'docker'\n+      version = VersionProperties.getElasticsearch()\n+      required = false // This ensures we skip this testing if Docker is unavailable", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f32d4158d136cae5dbbd94de600dbed96fce88ad"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE2NDMwMQ==", "bodyText": "This skips building the upstream docker images that are consumed by the tests. I realize now that comment isn't great, I'll improve it.", "url": "https://github.com/elastic/elasticsearch/pull/52548#discussion_r382164301", "createdAt": "2020-02-20T17:59:43Z", "author": {"login": "mark-vieira"}, "path": "distribution/docker/build.gradle", "diffHunk": "@@ -105,10 +106,19 @@ task copyKeystore(type: Sync) {\n   }\n }\n \n-preProcessFixture {\n-  if (TestFixturesPlugin.dockerComposeSupported()) {\n-    dependsOn assemble\n+elasticsearch_distributions {\n+  Flavor.values().each { distroFlavor ->\n+    \"docker_$distroFlavor\" {\n+      flavor = distroFlavor\n+      type = 'docker'\n+      version = VersionProperties.getElasticsearch()\n+      required = false // This ensures we skip this testing if Docker is unavailable", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg4Nzc1Mw=="}, "originalCommit": {"oid": "f32d4158d136cae5dbbd94de600dbed96fce88ad"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE2NjYzOA==", "bodyText": "I updated the comment text to make it clear this simply makes building the images optional. The logic for actually skipping the tests themselves lives in TestFixturesPlugin.", "url": "https://github.com/elastic/elasticsearch/pull/52548#discussion_r382166638", "createdAt": "2020-02-20T18:04:24Z", "author": {"login": "mark-vieira"}, "path": "distribution/docker/build.gradle", "diffHunk": "@@ -105,10 +106,19 @@ task copyKeystore(type: Sync) {\n   }\n }\n \n-preProcessFixture {\n-  if (TestFixturesPlugin.dockerComposeSupported()) {\n-    dependsOn assemble\n+elasticsearch_distributions {\n+  Flavor.values().each { distroFlavor ->\n+    \"docker_$distroFlavor\" {\n+      flavor = distroFlavor\n+      type = 'docker'\n+      version = VersionProperties.getElasticsearch()\n+      required = false // This ensures we skip this testing if Docker is unavailable", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg4Nzc1Mw=="}, "originalCommit": {"oid": "f32d4158d136cae5dbbd94de600dbed96fce88ad"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NjM3NDUyOnYy", "diffSide": "RIGHT", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/ElasticsearchDistribution.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQyMDo1MTozMVrOFsit4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQyMDo1MjowOFrOFsivRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI1MDQ2NQ==", "bodyText": "bundledJdk setting?", "url": "https://github.com/elastic/elasticsearch/pull/52548#discussion_r382250465", "createdAt": "2020-02-20T20:51:31Z", "author": {"login": "rjernst"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/ElasticsearchDistribution.java", "diffHunk": "@@ -270,6 +276,11 @@ void finalizeValues() {\n                     \"platform not allowed for elasticsearch distribution [\" + name + \"] of type [\" + getType() + \"]\"\n                 );\n             }\n+            if (getType() == Type.DOCKER && bundledJdk.isPresent()) {\n+                throw new IllegalArgumentException(\n+                    \"bundledJdk not allowed for elasticsearch distribution [\" + name + \"] of type [docker]\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a3cf2d451fa1c485393616db11de37b787afe66"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI1MDgyMg==", "bodyText": "or property or something like that? as it is written it sounds like docker can't use the bundledJdk, when in face it only uses it.", "url": "https://github.com/elastic/elasticsearch/pull/52548#discussion_r382250822", "createdAt": "2020-02-20T20:52:08Z", "author": {"login": "rjernst"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/ElasticsearchDistribution.java", "diffHunk": "@@ -270,6 +276,11 @@ void finalizeValues() {\n                     \"platform not allowed for elasticsearch distribution [\" + name + \"] of type [\" + getType() + \"]\"\n                 );\n             }\n+            if (getType() == Type.DOCKER && bundledJdk.isPresent()) {\n+                throw new IllegalArgumentException(\n+                    \"bundledJdk not allowed for elasticsearch distribution [\" + name + \"] of type [docker]\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI1MDQ2NQ=="}, "originalCommit": {"oid": "4a3cf2d451fa1c485393616db11de37b787afe66"}, "originalPosition": 63}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3830, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}