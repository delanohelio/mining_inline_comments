{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE0MjU2MjEz", "number": 64500, "title": "Clean up MultiFields implementation", "bodyText": "removes ImmutableOpenMap in favour of java Map\nenforce FieldMapper in place of Mapper through static typing\nreplace anonymous Builders with a simple function", "createdAt": "2020-11-02T18:57:09Z", "url": "https://github.com/elastic/elasticsearch/pull/64500", "merged": true, "mergeCommit": {"oid": "b33423e424870f71ed8f61cc5e5c59bd1aedbd84"}, "closed": true, "closedAt": "2020-11-04T17:07:47Z", "author": {"login": "romseygeek"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdSF7jrgH2gAyNTE0MjU2MjEzOjYwYWMzNTNjODFkZWVlNTUzOWY5OGI1MTY2ODdkYjAwOWM3YmI1ZjY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdZQLCqgH2gAyNTE0MjU2MjEzOjQ1ZjAzNzIwNWVjZTc2NTBiYjFkZTg2NDQzOGNhOWRjMzA5ZWQ0Mzg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "60ac353c81deee5539f98b516687db009c7bb5f6", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/elastic/elasticsearch/commit/60ac353c81deee5539f98b516687db009c7bb5f6", "committedDate": "2020-10-13T10:22:27Z", "message": "WIP"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d287714ca25748d6af4d44c387885afc917f9213", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/elastic/elasticsearch/commit/d287714ca25748d6af4d44c387885afc917f9213", "committedDate": "2020-11-02T17:27:42Z", "message": "Merge remote-tracking branch 'origin/master' into mapper/multifields-builder"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "55599e3d038e3387c60db106cd2b9f54328e8418", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/elastic/elasticsearch/commit/55599e3d038e3387c60db106cd2b9f54328e8418", "committedDate": "2020-11-02T18:57:31Z", "message": "don't need to cast"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyMDc2ODkx", "url": "https://github.com/elastic/elasticsearch/pull/64500#pullrequestreview-522076891", "createdAt": "2020-11-02T22:35:41Z", "commit": {"oid": "55599e3d038e3387c60db106cd2b9f54328e8418"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMjozNTo0MVrOHsYPTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMjo0Njo0NlrOHsYs5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI5NjUyNw==", "bodyText": "I'm kind of surprised that there isn't a simpler way to do this. But, \ud83e\udd37", "url": "https://github.com/elastic/elasticsearch/pull/64500#discussion_r516296527", "createdAt": "2020-11-02T22:35:41Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java", "diffHunk": "@@ -163,7 +160,18 @@ protected final void createFieldNamesField(ParseContext context) {\n \n     @Override\n     public Iterator<Mapper> iterator() {\n-        return multiFields.iterator();\n+        Iterator<FieldMapper> multiFieldsIterator = multiFields.iterator();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55599e3d038e3387c60db106cd2b9f54328e8418"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI5Njg0NQ==", "bodyText": "Yeah, I don't imagine ImmutableOpenMap is buying us too much. Might be worth git blame to see if there is anything back in the mists of time explaining it.", "url": "https://github.com/elastic/elasticsearch/pull/64500#discussion_r516296845", "createdAt": "2020-11-02T22:36:27Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java", "diffHunk": "@@ -284,72 +292,58 @@ protected void doXContentBody(XContentBuilder builder, boolean includeDefaults,\n \n     protected abstract String contentType();\n \n-    public static class MultiFields implements Iterable<Mapper> {\n+    public static class MultiFields implements Iterable<FieldMapper> {\n \n         public static MultiFields empty() {\n-            return new MultiFields(ImmutableOpenMap.<String, FieldMapper>of());\n+            return new MultiFields(Collections.emptyMap());\n         }\n \n         public static class Builder {\n \n-            private final ImmutableOpenMap.Builder<String, Mapper.Builder> mapperBuilders = ImmutableOpenMap.builder();\n+            private final Map<String, Function<BuilderContext, FieldMapper>> mapperBuilders = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55599e3d038e3387c60db106cd2b9f54328e8418"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI5OTIwMg==", "bodyText": "Wrap in unmodifiableMap or call Map.of on it? Just for extra double paranoia that it is immutable.", "url": "https://github.com/elastic/elasticsearch/pull/64500#discussion_r516299202", "createdAt": "2020-11-02T22:39:55Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java", "diffHunk": "@@ -284,72 +292,58 @@ protected void doXContentBody(XContentBuilder builder, boolean includeDefaults,\n \n     protected abstract String contentType();\n \n-    public static class MultiFields implements Iterable<Mapper> {\n+    public static class MultiFields implements Iterable<FieldMapper> {\n \n         public static MultiFields empty() {\n-            return new MultiFields(ImmutableOpenMap.<String, FieldMapper>of());\n+            return new MultiFields(Collections.emptyMap());\n         }\n \n         public static class Builder {\n \n-            private final ImmutableOpenMap.Builder<String, Mapper.Builder> mapperBuilders = ImmutableOpenMap.builder();\n+            private final Map<String, Function<BuilderContext, FieldMapper>> mapperBuilders = new HashMap<>();\n \n-            public Builder add(Mapper.Builder builder) {\n-                mapperBuilders.put(builder.name(), builder);\n+            public Builder add(FieldMapper.Builder builder) {\n+                mapperBuilders.put(builder.name(), builder::build);\n                 return this;\n             }\n \n-            public Builder add(Mapper mapper) {\n-                mapperBuilders.put(mapper.simpleName(), new Mapper.Builder(mapper.simpleName()) {\n-                    @Override\n-                    public Mapper build(BuilderContext context) {\n-                        return mapper;\n-                    }\n-                });\n+            public Builder add(FieldMapper mapper) {\n+                mapperBuilders.put(mapper.simpleName(), context -> mapper);\n                 return this;\n             }\n \n-            public Builder update(Mapper toMerge, ContentPath contentPath) {\n+            public Builder update(FieldMapper toMerge, ContentPath contentPath) {\n                 if (mapperBuilders.containsKey(toMerge.simpleName()) == false) {\n                     add(toMerge);\n                 } else {\n-                    Mapper.Builder builder = mapperBuilders.get(toMerge.simpleName());\n-                    Mapper existing = builder.build(new BuilderContext(Settings.EMPTY, contentPath));\n+                    FieldMapper existing\n+                        = mapperBuilders.get(toMerge.simpleName()).apply(new BuilderContext(Settings.EMPTY, contentPath));\n                     add(existing.merge(toMerge));\n                 }\n                 return this;\n             }\n \n-            @SuppressWarnings(\"unchecked\")\n             public MultiFields build(Mapper.Builder mainFieldBuilder, BuilderContext context) {\n                 if (mapperBuilders.isEmpty()) {\n                     return empty();\n                 } else {\n+                    Map<String, FieldMapper> mappers = new HashMap<>();\n                     context.path().add(mainFieldBuilder.name());\n-                    ImmutableOpenMap.Builder mapperBuilders = this.mapperBuilders;\n-                    for (ObjectObjectCursor<String, Mapper.Builder> cursor : this.mapperBuilders) {\n-                        String key = cursor.key;\n-                        Mapper.Builder value = cursor.value;\n-                        Mapper mapper = value.build(context);\n-                        assert mapper instanceof FieldMapper;\n-                        mapperBuilders.put(key, mapper);\n+                    for (Map.Entry<String, Function<BuilderContext, FieldMapper>> entry : this.mapperBuilders.entrySet()) {\n+                        String key = entry.getKey();\n+                        FieldMapper mapper = entry.getValue().apply(context);\n+                        mappers.put(key, mapper);\n                     }\n                     context.path().remove();\n-                    ImmutableOpenMap.Builder<String, FieldMapper> mappers = mapperBuilders.cast();\n-                    return new MultiFields(mappers.build());\n+                    return new MultiFields(mappers);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55599e3d038e3387c60db106cd2b9f54328e8418"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI5OTgyOA==", "bodyText": "Weird. That, like, doesn't do anything, right?", "url": "https://github.com/elastic/elasticsearch/pull/64500#discussion_r516299828", "createdAt": "2020-11-02T22:40:38Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java", "diffHunk": "@@ -284,72 +292,58 @@ protected void doXContentBody(XContentBuilder builder, boolean includeDefaults,\n \n     protected abstract String contentType();\n \n-    public static class MultiFields implements Iterable<Mapper> {\n+    public static class MultiFields implements Iterable<FieldMapper> {\n \n         public static MultiFields empty() {\n-            return new MultiFields(ImmutableOpenMap.<String, FieldMapper>of());\n+            return new MultiFields(Collections.emptyMap());\n         }\n \n         public static class Builder {\n \n-            private final ImmutableOpenMap.Builder<String, Mapper.Builder> mapperBuilders = ImmutableOpenMap.builder();\n+            private final Map<String, Function<BuilderContext, FieldMapper>> mapperBuilders = new HashMap<>();\n \n-            public Builder add(Mapper.Builder builder) {\n-                mapperBuilders.put(builder.name(), builder);\n+            public Builder add(FieldMapper.Builder builder) {\n+                mapperBuilders.put(builder.name(), builder::build);\n                 return this;\n             }\n \n-            public Builder add(Mapper mapper) {\n-                mapperBuilders.put(mapper.simpleName(), new Mapper.Builder(mapper.simpleName()) {\n-                    @Override\n-                    public Mapper build(BuilderContext context) {\n-                        return mapper;\n-                    }\n-                });\n+            public Builder add(FieldMapper mapper) {\n+                mapperBuilders.put(mapper.simpleName(), context -> mapper);\n                 return this;\n             }\n \n-            public Builder update(Mapper toMerge, ContentPath contentPath) {\n+            public Builder update(FieldMapper toMerge, ContentPath contentPath) {\n                 if (mapperBuilders.containsKey(toMerge.simpleName()) == false) {\n                     add(toMerge);\n                 } else {\n-                    Mapper.Builder builder = mapperBuilders.get(toMerge.simpleName());\n-                    Mapper existing = builder.build(new BuilderContext(Settings.EMPTY, contentPath));\n+                    FieldMapper existing\n+                        = mapperBuilders.get(toMerge.simpleName()).apply(new BuilderContext(Settings.EMPTY, contentPath));\n                     add(existing.merge(toMerge));\n                 }\n                 return this;\n             }\n \n-            @SuppressWarnings(\"unchecked\")\n             public MultiFields build(Mapper.Builder mainFieldBuilder, BuilderContext context) {\n                 if (mapperBuilders.isEmpty()) {\n                     return empty();\n                 } else {\n+                    Map<String, FieldMapper> mappers = new HashMap<>();\n                     context.path().add(mainFieldBuilder.name());\n-                    ImmutableOpenMap.Builder mapperBuilders = this.mapperBuilders;\n-                    for (ObjectObjectCursor<String, Mapper.Builder> cursor : this.mapperBuilders) {\n-                        String key = cursor.key;\n-                        Mapper.Builder value = cursor.value;\n-                        Mapper mapper = value.build(context);\n-                        assert mapper instanceof FieldMapper;\n-                        mapperBuilders.put(key, mapper);\n+                    for (Map.Entry<String, Function<BuilderContext, FieldMapper>> entry : this.mapperBuilders.entrySet()) {\n+                        String key = entry.getKey();\n+                        FieldMapper mapper = entry.getValue().apply(context);\n+                        mappers.put(key, mapper);\n                     }\n                     context.path().remove();\n-                    ImmutableOpenMap.Builder<String, FieldMapper> mappers = mapperBuilders.cast();\n-                    return new MultiFields(mappers.build());\n+                    return new MultiFields(mappers);\n                 }\n             }\n         }\n \n-        private final ImmutableOpenMap<String, FieldMapper> mappers;\n+        private final Map<String, FieldMapper> mappers;\n \n-        private MultiFields(ImmutableOpenMap<String, FieldMapper> mappers) {\n-            ImmutableOpenMap.Builder<String, FieldMapper> builder = new ImmutableOpenMap.Builder<>();\n-            // we disable the all in multi-field mappers\n-            for (ObjectObjectCursor<String, FieldMapper> cursor : mappers) {\n-                builder.put(cursor.key, cursor.value);\n-            }\n-            this.mappers = builder.build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55599e3d038e3387c60db106cd2b9f54328e8418"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMwMTEzOQ==", "bodyText": "Same comment about double super paranoid immutability.", "url": "https://github.com/elastic/elasticsearch/pull/64500#discussion_r516301139", "createdAt": "2020-11-02T22:42:12Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java", "diffHunk": "@@ -362,45 +356,37 @@ public void parse(FieldMapper mainField, ParseContext context) throws IOExceptio\n             context = context.createMultiFieldContext();\n \n             context.path().add(mainField.simpleName());\n-            for (ObjectCursor<FieldMapper> cursor : mappers.values()) {\n-                cursor.value.parse(context);\n+            for (FieldMapper mapper : mappers.values()) {\n+                mapper.parse(context);\n             }\n             context.path().remove();\n         }\n \n         public MultiFields merge(MultiFields mergeWith) {\n-            ImmutableOpenMap.Builder<String, FieldMapper> newMappersBuilder = ImmutableOpenMap.builder(mappers);\n-\n-            for (ObjectCursor<FieldMapper> cursor : mergeWith.mappers.values()) {\n-                FieldMapper mergeWithMapper = cursor.value;\n-                FieldMapper mergeIntoMapper = mappers.get(mergeWithMapper.simpleName());\n+            Map<String, FieldMapper> newMappers = new HashMap<>();\n+            for (FieldMapper mapper : mergeWith.mappers.values()) {\n+                FieldMapper mergeIntoMapper = mappers.get(mapper.simpleName());\n                 if (mergeIntoMapper == null) {\n-                    newMappersBuilder.put(mergeWithMapper.simpleName(), mergeWithMapper);\n+                    newMappers.put(mapper.simpleName(), mapper);\n                 } else {\n-                    FieldMapper merged = mergeIntoMapper.merge(mergeWithMapper);\n-                    newMappersBuilder.put(merged.simpleName(), merged); // override previous definition\n+                    FieldMapper merged = mergeIntoMapper.merge(mapper);\n+                    newMappers.put(merged.simpleName(), merged); // override previous definition\n                 }\n             }\n-\n-            ImmutableOpenMap<String, FieldMapper> mappers = newMappersBuilder.build();\n-            return new MultiFields(mappers);\n+            return new MultiFields(newMappers);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55599e3d038e3387c60db106cd2b9f54328e8418"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMwMTY1Nw==", "bodyText": "I'm so happy we sorted this. I know we did it for an odd reason around loops in mapping updates, but it just makes the output nicer to read.", "url": "https://github.com/elastic/elasticsearch/pull/64500#discussion_r516301657", "createdAt": "2020-11-02T22:42:50Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java", "diffHunk": "@@ -362,45 +356,37 @@ public void parse(FieldMapper mainField, ParseContext context) throws IOExceptio\n             context = context.createMultiFieldContext();\n \n             context.path().add(mainField.simpleName());\n-            for (ObjectCursor<FieldMapper> cursor : mappers.values()) {\n-                cursor.value.parse(context);\n+            for (FieldMapper mapper : mappers.values()) {\n+                mapper.parse(context);\n             }\n             context.path().remove();\n         }\n \n         public MultiFields merge(MultiFields mergeWith) {\n-            ImmutableOpenMap.Builder<String, FieldMapper> newMappersBuilder = ImmutableOpenMap.builder(mappers);\n-\n-            for (ObjectCursor<FieldMapper> cursor : mergeWith.mappers.values()) {\n-                FieldMapper mergeWithMapper = cursor.value;\n-                FieldMapper mergeIntoMapper = mappers.get(mergeWithMapper.simpleName());\n+            Map<String, FieldMapper> newMappers = new HashMap<>();\n+            for (FieldMapper mapper : mergeWith.mappers.values()) {\n+                FieldMapper mergeIntoMapper = mappers.get(mapper.simpleName());\n                 if (mergeIntoMapper == null) {\n-                    newMappersBuilder.put(mergeWithMapper.simpleName(), mergeWithMapper);\n+                    newMappers.put(mapper.simpleName(), mapper);\n                 } else {\n-                    FieldMapper merged = mergeIntoMapper.merge(mergeWithMapper);\n-                    newMappersBuilder.put(merged.simpleName(), merged); // override previous definition\n+                    FieldMapper merged = mergeIntoMapper.merge(mapper);\n+                    newMappers.put(merged.simpleName(), merged); // override previous definition\n                 }\n             }\n-\n-            ImmutableOpenMap<String, FieldMapper> mappers = newMappersBuilder.build();\n-            return new MultiFields(mappers);\n+            return new MultiFields(newMappers);\n         }\n \n         @Override\n-        public Iterator<Mapper> iterator() {\n-            return StreamSupport.stream(mappers.values().spliterator(), false).map((p) -> (Mapper)p.value).iterator();\n+        public Iterator<FieldMapper> iterator() {\n+            return mappers.values().iterator();\n         }\n \n         public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n             if (!mappers.isEmpty()) {\n                 // sort the mappers so we get consistent serialization format\n-                Mapper[] sortedMappers = mappers.values().toArray(Mapper.class);\n-                Arrays.sort(sortedMappers, new Comparator<Mapper>() {\n-                    @Override\n-                    public int compare(Mapper o1, Mapper o2) {\n-                        return o1.name().compareTo(o2.name());\n-                    }\n-                });\n+                List<Mapper> sortedMappers = mappers.values().stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55599e3d038e3387c60db106cd2b9f54328e8418"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMwMzQxNQ==", "bodyText": "I wonder, not that it matters, but, is it faster to do list = new List(mappers.values()); Collections.sort(list);. Sorting a stream feels funny to me because it is a forwards only data structure and feels like it'll amount to just sorting anyway. Whatever. It super doesn't matter.", "url": "https://github.com/elastic/elasticsearch/pull/64500#discussion_r516303415", "createdAt": "2020-11-02T22:45:38Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java", "diffHunk": "@@ -362,45 +356,37 @@ public void parse(FieldMapper mainField, ParseContext context) throws IOExceptio\n             context = context.createMultiFieldContext();\n \n             context.path().add(mainField.simpleName());\n-            for (ObjectCursor<FieldMapper> cursor : mappers.values()) {\n-                cursor.value.parse(context);\n+            for (FieldMapper mapper : mappers.values()) {\n+                mapper.parse(context);\n             }\n             context.path().remove();\n         }\n \n         public MultiFields merge(MultiFields mergeWith) {\n-            ImmutableOpenMap.Builder<String, FieldMapper> newMappersBuilder = ImmutableOpenMap.builder(mappers);\n-\n-            for (ObjectCursor<FieldMapper> cursor : mergeWith.mappers.values()) {\n-                FieldMapper mergeWithMapper = cursor.value;\n-                FieldMapper mergeIntoMapper = mappers.get(mergeWithMapper.simpleName());\n+            Map<String, FieldMapper> newMappers = new HashMap<>();\n+            for (FieldMapper mapper : mergeWith.mappers.values()) {\n+                FieldMapper mergeIntoMapper = mappers.get(mapper.simpleName());\n                 if (mergeIntoMapper == null) {\n-                    newMappersBuilder.put(mergeWithMapper.simpleName(), mergeWithMapper);\n+                    newMappers.put(mapper.simpleName(), mapper);\n                 } else {\n-                    FieldMapper merged = mergeIntoMapper.merge(mergeWithMapper);\n-                    newMappersBuilder.put(merged.simpleName(), merged); // override previous definition\n+                    FieldMapper merged = mergeIntoMapper.merge(mapper);\n+                    newMappers.put(merged.simpleName(), merged); // override previous definition\n                 }\n             }\n-\n-            ImmutableOpenMap<String, FieldMapper> mappers = newMappersBuilder.build();\n-            return new MultiFields(mappers);\n+            return new MultiFields(newMappers);\n         }\n \n         @Override\n-        public Iterator<Mapper> iterator() {\n-            return StreamSupport.stream(mappers.values().spliterator(), false).map((p) -> (Mapper)p.value).iterator();\n+        public Iterator<FieldMapper> iterator() {\n+            return mappers.values().iterator();\n         }\n \n         public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n             if (!mappers.isEmpty()) {\n                 // sort the mappers so we get consistent serialization format\n-                Mapper[] sortedMappers = mappers.values().toArray(Mapper.class);\n-                Arrays.sort(sortedMappers, new Comparator<Mapper>() {\n-                    @Override\n-                    public int compare(Mapper o1, Mapper o2) {\n-                        return o1.name().compareTo(o2.name());\n-                    }\n-                });\n+                List<Mapper> sortedMappers = mappers.values().stream()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMwMTY1Nw=="}, "originalCommit": {"oid": "55599e3d038e3387c60db106cd2b9f54328e8418"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMwNDEwMA==", "bodyText": "Oh! It's worth triple checking that this doesn't change the order from before. It sure looks the same to me but please make sure we have a test. We need the same order as before or things can get \"fun\" in a mixed version cluster.", "url": "https://github.com/elastic/elasticsearch/pull/64500#discussion_r516304100", "createdAt": "2020-11-02T22:46:46Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java", "diffHunk": "@@ -362,45 +356,37 @@ public void parse(FieldMapper mainField, ParseContext context) throws IOExceptio\n             context = context.createMultiFieldContext();\n \n             context.path().add(mainField.simpleName());\n-            for (ObjectCursor<FieldMapper> cursor : mappers.values()) {\n-                cursor.value.parse(context);\n+            for (FieldMapper mapper : mappers.values()) {\n+                mapper.parse(context);\n             }\n             context.path().remove();\n         }\n \n         public MultiFields merge(MultiFields mergeWith) {\n-            ImmutableOpenMap.Builder<String, FieldMapper> newMappersBuilder = ImmutableOpenMap.builder(mappers);\n-\n-            for (ObjectCursor<FieldMapper> cursor : mergeWith.mappers.values()) {\n-                FieldMapper mergeWithMapper = cursor.value;\n-                FieldMapper mergeIntoMapper = mappers.get(mergeWithMapper.simpleName());\n+            Map<String, FieldMapper> newMappers = new HashMap<>();\n+            for (FieldMapper mapper : mergeWith.mappers.values()) {\n+                FieldMapper mergeIntoMapper = mappers.get(mapper.simpleName());\n                 if (mergeIntoMapper == null) {\n-                    newMappersBuilder.put(mergeWithMapper.simpleName(), mergeWithMapper);\n+                    newMappers.put(mapper.simpleName(), mapper);\n                 } else {\n-                    FieldMapper merged = mergeIntoMapper.merge(mergeWithMapper);\n-                    newMappersBuilder.put(merged.simpleName(), merged); // override previous definition\n+                    FieldMapper merged = mergeIntoMapper.merge(mapper);\n+                    newMappers.put(merged.simpleName(), merged); // override previous definition\n                 }\n             }\n-\n-            ImmutableOpenMap<String, FieldMapper> mappers = newMappersBuilder.build();\n-            return new MultiFields(mappers);\n+            return new MultiFields(newMappers);\n         }\n \n         @Override\n-        public Iterator<Mapper> iterator() {\n-            return StreamSupport.stream(mappers.values().spliterator(), false).map((p) -> (Mapper)p.value).iterator();\n+        public Iterator<FieldMapper> iterator() {\n+            return mappers.values().iterator();\n         }\n \n         public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n             if (!mappers.isEmpty()) {\n                 // sort the mappers so we get consistent serialization format\n-                Mapper[] sortedMappers = mappers.values().toArray(Mapper.class);\n-                Arrays.sort(sortedMappers, new Comparator<Mapper>() {\n-                    @Override\n-                    public int compare(Mapper o1, Mapper o2) {\n-                        return o1.name().compareTo(o2.name());\n-                    }\n-                });\n+                List<Mapper> sortedMappers = mappers.values().stream()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMwMTY1Nw=="}, "originalCommit": {"oid": "55599e3d038e3387c60db106cd2b9f54328e8418"}, "originalPosition": 189}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ffdff2a81fa62ea3ac1ca34474cf1a1ef29c6462", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/elastic/elasticsearch/commit/ffdff2a81fa62ea3ac1ca34474cf1a1ef29c6462", "committedDate": "2020-11-03T10:08:57Z", "message": "Immutability; add tests for sort order"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzkzNjMw", "url": "https://github.com/elastic/elasticsearch/pull/64500#pullrequestreview-523393630", "createdAt": "2020-11-04T14:08:47Z", "commit": {"oid": "ffdff2a81fa62ea3ac1ca34474cf1a1ef29c6462"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNDowODo0N1rOHtZrEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNDowODo0N1rOHtZrEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2ODU5NA==", "bodyText": "I'd make this a Set because weird things will happen if there are dupes, I think.", "url": "https://github.com/elastic/elasticsearch/pull/64500#discussion_r517368594", "createdAt": "2020-11-04T14:08:47Z", "author": {"login": "nik9000"}, "path": "server/src/test/java/org/elasticsearch/index/mapper/MultiFieldsSerializationTests.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.test.ESTestCase;\n+\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.List;\n+\n+import static org.hamcrest.Matchers.greaterThan;\n+\n+public class MultiFieldsSerializationTests extends ESTestCase {\n+\n+    public void testSorting() {\n+\n+        FieldMapper.MultiFields.Builder builder = new FieldMapper.MultiFields.Builder();\n+\n+        List<String> names = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ffdff2a81fa62ea3ac1ca34474cf1a1ef29c6462"}, "originalPosition": 38}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b9a4509c1e581268eefc02c5e4d7f627321ed0d0", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/elastic/elasticsearch/commit/b9a4509c1e581268eefc02c5e4d7f627321ed0d0", "committedDate": "2020-11-04T16:14:44Z", "message": "Merge remote-tracking branch 'origin/master' into mapper/multifields-builder"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "45f037205ece7650bb1de864438ca9dc309ed438", "author": {"user": {"login": "romseygeek", "name": "Alan Woodward"}}, "url": "https://github.com/elastic/elasticsearch/commit/45f037205ece7650bb1de864438ca9dc309ed438", "committedDate": "2020-11-04T16:15:53Z", "message": "Harden test against random shenanigans"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 746, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}