{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk3MjE5MjE5", "number": 54610, "title": "Implement transport circuit breaking in aggregator", "bodyText": "This commit moves the action name validation and circuit breaking into\nthe InboundAggregator. This work is valuable because it lays the\ngroundwork for incrementally circuit breaking as data is received.\nThis PR includes the follow behavioral change:\nHandshakes contribute to circuit breaking, but cannot be broken. They\ncurrently do not contribute nor are they broken.", "createdAt": "2020-04-01T20:35:46Z", "url": "https://github.com/elastic/elasticsearch/pull/54610", "merged": true, "mergeCommit": {"oid": "4f0ccd3c254fe58a32fbaa88aee8cf5246df397a"}, "closed": true, "closedAt": "2020-04-07T15:51:31Z", "author": {"login": "tbrooks8"}, "timelineItems": {"totalCount": 28, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcTH88qgH2gAyMzk3MjE5MjE5Ojc0OWM5NTdlODRjOGRlZWIxOWRhODhhODdmOTcxODg1MjFlNmZiNzc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcVNVnWAFqTM4ODgxODExMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "749c957e84c8deeb19da88a87f97188521e6fb77", "author": {"user": {"login": "tbrooks8", "name": "Tim Brooks"}}, "url": "https://github.com/elastic/elasticsearch/commit/749c957e84c8deeb19da88a87f97188521e6fb77", "committedDate": "2020-03-31T19:06:33Z", "message": "Chnages"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1de985cde68028801235010a705805b586e2a79b", "author": {"user": {"login": "tbrooks8", "name": "Tim Brooks"}}, "url": "https://github.com/elastic/elasticsearch/commit/1de985cde68028801235010a705805b586e2a79b", "committedDate": "2020-03-31T22:55:31Z", "message": "WIP"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "03cd11835bdb2ea33a3a9c96cf97f9594a93e334", "author": {"user": {"login": "tbrooks8", "name": "Tim Brooks"}}, "url": "https://github.com/elastic/elasticsearch/commit/03cd11835bdb2ea33a3a9c96cf97f9594a93e334", "committedDate": "2020-04-01T02:54:12Z", "message": "WIP"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e2d10b9927c6c2d0930dd322d5789e9039c00b5d", "author": {"user": {"login": "tbrooks8", "name": "Tim Brooks"}}, "url": "https://github.com/elastic/elasticsearch/commit/e2d10b9927c6c2d0930dd322d5789e9039c00b5d", "committedDate": "2020-04-01T15:51:31Z", "message": "WIP"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "555d5a8eb0e25e059a8a60d50f6760dd4e502c45", "author": {"user": {"login": "tbrooks8", "name": "Tim Brooks"}}, "url": "https://github.com/elastic/elasticsearch/commit/555d5a8eb0e25e059a8a60d50f6760dd4e502c45", "committedDate": "2020-04-01T18:46:39Z", "message": "Chnages"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7dcc09c21908ab2d099e1cb6b9ea2cf04827740e", "author": {"user": {"login": "tbrooks8", "name": "Tim Brooks"}}, "url": "https://github.com/elastic/elasticsearch/commit/7dcc09c21908ab2d099e1cb6b9ea2cf04827740e", "committedDate": "2020-04-01T20:31:28Z", "message": "Changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e94d17af5be0a4a0b516a2382eaf834361bc6a65", "author": {"user": {"login": "tbrooks8", "name": "Tim Brooks"}}, "url": "https://github.com/elastic/elasticsearch/commit/e94d17af5be0a4a0b516a2382eaf834361bc6a65", "committedDate": "2020-04-01T22:13:58Z", "message": "Fix issue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fcd0ce7897e01c316e1f980c3c0a830eb832e7de", "author": {"user": {"login": "tbrooks8", "name": "Tim Brooks"}}, "url": "https://github.com/elastic/elasticsearch/commit/fcd0ce7897e01c316e1f980c3c0a830eb832e7de", "committedDate": "2020-04-01T23:30:07Z", "message": "Fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "10c44a4f8e044aaae5683b3f62368f58da7dcb28", "author": {"user": {"login": "tbrooks8", "name": "Tim Brooks"}}, "url": "https://github.com/elastic/elasticsearch/commit/10c44a4f8e044aaae5683b3f62368f58da7dcb28", "committedDate": "2020-04-01T23:30:34Z", "message": "Merge remote-tracking branch 'upstream/master' into circuit_breaking_inside_pipeline"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fe39a308f7163e2d4af96602ad4af3be4742c0e9", "author": {"user": {"login": "tbrooks8", "name": "Tim Brooks"}}, "url": "https://github.com/elastic/elasticsearch/commit/fe39a308f7163e2d4af96602ad4af3be4742c0e9", "committedDate": "2020-04-02T19:09:36Z", "message": "Merge remote-tracking branch 'upstream/master' into circuit_breaking_inside_pipeline"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "901d63ed7dcf7b98bad8328b4102305831a4a149", "author": {"user": {"login": "tbrooks8", "name": "Tim Brooks"}}, "url": "https://github.com/elastic/elasticsearch/commit/901d63ed7dcf7b98bad8328b4102305831a4a149", "committedDate": "2020-04-02T22:19:32Z", "message": "Merge remote-tracking branch 'upstream/master' into circuit_breaking_inside_pipeline"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3MDM5MjU2", "url": "https://github.com/elastic/elasticsearch/pull/54610#pullrequestreview-387039256", "createdAt": "2020-04-03T08:02:50Z", "commit": {"oid": "901d63ed7dcf7b98bad8328b4102305831a4a149"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwODowMjo1MFrOGAJdFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxMzoxMToyNVrOGAUzHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgwODA4Nw==", "bodyText": "make this package-visible and add comment that this is only to be used for tests?", "url": "https://github.com/elastic/elasticsearch/pull/54610#discussion_r402808087", "createdAt": "2020-04-03T08:02:50Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/transport/InboundAggregator.java", "diffHunk": "@@ -27,44 +29,68 @@\n \n import java.io.IOException;\n import java.util.ArrayList;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n \n public class InboundAggregator implements Releasable {\n \n+    private final Supplier<CircuitBreaker> circuitBreaker;\n+    private final Predicate<String> requestCanTripBreaker;\n+\n     private ReleasableBytesReference firstContent;\n     private ArrayList<ReleasableBytesReference> contentAggregation;\n     private Header currentHeader;\n+    private Exception aggregationException;\n+    private boolean canTripBreaker = true;\n     private boolean isClosed = false;\n \n+    public InboundAggregator(Supplier<CircuitBreaker> circuitBreaker,\n+                             Function<String, RequestHandlerRegistry<TransportRequest>> registryFunction) {\n+        this(circuitBreaker, (Predicate<String>) actionName -> {\n+            final RequestHandlerRegistry<TransportRequest> reg = registryFunction.apply(actionName);\n+            if (reg == null) {\n+                throw new ActionNotFoundTransportException(actionName);\n+            } else {\n+                return reg.canTripCircuitBreaker();\n+            }\n+        });\n+\n+    }\n+\n+    public InboundAggregator(Supplier<CircuitBreaker> circuitBreaker, Predicate<String> requestCanTripBreaker) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "901d63ed7dcf7b98bad8328b4102305831a4a149"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgxMTMzOQ==", "bodyText": "can we add assert firstContent != null before this line?", "url": "https://github.com/elastic/elasticsearch/pull/54610#discussion_r402811339", "createdAt": "2020-04-03T08:06:37Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/transport/InboundAggregator.java", "diffHunk": "@@ -27,44 +29,68 @@\n \n import java.io.IOException;\n import java.util.ArrayList;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n \n public class InboundAggregator implements Releasable {\n \n+    private final Supplier<CircuitBreaker> circuitBreaker;\n+    private final Predicate<String> requestCanTripBreaker;\n+\n     private ReleasableBytesReference firstContent;\n     private ArrayList<ReleasableBytesReference> contentAggregation;\n     private Header currentHeader;\n+    private Exception aggregationException;\n+    private boolean canTripBreaker = true;\n     private boolean isClosed = false;\n \n+    public InboundAggregator(Supplier<CircuitBreaker> circuitBreaker,\n+                             Function<String, RequestHandlerRegistry<TransportRequest>> registryFunction) {\n+        this(circuitBreaker, (Predicate<String>) actionName -> {\n+            final RequestHandlerRegistry<TransportRequest> reg = registryFunction.apply(actionName);\n+            if (reg == null) {\n+                throw new ActionNotFoundTransportException(actionName);\n+            } else {\n+                return reg.canTripCircuitBreaker();\n+            }\n+        });\n+\n+    }\n+\n+    public InboundAggregator(Supplier<CircuitBreaker> circuitBreaker, Predicate<String> requestCanTripBreaker) {\n+        this.circuitBreaker = circuitBreaker;\n+        this.requestCanTripBreaker = requestCanTripBreaker;\n+    }\n+\n     public void headerReceived(Header header) {\n         ensureOpen();\n         assert isAggregating() == false;\n         assert firstContent == null && contentAggregation == null;\n         currentHeader = header;\n+        if (currentHeader.isRequest() && currentHeader.needsToReadVariableHeader() == false) {\n+            initializeRequestState();\n+        }\n     }\n \n     public void aggregate(ReleasableBytesReference content) {\n         ensureOpen();\n         assert isAggregating();\n-        if (isFirstContent()) {\n-            firstContent = content.retain();\n-        } else {\n-            if (contentAggregation == null) {\n-                contentAggregation = new ArrayList<>(4);\n-                contentAggregation.add(firstContent);\n-                firstContent = null;\n+        if (isShortCircuited() == false) {\n+            if (isFirstContent()) {\n+                firstContent = content.retain();\n+            } else {\n+                if (contentAggregation == null) {\n+                    contentAggregation = new ArrayList<>(4);\n+                    contentAggregation.add(firstContent);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "901d63ed7dcf7b98bad8328b4102305831a4a149"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgxNjU2MA==", "bodyText": "I wonder if we should assert that this method is not called anymore after close has been called", "url": "https://github.com/elastic/elasticsearch/pull/54610#discussion_r402816560", "createdAt": "2020-04-03T08:12:29Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/transport/InboundAggregator.java", "diffHunk": "@@ -108,23 +156,84 @@ public void close() {\n     }\n \n     private void closeCurrentAggregation() {\n+        releaseContent();\n+        resetCurrentAggregation();\n+    }\n+\n+    private void releaseContent() {\n         if (contentAggregation == null) {\n             Releasables.close(firstContent);\n         } else {\n             Releasables.close(contentAggregation);\n         }\n-        resetCurrentAggregation();\n     }\n \n     private void resetCurrentAggregation() {\n         firstContent = null;\n         contentAggregation = null;\n         currentHeader = null;\n+        aggregationException = null;\n+        canTripBreaker = true;\n     }\n \n     private void ensureOpen() {\n         if (isClosed) {\n             throw new IllegalStateException(\"Aggregator is already closed\");\n         }\n     }\n+\n+    private void initializeRequestState() {\n+        assert currentHeader.needsToReadVariableHeader() == false;\n+        assert currentHeader.isRequest();\n+        if (currentHeader.isHandshake()) {\n+            canTripBreaker = false;\n+            return;\n+        }\n+\n+        final String actionName = currentHeader.getActionName();\n+        try {\n+            canTripBreaker = requestCanTripBreaker.test(actionName);\n+        } catch (ActionNotFoundTransportException e) {\n+            shortCircuit(new ActionNotFoundTransportException(actionName));\n+        }\n+    }\n+\n+    private void checkBreaker(final Header header, final int contentLength, final BreakerControl breakerControl) {\n+        if (header.isRequest() == false) {\n+            return;\n+        }\n+        assert header.needsToReadVariableHeader() == false;\n+\n+        if (canTripBreaker) {\n+            try {\n+                circuitBreaker.get().addEstimateBytesAndMaybeBreak(contentLength, \"<transport_request>\");\n+                breakerControl.incrementReservedBytes(contentLength);\n+            } catch (CircuitBreakingException e) {\n+                shortCircuit(e);\n+            }\n+        } else {\n+            circuitBreaker.get().addWithoutBreaking(contentLength);\n+            breakerControl.incrementReservedBytes(contentLength);\n+        }\n+    }\n+\n+    private static class BreakerControl implements Releasable {\n+\n+        private final Supplier<CircuitBreaker> circuitBreaker;\n+        private final AtomicInteger bytesToRelease = new AtomicInteger(0);\n+\n+        private BreakerControl(Supplier<CircuitBreaker> circuitBreaker) {\n+            this.circuitBreaker = circuitBreaker;\n+        }\n+\n+        private void incrementReservedBytes(int delta) {\n+            bytesToRelease.getAndAdd(delta);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "901d63ed7dcf7b98bad8328b4102305831a4a149"}, "originalPosition": 220}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgyMTc4OQ==", "bodyText": "i would love it if we could add more information here than just <transport_request>. We potentially have action name and more available here", "url": "https://github.com/elastic/elasticsearch/pull/54610#discussion_r402821789", "createdAt": "2020-04-03T08:18:37Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/transport/InboundAggregator.java", "diffHunk": "@@ -108,23 +156,84 @@ public void close() {\n     }\n \n     private void closeCurrentAggregation() {\n+        releaseContent();\n+        resetCurrentAggregation();\n+    }\n+\n+    private void releaseContent() {\n         if (contentAggregation == null) {\n             Releasables.close(firstContent);\n         } else {\n             Releasables.close(contentAggregation);\n         }\n-        resetCurrentAggregation();\n     }\n \n     private void resetCurrentAggregation() {\n         firstContent = null;\n         contentAggregation = null;\n         currentHeader = null;\n+        aggregationException = null;\n+        canTripBreaker = true;\n     }\n \n     private void ensureOpen() {\n         if (isClosed) {\n             throw new IllegalStateException(\"Aggregator is already closed\");\n         }\n     }\n+\n+    private void initializeRequestState() {\n+        assert currentHeader.needsToReadVariableHeader() == false;\n+        assert currentHeader.isRequest();\n+        if (currentHeader.isHandshake()) {\n+            canTripBreaker = false;\n+            return;\n+        }\n+\n+        final String actionName = currentHeader.getActionName();\n+        try {\n+            canTripBreaker = requestCanTripBreaker.test(actionName);\n+        } catch (ActionNotFoundTransportException e) {\n+            shortCircuit(new ActionNotFoundTransportException(actionName));\n+        }\n+    }\n+\n+    private void checkBreaker(final Header header, final int contentLength, final BreakerControl breakerControl) {\n+        if (header.isRequest() == false) {\n+            return;\n+        }\n+        assert header.needsToReadVariableHeader() == false;\n+\n+        if (canTripBreaker) {\n+            try {\n+                circuitBreaker.get().addEstimateBytesAndMaybeBreak(contentLength, \"<transport_request>\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "901d63ed7dcf7b98bad8328b4102305831a4a149"}, "originalPosition": 199}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjk3MjcwNg==", "bodyText": "Also, we should assert right now that this method is only called once.", "url": "https://github.com/elastic/elasticsearch/pull/54610#discussion_r402972706", "createdAt": "2020-04-03T12:34:31Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/transport/InboundAggregator.java", "diffHunk": "@@ -108,23 +156,84 @@ public void close() {\n     }\n \n     private void closeCurrentAggregation() {\n+        releaseContent();\n+        resetCurrentAggregation();\n+    }\n+\n+    private void releaseContent() {\n         if (contentAggregation == null) {\n             Releasables.close(firstContent);\n         } else {\n             Releasables.close(contentAggregation);\n         }\n-        resetCurrentAggregation();\n     }\n \n     private void resetCurrentAggregation() {\n         firstContent = null;\n         contentAggregation = null;\n         currentHeader = null;\n+        aggregationException = null;\n+        canTripBreaker = true;\n     }\n \n     private void ensureOpen() {\n         if (isClosed) {\n             throw new IllegalStateException(\"Aggregator is already closed\");\n         }\n     }\n+\n+    private void initializeRequestState() {\n+        assert currentHeader.needsToReadVariableHeader() == false;\n+        assert currentHeader.isRequest();\n+        if (currentHeader.isHandshake()) {\n+            canTripBreaker = false;\n+            return;\n+        }\n+\n+        final String actionName = currentHeader.getActionName();\n+        try {\n+            canTripBreaker = requestCanTripBreaker.test(actionName);\n+        } catch (ActionNotFoundTransportException e) {\n+            shortCircuit(new ActionNotFoundTransportException(actionName));\n+        }\n+    }\n+\n+    private void checkBreaker(final Header header, final int contentLength, final BreakerControl breakerControl) {\n+        if (header.isRequest() == false) {\n+            return;\n+        }\n+        assert header.needsToReadVariableHeader() == false;\n+\n+        if (canTripBreaker) {\n+            try {\n+                circuitBreaker.get().addEstimateBytesAndMaybeBreak(contentLength, \"<transport_request>\");\n+                breakerControl.incrementReservedBytes(contentLength);\n+            } catch (CircuitBreakingException e) {\n+                shortCircuit(e);\n+            }\n+        } else {\n+            circuitBreaker.get().addWithoutBreaking(contentLength);\n+            breakerControl.incrementReservedBytes(contentLength);\n+        }\n+    }\n+\n+    private static class BreakerControl implements Releasable {\n+\n+        private final Supplier<CircuitBreaker> circuitBreaker;\n+        private final AtomicInteger bytesToRelease = new AtomicInteger(0);\n+\n+        private BreakerControl(Supplier<CircuitBreaker> circuitBreaker) {\n+            this.circuitBreaker = circuitBreaker;\n+        }\n+\n+        private void incrementReservedBytes(int delta) {\n+            bytesToRelease.getAndAdd(delta);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgxNjU2MA=="}, "originalCommit": {"oid": "901d63ed7dcf7b98bad8328b4102305831a4a149"}, "originalPosition": 220}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjk4MzIzMg==", "bodyText": "why are you not storing the original exception here?", "url": "https://github.com/elastic/elasticsearch/pull/54610#discussion_r402983232", "createdAt": "2020-04-03T12:53:09Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/transport/InboundAggregator.java", "diffHunk": "@@ -108,23 +156,84 @@ public void close() {\n     }\n \n     private void closeCurrentAggregation() {\n+        releaseContent();\n+        resetCurrentAggregation();\n+    }\n+\n+    private void releaseContent() {\n         if (contentAggregation == null) {\n             Releasables.close(firstContent);\n         } else {\n             Releasables.close(contentAggregation);\n         }\n-        resetCurrentAggregation();\n     }\n \n     private void resetCurrentAggregation() {\n         firstContent = null;\n         contentAggregation = null;\n         currentHeader = null;\n+        aggregationException = null;\n+        canTripBreaker = true;\n     }\n \n     private void ensureOpen() {\n         if (isClosed) {\n             throw new IllegalStateException(\"Aggregator is already closed\");\n         }\n     }\n+\n+    private void initializeRequestState() {\n+        assert currentHeader.needsToReadVariableHeader() == false;\n+        assert currentHeader.isRequest();\n+        if (currentHeader.isHandshake()) {\n+            canTripBreaker = false;\n+            return;\n+        }\n+\n+        final String actionName = currentHeader.getActionName();\n+        try {\n+            canTripBreaker = requestCanTripBreaker.test(actionName);\n+        } catch (ActionNotFoundTransportException e) {\n+            shortCircuit(new ActionNotFoundTransportException(actionName));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "901d63ed7dcf7b98bad8328b4102305831a4a149"}, "originalPosition": 187}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjk4NjYwMQ==", "bodyText": "you've moved this out of the try block. Some implementations of this can throw an exception though. I think we need to handle those.", "url": "https://github.com/elastic/elasticsearch/pull/54610#discussion_r402986601", "createdAt": "2020-04-03T12:58:41Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/transport/InboundHandler.java", "diffHunk": "@@ -147,54 +144,59 @@ private void messageReceived(InboundMessage message, TcpChannel channel) throws\n         }\n     }\n \n-    private <T extends TransportRequest> void handleRequest(TcpChannel channel, Header header, StreamInput stream, int messageLengthBytes) {\n+    private <T extends TransportRequest> void handleRequest(TcpChannel channel, Header header, InboundMessage message) throws IOException {\n         final String action = header.getActionName();\n         final long requestId = header.getRequestId();\n         final Version version = header.getVersion();\n-        TransportChannel transportChannel = null;\n-        try {\n-            messageListener.onRequestReceived(requestId, action);\n-            if (header.isHandshake()) {\n-                handshaker.handleHandshake(version, channel, requestId, stream);\n-            } else {\n-                final RequestHandlerRegistry<T> reg = getRequestHandler(action);\n-                if (reg == null) {\n-                    throw new ActionNotFoundTransportException(action);\n-                }\n-                CircuitBreaker breaker = circuitBreakerService.getBreaker(CircuitBreaker.IN_FLIGHT_REQUESTS);\n-                if (reg.canTripCircuitBreaker()) {\n-                    breaker.addEstimateBytesAndMaybeBreak(messageLengthBytes, \"<transport_request>\");\n+        messageListener.onRequestReceived(requestId, action);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "901d63ed7dcf7b98bad8328b4102305831a4a149"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjk4NzgwMA==", "bodyText": "should we catch Exception here? We probably never want to bubble anything up here", "url": "https://github.com/elastic/elasticsearch/pull/54610#discussion_r402987800", "createdAt": "2020-04-03T13:00:46Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/transport/InboundHandler.java", "diffHunk": "@@ -147,54 +144,59 @@ private void messageReceived(InboundMessage message, TcpChannel channel) throws\n         }\n     }\n \n-    private <T extends TransportRequest> void handleRequest(TcpChannel channel, Header header, StreamInput stream, int messageLengthBytes) {\n+    private <T extends TransportRequest> void handleRequest(TcpChannel channel, Header header, InboundMessage message) throws IOException {\n         final String action = header.getActionName();\n         final long requestId = header.getRequestId();\n         final Version version = header.getVersion();\n-        TransportChannel transportChannel = null;\n-        try {\n-            messageListener.onRequestReceived(requestId, action);\n-            if (header.isHandshake()) {\n-                handshaker.handleHandshake(version, channel, requestId, stream);\n-            } else {\n-                final RequestHandlerRegistry<T> reg = getRequestHandler(action);\n-                if (reg == null) {\n-                    throw new ActionNotFoundTransportException(action);\n-                }\n-                CircuitBreaker breaker = circuitBreakerService.getBreaker(CircuitBreaker.IN_FLIGHT_REQUESTS);\n-                if (reg.canTripCircuitBreaker()) {\n-                    breaker.addEstimateBytesAndMaybeBreak(messageLengthBytes, \"<transport_request>\");\n+        messageListener.onRequestReceived(requestId, action);\n+        if (message.isShortCircuit()) {\n+            final TransportChannel transportChannel = new TcpTransportChannel(outboundHandler, channel, action, requestId, version,\n+                header.isCompressed(), message.takeBreakerReleaseControl());\n+            sendErrorResponse(action, transportChannel, message.getException());\n+        } else {\n+            final StreamInput stream = namedWriteableStream(message.openOrGetStreamInput());\n+            assertRemoteVersion(stream, header.getVersion());\n+            TransportChannel transportChannel = null;\n+            try {\n+                if (header.isHandshake()) {\n+                    // TODO: Modify the handshaker to use the TcpTransportChannl. This should be\n+                    //  straightforward now that handshakes contribute to circuit breaking.\n+                    handshaker.handleHandshake(version, channel, requestId, stream);\n                 } else {\n-                    breaker.addWithoutBreaking(messageLengthBytes);\n+                    transportChannel = new TcpTransportChannel(outboundHandler, channel, action, requestId, version, header.isCompressed(),\n+                        message.takeBreakerReleaseControl());\n+                    final RequestHandlerRegistry<T> reg = getRequestHandler(action);\n+                    assert reg != null;\n+                    final T request = reg.newRequest(stream);\n+                    request.remoteAddress(new TransportAddress(channel.getRemoteAddress()));\n+                    // in case we throw an exception, i.e. when the limit is hit, we don't want to verify\n+                    final int nextByte = stream.read();\n+                    // calling read() is useful to make sure the message is fully read, even if there some kind of EOS marker\n+                    if (nextByte != -1) {\n+                        throw new IllegalStateException(\"Message not fully read (request) for requestId [\" + requestId + \"], action [\"\n+                            + action + \"], available [\" + stream.available() + \"]; resetting\");\n+                    }\n+                    threadPool.executor(reg.getExecutor()).execute(new RequestHandler<>(reg, request, transportChannel));\n                 }\n-                transportChannel = new TcpTransportChannel(outboundHandler, channel, action, requestId, version,\n-                    circuitBreakerService, messageLengthBytes, header.isCompressed());\n-                final T request = reg.newRequest(stream);\n-                request.remoteAddress(new TransportAddress(channel.getRemoteAddress()));\n-                // in case we throw an exception, i.e. when the limit is hit, we don't want to verify\n-                final int nextByte = stream.read();\n-                // calling read() is useful to make sure the message is fully read, even if there some kind of EOS marker\n-                if (nextByte != -1) {\n-                    throw new IllegalStateException(\"Message not fully read (request) for requestId [\" + requestId + \"], action [\" + action\n-                        + \"], available [\" + stream.available() + \"]; resetting\");\n+            } catch (Exception e) {\n+                if (transportChannel == null) {\n+                    transportChannel = new TcpTransportChannel(outboundHandler, channel, action, requestId, version, header.isCompressed(),\n+                        message.takeBreakerReleaseControl());\n                 }\n-                threadPool.executor(reg.getExecutor()).execute(new RequestHandler<>(reg, request, transportChannel));\n-            }\n-        } catch (Exception e) {\n-            // the circuit breaker tripped\n-            if (transportChannel == null) {\n-                transportChannel = new TcpTransportChannel(outboundHandler, channel, action, requestId, version,\n-                    circuitBreakerService, 0, header.isCompressed());\n-            }\n-            try {\n-                transportChannel.sendResponse(e);\n-            } catch (IOException inner) {\n-                inner.addSuppressed(e);\n-                logger.warn(() -> new ParameterizedMessage(\"Failed to send error message back to client for action [{}]\", action), inner);\n+                sendErrorResponse(action, transportChannel, e);\n             }\n         }\n     }\n \n+    private static void sendErrorResponse(String actionName, TransportChannel transportChannel, Exception e) {\n+        try {\n+            transportChannel.sendResponse(e);\n+        } catch (IOException inner) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "901d63ed7dcf7b98bad8328b4102305831a4a149"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjk5MDI1MQ==", "bodyText": "I think we should protect against double-closing here, given how important it is to this correctly.", "url": "https://github.com/elastic/elasticsearch/pull/54610#discussion_r402990251", "createdAt": "2020-04-03T13:05:08Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/transport/InboundAggregator.java", "diffHunk": "@@ -108,23 +156,84 @@ public void close() {\n     }\n \n     private void closeCurrentAggregation() {\n+        releaseContent();\n+        resetCurrentAggregation();\n+    }\n+\n+    private void releaseContent() {\n         if (contentAggregation == null) {\n             Releasables.close(firstContent);\n         } else {\n             Releasables.close(contentAggregation);\n         }\n-        resetCurrentAggregation();\n     }\n \n     private void resetCurrentAggregation() {\n         firstContent = null;\n         contentAggregation = null;\n         currentHeader = null;\n+        aggregationException = null;\n+        canTripBreaker = true;\n     }\n \n     private void ensureOpen() {\n         if (isClosed) {\n             throw new IllegalStateException(\"Aggregator is already closed\");\n         }\n     }\n+\n+    private void initializeRequestState() {\n+        assert currentHeader.needsToReadVariableHeader() == false;\n+        assert currentHeader.isRequest();\n+        if (currentHeader.isHandshake()) {\n+            canTripBreaker = false;\n+            return;\n+        }\n+\n+        final String actionName = currentHeader.getActionName();\n+        try {\n+            canTripBreaker = requestCanTripBreaker.test(actionName);\n+        } catch (ActionNotFoundTransportException e) {\n+            shortCircuit(new ActionNotFoundTransportException(actionName));\n+        }\n+    }\n+\n+    private void checkBreaker(final Header header, final int contentLength, final BreakerControl breakerControl) {\n+        if (header.isRequest() == false) {\n+            return;\n+        }\n+        assert header.needsToReadVariableHeader() == false;\n+\n+        if (canTripBreaker) {\n+            try {\n+                circuitBreaker.get().addEstimateBytesAndMaybeBreak(contentLength, \"<transport_request>\");\n+                breakerControl.incrementReservedBytes(contentLength);\n+            } catch (CircuitBreakingException e) {\n+                shortCircuit(e);\n+            }\n+        } else {\n+            circuitBreaker.get().addWithoutBreaking(contentLength);\n+            breakerControl.incrementReservedBytes(contentLength);\n+        }\n+    }\n+\n+    private static class BreakerControl implements Releasable {\n+\n+        private final Supplier<CircuitBreaker> circuitBreaker;\n+        private final AtomicInteger bytesToRelease = new AtomicInteger(0);\n+\n+        private BreakerControl(Supplier<CircuitBreaker> circuitBreaker) {\n+            this.circuitBreaker = circuitBreaker;\n+        }\n+\n+        private void incrementReservedBytes(int delta) {\n+            bytesToRelease.getAndAdd(delta);\n+        }\n+\n+        @Override\n+        public void close() {\n+            final int toRelease = bytesToRelease.getAndSet(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "901d63ed7dcf7b98bad8328b4102305831a4a149"}, "originalPosition": 225}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjk5Mzk0OA==", "bodyText": "when do we expect this to happen? should we assert false here?", "url": "https://github.com/elastic/elasticsearch/pull/54610#discussion_r402993948", "createdAt": "2020-04-03T13:11:25Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/transport/InboundPipeline.java", "diffHunk": "@@ -74,6 +75,18 @@ public void close() {\n     }\n \n     public void handleBytes(TcpChannel channel, ReleasableBytesReference reference) throws IOException {\n+        if (uncaughtException != null) {\n+            throw new IllegalStateException(\"Pipeline state corrupted by uncaught exception\", uncaughtException);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "901d63ed7dcf7b98bad8328b4102305831a4a149"}, "originalPosition": 61}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "299feebcf8cc2bc81f01b7ed84164a671e0ee3d4", "author": {"user": {"login": "tbrooks8", "name": "Tim Brooks"}}, "url": "https://github.com/elastic/elasticsearch/commit/299feebcf8cc2bc81f01b7ed84164a671e0ee3d4", "committedDate": "2020-04-03T16:08:24Z", "message": "Merge remote-tracking branch 'upstream/master' into circuit_breaking_inside_pipeline"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac8b0f3e47b7bb6c43750d3a3a029d26de1c6c50", "author": {"user": {"login": "tbrooks8", "name": "Tim Brooks"}}, "url": "https://github.com/elastic/elasticsearch/commit/ac8b0f3e47b7bb6c43750d3a3a029d26de1c6c50", "committedDate": "2020-04-03T16:12:18Z", "message": "Delete comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "13f62856b7a2097691af72596fcc5e2969d61b85", "author": {"user": {"login": "tbrooks8", "name": "Tim Brooks"}}, "url": "https://github.com/elastic/elasticsearch/commit/13f62856b7a2097691af72596fcc5e2969d61b85", "committedDate": "2020-04-03T18:09:53Z", "message": "Changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f8cbb2e08ccb12bae6ca650c337aaad1e114fdcd", "author": {"user": {"login": "tbrooks8", "name": "Tim Brooks"}}, "url": "https://github.com/elastic/elasticsearch/commit/f8cbb2e08ccb12bae6ca650c337aaad1e114fdcd", "committedDate": "2020-04-03T19:04:35Z", "message": "Change"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6283366f0dd171ec6814c56d6f9eddd7c3c30278", "author": {"user": {"login": "tbrooks8", "name": "Tim Brooks"}}, "url": "https://github.com/elastic/elasticsearch/commit/6283366f0dd171ec6814c56d6f9eddd7c3c30278", "committedDate": "2020-04-03T19:29:01Z", "message": "Cleanup exception handling"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "21bbda9298ad9b0b9339bde53794346b1e28604e", "author": {"user": {"login": "tbrooks8", "name": "Tim Brooks"}}, "url": "https://github.com/elastic/elasticsearch/commit/21bbda9298ad9b0b9339bde53794346b1e28604e", "committedDate": "2020-04-03T19:33:12Z", "message": "Whitespace"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3f2a32cd687cdad6a204ce424e45e665d146d270", "author": {"user": {"login": "tbrooks8", "name": "Tim Brooks"}}, "url": "https://github.com/elastic/elasticsearch/commit/3f2a32cd687cdad6a204ce424e45e665d146d270", "committedDate": "2020-04-03T19:46:10Z", "message": "Merge remote-tracking branch 'upstream/master' into circuit_breaking_inside_pipeline"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3c7ae75c32026ed1c64a9b3a7ecd550b7db08097", "author": {"user": {"login": "tbrooks8", "name": "Tim Brooks"}}, "url": "https://github.com/elastic/elasticsearch/commit/3c7ae75c32026ed1c64a9b3a7ecd550b7db08097", "committedDate": "2020-04-03T19:50:55Z", "message": "Change"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "17f42a3f460e1c335a9df257cd4156bc29d2dd09", "author": {"user": {"login": "tbrooks8", "name": "Tim Brooks"}}, "url": "https://github.com/elastic/elasticsearch/commit/17f42a3f460e1c335a9df257cd4156bc29d2dd09", "committedDate": "2020-04-03T21:49:38Z", "message": "Merge remote-tracking branch 'upstream/master' into circuit_breaking_inside_pipeline"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4MDE4MzA5", "url": "https://github.com/elastic/elasticsearch/pull/54610#pullrequestreview-388018309", "createdAt": "2020-04-06T08:07:15Z", "commit": {"oid": "17f42a3f460e1c335a9df257cd4156bc29d2dd09"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwODowNzoxNVrOGBMNGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwODowNzoxNVrOGBMNGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzkwMTcyMQ==", "bodyText": "If TransportHandshaker.handleHandshake throws an exception (e.g. IllegalStateException), that is no longer bubbled up back to the node that initiated the handshake. I'm not sure what this change of behavior entails, but would suggest backing it out of this PR.", "url": "https://github.com/elastic/elasticsearch/pull/54610#discussion_r403901721", "createdAt": "2020-04-06T08:07:15Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/transport/InboundHandler.java", "diffHunk": "@@ -147,54 +145,57 @@ private void messageReceived(InboundMessage message, TcpChannel channel) throws\n         }\n     }\n \n-    private <T extends TransportRequest> void handleRequest(TcpChannel channel, Header header, StreamInput stream, int messageLengthBytes) {\n+    private <T extends TransportRequest> void handleRequest(TcpChannel channel, Header header, InboundMessage message) throws IOException {\n         final String action = header.getActionName();\n         final long requestId = header.getRequestId();\n         final Version version = header.getVersion();\n-        TransportChannel transportChannel = null;\n-        try {\n+        if (header.isHandshake()) {\n             messageListener.onRequestReceived(requestId, action);\n-            if (header.isHandshake()) {\n-                // Handshakes are not currently circuit broken\n-                transportChannel = new TcpTransportChannel(outboundHandler, channel, action, requestId, version,\n-                    circuitBreakerService, 0, header.isCompressed(), header.isHandshake());\n+            // Cannot short circuit handshakes\n+            assert message.isShortCircuit() == false;\n+            final StreamInput stream = namedWriteableStream(message.openOrGetStreamInput());\n+            assertRemoteVersion(stream, header.getVersion());\n+            try (Releasable breakerRelease = message.takeBreakerReleaseControl()) {\n+                final TransportChannel transportChannel = new TcpTransportChannel(outboundHandler, channel, action, requestId, version,\n+                    header.isCompressed(), header.isHandshake(), () -> {});\n                 handshaker.handleHandshake(transportChannel, requestId, stream);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17f42a3f460e1c335a9df257cd4156bc29d2dd09"}, "originalPosition": 105}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4MDgzMjc4", "url": "https://github.com/elastic/elasticsearch/pull/54610#pullrequestreview-388083278", "createdAt": "2020-04-06T09:35:35Z", "commit": {"oid": "17f42a3f460e1c335a9df257cd4156bc29d2dd09"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d972a6272e519277e795431b5f880e58eed238dc", "author": {"user": {"login": "tbrooks8", "name": "Tim Brooks"}}, "url": "https://github.com/elastic/elasticsearch/commit/d972a6272e519277e795431b5f880e58eed238dc", "committedDate": "2020-04-06T15:54:08Z", "message": "Changes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4NDI4Mjgz", "url": "https://github.com/elastic/elasticsearch/pull/54610#pullrequestreview-388428283", "createdAt": "2020-04-06T16:40:28Z", "commit": {"oid": "d972a6272e519277e795431b5f880e58eed238dc"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5f5fb0fe4c2e11a7f6074642264b0efa8f44c5b3", "author": {"user": {"login": "tbrooks8", "name": "Tim Brooks"}}, "url": "https://github.com/elastic/elasticsearch/commit/5f5fb0fe4c2e11a7f6074642264b0efa8f44c5b3", "committedDate": "2020-04-06T17:00:30Z", "message": "Merge remote-tracking branch 'upstream/master' into circuit_breaking_inside_pipeline"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c300562a5f736505ae185aa4f2f47a08071950cb", "author": {"user": {"login": "tbrooks8", "name": "Tim Brooks"}}, "url": "https://github.com/elastic/elasticsearch/commit/c300562a5f736505ae185aa4f2f47a08071950cb", "committedDate": "2020-04-06T17:44:21Z", "message": "Merge remote-tracking branch 'upstream/master' into circuit_breaking_inside_pipeline"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4ODE4MTEx", "url": "https://github.com/elastic/elasticsearch/pull/54610#pullrequestreview-388818111", "createdAt": "2020-04-07T06:30:52Z", "commit": {"oid": "c300562a5f736505ae185aa4f2f47a08071950cb"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1267, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}