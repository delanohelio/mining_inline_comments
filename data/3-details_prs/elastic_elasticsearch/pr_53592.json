{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg5MTUwMzI2", "number": 53592, "title": "Add async_search.submit to HLRC", "bodyText": "This commit adds a new AsyncSearchClient to the High Level Rest Client which\ninitially supporst the submitAsyncSearch in its blocking and non-blocking\nflavour. Also adding client side request and response objects and parsing code\nto parse the xContent output of the client side AsyncSearchResponse together\nwith parsing roundtrip tests and a simple roundtrip integration test.\nRelates to #49091", "createdAt": "2020-03-16T10:54:20Z", "url": "https://github.com/elastic/elasticsearch/pull/53592", "merged": true, "mergeCommit": {"oid": "dea6b7d67fab8d6db0a4cd4bd6502e56fe73ee27"}, "closed": true, "closedAt": "2020-03-19T19:13:41Z", "author": {"login": "cbuescher"}, "timelineItems": {"totalCount": 37, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcOL1E0gH2gAyMzg5MTUwMzI2OmExNDdjNDFiOGIxZGE0YTg1M2ZkY2FlNzQ4ZDFlNmIzMDFiOTEzMWE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcPP-99AH2gAyMzg5MTUwMzI2OjgyMjM5ODk3YmYwNWJjM2JkMmM5YzJmODdiNzU0ZjhlMTU0MmZkMDY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "a147c41b8b1da4a853fdcae748d1e6b301b9131a", "author": {"user": {"login": "cbuescher", "name": "Christoph B\u00fcscher"}}, "url": "https://github.com/elastic/elasticsearch/commit/a147c41b8b1da4a853fdcae748d1e6b301b9131a", "committedDate": "2020-03-16T10:47:57Z", "message": "Add async_search.submit to HLRC\n\nThis commit adds a new AsyncSearchClient to the High Level Rest Client which\ninitially supporst the submitAsyncSearch in its blocking and non-blocking\nflavour. Also adding client side request and response objects and parsing code\nto parse the xContent output of the client side AsyncSearchResponse together\nwith parsing roundtrip tests and a simple roundtrip integration test.\n\nRelates to #49091"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc1MjQ0ODY5", "url": "https://github.com/elastic/elasticsearch/pull/53592#pullrequestreview-375244869", "createdAt": "2020-03-16T14:07:57Z", "commit": {"oid": "a147c41b8b1da4a853fdcae748d1e6b301b9131a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNDowNzo1N1rOF21t2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNDowNzo1N1rOF21t2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA0NzUxNQ==", "bodyText": "We should probably not force users to remember to set this to false, although true seems to be the default. I wonder if we shold either\n\nset the value to false automatically for every SearchRequest once it is set for an AsyncSearchRequest\nignore this parameter as request parameter when sending the request\nignore this paramter on the receiving Rest action regardless of how it is set in the client (maybe warn)\nfail on the client side already when validating the request. This would still require the user to always set the property to \"false\" manually", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r393047515", "createdAt": "2020-03-16T14:07:57Z", "author": {"login": "cbuescher"}, "path": "client/rest-high-level/src/test/java/org/elasticsearch/client/asyncsearch/AsyncSearchIT.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.client.ESRestHighLevelClientTestCase;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+\n+import java.io.IOException;\n+import java.util.concurrent.TimeUnit;\n+\n+public class AsyncSearchIT extends ESRestHighLevelClientTestCase {\n+\n+    public void testSubmitAsyncSearchRequest() throws IOException {\n+        String index = \"test-index\";\n+        createIndex(index, Settings.EMPTY);\n+\n+        SearchRequest searchRequest = new SearchRequest(index);\n+        // TODO either check that in client request validation already or set it automatically?\n+        searchRequest.setCcsMinimizeRoundtrips(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a147c41b8b1da4a853fdcae748d1e6b301b9131a"}, "originalPosition": 41}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ebf54280526c314dcd9dbff1782d4ecff54804e2", "author": {"user": {"login": "cbuescher", "name": "Christoph B\u00fcscher"}}, "url": "https://github.com/elastic/elasticsearch/commit/ebf54280526c314dcd9dbff1782d4ecff54804e2", "committedDate": "2020-03-16T14:09:25Z", "message": "iter"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc1Mjc5Mzcz", "url": "https://github.com/elastic/elasticsearch/pull/53592#pullrequestreview-375279373", "createdAt": "2020-03-16T14:38:10Z", "commit": {"oid": "ebf54280526c314dcd9dbff1782d4ecff54804e2"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNDozODoxMFrOF23ULw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNDo0MTo0OFrOF23egA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA3MzcxMQ==", "bodyText": "Is it required to extend TimedRequest ? What's the advantage of doing so ?", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r393073711", "createdAt": "2020-03-16T14:38:10Z", "author": {"login": "jimczi"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.client.TimedRequest;\n+import org.elasticsearch.common.unit.TimeValue;\n+\n+import java.util.Objects;\n+\n+public class SubmitAsyncSearchRequest extends TimedRequest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ebf54280526c314dcd9dbff1782d4ecff54804e2"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA3NDA3Mw==", "bodyText": "Can you add javadocs for the options ?", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r393074073", "createdAt": "2020-03-16T14:38:44Z", "author": {"login": "jimczi"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.client.TimedRequest;\n+import org.elasticsearch.common.unit.TimeValue;\n+\n+import java.util.Objects;\n+\n+public class SubmitAsyncSearchRequest extends TimedRequest {\n+\n+    private TimeValue waitForCompletion;\n+    private Boolean cleanOnCompletion;\n+    private TimeValue keepAlive;\n+    private final SearchRequest searchRequest;\n+\n+    public SubmitAsyncSearchRequest(SearchRequest searchRequest) {\n+        this.searchRequest = searchRequest;\n+}\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ebf54280526c314dcd9dbff1782d4ecff54804e2"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA3NjM1Mg==", "bodyText": "Can we try to avoid this change ? Maybe using a custom parser in the root object parser for the response field ?", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r393076352", "createdAt": "2020-03-16T14:41:48Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/action/search/SearchResponse.java", "diffHunk": "@@ -255,8 +255,12 @@ public XContentBuilder innerToXContent(XContentBuilder builder, Params params) t\n     }\n \n     public static SearchResponse fromXContent(XContentParser parser) throws IOException {\n-        ensureExpectedToken(Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n-        parser.nextToken();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ebf54280526c314dcd9dbff1782d4ecff54804e2"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ed46e6165c7b91fa99fac3e26e2af4638ae647c", "author": {"user": {"login": "cbuescher", "name": "Christoph B\u00fcscher"}}, "url": "https://github.com/elastic/elasticsearch/commit/0ed46e6165c7b91fa99fac3e26e2af4638ae647c", "committedDate": "2020-03-16T17:08:57Z", "message": "Change supertype of SubmitAsyncSearchRequest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "701793e47997edd4e61c12352adfe5f21225da6b", "author": {"user": {"login": "cbuescher", "name": "Christoph B\u00fcscher"}}, "url": "https://github.com/elastic/elasticsearch/commit/701793e47997edd4e61c12352adfe5f21225da6b", "committedDate": "2020-03-16T17:22:06Z", "message": "Adding javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "089485bd01819fdc332fa8c3d97a87600bf3fb22", "author": {"user": {"login": "cbuescher", "name": "Christoph B\u00fcscher"}}, "url": "https://github.com/elastic/elasticsearch/commit/089485bd01819fdc332fa8c3d97a87600bf3fb22", "committedDate": "2020-03-16T17:52:42Z", "message": "Overwrite certain SearchRequest paramters on submit request"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "87a4f928060b6a239d156859681b36fe56698d53", "author": {"user": {"login": "cbuescher", "name": "Christoph B\u00fcscher"}}, "url": "https://github.com/elastic/elasticsearch/commit/87a4f928060b6a239d156859681b36fe56698d53", "committedDate": "2020-03-16T17:59:50Z", "message": "Change SearchResponse parsing"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc1Nzg0NDE3", "url": "https://github.com/elastic/elasticsearch/pull/53592#pullrequestreview-375784417", "createdAt": "2020-03-17T07:12:45Z", "commit": {"oid": "87a4f928060b6a239d156859681b36fe56698d53"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwNzoxMjo0NVrOF3QJbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwNzoxNTozNVrOF3QNEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ4MDU1Ng==", "bodyText": "The response is shared with the get api so can you rename like the original AsyncSearchResponse ?", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r393480556", "createdAt": "2020-03-17T07:12:45Z", "author": {"login": "jimczi"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchResponse.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentParser.Token;\n+\n+import java.io.IOException;\n+\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+/**\n+ * A response of an async search request.\n+ */\n+public class SubmitAsyncSearchResponse implements ToXContentObject  {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87a4f928060b6a239d156859681b36fe56698d53"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ4MTA3MA==", "bodyText": "The original request takes the indices to search in the constructor rather than the SearchRequest that is created internally. Can you adapt it to match the behavior of the transport request ?", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r393481070", "createdAt": "2020-03-17T07:14:18Z", "author": {"login": "jimczi"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.client.Validatable;\n+import org.elasticsearch.common.unit.TimeValue;\n+\n+import java.util.Objects;\n+\n+/**\n+ * A request to track asynchronously the progress of a search against one or more indices.\n+ */\n+public class SubmitAsyncSearchRequest implements Validatable {\n+\n+    private TimeValue waitForCompletion;\n+    private Boolean cleanOnCompletion;\n+    private TimeValue keepAlive;\n+    private final SearchRequest searchRequest;\n+\n+    /**\n+     * Create a request to submit an async search.\n+     * Target indices, queries and all other search related options should be set on\n+     * the input {@link SearchRequest}.\n+     * @param searchRequest the actual search request to submit\n+     */\n+    public SubmitAsyncSearchRequest(SearchRequest searchRequest) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87a4f928060b6a239d156859681b36fe56698d53"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ4MTE1MQ==", "bodyText": "++", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r393481151", "createdAt": "2020-03-17T07:14:31Z", "author": {"login": "jimczi"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchResponse.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentParser.Token;\n+\n+import java.io.IOException;\n+\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+/**\n+ * A response of an async search request.\n+ */\n+public class SubmitAsyncSearchResponse implements ToXContentObject  {\n+    @Nullable\n+    private String id;\n+    private final int version;\n+    private SearchResponse searchResponse;\n+    private ElasticsearchException error;\n+    private final boolean isRunning;\n+    private final boolean isPartial;\n+\n+    private final long startTimeMillis;\n+    private final long expirationTimeMillis;\n+\n+    /**\n+     * Creates an {@link SubmitAsyncSearchResponse} with the arguments that are always present in the server response\n+     */\n+    SubmitAsyncSearchResponse(int version,\n+                               boolean isPartial,\n+                               boolean isRunning,\n+                               long startTimeMillis,\n+                               long expirationTimeMillis) {\n+        this.version = version;\n+        this.isPartial = isPartial;\n+        this.isRunning = isRunning;\n+        this.startTimeMillis = startTimeMillis;\n+        this.expirationTimeMillis = expirationTimeMillis;\n+    }\n+\n+    /**\n+     * Returns the id of the async search request or null if the response is not stored in the cluster.\n+     */\n+    @Nullable\n+    public String getId() {\n+        return id;\n+    }\n+\n+    /**\n+     * Sets the optional id property, use by parser and tests\n+     */\n+    void setId(String id) {\n+        this.id = id;\n+    }\n+\n+    /**\n+     * Returns the version of this response.\n+     */\n+    public int getVersion() {\n+        return version;\n+    }\n+\n+    /**\n+     * Returns the current {@link SearchResponse} or <code>null</code> if not available.\n+     *\n+     * See {@link #isPartial()} to determine whether the response contains partial or complete\n+     * results.\n+     */\n+    public SearchResponse getSearchResponse() {\n+        return searchResponse;\n+    }\n+\n+    /**\n+     * Sets the optional search response property, used by parser and tests\n+     */\n+    void setSearchResponse(SearchResponse searchResponse) {\n+        this.searchResponse = searchResponse;\n+    }\n+\n+    /**\n+     * Returns the failure reason or null if the query is running or has completed normally.\n+     */\n+    public ElasticsearchException getFailure() {\n+        return error;\n+    }\n+\n+    /**\n+     * Sets the optional failure property, use by parser and tests\n+     */\n+    void setFailure(ElasticsearchException error) {\n+        this.error = error;\n+    }\n+\n+    /**\n+     * Returns <code>true</code> if the {@link SearchResponse} contains partial\n+     * results computed from a subset of the total shards.\n+     */\n+    public boolean isPartial() {\n+        return isPartial;\n+    }\n+\n+    /**\n+     * Whether the search is still running in the cluster.\n+     *\n+     * A value of <code>false</code> indicates that the response is final\n+     * even if {@link #isPartial()} returns <code>true</code>. In such case,\n+     * the partial response represents the status of the search before a\n+     * non-recoverable failure.\n+     */\n+    public boolean isRunning() {\n+        return isRunning;\n+    }\n+\n+    /**\n+     * When this response was created as a timestamp in milliseconds since epoch.\n+     */\n+    public long getStartTime() {\n+        return startTimeMillis;\n+    }\n+\n+    /**\n+     * When this response will expired as a timestamp in milliseconds since epoch.\n+     */\n+    public long getExpirationTime() {\n+        return expirationTimeMillis;\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject();\n+        if (id != null) {\n+            builder.field(\"id\", id);\n+        }\n+        builder.field(\"version\", version);\n+        builder.field(\"is_partial\", isPartial);\n+        builder.field(\"is_running\", isRunning);\n+        builder.field(\"start_time_in_millis\", startTimeMillis);\n+        builder.field(\"expiration_time_in_millis\", expirationTimeMillis);\n+\n+        if (searchResponse != null) {\n+            builder.field(\"response\");\n+            searchResponse.toXContent(builder, params);\n+        }\n+        if (error != null) {\n+            builder.startObject(\"error\");\n+            error.toXContent(builder, params);\n+            builder.endObject();\n+        }\n+        builder.endObject();\n+        return builder;\n+    }\n+\n+    public static final ParseField ID_FIELD = new ParseField(\"id\");\n+    public static final ParseField VERSION_FIELD = new ParseField(\"version\");\n+    public static final ParseField IS_PARTIAL_FIELD = new ParseField(\"is_partial\");\n+    public static final ParseField IS_RUNNING_FIELD = new ParseField(\"is_running\");\n+    public static final ParseField START_TIME_FIELD = new ParseField(\"start_time_in_millis\");\n+    public static final ParseField EXPIRATION_FIELD = new ParseField(\"expiration_time_in_millis\");\n+    public static final ParseField RESPONSE_FIELD = new ParseField(\"response\");\n+    public static final ParseField ERROR_FIELD = new ParseField(\"error\");\n+\n+    public static final ConstructingObjectParser<SubmitAsyncSearchResponse, Void> PARSER = new ConstructingObjectParser<>(\n+            \"submit_async_search_response\", true,\n+            args -> new SubmitAsyncSearchResponse(\n+                    (int) args[0],\n+                    (boolean) args[1],\n+                    (boolean) args[2],\n+                    (long) args[3],\n+                    (long) args[4]));\n+    static {\n+        PARSER.declareInt(ConstructingObjectParser.constructorArg(), VERSION_FIELD);\n+        PARSER.declareBoolean(ConstructingObjectParser.constructorArg(), IS_PARTIAL_FIELD);\n+        PARSER.declareBoolean(ConstructingObjectParser.constructorArg(), IS_RUNNING_FIELD);\n+        PARSER.declareLong(ConstructingObjectParser.constructorArg(), START_TIME_FIELD);\n+        PARSER.declareLong(ConstructingObjectParser.constructorArg(), EXPIRATION_FIELD);\n+        PARSER.declareString(SubmitAsyncSearchResponse::setId, ID_FIELD);\n+        PARSER.declareObject(SubmitAsyncSearchResponse::setSearchResponse, (p, c) -> SubmitAsyncSearchResponse.parseSearchResponse(p),\n+                RESPONSE_FIELD);\n+        PARSER.declareObject(SubmitAsyncSearchResponse::setFailure, (p, c) -> ElasticsearchException.fromXContent(p), ERROR_FIELD);\n+    }\n+\n+    private static SearchResponse parseSearchResponse(XContentParser p) throws IOException {\n+        // we should be before the opening START_OBJECT of the response\n+        ensureExpectedToken(Token.START_OBJECT, p.currentToken(), p::getTokenLocation);\n+        p.nextToken();\n+        return SearchResponse.innerFromXContent(p);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87a4f928060b6a239d156859681b36fe56698d53"}, "originalPosition": 211}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ4MTQ4OA==", "bodyText": "This can be removed now that we set these values automatically in the ctr ?", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r393481488", "createdAt": "2020-03-17T07:15:35Z", "author": {"login": "jimczi"}, "path": "client/rest-high-level/src/test/java/org/elasticsearch/client/asyncsearch/AsyncSearchIT.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.client.ESRestHighLevelClientTestCase;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+\n+import java.io.IOException;\n+import java.util.concurrent.TimeUnit;\n+\n+public class AsyncSearchIT extends ESRestHighLevelClientTestCase {\n+\n+    public void testSubmitAsyncSearchRequest() throws IOException {\n+        String index = \"test-index\";\n+        createIndex(index, Settings.EMPTY);\n+\n+        SearchRequest searchRequest = new SearchRequest(index);\n+        // TODO either check that in client request validation already or set it automatically?\n+        searchRequest.setCcsMinimizeRoundtrips(false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA0NzUxNQ=="}, "originalCommit": {"oid": "a147c41b8b1da4a853fdcae748d1e6b301b9131a"}, "originalPosition": 41}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "207441dd07eee0b9b0efd474eba1336eb3c24c68", "author": {"user": {"login": "cbuescher", "name": "Christoph B\u00fcscher"}}, "url": "https://github.com/elastic/elasticsearch/commit/207441dd07eee0b9b0efd474eba1336eb3c24c68", "committedDate": "2020-03-17T09:28:36Z", "message": "Merge branch 'master' into async-search-hlrc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8f708af8bd46b3dc9c6516c9ec04c29c5f85d7af", "author": {"user": {"login": "cbuescher", "name": "Christoph B\u00fcscher"}}, "url": "https://github.com/elastic/elasticsearch/commit/8f708af8bd46b3dc9c6516c9ec04c29c5f85d7af", "committedDate": "2020-03-17T09:50:21Z", "message": "Rename response class"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b7d6f1438d71f47d3c4cede30de6d2447cdf3079", "author": {"user": {"login": "cbuescher", "name": "Christoph B\u00fcscher"}}, "url": "https://github.com/elastic/elasticsearch/commit/b7d6f1438d71f47d3c4cede30de6d2447cdf3079", "committedDate": "2020-03-17T09:54:36Z", "message": "Don't set CcsMinimizeRountrips in test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "68baeb933103cf574345295f661493cdaa4cf1c6", "author": {"user": {"login": "cbuescher", "name": "Christoph B\u00fcscher"}}, "url": "https://github.com/elastic/elasticsearch/commit/68baeb933103cf574345295f661493cdaa4cf1c6", "committedDate": "2020-03-17T10:18:15Z", "message": "Use setCleanOnCompletion(false) in AsyncSearchIT to always get an ID back"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "94083b6e6b5585d92c3960be5dbdc4de54b22362", "author": {"user": {"login": "cbuescher", "name": "Christoph B\u00fcscher"}}, "url": "https://github.com/elastic/elasticsearch/commit/94083b6e6b5585d92c3960be5dbdc4de54b22362", "committedDate": "2020-03-17T14:58:18Z", "message": "Change ctor of SubmitAsyncSearchRequest"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc2MTI0NzU4", "url": "https://github.com/elastic/elasticsearch/pull/53592#pullrequestreview-376124758", "createdAt": "2020-03-17T15:07:46Z", "commit": {"oid": "94083b6e6b5585d92c3960be5dbdc4de54b22362"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxNTowNzo0N1rOF3giiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxNTowNzo0N1rOF3giiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzc0OTEyOA==", "bodyText": "We should also expose batchedReduceSize since that's the option to use to change the granularity of the progress ?", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r393749128", "createdAt": "2020-03-17T15:07:47Z", "author": {"login": "jimczi"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchType;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.client.Validatable;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+\n+import java.util.Objects;\n+\n+/**\n+ * A request to track asynchronously the progress of a search against one or more indices.\n+ */\n+public class SubmitAsyncSearchRequest implements Validatable {\n+\n+    private TimeValue waitForCompletion;\n+    private Boolean cleanOnCompletion;\n+    private TimeValue keepAlive;\n+    private final SearchRequest searchRequest;\n+\n+    /**\n+     * Creates a new request\n+     */\n+    public SubmitAsyncSearchRequest(SearchSourceBuilder source, String... indices) {\n+        this.searchRequest = new SearchRequest(indices, source);\n+        searchRequest.setCcsMinimizeRoundtrips(false);\n+        searchRequest.setPreFilterShardSize(1);\n+        searchRequest.setBatchedReduceSize(5);\n+        searchRequest.requestCache(true);\n+    }\n+\n+\n+    /**\n+     * Get the {@link SearchRequest} that this submit request wraps\n+     */\n+    public SearchRequest getSearchRequest() {\n+        return searchRequest;\n+    }\n+\n+    /**\n+     * Get the minimum time that the request should wait before returning a partial result (defaults to 1 second).\n+     */\n+    public TimeValue getWaitForCompletion() {\n+        return waitForCompletion;\n+    }\n+\n+    /**\n+     * Sets the minimum time that the request should wait before returning a partial result (defaults to 1 second).\n+     */\n+    public void setWaitForCompletion(TimeValue waitForCompletion) {\n+        this.waitForCompletion = waitForCompletion;\n+    }\n+\n+    /**\n+     * Returns whether the resource resource should be removed on completion or failure (defaults to true).\n+     */\n+    public Boolean isCleanOnCompletion() {\n+        return cleanOnCompletion;\n+    }\n+\n+    /**\n+     * Determines if the resource should be removed on completion or failure (defaults to true).\n+     */\n+    public void setCleanOnCompletion(boolean cleanOnCompletion) {\n+        this.cleanOnCompletion = cleanOnCompletion;\n+    }\n+\n+    /**\n+     * Get the amount of time after which the result will expire (defaults to 5 days).\n+     */\n+    public TimeValue getKeepAlive() {\n+        return keepAlive;\n+    }\n+\n+    /**\n+     * Sets the amount of time after which the result will expire (defaults to 5 days).\n+     */\n+    public void setKeepAlive(TimeValue keepAlive) {\n+        this.keepAlive = keepAlive;\n+    }\n+\n+    // setters for request parameters of the wrapped SearchRequest\n+    /**\n+     * Set the routing values to control the shards that the search will be executed on.\n+     * A comma separated list of routing values to control the shards the search will be executed on.\n+     */\n+    public void routing(String routing) {\n+        this.searchRequest.routing(routing);\n+    }\n+\n+    /**\n+     * Set the routing values to control the shards that the search will be executed on.\n+     */\n+    public void routing(String... routings) {\n+        this.searchRequest.routing(routings);\n+    }\n+\n+    /**\n+     * Sets the preference to execute the search. Defaults to randomize across shards. Can be set to\n+     * {@code _local} to prefer local shards or a custom value, which guarantees that the same order\n+     * will be used across different requests.\n+     */\n+    public void preference(String preference) {\n+        this.searchRequest.preference(preference);\n+    }\n+\n+    /**\n+     * Specifies what type of requested indices to ignore and how to deal with indices wildcard expressions.\n+     */\n+    public void indicesOptions(IndicesOptions indicesOptions) {\n+        this.searchRequest.indicesOptions(indicesOptions);\n+    }\n+\n+    /**\n+     * The search type to execute, defaults to {@link SearchType#DEFAULT}.\n+     */\n+    public void searchType(SearchType searchType) {\n+        this.searchRequest.searchType(searchType);\n+    }\n+\n+    /**\n+     * Sets if this request should allow partial results. (If method is not called,\n+     * will default to the cluster level setting).\n+     */\n+    public void allowPartialSearchResults(boolean allowPartialSearchResults) {\n+        this.searchRequest.allowPartialSearchResults(allowPartialSearchResults);\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94083b6e6b5585d92c3960be5dbdc4de54b22362"}, "originalPosition": 149}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "07966510b30766367b80c0ead730a83b293afc9f", "author": {"user": {"login": "cbuescher", "name": "Christoph B\u00fcscher"}}, "url": "https://github.com/elastic/elasticsearch/commit/07966510b30766367b80c0ead730a83b293afc9f", "committedDate": "2020-03-17T15:24:17Z", "message": "Merge branch 'master' into async-search-hlrc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "310fdee51c59a7d28eb2b4e7d3627767969161a9", "author": {"user": {"login": "cbuescher", "name": "Christoph B\u00fcscher"}}, "url": "https://github.com/elastic/elasticsearch/commit/310fdee51c59a7d28eb2b4e7d3627767969161a9", "committedDate": "2020-03-17T17:33:07Z", "message": "Add request validation and tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7e02579a94fa48bade62a04d565d2b5f38f457aa", "author": {"user": {"login": "cbuescher", "name": "Christoph B\u00fcscher"}}, "url": "https://github.com/elastic/elasticsearch/commit/7e02579a94fa48bade62a04d565d2b5f38f457aa", "committedDate": "2020-03-17T18:16:07Z", "message": "iter on failing test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c88625a4d76a44a2c9c783b3c0d6f0a6057dc4fb", "author": {"user": {"login": "cbuescher", "name": "Christoph B\u00fcscher"}}, "url": "https://github.com/elastic/elasticsearch/commit/c88625a4d76a44a2c9c783b3c0d6f0a6057dc4fb", "committedDate": "2020-03-17T18:37:12Z", "message": "Expose batchedReduceSize and batchedReduceSize on submit request"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc2NzE2ODYx", "url": "https://github.com/elastic/elasticsearch/pull/53592#pullrequestreview-376716861", "createdAt": "2020-03-18T10:02:56Z", "commit": {"oid": "c88625a4d76a44a2c9c783b3c0d6f0a6057dc4fb"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxMDowMjo1N1rOF3922Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxMDoyOToxMlrOF3-z9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIyOTQ2NQ==", "bodyText": "I wonder if we need to expose this async async method. Is there a reason why people would call an async API asynchronously?", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394229465", "createdAt": "2020-03-18T10:02:57Z", "author": {"login": "javanna"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/AsyncSearchClient.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.client;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.client.asyncsearch.SubmitAsyncSearchRequest;\n+import org.elasticsearch.client.asyncsearch.AsyncSearchResponse;\n+\n+import java.io.IOException;\n+\n+import static java.util.Collections.emptySet;\n+\n+public class AsyncSearchClient {\n+    private final RestHighLevelClient restHighLevelClient;\n+\n+    AsyncSearchClient(RestHighLevelClient restHighLevelClient) {\n+        this.restHighLevelClient = restHighLevelClient;\n+    }\n+\n+    // TODO add docs url\n+    /**\n+     * Submit a new async search request.\n+     * See <a href=\"todo\"> the docs</a> for more.\n+     * @param request the request\n+     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n+     * @return the response\n+     * @throws IOException in case there is a problem sending the request or parsing back the response\n+     */\n+    public AsyncSearchResponse submitAsyncSearch(SubmitAsyncSearchRequest request, RequestOptions options) throws IOException {\n+        return restHighLevelClient.performRequestAndParseEntity(request, AsyncSearchRequestConverters::submitAsyncSearch, options,\n+                AsyncSearchResponse::fromXContent, emptySet());\n+    }\n+\n+    // TODO add docs url\n+    /**\n+     * Asynchronously submit a new async search request.\n+     * See <a href=\"todo\"> the docs</a> for more.\n+     * <a href=\"https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/java-rest-high-ilm-ilm-get-lifecycle-policy.html\">\n+     * the docs</a> for more.\n+     * @param request the request\n+     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n+     * @param listener the listener to be notified upon request completion\n+     * @return cancellable that may be used to cancel the request\n+     */\n+    public Cancellable submitAsyncSearchAsync(SubmitAsyncSearchRequest request, RequestOptions options,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c88625a4d76a44a2c9c783b3c0d6f0a6057dc4fb"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIzNDYxMw==", "bodyText": "good catch, looks like search was not supporting this parameter.", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394234613", "createdAt": "2020-03-18T10:11:44Z", "author": {"login": "javanna"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/RequestConverters.java", "diffHunk": "@@ -403,13 +403,14 @@ static Request search(SearchRequest searchRequest, String searchEndpoint) throws\n         return request;\n     }\n \n-    private static void addSearchRequestParams(Params params, SearchRequest searchRequest) {\n+    static void addSearchRequestParams(Params params, SearchRequest searchRequest) {\n         params.putParam(RestSearchAction.TYPED_KEYS_PARAM, \"true\");\n         params.withRouting(searchRequest.routing());\n         params.withPreference(searchRequest.preference());\n         params.withIndicesOptions(searchRequest.indicesOptions());\n         params.putParam(\"search_type\", searchRequest.searchType().name().toLowerCase(Locale.ROOT));\n         params.putParam(\"ccs_minimize_roundtrips\", Boolean.toString(searchRequest.isCcsMinimizeRoundtrips()));\n+        params.putParam(\"pre_filter_shard_size\", Integer.toString(searchRequest.getPreFilterShardSize()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c88625a4d76a44a2c9c783b3c0d6f0a6057dc4fb"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIzNTY0Ng==", "bodyText": "maybe this should be nullable too?", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394235646", "createdAt": "2020-03-18T10:13:18Z", "author": {"login": "javanna"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/AsyncSearchResponse.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentParser.Token;\n+\n+import java.io.IOException;\n+\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+/**\n+ * A response of an async search request.\n+ */\n+public class AsyncSearchResponse implements ToXContentObject  {\n+    @Nullable\n+    private String id;\n+    private final int version;\n+    private SearchResponse searchResponse;\n+    private ElasticsearchException error;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c88625a4d76a44a2c9c783b3c0d6f0a6057dc4fb"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIzODgzNg==", "bodyText": "I see that whether or not to expose the inner search request was discussed in previous reviews. I am confused though on what direction was chosen. I see that the getters and setters from the search request are copied to the async request, but the inner search request is still exposed through this getter and can be modified directly. Didn't we want to rather hide it from users?", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394238836", "createdAt": "2020-03-18T10:18:25Z", "author": {"login": "javanna"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchType;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.client.Validatable;\n+import org.elasticsearch.client.ValidationException;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+/**\n+ * A request to track asynchronously the progress of a search against one or more indices.\n+ */\n+public class SubmitAsyncSearchRequest implements Validatable {\n+\n+    public static long MIN_KEEP_ALIVE = TimeValue.timeValueMinutes(1).millis();\n+\n+    private TimeValue waitForCompletion;\n+    private Boolean cleanOnCompletion;\n+    private TimeValue keepAlive;\n+    private final SearchRequest searchRequest;\n+\n+    /**\n+     * Creates a new request\n+     */\n+    public SubmitAsyncSearchRequest(SearchSourceBuilder source, String... indices) {\n+        this.searchRequest = new SearchRequest(indices, source);\n+        searchRequest.setCcsMinimizeRoundtrips(false);\n+        searchRequest.setPreFilterShardSize(1);\n+        searchRequest.setBatchedReduceSize(5);\n+        searchRequest.requestCache(true);\n+    }\n+\n+\n+    /**\n+     * Get the {@link SearchRequest} that this submit request wraps\n+     */\n+    public SearchRequest getSearchRequest() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c88625a4d76a44a2c9c783b3c0d6f0a6057dc4fb"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIzOTI5OA==", "bodyText": "annoying nit: I see that some getters and setters use the get and set prefix in this class, while others don't. I get why, but shall we unify the style at least throughout this one class?", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394239298", "createdAt": "2020-03-18T10:19:17Z", "author": {"login": "javanna"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchType;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.client.Validatable;\n+import org.elasticsearch.client.ValidationException;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+/**\n+ * A request to track asynchronously the progress of a search against one or more indices.\n+ */\n+public class SubmitAsyncSearchRequest implements Validatable {\n+\n+    public static long MIN_KEEP_ALIVE = TimeValue.timeValueMinutes(1).millis();\n+\n+    private TimeValue waitForCompletion;\n+    private Boolean cleanOnCompletion;\n+    private TimeValue keepAlive;\n+    private final SearchRequest searchRequest;\n+\n+    /**\n+     * Creates a new request\n+     */\n+    public SubmitAsyncSearchRequest(SearchSourceBuilder source, String... indices) {\n+        this.searchRequest = new SearchRequest(indices, source);\n+        searchRequest.setCcsMinimizeRoundtrips(false);\n+        searchRequest.setPreFilterShardSize(1);\n+        searchRequest.setBatchedReduceSize(5);\n+        searchRequest.requestCache(true);\n+    }\n+\n+\n+    /**\n+     * Get the {@link SearchRequest} that this submit request wraps\n+     */\n+    public SearchRequest getSearchRequest() {\n+        return searchRequest;\n+    }\n+\n+    /**\n+     * Get the minimum time that the request should wait before returning a partial result (defaults to 1 second).\n+     */\n+    public TimeValue getWaitForCompletion() {\n+        return waitForCompletion;\n+    }\n+\n+    /**\n+     * Sets the minimum time that the request should wait before returning a partial result (defaults to 1 second).\n+     */\n+    public void setWaitForCompletion(TimeValue waitForCompletion) {\n+        this.waitForCompletion = waitForCompletion;\n+    }\n+\n+    /**\n+     * Returns whether the resource resource should be removed on completion or failure (defaults to true).\n+     */\n+    public Boolean isCleanOnCompletion() {\n+        return cleanOnCompletion;\n+    }\n+\n+    /**\n+     * Determines if the resource should be removed on completion or failure (defaults to true).\n+     */\n+    public void setCleanOnCompletion(boolean cleanOnCompletion) {\n+        this.cleanOnCompletion = cleanOnCompletion;\n+    }\n+\n+    /**\n+     * Get the amount of time after which the result will expire (defaults to 5 days).\n+     */\n+    public TimeValue getKeepAlive() {\n+        return keepAlive;\n+    }\n+\n+    /**\n+     * Sets the amount of time after which the result will expire (defaults to 5 days).\n+     */\n+    public void setKeepAlive(TimeValue keepAlive) {\n+        this.keepAlive = keepAlive;\n+    }\n+\n+    // setters for request parameters of the wrapped SearchRequest\n+    /**\n+     * Set the routing values to control the shards that the search will be executed on.\n+     * A comma separated list of routing values to control the shards the search will be executed on.\n+     */\n+    public void routing(String routing) {\n+        this.searchRequest.routing(routing);\n+    }\n+\n+    /**\n+     * Set the routing values to control the shards that the search will be executed on.\n+     */\n+    public void routing(String... routings) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c88625a4d76a44a2c9c783b3c0d6f0a6057dc4fb"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDI0NTExMQ==", "bodyText": "this should work but it's also risky. What other options we have?\n\nincrease the timeout even more to really make sure it's enough, though what is enough\naccept that we may get a response while the search is still running, in which case is_partial and is_final will have a different value? Maybe don't set cleanOnCompletion and assert that when the id is returned the search is running, and when the id is not returned, both flags are false.\n\nI am not sure either way, maybe  I would go for option 1.", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394245111", "createdAt": "2020-03-18T10:29:12Z", "author": {"login": "javanna"}, "path": "client/rest-high-level/src/test/java/org/elasticsearch/client/asyncsearch/AsyncSearchIT.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.client.ESRestHighLevelClientTestCase;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+\n+import java.io.IOException;\n+import java.util.concurrent.TimeUnit;\n+\n+public class AsyncSearchIT extends ESRestHighLevelClientTestCase {\n+\n+    public void testSubmitAsyncSearchRequest() throws IOException {\n+        String index = \"test-index\";\n+        createIndex(index, Settings.EMPTY);\n+\n+        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder().query(QueryBuilders.matchAllQuery());\n+        SubmitAsyncSearchRequest request = new SubmitAsyncSearchRequest(sourceBuilder, index);\n+        // 2 sec should be enough to make sure we always complete right away\n+        request.setWaitForCompletion(new TimeValue(2, TimeUnit.SECONDS));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c88625a4d76a44a2c9c783b3c0d6f0a6057dc4fb"}, "originalPosition": 41}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3e5a33fe9da0332a480ed5de7c6b3d1dfdf4b851", "author": {"user": {"login": "cbuescher", "name": "Christoph B\u00fcscher"}}, "url": "https://github.com/elastic/elasticsearch/commit/3e5a33fe9da0332a480ed5de7c6b3d1dfdf4b851", "committedDate": "2020-03-18T14:32:26Z", "message": "Adressing review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc2OTcxNzI0", "url": "https://github.com/elastic/elasticsearch/pull/53592#pullrequestreview-376971724", "createdAt": "2020-03-18T15:23:25Z", "commit": {"oid": "3e5a33fe9da0332a480ed5de7c6b3d1dfdf4b851"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNToyMzoyNVrOF4KI2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNToyODowNFrOF4KWdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQzMDY4MA==", "bodyText": "we may want to expose a setter for the source too. Not so important but I guess users would argue that once set at the constructor it can never be reset. Search request allows to set it.", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394430680", "createdAt": "2020-03-18T15:23:25Z", "author": {"login": "javanna"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchType;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.client.Validatable;\n+import org.elasticsearch.client.ValidationException;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+/**\n+ * A request to track asynchronously the progress of a search against one or more indices.\n+ */\n+public class SubmitAsyncSearchRequest implements Validatable {\n+\n+    public static final int DEFAULT_PRE_FILTER_SHARD_SIZE = 1;\n+    public static final int DEFAULT_BATCHED_REDUCE_SIZE = 5;\n+    public static final boolean DEFAULT_CCS_MINIMIZE_ROUNDTRIPS = false;\n+    public static final boolean DEFAULT_REQUEST_CACHE_VALUE = true;\n+\n+    public static long MIN_KEEP_ALIVE = TimeValue.timeValueMinutes(1).millis();\n+\n+    private TimeValue waitForCompletion;\n+    private Boolean cleanOnCompletion;\n+    private TimeValue keepAlive;\n+    private final SearchRequest searchRequest;\n+\n+    /**\n+     * Creates a new request\n+     */\n+    public SubmitAsyncSearchRequest(SearchSourceBuilder source, String... indices) {\n+        this.searchRequest = new SearchRequest(indices, source);\n+        searchRequest.setCcsMinimizeRoundtrips(DEFAULT_CCS_MINIMIZE_ROUNDTRIPS);\n+        searchRequest.setPreFilterShardSize(DEFAULT_PRE_FILTER_SHARD_SIZE);\n+        searchRequest.setBatchedReduceSize(DEFAULT_BATCHED_REDUCE_SIZE);\n+        searchRequest.requestCache(DEFAULT_REQUEST_CACHE_VALUE);\n+    }\n+\n+\n+//    /**\n+//     * Get the {@link SearchRequest} that this submit request wraps\n+//     */\n+//    public SearchRequest getSearchRequest() {\n+//        return searchRequest;\n+//    }\n+\n+    /**\n+     * Get the target indices\n+     */\n+    public String[] getIndices() {\n+        return this.searchRequest.indices();\n+    }\n+\n+\n+    /**\n+     * Get the minimum time that the request should wait before returning a partial result (defaults to 1 second).\n+     */\n+    public TimeValue getWaitForCompletion() {\n+        return waitForCompletion;\n+    }\n+\n+    /**\n+     * Sets the minimum time that the request should wait before returning a partial result (defaults to 1 second).\n+     */\n+    public void setWaitForCompletion(TimeValue waitForCompletion) {\n+        this.waitForCompletion = waitForCompletion;\n+    }\n+\n+    /**\n+     * Returns whether the resource resource should be removed on completion or failure (defaults to true).\n+     */\n+    public Boolean isCleanOnCompletion() {\n+        return cleanOnCompletion;\n+    }\n+\n+    /**\n+     * Determines if the resource should be removed on completion or failure (defaults to true).\n+     */\n+    public void setCleanOnCompletion(boolean cleanOnCompletion) {\n+        this.cleanOnCompletion = cleanOnCompletion;\n+    }\n+\n+    /**\n+     * Get the amount of time after which the result will expire (defaults to 5 days).\n+     */\n+    public TimeValue getKeepAlive() {\n+        return keepAlive;\n+    }\n+\n+    /**\n+     * Sets the amount of time after which the result will expire (defaults to 5 days).\n+     */\n+    public void setKeepAlive(TimeValue keepAlive) {\n+        this.keepAlive = keepAlive;\n+    }\n+\n+    // setters for request parameters of the wrapped SearchRequest\n+    /**\n+     * Set the routing value to control the shards that the search will be executed on.\n+     * A comma separated list of routing values to control the shards the search will be executed on.\n+     */\n+    public void setRouting(String routing) {\n+        this.searchRequest.routing(routing);\n+    }\n+\n+    /**\n+     * Set the routing values to control the shards that the search will be executed on.\n+     */\n+    public void setRoutings(String... routings) {\n+        this.searchRequest.routing(routings);\n+    }\n+\n+    /**\n+     * Get the routing value to control the shards that the search will be executed on.\n+     */\n+    public String getRouting() {\n+        return this.searchRequest.routing();\n+    }\n+\n+    /**\n+     * Sets the preference to execute the search. Defaults to randomize across shards. Can be set to\n+     * {@code _local} to prefer local shards or a custom value, which guarantees that the same order\n+     * will be used across different requests.\n+     */\n+    public void setPreference(String preference) {\n+        this.searchRequest.preference(preference);\n+    }\n+\n+    /**\n+     * Get the preference to execute the search.\n+     */\n+    public String getPreference() {\n+        return this.searchRequest.preference();\n+    }\n+\n+    /**\n+     * Specifies what type of requested indices to ignore and how to deal with indices wildcard expressions.\n+     */\n+    public void setIndicesOptions(IndicesOptions indicesOptions) {\n+        this.searchRequest.indicesOptions(indicesOptions);\n+    }\n+\n+    /**\n+     * Get the indices Options.\n+     */\n+    public IndicesOptions getIndicesOptions() {\n+        return this.searchRequest.indicesOptions();\n+    }\n+\n+    /**\n+     * The search type to execute, defaults to {@link SearchType#DEFAULT}.\n+     */\n+    public void setSearchType(SearchType searchType) {\n+        this.searchRequest.searchType(searchType);\n+    }\n+\n+    /**\n+     * Get the search type to execute, defaults to {@link SearchType#DEFAULT}.\n+     */\n+    public SearchType getSearchType() {\n+        return this.searchRequest.searchType();\n+    }\n+\n+    /**\n+     * Sets if this request should allow partial results. (If method is not called,\n+     * will default to the cluster level setting).\n+     */\n+    public void setAllowPartialSearchResults(boolean allowPartialSearchResults) {\n+        this.searchRequest.allowPartialSearchResults(allowPartialSearchResults);\n+    }\n+\n+    /**\n+     * Gets if this request should allow partial results.\n+     */\n+    public Boolean getAllowPartialSearchResults() {\n+        return this.searchRequest.allowPartialSearchResults();\n+    }\n+\n+    /**\n+     * Sets the number of shard results that should be reduced at once on the coordinating node. This value should be used as a protection\n+     * mechanism to reduce the memory overhead per search request if the potential number of shards in the request can be large.\n+     */\n+    public void setBatchedReduceSize(int batchedReduceSize) {\n+        this.searchRequest.setBatchedReduceSize(batchedReduceSize);\n+    }\n+\n+    /**\n+     * Gets the number of shard results that should be reduced at once on the coordinating node.\n+     * This defaults to 5 for {@link SubmitAsyncSearchRequest}.\n+     */\n+    public int getBatchedReduceSize() {\n+        return this.searchRequest.getBatchedReduceSize();\n+    }\n+\n+    /**\n+     * Sets if this request should use the request cache or not, assuming that it can (for\n+     * example, if \"now\" is used, it will never be cached). By default (not set, or null,\n+     * will default to the index level setting if request cache is enabled or not).\n+     */\n+    public void setRequestCache(Boolean requestCache) {\n+        this.searchRequest.requestCache(requestCache);\n+    }\n+\n+    /**\n+     * Gets if this request should use the request cache or not.\n+     * Defaults to `true` for {@link SubmitAsyncSearchRequest}.\n+     */\n+    public Boolean getRequestCache() {\n+        return this.searchRequest.requestCache();\n+    }\n+\n+    /**\n+     * Gets if the source of the {@link SearchSourceBuilder} initially used on this request.\n+     */\n+    public SearchSourceBuilder getSearchSource() {\n+        return this.searchRequest.source();\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e5a33fe9da0332a480ed5de7c6b3d1dfdf4b851"}, "originalPosition": 240}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQzMTAxNQ==", "bodyText": "how about maxConcurrentShardRequests? Was it left out on purpose?", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394431015", "createdAt": "2020-03-18T15:23:49Z", "author": {"login": "javanna"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchType;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.client.Validatable;\n+import org.elasticsearch.client.ValidationException;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+/**\n+ * A request to track asynchronously the progress of a search against one or more indices.\n+ */\n+public class SubmitAsyncSearchRequest implements Validatable {\n+\n+    public static final int DEFAULT_PRE_FILTER_SHARD_SIZE = 1;\n+    public static final int DEFAULT_BATCHED_REDUCE_SIZE = 5;\n+    public static final boolean DEFAULT_CCS_MINIMIZE_ROUNDTRIPS = false;\n+    public static final boolean DEFAULT_REQUEST_CACHE_VALUE = true;\n+\n+    public static long MIN_KEEP_ALIVE = TimeValue.timeValueMinutes(1).millis();\n+\n+    private TimeValue waitForCompletion;\n+    private Boolean cleanOnCompletion;\n+    private TimeValue keepAlive;\n+    private final SearchRequest searchRequest;\n+\n+    /**\n+     * Creates a new request\n+     */\n+    public SubmitAsyncSearchRequest(SearchSourceBuilder source, String... indices) {\n+        this.searchRequest = new SearchRequest(indices, source);\n+        searchRequest.setCcsMinimizeRoundtrips(DEFAULT_CCS_MINIMIZE_ROUNDTRIPS);\n+        searchRequest.setPreFilterShardSize(DEFAULT_PRE_FILTER_SHARD_SIZE);\n+        searchRequest.setBatchedReduceSize(DEFAULT_BATCHED_REDUCE_SIZE);\n+        searchRequest.requestCache(DEFAULT_REQUEST_CACHE_VALUE);\n+    }\n+\n+\n+//    /**\n+//     * Get the {@link SearchRequest} that this submit request wraps\n+//     */\n+//    public SearchRequest getSearchRequest() {\n+//        return searchRequest;\n+//    }\n+\n+    /**\n+     * Get the target indices\n+     */\n+    public String[] getIndices() {\n+        return this.searchRequest.indices();\n+    }\n+\n+\n+    /**\n+     * Get the minimum time that the request should wait before returning a partial result (defaults to 1 second).\n+     */\n+    public TimeValue getWaitForCompletion() {\n+        return waitForCompletion;\n+    }\n+\n+    /**\n+     * Sets the minimum time that the request should wait before returning a partial result (defaults to 1 second).\n+     */\n+    public void setWaitForCompletion(TimeValue waitForCompletion) {\n+        this.waitForCompletion = waitForCompletion;\n+    }\n+\n+    /**\n+     * Returns whether the resource resource should be removed on completion or failure (defaults to true).\n+     */\n+    public Boolean isCleanOnCompletion() {\n+        return cleanOnCompletion;\n+    }\n+\n+    /**\n+     * Determines if the resource should be removed on completion or failure (defaults to true).\n+     */\n+    public void setCleanOnCompletion(boolean cleanOnCompletion) {\n+        this.cleanOnCompletion = cleanOnCompletion;\n+    }\n+\n+    /**\n+     * Get the amount of time after which the result will expire (defaults to 5 days).\n+     */\n+    public TimeValue getKeepAlive() {\n+        return keepAlive;\n+    }\n+\n+    /**\n+     * Sets the amount of time after which the result will expire (defaults to 5 days).\n+     */\n+    public void setKeepAlive(TimeValue keepAlive) {\n+        this.keepAlive = keepAlive;\n+    }\n+\n+    // setters for request parameters of the wrapped SearchRequest\n+    /**\n+     * Set the routing value to control the shards that the search will be executed on.\n+     * A comma separated list of routing values to control the shards the search will be executed on.\n+     */\n+    public void setRouting(String routing) {\n+        this.searchRequest.routing(routing);\n+    }\n+\n+    /**\n+     * Set the routing values to control the shards that the search will be executed on.\n+     */\n+    public void setRoutings(String... routings) {\n+        this.searchRequest.routing(routings);\n+    }\n+\n+    /**\n+     * Get the routing value to control the shards that the search will be executed on.\n+     */\n+    public String getRouting() {\n+        return this.searchRequest.routing();\n+    }\n+\n+    /**\n+     * Sets the preference to execute the search. Defaults to randomize across shards. Can be set to\n+     * {@code _local} to prefer local shards or a custom value, which guarantees that the same order\n+     * will be used across different requests.\n+     */\n+    public void setPreference(String preference) {\n+        this.searchRequest.preference(preference);\n+    }\n+\n+    /**\n+     * Get the preference to execute the search.\n+     */\n+    public String getPreference() {\n+        return this.searchRequest.preference();\n+    }\n+\n+    /**\n+     * Specifies what type of requested indices to ignore and how to deal with indices wildcard expressions.\n+     */\n+    public void setIndicesOptions(IndicesOptions indicesOptions) {\n+        this.searchRequest.indicesOptions(indicesOptions);\n+    }\n+\n+    /**\n+     * Get the indices Options.\n+     */\n+    public IndicesOptions getIndicesOptions() {\n+        return this.searchRequest.indicesOptions();\n+    }\n+\n+    /**\n+     * The search type to execute, defaults to {@link SearchType#DEFAULT}.\n+     */\n+    public void setSearchType(SearchType searchType) {\n+        this.searchRequest.searchType(searchType);\n+    }\n+\n+    /**\n+     * Get the search type to execute, defaults to {@link SearchType#DEFAULT}.\n+     */\n+    public SearchType getSearchType() {\n+        return this.searchRequest.searchType();\n+    }\n+\n+    /**\n+     * Sets if this request should allow partial results. (If method is not called,\n+     * will default to the cluster level setting).\n+     */\n+    public void setAllowPartialSearchResults(boolean allowPartialSearchResults) {\n+        this.searchRequest.allowPartialSearchResults(allowPartialSearchResults);\n+    }\n+\n+    /**\n+     * Gets if this request should allow partial results.\n+     */\n+    public Boolean getAllowPartialSearchResults() {\n+        return this.searchRequest.allowPartialSearchResults();\n+    }\n+\n+    /**\n+     * Sets the number of shard results that should be reduced at once on the coordinating node. This value should be used as a protection\n+     * mechanism to reduce the memory overhead per search request if the potential number of shards in the request can be large.\n+     */\n+    public void setBatchedReduceSize(int batchedReduceSize) {\n+        this.searchRequest.setBatchedReduceSize(batchedReduceSize);\n+    }\n+\n+    /**\n+     * Gets the number of shard results that should be reduced at once on the coordinating node.\n+     * This defaults to 5 for {@link SubmitAsyncSearchRequest}.\n+     */\n+    public int getBatchedReduceSize() {\n+        return this.searchRequest.getBatchedReduceSize();\n+    }\n+\n+    /**\n+     * Sets if this request should use the request cache or not, assuming that it can (for\n+     * example, if \"now\" is used, it will never be cached). By default (not set, or null,\n+     * will default to the index level setting if request cache is enabled or not).\n+     */\n+    public void setRequestCache(Boolean requestCache) {\n+        this.searchRequest.requestCache(requestCache);\n+    }\n+\n+    /**\n+     * Gets if this request should use the request cache or not.\n+     * Defaults to `true` for {@link SubmitAsyncSearchRequest}.\n+     */\n+    public Boolean getRequestCache() {\n+        return this.searchRequest.requestCache();\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e5a33fe9da0332a480ed5de7c6b3d1dfdf4b851"}, "originalPosition": 233}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQzMjU0NQ==", "bodyText": "some of these checks become redundant once the search request is hidden. Are we going to be able to remove the getter for the search request, or will it be package protected? I guess that will play a role in whether these values are at least theoretically settable from the same package, or not at all.", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394432545", "createdAt": "2020-03-18T15:25:58Z", "author": {"login": "javanna"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/SubmitAsyncSearchRequest.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchType;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.client.Validatable;\n+import org.elasticsearch.client.ValidationException;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+/**\n+ * A request to track asynchronously the progress of a search against one or more indices.\n+ */\n+public class SubmitAsyncSearchRequest implements Validatable {\n+\n+    public static final int DEFAULT_PRE_FILTER_SHARD_SIZE = 1;\n+    public static final int DEFAULT_BATCHED_REDUCE_SIZE = 5;\n+    public static final boolean DEFAULT_CCS_MINIMIZE_ROUNDTRIPS = false;\n+    public static final boolean DEFAULT_REQUEST_CACHE_VALUE = true;\n+\n+    public static long MIN_KEEP_ALIVE = TimeValue.timeValueMinutes(1).millis();\n+\n+    private TimeValue waitForCompletion;\n+    private Boolean cleanOnCompletion;\n+    private TimeValue keepAlive;\n+    private final SearchRequest searchRequest;\n+\n+    /**\n+     * Creates a new request\n+     */\n+    public SubmitAsyncSearchRequest(SearchSourceBuilder source, String... indices) {\n+        this.searchRequest = new SearchRequest(indices, source);\n+        searchRequest.setCcsMinimizeRoundtrips(DEFAULT_CCS_MINIMIZE_ROUNDTRIPS);\n+        searchRequest.setPreFilterShardSize(DEFAULT_PRE_FILTER_SHARD_SIZE);\n+        searchRequest.setBatchedReduceSize(DEFAULT_BATCHED_REDUCE_SIZE);\n+        searchRequest.requestCache(DEFAULT_REQUEST_CACHE_VALUE);\n+    }\n+\n+\n+//    /**\n+//     * Get the {@link SearchRequest} that this submit request wraps\n+//     */\n+//    public SearchRequest getSearchRequest() {\n+//        return searchRequest;\n+//    }\n+\n+    /**\n+     * Get the target indices\n+     */\n+    public String[] getIndices() {\n+        return this.searchRequest.indices();\n+    }\n+\n+\n+    /**\n+     * Get the minimum time that the request should wait before returning a partial result (defaults to 1 second).\n+     */\n+    public TimeValue getWaitForCompletion() {\n+        return waitForCompletion;\n+    }\n+\n+    /**\n+     * Sets the minimum time that the request should wait before returning a partial result (defaults to 1 second).\n+     */\n+    public void setWaitForCompletion(TimeValue waitForCompletion) {\n+        this.waitForCompletion = waitForCompletion;\n+    }\n+\n+    /**\n+     * Returns whether the resource resource should be removed on completion or failure (defaults to true).\n+     */\n+    public Boolean isCleanOnCompletion() {\n+        return cleanOnCompletion;\n+    }\n+\n+    /**\n+     * Determines if the resource should be removed on completion or failure (defaults to true).\n+     */\n+    public void setCleanOnCompletion(boolean cleanOnCompletion) {\n+        this.cleanOnCompletion = cleanOnCompletion;\n+    }\n+\n+    /**\n+     * Get the amount of time after which the result will expire (defaults to 5 days).\n+     */\n+    public TimeValue getKeepAlive() {\n+        return keepAlive;\n+    }\n+\n+    /**\n+     * Sets the amount of time after which the result will expire (defaults to 5 days).\n+     */\n+    public void setKeepAlive(TimeValue keepAlive) {\n+        this.keepAlive = keepAlive;\n+    }\n+\n+    // setters for request parameters of the wrapped SearchRequest\n+    /**\n+     * Set the routing value to control the shards that the search will be executed on.\n+     * A comma separated list of routing values to control the shards the search will be executed on.\n+     */\n+    public void setRouting(String routing) {\n+        this.searchRequest.routing(routing);\n+    }\n+\n+    /**\n+     * Set the routing values to control the shards that the search will be executed on.\n+     */\n+    public void setRoutings(String... routings) {\n+        this.searchRequest.routing(routings);\n+    }\n+\n+    /**\n+     * Get the routing value to control the shards that the search will be executed on.\n+     */\n+    public String getRouting() {\n+        return this.searchRequest.routing();\n+    }\n+\n+    /**\n+     * Sets the preference to execute the search. Defaults to randomize across shards. Can be set to\n+     * {@code _local} to prefer local shards or a custom value, which guarantees that the same order\n+     * will be used across different requests.\n+     */\n+    public void setPreference(String preference) {\n+        this.searchRequest.preference(preference);\n+    }\n+\n+    /**\n+     * Get the preference to execute the search.\n+     */\n+    public String getPreference() {\n+        return this.searchRequest.preference();\n+    }\n+\n+    /**\n+     * Specifies what type of requested indices to ignore and how to deal with indices wildcard expressions.\n+     */\n+    public void setIndicesOptions(IndicesOptions indicesOptions) {\n+        this.searchRequest.indicesOptions(indicesOptions);\n+    }\n+\n+    /**\n+     * Get the indices Options.\n+     */\n+    public IndicesOptions getIndicesOptions() {\n+        return this.searchRequest.indicesOptions();\n+    }\n+\n+    /**\n+     * The search type to execute, defaults to {@link SearchType#DEFAULT}.\n+     */\n+    public void setSearchType(SearchType searchType) {\n+        this.searchRequest.searchType(searchType);\n+    }\n+\n+    /**\n+     * Get the search type to execute, defaults to {@link SearchType#DEFAULT}.\n+     */\n+    public SearchType getSearchType() {\n+        return this.searchRequest.searchType();\n+    }\n+\n+    /**\n+     * Sets if this request should allow partial results. (If method is not called,\n+     * will default to the cluster level setting).\n+     */\n+    public void setAllowPartialSearchResults(boolean allowPartialSearchResults) {\n+        this.searchRequest.allowPartialSearchResults(allowPartialSearchResults);\n+    }\n+\n+    /**\n+     * Gets if this request should allow partial results.\n+     */\n+    public Boolean getAllowPartialSearchResults() {\n+        return this.searchRequest.allowPartialSearchResults();\n+    }\n+\n+    /**\n+     * Sets the number of shard results that should be reduced at once on the coordinating node. This value should be used as a protection\n+     * mechanism to reduce the memory overhead per search request if the potential number of shards in the request can be large.\n+     */\n+    public void setBatchedReduceSize(int batchedReduceSize) {\n+        this.searchRequest.setBatchedReduceSize(batchedReduceSize);\n+    }\n+\n+    /**\n+     * Gets the number of shard results that should be reduced at once on the coordinating node.\n+     * This defaults to 5 for {@link SubmitAsyncSearchRequest}.\n+     */\n+    public int getBatchedReduceSize() {\n+        return this.searchRequest.getBatchedReduceSize();\n+    }\n+\n+    /**\n+     * Sets if this request should use the request cache or not, assuming that it can (for\n+     * example, if \"now\" is used, it will never be cached). By default (not set, or null,\n+     * will default to the index level setting if request cache is enabled or not).\n+     */\n+    public void setRequestCache(Boolean requestCache) {\n+        this.searchRequest.requestCache(requestCache);\n+    }\n+\n+    /**\n+     * Gets if this request should use the request cache or not.\n+     * Defaults to `true` for {@link SubmitAsyncSearchRequest}.\n+     */\n+    public Boolean getRequestCache() {\n+        return this.searchRequest.requestCache();\n+    }\n+\n+    /**\n+     * Gets if the source of the {@link SearchSourceBuilder} initially used on this request.\n+     */\n+    public SearchSourceBuilder getSearchSource() {\n+        return this.searchRequest.source();\n+    }\n+\n+    @Override\n+    public Optional<ValidationException> validate() {\n+        final ValidationException validationException = new ValidationException();\n+        if (searchRequest.scroll() != null) {\n+            validationException.addValidationError(\"[scroll] queries are not supported\");\n+        }\n+        if (searchRequest.isSuggestOnly()) {\n+            validationException.addValidationError(\"suggest-only queries are not supported\");\n+        }\n+        if (searchRequest.isCcsMinimizeRoundtrips()) {\n+            validationException.addValidationError(\"[ccs_minimize_roundtrips] is not supported on async search queries\");\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e5a33fe9da0332a480ed5de7c6b3d1dfdf4b851"}, "originalPosition": 253}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQzMzczNg==", "bodyText": "should this be there given that we don't allow to set it directly and we support only one value for it?", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394433736", "createdAt": "2020-03-18T15:27:29Z", "author": {"login": "javanna"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/AsyncSearchRequestConverters.java", "diffHunk": "@@ -56,4 +55,21 @@ static Request submitAsyncSearch(SubmitAsyncSearchRequest asyncSearchRequest) th\n         request.addParameters(params.asMap());\n         return request;\n     }\n+\n+    static void addSearchRequestParams(Params params, SubmitAsyncSearchRequest request) {\n+        params.putParam(RestSearchAction.TYPED_KEYS_PARAM, \"true\");\n+        params.withRouting(request.getRouting());\n+        params.withPreference(request.getPreference());\n+        params.withIndicesOptions(request.getIndicesOptions());\n+        params.putParam(\"search_type\", request.getSearchType().name().toLowerCase(Locale.ROOT));\n+        if (request.getRequestCache() != null) {\n+            params.putParam(\"request_cache\", Boolean.toString(request.getRequestCache()));\n+        }\n+        if (request.getAllowPartialSearchResults() != null) {\n+            params.putParam(\"allow_partial_search_results\", Boolean.toString(request.getAllowPartialSearchResults()));\n+        }\n+        params.putParam(\"batched_reduce_size\", Integer.toString(request.getBatchedReduceSize()));\n+        params.putParam(\"pre_filter_shard_size\", Integer.toString(SubmitAsyncSearchRequest.DEFAULT_PRE_FILTER_SHARD_SIZE));\n+        params.putParam(\"ccs_minimize_roundtrips\", Boolean.toString(SubmitAsyncSearchRequest.DEFAULT_CCS_MINIMIZE_ROUNDTRIPS));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e5a33fe9da0332a480ed5de7c6b3d1dfdf4b851"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQzNDE2Ng==", "bodyText": "I think we can remove it. it is not in the spec and we don't allow to set it directly", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394434166", "createdAt": "2020-03-18T15:28:04Z", "author": {"login": "javanna"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/AsyncSearchRequestConverters.java", "diffHunk": "@@ -56,4 +55,21 @@ static Request submitAsyncSearch(SubmitAsyncSearchRequest asyncSearchRequest) th\n         request.addParameters(params.asMap());\n         return request;\n     }\n+\n+    static void addSearchRequestParams(Params params, SubmitAsyncSearchRequest request) {\n+        params.putParam(RestSearchAction.TYPED_KEYS_PARAM, \"true\");\n+        params.withRouting(request.getRouting());\n+        params.withPreference(request.getPreference());\n+        params.withIndicesOptions(request.getIndicesOptions());\n+        params.putParam(\"search_type\", request.getSearchType().name().toLowerCase(Locale.ROOT));\n+        if (request.getRequestCache() != null) {\n+            params.putParam(\"request_cache\", Boolean.toString(request.getRequestCache()));\n+        }\n+        if (request.getAllowPartialSearchResults() != null) {\n+            params.putParam(\"allow_partial_search_results\", Boolean.toString(request.getAllowPartialSearchResults()));\n+        }\n+        params.putParam(\"batched_reduce_size\", Integer.toString(request.getBatchedReduceSize()));\n+        params.putParam(\"pre_filter_shard_size\", Integer.toString(SubmitAsyncSearchRequest.DEFAULT_PRE_FILTER_SHARD_SIZE));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e5a33fe9da0332a480ed5de7c6b3d1dfdf4b851"}, "originalPosition": 53}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "594a5eb68b4c26925bbde16776dfa4b4b9b2b7b0", "author": {"user": {"login": "cbuescher", "name": "Christoph B\u00fcscher"}}, "url": "https://github.com/elastic/elasticsearch/commit/594a5eb68b4c26925bbde16776dfa4b4b9b2b7b0", "committedDate": "2020-03-18T15:55:14Z", "message": "Remove redundant parameters and validation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f686a5081f0a2489c32eae027c0b7817c18f0884", "author": {"user": {"login": "cbuescher", "name": "Christoph B\u00fcscher"}}, "url": "https://github.com/elastic/elasticsearch/commit/f686a5081f0a2489c32eae027c0b7817c18f0884", "committedDate": "2020-03-18T16:40:29Z", "message": "Avoid additional boilerplate getters on SubmitAsyncSearchRequest by making getSearchRequest() package private"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1d301c47d871a9bcc43907eb861e4c0fb4b7353d", "author": {"user": {"login": "cbuescher", "name": "Christoph B\u00fcscher"}}, "url": "https://github.com/elastic/elasticsearch/commit/1d301c47d871a9bcc43907eb861e4c0fb4b7353d", "committedDate": "2020-03-18T18:10:45Z", "message": "Add unsupported parameters to HLRC search request\n\nCurrently we don't send values for the `pre_filter_shard_size` and\n`max_concurrent_shard_requests` SearchRequest parameters over http when using\nthe High Level Rest Client. This change adds these parameters to the\nRequestConverters and tests."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4ab7dc78477bb8752fcc899aac12f31d3f1049f8", "author": {"user": {"login": "cbuescher", "name": "Christoph B\u00fcscher"}}, "url": "https://github.com/elastic/elasticsearch/commit/4ab7dc78477bb8752fcc899aac12f31d3f1049f8", "committedDate": "2020-03-18T18:13:35Z", "message": "Revert \"Avoid additional boilerplate getters on SubmitAsyncSearchRequest by making getSearchRequest() package private\"\n\nThis reverts commit f686a5081f0a2489c32eae027c0b7817c18f0884."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "720c966dc4aa7b54a083c18b7fa79b8d12452964", "author": {"user": {"login": "cbuescher", "name": "Christoph B\u00fcscher"}}, "url": "https://github.com/elastic/elasticsearch/commit/720c966dc4aa7b54a083c18b7fa79b8d12452964", "committedDate": "2020-03-18T18:24:21Z", "message": "Add support for max_concurrent_shard_requests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "220e6a89f0600570717081089cba70acf412c3c4", "author": {"user": {"login": "cbuescher", "name": "Christoph B\u00fcscher"}}, "url": "https://github.com/elastic/elasticsearch/commit/220e6a89f0600570717081089cba70acf412c3c4", "committedDate": "2020-03-18T20:30:28Z", "message": "Merge branch 'master' into async-search-hlrc"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc3MzAwNDA5", "url": "https://github.com/elastic/elasticsearch/pull/53592#pullrequestreview-377300409", "createdAt": "2020-03-18T23:14:04Z", "commit": {"oid": "220e6a89f0600570717081089cba70acf412c3c4"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQyMzoxNDowNFrOF4aDwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQyMzoxNTowMFrOF4aE8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY5MTUyMg==", "bodyText": "docs link should be https://www.elastic.co/guide/en/elasticsearch/reference/current/async-search.html PR is open but not merged yet: #53675", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394691522", "createdAt": "2020-03-18T23:14:04Z", "author": {"login": "javanna"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/AsyncSearchClient.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.client;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.client.asyncsearch.SubmitAsyncSearchRequest;\n+import org.elasticsearch.client.asyncsearch.AsyncSearchResponse;\n+\n+import java.io.IOException;\n+\n+import static java.util.Collections.emptySet;\n+\n+public class AsyncSearchClient {\n+    private final RestHighLevelClient restHighLevelClient;\n+\n+    AsyncSearchClient(RestHighLevelClient restHighLevelClient) {\n+        this.restHighLevelClient = restHighLevelClient;\n+    }\n+\n+    // TODO add docs url", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "220e6a89f0600570717081089cba70acf412c3c4"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY5MTgyNQ==", "bodyText": "nit: maybe given they are now used in two places we could add the with* methods for these params too?", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394691825", "createdAt": "2020-03-18T23:15:00Z", "author": {"login": "javanna"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/AsyncSearchRequestConverters.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.client;\n+\n+import org.apache.http.client.methods.HttpPost;\n+import org.elasticsearch.client.RequestConverters.Params;\n+import org.elasticsearch.client.asyncsearch.SubmitAsyncSearchRequest;\n+import org.elasticsearch.rest.action.search.RestSearchAction;\n+\n+import java.io.IOException;\n+import java.util.Locale;\n+\n+import static org.elasticsearch.client.RequestConverters.REQUEST_BODY_CONTENT_TYPE;\n+\n+final class AsyncSearchRequestConverters {\n+\n+    static Request submitAsyncSearch(SubmitAsyncSearchRequest asyncSearchRequest) throws IOException {\n+        String endpoint = new RequestConverters.EndpointBuilder().addCommaSeparatedPathParts(\n+                asyncSearchRequest.getIndices())\n+                .addPathPartAsIs(\"_async_search\").build();\n+        Request request = new Request(HttpPost.METHOD_NAME, endpoint);\n+        Params params = new RequestConverters.Params();\n+        // add all typical search params and search request source as body\n+        addSearchRequestParams(params, asyncSearchRequest);\n+        if (asyncSearchRequest.getSearchSource() != null) {\n+            request.setEntity(RequestConverters.createEntity(asyncSearchRequest.getSearchSource(), REQUEST_BODY_CONTENT_TYPE));\n+        }\n+        // set async search submit specific parameters\n+        if (asyncSearchRequest.isCleanOnCompletion() != null) {\n+            params.putParam(\"clean_on_completion\", asyncSearchRequest.isCleanOnCompletion().toString());\n+        }\n+        if (asyncSearchRequest.getKeepAlive() != null) {\n+            params.putParam(\"keep_alive\", asyncSearchRequest.getKeepAlive().getStringRep());\n+        }\n+        if (asyncSearchRequest.getWaitForCompletion() != null) {\n+            params.putParam(\"wait_for_completion\", asyncSearchRequest.getWaitForCompletion().getStringRep());\n+        }\n+        request.addParameters(params.asMap());\n+        return request;\n+    }\n+\n+    static void addSearchRequestParams(Params params, SubmitAsyncSearchRequest request) {\n+        params.putParam(RestSearchAction.TYPED_KEYS_PARAM, \"true\");\n+        params.withRouting(request.getRouting());\n+        params.withPreference(request.getPreference());\n+        params.withIndicesOptions(request.getIndicesOptions());\n+        params.putParam(\"search_type\", request.getSearchType().name().toLowerCase(Locale.ROOT));\n+        params.putParam(\"max_concurrent_shard_requests\", Integer.toString(request.getMaxConcurrentShardRequests()));\n+        if (request.getRequestCache() != null) {\n+            params.putParam(\"request_cache\", Boolean.toString(request.getRequestCache()));\n+        }\n+        if (request.getAllowPartialSearchResults() != null) {\n+            params.putParam(\"allow_partial_search_results\", Boolean.toString(request.getAllowPartialSearchResults()));\n+        }\n+        params.putParam(\"batched_reduce_size\", Integer.toString(request.getBatchedReduceSize()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "220e6a89f0600570717081089cba70acf412c3c4"}, "originalPosition": 72}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1d0b59c406bea3b1a621e5108187922680afcc37", "author": {"user": {"login": "cbuescher", "name": "Christoph B\u00fcscher"}}, "url": "https://github.com/elastic/elasticsearch/commit/1d0b59c406bea3b1a621e5108187922680afcc37", "committedDate": "2020-03-19T09:08:55Z", "message": "Merge branch 'master' into async-search-hlrc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ebd19061c1d5f00e8a54de372ea294ed6da6b54d", "author": {"user": {"login": "cbuescher", "name": "Christoph B\u00fcscher"}}, "url": "https://github.com/elastic/elasticsearch/commit/ebd19061c1d5f00e8a54de372ea294ed6da6b54d", "committedDate": "2020-03-19T09:24:57Z", "message": "Add docs urls"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f65cf820d03d64096d506b95d412f03a26db9c68", "author": {"user": {"login": "cbuescher", "name": "Christoph B\u00fcscher"}}, "url": "https://github.com/elastic/elasticsearch/commit/f65cf820d03d64096d506b95d412f03a26db9c68", "committedDate": "2020-03-19T09:49:28Z", "message": "Unify conversion of some request parameters"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc3NTc4NzYy", "url": "https://github.com/elastic/elasticsearch/pull/53592#pullrequestreview-377578762", "createdAt": "2020-03-19T10:08:53Z", "commit": {"oid": "f65cf820d03d64096d506b95d412f03a26db9c68"}, "state": "APPROVED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxMDowODo1M1rOF4nvYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxMDoxMjo0MlrOF4n3_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDkxNTY4Mg==", "bodyText": "nit: rename to  withAllowPartialResults ?", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394915682", "createdAt": "2020-03-19T10:08:53Z", "author": {"login": "jimczi"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/RequestConverters.java", "diffHunk": "@@ -860,6 +860,26 @@ Params withPreference(String preference) {\n             return putParam(\"preference\", preference);\n         }\n \n+        Params withSearchType(String searchType) {\n+            return putParam(\"search_type\", searchType);\n+        }\n+\n+        Params withMaxConcurrentShardRequests(int maxConcurrentShardRequests) {\n+            return putParam(\"max_concurrent_shard_requests\", Integer.toString(maxConcurrentShardRequests));\n+        }\n+\n+        Params withBatchedReduceSize(int batchedReduceSize) {\n+            return putParam(\"batched_reduce_size\", Integer.toString(batchedReduceSize));\n+        }\n+\n+        Params withRequestCache(boolean requestCache) {\n+            return putParam(\"request_cache\", Boolean.toString(requestCache));\n+        }\n+\n+        Params withPartialResults(boolean allowPartialSearchResults) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f65cf820d03d64096d506b95d412f03a26db9c68"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDkxNjMyMw==", "bodyText": "Why can't this be a constructor arg ?", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394916323", "createdAt": "2020-03-19T10:10:07Z", "author": {"login": "jimczi"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/AsyncSearchResponse.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentParser.Token;\n+\n+import java.io.IOException;\n+\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+/**\n+ * A response of an async search request.\n+ */\n+public class AsyncSearchResponse implements ToXContentObject  {\n+    @Nullable\n+    private String id;\n+    private final int version;\n+    @Nullable\n+    private SearchResponse searchResponse;\n+    @Nullable\n+    private ElasticsearchException error;\n+    private final boolean isRunning;\n+    private final boolean isPartial;\n+\n+    private final long startTimeMillis;\n+    private final long expirationTimeMillis;\n+\n+    /**\n+     * Creates an {@link AsyncSearchResponse} with the arguments that are always present in the server response\n+     */\n+    AsyncSearchResponse(int version,\n+                               boolean isPartial,\n+                               boolean isRunning,\n+                               long startTimeMillis,\n+                               long expirationTimeMillis) {\n+        this.version = version;\n+        this.isPartial = isPartial;\n+        this.isRunning = isRunning;\n+        this.startTimeMillis = startTimeMillis;\n+        this.expirationTimeMillis = expirationTimeMillis;\n+    }\n+\n+    /**\n+     * Returns the id of the async search request or null if the response is not stored in the cluster.\n+     */\n+    @Nullable\n+    public String getId() {\n+        return id;\n+    }\n+\n+    /**\n+     * Sets the optional id property, use by parser and tests\n+     */\n+    void setId(String id) {\n+        this.id = id;\n+    }\n+\n+    /**\n+     * Returns the version of this response.\n+     */\n+    public int getVersion() {\n+        return version;\n+    }\n+\n+    /**\n+     * Returns the current {@link SearchResponse} or <code>null</code> if not available.\n+     *\n+     * See {@link #isPartial()} to determine whether the response contains partial or complete\n+     * results.\n+     */\n+    public SearchResponse getSearchResponse() {\n+        return searchResponse;\n+    }\n+\n+    /**\n+     * Sets the optional search response property, used by parser and tests\n+     */\n+    void setSearchResponse(SearchResponse searchResponse) {\n+        this.searchResponse = searchResponse;\n+    }\n+\n+    /**\n+     * Returns the failure reason or null if the query is running or has completed normally.\n+     */\n+    public ElasticsearchException getFailure() {\n+        return error;\n+    }\n+\n+    /**\n+     * Sets the optional failure property, use by parser and tests\n+     */\n+    void setFailure(ElasticsearchException error) {\n+        this.error = error;\n+    }\n+\n+    /**\n+     * Returns <code>true</code> if the {@link SearchResponse} contains partial\n+     * results computed from a subset of the total shards.\n+     */\n+    public boolean isPartial() {\n+        return isPartial;\n+    }\n+\n+    /**\n+     * Whether the search is still running in the cluster.\n+     *\n+     * A value of <code>false</code> indicates that the response is final\n+     * even if {@link #isPartial()} returns <code>true</code>. In such case,\n+     * the partial response represents the status of the search before a\n+     * non-recoverable failure.\n+     */\n+    public boolean isRunning() {\n+        return isRunning;\n+    }\n+\n+    /**\n+     * When this response was created as a timestamp in milliseconds since epoch.\n+     */\n+    public long getStartTime() {\n+        return startTimeMillis;\n+    }\n+\n+    /**\n+     * When this response will expired as a timestamp in milliseconds since epoch.\n+     */\n+    public long getExpirationTime() {\n+        return expirationTimeMillis;\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject();\n+        if (id != null) {\n+            builder.field(\"id\", id);\n+        }\n+        builder.field(\"version\", version);\n+        builder.field(\"is_partial\", isPartial);\n+        builder.field(\"is_running\", isRunning);\n+        builder.field(\"start_time_in_millis\", startTimeMillis);\n+        builder.field(\"expiration_time_in_millis\", expirationTimeMillis);\n+\n+        if (searchResponse != null) {\n+            builder.field(\"response\");\n+            searchResponse.toXContent(builder, params);\n+        }\n+        if (error != null) {\n+            builder.startObject(\"error\");\n+            error.toXContent(builder, params);\n+            builder.endObject();\n+        }\n+        builder.endObject();\n+        return builder;\n+    }\n+\n+    public static final ParseField ID_FIELD = new ParseField(\"id\");\n+    public static final ParseField VERSION_FIELD = new ParseField(\"version\");\n+    public static final ParseField IS_PARTIAL_FIELD = new ParseField(\"is_partial\");\n+    public static final ParseField IS_RUNNING_FIELD = new ParseField(\"is_running\");\n+    public static final ParseField START_TIME_FIELD = new ParseField(\"start_time_in_millis\");\n+    public static final ParseField EXPIRATION_FIELD = new ParseField(\"expiration_time_in_millis\");\n+    public static final ParseField RESPONSE_FIELD = new ParseField(\"response\");\n+    public static final ParseField ERROR_FIELD = new ParseField(\"error\");\n+\n+    public static final ConstructingObjectParser<AsyncSearchResponse, Void> PARSER = new ConstructingObjectParser<>(\n+            \"submit_async_search_response\", true,\n+            args -> new AsyncSearchResponse(\n+                    (int) args[0],\n+                    (boolean) args[1],\n+                    (boolean) args[2],\n+                    (long) args[3],\n+                    (long) args[4]));\n+    static {\n+        PARSER.declareInt(ConstructingObjectParser.constructorArg(), VERSION_FIELD);\n+        PARSER.declareBoolean(ConstructingObjectParser.constructorArg(), IS_PARTIAL_FIELD);\n+        PARSER.declareBoolean(ConstructingObjectParser.constructorArg(), IS_RUNNING_FIELD);\n+        PARSER.declareLong(ConstructingObjectParser.constructorArg(), START_TIME_FIELD);\n+        PARSER.declareLong(ConstructingObjectParser.constructorArg(), EXPIRATION_FIELD);\n+        PARSER.declareString(AsyncSearchResponse::setId, ID_FIELD);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f65cf820d03d64096d506b95d412f03a26db9c68"}, "originalPosition": 203}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDkxNjQwMA==", "bodyText": "Same here ?", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394916400", "createdAt": "2020-03-19T10:10:15Z", "author": {"login": "jimczi"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/AsyncSearchResponse.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentParser.Token;\n+\n+import java.io.IOException;\n+\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+/**\n+ * A response of an async search request.\n+ */\n+public class AsyncSearchResponse implements ToXContentObject  {\n+    @Nullable\n+    private String id;\n+    private final int version;\n+    @Nullable\n+    private SearchResponse searchResponse;\n+    @Nullable\n+    private ElasticsearchException error;\n+    private final boolean isRunning;\n+    private final boolean isPartial;\n+\n+    private final long startTimeMillis;\n+    private final long expirationTimeMillis;\n+\n+    /**\n+     * Creates an {@link AsyncSearchResponse} with the arguments that are always present in the server response\n+     */\n+    AsyncSearchResponse(int version,\n+                               boolean isPartial,\n+                               boolean isRunning,\n+                               long startTimeMillis,\n+                               long expirationTimeMillis) {\n+        this.version = version;\n+        this.isPartial = isPartial;\n+        this.isRunning = isRunning;\n+        this.startTimeMillis = startTimeMillis;\n+        this.expirationTimeMillis = expirationTimeMillis;\n+    }\n+\n+    /**\n+     * Returns the id of the async search request or null if the response is not stored in the cluster.\n+     */\n+    @Nullable\n+    public String getId() {\n+        return id;\n+    }\n+\n+    /**\n+     * Sets the optional id property, use by parser and tests\n+     */\n+    void setId(String id) {\n+        this.id = id;\n+    }\n+\n+    /**\n+     * Returns the version of this response.\n+     */\n+    public int getVersion() {\n+        return version;\n+    }\n+\n+    /**\n+     * Returns the current {@link SearchResponse} or <code>null</code> if not available.\n+     *\n+     * See {@link #isPartial()} to determine whether the response contains partial or complete\n+     * results.\n+     */\n+    public SearchResponse getSearchResponse() {\n+        return searchResponse;\n+    }\n+\n+    /**\n+     * Sets the optional search response property, used by parser and tests\n+     */\n+    void setSearchResponse(SearchResponse searchResponse) {\n+        this.searchResponse = searchResponse;\n+    }\n+\n+    /**\n+     * Returns the failure reason or null if the query is running or has completed normally.\n+     */\n+    public ElasticsearchException getFailure() {\n+        return error;\n+    }\n+\n+    /**\n+     * Sets the optional failure property, use by parser and tests\n+     */\n+    void setFailure(ElasticsearchException error) {\n+        this.error = error;\n+    }\n+\n+    /**\n+     * Returns <code>true</code> if the {@link SearchResponse} contains partial\n+     * results computed from a subset of the total shards.\n+     */\n+    public boolean isPartial() {\n+        return isPartial;\n+    }\n+\n+    /**\n+     * Whether the search is still running in the cluster.\n+     *\n+     * A value of <code>false</code> indicates that the response is final\n+     * even if {@link #isPartial()} returns <code>true</code>. In such case,\n+     * the partial response represents the status of the search before a\n+     * non-recoverable failure.\n+     */\n+    public boolean isRunning() {\n+        return isRunning;\n+    }\n+\n+    /**\n+     * When this response was created as a timestamp in milliseconds since epoch.\n+     */\n+    public long getStartTime() {\n+        return startTimeMillis;\n+    }\n+\n+    /**\n+     * When this response will expired as a timestamp in milliseconds since epoch.\n+     */\n+    public long getExpirationTime() {\n+        return expirationTimeMillis;\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject();\n+        if (id != null) {\n+            builder.field(\"id\", id);\n+        }\n+        builder.field(\"version\", version);\n+        builder.field(\"is_partial\", isPartial);\n+        builder.field(\"is_running\", isRunning);\n+        builder.field(\"start_time_in_millis\", startTimeMillis);\n+        builder.field(\"expiration_time_in_millis\", expirationTimeMillis);\n+\n+        if (searchResponse != null) {\n+            builder.field(\"response\");\n+            searchResponse.toXContent(builder, params);\n+        }\n+        if (error != null) {\n+            builder.startObject(\"error\");\n+            error.toXContent(builder, params);\n+            builder.endObject();\n+        }\n+        builder.endObject();\n+        return builder;\n+    }\n+\n+    public static final ParseField ID_FIELD = new ParseField(\"id\");\n+    public static final ParseField VERSION_FIELD = new ParseField(\"version\");\n+    public static final ParseField IS_PARTIAL_FIELD = new ParseField(\"is_partial\");\n+    public static final ParseField IS_RUNNING_FIELD = new ParseField(\"is_running\");\n+    public static final ParseField START_TIME_FIELD = new ParseField(\"start_time_in_millis\");\n+    public static final ParseField EXPIRATION_FIELD = new ParseField(\"expiration_time_in_millis\");\n+    public static final ParseField RESPONSE_FIELD = new ParseField(\"response\");\n+    public static final ParseField ERROR_FIELD = new ParseField(\"error\");\n+\n+    public static final ConstructingObjectParser<AsyncSearchResponse, Void> PARSER = new ConstructingObjectParser<>(\n+            \"submit_async_search_response\", true,\n+            args -> new AsyncSearchResponse(\n+                    (int) args[0],\n+                    (boolean) args[1],\n+                    (boolean) args[2],\n+                    (long) args[3],\n+                    (long) args[4]));\n+    static {\n+        PARSER.declareInt(ConstructingObjectParser.constructorArg(), VERSION_FIELD);\n+        PARSER.declareBoolean(ConstructingObjectParser.constructorArg(), IS_PARTIAL_FIELD);\n+        PARSER.declareBoolean(ConstructingObjectParser.constructorArg(), IS_RUNNING_FIELD);\n+        PARSER.declareLong(ConstructingObjectParser.constructorArg(), START_TIME_FIELD);\n+        PARSER.declareLong(ConstructingObjectParser.constructorArg(), EXPIRATION_FIELD);\n+        PARSER.declareString(AsyncSearchResponse::setId, ID_FIELD);\n+        PARSER.declareObject(AsyncSearchResponse::setSearchResponse, (p, c) -> AsyncSearchResponse.parseSearchResponse(p),\n+                RESPONSE_FIELD);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f65cf820d03d64096d506b95d412f03a26db9c68"}, "originalPosition": 205}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDkxNjQ4Ng==", "bodyText": "And here ?", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394916486", "createdAt": "2020-03-19T10:10:23Z", "author": {"login": "jimczi"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/AsyncSearchResponse.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentParser.Token;\n+\n+import java.io.IOException;\n+\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+/**\n+ * A response of an async search request.\n+ */\n+public class AsyncSearchResponse implements ToXContentObject  {\n+    @Nullable\n+    private String id;\n+    private final int version;\n+    @Nullable\n+    private SearchResponse searchResponse;\n+    @Nullable\n+    private ElasticsearchException error;\n+    private final boolean isRunning;\n+    private final boolean isPartial;\n+\n+    private final long startTimeMillis;\n+    private final long expirationTimeMillis;\n+\n+    /**\n+     * Creates an {@link AsyncSearchResponse} with the arguments that are always present in the server response\n+     */\n+    AsyncSearchResponse(int version,\n+                               boolean isPartial,\n+                               boolean isRunning,\n+                               long startTimeMillis,\n+                               long expirationTimeMillis) {\n+        this.version = version;\n+        this.isPartial = isPartial;\n+        this.isRunning = isRunning;\n+        this.startTimeMillis = startTimeMillis;\n+        this.expirationTimeMillis = expirationTimeMillis;\n+    }\n+\n+    /**\n+     * Returns the id of the async search request or null if the response is not stored in the cluster.\n+     */\n+    @Nullable\n+    public String getId() {\n+        return id;\n+    }\n+\n+    /**\n+     * Sets the optional id property, use by parser and tests\n+     */\n+    void setId(String id) {\n+        this.id = id;\n+    }\n+\n+    /**\n+     * Returns the version of this response.\n+     */\n+    public int getVersion() {\n+        return version;\n+    }\n+\n+    /**\n+     * Returns the current {@link SearchResponse} or <code>null</code> if not available.\n+     *\n+     * See {@link #isPartial()} to determine whether the response contains partial or complete\n+     * results.\n+     */\n+    public SearchResponse getSearchResponse() {\n+        return searchResponse;\n+    }\n+\n+    /**\n+     * Sets the optional search response property, used by parser and tests\n+     */\n+    void setSearchResponse(SearchResponse searchResponse) {\n+        this.searchResponse = searchResponse;\n+    }\n+\n+    /**\n+     * Returns the failure reason or null if the query is running or has completed normally.\n+     */\n+    public ElasticsearchException getFailure() {\n+        return error;\n+    }\n+\n+    /**\n+     * Sets the optional failure property, use by parser and tests\n+     */\n+    void setFailure(ElasticsearchException error) {\n+        this.error = error;\n+    }\n+\n+    /**\n+     * Returns <code>true</code> if the {@link SearchResponse} contains partial\n+     * results computed from a subset of the total shards.\n+     */\n+    public boolean isPartial() {\n+        return isPartial;\n+    }\n+\n+    /**\n+     * Whether the search is still running in the cluster.\n+     *\n+     * A value of <code>false</code> indicates that the response is final\n+     * even if {@link #isPartial()} returns <code>true</code>. In such case,\n+     * the partial response represents the status of the search before a\n+     * non-recoverable failure.\n+     */\n+    public boolean isRunning() {\n+        return isRunning;\n+    }\n+\n+    /**\n+     * When this response was created as a timestamp in milliseconds since epoch.\n+     */\n+    public long getStartTime() {\n+        return startTimeMillis;\n+    }\n+\n+    /**\n+     * When this response will expired as a timestamp in milliseconds since epoch.\n+     */\n+    public long getExpirationTime() {\n+        return expirationTimeMillis;\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject();\n+        if (id != null) {\n+            builder.field(\"id\", id);\n+        }\n+        builder.field(\"version\", version);\n+        builder.field(\"is_partial\", isPartial);\n+        builder.field(\"is_running\", isRunning);\n+        builder.field(\"start_time_in_millis\", startTimeMillis);\n+        builder.field(\"expiration_time_in_millis\", expirationTimeMillis);\n+\n+        if (searchResponse != null) {\n+            builder.field(\"response\");\n+            searchResponse.toXContent(builder, params);\n+        }\n+        if (error != null) {\n+            builder.startObject(\"error\");\n+            error.toXContent(builder, params);\n+            builder.endObject();\n+        }\n+        builder.endObject();\n+        return builder;\n+    }\n+\n+    public static final ParseField ID_FIELD = new ParseField(\"id\");\n+    public static final ParseField VERSION_FIELD = new ParseField(\"version\");\n+    public static final ParseField IS_PARTIAL_FIELD = new ParseField(\"is_partial\");\n+    public static final ParseField IS_RUNNING_FIELD = new ParseField(\"is_running\");\n+    public static final ParseField START_TIME_FIELD = new ParseField(\"start_time_in_millis\");\n+    public static final ParseField EXPIRATION_FIELD = new ParseField(\"expiration_time_in_millis\");\n+    public static final ParseField RESPONSE_FIELD = new ParseField(\"response\");\n+    public static final ParseField ERROR_FIELD = new ParseField(\"error\");\n+\n+    public static final ConstructingObjectParser<AsyncSearchResponse, Void> PARSER = new ConstructingObjectParser<>(\n+            \"submit_async_search_response\", true,\n+            args -> new AsyncSearchResponse(\n+                    (int) args[0],\n+                    (boolean) args[1],\n+                    (boolean) args[2],\n+                    (long) args[3],\n+                    (long) args[4]));\n+    static {\n+        PARSER.declareInt(ConstructingObjectParser.constructorArg(), VERSION_FIELD);\n+        PARSER.declareBoolean(ConstructingObjectParser.constructorArg(), IS_PARTIAL_FIELD);\n+        PARSER.declareBoolean(ConstructingObjectParser.constructorArg(), IS_RUNNING_FIELD);\n+        PARSER.declareLong(ConstructingObjectParser.constructorArg(), START_TIME_FIELD);\n+        PARSER.declareLong(ConstructingObjectParser.constructorArg(), EXPIRATION_FIELD);\n+        PARSER.declareString(AsyncSearchResponse::setId, ID_FIELD);\n+        PARSER.declareObject(AsyncSearchResponse::setSearchResponse, (p, c) -> AsyncSearchResponse.parseSearchResponse(p),\n+                RESPONSE_FIELD);\n+        PARSER.declareObject(AsyncSearchResponse::setFailure, (p, c) -> ElasticsearchException.fromXContent(p), ERROR_FIELD);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f65cf820d03d64096d506b95d412f03a26db9c68"}, "originalPosition": 206}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDkxNzgzMQ==", "bodyText": "This can be set in the ctr ? It should be final too.", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394917831", "createdAt": "2020-03-19T10:12:35Z", "author": {"login": "jimczi"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/AsyncSearchResponse.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentParser.Token;\n+\n+import java.io.IOException;\n+\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+/**\n+ * A response of an async search request.\n+ */\n+public class AsyncSearchResponse implements ToXContentObject  {\n+    @Nullable\n+    private String id;\n+    private final int version;\n+    @Nullable\n+    private SearchResponse searchResponse;\n+    @Nullable\n+    private ElasticsearchException error;\n+    private final boolean isRunning;\n+    private final boolean isPartial;\n+\n+    private final long startTimeMillis;\n+    private final long expirationTimeMillis;\n+\n+    /**\n+     * Creates an {@link AsyncSearchResponse} with the arguments that are always present in the server response\n+     */\n+    AsyncSearchResponse(int version,\n+                               boolean isPartial,\n+                               boolean isRunning,\n+                               long startTimeMillis,\n+                               long expirationTimeMillis) {\n+        this.version = version;\n+        this.isPartial = isPartial;\n+        this.isRunning = isRunning;\n+        this.startTimeMillis = startTimeMillis;\n+        this.expirationTimeMillis = expirationTimeMillis;\n+    }\n+\n+    /**\n+     * Returns the id of the async search request or null if the response is not stored in the cluster.\n+     */\n+    @Nullable\n+    public String getId() {\n+        return id;\n+    }\n+\n+    /**\n+     * Sets the optional id property, use by parser and tests\n+     */\n+    void setId(String id) {\n+        this.id = id;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f65cf820d03d64096d506b95d412f03a26db9c68"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDkxNzg4NQ==", "bodyText": "same here", "url": "https://github.com/elastic/elasticsearch/pull/53592#discussion_r394917885", "createdAt": "2020-03-19T10:12:42Z", "author": {"login": "jimczi"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/asyncsearch/AsyncSearchResponse.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.client.asyncsearch;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentParser.Token;\n+\n+import java.io.IOException;\n+\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+/**\n+ * A response of an async search request.\n+ */\n+public class AsyncSearchResponse implements ToXContentObject  {\n+    @Nullable\n+    private String id;\n+    private final int version;\n+    @Nullable\n+    private SearchResponse searchResponse;\n+    @Nullable\n+    private ElasticsearchException error;\n+    private final boolean isRunning;\n+    private final boolean isPartial;\n+\n+    private final long startTimeMillis;\n+    private final long expirationTimeMillis;\n+\n+    /**\n+     * Creates an {@link AsyncSearchResponse} with the arguments that are always present in the server response\n+     */\n+    AsyncSearchResponse(int version,\n+                               boolean isPartial,\n+                               boolean isRunning,\n+                               long startTimeMillis,\n+                               long expirationTimeMillis) {\n+        this.version = version;\n+        this.isPartial = isPartial;\n+        this.isRunning = isRunning;\n+        this.startTimeMillis = startTimeMillis;\n+        this.expirationTimeMillis = expirationTimeMillis;\n+    }\n+\n+    /**\n+     * Returns the id of the async search request or null if the response is not stored in the cluster.\n+     */\n+    @Nullable\n+    public String getId() {\n+        return id;\n+    }\n+\n+    /**\n+     * Sets the optional id property, use by parser and tests\n+     */\n+    void setId(String id) {\n+        this.id = id;\n+    }\n+\n+    /**\n+     * Returns the version of this response.\n+     */\n+    public int getVersion() {\n+        return version;\n+    }\n+\n+    /**\n+     * Returns the current {@link SearchResponse} or <code>null</code> if not available.\n+     *\n+     * See {@link #isPartial()} to determine whether the response contains partial or complete\n+     * results.\n+     */\n+    public SearchResponse getSearchResponse() {\n+        return searchResponse;\n+    }\n+\n+    /**\n+     * Sets the optional search response property, used by parser and tests\n+     */\n+    void setSearchResponse(SearchResponse searchResponse) {\n+        this.searchResponse = searchResponse;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f65cf820d03d64096d506b95d412f03a26db9c68"}, "originalPosition": 104}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "841430e94cd6789e9b2f229ea46859c213569327", "author": {"user": {"login": "cbuescher", "name": "Christoph B\u00fcscher"}}, "url": "https://github.com/elastic/elasticsearch/commit/841430e94cd6789e9b2f229ea46859c213569327", "committedDate": "2020-03-19T13:21:28Z", "message": "adress review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc3NzM2NTU1", "url": "https://github.com/elastic/elasticsearch/pull/53592#pullrequestreview-377736555", "createdAt": "2020-03-19T13:50:15Z", "commit": {"oid": "841430e94cd6789e9b2f229ea46859c213569327"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7d3a8ed27dff978d2c7929637b925b5119760e72", "author": {"user": {"login": "cbuescher", "name": "Christoph B\u00fcscher"}}, "url": "https://github.com/elastic/elasticsearch/commit/7d3a8ed27dff978d2c7929637b925b5119760e72", "committedDate": "2020-03-19T14:46:32Z", "message": "Merge branch 'master' into async-search-hlrc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "82239897bf05bc3bd2c9c2f87b754f8e1542fd06", "author": {"user": {"login": "cbuescher", "name": "Christoph B\u00fcscher"}}, "url": "https://github.com/elastic/elasticsearch/commit/82239897bf05bc3bd2c9c2f87b754f8e1542fd06", "committedDate": "2020-03-19T18:12:18Z", "message": "iter"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1441, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}