{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYwOTcyOTk1", "number": 50792, "title": "SQL: Extend the optimisations for equalities", "bodyText": "This PR supplements the optimisations of equalities in conjunctions\nand disjunctions:\n\nfor conjunctions, the existing optimizations with ranges are extended\nwith not-equalities and inequalities; these lead to a fast resolution,\nthe conjunction either being evaluate to a FALSE, or the non-equality\nconditions being dropped as superfluous;\noptimisations for disjunctions are added to be applied against ranges,\ninequalities and not-equalities; these lead to disjunction either\nbecoming TRUE or the equality being dropped, either as superfluous or\nmerged into a range/inequality.\n\nAdresses #49637", "createdAt": "2020-01-09T13:57:50Z", "url": "https://github.com/elastic/elasticsearch/pull/50792", "merged": true, "mergeCommit": {"oid": "62e7c6a010f10cd7893ee5c99bad8b8d2a693436"}, "closed": true, "closedAt": "2020-01-14T16:39:31Z", "author": {"login": "bpintea"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb4qSR4AH2gAyMzYwOTcyOTk1OjU5YmIyNTg0YWE2NzQ5NmE5MTU5YjNlM2ZkZTBiNGVhOWJkMjRjMzk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb6BdIwAH2gAyMzYwOTcyOTk1Ojc3NTVkMWRmMDc5ZDJiMjMwZDc5NDFiZTYwZmJkMTI4Yzk4Mjc3MGE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "59bb2584aa67496a9159b3e3fde0b4ea9bd24c39", "author": {"user": {"login": "bpintea", "name": "Bogdan Pintea"}}, "url": "https://github.com/elastic/elasticsearch/commit/59bb2584aa67496a9159b3e3fde0b4ea9bd24c39", "committedDate": "2020-01-09T13:50:40Z", "message": "Extend the optimizations for equalities\n\nThis commit supplements the optimisations of equalities in conjunctions\nand disjunctions:\n* for conjunctions, the existing optimizations with ranges are extended\nwith not-equalities and inequalities; these lead to a fast resolution,\nthe conjunction either being evaluate to a FALSE, or the non-equality\nconditions being dropped as superfluous;\n* optimisations for disjunctions are added to be applied against ranges,\ninequalities and not-equalities; these lead to disjunction either\nbecoming TRUE or the equality being dropped, either as superfluous or\nmerged into a range/inequality."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQxMDQ4MTg1", "url": "https://github.com/elastic/elasticsearch/pull/50792#pullrequestreview-341048185", "createdAt": "2020-01-10T09:40:00Z", "commit": {"oid": "59bb2584aa67496a9159b3e3fde0b4ea9bd24c39"}, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQwOTo0MDowMFrOFcOylg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQxMDoyNzowM1rOFcQEbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE0Njc3NA==", "bodyText": "what does fr stand for? Can you expand the name to the full word?", "url": "https://github.com/elastic/elasticsearch/pull/50792#discussion_r365146774", "createdAt": "2020-01-10T09:40:00Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -976,14 +979,20 @@ private Expression literalToTheRight(BinaryOperator<?, ?, ?, ?> be) {\n         protected Expression rule(Expression e) {\n             if (e instanceof And) {\n                 return propagate((And) e);\n+            } else if (e instanceof Or) {\n+                return propagate((Or) e);\n             }\n             return e;\n         }\n \n         // combine conjunction\n         private Expression propagate(And and) {\n             List<Range> ranges = new ArrayList<>();\n-            List<BinaryComparison> equals = new ArrayList<>();\n+            // Only equalities, not-equalities and inequalities with a foldable .right are extracted separately;\n+            // the others go into the general 'exps'.\n+            List<BinaryComparison> frEquals = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59bb2584aa67496a9159b3e3fde0b4ea9bd24c39"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE2NTA1NA==", "bodyText": "I see that fr comes from foldable right - I would remove the prefix since there's no foldable left and the collections are used for compacting or selecting the expressions.", "url": "https://github.com/elastic/elasticsearch/pull/50792#discussion_r365165054", "createdAt": "2020-01-10T10:20:24Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -1060,9 +1076,171 @@ private Expression propagate(And and) {\n                         changed = true;\n                     }\n                 }\n+\n+                // evaluate all NotEquals against the Equal\n+                for (Iterator<NotEquals> iter = frNotEquals.iterator(); iter.hasNext(); ) {\n+                    NotEquals neq = iter.next();\n+                    if (eq.left().semanticEquals(neq.left())) {\n+                        Integer comp = BinaryComparison.compare(eq.right().fold(), neq.right().fold());\n+                        if (comp != null) {\n+                            if (comp == 0) {\n+                                return FALSE; // clashing and conflicting: a = 1 AND a != 1\n+                            } else {\n+                                iter.remove(); // clashing and redundant: a = 1 AND a != 2\n+                                changed = true;\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                // evaluate all inequalities against the Equal\n+                for (Iterator<BinaryComparison> iter = frInequalities.iterator(); iter.hasNext(); ) {\n+                    BinaryComparison bc = iter.next();\n+                    if (! eq.left().semanticEquals(bc.left())) {\n+                        continue;\n+                    }\n+\n+                    Integer compare = BinaryComparison.compare(eqValue, bc.right().fold());\n+                    if (compare == null) {\n+                        continue;\n+                    }\n+\n+                    if (bc instanceof LessThan || bc instanceof LessThanOrEqual) { // a = 2 AND a </<= ?\n+                        if ((compare == 0 && bc instanceof LessThan) || // a = 2 AND a < 2\n+                            0 < compare) { // a = 2 AND a </<= 1\n+                            return FALSE;\n+                        }\n+                    } else if (bc instanceof GreaterThan || bc instanceof GreaterThanOrEqual) { // a = 2 AND a >/>= ?\n+                        if ((compare == 0 && bc instanceof GreaterThan) || // a = 2 AND a > 2\n+                            compare < 0) { // a = 2 AND a >/>= 3\n+                            return FALSE;\n+                        }\n+                    }\n+\n+                    iter.remove();\n+                    changed = true;\n+                }\n+            }\n+\n+            return changed ? Predicates.combineAnd(CollectionUtils.combine(exps, frEquals, frNotEquals, frInequalities, ranges)) : and;\n+        }\n+\n+        // combine disjunction:\n+        // a = 2 OR a > 3 -> nop; a = 2 OR a > 1 -> a > 1\n+        // a = 2 OR a < 3 -> a < 3; a = 2 OR a < 1 -> nop\n+        // a = 2 OR 3 < a < 5 -> nop; a = 2 OR 1 < a < 3 -> 1 < a < 3; a = 2 OR 0 < a < 1 -> nop\n+        // a = 2 OR a != 5 -> TRUE; a = 2 OR a = 5 -> nop\n+        private Expression propagate(Or or) {\n+            List<Expression> exps = new ArrayList<>();\n+            List<Equals> frEquals = new ArrayList<>(); // foldable right term Equals", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59bb2584aa67496a9159b3e3fde0b4ea9bd24c39"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE2NjMwNA==", "bodyText": "Isn't this handled already by the folding rule  + BooleanSimplification?", "url": "https://github.com/elastic/elasticsearch/pull/50792#discussion_r365166304", "createdAt": "2020-01-10T10:23:34Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -1060,9 +1076,171 @@ private Expression propagate(And and) {\n                         changed = true;\n                     }\n                 }\n+\n+                // evaluate all NotEquals against the Equal\n+                for (Iterator<NotEquals> iter = frNotEquals.iterator(); iter.hasNext(); ) {\n+                    NotEquals neq = iter.next();\n+                    if (eq.left().semanticEquals(neq.left())) {\n+                        Integer comp = BinaryComparison.compare(eq.right().fold(), neq.right().fold());\n+                        if (comp != null) {\n+                            if (comp == 0) {\n+                                return FALSE; // clashing and conflicting: a = 1 AND a != 1\n+                            } else {\n+                                iter.remove(); // clashing and redundant: a = 1 AND a != 2\n+                                changed = true;\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                // evaluate all inequalities against the Equal\n+                for (Iterator<BinaryComparison> iter = frInequalities.iterator(); iter.hasNext(); ) {\n+                    BinaryComparison bc = iter.next();\n+                    if (! eq.left().semanticEquals(bc.left())) {\n+                        continue;\n+                    }\n+\n+                    Integer compare = BinaryComparison.compare(eqValue, bc.right().fold());\n+                    if (compare == null) {\n+                        continue;\n+                    }\n+\n+                    if (bc instanceof LessThan || bc instanceof LessThanOrEqual) { // a = 2 AND a </<= ?\n+                        if ((compare == 0 && bc instanceof LessThan) || // a = 2 AND a < 2\n+                            0 < compare) { // a = 2 AND a </<= 1\n+                            return FALSE;\n+                        }\n+                    } else if (bc instanceof GreaterThan || bc instanceof GreaterThanOrEqual) { // a = 2 AND a >/>= ?\n+                        if ((compare == 0 && bc instanceof GreaterThan) || // a = 2 AND a > 2\n+                            compare < 0) { // a = 2 AND a >/>= 3\n+                            return FALSE;\n+                        }\n+                    }\n+\n+                    iter.remove();\n+                    changed = true;\n+                }\n+            }\n+\n+            return changed ? Predicates.combineAnd(CollectionUtils.combine(exps, frEquals, frNotEquals, frInequalities, ranges)) : and;\n+        }\n+\n+        // combine disjunction:\n+        // a = 2 OR a > 3 -> nop; a = 2 OR a > 1 -> a > 1\n+        // a = 2 OR a < 3 -> a < 3; a = 2 OR a < 1 -> nop\n+        // a = 2 OR 3 < a < 5 -> nop; a = 2 OR 1 < a < 3 -> 1 < a < 3; a = 2 OR 0 < a < 1 -> nop\n+        // a = 2 OR a != 5 -> TRUE; a = 2 OR a = 5 -> nop\n+        private Expression propagate(Or or) {\n+            List<Expression> exps = new ArrayList<>();\n+            List<Equals> frEquals = new ArrayList<>(); // foldable right term Equals\n+            List<NotEquals> frNotEquals = new ArrayList<>(); // foldable right term NotEquals\n+            List<Range> ranges = new ArrayList<>();\n+            List<BinaryComparison> frInequalities = new ArrayList<>(); // foldable right term (=limit) BinaryComparision\n+\n+            // split expressions by type\n+            for (Expression ex : Predicates.splitOr(or)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59bb2584aa67496a9159b3e3fde0b4ea9bd24c39"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE2NzcyNg==", "bodyText": "It's worth reviewing the code that does removal through position (for (int i = ...) { ranges.remove(i); } ) since it's incorrect as after a removal it skips the next item as the counter is not decremented.\nMoving that to use iterator removal is better (though more verbose).", "url": "https://github.com/elastic/elasticsearch/pull/50792#discussion_r365167726", "createdAt": "2020-01-10T10:27:03Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -1060,9 +1076,171 @@ private Expression propagate(And and) {\n                         changed = true;\n                     }\n                 }\n+\n+                // evaluate all NotEquals against the Equal\n+                for (Iterator<NotEquals> iter = frNotEquals.iterator(); iter.hasNext(); ) {\n+                    NotEquals neq = iter.next();\n+                    if (eq.left().semanticEquals(neq.left())) {\n+                        Integer comp = BinaryComparison.compare(eq.right().fold(), neq.right().fold());\n+                        if (comp != null) {\n+                            if (comp == 0) {\n+                                return FALSE; // clashing and conflicting: a = 1 AND a != 1\n+                            } else {\n+                                iter.remove(); // clashing and redundant: a = 1 AND a != 2\n+                                changed = true;\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                // evaluate all inequalities against the Equal\n+                for (Iterator<BinaryComparison> iter = frInequalities.iterator(); iter.hasNext(); ) {\n+                    BinaryComparison bc = iter.next();\n+                    if (! eq.left().semanticEquals(bc.left())) {\n+                        continue;\n+                    }\n+\n+                    Integer compare = BinaryComparison.compare(eqValue, bc.right().fold());\n+                    if (compare == null) {\n+                        continue;\n+                    }\n+\n+                    if (bc instanceof LessThan || bc instanceof LessThanOrEqual) { // a = 2 AND a </<= ?\n+                        if ((compare == 0 && bc instanceof LessThan) || // a = 2 AND a < 2\n+                            0 < compare) { // a = 2 AND a </<= 1\n+                            return FALSE;\n+                        }\n+                    } else if (bc instanceof GreaterThan || bc instanceof GreaterThanOrEqual) { // a = 2 AND a >/>= ?\n+                        if ((compare == 0 && bc instanceof GreaterThan) || // a = 2 AND a > 2\n+                            compare < 0) { // a = 2 AND a >/>= 3\n+                            return FALSE;\n+                        }\n+                    }\n+\n+                    iter.remove();\n+                    changed = true;\n+                }\n+            }\n+\n+            return changed ? Predicates.combineAnd(CollectionUtils.combine(exps, frEquals, frNotEquals, frInequalities, ranges)) : and;\n+        }\n+\n+        // combine disjunction:\n+        // a = 2 OR a > 3 -> nop; a = 2 OR a > 1 -> a > 1\n+        // a = 2 OR a < 3 -> a < 3; a = 2 OR a < 1 -> nop\n+        // a = 2 OR 3 < a < 5 -> nop; a = 2 OR 1 < a < 3 -> 1 < a < 3; a = 2 OR 0 < a < 1 -> nop\n+        // a = 2 OR a != 5 -> TRUE; a = 2 OR a = 5 -> nop\n+        private Expression propagate(Or or) {\n+            List<Expression> exps = new ArrayList<>();\n+            List<Equals> frEquals = new ArrayList<>(); // foldable right term Equals\n+            List<NotEquals> frNotEquals = new ArrayList<>(); // foldable right term NotEquals\n+            List<Range> ranges = new ArrayList<>();\n+            List<BinaryComparison> frInequalities = new ArrayList<>(); // foldable right term (=limit) BinaryComparision\n+\n+            // split expressions by type\n+            for (Expression ex : Predicates.splitOr(or)) {\n+                if (ex instanceof Equals) {\n+                    Equals eq = (Equals) ex;\n+                    if (eq.right().foldable()) {\n+                        frEquals.add(eq);\n+                    } else {\n+                        exps.add(ex);\n+                    }\n+                } else if (ex instanceof NotEquals) {\n+                    NotEquals neq = (NotEquals) ex;\n+                    if (neq.right().foldable()) {\n+                        frNotEquals.add(neq);\n+                    } else {\n+                        exps.add(ex);\n+                    }\n+                } else if (ex instanceof Range) {\n+                    ranges.add((Range) ex);\n+                } else if (ex instanceof BinaryComparison) {\n+                    BinaryComparison bc = (BinaryComparison) ex;\n+                    if (bc.right().foldable()) {\n+                        frInequalities.add(bc);\n+                    } else {\n+                        exps.add(ex);\n+                    }\n+                } else {\n+                    exps.add(ex);\n+                }\n+            }\n+\n+            boolean updated = false; // has the expression been modified?\n+\n+            // evaluate the impact of each Equal over the different types of Expressions\n+            for (Iterator<Equals> iterEq = frEquals.iterator(); iterEq.hasNext(); ) {\n+                Equals eq = iterEq.next();\n+\n+                // Equals OR NotEquals\n+                for (NotEquals neq : frNotEquals) {\n+                    if (eq.left().semanticEquals(neq.left())) { // a = 2 OR a != ? -> TRUE\n+                        return TRUE;\n+                    }\n+                }\n+\n+                Object eqValue = eq.right().fold();\n+\n+                // Equals OR Range\n+                for (int i = 0; i < ranges.size(); i ++) { // might modify list, so use index loop\n+                    Range range = ranges.get(i);\n+                    if (! eq.left().semanticEquals(range.value())) {\n+                        continue;\n+                    }\n+\n+                    Integer lowerComp = range.lower().foldable() ? BinaryComparison.compare(eqValue, range.lower().fold()) : null;\n+                    Integer upperComp = range.upper().foldable() ? BinaryComparison.compare(eqValue, range.upper().fold()) : null;\n+\n+                    if (lowerComp != null && lowerComp == 0 && !range.includeLower()) { // a = 2 OR 2 < a < ? -> 2 <= a < ?\n+                        iterEq.remove(); // update range with lower equality instead\n+                        ranges.set(i, new Range(range.source(), range.value(), range.lower(), true, range.upper(), range.includeUpper()));\n+                        updated = true;\n+                    } else if (upperComp != null && upperComp == 0 && !range.includeUpper()) { // a = 2 OR ? < a < 2 -> ? < a <= 2\n+                        iterEq.remove(); // update range with upper equality instead\n+                        ranges.set(i, new Range(range.source(), range.value(), range.lower(), range.includeLower(), range.upper(), true));\n+                        updated = true;\n+                    } else if (lowerComp != null && upperComp != null) {\n+                        if (0 < lowerComp && upperComp < 0) { // a = 2 OR 1 < a < 3\n+                            iterEq.remove(); // equality is superfluous", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59bb2584aa67496a9159b3e3fde0b4ea9bd24c39"}, "originalPosition": 237}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQxMDA4MjI0", "url": "https://github.com/elastic/elasticsearch/pull/50792#pullrequestreview-341008224", "createdAt": "2020-01-10T08:20:22Z", "commit": {"oid": "59bb2584aa67496a9159b3e3fde0b4ea9bd24c39"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQwODoyMDoyMlrOFcM5BA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQxNDoxNDozN1rOFcVOcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTExNTY1Mg==", "bodyText": "It took  me few seconds to determine what fr stands for. My personal preference is to name these variables as foldRightEq or foldRightEquals.", "url": "https://github.com/elastic/elasticsearch/pull/50792#discussion_r365115652", "createdAt": "2020-01-10T08:20:22Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -976,14 +979,20 @@ private Expression literalToTheRight(BinaryOperator<?, ?, ?, ?> be) {\n         protected Expression rule(Expression e) {\n             if (e instanceof And) {\n                 return propagate((And) e);\n+            } else if (e instanceof Or) {\n+                return propagate((Or) e);\n             }\n             return e;\n         }\n \n         // combine conjunction\n         private Expression propagate(And and) {\n             List<Range> ranges = new ArrayList<>();\n-            List<BinaryComparison> equals = new ArrayList<>();\n+            // Only equalities, not-equalities and inequalities with a foldable .right are extracted separately;\n+            // the others go into the general 'exps'.\n+            List<BinaryComparison> frEquals = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59bb2584aa67496a9159b3e3fde0b4ea9bd24c39"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTIzMDY5OA==", "bodyText": "I think we prefer the eq.left().semanticEquals(bc.left()) == false format for better visibility.\nActually, I would have kept the same \"style\" as the previous conditional statements and not use continue, but the positive outcome of semanticEquals and include the following statements in a bigger if clause.", "url": "https://github.com/elastic/elasticsearch/pull/50792#discussion_r365230698", "createdAt": "2020-01-10T13:23:34Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -1060,9 +1076,171 @@ private Expression propagate(And and) {\n                         changed = true;\n                     }\n                 }\n+\n+                // evaluate all NotEquals against the Equal\n+                for (Iterator<NotEquals> iter = frNotEquals.iterator(); iter.hasNext(); ) {\n+                    NotEquals neq = iter.next();\n+                    if (eq.left().semanticEquals(neq.left())) {\n+                        Integer comp = BinaryComparison.compare(eq.right().fold(), neq.right().fold());\n+                        if (comp != null) {\n+                            if (comp == 0) {\n+                                return FALSE; // clashing and conflicting: a = 1 AND a != 1\n+                            } else {\n+                                iter.remove(); // clashing and redundant: a = 1 AND a != 2\n+                                changed = true;\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                // evaluate all inequalities against the Equal\n+                for (Iterator<BinaryComparison> iter = frInequalities.iterator(); iter.hasNext(); ) {\n+                    BinaryComparison bc = iter.next();\n+                    if (! eq.left().semanticEquals(bc.left())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59bb2584aa67496a9159b3e3fde0b4ea9bd24c39"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTIzMTM4Nw==", "bodyText": "Instead of eq.right().fold() you could have used eqValue, no?", "url": "https://github.com/elastic/elasticsearch/pull/50792#discussion_r365231387", "createdAt": "2020-01-10T13:25:29Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -1060,9 +1076,171 @@ private Expression propagate(And and) {\n                         changed = true;\n                     }\n                 }\n+\n+                // evaluate all NotEquals against the Equal\n+                for (Iterator<NotEquals> iter = frNotEquals.iterator(); iter.hasNext(); ) {\n+                    NotEquals neq = iter.next();\n+                    if (eq.left().semanticEquals(neq.left())) {\n+                        Integer comp = BinaryComparison.compare(eq.right().fold(), neq.right().fold());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59bb2584aa67496a9159b3e3fde0b4ea9bd24c39"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTIzMzczMw==", "bodyText": "return changed == true ? Predicates......", "url": "https://github.com/elastic/elasticsearch/pull/50792#discussion_r365233733", "createdAt": "2020-01-10T13:31:02Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -1060,9 +1076,171 @@ private Expression propagate(And and) {\n                         changed = true;\n                     }\n                 }\n+\n+                // evaluate all NotEquals against the Equal\n+                for (Iterator<NotEquals> iter = frNotEquals.iterator(); iter.hasNext(); ) {\n+                    NotEquals neq = iter.next();\n+                    if (eq.left().semanticEquals(neq.left())) {\n+                        Integer comp = BinaryComparison.compare(eq.right().fold(), neq.right().fold());\n+                        if (comp != null) {\n+                            if (comp == 0) {\n+                                return FALSE; // clashing and conflicting: a = 1 AND a != 1\n+                            } else {\n+                                iter.remove(); // clashing and redundant: a = 1 AND a != 2\n+                                changed = true;\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                // evaluate all inequalities against the Equal\n+                for (Iterator<BinaryComparison> iter = frInequalities.iterator(); iter.hasNext(); ) {\n+                    BinaryComparison bc = iter.next();\n+                    if (! eq.left().semanticEquals(bc.left())) {\n+                        continue;\n+                    }\n+\n+                    Integer compare = BinaryComparison.compare(eqValue, bc.right().fold());\n+                    if (compare == null) {\n+                        continue;\n+                    }\n+\n+                    if (bc instanceof LessThan || bc instanceof LessThanOrEqual) { // a = 2 AND a </<= ?\n+                        if ((compare == 0 && bc instanceof LessThan) || // a = 2 AND a < 2\n+                            0 < compare) { // a = 2 AND a </<= 1\n+                            return FALSE;\n+                        }\n+                    } else if (bc instanceof GreaterThan || bc instanceof GreaterThanOrEqual) { // a = 2 AND a >/>= ?\n+                        if ((compare == 0 && bc instanceof GreaterThan) || // a = 2 AND a > 2\n+                            compare < 0) { // a = 2 AND a >/>= 3\n+                            return FALSE;\n+                        }\n+                    }\n+\n+                    iter.remove();\n+                    changed = true;\n+                }\n+            }\n+\n+            return changed ? Predicates.combineAnd(CollectionUtils.combine(exps, frEquals, frNotEquals, frInequalities, ranges)) : and;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59bb2584aa67496a9159b3e3fde0b4ea9bd24c39"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTIzOTMyMg==", "bodyText": "Why is this evaluated to true right away?\nAn OR is translated in ES query DSL as a combination of two should statements for a bool query and saying field_x = 2 OR field_x != 4 translates into give me all documents that have field_x = 2 OR field_x != 4 which is in fact a collection of documents with field_x = 2 and documents with field_x != 4. I don't think that statement should be evaluated straight to TRUE, but simplified to field_x != 4.\nEvaluating it to TRUE means give me all documents.\nKeeping the OR as is means give me the docs with field_x != 4.\nThese two ^ are not equivalent.", "url": "https://github.com/elastic/elasticsearch/pull/50792#discussion_r365239322", "createdAt": "2020-01-10T13:44:31Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -1060,9 +1076,171 @@ private Expression propagate(And and) {\n                         changed = true;\n                     }\n                 }\n+\n+                // evaluate all NotEquals against the Equal\n+                for (Iterator<NotEquals> iter = frNotEquals.iterator(); iter.hasNext(); ) {\n+                    NotEquals neq = iter.next();\n+                    if (eq.left().semanticEquals(neq.left())) {\n+                        Integer comp = BinaryComparison.compare(eq.right().fold(), neq.right().fold());\n+                        if (comp != null) {\n+                            if (comp == 0) {\n+                                return FALSE; // clashing and conflicting: a = 1 AND a != 1\n+                            } else {\n+                                iter.remove(); // clashing and redundant: a = 1 AND a != 2\n+                                changed = true;\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                // evaluate all inequalities against the Equal\n+                for (Iterator<BinaryComparison> iter = frInequalities.iterator(); iter.hasNext(); ) {\n+                    BinaryComparison bc = iter.next();\n+                    if (! eq.left().semanticEquals(bc.left())) {\n+                        continue;\n+                    }\n+\n+                    Integer compare = BinaryComparison.compare(eqValue, bc.right().fold());\n+                    if (compare == null) {\n+                        continue;\n+                    }\n+\n+                    if (bc instanceof LessThan || bc instanceof LessThanOrEqual) { // a = 2 AND a </<= ?\n+                        if ((compare == 0 && bc instanceof LessThan) || // a = 2 AND a < 2\n+                            0 < compare) { // a = 2 AND a </<= 1\n+                            return FALSE;\n+                        }\n+                    } else if (bc instanceof GreaterThan || bc instanceof GreaterThanOrEqual) { // a = 2 AND a >/>= ?\n+                        if ((compare == 0 && bc instanceof GreaterThan) || // a = 2 AND a > 2\n+                            compare < 0) { // a = 2 AND a >/>= 3\n+                            return FALSE;\n+                        }\n+                    }\n+\n+                    iter.remove();\n+                    changed = true;\n+                }\n+            }\n+\n+            return changed ? Predicates.combineAnd(CollectionUtils.combine(exps, frEquals, frNotEquals, frInequalities, ranges)) : and;\n+        }\n+\n+        // combine disjunction:\n+        // a = 2 OR a > 3 -> nop; a = 2 OR a > 1 -> a > 1\n+        // a = 2 OR a < 3 -> a < 3; a = 2 OR a < 1 -> nop\n+        // a = 2 OR 3 < a < 5 -> nop; a = 2 OR 1 < a < 3 -> 1 < a < 3; a = 2 OR 0 < a < 1 -> nop\n+        // a = 2 OR a != 5 -> TRUE; a = 2 OR a = 5 -> nop\n+        private Expression propagate(Or or) {\n+            List<Expression> exps = new ArrayList<>();\n+            List<Equals> frEquals = new ArrayList<>(); // foldable right term Equals\n+            List<NotEquals> frNotEquals = new ArrayList<>(); // foldable right term NotEquals\n+            List<Range> ranges = new ArrayList<>();\n+            List<BinaryComparison> frInequalities = new ArrayList<>(); // foldable right term (=limit) BinaryComparision\n+\n+            // split expressions by type\n+            for (Expression ex : Predicates.splitOr(or)) {\n+                if (ex instanceof Equals) {\n+                    Equals eq = (Equals) ex;\n+                    if (eq.right().foldable()) {\n+                        frEquals.add(eq);\n+                    } else {\n+                        exps.add(ex);\n+                    }\n+                } else if (ex instanceof NotEquals) {\n+                    NotEquals neq = (NotEquals) ex;\n+                    if (neq.right().foldable()) {\n+                        frNotEquals.add(neq);\n+                    } else {\n+                        exps.add(ex);\n+                    }\n+                } else if (ex instanceof Range) {\n+                    ranges.add((Range) ex);\n+                } else if (ex instanceof BinaryComparison) {\n+                    BinaryComparison bc = (BinaryComparison) ex;\n+                    if (bc.right().foldable()) {\n+                        frInequalities.add(bc);\n+                    } else {\n+                        exps.add(ex);\n+                    }\n+                } else {\n+                    exps.add(ex);\n+                }\n+            }\n+\n+            boolean updated = false; // has the expression been modified?\n+\n+            // evaluate the impact of each Equal over the different types of Expressions\n+            for (Iterator<Equals> iterEq = frEquals.iterator(); iterEq.hasNext(); ) {\n+                Equals eq = iterEq.next();\n+\n+                // Equals OR NotEquals\n+                for (NotEquals neq : frNotEquals) {\n+                    if (eq.left().semanticEquals(neq.left())) { // a = 2 OR a != ? -> TRUE", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59bb2584aa67496a9159b3e3fde0b4ea9bd24c39"}, "originalPosition": 210}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTIzOTk5Nw==", "bodyText": "a = 2 OR a != 5 -> TRUE I think it's not right. Please, see above more details about this.", "url": "https://github.com/elastic/elasticsearch/pull/50792#discussion_r365239997", "createdAt": "2020-01-10T13:45:58Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -1060,9 +1076,171 @@ private Expression propagate(And and) {\n                         changed = true;\n                     }\n                 }\n+\n+                // evaluate all NotEquals against the Equal\n+                for (Iterator<NotEquals> iter = frNotEquals.iterator(); iter.hasNext(); ) {\n+                    NotEquals neq = iter.next();\n+                    if (eq.left().semanticEquals(neq.left())) {\n+                        Integer comp = BinaryComparison.compare(eq.right().fold(), neq.right().fold());\n+                        if (comp != null) {\n+                            if (comp == 0) {\n+                                return FALSE; // clashing and conflicting: a = 1 AND a != 1\n+                            } else {\n+                                iter.remove(); // clashing and redundant: a = 1 AND a != 2\n+                                changed = true;\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                // evaluate all inequalities against the Equal\n+                for (Iterator<BinaryComparison> iter = frInequalities.iterator(); iter.hasNext(); ) {\n+                    BinaryComparison bc = iter.next();\n+                    if (! eq.left().semanticEquals(bc.left())) {\n+                        continue;\n+                    }\n+\n+                    Integer compare = BinaryComparison.compare(eqValue, bc.right().fold());\n+                    if (compare == null) {\n+                        continue;\n+                    }\n+\n+                    if (bc instanceof LessThan || bc instanceof LessThanOrEqual) { // a = 2 AND a </<= ?\n+                        if ((compare == 0 && bc instanceof LessThan) || // a = 2 AND a < 2\n+                            0 < compare) { // a = 2 AND a </<= 1\n+                            return FALSE;\n+                        }\n+                    } else if (bc instanceof GreaterThan || bc instanceof GreaterThanOrEqual) { // a = 2 AND a >/>= ?\n+                        if ((compare == 0 && bc instanceof GreaterThan) || // a = 2 AND a > 2\n+                            compare < 0) { // a = 2 AND a >/>= 3\n+                            return FALSE;\n+                        }\n+                    }\n+\n+                    iter.remove();\n+                    changed = true;\n+                }\n+            }\n+\n+            return changed ? Predicates.combineAnd(CollectionUtils.combine(exps, frEquals, frNotEquals, frInequalities, ranges)) : and;\n+        }\n+\n+        // combine disjunction:\n+        // a = 2 OR a > 3 -> nop; a = 2 OR a > 1 -> a > 1\n+        // a = 2 OR a < 3 -> a < 3; a = 2 OR a < 1 -> nop\n+        // a = 2 OR 3 < a < 5 -> nop; a = 2 OR 1 < a < 3 -> 1 < a < 3; a = 2 OR 0 < a < 1 -> nop\n+        // a = 2 OR a != 5 -> TRUE; a = 2 OR a = 5 -> nop", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59bb2584aa67496a9159b3e3fde0b4ea9bd24c39"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTI0Mjc4Ng==", "bodyText": "Same as above: == false instead of !.", "url": "https://github.com/elastic/elasticsearch/pull/50792#discussion_r365242786", "createdAt": "2020-01-10T13:52:25Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -1060,9 +1076,171 @@ private Expression propagate(And and) {\n                         changed = true;\n                     }\n                 }\n+\n+                // evaluate all NotEquals against the Equal\n+                for (Iterator<NotEquals> iter = frNotEquals.iterator(); iter.hasNext(); ) {\n+                    NotEquals neq = iter.next();\n+                    if (eq.left().semanticEquals(neq.left())) {\n+                        Integer comp = BinaryComparison.compare(eq.right().fold(), neq.right().fold());\n+                        if (comp != null) {\n+                            if (comp == 0) {\n+                                return FALSE; // clashing and conflicting: a = 1 AND a != 1\n+                            } else {\n+                                iter.remove(); // clashing and redundant: a = 1 AND a != 2\n+                                changed = true;\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                // evaluate all inequalities against the Equal\n+                for (Iterator<BinaryComparison> iter = frInequalities.iterator(); iter.hasNext(); ) {\n+                    BinaryComparison bc = iter.next();\n+                    if (! eq.left().semanticEquals(bc.left())) {\n+                        continue;\n+                    }\n+\n+                    Integer compare = BinaryComparison.compare(eqValue, bc.right().fold());\n+                    if (compare == null) {\n+                        continue;\n+                    }\n+\n+                    if (bc instanceof LessThan || bc instanceof LessThanOrEqual) { // a = 2 AND a </<= ?\n+                        if ((compare == 0 && bc instanceof LessThan) || // a = 2 AND a < 2\n+                            0 < compare) { // a = 2 AND a </<= 1\n+                            return FALSE;\n+                        }\n+                    } else if (bc instanceof GreaterThan || bc instanceof GreaterThanOrEqual) { // a = 2 AND a >/>= ?\n+                        if ((compare == 0 && bc instanceof GreaterThan) || // a = 2 AND a > 2\n+                            compare < 0) { // a = 2 AND a >/>= 3\n+                            return FALSE;\n+                        }\n+                    }\n+\n+                    iter.remove();\n+                    changed = true;\n+                }\n+            }\n+\n+            return changed ? Predicates.combineAnd(CollectionUtils.combine(exps, frEquals, frNotEquals, frInequalities, ranges)) : and;\n+        }\n+\n+        // combine disjunction:\n+        // a = 2 OR a > 3 -> nop; a = 2 OR a > 1 -> a > 1\n+        // a = 2 OR a < 3 -> a < 3; a = 2 OR a < 1 -> nop\n+        // a = 2 OR 3 < a < 5 -> nop; a = 2 OR 1 < a < 3 -> 1 < a < 3; a = 2 OR 0 < a < 1 -> nop\n+        // a = 2 OR a != 5 -> TRUE; a = 2 OR a = 5 -> nop\n+        private Expression propagate(Or or) {\n+            List<Expression> exps = new ArrayList<>();\n+            List<Equals> frEquals = new ArrayList<>(); // foldable right term Equals\n+            List<NotEquals> frNotEquals = new ArrayList<>(); // foldable right term NotEquals\n+            List<Range> ranges = new ArrayList<>();\n+            List<BinaryComparison> frInequalities = new ArrayList<>(); // foldable right term (=limit) BinaryComparision\n+\n+            // split expressions by type\n+            for (Expression ex : Predicates.splitOr(or)) {\n+                if (ex instanceof Equals) {\n+                    Equals eq = (Equals) ex;\n+                    if (eq.right().foldable()) {\n+                        frEquals.add(eq);\n+                    } else {\n+                        exps.add(ex);\n+                    }\n+                } else if (ex instanceof NotEquals) {\n+                    NotEquals neq = (NotEquals) ex;\n+                    if (neq.right().foldable()) {\n+                        frNotEquals.add(neq);\n+                    } else {\n+                        exps.add(ex);\n+                    }\n+                } else if (ex instanceof Range) {\n+                    ranges.add((Range) ex);\n+                } else if (ex instanceof BinaryComparison) {\n+                    BinaryComparison bc = (BinaryComparison) ex;\n+                    if (bc.right().foldable()) {\n+                        frInequalities.add(bc);\n+                    } else {\n+                        exps.add(ex);\n+                    }\n+                } else {\n+                    exps.add(ex);\n+                }\n+            }\n+\n+            boolean updated = false; // has the expression been modified?\n+\n+            // evaluate the impact of each Equal over the different types of Expressions\n+            for (Iterator<Equals> iterEq = frEquals.iterator(); iterEq.hasNext(); ) {\n+                Equals eq = iterEq.next();\n+\n+                // Equals OR NotEquals\n+                for (NotEquals neq : frNotEquals) {\n+                    if (eq.left().semanticEquals(neq.left())) { // a = 2 OR a != ? -> TRUE\n+                        return TRUE;\n+                    }\n+                }\n+\n+                Object eqValue = eq.right().fold();\n+\n+                // Equals OR Range\n+                for (int i = 0; i < ranges.size(); i ++) { // might modify list, so use index loop\n+                    Range range = ranges.get(i);\n+                    if (! eq.left().semanticEquals(range.value())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59bb2584aa67496a9159b3e3fde0b4ea9bd24c39"}, "originalPosition": 220}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTI0OTM2Mg==", "bodyText": "== false", "url": "https://github.com/elastic/elasticsearch/pull/50792#discussion_r365249362", "createdAt": "2020-01-10T14:08:20Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -1060,9 +1076,171 @@ private Expression propagate(And and) {\n                         changed = true;\n                     }\n                 }\n+\n+                // evaluate all NotEquals against the Equal\n+                for (Iterator<NotEquals> iter = frNotEquals.iterator(); iter.hasNext(); ) {\n+                    NotEquals neq = iter.next();\n+                    if (eq.left().semanticEquals(neq.left())) {\n+                        Integer comp = BinaryComparison.compare(eq.right().fold(), neq.right().fold());\n+                        if (comp != null) {\n+                            if (comp == 0) {\n+                                return FALSE; // clashing and conflicting: a = 1 AND a != 1\n+                            } else {\n+                                iter.remove(); // clashing and redundant: a = 1 AND a != 2\n+                                changed = true;\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                // evaluate all inequalities against the Equal\n+                for (Iterator<BinaryComparison> iter = frInequalities.iterator(); iter.hasNext(); ) {\n+                    BinaryComparison bc = iter.next();\n+                    if (! eq.left().semanticEquals(bc.left())) {\n+                        continue;\n+                    }\n+\n+                    Integer compare = BinaryComparison.compare(eqValue, bc.right().fold());\n+                    if (compare == null) {\n+                        continue;\n+                    }\n+\n+                    if (bc instanceof LessThan || bc instanceof LessThanOrEqual) { // a = 2 AND a </<= ?\n+                        if ((compare == 0 && bc instanceof LessThan) || // a = 2 AND a < 2\n+                            0 < compare) { // a = 2 AND a </<= 1\n+                            return FALSE;\n+                        }\n+                    } else if (bc instanceof GreaterThan || bc instanceof GreaterThanOrEqual) { // a = 2 AND a >/>= ?\n+                        if ((compare == 0 && bc instanceof GreaterThan) || // a = 2 AND a > 2\n+                            compare < 0) { // a = 2 AND a >/>= 3\n+                            return FALSE;\n+                        }\n+                    }\n+\n+                    iter.remove();\n+                    changed = true;\n+                }\n+            }\n+\n+            return changed ? Predicates.combineAnd(CollectionUtils.combine(exps, frEquals, frNotEquals, frInequalities, ranges)) : and;\n+        }\n+\n+        // combine disjunction:\n+        // a = 2 OR a > 3 -> nop; a = 2 OR a > 1 -> a > 1\n+        // a = 2 OR a < 3 -> a < 3; a = 2 OR a < 1 -> nop\n+        // a = 2 OR 3 < a < 5 -> nop; a = 2 OR 1 < a < 3 -> 1 < a < 3; a = 2 OR 0 < a < 1 -> nop\n+        // a = 2 OR a != 5 -> TRUE; a = 2 OR a = 5 -> nop\n+        private Expression propagate(Or or) {\n+            List<Expression> exps = new ArrayList<>();\n+            List<Equals> frEquals = new ArrayList<>(); // foldable right term Equals\n+            List<NotEquals> frNotEquals = new ArrayList<>(); // foldable right term NotEquals\n+            List<Range> ranges = new ArrayList<>();\n+            List<BinaryComparison> frInequalities = new ArrayList<>(); // foldable right term (=limit) BinaryComparision\n+\n+            // split expressions by type\n+            for (Expression ex : Predicates.splitOr(or)) {\n+                if (ex instanceof Equals) {\n+                    Equals eq = (Equals) ex;\n+                    if (eq.right().foldable()) {\n+                        frEquals.add(eq);\n+                    } else {\n+                        exps.add(ex);\n+                    }\n+                } else if (ex instanceof NotEquals) {\n+                    NotEquals neq = (NotEquals) ex;\n+                    if (neq.right().foldable()) {\n+                        frNotEquals.add(neq);\n+                    } else {\n+                        exps.add(ex);\n+                    }\n+                } else if (ex instanceof Range) {\n+                    ranges.add((Range) ex);\n+                } else if (ex instanceof BinaryComparison) {\n+                    BinaryComparison bc = (BinaryComparison) ex;\n+                    if (bc.right().foldable()) {\n+                        frInequalities.add(bc);\n+                    } else {\n+                        exps.add(ex);\n+                    }\n+                } else {\n+                    exps.add(ex);\n+                }\n+            }\n+\n+            boolean updated = false; // has the expression been modified?\n+\n+            // evaluate the impact of each Equal over the different types of Expressions\n+            for (Iterator<Equals> iterEq = frEquals.iterator(); iterEq.hasNext(); ) {\n+                Equals eq = iterEq.next();\n+\n+                // Equals OR NotEquals\n+                for (NotEquals neq : frNotEquals) {\n+                    if (eq.left().semanticEquals(neq.left())) { // a = 2 OR a != ? -> TRUE\n+                        return TRUE;\n+                    }\n+                }\n+\n+                Object eqValue = eq.right().fold();\n+\n+                // Equals OR Range\n+                for (int i = 0; i < ranges.size(); i ++) { // might modify list, so use index loop\n+                    Range range = ranges.get(i);\n+                    if (! eq.left().semanticEquals(range.value())) {\n+                        continue;\n+                    }\n+\n+                    Integer lowerComp = range.lower().foldable() ? BinaryComparison.compare(eqValue, range.lower().fold()) : null;\n+                    Integer upperComp = range.upper().foldable() ? BinaryComparison.compare(eqValue, range.upper().fold()) : null;\n+\n+                    if (lowerComp != null && lowerComp == 0 && !range.includeLower()) { // a = 2 OR 2 < a < ? -> 2 <= a < ?\n+                        iterEq.remove(); // update range with lower equality instead\n+                        ranges.set(i, new Range(range.source(), range.value(), range.lower(), true, range.upper(), range.includeUpper()));\n+                        updated = true;\n+                    } else if (upperComp != null && upperComp == 0 && !range.includeUpper()) { // a = 2 OR ? < a < 2 -> ? < a <= 2\n+                        iterEq.remove(); // update range with upper equality instead\n+                        ranges.set(i, new Range(range.source(), range.value(), range.lower(), range.includeLower(), range.upper(), true));\n+                        updated = true;\n+                    } else if (lowerComp != null && upperComp != null) {\n+                        if (0 < lowerComp && upperComp < 0) { // a = 2 OR 1 < a < 3\n+                            iterEq.remove(); // equality is superfluous\n+                            updated = true;\n+                        }\n+                    }\n+                }\n+\n+                // Equals OR Inequality\n+                for (int i = 0; i < frInequalities.size(); i ++) {\n+                    BinaryComparison bc = frInequalities.get(i);\n+                    if (! eq.left().semanticEquals(bc.left())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59bb2584aa67496a9159b3e3fde0b4ea9bd24c39"}, "originalPosition": 246}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTI1MDIyNw==", "bodyText": "The commented potential condition here - 0 < comp - is not entirely true. A potential else branch can also happen for bc instanceof GreaterThanOrEqual. I don't think it's changing the logic, but just saying.", "url": "https://github.com/elastic/elasticsearch/pull/50792#discussion_r365250227", "createdAt": "2020-01-10T14:10:19Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -1060,9 +1076,171 @@ private Expression propagate(And and) {\n                         changed = true;\n                     }\n                 }\n+\n+                // evaluate all NotEquals against the Equal\n+                for (Iterator<NotEquals> iter = frNotEquals.iterator(); iter.hasNext(); ) {\n+                    NotEquals neq = iter.next();\n+                    if (eq.left().semanticEquals(neq.left())) {\n+                        Integer comp = BinaryComparison.compare(eq.right().fold(), neq.right().fold());\n+                        if (comp != null) {\n+                            if (comp == 0) {\n+                                return FALSE; // clashing and conflicting: a = 1 AND a != 1\n+                            } else {\n+                                iter.remove(); // clashing and redundant: a = 1 AND a != 2\n+                                changed = true;\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                // evaluate all inequalities against the Equal\n+                for (Iterator<BinaryComparison> iter = frInequalities.iterator(); iter.hasNext(); ) {\n+                    BinaryComparison bc = iter.next();\n+                    if (! eq.left().semanticEquals(bc.left())) {\n+                        continue;\n+                    }\n+\n+                    Integer compare = BinaryComparison.compare(eqValue, bc.right().fold());\n+                    if (compare == null) {\n+                        continue;\n+                    }\n+\n+                    if (bc instanceof LessThan || bc instanceof LessThanOrEqual) { // a = 2 AND a </<= ?\n+                        if ((compare == 0 && bc instanceof LessThan) || // a = 2 AND a < 2\n+                            0 < compare) { // a = 2 AND a </<= 1\n+                            return FALSE;\n+                        }\n+                    } else if (bc instanceof GreaterThan || bc instanceof GreaterThanOrEqual) { // a = 2 AND a >/>= ?\n+                        if ((compare == 0 && bc instanceof GreaterThan) || // a = 2 AND a > 2\n+                            compare < 0) { // a = 2 AND a >/>= 3\n+                            return FALSE;\n+                        }\n+                    }\n+\n+                    iter.remove();\n+                    changed = true;\n+                }\n+            }\n+\n+            return changed ? Predicates.combineAnd(CollectionUtils.combine(exps, frEquals, frNotEquals, frInequalities, ranges)) : and;\n+        }\n+\n+        // combine disjunction:\n+        // a = 2 OR a > 3 -> nop; a = 2 OR a > 1 -> a > 1\n+        // a = 2 OR a < 3 -> a < 3; a = 2 OR a < 1 -> nop\n+        // a = 2 OR 3 < a < 5 -> nop; a = 2 OR 1 < a < 3 -> 1 < a < 3; a = 2 OR 0 < a < 1 -> nop\n+        // a = 2 OR a != 5 -> TRUE; a = 2 OR a = 5 -> nop\n+        private Expression propagate(Or or) {\n+            List<Expression> exps = new ArrayList<>();\n+            List<Equals> frEquals = new ArrayList<>(); // foldable right term Equals\n+            List<NotEquals> frNotEquals = new ArrayList<>(); // foldable right term NotEquals\n+            List<Range> ranges = new ArrayList<>();\n+            List<BinaryComparison> frInequalities = new ArrayList<>(); // foldable right term (=limit) BinaryComparision\n+\n+            // split expressions by type\n+            for (Expression ex : Predicates.splitOr(or)) {\n+                if (ex instanceof Equals) {\n+                    Equals eq = (Equals) ex;\n+                    if (eq.right().foldable()) {\n+                        frEquals.add(eq);\n+                    } else {\n+                        exps.add(ex);\n+                    }\n+                } else if (ex instanceof NotEquals) {\n+                    NotEquals neq = (NotEquals) ex;\n+                    if (neq.right().foldable()) {\n+                        frNotEquals.add(neq);\n+                    } else {\n+                        exps.add(ex);\n+                    }\n+                } else if (ex instanceof Range) {\n+                    ranges.add((Range) ex);\n+                } else if (ex instanceof BinaryComparison) {\n+                    BinaryComparison bc = (BinaryComparison) ex;\n+                    if (bc.right().foldable()) {\n+                        frInequalities.add(bc);\n+                    } else {\n+                        exps.add(ex);\n+                    }\n+                } else {\n+                    exps.add(ex);\n+                }\n+            }\n+\n+            boolean updated = false; // has the expression been modified?\n+\n+            // evaluate the impact of each Equal over the different types of Expressions\n+            for (Iterator<Equals> iterEq = frEquals.iterator(); iterEq.hasNext(); ) {\n+                Equals eq = iterEq.next();\n+\n+                // Equals OR NotEquals\n+                for (NotEquals neq : frNotEquals) {\n+                    if (eq.left().semanticEquals(neq.left())) { // a = 2 OR a != ? -> TRUE\n+                        return TRUE;\n+                    }\n+                }\n+\n+                Object eqValue = eq.right().fold();\n+\n+                // Equals OR Range\n+                for (int i = 0; i < ranges.size(); i ++) { // might modify list, so use index loop\n+                    Range range = ranges.get(i);\n+                    if (! eq.left().semanticEquals(range.value())) {\n+                        continue;\n+                    }\n+\n+                    Integer lowerComp = range.lower().foldable() ? BinaryComparison.compare(eqValue, range.lower().fold()) : null;\n+                    Integer upperComp = range.upper().foldable() ? BinaryComparison.compare(eqValue, range.upper().fold()) : null;\n+\n+                    if (lowerComp != null && lowerComp == 0 && !range.includeLower()) { // a = 2 OR 2 < a < ? -> 2 <= a < ?\n+                        iterEq.remove(); // update range with lower equality instead\n+                        ranges.set(i, new Range(range.source(), range.value(), range.lower(), true, range.upper(), range.includeUpper()));\n+                        updated = true;\n+                    } else if (upperComp != null && upperComp == 0 && !range.includeUpper()) { // a = 2 OR ? < a < 2 -> ? < a <= 2\n+                        iterEq.remove(); // update range with upper equality instead\n+                        ranges.set(i, new Range(range.source(), range.value(), range.lower(), range.includeLower(), range.upper(), true));\n+                        updated = true;\n+                    } else if (lowerComp != null && upperComp != null) {\n+                        if (0 < lowerComp && upperComp < 0) { // a = 2 OR 1 < a < 3\n+                            iterEq.remove(); // equality is superfluous\n+                            updated = true;\n+                        }\n+                    }\n+                }\n+\n+                // Equals OR Inequality\n+                for (int i = 0; i < frInequalities.size(); i ++) {\n+                    BinaryComparison bc = frInequalities.get(i);\n+                    if (! eq.left().semanticEquals(bc.left())) {\n+                        continue;\n+                    }\n+\n+                    Integer comp = BinaryComparison.compare(eqValue, bc.right().fold());\n+                    if (comp == null) {\n+                        continue;\n+                    }\n+                    if (bc instanceof GreaterThan || bc instanceof GreaterThanOrEqual) {\n+                        if (comp < 0) { // a = 1 OR a > 2 -> nop\n+                            continue;\n+                        } else if (comp == 0 && bc instanceof GreaterThan) { // a = 2 OR a > 2 -> a >= 2\n+                                frInequalities.set(i, new GreaterThanOrEqual(bc.source(), bc.left(), bc.right()));\n+                        } // else (0 < comp) : // a = 3 OR a > 2 -> a > 2", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59bb2584aa67496a9159b3e3fde0b4ea9bd24c39"}, "originalPosition": 259}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTI1MTkyOA==", "bodyText": "Can you, please, be consistent in the code format? The previous if branch used (comp < 0) and then else if. In this one you are switching places between variable and constant and there is no else.", "url": "https://github.com/elastic/elasticsearch/pull/50792#discussion_r365251928", "createdAt": "2020-01-10T14:13:57Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -1060,9 +1076,171 @@ private Expression propagate(And and) {\n                         changed = true;\n                     }\n                 }\n+\n+                // evaluate all NotEquals against the Equal\n+                for (Iterator<NotEquals> iter = frNotEquals.iterator(); iter.hasNext(); ) {\n+                    NotEquals neq = iter.next();\n+                    if (eq.left().semanticEquals(neq.left())) {\n+                        Integer comp = BinaryComparison.compare(eq.right().fold(), neq.right().fold());\n+                        if (comp != null) {\n+                            if (comp == 0) {\n+                                return FALSE; // clashing and conflicting: a = 1 AND a != 1\n+                            } else {\n+                                iter.remove(); // clashing and redundant: a = 1 AND a != 2\n+                                changed = true;\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                // evaluate all inequalities against the Equal\n+                for (Iterator<BinaryComparison> iter = frInequalities.iterator(); iter.hasNext(); ) {\n+                    BinaryComparison bc = iter.next();\n+                    if (! eq.left().semanticEquals(bc.left())) {\n+                        continue;\n+                    }\n+\n+                    Integer compare = BinaryComparison.compare(eqValue, bc.right().fold());\n+                    if (compare == null) {\n+                        continue;\n+                    }\n+\n+                    if (bc instanceof LessThan || bc instanceof LessThanOrEqual) { // a = 2 AND a </<= ?\n+                        if ((compare == 0 && bc instanceof LessThan) || // a = 2 AND a < 2\n+                            0 < compare) { // a = 2 AND a </<= 1\n+                            return FALSE;\n+                        }\n+                    } else if (bc instanceof GreaterThan || bc instanceof GreaterThanOrEqual) { // a = 2 AND a >/>= ?\n+                        if ((compare == 0 && bc instanceof GreaterThan) || // a = 2 AND a > 2\n+                            compare < 0) { // a = 2 AND a >/>= 3\n+                            return FALSE;\n+                        }\n+                    }\n+\n+                    iter.remove();\n+                    changed = true;\n+                }\n+            }\n+\n+            return changed ? Predicates.combineAnd(CollectionUtils.combine(exps, frEquals, frNotEquals, frInequalities, ranges)) : and;\n+        }\n+\n+        // combine disjunction:\n+        // a = 2 OR a > 3 -> nop; a = 2 OR a > 1 -> a > 1\n+        // a = 2 OR a < 3 -> a < 3; a = 2 OR a < 1 -> nop\n+        // a = 2 OR 3 < a < 5 -> nop; a = 2 OR 1 < a < 3 -> 1 < a < 3; a = 2 OR 0 < a < 1 -> nop\n+        // a = 2 OR a != 5 -> TRUE; a = 2 OR a = 5 -> nop\n+        private Expression propagate(Or or) {\n+            List<Expression> exps = new ArrayList<>();\n+            List<Equals> frEquals = new ArrayList<>(); // foldable right term Equals\n+            List<NotEquals> frNotEquals = new ArrayList<>(); // foldable right term NotEquals\n+            List<Range> ranges = new ArrayList<>();\n+            List<BinaryComparison> frInequalities = new ArrayList<>(); // foldable right term (=limit) BinaryComparision\n+\n+            // split expressions by type\n+            for (Expression ex : Predicates.splitOr(or)) {\n+                if (ex instanceof Equals) {\n+                    Equals eq = (Equals) ex;\n+                    if (eq.right().foldable()) {\n+                        frEquals.add(eq);\n+                    } else {\n+                        exps.add(ex);\n+                    }\n+                } else if (ex instanceof NotEquals) {\n+                    NotEquals neq = (NotEquals) ex;\n+                    if (neq.right().foldable()) {\n+                        frNotEquals.add(neq);\n+                    } else {\n+                        exps.add(ex);\n+                    }\n+                } else if (ex instanceof Range) {\n+                    ranges.add((Range) ex);\n+                } else if (ex instanceof BinaryComparison) {\n+                    BinaryComparison bc = (BinaryComparison) ex;\n+                    if (bc.right().foldable()) {\n+                        frInequalities.add(bc);\n+                    } else {\n+                        exps.add(ex);\n+                    }\n+                } else {\n+                    exps.add(ex);\n+                }\n+            }\n+\n+            boolean updated = false; // has the expression been modified?\n+\n+            // evaluate the impact of each Equal over the different types of Expressions\n+            for (Iterator<Equals> iterEq = frEquals.iterator(); iterEq.hasNext(); ) {\n+                Equals eq = iterEq.next();\n+\n+                // Equals OR NotEquals\n+                for (NotEquals neq : frNotEquals) {\n+                    if (eq.left().semanticEquals(neq.left())) { // a = 2 OR a != ? -> TRUE\n+                        return TRUE;\n+                    }\n+                }\n+\n+                Object eqValue = eq.right().fold();\n+\n+                // Equals OR Range\n+                for (int i = 0; i < ranges.size(); i ++) { // might modify list, so use index loop\n+                    Range range = ranges.get(i);\n+                    if (! eq.left().semanticEquals(range.value())) {\n+                        continue;\n+                    }\n+\n+                    Integer lowerComp = range.lower().foldable() ? BinaryComparison.compare(eqValue, range.lower().fold()) : null;\n+                    Integer upperComp = range.upper().foldable() ? BinaryComparison.compare(eqValue, range.upper().fold()) : null;\n+\n+                    if (lowerComp != null && lowerComp == 0 && !range.includeLower()) { // a = 2 OR 2 < a < ? -> 2 <= a < ?\n+                        iterEq.remove(); // update range with lower equality instead\n+                        ranges.set(i, new Range(range.source(), range.value(), range.lower(), true, range.upper(), range.includeUpper()));\n+                        updated = true;\n+                    } else if (upperComp != null && upperComp == 0 && !range.includeUpper()) { // a = 2 OR ? < a < 2 -> ? < a <= 2\n+                        iterEq.remove(); // update range with upper equality instead\n+                        ranges.set(i, new Range(range.source(), range.value(), range.lower(), range.includeLower(), range.upper(), true));\n+                        updated = true;\n+                    } else if (lowerComp != null && upperComp != null) {\n+                        if (0 < lowerComp && upperComp < 0) { // a = 2 OR 1 < a < 3\n+                            iterEq.remove(); // equality is superfluous\n+                            updated = true;\n+                        }\n+                    }\n+                }\n+\n+                // Equals OR Inequality\n+                for (int i = 0; i < frInequalities.size(); i ++) {\n+                    BinaryComparison bc = frInequalities.get(i);\n+                    if (! eq.left().semanticEquals(bc.left())) {\n+                        continue;\n+                    }\n+\n+                    Integer comp = BinaryComparison.compare(eqValue, bc.right().fold());\n+                    if (comp == null) {\n+                        continue;\n+                    }\n+                    if (bc instanceof GreaterThan || bc instanceof GreaterThanOrEqual) {\n+                        if (comp < 0) { // a = 1 OR a > 2 -> nop\n+                            continue;\n+                        } else if (comp == 0 && bc instanceof GreaterThan) { // a = 2 OR a > 2 -> a >= 2\n+                                frInequalities.set(i, new GreaterThanOrEqual(bc.source(), bc.left(), bc.right()));\n+                        } // else (0 < comp) : // a = 3 OR a > 2 -> a > 2\n+                        iterEq.remove(); // update range with equality instead or simply superfluous\n+                        updated = true;\n+                    } else if (bc instanceof LessThan || bc instanceof LessThanOrEqual) {\n+                        if (0 < comp) { // a = 2 OR a < 1 -> nop", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59bb2584aa67496a9159b3e3fde0b4ea9bd24c39"}, "originalPosition": 263}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTI1MjIxMA==", "bodyText": "updated == true ? Predicates.....", "url": "https://github.com/elastic/elasticsearch/pull/50792#discussion_r365252210", "createdAt": "2020-01-10T14:14:37Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -1060,9 +1076,171 @@ private Expression propagate(And and) {\n                         changed = true;\n                     }\n                 }\n+\n+                // evaluate all NotEquals against the Equal\n+                for (Iterator<NotEquals> iter = frNotEquals.iterator(); iter.hasNext(); ) {\n+                    NotEquals neq = iter.next();\n+                    if (eq.left().semanticEquals(neq.left())) {\n+                        Integer comp = BinaryComparison.compare(eq.right().fold(), neq.right().fold());\n+                        if (comp != null) {\n+                            if (comp == 0) {\n+                                return FALSE; // clashing and conflicting: a = 1 AND a != 1\n+                            } else {\n+                                iter.remove(); // clashing and redundant: a = 1 AND a != 2\n+                                changed = true;\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                // evaluate all inequalities against the Equal\n+                for (Iterator<BinaryComparison> iter = frInequalities.iterator(); iter.hasNext(); ) {\n+                    BinaryComparison bc = iter.next();\n+                    if (! eq.left().semanticEquals(bc.left())) {\n+                        continue;\n+                    }\n+\n+                    Integer compare = BinaryComparison.compare(eqValue, bc.right().fold());\n+                    if (compare == null) {\n+                        continue;\n+                    }\n+\n+                    if (bc instanceof LessThan || bc instanceof LessThanOrEqual) { // a = 2 AND a </<= ?\n+                        if ((compare == 0 && bc instanceof LessThan) || // a = 2 AND a < 2\n+                            0 < compare) { // a = 2 AND a </<= 1\n+                            return FALSE;\n+                        }\n+                    } else if (bc instanceof GreaterThan || bc instanceof GreaterThanOrEqual) { // a = 2 AND a >/>= ?\n+                        if ((compare == 0 && bc instanceof GreaterThan) || // a = 2 AND a > 2\n+                            compare < 0) { // a = 2 AND a >/>= 3\n+                            return FALSE;\n+                        }\n+                    }\n+\n+                    iter.remove();\n+                    changed = true;\n+                }\n+            }\n+\n+            return changed ? Predicates.combineAnd(CollectionUtils.combine(exps, frEquals, frNotEquals, frInequalities, ranges)) : and;\n+        }\n+\n+        // combine disjunction:\n+        // a = 2 OR a > 3 -> nop; a = 2 OR a > 1 -> a > 1\n+        // a = 2 OR a < 3 -> a < 3; a = 2 OR a < 1 -> nop\n+        // a = 2 OR 3 < a < 5 -> nop; a = 2 OR 1 < a < 3 -> 1 < a < 3; a = 2 OR 0 < a < 1 -> nop\n+        // a = 2 OR a != 5 -> TRUE; a = 2 OR a = 5 -> nop\n+        private Expression propagate(Or or) {\n+            List<Expression> exps = new ArrayList<>();\n+            List<Equals> frEquals = new ArrayList<>(); // foldable right term Equals\n+            List<NotEquals> frNotEquals = new ArrayList<>(); // foldable right term NotEquals\n+            List<Range> ranges = new ArrayList<>();\n+            List<BinaryComparison> frInequalities = new ArrayList<>(); // foldable right term (=limit) BinaryComparision\n+\n+            // split expressions by type\n+            for (Expression ex : Predicates.splitOr(or)) {\n+                if (ex instanceof Equals) {\n+                    Equals eq = (Equals) ex;\n+                    if (eq.right().foldable()) {\n+                        frEquals.add(eq);\n+                    } else {\n+                        exps.add(ex);\n+                    }\n+                } else if (ex instanceof NotEquals) {\n+                    NotEquals neq = (NotEquals) ex;\n+                    if (neq.right().foldable()) {\n+                        frNotEquals.add(neq);\n+                    } else {\n+                        exps.add(ex);\n+                    }\n+                } else if (ex instanceof Range) {\n+                    ranges.add((Range) ex);\n+                } else if (ex instanceof BinaryComparison) {\n+                    BinaryComparison bc = (BinaryComparison) ex;\n+                    if (bc.right().foldable()) {\n+                        frInequalities.add(bc);\n+                    } else {\n+                        exps.add(ex);\n+                    }\n+                } else {\n+                    exps.add(ex);\n+                }\n+            }\n+\n+            boolean updated = false; // has the expression been modified?\n+\n+            // evaluate the impact of each Equal over the different types of Expressions\n+            for (Iterator<Equals> iterEq = frEquals.iterator(); iterEq.hasNext(); ) {\n+                Equals eq = iterEq.next();\n+\n+                // Equals OR NotEquals\n+                for (NotEquals neq : frNotEquals) {\n+                    if (eq.left().semanticEquals(neq.left())) { // a = 2 OR a != ? -> TRUE\n+                        return TRUE;\n+                    }\n+                }\n+\n+                Object eqValue = eq.right().fold();\n+\n+                // Equals OR Range\n+                for (int i = 0; i < ranges.size(); i ++) { // might modify list, so use index loop\n+                    Range range = ranges.get(i);\n+                    if (! eq.left().semanticEquals(range.value())) {\n+                        continue;\n+                    }\n+\n+                    Integer lowerComp = range.lower().foldable() ? BinaryComparison.compare(eqValue, range.lower().fold()) : null;\n+                    Integer upperComp = range.upper().foldable() ? BinaryComparison.compare(eqValue, range.upper().fold()) : null;\n+\n+                    if (lowerComp != null && lowerComp == 0 && !range.includeLower()) { // a = 2 OR 2 < a < ? -> 2 <= a < ?\n+                        iterEq.remove(); // update range with lower equality instead\n+                        ranges.set(i, new Range(range.source(), range.value(), range.lower(), true, range.upper(), range.includeUpper()));\n+                        updated = true;\n+                    } else if (upperComp != null && upperComp == 0 && !range.includeUpper()) { // a = 2 OR ? < a < 2 -> ? < a <= 2\n+                        iterEq.remove(); // update range with upper equality instead\n+                        ranges.set(i, new Range(range.source(), range.value(), range.lower(), range.includeLower(), range.upper(), true));\n+                        updated = true;\n+                    } else if (lowerComp != null && upperComp != null) {\n+                        if (0 < lowerComp && upperComp < 0) { // a = 2 OR 1 < a < 3\n+                            iterEq.remove(); // equality is superfluous\n+                            updated = true;\n+                        }\n+                    }\n+                }\n+\n+                // Equals OR Inequality\n+                for (int i = 0; i < frInequalities.size(); i ++) {\n+                    BinaryComparison bc = frInequalities.get(i);\n+                    if (! eq.left().semanticEquals(bc.left())) {\n+                        continue;\n+                    }\n+\n+                    Integer comp = BinaryComparison.compare(eqValue, bc.right().fold());\n+                    if (comp == null) {\n+                        continue;\n+                    }\n+                    if (bc instanceof GreaterThan || bc instanceof GreaterThanOrEqual) {\n+                        if (comp < 0) { // a = 1 OR a > 2 -> nop\n+                            continue;\n+                        } else if (comp == 0 && bc instanceof GreaterThan) { // a = 2 OR a > 2 -> a >= 2\n+                                frInequalities.set(i, new GreaterThanOrEqual(bc.source(), bc.left(), bc.right()));\n+                        } // else (0 < comp) : // a = 3 OR a > 2 -> a > 2\n+                        iterEq.remove(); // update range with equality instead or simply superfluous\n+                        updated = true;\n+                    } else if (bc instanceof LessThan || bc instanceof LessThanOrEqual) {\n+                        if (0 < comp) { // a = 2 OR a < 1 -> nop\n+                            continue;\n+                        }\n+                        if (comp == 0 && bc instanceof LessThan) { // a = 2 OR a < 2 -> a <= 2\n+                            frInequalities.set(i, new LessThanOrEqual(bc.source(), bc.left(), bc.right()));\n+                        } // else (comp < 0) { // a = 2 OR a < 3 -> a < 3\n+                        iterEq.remove(); // update range with equality instead or simply superfluous\n+                        updated = true;\n+                    }\n+                }\n             }\n \n-            return changed ? Predicates.combineAnd(CollectionUtils.combine(exps, equals, ranges)) : and;\n+            return updated ? Predicates.combineOr(CollectionUtils.combine(exps, frEquals, frNotEquals, frInequalities, ranges)) : or;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59bb2584aa67496a9159b3e3fde0b4ea9bd24c39"}, "originalPosition": 276}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3eee6ca7fe483d89a73ec2bcd643127abf6f3b63", "author": {"user": {"login": "bpintea", "name": "Bogdan Pintea"}}, "url": "https://github.com/elastic/elasticsearch/commit/3eee6ca7fe483d89a73ec2bcd643127abf6f3b63", "committedDate": "2020-01-10T18:58:58Z", "message": "Adress review notes\n\n* Fix the bug around wrongly optimizing 'a=2 OR a!=?', which only yields\nTRUE for same values in equality and inequality.\n* Var renamings, code style adjustments, comments corrections."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQxNjc4MzU1", "url": "https://github.com/elastic/elasticsearch/pull/50792#pullrequestreview-341678355", "createdAt": "2020-01-13T08:07:52Z", "commit": {"oid": "3eee6ca7fe483d89a73ec2bcd643127abf6f3b63"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "55da0357054b1d2e25a15f41fe5d5267bdf7d106", "author": {"user": {"login": "bpintea", "name": "Bogdan Pintea"}}, "url": "https://github.com/elastic/elasticsearch/commit/55da0357054b1d2e25a15f41fe5d5267bdf7d106", "committedDate": "2020-01-13T14:47:24Z", "message": "Address further review comments. Extend optim.\n\n- fix a few code comments;\n- extend the Equals OR NotEquals optimitsation (a=2 OR a!=5 -> a!=5);\n- extend the Equals OR Range optimisation on limits equality (a=2 OR\n  2<=a<5 -> 2<=a<5);\n- in case an equality is being removed in a conjunction, the rest of\n  possible optimisations to test is now skipped."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cab0248b3614842579f0222e45ae049349f220bf", "author": {"user": {"login": "bpintea", "name": "Bogdan Pintea"}}, "url": "https://github.com/elastic/elasticsearch/commit/cab0248b3614842579f0222e45ae049349f220bf", "committedDate": "2020-01-13T16:32:12Z", "message": "rename one var for better legiblity\n\n- s/rmEqual/removeEquals"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7755d1df079d2b230d7941be60fbd128c982770a", "author": {"user": {"login": "bpintea", "name": "Bogdan Pintea"}}, "url": "https://github.com/elastic/elasticsearch/commit/7755d1df079d2b230d7941be60fbd128c982770a", "committedDate": "2020-01-13T19:24:16Z", "message": "Merge remote-tracking branch 'upstream/master' into enh/propagate-equals-optimisations"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3699, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}