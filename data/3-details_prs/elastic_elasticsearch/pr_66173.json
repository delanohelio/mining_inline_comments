{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM1OTcyNjkw", "number": 66173, "title": "SearchableSnapshotDirectory should not evict cache files when closed", "bodyText": "This pull request changes the SearchableSnapshotDirectory so that it does not evict all its cache files at closing time, but instead delegates this work to the CacheService.\nThis change is motivated by:\n\nthe fact that Lucene directories are closed as the consequence of applying a new cluster state and as such the closing is executed within the cluster state applier thread; and we want to minimize disk IO operations in such thread (like deleting a lot of evicted cache files)\nthe future of the searchable snapshot cache which should become persistent\n\nThis change is built on top of the existing SearchableSnapshotIndexEventListener and a new SearchableSnapshotIndexFoldersDeletionListener (see #65926) that are used to detect when a searchable snapshot index (or searchable snapshot shard) is removed from a data node.\nWhen such a thing happens, the listeners notify the CacheService that maintains an internal list of removed shards. This list is used to evict the cache files associated to these shards as soon as possible (but not in the cluster state applier thread) or right before the same searchable snapshot shard is being built again on the same node.\nIn other situations like opening/closing a searchable snapshot shard then the cache files are not evicted anymore and should be reused.", "createdAt": "2020-12-10T14:23:09Z", "url": "https://github.com/elastic/elasticsearch/pull/66173", "merged": true, "mergeCommit": {"oid": "7e6b52a998ff6e0051f358f6dae9669e64b642e1"}, "closed": true, "closedAt": "2020-12-11T10:49:00Z", "author": {"login": "tlrx"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdkz3ISgH2gAyNTM1OTcyNjkwOmFlZWFiYzdlNDExMmQ1YjRmZDI4ZjQxY2M4MGI4YmU1MDg5ZDYyNDY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdlE-udAH2gAyNTM1OTcyNjkwOjAyYWE5YzkyODRmMGNlOTUwMDYyNDZkNjM2M2IxMGRlZjVlNGQ2YWQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "aeeabc7e4112d5b4fd28f41cc80b8be5089d6246", "author": {"user": {"login": "tlrx", "name": "Tanguy Leroux"}}, "url": "https://github.com/elastic/elasticsearch/commit/aeeabc7e4112d5b4fd28f41cc80b8be5089d6246", "committedDate": "2020-12-10T14:03:53Z", "message": "Use listeners to manage cache files associated with removed shards"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c1a6e9cc7cb9f4fb13b53bbb4f4b10d07241b37", "author": {"user": {"login": "tlrx", "name": "Tanguy Leroux"}}, "url": "https://github.com/elastic/elasticsearch/commit/6c1a6e9cc7cb9f4fb13b53bbb4f4b10d07241b37", "committedDate": "2020-12-10T15:17:42Z", "message": "Merge branch 'master' into use-listeners-to-manage-cache-files-for-removed-shards"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5MzA2NjI3", "url": "https://github.com/elastic/elasticsearch/pull/66173#pullrequestreview-549306627", "createdAt": "2020-12-10T15:21:40Z", "commit": {"oid": "6c1a6e9cc7cb9f4fb13b53bbb4f4b10d07241b37"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxNToyMTo0MVrOIDOlnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxNTo0ODozNFrOIDP9zg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI1NTY0NQ==", "bodyText": "Would holding the readLock not be enough?", "url": "https://github.com/elastic/elasticsearch/pull/66173#discussion_r540255645", "createdAt": "2020-12-10T15:21:41Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/common/cache/Cache.java", "diffHunk": "@@ -650,6 +651,31 @@ public void remove() {\n         };\n     }\n \n+    /**\n+     * Performs an action for each cache entry in the cache. While iterating over the cache entries this method is protected from mutations\n+     * that occurs within the same cache segment by acquiring the segment's writing lock during all the iteration. As such, the specified\n+     * consumer should not try to modify the cache. Modifications that occur in already traveled segments won't been seen by the consumer\n+     * but modification that occur in non yet traveled segments should be.\n+     *\n+     * @param consumer the {@link Consumer}\n+     */\n+    public void forEach(BiConsumer<K, V> consumer) {\n+        for (CacheSegment<K, V> segment : segments) {\n+            try (ReleasableLock ignored = segment.writeLock.acquire()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c1a6e9cc7cb9f4fb13b53bbb4f4b10d07241b37"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI3NzMxNA==", "bodyText": "I am not sure this is necessary. When cache.invalidate fails, it already removed the object from the map, so if we retry an eviction, it will not hit the shard anyway.\nSo if we can remove this, I think we can also drop the shardsEvictionLock, which makes markShardAsEvictedInCache safer wrt. being called from the cluster applier thread.", "url": "https://github.com/elastic/elasticsearch/pull/66173#discussion_r540277314", "createdAt": "2020-12-10T15:47:24Z", "author": {"login": "henningandersen"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/cache/CacheService.java", "diffHunk": "@@ -277,6 +290,88 @@ public void removeFromCache(final CacheKey cacheKey) {\n         cache.invalidate(cacheKey);\n     }\n \n+    /**\n+     * Marks the specified searchable snapshot shard as evicted in cache. Cache files associated with this shard will be evicted from cache.\n+     *\n+     * @param snapshotId the {@link SnapshotId}\n+     * @param indexId the {@link SnapshotId}\n+     * @param shardId the {@link SnapshotId}\n+     */\n+    public void markShardAsEvictedInCache(SnapshotId snapshotId, IndexId indexId, ShardId shardId) {\n+        boolean markedAsEvicted = false;\n+        final ShardEviction shardEviction = new ShardEviction(snapshotId, indexId, shardId);\n+        try (Releasable ignored = shardsEvictionLock.acquire(shardEviction)) {\n+            if (evictedShards.add(shardEviction)) {\n+                markedAsEvicted = true;\n+            }\n+        }\n+        if (markedAsEvicted) {\n+            threadPool.generic().submit(new AbstractRunnable() {\n+                @Override\n+                protected void doRun() {\n+                    runIfShardMarkedAsEvictedInCache(shardEviction, () -> {\n+                        assert shardsEvictionLock.isHeldByCurrentThread(shardEviction);\n+                        final Map<CacheKey, CacheFile> cacheFilesToEvict = new HashMap<>();\n+                        cache.forEach((cacheKey, cacheFile) -> {\n+                            if (shardEviction.matches(cacheKey)) {\n+                                cacheFilesToEvict.put(cacheKey, cacheFile);\n+                            }\n+                        });\n+                        if (cacheFilesToEvict.isEmpty() == false) {\n+                            cacheFilesToEvict.forEach(cache::invalidate);\n+                        }\n+                    });\n+                }\n+\n+                @Override\n+                public void onFailure(Exception e) {\n+                    logger.warn(\n+                        () -> new ParameterizedMessage(\"failed to evict cache files associated with evicted shard {}\", shardEviction),\n+                        e\n+                    );\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Allows to run the specified {@link Runnable} if the shard represented by the triplet ({@link SnapshotId}, {@link IndexId},\n+     * {@link SnapshotId}) is still marked as evicted at the time this method is executed. The @link Runnable} will be executed\n+     * while the current thread is holding the lock associated to the shard.\n+     *\n+     * @param snapshotId the snapshot the evicted searchable snapshots shard belongs to\n+     * @param indexId    the index in the snapshot the evicted searchable snapshots shard belongs to\n+     * @param shardId    the searchable snapshots shard id\n+     * @param runnable   a runnable to execute\n+     */\n+    public void runIfShardMarkedAsEvictedInCache(SnapshotId snapshotId, IndexId indexId, ShardId shardId, Runnable runnable) {\n+        runIfShardMarkedAsEvictedInCache(new ShardEviction(snapshotId, indexId, shardId), runnable);\n+    }\n+\n+    /**\n+     * Allows to run the specified {@link Runnable} if the shard represented by {@link ShardEviction} is still marked as evicted at the time\n+     * this method is executed. The @link Runnable} will be executed while the current thread is holding the lock associated to the shard.\n+     *\n+     * @param shardEviction a {@link ShardEviction} representing the shard marked as evicted\n+     * @param runnable      a runnable to execute\n+     */\n+    private void runIfShardMarkedAsEvictedInCache(ShardEviction shardEviction, Runnable runnable) {\n+        try (Releasable ignored = shardsEvictionLock.acquire(shardEviction)) {\n+            boolean success = false;\n+            try {\n+                if (evictedShards.remove(shardEviction)) {\n+                    runnable.run();\n+                }\n+                success = true;\n+            } finally {\n+                if (success == false) {\n+                    final boolean added = evictedShards.add(shardEviction);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c1a6e9cc7cb9f4fb13b53bbb4f4b10d07241b37"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI3ODIyMg==", "bodyText": "Perhaps we need to catch exception here and assert that they are io-related, write a warning and then continue with the next file? That ensures we remove all cache files from the cache in one go, but may linger some files if there are io-issues.", "url": "https://github.com/elastic/elasticsearch/pull/66173#discussion_r540278222", "createdAt": "2020-12-10T15:48:34Z", "author": {"login": "henningandersen"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/cache/CacheService.java", "diffHunk": "@@ -277,6 +290,88 @@ public void removeFromCache(final CacheKey cacheKey) {\n         cache.invalidate(cacheKey);\n     }\n \n+    /**\n+     * Marks the specified searchable snapshot shard as evicted in cache. Cache files associated with this shard will be evicted from cache.\n+     *\n+     * @param snapshotId the {@link SnapshotId}\n+     * @param indexId the {@link SnapshotId}\n+     * @param shardId the {@link SnapshotId}\n+     */\n+    public void markShardAsEvictedInCache(SnapshotId snapshotId, IndexId indexId, ShardId shardId) {\n+        boolean markedAsEvicted = false;\n+        final ShardEviction shardEviction = new ShardEviction(snapshotId, indexId, shardId);\n+        try (Releasable ignored = shardsEvictionLock.acquire(shardEviction)) {\n+            if (evictedShards.add(shardEviction)) {\n+                markedAsEvicted = true;\n+            }\n+        }\n+        if (markedAsEvicted) {\n+            threadPool.generic().submit(new AbstractRunnable() {\n+                @Override\n+                protected void doRun() {\n+                    runIfShardMarkedAsEvictedInCache(shardEviction, () -> {\n+                        assert shardsEvictionLock.isHeldByCurrentThread(shardEviction);\n+                        final Map<CacheKey, CacheFile> cacheFilesToEvict = new HashMap<>();\n+                        cache.forEach((cacheKey, cacheFile) -> {\n+                            if (shardEviction.matches(cacheKey)) {\n+                                cacheFilesToEvict.put(cacheKey, cacheFile);\n+                            }\n+                        });\n+                        if (cacheFilesToEvict.isEmpty() == false) {\n+                            cacheFilesToEvict.forEach(cache::invalidate);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c1a6e9cc7cb9f4fb13b53bbb4f4b10d07241b37"}, "originalPosition": 84}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "58b7bd9a919cd99f2fffede93e7580879c600299", "author": {"user": {"login": "tlrx", "name": "Tanguy Leroux"}}, "url": "https://github.com/elastic/elasticsearch/commit/58b7bd9a919cd99f2fffede93e7580879c600299", "committedDate": "2020-12-10T19:34:32Z", "message": "invalidate single cache file"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "082e0c8342c85bf476ecec958a08e69cedac5d43", "author": {"user": {"login": "tlrx", "name": "Tanguy Leroux"}}, "url": "https://github.com/elastic/elasticsearch/commit/082e0c8342c85bf476ecec958a08e69cedac5d43", "committedDate": "2020-12-10T19:36:02Z", "message": "readLock"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "393deaf6621cc2fd7650fc946f1344a0f3bd53d9", "author": {"user": {"login": "tlrx", "name": "Tanguy Leroux"}}, "url": "https://github.com/elastic/elasticsearch/commit/393deaf6621cc2fd7650fc946f1344a0f3bd53d9", "committedDate": "2020-12-10T19:54:20Z", "message": "simplify markShardAsEvictedInCache"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1555ce5b8aeed6a9501847c32b724d3d66acfa80", "author": {"user": {"login": "tlrx", "name": "Tanguy Leroux"}}, "url": "https://github.com/elastic/elasticsearch/commit/1555ce5b8aeed6a9501847c32b724d3d66acfa80", "committedDate": "2020-12-10T20:23:48Z", "message": "fix messed up imports"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c1c9e543ca083ef0356fece7319f540d3431aa02", "author": {"user": {"login": "tlrx", "name": "Tanguy Leroux"}}, "url": "https://github.com/elastic/elasticsearch/commit/c1c9e543ca083ef0356fece7319f540d3431aa02", "committedDate": "2020-12-10T20:24:10Z", "message": "Merge branch 'master' into use-listeners-to-manage-cache-files-for-removed-shards"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5ODQwODcz", "url": "https://github.com/elastic/elasticsearch/pull/66173#pullrequestreview-549840873", "createdAt": "2020-12-11T06:54:17Z", "commit": {"oid": "c1c9e543ca083ef0356fece7319f540d3431aa02"}, "state": "APPROVED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQwNjo1NDoxN1rOIDrhMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQwNzoxOTowMVrOIDsFlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDcyOTY1MA==", "bodyText": "nit: this check seems superfluous?", "url": "https://github.com/elastic/elasticsearch/pull/66173#discussion_r540729650", "createdAt": "2020-12-11T06:54:17Z", "author": {"login": "henningandersen"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/cache/CacheService.java", "diffHunk": "@@ -277,6 +290,89 @@ public void removeFromCache(final CacheKey cacheKey) {\n         cache.invalidate(cacheKey);\n     }\n \n+    /**\n+     * Marks the specified searchable snapshot shard as evicted in cache. Cache files associated with this shard will be evicted from cache.\n+     *\n+     * @param snapshotId the {@link SnapshotId}\n+     * @param indexId the {@link SnapshotId}\n+     * @param shardId the {@link SnapshotId}\n+     */\n+    public void markShardAsEvictedInCache(SnapshotId snapshotId, IndexId indexId, ShardId shardId) {\n+        final ShardEviction shardEviction = new ShardEviction(snapshotId, indexId, shardId);\n+        if (evictedShards.add(shardEviction)) {\n+            threadPool.generic().submit(new AbstractRunnable() {\n+                @Override\n+                protected void doRun() {\n+                    runIfShardMarkedAsEvictedInCache(shardEviction, () -> {\n+                        assert shardsEvictionLock.isHeldByCurrentThread(shardEviction);\n+                        final Map<CacheKey, CacheFile> cacheFilesToEvict = new HashMap<>();\n+                        cache.forEach((cacheKey, cacheFile) -> {\n+                            if (shardEviction.matches(cacheKey)) {\n+                                cacheFilesToEvict.put(cacheKey, cacheFile);\n+                            }\n+                        });\n+                        if (cacheFilesToEvict.isEmpty() == false) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1c9e543ca083ef0356fece7319f540d3431aa02"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDczMTExOQ==", "bodyText": "Can we just catch RuntimeException instead, since invalidate declares to not throw checked?", "url": "https://github.com/elastic/elasticsearch/pull/66173#discussion_r540731119", "createdAt": "2020-12-11T06:58:12Z", "author": {"login": "henningandersen"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/cache/CacheService.java", "diffHunk": "@@ -277,6 +290,89 @@ public void removeFromCache(final CacheKey cacheKey) {\n         cache.invalidate(cacheKey);\n     }\n \n+    /**\n+     * Marks the specified searchable snapshot shard as evicted in cache. Cache files associated with this shard will be evicted from cache.\n+     *\n+     * @param snapshotId the {@link SnapshotId}\n+     * @param indexId the {@link SnapshotId}\n+     * @param shardId the {@link SnapshotId}\n+     */\n+    public void markShardAsEvictedInCache(SnapshotId snapshotId, IndexId indexId, ShardId shardId) {\n+        final ShardEviction shardEviction = new ShardEviction(snapshotId, indexId, shardId);\n+        if (evictedShards.add(shardEviction)) {\n+            threadPool.generic().submit(new AbstractRunnable() {\n+                @Override\n+                protected void doRun() {\n+                    runIfShardMarkedAsEvictedInCache(shardEviction, () -> {\n+                        assert shardsEvictionLock.isHeldByCurrentThread(shardEviction);\n+                        final Map<CacheKey, CacheFile> cacheFilesToEvict = new HashMap<>();\n+                        cache.forEach((cacheKey, cacheFile) -> {\n+                            if (shardEviction.matches(cacheKey)) {\n+                                cacheFilesToEvict.put(cacheKey, cacheFile);\n+                            }\n+                        });\n+                        if (cacheFilesToEvict.isEmpty() == false) {\n+                            for (Map.Entry<CacheKey, CacheFile> cacheFile : cacheFilesToEvict.entrySet()) {\n+                                try {\n+                                    cache.invalidate(cacheFile.getKey(), cacheFile.getValue());\n+                                } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1c9e543ca083ef0356fece7319f540d3431aa02"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDczMTM2Nw==", "bodyText": "Looking closer at this, I suppose this should never happen since we catch IO exceptions in onCacheFileRemoval, so we could just assert false : e here instead?", "url": "https://github.com/elastic/elasticsearch/pull/66173#discussion_r540731367", "createdAt": "2020-12-11T06:59:01Z", "author": {"login": "henningandersen"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/cache/CacheService.java", "diffHunk": "@@ -277,6 +290,89 @@ public void removeFromCache(final CacheKey cacheKey) {\n         cache.invalidate(cacheKey);\n     }\n \n+    /**\n+     * Marks the specified searchable snapshot shard as evicted in cache. Cache files associated with this shard will be evicted from cache.\n+     *\n+     * @param snapshotId the {@link SnapshotId}\n+     * @param indexId the {@link SnapshotId}\n+     * @param shardId the {@link SnapshotId}\n+     */\n+    public void markShardAsEvictedInCache(SnapshotId snapshotId, IndexId indexId, ShardId shardId) {\n+        final ShardEviction shardEviction = new ShardEviction(snapshotId, indexId, shardId);\n+        if (evictedShards.add(shardEviction)) {\n+            threadPool.generic().submit(new AbstractRunnable() {\n+                @Override\n+                protected void doRun() {\n+                    runIfShardMarkedAsEvictedInCache(shardEviction, () -> {\n+                        assert shardsEvictionLock.isHeldByCurrentThread(shardEviction);\n+                        final Map<CacheKey, CacheFile> cacheFilesToEvict = new HashMap<>();\n+                        cache.forEach((cacheKey, cacheFile) -> {\n+                            if (shardEviction.matches(cacheKey)) {\n+                                cacheFilesToEvict.put(cacheKey, cacheFile);\n+                            }\n+                        });\n+                        if (cacheFilesToEvict.isEmpty() == false) {\n+                            for (Map.Entry<CacheKey, CacheFile> cacheFile : cacheFilesToEvict.entrySet()) {\n+                                try {\n+                                    cache.invalidate(cacheFile.getKey(), cacheFile.getValue());\n+                                } catch (Exception e) {\n+                                    assert e instanceof IOException : e;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1c9e543ca083ef0356fece7319f540d3431aa02"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDczMTYwOQ==", "bodyText": "I think we could also assert false : e here?", "url": "https://github.com/elastic/elasticsearch/pull/66173#discussion_r540731609", "createdAt": "2020-12-11T06:59:41Z", "author": {"login": "henningandersen"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/cache/CacheService.java", "diffHunk": "@@ -277,6 +290,89 @@ public void removeFromCache(final CacheKey cacheKey) {\n         cache.invalidate(cacheKey);\n     }\n \n+    /**\n+     * Marks the specified searchable snapshot shard as evicted in cache. Cache files associated with this shard will be evicted from cache.\n+     *\n+     * @param snapshotId the {@link SnapshotId}\n+     * @param indexId the {@link SnapshotId}\n+     * @param shardId the {@link SnapshotId}\n+     */\n+    public void markShardAsEvictedInCache(SnapshotId snapshotId, IndexId indexId, ShardId shardId) {\n+        final ShardEviction shardEviction = new ShardEviction(snapshotId, indexId, shardId);\n+        if (evictedShards.add(shardEviction)) {\n+            threadPool.generic().submit(new AbstractRunnable() {\n+                @Override\n+                protected void doRun() {\n+                    runIfShardMarkedAsEvictedInCache(shardEviction, () -> {\n+                        assert shardsEvictionLock.isHeldByCurrentThread(shardEviction);\n+                        final Map<CacheKey, CacheFile> cacheFilesToEvict = new HashMap<>();\n+                        cache.forEach((cacheKey, cacheFile) -> {\n+                            if (shardEviction.matches(cacheKey)) {\n+                                cacheFilesToEvict.put(cacheKey, cacheFile);\n+                            }\n+                        });\n+                        if (cacheFilesToEvict.isEmpty() == false) {\n+                            for (Map.Entry<CacheKey, CacheFile> cacheFile : cacheFilesToEvict.entrySet()) {\n+                                try {\n+                                    cache.invalidate(cacheFile.getKey(), cacheFile.getValue());\n+                                } catch (Exception e) {\n+                                    assert e instanceof IOException : e;\n+                                    logger.warn(() -> new ParameterizedMessage(\"failed to evict cache file {}\", cacheFile.getKey()), e);\n+                                }\n+                            }\n+                        }\n+                    });\n+                }\n+\n+                @Override\n+                public void onFailure(Exception e) {\n+                    logger.warn(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1c9e543ca083ef0356fece7319f540d3431aa02"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDczODk2NQ==", "bodyText": "I think the locks could be removed with some restructure, but we can tackle that in a follow-up, it is not really important.\nHowever, if we add to evictedShards here while running the job on the thread, I think we risk it leaking since nothing will remove it later? I think we should assert success here. AFAICS, there is no way this should fail unless there is a bug somewhere.", "url": "https://github.com/elastic/elasticsearch/pull/66173#discussion_r540738965", "createdAt": "2020-12-11T07:19:01Z", "author": {"login": "henningandersen"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/cache/CacheService.java", "diffHunk": "@@ -277,6 +290,88 @@ public void removeFromCache(final CacheKey cacheKey) {\n         cache.invalidate(cacheKey);\n     }\n \n+    /**\n+     * Marks the specified searchable snapshot shard as evicted in cache. Cache files associated with this shard will be evicted from cache.\n+     *\n+     * @param snapshotId the {@link SnapshotId}\n+     * @param indexId the {@link SnapshotId}\n+     * @param shardId the {@link SnapshotId}\n+     */\n+    public void markShardAsEvictedInCache(SnapshotId snapshotId, IndexId indexId, ShardId shardId) {\n+        boolean markedAsEvicted = false;\n+        final ShardEviction shardEviction = new ShardEviction(snapshotId, indexId, shardId);\n+        try (Releasable ignored = shardsEvictionLock.acquire(shardEviction)) {\n+            if (evictedShards.add(shardEviction)) {\n+                markedAsEvicted = true;\n+            }\n+        }\n+        if (markedAsEvicted) {\n+            threadPool.generic().submit(new AbstractRunnable() {\n+                @Override\n+                protected void doRun() {\n+                    runIfShardMarkedAsEvictedInCache(shardEviction, () -> {\n+                        assert shardsEvictionLock.isHeldByCurrentThread(shardEviction);\n+                        final Map<CacheKey, CacheFile> cacheFilesToEvict = new HashMap<>();\n+                        cache.forEach((cacheKey, cacheFile) -> {\n+                            if (shardEviction.matches(cacheKey)) {\n+                                cacheFilesToEvict.put(cacheKey, cacheFile);\n+                            }\n+                        });\n+                        if (cacheFilesToEvict.isEmpty() == false) {\n+                            cacheFilesToEvict.forEach(cache::invalidate);\n+                        }\n+                    });\n+                }\n+\n+                @Override\n+                public void onFailure(Exception e) {\n+                    logger.warn(\n+                        () -> new ParameterizedMessage(\"failed to evict cache files associated with evicted shard {}\", shardEviction),\n+                        e\n+                    );\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Allows to run the specified {@link Runnable} if the shard represented by the triplet ({@link SnapshotId}, {@link IndexId},\n+     * {@link SnapshotId}) is still marked as evicted at the time this method is executed. The @link Runnable} will be executed\n+     * while the current thread is holding the lock associated to the shard.\n+     *\n+     * @param snapshotId the snapshot the evicted searchable snapshots shard belongs to\n+     * @param indexId    the index in the snapshot the evicted searchable snapshots shard belongs to\n+     * @param shardId    the searchable snapshots shard id\n+     * @param runnable   a runnable to execute\n+     */\n+    public void runIfShardMarkedAsEvictedInCache(SnapshotId snapshotId, IndexId indexId, ShardId shardId, Runnable runnable) {\n+        runIfShardMarkedAsEvictedInCache(new ShardEviction(snapshotId, indexId, shardId), runnable);\n+    }\n+\n+    /**\n+     * Allows to run the specified {@link Runnable} if the shard represented by {@link ShardEviction} is still marked as evicted at the time\n+     * this method is executed. The @link Runnable} will be executed while the current thread is holding the lock associated to the shard.\n+     *\n+     * @param shardEviction a {@link ShardEviction} representing the shard marked as evicted\n+     * @param runnable      a runnable to execute\n+     */\n+    private void runIfShardMarkedAsEvictedInCache(ShardEviction shardEviction, Runnable runnable) {\n+        try (Releasable ignored = shardsEvictionLock.acquire(shardEviction)) {\n+            boolean success = false;\n+            try {\n+                if (evictedShards.remove(shardEviction)) {\n+                    runnable.run();\n+                }\n+                success = true;\n+            } finally {\n+                if (success == false) {\n+                    final boolean added = evictedShards.add(shardEviction);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI3NzMxNA=="}, "originalCommit": {"oid": "6c1a6e9cc7cb9f4fb13b53bbb4f4b10d07241b37"}, "originalPosition": 131}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3395cf95543380607952b43a9b962d231d0815ee", "author": {"user": {"login": "tlrx", "name": "Tanguy Leroux"}}, "url": "https://github.com/elastic/elasticsearch/commit/3395cf95543380607952b43a9b962d231d0815ee", "committedDate": "2020-12-11T10:00:07Z", "message": "feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "02aa9c9284f0ce95006246d6363b10def5e4d6ad", "author": {"user": {"login": "tlrx", "name": "Tanguy Leroux"}}, "url": "https://github.com/elastic/elasticsearch/commit/02aa9c9284f0ce95006246d6363b10def5e4d6ad", "committedDate": "2020-12-11T10:00:34Z", "message": "Merge branch 'master' into use-listeners-to-manage-cache-files-for-removed-shards"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4723, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}