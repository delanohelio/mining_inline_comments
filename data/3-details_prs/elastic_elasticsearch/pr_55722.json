{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA4NTg3MjEx", "number": 55722, "title": "Remove \"Sub\" Nodes in Painless User Tree", "bodyText": "This change removes all of the \"sub\" nodes from the Painless user tree. These nodes are generated by other nodes within the user tree, but it no longer makes sense to do so as we now generate an ir tree instead. The generated ir tree takes on the role that these sub nodes were previously used for in separation of writing logic. The semantic analysis logic for the sub nodes is moved into the nodes that used to generate them. This continues our march toward the goal an of immutable user tree.\nThis change also renames PField -> EDot, PCallInvoke -> ECall, and PBrace -> EBrace which is more representative of the direct operator that's called.", "createdAt": "2020-04-24T14:33:12Z", "url": "https://github.com/elastic/elasticsearch/pull/55722", "merged": true, "mergeCommit": {"oid": "65eaf325bf610248c6ef8dca62a6da3cae3ec9c8"}, "closed": true, "closedAt": "2020-04-29T21:49:25Z", "author": {"login": "jdconrad"}, "timelineItems": {"totalCount": 37, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcR5r_bAH2gAyNDA4NTg3MjExOmVhYzFkNjFlNDE3MTdkZjUxYjQyZWRmNjVjYmQxNTcwYTJhNDY2NjM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcce7PMgH2gAyNDA4NTg3MjExOjM1YTAyOWUwNWEwYjIzN2YwZGU0NjFlZmMzM2NiOTQ5OTI3Mzk2MTQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "eac1d61e41717df51b42edf65cbd1570a2a46663", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/eac1d61e41717df51b42edf65cbd1570a2a46663", "committedDate": "2020-03-27T23:55:26Z", "message": "remove statement, use read instead"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "082e94b4a590591196625bad85750d2fcbc4f551", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/082e94b4a590591196625bad85750d2fcbc4f551", "committedDate": "2020-03-30T16:27:34Z", "message": "add tests for not a statement"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d6ca6a35cfeb2f5b8689b7258bb19eda858c03bf", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/d6ca6a35cfeb2f5b8689b7258bb19eda858c03bf", "committedDate": "2020-03-30T16:51:01Z", "message": "Merge branch 'master' into nodes0"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4459ee9a8029edd7c995865bd3202830def8097c", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/4459ee9a8029edd7c995865bd3202830def8097c", "committedDate": "2020-03-30T19:02:43Z", "message": "move isDefOptimized to output instead of as mutable state on the nodes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1eb0a513f54a2abc3a4d90877d43297a246e7dac", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/1eb0a513f54a2abc3a4d90877d43297a246e7dac", "committedDate": "2020-03-30T19:05:32Z", "message": "Merge branch 'master' into nodes0"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "372ec631791fceda73c22bb1dfbba176aeba7c1f", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/372ec631791fceda73c22bb1dfbba176aeba7c1f", "committedDate": "2020-03-30T19:05:58Z", "message": "Merge branch 'nodes0' into nodes1"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "99c54f190497586547ab073b41a0c5d39d89b5fd", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/99c54f190497586547ab073b41a0c5d39d89b5fd", "committedDate": "2020-03-30T20:18:46Z", "message": "remove AStoreable and give individual nodes responsibility to check\nwrite"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2eceff4ba180840b185ae834b963c9b7ae1f58bc", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/2eceff4ba180840b185ae834b963c9b7ae1f58bc", "committedDate": "2020-03-30T22:18:14Z", "message": "clean up write messages and add tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "78961f80bef311dfa557dd0288dec8a7a1564be6", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/78961f80bef311dfa557dd0288dec8a7a1564be6", "committedDate": "2020-03-30T22:57:27Z", "message": "elimate extraneous new array function reference ir node"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7a3a3870e6443c2cfa2cdf9a3e0920977daaaf82", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/7a3a3870e6443c2cfa2cdf9a3e0920977daaaf82", "committedDate": "2020-03-31T20:07:52Z", "message": "switch ir function ref nodes to different types"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "791eca3b0d29f37c9d84fd196fb03618d33b8606", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/791eca3b0d29f37c9d84fd196fb03618d33b8606", "committedDate": "2020-03-31T20:45:25Z", "message": "remove ILambda in favor of ir tree calculating def method call recipe"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e77796275a7bf20572efb4dd1610e26ad0adefe1", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/e77796275a7bf20572efb4dd1610e26ad0adefe1", "committedDate": "2020-03-31T22:52:45Z", "message": "remove sub nodes from user tree"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "94b6c80f963c042dae95604d3c6b469fff10d9ac", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/94b6c80f963c042dae95604d3c6b469fff10d9ac", "committedDate": "2020-04-08T17:03:44Z", "message": "Merge branch 'master' into nodes0"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e7af841e35bcd8d4f845f54ffb082d3d201a51b4", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/e7af841e35bcd8d4f845f54ffb082d3d201a51b4", "committedDate": "2020-04-08T17:03:54Z", "message": "Merge branch 'nodes0' into nodes1"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "97549c8d5b65a1c97a361a9fb8fa30bdab0ea6db", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/97549c8d5b65a1c97a361a9fb8fa30bdab0ea6db", "committedDate": "2020-04-08T17:24:14Z", "message": "Merge branch 'nodes1' into nodes2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "68cd9273b01b4d9a5b27546c3a61862dd7c424b4", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/68cd9273b01b4d9a5b27546c3a61862dd7c424b4", "committedDate": "2020-04-08T17:26:09Z", "message": "Merge branch 'nodes2' into nodes3"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "251ff50fcac2ded70f1026560cf7cb67d1e86c28", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/251ff50fcac2ded70f1026560cf7cb67d1e86c28", "committedDate": "2020-04-10T15:30:43Z", "message": "Merge branch 'master' into nodes1"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "198fa475e180a169ca1911734d49096dbaf4a1f3", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/198fa475e180a169ca1911734d49096dbaf4a1f3", "committedDate": "2020-04-10T15:36:40Z", "message": "Merge branch 'nodes1' into nodes2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dd82b5f86711cb8d99c686d9fa21ddb035e84880", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/dd82b5f86711cb8d99c686d9fa21ddb035e84880", "committedDate": "2020-04-10T15:40:21Z", "message": "Merge branch 'nodes2' into nodes3"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a79f9b33ca1b8333d0e0b471c8c337674ca6f3f4", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/a79f9b33ca1b8333d0e0b471c8c337674ca6f3f4", "committedDate": "2020-04-14T23:12:20Z", "message": "Merge branch 'master' into nodes1"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4c93293c2ada3933550f1b64fa303a8785b7b328", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/4c93293c2ada3933550f1b64fa303a8785b7b328", "committedDate": "2020-04-14T23:12:46Z", "message": "Merge branch 'nodes1' into nodes2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c8076bfa4366e371aaba802a038db3c56ce43074", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/c8076bfa4366e371aaba802a038db3c56ce43074", "committedDate": "2020-04-21T14:51:10Z", "message": "Merge branch 'master' into nodes2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a4d34169a4724a4111cb30c9671e79798b64f3ef", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/a4d34169a4724a4111cb30c9671e79798b64f3ef", "committedDate": "2020-04-21T16:38:42Z", "message": "response to pr comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dafeaeb13af618684c04f0f5d38d509d4af92533", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/dafeaeb13af618684c04f0f5d38d509d4af92533", "committedDate": "2020-04-21T17:31:42Z", "message": "Merge branch 'master' into nodes2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ee2e19f11c6d3781eb420fc9c94d8bb1342d76a4", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/ee2e19f11c6d3781eb420fc9c94d8bb1342d76a4", "committedDate": "2020-04-21T17:32:33Z", "message": "Merge branch 'nodes2' into nodes3"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a1ff4a0a9d2141722bffeb4d8b6fef3fc5e7addb", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/a1ff4a0a9d2141722bffeb4d8b6fef3fc5e7addb", "committedDate": "2020-04-24T14:26:04Z", "message": "Merge branch 'master' into nodes3"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzMDAzNjYx", "url": "https://github.com/elastic/elasticsearch/pull/55722#pullrequestreview-403003661", "createdAt": "2020-04-29T20:14:04Z", "commit": {"oid": "a1ff4a0a9d2141722bffeb4d8b6fef3fc5e7addb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQyMDoxNDowNFrOGOPQ9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQyMDoxNDowNFrOGOPQ9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU4MzM1MA==", "bodyText": "(input.read || input.write) will always succeed here, see line 56.", "url": "https://github.com/elastic/elasticsearch/pull/55722#discussion_r417583350", "createdAt": "2020-04-29T20:14:04Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EBrace.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.node;\n+\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.Scope;\n+import org.elasticsearch.painless.ir.BraceNode;\n+import org.elasticsearch.painless.ir.BraceSubDefNode;\n+import org.elasticsearch.painless.ir.BraceSubNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.ExpressionNode;\n+import org.elasticsearch.painless.ir.ListSubShortcutNode;\n+import org.elasticsearch.painless.ir.MapSubShortcutNode;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.symbol.ScriptRoot;\n+\n+import java.time.ZonedDateTime;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * Represents an array load/store and defers to a child subnode.\n+ */\n+public class EBrace extends AExpression {\n+\n+    protected final AExpression index;\n+\n+    public EBrace(Location location, AExpression prefix, AExpression index) {\n+        super(location, prefix);\n+\n+        this.index = Objects.requireNonNull(index);\n+    }\n+\n+    @Override\n+    Output analyze(ClassNode classNode, ScriptRoot scriptRoot, Scope scope, Input input) {\n+        if (input.read == false && input.write == false) {\n+            throw createError(new IllegalArgumentException(\"not a statement: result of brace operator not used\"));\n+        }\n+\n+        Output prefixOutput = prefix.analyze(classNode, scriptRoot, scope, new Input());\n+\n+        ExpressionNode expressionNode;\n+        Output output = new Output();\n+\n+        if (prefixOutput.actual.isArray()) {\n+            Input indexInput = new Input();\n+            indexInput.expected = int.class;\n+            Output indexOutput = index.analyze(classNode, scriptRoot, scope, indexInput);\n+            index.cast(indexInput, indexOutput);\n+\n+            output.actual = prefixOutput.actual.getComponentType();\n+\n+            BraceSubNode braceSubNode = new BraceSubNode();\n+            braceSubNode.setChildNode(index.cast(indexOutput));\n+            braceSubNode.setLocation(location);\n+            braceSubNode.setExpressionType(output.actual);\n+            expressionNode = braceSubNode;\n+        } else if (prefixOutput.actual == def.class) {\n+            Input indexInput = new Input();\n+            Output indexOutput = index.analyze(classNode, scriptRoot, scope, indexInput);\n+\n+            // TODO: remove ZonedDateTime exception when JodaCompatibleDateTime is removed\n+            output.actual = input.expected == null || input.expected == ZonedDateTime.class || input.explicit ? def.class : input.expected;\n+            output.isDefOptimized = true;\n+\n+            BraceSubDefNode braceSubDefNode = new BraceSubDefNode();\n+            braceSubDefNode.setChildNode(indexOutput.expressionNode);\n+            braceSubDefNode.setLocation(location);\n+            braceSubDefNode.setExpressionType(output.actual);\n+            expressionNode = braceSubDefNode;\n+        } else if (Map.class.isAssignableFrom(prefixOutput.actual)) {\n+            Class<?> targetClass = prefixOutput.actual;\n+            String canonicalClassName = PainlessLookupUtility.typeToCanonicalTypeName(targetClass);\n+\n+            PainlessMethod getter = scriptRoot.getPainlessLookup().lookupPainlessMethod(targetClass, false, \"get\", 1);\n+            PainlessMethod setter = scriptRoot.getPainlessLookup().lookupPainlessMethod(targetClass, false, \"put\", 2);\n+\n+            if (getter != null && (getter.returnType == void.class || getter.typeParameters.size() != 1)) {\n+                throw createError(new IllegalArgumentException(\"Illegal map get shortcut for type [\" + canonicalClassName + \"].\"));\n+            }\n+\n+            if (setter != null && setter.typeParameters.size() != 2) {\n+                throw createError(new IllegalArgumentException(\"Illegal map set shortcut for type [\" + canonicalClassName + \"].\"));\n+            }\n+\n+            if (getter != null && setter != null && (!getter.typeParameters.get(0).equals(setter.typeParameters.get(0)) ||\n+                    !getter.returnType.equals(setter.typeParameters.get(1)))) {\n+                throw createError(new IllegalArgumentException(\"Shortcut argument types must match.\"));\n+            }\n+\n+            Output indexOutput;\n+\n+            if ((input.read || input.write) && (input.read == false || getter != null) && (input.write == false || setter != null)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1ff4a0a9d2141722bffeb4d8b6fef3fc5e7addb"}, "originalPosition": 113}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzMDA1NzE1", "url": "https://github.com/elastic/elasticsearch/pull/55722#pullrequestreview-403005715", "createdAt": "2020-04-29T20:17:04Z", "commit": {"oid": "a1ff4a0a9d2141722bffeb4d8b6fef3fc5e7addb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQyMDoxNzowNFrOGOPXcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQyMDoxNzowNFrOGOPXcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU4NTAxMA==", "bodyText": "Unnecessary first clause.", "url": "https://github.com/elastic/elasticsearch/pull/55722#discussion_r417585010", "createdAt": "2020-04-29T20:17:04Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EBrace.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.node;\n+\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.Scope;\n+import org.elasticsearch.painless.ir.BraceNode;\n+import org.elasticsearch.painless.ir.BraceSubDefNode;\n+import org.elasticsearch.painless.ir.BraceSubNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.ExpressionNode;\n+import org.elasticsearch.painless.ir.ListSubShortcutNode;\n+import org.elasticsearch.painless.ir.MapSubShortcutNode;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.symbol.ScriptRoot;\n+\n+import java.time.ZonedDateTime;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * Represents an array load/store and defers to a child subnode.\n+ */\n+public class EBrace extends AExpression {\n+\n+    protected final AExpression index;\n+\n+    public EBrace(Location location, AExpression prefix, AExpression index) {\n+        super(location, prefix);\n+\n+        this.index = Objects.requireNonNull(index);\n+    }\n+\n+    @Override\n+    Output analyze(ClassNode classNode, ScriptRoot scriptRoot, Scope scope, Input input) {\n+        if (input.read == false && input.write == false) {\n+            throw createError(new IllegalArgumentException(\"not a statement: result of brace operator not used\"));\n+        }\n+\n+        Output prefixOutput = prefix.analyze(classNode, scriptRoot, scope, new Input());\n+\n+        ExpressionNode expressionNode;\n+        Output output = new Output();\n+\n+        if (prefixOutput.actual.isArray()) {\n+            Input indexInput = new Input();\n+            indexInput.expected = int.class;\n+            Output indexOutput = index.analyze(classNode, scriptRoot, scope, indexInput);\n+            index.cast(indexInput, indexOutput);\n+\n+            output.actual = prefixOutput.actual.getComponentType();\n+\n+            BraceSubNode braceSubNode = new BraceSubNode();\n+            braceSubNode.setChildNode(index.cast(indexOutput));\n+            braceSubNode.setLocation(location);\n+            braceSubNode.setExpressionType(output.actual);\n+            expressionNode = braceSubNode;\n+        } else if (prefixOutput.actual == def.class) {\n+            Input indexInput = new Input();\n+            Output indexOutput = index.analyze(classNode, scriptRoot, scope, indexInput);\n+\n+            // TODO: remove ZonedDateTime exception when JodaCompatibleDateTime is removed\n+            output.actual = input.expected == null || input.expected == ZonedDateTime.class || input.explicit ? def.class : input.expected;\n+            output.isDefOptimized = true;\n+\n+            BraceSubDefNode braceSubDefNode = new BraceSubDefNode();\n+            braceSubDefNode.setChildNode(indexOutput.expressionNode);\n+            braceSubDefNode.setLocation(location);\n+            braceSubDefNode.setExpressionType(output.actual);\n+            expressionNode = braceSubDefNode;\n+        } else if (Map.class.isAssignableFrom(prefixOutput.actual)) {\n+            Class<?> targetClass = prefixOutput.actual;\n+            String canonicalClassName = PainlessLookupUtility.typeToCanonicalTypeName(targetClass);\n+\n+            PainlessMethod getter = scriptRoot.getPainlessLookup().lookupPainlessMethod(targetClass, false, \"get\", 1);\n+            PainlessMethod setter = scriptRoot.getPainlessLookup().lookupPainlessMethod(targetClass, false, \"put\", 2);\n+\n+            if (getter != null && (getter.returnType == void.class || getter.typeParameters.size() != 1)) {\n+                throw createError(new IllegalArgumentException(\"Illegal map get shortcut for type [\" + canonicalClassName + \"].\"));\n+            }\n+\n+            if (setter != null && setter.typeParameters.size() != 2) {\n+                throw createError(new IllegalArgumentException(\"Illegal map set shortcut for type [\" + canonicalClassName + \"].\"));\n+            }\n+\n+            if (getter != null && setter != null && (!getter.typeParameters.get(0).equals(setter.typeParameters.get(0)) ||\n+                    !getter.returnType.equals(setter.typeParameters.get(1)))) {\n+                throw createError(new IllegalArgumentException(\"Shortcut argument types must match.\"));\n+            }\n+\n+            Output indexOutput;\n+\n+            if ((input.read || input.write) && (input.read == false || getter != null) && (input.write == false || setter != null)) {\n+                Input indexInput = new Input();\n+                indexInput.expected = setter != null ? setter.typeParameters.get(0) : getter.typeParameters.get(0);\n+                indexOutput = index.analyze(classNode, scriptRoot, scope, indexInput);\n+                index.cast(indexInput, indexOutput);\n+\n+                output.actual = setter != null ? setter.typeParameters.get(1) : getter.returnType;\n+            } else {\n+                throw createError(new IllegalArgumentException(\"Illegal map shortcut for type [\" + canonicalClassName + \"].\"));\n+            }\n+\n+            MapSubShortcutNode mapSubShortcutNode = new MapSubShortcutNode();\n+            mapSubShortcutNode.setChildNode(index.cast(indexOutput));\n+            mapSubShortcutNode.setLocation(location);\n+            mapSubShortcutNode.setExpressionType(output.actual);\n+            mapSubShortcutNode.setGetter(getter);\n+            mapSubShortcutNode.setSetter(setter);\n+            expressionNode = mapSubShortcutNode;\n+        } else if (List.class.isAssignableFrom(prefixOutput.actual)) {\n+            Class<?> targetClass = prefixOutput.actual;\n+            String canonicalClassName = PainlessLookupUtility.typeToCanonicalTypeName(targetClass);\n+\n+            PainlessMethod getter = scriptRoot.getPainlessLookup().lookupPainlessMethod(targetClass, false, \"get\", 1);\n+            PainlessMethod setter = scriptRoot.getPainlessLookup().lookupPainlessMethod(targetClass, false, \"set\", 2);\n+\n+            if (getter != null && (getter.returnType == void.class || getter.typeParameters.size() != 1 ||\n+                    getter.typeParameters.get(0) != int.class)) {\n+                throw createError(new IllegalArgumentException(\"Illegal list get shortcut for type [\" + canonicalClassName + \"].\"));\n+            }\n+\n+            if (setter != null && (setter.typeParameters.size() != 2 || setter.typeParameters.get(0) != int.class)) {\n+                throw createError(new IllegalArgumentException(\"Illegal list set shortcut for type [\" + canonicalClassName + \"].\"));\n+            }\n+\n+            if (getter != null && setter != null && (!getter.typeParameters.get(0).equals(setter.typeParameters.get(0))\n+                    || !getter.returnType.equals(setter.typeParameters.get(1)))) {\n+                throw createError(new IllegalArgumentException(\"Shortcut argument types must match.\"));\n+            }\n+\n+            Output indexOutput;\n+\n+            if ((input.read || input.write) && (input.read == false || getter != null) && (input.write == false || setter != null)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1ff4a0a9d2141722bffeb4d8b6fef3fc5e7addb"}, "originalPosition": 154}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzMDA3NDc2", "url": "https://github.com/elastic/elasticsearch/pull/55722#pullrequestreview-403007476", "createdAt": "2020-04-29T20:19:41Z", "commit": {"oid": "a1ff4a0a9d2141722bffeb4d8b6fef3fc5e7addb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQyMDoxOTo0MlrOGOPc-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQyMDoxOTo0MlrOGOPc-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU4NjQyNg==", "bodyText": "This check seems fruitless.", "url": "https://github.com/elastic/elasticsearch/pull/55722#discussion_r417586426", "createdAt": "2020-04-29T20:19:42Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EBrace.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.node;\n+\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.Scope;\n+import org.elasticsearch.painless.ir.BraceNode;\n+import org.elasticsearch.painless.ir.BraceSubDefNode;\n+import org.elasticsearch.painless.ir.BraceSubNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.ExpressionNode;\n+import org.elasticsearch.painless.ir.ListSubShortcutNode;\n+import org.elasticsearch.painless.ir.MapSubShortcutNode;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.symbol.ScriptRoot;\n+\n+import java.time.ZonedDateTime;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * Represents an array load/store and defers to a child subnode.\n+ */\n+public class EBrace extends AExpression {\n+\n+    protected final AExpression index;\n+\n+    public EBrace(Location location, AExpression prefix, AExpression index) {\n+        super(location, prefix);\n+\n+        this.index = Objects.requireNonNull(index);\n+    }\n+\n+    @Override\n+    Output analyze(ClassNode classNode, ScriptRoot scriptRoot, Scope scope, Input input) {\n+        if (input.read == false && input.write == false) {\n+            throw createError(new IllegalArgumentException(\"not a statement: result of brace operator not used\"));\n+        }\n+\n+        Output prefixOutput = prefix.analyze(classNode, scriptRoot, scope, new Input());\n+\n+        ExpressionNode expressionNode;\n+        Output output = new Output();\n+\n+        if (prefixOutput.actual.isArray()) {\n+            Input indexInput = new Input();\n+            indexInput.expected = int.class;\n+            Output indexOutput = index.analyze(classNode, scriptRoot, scope, indexInput);\n+            index.cast(indexInput, indexOutput);\n+\n+            output.actual = prefixOutput.actual.getComponentType();\n+\n+            BraceSubNode braceSubNode = new BraceSubNode();\n+            braceSubNode.setChildNode(index.cast(indexOutput));\n+            braceSubNode.setLocation(location);\n+            braceSubNode.setExpressionType(output.actual);\n+            expressionNode = braceSubNode;\n+        } else if (prefixOutput.actual == def.class) {\n+            Input indexInput = new Input();\n+            Output indexOutput = index.analyze(classNode, scriptRoot, scope, indexInput);\n+\n+            // TODO: remove ZonedDateTime exception when JodaCompatibleDateTime is removed\n+            output.actual = input.expected == null || input.expected == ZonedDateTime.class || input.explicit ? def.class : input.expected;\n+            output.isDefOptimized = true;\n+\n+            BraceSubDefNode braceSubDefNode = new BraceSubDefNode();\n+            braceSubDefNode.setChildNode(indexOutput.expressionNode);\n+            braceSubDefNode.setLocation(location);\n+            braceSubDefNode.setExpressionType(output.actual);\n+            expressionNode = braceSubDefNode;\n+        } else if (Map.class.isAssignableFrom(prefixOutput.actual)) {\n+            Class<?> targetClass = prefixOutput.actual;\n+            String canonicalClassName = PainlessLookupUtility.typeToCanonicalTypeName(targetClass);\n+\n+            PainlessMethod getter = scriptRoot.getPainlessLookup().lookupPainlessMethod(targetClass, false, \"get\", 1);\n+            PainlessMethod setter = scriptRoot.getPainlessLookup().lookupPainlessMethod(targetClass, false, \"put\", 2);\n+\n+            if (getter != null && (getter.returnType == void.class || getter.typeParameters.size() != 1)) {\n+                throw createError(new IllegalArgumentException(\"Illegal map get shortcut for type [\" + canonicalClassName + \"].\"));\n+            }\n+\n+            if (setter != null && setter.typeParameters.size() != 2) {\n+                throw createError(new IllegalArgumentException(\"Illegal map set shortcut for type [\" + canonicalClassName + \"].\"));\n+            }\n+\n+            if (getter != null && setter != null && (!getter.typeParameters.get(0).equals(setter.typeParameters.get(0)) ||\n+                    !getter.returnType.equals(setter.typeParameters.get(1)))) {\n+                throw createError(new IllegalArgumentException(\"Shortcut argument types must match.\"));\n+            }\n+\n+            Output indexOutput;\n+\n+            if ((input.read || input.write) && (input.read == false || getter != null) && (input.write == false || setter != null)) {\n+                Input indexInput = new Input();\n+                indexInput.expected = setter != null ? setter.typeParameters.get(0) : getter.typeParameters.get(0);\n+                indexOutput = index.analyze(classNode, scriptRoot, scope, indexInput);\n+                index.cast(indexInput, indexOutput);\n+\n+                output.actual = setter != null ? setter.typeParameters.get(1) : getter.returnType;\n+            } else {\n+                throw createError(new IllegalArgumentException(\"Illegal map shortcut for type [\" + canonicalClassName + \"].\"));\n+            }\n+\n+            MapSubShortcutNode mapSubShortcutNode = new MapSubShortcutNode();\n+            mapSubShortcutNode.setChildNode(index.cast(indexOutput));\n+            mapSubShortcutNode.setLocation(location);\n+            mapSubShortcutNode.setExpressionType(output.actual);\n+            mapSubShortcutNode.setGetter(getter);\n+            mapSubShortcutNode.setSetter(setter);\n+            expressionNode = mapSubShortcutNode;\n+        } else if (List.class.isAssignableFrom(prefixOutput.actual)) {\n+            Class<?> targetClass = prefixOutput.actual;\n+            String canonicalClassName = PainlessLookupUtility.typeToCanonicalTypeName(targetClass);\n+\n+            PainlessMethod getter = scriptRoot.getPainlessLookup().lookupPainlessMethod(targetClass, false, \"get\", 1);\n+            PainlessMethod setter = scriptRoot.getPainlessLookup().lookupPainlessMethod(targetClass, false, \"set\", 2);\n+\n+            if (getter != null && (getter.returnType == void.class || getter.typeParameters.size() != 1 ||\n+                    getter.typeParameters.get(0) != int.class)) {\n+                throw createError(new IllegalArgumentException(\"Illegal list get shortcut for type [\" + canonicalClassName + \"].\"));\n+            }\n+\n+            if (setter != null && (setter.typeParameters.size() != 2 || setter.typeParameters.get(0) != int.class)) {\n+                throw createError(new IllegalArgumentException(\"Illegal list set shortcut for type [\" + canonicalClassName + \"].\"));\n+            }\n+\n+            if (getter != null && setter != null && (!getter.typeParameters.get(0).equals(setter.typeParameters.get(0))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1ff4a0a9d2141722bffeb4d8b6fef3fc5e7addb"}, "originalPosition": 147}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzMDEwMzI2", "url": "https://github.com/elastic/elasticsearch/pull/55722#pullrequestreview-403010326", "createdAt": "2020-04-29T20:23:56Z", "commit": {"oid": "a1ff4a0a9d2141722bffeb4d8b6fef3fc5e7addb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQyMDoyMzo1NlrOGOPl1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQyMDoyMzo1NlrOGOPl1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU4ODY5NA==", "bodyText": "input.expected == ZonedDateTime.class?", "url": "https://github.com/elastic/elasticsearch/pull/55722#discussion_r417588694", "createdAt": "2020-04-29T20:23:56Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EDot.java", "diffHunk": "@@ -0,0 +1,288 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.node;\n+\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.Scope;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.DotNode;\n+import org.elasticsearch.painless.ir.DotSubArrayLengthNode;\n+import org.elasticsearch.painless.ir.DotSubDefNode;\n+import org.elasticsearch.painless.ir.DotSubNode;\n+import org.elasticsearch.painless.ir.DotSubShortcutNode;\n+import org.elasticsearch.painless.ir.ExpressionNode;\n+import org.elasticsearch.painless.ir.ListSubShortcutNode;\n+import org.elasticsearch.painless.ir.MapSubShortcutNode;\n+import org.elasticsearch.painless.ir.NullSafeSubNode;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.symbol.ScriptRoot;\n+\n+import java.lang.reflect.Modifier;\n+import java.time.ZonedDateTime;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.painless.lookup.PainlessLookupUtility.typeToCanonicalTypeName;\n+\n+/**\n+ * Represents a field load/store and defers to a child subnode.\n+ */\n+public class EDot extends AExpression {\n+\n+    protected final boolean nullSafe;\n+    protected final String value;\n+\n+    public EDot(Location location, AExpression prefix, boolean nullSafe, String value) {\n+        super(location, prefix);\n+\n+        this.nullSafe = nullSafe;\n+        this.value = Objects.requireNonNull(value);\n+    }\n+\n+    @Override\n+    Output analyze(ClassNode classNode, ScriptRoot scriptRoot, Scope scope, Input input) {\n+        if (input.read == false && input.write == false) {\n+            throw createError(new IllegalArgumentException(\"not a statement: result of dot operator [.] not used\"));\n+        }\n+\n+        Output output = new Output();\n+\n+        Output prefixOutput = prefix.analyze(classNode, scriptRoot, scope, new Input());\n+\n+        Class<?> targetType = prefixOutput.actual;\n+        String targetCanonicalTypeName = PainlessLookupUtility.typeToCanonicalTypeName(targetType);\n+\n+        ExpressionNode expressionNode = null;\n+\n+        if (prefixOutput.actual.isArray()) {\n+            if (\"length\".equals(value)) {\n+                if (input.write) {\n+                    throw createError(new IllegalArgumentException(\n+                            \"invalid assignment: cannot assign a value write to read-only field [length] for an array.\"));\n+                }\n+\n+                output.actual = int.class;\n+            } else {\n+                throw createError(new IllegalArgumentException(\n+                        \"Field [\" + value + \"] does not exist for type [\" + targetCanonicalTypeName + \"].\"));\n+            }\n+\n+            DotSubArrayLengthNode dotSubArrayLengthNode = new DotSubArrayLengthNode();\n+            dotSubArrayLengthNode.setLocation(location);\n+            dotSubArrayLengthNode.setExpressionType(output.actual);\n+            expressionNode = dotSubArrayLengthNode;\n+        } else if (prefixOutput.actual == def.class) {\n+            // TODO: remove ZonedDateTime exception when JodaCompatibleDateTime is removed\n+            output.actual = input.expected == null || input.expected == ZonedDateTime.class || input.explicit ? def.class : input.expected;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1ff4a0a9d2141722bffeb4d8b6fef3fc5e7addb"}, "originalPosition": 97}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzMDEwNjkw", "url": "https://github.com/elastic/elasticsearch/pull/55722#pullrequestreview-403010690", "createdAt": "2020-04-29T20:24:28Z", "commit": {"oid": "a1ff4a0a9d2141722bffeb4d8b6fef3fc5e7addb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQyMDoyNDoyOVrOGOPm9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQyMDoyNDoyOVrOGOPm9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU4ODk4Mg==", "bodyText": "input.expected == ZonedDateTime.class?", "url": "https://github.com/elastic/elasticsearch/pull/55722#discussion_r417588982", "createdAt": "2020-04-29T20:24:29Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EBrace.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.node;\n+\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.Scope;\n+import org.elasticsearch.painless.ir.BraceNode;\n+import org.elasticsearch.painless.ir.BraceSubDefNode;\n+import org.elasticsearch.painless.ir.BraceSubNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.ExpressionNode;\n+import org.elasticsearch.painless.ir.ListSubShortcutNode;\n+import org.elasticsearch.painless.ir.MapSubShortcutNode;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.symbol.ScriptRoot;\n+\n+import java.time.ZonedDateTime;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * Represents an array load/store and defers to a child subnode.\n+ */\n+public class EBrace extends AExpression {\n+\n+    protected final AExpression index;\n+\n+    public EBrace(Location location, AExpression prefix, AExpression index) {\n+        super(location, prefix);\n+\n+        this.index = Objects.requireNonNull(index);\n+    }\n+\n+    @Override\n+    Output analyze(ClassNode classNode, ScriptRoot scriptRoot, Scope scope, Input input) {\n+        if (input.read == false && input.write == false) {\n+            throw createError(new IllegalArgumentException(\"not a statement: result of brace operator not used\"));\n+        }\n+\n+        Output prefixOutput = prefix.analyze(classNode, scriptRoot, scope, new Input());\n+\n+        ExpressionNode expressionNode;\n+        Output output = new Output();\n+\n+        if (prefixOutput.actual.isArray()) {\n+            Input indexInput = new Input();\n+            indexInput.expected = int.class;\n+            Output indexOutput = index.analyze(classNode, scriptRoot, scope, indexInput);\n+            index.cast(indexInput, indexOutput);\n+\n+            output.actual = prefixOutput.actual.getComponentType();\n+\n+            BraceSubNode braceSubNode = new BraceSubNode();\n+            braceSubNode.setChildNode(index.cast(indexOutput));\n+            braceSubNode.setLocation(location);\n+            braceSubNode.setExpressionType(output.actual);\n+            expressionNode = braceSubNode;\n+        } else if (prefixOutput.actual == def.class) {\n+            Input indexInput = new Input();\n+            Output indexOutput = index.analyze(classNode, scriptRoot, scope, indexInput);\n+\n+            // TODO: remove ZonedDateTime exception when JodaCompatibleDateTime is removed\n+            output.actual = input.expected == null || input.expected == ZonedDateTime.class || input.explicit ? def.class : input.expected;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1ff4a0a9d2141722bffeb4d8b6fef3fc5e7addb"}, "originalPosition": 83}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzMDExMTg0", "url": "https://github.com/elastic/elasticsearch/pull/55722#pullrequestreview-403011184", "createdAt": "2020-04-29T20:25:09Z", "commit": {"oid": "a1ff4a0a9d2141722bffeb4d8b6fef3fc5e7addb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQyMDoyNTowOVrOGOPokQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQyMDoyNTowOVrOGOPokQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU4OTM5Mw==", "bodyText": "Same ZonedDateTime question.", "url": "https://github.com/elastic/elasticsearch/pull/55722#discussion_r417589393", "createdAt": "2020-04-29T20:25:09Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/ECall.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.node;\n+\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.Scope;\n+import org.elasticsearch.painless.ir.CallNode;\n+import org.elasticsearch.painless.ir.CallSubDefNode;\n+import org.elasticsearch.painless.ir.CallSubNode;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.ExpressionNode;\n+import org.elasticsearch.painless.ir.NullSafeSubNode;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.spi.annotation.NonDeterministicAnnotation;\n+import org.elasticsearch.painless.symbol.ScriptRoot;\n+\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.painless.lookup.PainlessLookupUtility.typeToCanonicalTypeName;\n+\n+/**\n+ * Represents a method call and defers to a child subnode.\n+ */\n+public class ECall extends AExpression {\n+\n+    protected final String name;\n+    protected final List<AExpression> arguments;\n+    protected final boolean nullSafe;\n+\n+    public ECall(Location location, AExpression prefix, String name, List<AExpression> arguments, boolean nullSafe) {\n+        super(location, prefix);\n+\n+        this.name = Objects.requireNonNull(name);\n+        this.arguments = Collections.unmodifiableList(Objects.requireNonNull(arguments));\n+        this.nullSafe = nullSafe;\n+    }\n+\n+    @Override\n+    Output analyze(ClassNode classNode, ScriptRoot scriptRoot, Scope scope, Input input) {\n+        if (input.write) {\n+            throw createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to method call [\" + name + \"/\" + arguments.size() + \"]\"));\n+        }\n+\n+        Output output = new Output();\n+\n+        Input prefixInput = new Input();\n+        Output prefixOutput = prefix.analyze(classNode, scriptRoot, scope, prefixInput);\n+\n+        ExpressionNode expressionNode;\n+\n+        if (prefixOutput.actual == def.class) {\n+            List<Output> argumentOutputs = new ArrayList<>(arguments.size());\n+\n+            for (AExpression argument : arguments) {\n+                Input expressionInput = new Input();\n+                expressionInput.internal = true;\n+                Output expressionOutput = argument.analyze(classNode, scriptRoot, scope, expressionInput);\n+                argumentOutputs.add(expressionOutput);\n+\n+                if (expressionOutput.actual == void.class) {\n+                    throw createError(new IllegalArgumentException(\n+                            \"Argument(s) cannot be of [void] type when calling method [\" + name + \"].\"));\n+                }\n+\n+                expressionInput.expected = expressionOutput.actual;\n+                argument.cast(expressionInput, expressionOutput);\n+            }\n+\n+            // TODO: remove ZonedDateTime exception when JodaCompatibleDateTime is removed\n+            output.actual = input.expected == null || input.expected == ZonedDateTime.class || input.explicit ? def.class : input.expected;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1ff4a0a9d2141722bffeb4d8b6fef3fc5e7addb"}, "originalPosition": 93}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzMDE0MzUz", "url": "https://github.com/elastic/elasticsearch/pull/55722#pullrequestreview-403014353", "createdAt": "2020-04-29T20:29:44Z", "commit": {"oid": "a1ff4a0a9d2141722bffeb4d8b6fef3fc5e7addb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQyMDoyOTo0NFrOGOPyiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQyMDoyOTo0NFrOGOPyiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU5MTk0Nw==", "bodyText": "(input.read || input.write)", "url": "https://github.com/elastic/elasticsearch/pull/55722#discussion_r417591947", "createdAt": "2020-04-29T20:29:44Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EDot.java", "diffHunk": "@@ -0,0 +1,288 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.node;\n+\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.Scope;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.DotNode;\n+import org.elasticsearch.painless.ir.DotSubArrayLengthNode;\n+import org.elasticsearch.painless.ir.DotSubDefNode;\n+import org.elasticsearch.painless.ir.DotSubNode;\n+import org.elasticsearch.painless.ir.DotSubShortcutNode;\n+import org.elasticsearch.painless.ir.ExpressionNode;\n+import org.elasticsearch.painless.ir.ListSubShortcutNode;\n+import org.elasticsearch.painless.ir.MapSubShortcutNode;\n+import org.elasticsearch.painless.ir.NullSafeSubNode;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.symbol.ScriptRoot;\n+\n+import java.lang.reflect.Modifier;\n+import java.time.ZonedDateTime;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.painless.lookup.PainlessLookupUtility.typeToCanonicalTypeName;\n+\n+/**\n+ * Represents a field load/store and defers to a child subnode.\n+ */\n+public class EDot extends AExpression {\n+\n+    protected final boolean nullSafe;\n+    protected final String value;\n+\n+    public EDot(Location location, AExpression prefix, boolean nullSafe, String value) {\n+        super(location, prefix);\n+\n+        this.nullSafe = nullSafe;\n+        this.value = Objects.requireNonNull(value);\n+    }\n+\n+    @Override\n+    Output analyze(ClassNode classNode, ScriptRoot scriptRoot, Scope scope, Input input) {\n+        if (input.read == false && input.write == false) {\n+            throw createError(new IllegalArgumentException(\"not a statement: result of dot operator [.] not used\"));\n+        }\n+\n+        Output output = new Output();\n+\n+        Output prefixOutput = prefix.analyze(classNode, scriptRoot, scope, new Input());\n+\n+        Class<?> targetType = prefixOutput.actual;\n+        String targetCanonicalTypeName = PainlessLookupUtility.typeToCanonicalTypeName(targetType);\n+\n+        ExpressionNode expressionNode = null;\n+\n+        if (prefixOutput.actual.isArray()) {\n+            if (\"length\".equals(value)) {\n+                if (input.write) {\n+                    throw createError(new IllegalArgumentException(\n+                            \"invalid assignment: cannot assign a value write to read-only field [length] for an array.\"));\n+                }\n+\n+                output.actual = int.class;\n+            } else {\n+                throw createError(new IllegalArgumentException(\n+                        \"Field [\" + value + \"] does not exist for type [\" + targetCanonicalTypeName + \"].\"));\n+            }\n+\n+            DotSubArrayLengthNode dotSubArrayLengthNode = new DotSubArrayLengthNode();\n+            dotSubArrayLengthNode.setLocation(location);\n+            dotSubArrayLengthNode.setExpressionType(output.actual);\n+            expressionNode = dotSubArrayLengthNode;\n+        } else if (prefixOutput.actual == def.class) {\n+            // TODO: remove ZonedDateTime exception when JodaCompatibleDateTime is removed\n+            output.actual = input.expected == null || input.expected == ZonedDateTime.class || input.explicit ? def.class : input.expected;\n+            output.isDefOptimized = true;\n+\n+            DotSubDefNode dotSubDefNode = new DotSubDefNode();\n+            dotSubDefNode.setLocation(location);\n+            dotSubDefNode.setExpressionType(output.actual);\n+            dotSubDefNode.setValue(value);\n+            expressionNode = dotSubDefNode;\n+        } else {\n+            PainlessField field = scriptRoot.getPainlessLookup().lookupPainlessField(prefixOutput.actual, prefix instanceof EStatic, value);\n+\n+            if (field == null) {\n+                PainlessMethod getter;\n+                PainlessMethod setter;\n+\n+                getter = scriptRoot.getPainlessLookup().lookupPainlessMethod(prefixOutput.actual, false,\n+                        \"get\" + Character.toUpperCase(value.charAt(0)) + value.substring(1), 0);\n+\n+                if (getter == null) {\n+                    getter = scriptRoot.getPainlessLookup().lookupPainlessMethod(prefixOutput.actual, false,\n+                            \"is\" + Character.toUpperCase(value.charAt(0)) + value.substring(1), 0);\n+                }\n+\n+                setter = scriptRoot.getPainlessLookup().lookupPainlessMethod(prefixOutput.actual, false,\n+                        \"set\" + Character.toUpperCase(value.charAt(0)) + value.substring(1), 0);\n+\n+                if (getter != null || setter != null) {\n+                    if (getter != null && (getter.returnType == void.class || !getter.typeParameters.isEmpty())) {\n+                        throw createError(new IllegalArgumentException(\n+                                \"Illegal get shortcut on field [\" + value + \"] for type [\" + targetCanonicalTypeName + \"].\"));\n+                    }\n+\n+                    if (setter != null && (setter.returnType != void.class || setter.typeParameters.size() != 1)) {\n+                        throw createError(new IllegalArgumentException(\n+                                \"Illegal set shortcut on field [\" + value + \"] for type [\" + targetCanonicalTypeName + \"].\"));\n+                    }\n+\n+                    if (getter != null && setter != null && setter.typeParameters.get(0) != getter.returnType) {\n+                        throw createError(new IllegalArgumentException(\"Shortcut argument types must match.\"));\n+                    }\n+\n+                    if ((input.read == false || getter != null) && (input.write == false || setter != null)) {\n+                        output.actual = setter != null ? setter.typeParameters.get(0) : getter.returnType;\n+                    } else {\n+                        throw createError(new IllegalArgumentException(\n+                                \"Illegal shortcut on field [\" + value + \"] for type [\" + targetCanonicalTypeName + \"].\"));\n+                    }\n+\n+                    DotSubShortcutNode dotSubShortcutNode = new DotSubShortcutNode();\n+                    dotSubShortcutNode.setLocation(location);\n+                    dotSubShortcutNode.setExpressionType(output.actual);\n+                    dotSubShortcutNode.setGetter(getter);\n+                    dotSubShortcutNode.setSetter(setter);\n+                    expressionNode = dotSubShortcutNode;\n+                } else {\n+                    EConstant index = new EConstant(location, value);\n+                    index.analyze(classNode, scriptRoot, scope, new Input());\n+\n+                    if (Map.class.isAssignableFrom(prefixOutput.actual)) {\n+                        getter = scriptRoot.getPainlessLookup().lookupPainlessMethod(targetType, false, \"get\", 1);\n+                        setter = scriptRoot.getPainlessLookup().lookupPainlessMethod(targetType, false, \"put\", 2);\n+\n+                        if (getter != null && (getter.returnType == void.class || getter.typeParameters.size() != 1)) {\n+                            throw createError(new IllegalArgumentException(\n+                                    \"Illegal map get shortcut for type [\" + targetCanonicalTypeName + \"].\"));\n+                        }\n+\n+                        if (setter != null && setter.typeParameters.size() != 2) {\n+                            throw createError(new IllegalArgumentException(\n+                                    \"Illegal map set shortcut for type [\" + targetCanonicalTypeName + \"].\"));\n+                        }\n+\n+                        if (getter != null && setter != null && (!getter.typeParameters.get(0).equals(setter.typeParameters.get(0)) ||\n+                                !getter.returnType.equals(setter.typeParameters.get(1)))) {\n+                            throw createError(new IllegalArgumentException(\"Shortcut argument types must match.\"));\n+                        }\n+\n+                        Output indexOutput;\n+\n+                        if ((input.read || input.write)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1ff4a0a9d2141722bffeb4d8b6fef3fc5e7addb"}, "originalPosition": 176}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzMDE0Njc2", "url": "https://github.com/elastic/elasticsearch/pull/55722#pullrequestreview-403014676", "createdAt": "2020-04-29T20:30:11Z", "commit": {"oid": "a1ff4a0a9d2141722bffeb4d8b6fef3fc5e7addb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQyMDozMDoxMVrOGOPzeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQyMDozMDoxMVrOGOPzeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU5MjE4NQ==", "bodyText": "(input.read || input.write)", "url": "https://github.com/elastic/elasticsearch/pull/55722#discussion_r417592185", "createdAt": "2020-04-29T20:30:11Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EDot.java", "diffHunk": "@@ -0,0 +1,288 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.node;\n+\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.Scope;\n+import org.elasticsearch.painless.ir.ClassNode;\n+import org.elasticsearch.painless.ir.DotNode;\n+import org.elasticsearch.painless.ir.DotSubArrayLengthNode;\n+import org.elasticsearch.painless.ir.DotSubDefNode;\n+import org.elasticsearch.painless.ir.DotSubNode;\n+import org.elasticsearch.painless.ir.DotSubShortcutNode;\n+import org.elasticsearch.painless.ir.ExpressionNode;\n+import org.elasticsearch.painless.ir.ListSubShortcutNode;\n+import org.elasticsearch.painless.ir.MapSubShortcutNode;\n+import org.elasticsearch.painless.ir.NullSafeSubNode;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.symbol.ScriptRoot;\n+\n+import java.lang.reflect.Modifier;\n+import java.time.ZonedDateTime;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.painless.lookup.PainlessLookupUtility.typeToCanonicalTypeName;\n+\n+/**\n+ * Represents a field load/store and defers to a child subnode.\n+ */\n+public class EDot extends AExpression {\n+\n+    protected final boolean nullSafe;\n+    protected final String value;\n+\n+    public EDot(Location location, AExpression prefix, boolean nullSafe, String value) {\n+        super(location, prefix);\n+\n+        this.nullSafe = nullSafe;\n+        this.value = Objects.requireNonNull(value);\n+    }\n+\n+    @Override\n+    Output analyze(ClassNode classNode, ScriptRoot scriptRoot, Scope scope, Input input) {\n+        if (input.read == false && input.write == false) {\n+            throw createError(new IllegalArgumentException(\"not a statement: result of dot operator [.] not used\"));\n+        }\n+\n+        Output output = new Output();\n+\n+        Output prefixOutput = prefix.analyze(classNode, scriptRoot, scope, new Input());\n+\n+        Class<?> targetType = prefixOutput.actual;\n+        String targetCanonicalTypeName = PainlessLookupUtility.typeToCanonicalTypeName(targetType);\n+\n+        ExpressionNode expressionNode = null;\n+\n+        if (prefixOutput.actual.isArray()) {\n+            if (\"length\".equals(value)) {\n+                if (input.write) {\n+                    throw createError(new IllegalArgumentException(\n+                            \"invalid assignment: cannot assign a value write to read-only field [length] for an array.\"));\n+                }\n+\n+                output.actual = int.class;\n+            } else {\n+                throw createError(new IllegalArgumentException(\n+                        \"Field [\" + value + \"] does not exist for type [\" + targetCanonicalTypeName + \"].\"));\n+            }\n+\n+            DotSubArrayLengthNode dotSubArrayLengthNode = new DotSubArrayLengthNode();\n+            dotSubArrayLengthNode.setLocation(location);\n+            dotSubArrayLengthNode.setExpressionType(output.actual);\n+            expressionNode = dotSubArrayLengthNode;\n+        } else if (prefixOutput.actual == def.class) {\n+            // TODO: remove ZonedDateTime exception when JodaCompatibleDateTime is removed\n+            output.actual = input.expected == null || input.expected == ZonedDateTime.class || input.explicit ? def.class : input.expected;\n+            output.isDefOptimized = true;\n+\n+            DotSubDefNode dotSubDefNode = new DotSubDefNode();\n+            dotSubDefNode.setLocation(location);\n+            dotSubDefNode.setExpressionType(output.actual);\n+            dotSubDefNode.setValue(value);\n+            expressionNode = dotSubDefNode;\n+        } else {\n+            PainlessField field = scriptRoot.getPainlessLookup().lookupPainlessField(prefixOutput.actual, prefix instanceof EStatic, value);\n+\n+            if (field == null) {\n+                PainlessMethod getter;\n+                PainlessMethod setter;\n+\n+                getter = scriptRoot.getPainlessLookup().lookupPainlessMethod(prefixOutput.actual, false,\n+                        \"get\" + Character.toUpperCase(value.charAt(0)) + value.substring(1), 0);\n+\n+                if (getter == null) {\n+                    getter = scriptRoot.getPainlessLookup().lookupPainlessMethod(prefixOutput.actual, false,\n+                            \"is\" + Character.toUpperCase(value.charAt(0)) + value.substring(1), 0);\n+                }\n+\n+                setter = scriptRoot.getPainlessLookup().lookupPainlessMethod(prefixOutput.actual, false,\n+                        \"set\" + Character.toUpperCase(value.charAt(0)) + value.substring(1), 0);\n+\n+                if (getter != null || setter != null) {\n+                    if (getter != null && (getter.returnType == void.class || !getter.typeParameters.isEmpty())) {\n+                        throw createError(new IllegalArgumentException(\n+                                \"Illegal get shortcut on field [\" + value + \"] for type [\" + targetCanonicalTypeName + \"].\"));\n+                    }\n+\n+                    if (setter != null && (setter.returnType != void.class || setter.typeParameters.size() != 1)) {\n+                        throw createError(new IllegalArgumentException(\n+                                \"Illegal set shortcut on field [\" + value + \"] for type [\" + targetCanonicalTypeName + \"].\"));\n+                    }\n+\n+                    if (getter != null && setter != null && setter.typeParameters.get(0) != getter.returnType) {\n+                        throw createError(new IllegalArgumentException(\"Shortcut argument types must match.\"));\n+                    }\n+\n+                    if ((input.read == false || getter != null) && (input.write == false || setter != null)) {\n+                        output.actual = setter != null ? setter.typeParameters.get(0) : getter.returnType;\n+                    } else {\n+                        throw createError(new IllegalArgumentException(\n+                                \"Illegal shortcut on field [\" + value + \"] for type [\" + targetCanonicalTypeName + \"].\"));\n+                    }\n+\n+                    DotSubShortcutNode dotSubShortcutNode = new DotSubShortcutNode();\n+                    dotSubShortcutNode.setLocation(location);\n+                    dotSubShortcutNode.setExpressionType(output.actual);\n+                    dotSubShortcutNode.setGetter(getter);\n+                    dotSubShortcutNode.setSetter(setter);\n+                    expressionNode = dotSubShortcutNode;\n+                } else {\n+                    EConstant index = new EConstant(location, value);\n+                    index.analyze(classNode, scriptRoot, scope, new Input());\n+\n+                    if (Map.class.isAssignableFrom(prefixOutput.actual)) {\n+                        getter = scriptRoot.getPainlessLookup().lookupPainlessMethod(targetType, false, \"get\", 1);\n+                        setter = scriptRoot.getPainlessLookup().lookupPainlessMethod(targetType, false, \"put\", 2);\n+\n+                        if (getter != null && (getter.returnType == void.class || getter.typeParameters.size() != 1)) {\n+                            throw createError(new IllegalArgumentException(\n+                                    \"Illegal map get shortcut for type [\" + targetCanonicalTypeName + \"].\"));\n+                        }\n+\n+                        if (setter != null && setter.typeParameters.size() != 2) {\n+                            throw createError(new IllegalArgumentException(\n+                                    \"Illegal map set shortcut for type [\" + targetCanonicalTypeName + \"].\"));\n+                        }\n+\n+                        if (getter != null && setter != null && (!getter.typeParameters.get(0).equals(setter.typeParameters.get(0)) ||\n+                                !getter.returnType.equals(setter.typeParameters.get(1)))) {\n+                            throw createError(new IllegalArgumentException(\"Shortcut argument types must match.\"));\n+                        }\n+\n+                        Output indexOutput;\n+\n+                        if ((input.read || input.write)\n+                                && (input.read == false || getter != null) && (input.write == false || setter != null)) {\n+                            Input indexInput = new Input();\n+                            indexInput.expected = setter != null ? setter.typeParameters.get(0) : getter.typeParameters.get(0);\n+                            indexOutput = index.analyze(classNode, scriptRoot, scope, indexInput);\n+                            index.cast(indexInput, indexOutput);\n+\n+                            output.actual = setter != null ? setter.typeParameters.get(1) : getter.returnType;\n+                        } else {\n+                            throw createError(new IllegalArgumentException(\n+                                    \"Illegal map shortcut for type [\" + targetCanonicalTypeName + \"].\"));\n+                        }\n+\n+                        MapSubShortcutNode mapSubShortcutNode = new MapSubShortcutNode();\n+                        mapSubShortcutNode.setChildNode(index.cast(indexOutput));\n+                        mapSubShortcutNode.setLocation(location);\n+                        mapSubShortcutNode.setExpressionType(output.actual);\n+                        mapSubShortcutNode.setGetter(getter);\n+                        mapSubShortcutNode.setSetter(setter);\n+                        expressionNode = mapSubShortcutNode;\n+                    }\n+\n+                    if (List.class.isAssignableFrom(prefixOutput.actual)) {\n+                        getter = scriptRoot.getPainlessLookup().lookupPainlessMethod(targetType, false, \"get\", 1);\n+                        setter = scriptRoot.getPainlessLookup().lookupPainlessMethod(targetType, false, \"set\", 2);\n+\n+                        if (getter != null && (getter.returnType == void.class || getter.typeParameters.size() != 1 ||\n+                                getter.typeParameters.get(0) != int.class)) {\n+                            throw createError(new IllegalArgumentException(\n+                                    \"Illegal list get shortcut for type [\" + targetCanonicalTypeName + \"].\"));\n+                        }\n+\n+                        if (setter != null && (setter.typeParameters.size() != 2 || setter.typeParameters.get(0) != int.class)) {\n+                            throw createError(new IllegalArgumentException(\n+                                    \"Illegal list set shortcut for type [\" + targetCanonicalTypeName + \"].\"));\n+                        }\n+\n+                        if (getter != null && setter != null && (!getter.typeParameters.get(0).equals(setter.typeParameters.get(0))\n+                                || !getter.returnType.equals(setter.typeParameters.get(1)))) {\n+                            throw createError(new IllegalArgumentException(\"Shortcut argument types must match.\"));\n+                        }\n+\n+                        Output indexOutput;\n+\n+                        if ((input.read || input.write)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1ff4a0a9d2141722bffeb4d8b6fef3fc5e7addb"}, "originalPosition": 220}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzMDE3NDc0", "url": "https://github.com/elastic/elasticsearch/pull/55722#pullrequestreview-403017474", "createdAt": "2020-04-29T20:34:23Z", "commit": {"oid": "a1ff4a0a9d2141722bffeb4d8b6fef3fc5e7addb"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "64796ba9432bd5240d7bd1a9190503622d0af0ba", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/64796ba9432bd5240d7bd1a9190503622d0af0ba", "committedDate": "2020-04-29T20:36:52Z", "message": "Merge branch 'master' into nodes3"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "35a029e05a0b237f0de461efc33cb94992739614", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/35a029e05a0b237f0de461efc33cb94992739614", "committedDate": "2020-04-29T20:57:49Z", "message": "response to pr comments"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 556, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}