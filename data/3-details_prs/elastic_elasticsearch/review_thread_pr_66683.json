{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQzMzk5NzYy", "number": 66683, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxMToyMzo0NlrOFLPlFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxMToyMzo0NlrOFLPlFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3MzMzOTEwOnYy", "diffSide": "RIGHT", "path": "plugins/repository-gcs/src/main/java/org/elasticsearch/repositories/gcs/GoogleCloudStorageBlobStore.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxMToyMzo0NlrOIOTn_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNTozNjowM1rOIOb8zg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTg3MjUwOQ==", "bodyText": "BytesReference.toBytes(bytes) just copies all the bytes in most cases when working from anything that I'm afraid. Maybe we could use com.google.cloud.storage.Storage#createFrom(com.google.cloud.storage.BlobInfo, java.io.InputStream, int, com.google.cloud.storage.Storage.BlobWriteOption...) instead and use the stream we can get out of the BytesReference which won't do any copying?", "url": "https://github.com/elastic/elasticsearch/pull/66683#discussion_r551872509", "createdAt": "2021-01-05T11:23:46Z", "author": {"login": "original-brownbear"}, "path": "plugins/repository-gcs/src/main/java/org/elasticsearch/repositories/gcs/GoogleCloudStorageBlobStore.java", "diffHunk": "@@ -226,6 +227,11 @@ InputStream readBlob(String blobName, long position, long length) throws IOExcep\n         }\n     }\n \n+    public void writeBlob(String blobName, BytesReference bytes, boolean failIfAlreadyExists) throws IOException {\n+        final BlobInfo blobInfo = BlobInfo.newBuilder(bucketName, blobName).build();\n+        executePutMultipartBlob(blobInfo, failIfAlreadyExists, BytesReference.toBytes(bytes));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "753d841e5da2f1d78d08a7c20bb0d301063b2f32"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTkyODA4NA==", "bodyText": "Sadly Storage#createFrom perform multiples copies \ud83e\udd26. The alternative, Storage#writer(com.google.cloud.storage.BlobInfo, com.google.cloud.storage.Storage.BlobWriteOption...) performs multiple copies too. I'm not sure if we should apply the optimization for GCP?", "url": "https://github.com/elastic/elasticsearch/pull/66683#discussion_r551928084", "createdAt": "2021-01-05T13:23:04Z", "author": {"login": "fcofdez"}, "path": "plugins/repository-gcs/src/main/java/org/elasticsearch/repositories/gcs/GoogleCloudStorageBlobStore.java", "diffHunk": "@@ -226,6 +227,11 @@ InputStream readBlob(String blobName, long position, long length) throws IOExcep\n         }\n     }\n \n+    public void writeBlob(String blobName, BytesReference bytes, boolean failIfAlreadyExists) throws IOException {\n+        final BlobInfo blobInfo = BlobInfo.newBuilder(bucketName, blobName).build();\n+        executePutMultipartBlob(blobInfo, failIfAlreadyExists, BytesReference.toBytes(bytes));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTg3MjUwOQ=="}, "originalCommit": {"oid": "753d841e5da2f1d78d08a7c20bb0d301063b2f32"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTk5MjM2OA==", "bodyText": "Urgh yea you're right GCP does crazy stuff there either way it seems. I'd say let's just fix Azure then and think about GCP at low priority in a follow up :)", "url": "https://github.com/elastic/elasticsearch/pull/66683#discussion_r551992368", "createdAt": "2021-01-05T15:11:08Z", "author": {"login": "original-brownbear"}, "path": "plugins/repository-gcs/src/main/java/org/elasticsearch/repositories/gcs/GoogleCloudStorageBlobStore.java", "diffHunk": "@@ -226,6 +227,11 @@ InputStream readBlob(String blobName, long position, long length) throws IOExcep\n         }\n     }\n \n+    public void writeBlob(String blobName, BytesReference bytes, boolean failIfAlreadyExists) throws IOException {\n+        final BlobInfo blobInfo = BlobInfo.newBuilder(bucketName, blobName).build();\n+        executePutMultipartBlob(blobInfo, failIfAlreadyExists, BytesReference.toBytes(bytes));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTg3MjUwOQ=="}, "originalCommit": {"oid": "753d841e5da2f1d78d08a7c20bb0d301063b2f32"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjAwODkxMA==", "bodyText": "I'll revert the changes for GCP \ud83d\udc4d", "url": "https://github.com/elastic/elasticsearch/pull/66683#discussion_r552008910", "createdAt": "2021-01-05T15:36:03Z", "author": {"login": "fcofdez"}, "path": "plugins/repository-gcs/src/main/java/org/elasticsearch/repositories/gcs/GoogleCloudStorageBlobStore.java", "diffHunk": "@@ -226,6 +227,11 @@ InputStream readBlob(String blobName, long position, long length) throws IOExcep\n         }\n     }\n \n+    public void writeBlob(String blobName, BytesReference bytes, boolean failIfAlreadyExists) throws IOException {\n+        final BlobInfo blobInfo = BlobInfo.newBuilder(bucketName, blobName).build();\n+        executePutMultipartBlob(blobInfo, failIfAlreadyExists, BytesReference.toBytes(bytes));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTg3MjUwOQ=="}, "originalCommit": {"oid": "753d841e5da2f1d78d08a7c20bb0d301063b2f32"}, "originalPosition": 14}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4504, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}