{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQzNTk0Mjk4", "number": 58933, "title": "[ML] add exponent output aggregator to inference", "bodyText": "This adds support for the exponent output aggregator for ensemble.\nThis is necessary as ensemble models trained by data frame analytics with the mlse loss function cannot simply be summed up.", "createdAt": "2020-07-02T15:30:42Z", "url": "https://github.com/elastic/elasticsearch/pull/58933", "merged": true, "mergeCommit": {"oid": "6238d4fc49edbae1fbfbe161cdb9c4cfad82f790"}, "closed": true, "closedAt": "2020-07-03T12:22:02Z", "author": {"login": "benwtrent"}, "timelineItems": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcxAlVYgH2gAyNDQzNTk0Mjk4OjkzZjA1N2M5ZWVmZmNiMDU1ZTMzOWQ4MDlmOWI3ZTUyOWQ0ZWZkZWU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcxSdFlAFqTQ0MjM3NDAyNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "93f057c9eeffcb055e339d809f9b7e529d4efdee", "author": {"user": {"login": "benwtrent", "name": "Benjamin Trent"}}, "url": "https://github.com/elastic/elasticsearch/commit/93f057c9eeffcb055e339d809f9b7e529d4efdee", "committedDate": "2020-07-02T15:29:09Z", "message": "[ML] add exponent output aggregator to inference"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "84748c3519196f7db3d65dcf37e604ffe49446fc", "author": {"user": {"login": "benwtrent", "name": "Benjamin Trent"}}, "url": "https://github.com/elastic/elasticsearch/commit/84748c3519196f7db3d65dcf37e604ffe49446fc", "committedDate": "2020-07-02T15:40:34Z", "message": "fixing docs"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyMjEzMTYy", "url": "https://github.com/elastic/elasticsearch/pull/58933#pullrequestreview-442213162", "createdAt": "2020-07-03T07:46:39Z", "commit": {"oid": "84748c3519196f7db3d65dcf37e604ffe49446fc"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyMzc0MDI3", "url": "https://github.com/elastic/elasticsearch/pull/58933#pullrequestreview-442374027", "createdAt": "2020-07-03T12:18:07Z", "commit": {"oid": "84748c3519196f7db3d65dcf37e604ffe49446fc"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxMjoxODowOFrOGsulBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxMjoxODowOFrOGsulBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU1MzY2OA==", "bodyText": "You've got the math right! \ud83d\udc4d", "url": "https://github.com/elastic/elasticsearch/pull/58933#discussion_r449553668", "createdAt": "2020-07-03T12:18:08Z", "author": {"login": "valeriy42"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/trainedmodel/ensemble/Exponent.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ml.inference.trainedmodel.ensemble;\n+\n+import org.apache.lucene.util.RamUsageEstimator;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.TargetType;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class Exponent implements StrictlyParsedOutputAggregator, LenientlyParsedOutputAggregator {\n+\n+    public static final long SHALLOW_SIZE = RamUsageEstimator.shallowSizeOfInstance(Exponent.class);\n+    public static final ParseField NAME = new ParseField(\"exponent\");\n+    public static final ParseField WEIGHTS = new ParseField(\"weights\");\n+\n+    private static final ConstructingObjectParser<Exponent, Void> LENIENT_PARSER = createParser(true);\n+    private static final ConstructingObjectParser<Exponent, Void> STRICT_PARSER = createParser(false);\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static ConstructingObjectParser<Exponent, Void> createParser(boolean lenient) {\n+        ConstructingObjectParser<Exponent, Void> parser = new ConstructingObjectParser<>(\n+            NAME.getPreferredName(),\n+            lenient,\n+            a -> new Exponent((List<Double>)a[0]));\n+        parser.declareDoubleArray(ConstructingObjectParser.optionalConstructorArg(), WEIGHTS);\n+        return parser;\n+    }\n+\n+    public static Exponent fromXContentStrict(XContentParser parser) {\n+        return STRICT_PARSER.apply(parser, null);\n+    }\n+\n+    public static Exponent fromXContentLenient(XContentParser parser) {\n+        return LENIENT_PARSER.apply(parser, null);\n+    }\n+\n+    private final double[] weights;\n+\n+    Exponent() {\n+        this((List<Double>) null);\n+    }\n+\n+    private Exponent(List<Double> weights) {\n+        this(weights == null ? null : weights.stream().mapToDouble(Double::valueOf).toArray());\n+    }\n+\n+    public Exponent(double[] weights) {\n+        this.weights = weights;\n+    }\n+\n+    public Exponent(StreamInput in) throws IOException {\n+        if (in.readBoolean()) {\n+            this.weights = in.readDoubleArray();\n+        } else {\n+            this.weights = null;\n+        }\n+    }\n+\n+    @Override\n+    public Integer expectedValueSize() {\n+        return this.weights == null ? null : this.weights.length;\n+    }\n+\n+    @Override\n+    public double[] processValues(double[][] values) {\n+        Objects.requireNonNull(values, \"values must not be null\");\n+        if (weights != null && values.length != weights.length) {\n+            throw new IllegalArgumentException(\"values must be the same length as weights.\");\n+        }\n+        assert values[0].length == 1;\n+        double[] processed = new double[values.length];\n+        for (int i = 0; i < values.length; ++i) {\n+            if (weights != null) {\n+                processed[i] = weights[i] * values[i][0];\n+            } else {\n+                processed[i] = values[i][0];\n+            }\n+        }\n+        return processed;\n+    }\n+\n+    @Override\n+    public double aggregate(double[] values) {\n+        Objects.requireNonNull(values, \"values must not be null\");\n+        double sum = 0.0;\n+        for (double val : values) {\n+            if (Double.isFinite(val)) {\n+                sum += val;\n+            }\n+        }\n+        return Math.exp(sum);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84748c3519196f7db3d65dcf37e604ffe49446fc"}, "originalPosition": 103}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2400, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}