{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg5Mzc5MTg5", "number": 62640, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwOTozNToyN1rOEmAKBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwOTo0MTo0NVrOEmATKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MjgzOTA5OnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/elasticsearch/gateway/PriorityComparatorTests.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwOTozNToyN1rOHVx8lg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxMTowMDo1M1rOHV0xAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYwMDQ3MA==", "bodyText": "nit: since i can span to 99 using a prefix like \"idx_\" makes more sense", "url": "https://github.com/elastic/elasticsearch/pull/62640#discussion_r492600470", "createdAt": "2020-09-22T09:35:27Z", "author": {"login": "tlrx"}, "path": "server/src/test/java/org/elasticsearch/gateway/PriorityComparatorTests.java", "diffHunk": "@@ -106,75 +147,102 @@ protected Settings getIndexSettings(Index index) {\n     public void testPriorityComparatorSort() {\n         RoutingNodes.UnassignedShards shards = new RoutingNodes.UnassignedShards(mock(RoutingNodes.class));\n         int numIndices = randomIntBetween(3, 99);\n-        IndexMeta[] indices = new IndexMeta[numIndices];\n-        final Map<String, IndexMeta> map = new HashMap<>();\n+        IndexMetadata[] indices = new IndexMetadata[numIndices];\n+        final Map<String, IndexMetadata> map = new HashMap<>();\n \n         for (int i = 0; i < indices.length; i++) {\n+            int priority = 0;\n+            int creationDate = 0;\n+            boolean isSystem = false;\n+\n             if (frequently()) {\n-                indices[i] = new IndexMeta(\"idx_2015_04_\" + String.format(Locale.ROOT, \"%02d\", i), randomIntBetween(1, 1000),\n-                    randomIntBetween(1, 10000));\n-            } else { // sometimes just use defaults\n-                indices[i] = new IndexMeta(\"idx_2015_04_\" +  String.format(Locale.ROOT, \"%02d\", i));\n+                priority = randomIntBetween(1, 1000);\n+                creationDate = randomIntBetween(1, 10000);\n             }\n-            map.put(indices[i].name, indices[i]);\n+            if (rarely()) {\n+                isSystem = true;\n+            }\n+            // else sometimes just use the defaults\n+\n+            indices[i] = IndexMetadata.builder(\"idx_2015_04_\" + String.format(Locale.ROOT, \"%02d\", i))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67f7711bb3644be1ed2fdd936e6122e6cc392094"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYyNjA2OQ==", "bodyText": "Are you suggesting just \"idx_\" + i?\nI'm not sure what the best thing to do here is. The comparator class just does a compareTo on the index names, so in a sense it doesn't matter what index names we use, so long as the result is sorted the way we expect. However, the intention of the sort is that newer indices, according to dates in the index names, are sorted first. So I wonder if it's worth preserving a date-like pattern in the index names for that reason? What do you think?", "url": "https://github.com/elastic/elasticsearch/pull/62640#discussion_r492626069", "createdAt": "2020-09-22T10:21:13Z", "author": {"login": "pugnascotia"}, "path": "server/src/test/java/org/elasticsearch/gateway/PriorityComparatorTests.java", "diffHunk": "@@ -106,75 +147,102 @@ protected Settings getIndexSettings(Index index) {\n     public void testPriorityComparatorSort() {\n         RoutingNodes.UnassignedShards shards = new RoutingNodes.UnassignedShards(mock(RoutingNodes.class));\n         int numIndices = randomIntBetween(3, 99);\n-        IndexMeta[] indices = new IndexMeta[numIndices];\n-        final Map<String, IndexMeta> map = new HashMap<>();\n+        IndexMetadata[] indices = new IndexMetadata[numIndices];\n+        final Map<String, IndexMetadata> map = new HashMap<>();\n \n         for (int i = 0; i < indices.length; i++) {\n+            int priority = 0;\n+            int creationDate = 0;\n+            boolean isSystem = false;\n+\n             if (frequently()) {\n-                indices[i] = new IndexMeta(\"idx_2015_04_\" + String.format(Locale.ROOT, \"%02d\", i), randomIntBetween(1, 1000),\n-                    randomIntBetween(1, 10000));\n-            } else { // sometimes just use defaults\n-                indices[i] = new IndexMeta(\"idx_2015_04_\" +  String.format(Locale.ROOT, \"%02d\", i));\n+                priority = randomIntBetween(1, 1000);\n+                creationDate = randomIntBetween(1, 10000);\n             }\n-            map.put(indices[i].name, indices[i]);\n+            if (rarely()) {\n+                isSystem = true;\n+            }\n+            // else sometimes just use the defaults\n+\n+            indices[i] = IndexMetadata.builder(\"idx_2015_04_\" + String.format(Locale.ROOT, \"%02d\", i))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYwMDQ3MA=="}, "originalCommit": {"oid": "67f7711bb3644be1ed2fdd936e6122e6cc392094"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjY0MDg1Nw==", "bodyText": "I think that we should test what the code is effectively doing, ie alphabetically sorting by index names. Applying this to index names that contain a date is sort of a workaround as most of the time SETTING_CREATION_DATE should be present. Prioritizing index-0002 over index-0001 is also a thing.", "url": "https://github.com/elastic/elasticsearch/pull/62640#discussion_r492640857", "createdAt": "2020-09-22T10:50:49Z", "author": {"login": "tlrx"}, "path": "server/src/test/java/org/elasticsearch/gateway/PriorityComparatorTests.java", "diffHunk": "@@ -106,75 +147,102 @@ protected Settings getIndexSettings(Index index) {\n     public void testPriorityComparatorSort() {\n         RoutingNodes.UnassignedShards shards = new RoutingNodes.UnassignedShards(mock(RoutingNodes.class));\n         int numIndices = randomIntBetween(3, 99);\n-        IndexMeta[] indices = new IndexMeta[numIndices];\n-        final Map<String, IndexMeta> map = new HashMap<>();\n+        IndexMetadata[] indices = new IndexMetadata[numIndices];\n+        final Map<String, IndexMetadata> map = new HashMap<>();\n \n         for (int i = 0; i < indices.length; i++) {\n+            int priority = 0;\n+            int creationDate = 0;\n+            boolean isSystem = false;\n+\n             if (frequently()) {\n-                indices[i] = new IndexMeta(\"idx_2015_04_\" + String.format(Locale.ROOT, \"%02d\", i), randomIntBetween(1, 1000),\n-                    randomIntBetween(1, 10000));\n-            } else { // sometimes just use defaults\n-                indices[i] = new IndexMeta(\"idx_2015_04_\" +  String.format(Locale.ROOT, \"%02d\", i));\n+                priority = randomIntBetween(1, 1000);\n+                creationDate = randomIntBetween(1, 10000);\n             }\n-            map.put(indices[i].name, indices[i]);\n+            if (rarely()) {\n+                isSystem = true;\n+            }\n+            // else sometimes just use the defaults\n+\n+            indices[i] = IndexMetadata.builder(\"idx_2015_04_\" + String.format(Locale.ROOT, \"%02d\", i))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYwMDQ3MA=="}, "originalCommit": {"oid": "67f7711bb3644be1ed2fdd936e6122e6cc392094"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjY0NDY5MA==", "bodyText": "I swapped it for just \"idx_%04d\". Any better?", "url": "https://github.com/elastic/elasticsearch/pull/62640#discussion_r492644690", "createdAt": "2020-09-22T10:57:05Z", "author": {"login": "pugnascotia"}, "path": "server/src/test/java/org/elasticsearch/gateway/PriorityComparatorTests.java", "diffHunk": "@@ -106,75 +147,102 @@ protected Settings getIndexSettings(Index index) {\n     public void testPriorityComparatorSort() {\n         RoutingNodes.UnassignedShards shards = new RoutingNodes.UnassignedShards(mock(RoutingNodes.class));\n         int numIndices = randomIntBetween(3, 99);\n-        IndexMeta[] indices = new IndexMeta[numIndices];\n-        final Map<String, IndexMeta> map = new HashMap<>();\n+        IndexMetadata[] indices = new IndexMetadata[numIndices];\n+        final Map<String, IndexMetadata> map = new HashMap<>();\n \n         for (int i = 0; i < indices.length; i++) {\n+            int priority = 0;\n+            int creationDate = 0;\n+            boolean isSystem = false;\n+\n             if (frequently()) {\n-                indices[i] = new IndexMeta(\"idx_2015_04_\" + String.format(Locale.ROOT, \"%02d\", i), randomIntBetween(1, 1000),\n-                    randomIntBetween(1, 10000));\n-            } else { // sometimes just use defaults\n-                indices[i] = new IndexMeta(\"idx_2015_04_\" +  String.format(Locale.ROOT, \"%02d\", i));\n+                priority = randomIntBetween(1, 1000);\n+                creationDate = randomIntBetween(1, 10000);\n             }\n-            map.put(indices[i].name, indices[i]);\n+            if (rarely()) {\n+                isSystem = true;\n+            }\n+            // else sometimes just use the defaults\n+\n+            indices[i] = IndexMetadata.builder(\"idx_2015_04_\" + String.format(Locale.ROOT, \"%02d\", i))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYwMDQ3MA=="}, "originalCommit": {"oid": "67f7711bb3644be1ed2fdd936e6122e6cc392094"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjY0NjY1OQ==", "bodyText": "Thanks!", "url": "https://github.com/elastic/elasticsearch/pull/62640#discussion_r492646659", "createdAt": "2020-09-22T11:00:53Z", "author": {"login": "tlrx"}, "path": "server/src/test/java/org/elasticsearch/gateway/PriorityComparatorTests.java", "diffHunk": "@@ -106,75 +147,102 @@ protected Settings getIndexSettings(Index index) {\n     public void testPriorityComparatorSort() {\n         RoutingNodes.UnassignedShards shards = new RoutingNodes.UnassignedShards(mock(RoutingNodes.class));\n         int numIndices = randomIntBetween(3, 99);\n-        IndexMeta[] indices = new IndexMeta[numIndices];\n-        final Map<String, IndexMeta> map = new HashMap<>();\n+        IndexMetadata[] indices = new IndexMetadata[numIndices];\n+        final Map<String, IndexMetadata> map = new HashMap<>();\n \n         for (int i = 0; i < indices.length; i++) {\n+            int priority = 0;\n+            int creationDate = 0;\n+            boolean isSystem = false;\n+\n             if (frequently()) {\n-                indices[i] = new IndexMeta(\"idx_2015_04_\" + String.format(Locale.ROOT, \"%02d\", i), randomIntBetween(1, 1000),\n-                    randomIntBetween(1, 10000));\n-            } else { // sometimes just use defaults\n-                indices[i] = new IndexMeta(\"idx_2015_04_\" +  String.format(Locale.ROOT, \"%02d\", i));\n+                priority = randomIntBetween(1, 1000);\n+                creationDate = randomIntBetween(1, 10000);\n             }\n-            map.put(indices[i].name, indices[i]);\n+            if (rarely()) {\n+                isSystem = true;\n+            }\n+            // else sometimes just use the defaults\n+\n+            indices[i] = IndexMetadata.builder(\"idx_2015_04_\" + String.format(Locale.ROOT, \"%02d\", i))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYwMDQ3MA=="}, "originalCommit": {"oid": "67f7711bb3644be1ed2fdd936e6122e6cc392094"}, "originalPosition": 120}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4Mjg2MjQ5OnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/elasticsearch/gateway/PriorityComparatorTests.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwOTo0MTo0NVrOHVyLMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxMDo1MDo1MFrOHV0aZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYwNDIwOA==", "bodyText": "Maybe\nassertThat(\"system mismatch, expected:\" + currentMeta.isSystem() + \" after \" + prevMeta.isSystem(),\nBoolean.compare(prevMeta.isSystem(), currentMeta.isSystem()), greaterThanOrEqualTo(0));", "url": "https://github.com/elastic/elasticsearch/pull/62640#discussion_r492604208", "createdAt": "2020-09-22T09:41:45Z", "author": {"login": "tlrx"}, "path": "server/src/test/java/org/elasticsearch/gateway/PriorityComparatorTests.java", "diffHunk": "@@ -106,75 +147,102 @@ protected Settings getIndexSettings(Index index) {\n     public void testPriorityComparatorSort() {\n         RoutingNodes.UnassignedShards shards = new RoutingNodes.UnassignedShards(mock(RoutingNodes.class));\n         int numIndices = randomIntBetween(3, 99);\n-        IndexMeta[] indices = new IndexMeta[numIndices];\n-        final Map<String, IndexMeta> map = new HashMap<>();\n+        IndexMetadata[] indices = new IndexMetadata[numIndices];\n+        final Map<String, IndexMetadata> map = new HashMap<>();\n \n         for (int i = 0; i < indices.length; i++) {\n+            int priority = 0;\n+            int creationDate = 0;\n+            boolean isSystem = false;\n+\n             if (frequently()) {\n-                indices[i] = new IndexMeta(\"idx_2015_04_\" + String.format(Locale.ROOT, \"%02d\", i), randomIntBetween(1, 1000),\n-                    randomIntBetween(1, 10000));\n-            } else { // sometimes just use defaults\n-                indices[i] = new IndexMeta(\"idx_2015_04_\" +  String.format(Locale.ROOT, \"%02d\", i));\n+                priority = randomIntBetween(1, 1000);\n+                creationDate = randomIntBetween(1, 10000);\n             }\n-            map.put(indices[i].name, indices[i]);\n+            if (rarely()) {\n+                isSystem = true;\n+            }\n+            // else sometimes just use the defaults\n+\n+            indices[i] = IndexMetadata.builder(\"idx_2015_04_\" + String.format(Locale.ROOT, \"%02d\", i))\n+                .system(isSystem)\n+                .settings(buildSettings(creationDate, priority))\n+                .build();\n+\n+            map.put(indices[i].getIndex().getName(), indices[i]);\n         }\n         int numShards = randomIntBetween(10, 100);\n         for (int i = 0; i < numShards; i++) {\n-            IndexMeta indexMeta = randomFrom(indices);\n-            shards.add(TestShardRouting.newShardRouting(indexMeta.name, randomIntBetween(1, 5), null, null,\n+            IndexMetadata indexMeta = randomFrom(indices);\n+            shards.add(TestShardRouting.newShardRouting(indexMeta.getIndex().getName(), randomIntBetween(1, 5), null, null,\n                     randomBoolean(), ShardRoutingState.UNASSIGNED, new UnassignedInfo(randomFrom(UnassignedInfo.Reason.values()),\n                     \"foobar\")));\n         }\n         shards.sort(new PriorityComparator() {\n             @Override\n-            protected Settings getIndexSettings(Index index) {\n-                IndexMeta indexMeta = map.get(index.getName());\n-                return indexMeta.settings;\n+            protected IndexMetadata getMetadata(Index index) {\n+                return map.get(index.getName());\n             }\n         });\n         ShardRouting previous = null;\n         for (ShardRouting routing : shards) {\n             if (previous != null) {\n-                IndexMeta prevMeta = map.get(previous.getIndexName());\n-                IndexMeta currentMeta = map.get(routing.getIndexName());\n-                if (prevMeta.priority == currentMeta.priority) {\n-                    if (prevMeta.creationDate == currentMeta.creationDate) {\n-                        if (prevMeta.name.equals(currentMeta.name) == false) {\n-                            assertTrue(\"indexName mismatch, expected:\" + currentMeta.name + \" after \" + prevMeta.name + \" \" +\n-                                prevMeta.name.compareTo(currentMeta.name), prevMeta.name.compareTo(currentMeta.name) > 0);\n+                IndexMetadata prevMeta = map.get(previous.getIndexName());\n+                IndexMetadata currentMeta = map.get(routing.getIndexName());\n+\n+                if (prevMeta.isSystem() == currentMeta.isSystem()) {\n+                    final int prevPriority = prevMeta.getSettings().getAsInt(IndexMetadata.SETTING_PRIORITY, -1);\n+                    final int currentPriority = currentMeta.getSettings().getAsInt(IndexMetadata.SETTING_PRIORITY, -1);\n+\n+                    if (prevPriority == currentPriority) {\n+                        final int prevCreationDate = prevMeta.getSettings().getAsInt(IndexMetadata.SETTING_CREATION_DATE, -1);\n+                        final int currentCreationDate = currentMeta.getSettings().getAsInt(IndexMetadata.SETTING_CREATION_DATE, -1);\n+\n+                        if (prevCreationDate == currentCreationDate) {\n+                            final String prevName = prevMeta.getIndex().getName();\n+                            final String currentName = currentMeta.getIndex().getName();\n+\n+                            if (prevName.equals(currentName) == false) {\n+                                assertTrue(\n+                                    \"indexName mismatch, expected:\"\n+                                        + currentName\n+                                        + \" after \"\n+                                        + prevName\n+                                        + \" \"\n+                                        + prevName.compareTo(currentName),\n+                                    prevName.compareTo(currentName) > 0\n+                                );\n+                            }\n+                        } else {\n+                            assertTrue(\n+                                \"creationDate mismatch, expected:\" + currentCreationDate + \" after \" + prevCreationDate,\n+                                prevCreationDate > currentCreationDate\n+                            );\n                         }\n                     } else {\n-                        assertTrue(\"creationDate mismatch, expected:\" + currentMeta.creationDate + \" after \" + prevMeta.creationDate,\n-                            prevMeta.creationDate > currentMeta.creationDate);\n+                        assertTrue(\n+                            \"priority mismatch, expected:\" + currentPriority + \" after \" + prevPriority,\n+                            prevPriority > currentPriority\n+                        );\n                     }\n                 } else {\n-                    assertTrue(\"priority mismatch, expected:\" +  currentMeta.priority + \" after \" + prevMeta.priority,\n-                        prevMeta.priority > currentMeta.priority);\n+                    assertTrue(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67f7711bb3644be1ed2fdd936e6122e6cc392094"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjY0MDg2OA==", "bodyText": "I changed it to a modified version of your suggestion, using greaterThan(). I also changed the other assertions for consistency.", "url": "https://github.com/elastic/elasticsearch/pull/62640#discussion_r492640868", "createdAt": "2020-09-22T10:50:50Z", "author": {"login": "pugnascotia"}, "path": "server/src/test/java/org/elasticsearch/gateway/PriorityComparatorTests.java", "diffHunk": "@@ -106,75 +147,102 @@ protected Settings getIndexSettings(Index index) {\n     public void testPriorityComparatorSort() {\n         RoutingNodes.UnassignedShards shards = new RoutingNodes.UnassignedShards(mock(RoutingNodes.class));\n         int numIndices = randomIntBetween(3, 99);\n-        IndexMeta[] indices = new IndexMeta[numIndices];\n-        final Map<String, IndexMeta> map = new HashMap<>();\n+        IndexMetadata[] indices = new IndexMetadata[numIndices];\n+        final Map<String, IndexMetadata> map = new HashMap<>();\n \n         for (int i = 0; i < indices.length; i++) {\n+            int priority = 0;\n+            int creationDate = 0;\n+            boolean isSystem = false;\n+\n             if (frequently()) {\n-                indices[i] = new IndexMeta(\"idx_2015_04_\" + String.format(Locale.ROOT, \"%02d\", i), randomIntBetween(1, 1000),\n-                    randomIntBetween(1, 10000));\n-            } else { // sometimes just use defaults\n-                indices[i] = new IndexMeta(\"idx_2015_04_\" +  String.format(Locale.ROOT, \"%02d\", i));\n+                priority = randomIntBetween(1, 1000);\n+                creationDate = randomIntBetween(1, 10000);\n             }\n-            map.put(indices[i].name, indices[i]);\n+            if (rarely()) {\n+                isSystem = true;\n+            }\n+            // else sometimes just use the defaults\n+\n+            indices[i] = IndexMetadata.builder(\"idx_2015_04_\" + String.format(Locale.ROOT, \"%02d\", i))\n+                .system(isSystem)\n+                .settings(buildSettings(creationDate, priority))\n+                .build();\n+\n+            map.put(indices[i].getIndex().getName(), indices[i]);\n         }\n         int numShards = randomIntBetween(10, 100);\n         for (int i = 0; i < numShards; i++) {\n-            IndexMeta indexMeta = randomFrom(indices);\n-            shards.add(TestShardRouting.newShardRouting(indexMeta.name, randomIntBetween(1, 5), null, null,\n+            IndexMetadata indexMeta = randomFrom(indices);\n+            shards.add(TestShardRouting.newShardRouting(indexMeta.getIndex().getName(), randomIntBetween(1, 5), null, null,\n                     randomBoolean(), ShardRoutingState.UNASSIGNED, new UnassignedInfo(randomFrom(UnassignedInfo.Reason.values()),\n                     \"foobar\")));\n         }\n         shards.sort(new PriorityComparator() {\n             @Override\n-            protected Settings getIndexSettings(Index index) {\n-                IndexMeta indexMeta = map.get(index.getName());\n-                return indexMeta.settings;\n+            protected IndexMetadata getMetadata(Index index) {\n+                return map.get(index.getName());\n             }\n         });\n         ShardRouting previous = null;\n         for (ShardRouting routing : shards) {\n             if (previous != null) {\n-                IndexMeta prevMeta = map.get(previous.getIndexName());\n-                IndexMeta currentMeta = map.get(routing.getIndexName());\n-                if (prevMeta.priority == currentMeta.priority) {\n-                    if (prevMeta.creationDate == currentMeta.creationDate) {\n-                        if (prevMeta.name.equals(currentMeta.name) == false) {\n-                            assertTrue(\"indexName mismatch, expected:\" + currentMeta.name + \" after \" + prevMeta.name + \" \" +\n-                                prevMeta.name.compareTo(currentMeta.name), prevMeta.name.compareTo(currentMeta.name) > 0);\n+                IndexMetadata prevMeta = map.get(previous.getIndexName());\n+                IndexMetadata currentMeta = map.get(routing.getIndexName());\n+\n+                if (prevMeta.isSystem() == currentMeta.isSystem()) {\n+                    final int prevPriority = prevMeta.getSettings().getAsInt(IndexMetadata.SETTING_PRIORITY, -1);\n+                    final int currentPriority = currentMeta.getSettings().getAsInt(IndexMetadata.SETTING_PRIORITY, -1);\n+\n+                    if (prevPriority == currentPriority) {\n+                        final int prevCreationDate = prevMeta.getSettings().getAsInt(IndexMetadata.SETTING_CREATION_DATE, -1);\n+                        final int currentCreationDate = currentMeta.getSettings().getAsInt(IndexMetadata.SETTING_CREATION_DATE, -1);\n+\n+                        if (prevCreationDate == currentCreationDate) {\n+                            final String prevName = prevMeta.getIndex().getName();\n+                            final String currentName = currentMeta.getIndex().getName();\n+\n+                            if (prevName.equals(currentName) == false) {\n+                                assertTrue(\n+                                    \"indexName mismatch, expected:\"\n+                                        + currentName\n+                                        + \" after \"\n+                                        + prevName\n+                                        + \" \"\n+                                        + prevName.compareTo(currentName),\n+                                    prevName.compareTo(currentName) > 0\n+                                );\n+                            }\n+                        } else {\n+                            assertTrue(\n+                                \"creationDate mismatch, expected:\" + currentCreationDate + \" after \" + prevCreationDate,\n+                                prevCreationDate > currentCreationDate\n+                            );\n                         }\n                     } else {\n-                        assertTrue(\"creationDate mismatch, expected:\" + currentMeta.creationDate + \" after \" + prevMeta.creationDate,\n-                            prevMeta.creationDate > currentMeta.creationDate);\n+                        assertTrue(\n+                            \"priority mismatch, expected:\" + currentPriority + \" after \" + prevPriority,\n+                            prevPriority > currentPriority\n+                        );\n                     }\n                 } else {\n-                    assertTrue(\"priority mismatch, expected:\" +  currentMeta.priority + \" after \" + prevMeta.priority,\n-                        prevMeta.priority > currentMeta.priority);\n+                    assertTrue(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYwNDIwOA=="}, "originalCommit": {"oid": "67f7711bb3644be1ed2fdd936e6122e6cc392094"}, "originalPosition": 198}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3473, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}