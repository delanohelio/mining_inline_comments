{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE3NTIyNDM3", "number": 64757, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwOToyMjozOFrOE2rEEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwOToyMjozOFrOE2rEEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1NzY0MTE1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/internalClusterTest/java/org/elasticsearch/xpack/security/authc/TokenAuthIntegTests.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwOToyMjozOFrOHvli6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwMjo1ODo1MVrOHwJ2UQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY2MDI2NQ==", "bodyText": "It is worthwhile to link #64259 here because that is what actually fixed this assertion (original error of #56903).", "url": "https://github.com/elastic/elasticsearch/pull/64757#discussion_r519660265", "createdAt": "2020-11-09T09:22:38Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/internalClusterTest/java/org/elasticsearch/xpack/security/authc/TokenAuthIntegTests.java", "diffHunk": "@@ -194,11 +194,26 @@ public void testExpiredTokensDeletedAfterExpiration() throws Exception {\n         assertThat(invalidateAccessTokenResponse.getPreviouslyInvalidatedTokens(), equalTo(0));\n         assertThat(invalidateAccessTokenResponse.getErrors(), empty());\n \n+        // Weird testing behaviour ahead...\n+        // invalidating by access token (above) is a Get, but invalidating by refresh token (below) is a Search\n+        // In a multi node cluster, in a small % of cases, the search might find a document that has been invalidated but not yet deleted\n+        // from that node's shard.\n+        // Our assertion, therefore, is that an attempt to invalidate the (already invalidated) refresh token must not actually invalidate\n+        // anything (concurrency controls must prevent that), nor may return any errors,\n+        // but it might _temporarily_ find an \"already invalidated\" token.\n+        final InvalidateTokenRequest invalidateRefreshTokenRequest = InvalidateTokenRequest.refreshToken(refreshToken);\n         InvalidateTokenResponse invalidateRefreshTokenResponse = restClient.security().invalidateToken(\n-            InvalidateTokenRequest.refreshToken(refreshToken), SECURITY_REQUEST_OPTIONS);\n+            invalidateRefreshTokenRequest, SECURITY_REQUEST_OPTIONS);\n         assertThat(invalidateRefreshTokenResponse.getInvalidatedTokens(), equalTo(0));\n-        assertThat(invalidateRefreshTokenResponse.getPreviouslyInvalidatedTokens(), equalTo(0));\n         assertThat(invalidateRefreshTokenResponse.getErrors(), empty());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a0c67d6618c63cad1b9171eb81001fe71499d81"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI0MTMzMQ==", "bodyText": "I don't follow.\nDo you want this PR to reference another PR that is loosely related (they've both linked to the original issue)? Or do you want the code to reference the PR.\nI didn't link these because they're separate pieces of work. One fixed a particular error in the code and the other fixes an incorrect assumption in the test. Both PRs link back to the original issue because the precised CI failure was a combination of the two, but I don't think the PRs themselves are that closely related.", "url": "https://github.com/elastic/elasticsearch/pull/64757#discussion_r520241331", "createdAt": "2020-11-10T02:13:59Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/internalClusterTest/java/org/elasticsearch/xpack/security/authc/TokenAuthIntegTests.java", "diffHunk": "@@ -194,11 +194,26 @@ public void testExpiredTokensDeletedAfterExpiration() throws Exception {\n         assertThat(invalidateAccessTokenResponse.getPreviouslyInvalidatedTokens(), equalTo(0));\n         assertThat(invalidateAccessTokenResponse.getErrors(), empty());\n \n+        // Weird testing behaviour ahead...\n+        // invalidating by access token (above) is a Get, but invalidating by refresh token (below) is a Search\n+        // In a multi node cluster, in a small % of cases, the search might find a document that has been invalidated but not yet deleted\n+        // from that node's shard.\n+        // Our assertion, therefore, is that an attempt to invalidate the (already invalidated) refresh token must not actually invalidate\n+        // anything (concurrency controls must prevent that), nor may return any errors,\n+        // but it might _temporarily_ find an \"already invalidated\" token.\n+        final InvalidateTokenRequest invalidateRefreshTokenRequest = InvalidateTokenRequest.refreshToken(refreshToken);\n         InvalidateTokenResponse invalidateRefreshTokenResponse = restClient.security().invalidateToken(\n-            InvalidateTokenRequest.refreshToken(refreshToken), SECURITY_REQUEST_OPTIONS);\n+            invalidateRefreshTokenRequest, SECURITY_REQUEST_OPTIONS);\n         assertThat(invalidateRefreshTokenResponse.getInvalidatedTokens(), equalTo(0));\n-        assertThat(invalidateRefreshTokenResponse.getPreviouslyInvalidatedTokens(), equalTo(0));\n         assertThat(invalidateRefreshTokenResponse.getErrors(), empty());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY2MDI2NQ=="}, "originalCommit": {"oid": "1a0c67d6618c63cad1b9171eb81001fe71499d81"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI1NTA1Nw==", "bodyText": "The former. This is mainly a note to myself. I am not suggesting you to do anything. I did not review the other PR. So I was a bit confused when trying to cross compare the build scan failure and the changes in this PR, which \"resolves\" the failure. Initially they seemed to be unrelated to me.\nFrom the build scan, the exact error occured at the following line :\nassertThat(invalidateRefreshTokenResponse.getErrors(), empty());\nand technically speaking, the above error can be fixed by the other PR alone. By itself it will not be able to fix the \"getPreviouslyInvalidatedTokens\" assertion, but that was not the original error. So I added the comment as a reminder to my-future-self or maybe someone else who might need to look into it in future.", "url": "https://github.com/elastic/elasticsearch/pull/64757#discussion_r520255057", "createdAt": "2020-11-10T02:58:51Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/internalClusterTest/java/org/elasticsearch/xpack/security/authc/TokenAuthIntegTests.java", "diffHunk": "@@ -194,11 +194,26 @@ public void testExpiredTokensDeletedAfterExpiration() throws Exception {\n         assertThat(invalidateAccessTokenResponse.getPreviouslyInvalidatedTokens(), equalTo(0));\n         assertThat(invalidateAccessTokenResponse.getErrors(), empty());\n \n+        // Weird testing behaviour ahead...\n+        // invalidating by access token (above) is a Get, but invalidating by refresh token (below) is a Search\n+        // In a multi node cluster, in a small % of cases, the search might find a document that has been invalidated but not yet deleted\n+        // from that node's shard.\n+        // Our assertion, therefore, is that an attempt to invalidate the (already invalidated) refresh token must not actually invalidate\n+        // anything (concurrency controls must prevent that), nor may return any errors,\n+        // but it might _temporarily_ find an \"already invalidated\" token.\n+        final InvalidateTokenRequest invalidateRefreshTokenRequest = InvalidateTokenRequest.refreshToken(refreshToken);\n         InvalidateTokenResponse invalidateRefreshTokenResponse = restClient.security().invalidateToken(\n-            InvalidateTokenRequest.refreshToken(refreshToken), SECURITY_REQUEST_OPTIONS);\n+            invalidateRefreshTokenRequest, SECURITY_REQUEST_OPTIONS);\n         assertThat(invalidateRefreshTokenResponse.getInvalidatedTokens(), equalTo(0));\n-        assertThat(invalidateRefreshTokenResponse.getPreviouslyInvalidatedTokens(), equalTo(0));\n         assertThat(invalidateRefreshTokenResponse.getErrors(), empty());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY2MDI2NQ=="}, "originalCommit": {"oid": "1a0c67d6618c63cad1b9171eb81001fe71499d81"}, "originalPosition": 17}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3137, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}