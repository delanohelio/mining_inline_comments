{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcwMjkyODA2", "number": 61342, "reviewThreads": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxODozOToxMFrOEcsw3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNzo1MzoyOVrOEdU9tw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4NTI4OTkwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataCreateIndexService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxODozOToxMFrOHHYyvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxODozOToxMFrOHHYyvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzUwODI4NQ==", "bodyText": "nit: :s/listener/provider", "url": "https://github.com/elastic/elasticsearch/pull/61342#discussion_r477508285", "createdAt": "2020-08-26T18:39:10Z", "author": {"login": "jakelandis"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataCreateIndexService.java", "diffHunk": "@@ -595,14 +611,65 @@ private ClusterState applyCreateIndexRequestWithExistingMetadata(final ClusterSt\n      * @return the aggregated settings for the new index\n      */\n     static Settings aggregateIndexSettings(ClusterState currentState, CreateIndexClusterStateUpdateRequest request,\n-                                           Settings templateSettings, @Nullable IndexMetadata sourceMetadata, Settings settings,\n-                                           IndexScopedSettings indexScopedSettings, ShardLimitValidator shardLimitValidator) {\n-        Settings.Builder indexSettingsBuilder = Settings.builder();\n+                                           Settings combinedTemplateSettings, @Nullable IndexMetadata sourceMetadata, Settings settings,\n+                                           IndexScopedSettings indexScopedSettings, ShardLimitValidator shardLimitValidator,\n+                                           Set<ExplicitIndexSettingProvider> explicitIndexSettingProviders) {\n+        // Create builders for the template and request settings. We transform these into builders\n+        // because we may want settings to be \"removed\" from these prior to being set on the new\n+        // index (see more comments below)\n+        final Settings.Builder templateSettings = Settings.builder().put(combinedTemplateSettings);\n+        final Settings.Builder requestSettings = Settings.builder().put(request.settings());\n+\n+        final Settings.Builder indexSettingsBuilder = Settings.builder();\n         if (sourceMetadata == null) {\n-            indexSettingsBuilder.put(templateSettings);\n+            final Settings.Builder explicitDefaultSettings = Settings.builder();\n+            final Settings templateAndRequestSettings = Settings.builder()\n+                .put(combinedTemplateSettings)\n+                .put(request.settings())\n+                .build();\n+\n+            // Loop through all the explicit index setting providers, adding them to the\n+            // explicitDefaultSettings map\n+            for (ExplicitIndexSettingProvider listener : explicitIndexSettingProviders) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed6c3dc8adf8d9f7e1f919abf047d400a27f6e48"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4NTQyODQ2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataCreateIndexService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxOToxMzo0MVrOHHaKbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxOToxMzo0MVrOHHaKbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzUzMDczMw==", "bodyText": "If we expected exceptions here, we should document it on the interface. However, I don't think we should.\nI think the contract should be that a provider provides all valid settings, or Settings.EMPTY if none can be satisfied. Removing the catch here and any exception thrown by a provider impl would result in a 500 and no index created, which I think is slightly better then settings that should have been applied but were not.", "url": "https://github.com/elastic/elasticsearch/pull/61342#discussion_r477530733", "createdAt": "2020-08-26T19:13:41Z", "author": {"login": "jakelandis"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataCreateIndexService.java", "diffHunk": "@@ -595,14 +611,65 @@ private ClusterState applyCreateIndexRequestWithExistingMetadata(final ClusterSt\n      * @return the aggregated settings for the new index\n      */\n     static Settings aggregateIndexSettings(ClusterState currentState, CreateIndexClusterStateUpdateRequest request,\n-                                           Settings templateSettings, @Nullable IndexMetadata sourceMetadata, Settings settings,\n-                                           IndexScopedSettings indexScopedSettings, ShardLimitValidator shardLimitValidator) {\n-        Settings.Builder indexSettingsBuilder = Settings.builder();\n+                                           Settings combinedTemplateSettings, @Nullable IndexMetadata sourceMetadata, Settings settings,\n+                                           IndexScopedSettings indexScopedSettings, ShardLimitValidator shardLimitValidator,\n+                                           Set<ExplicitIndexSettingProvider> explicitIndexSettingProviders) {\n+        // Create builders for the template and request settings. We transform these into builders\n+        // because we may want settings to be \"removed\" from these prior to being set on the new\n+        // index (see more comments below)\n+        final Settings.Builder templateSettings = Settings.builder().put(combinedTemplateSettings);\n+        final Settings.Builder requestSettings = Settings.builder().put(request.settings());\n+\n+        final Settings.Builder indexSettingsBuilder = Settings.builder();\n         if (sourceMetadata == null) {\n-            indexSettingsBuilder.put(templateSettings);\n+            final Settings.Builder explicitDefaultSettings = Settings.builder();\n+            final Settings templateAndRequestSettings = Settings.builder()\n+                .put(combinedTemplateSettings)\n+                .put(request.settings())\n+                .build();\n+\n+            // Loop through all the explicit index setting providers, adding them to the\n+            // explicitDefaultSettings map\n+            for (ExplicitIndexSettingProvider listener : explicitIndexSettingProviders) {\n+                try {\n+                    explicitDefaultSettings.put(listener.getExplicitIndexSettings(request.index(), templateAndRequestSettings));\n+                } catch (Exception e) {\n+                    logger.warn(new ParameterizedMessage(\"failed invoking explicit setting provider for creation of [{}] index\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed6c3dc8adf8d9f7e1f919abf047d400a27f6e48"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4NTQ4Mzc1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/DataTier.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxOTozMDoxOFrOHHasUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxOTozMDoxOFrOHHasUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzUzOTQxMA==", "bodyText": "nit: this if/elseif/else can be simplified to an if/elseif (just a minor style preference)", "url": "https://github.com/elastic/elasticsearch/pull/61342#discussion_r477539410", "createdAt": "2020-08-26T19:30:18Z", "author": {"login": "jakelandis"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/DataTier.java", "diffHunk": "@@ -137,4 +142,28 @@ public static boolean isColdNode(DiscoveryNode discoveryNode) {\n     public static boolean isFrozenNode(DiscoveryNode discoveryNode) {\n         return discoveryNode.getRoles().contains(DATA_FROZEN_NODE_ROLE) || discoveryNode.getRoles().contains(DiscoveryNodeRole.DATA_ROLE);\n     }\n+\n+    /**\n+     * This listener injects the setting allocating all newly created indices with\n+     * {@code index.routing.allocation.include._tier: \"data_hot\"} unless the user overrides the\n+     * setting while the index is being created (in a create index request for instance)\n+     */\n+    public static class DefaultHotAllocationSettingProvider implements ExplicitIndexSettingProvider {\n+        @Override\n+        public Settings getExplicitIndexSettings(String indexName, Settings indexSettings) {\n+            Set<String> settings = indexSettings.keySet();\n+            if (settings.contains(DataTierAllocationDecider.INDEX_ROUTING_INCLUDE)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed6c3dc8adf8d9f7e1f919abf047d400a27f6e48"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4NTQ5NDYxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/DataTier.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxOTozMzo1MVrOHHazNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxOTozMzo1MVrOHHazNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU0MTE3Mg==", "bodyText": "nit: the listener ? not sure i follow what that is in reference to..", "url": "https://github.com/elastic/elasticsearch/pull/61342#discussion_r477541172", "createdAt": "2020-08-26T19:33:51Z", "author": {"login": "jakelandis"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/DataTier.java", "diffHunk": "@@ -137,4 +142,28 @@ public static boolean isColdNode(DiscoveryNode discoveryNode) {\n     public static boolean isFrozenNode(DiscoveryNode discoveryNode) {\n         return discoveryNode.getRoles().contains(DATA_FROZEN_NODE_ROLE) || discoveryNode.getRoles().contains(DiscoveryNodeRole.DATA_ROLE);\n     }\n+\n+    /**\n+     * This listener injects the setting allocating all newly created indices with", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed6c3dc8adf8d9f7e1f919abf047d400a27f6e48"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4NTU0NzQzOnYy", "diffSide": "RIGHT", "path": "docs/reference/api-conventions.asciidoc", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxOTo0OToxM1rOHHbTSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQyMDozNzoxMVrOHHc0Ww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU0OTM4Nw==", "bodyText": "probably want to update https://www.elastic.co/guide/en/elasticsearch/reference/7.9/shard-allocation-filtering.html with or soon after this PR. (also https://www.elastic.co/guide/en/elasticsearch/reference/7.9/modules-node.html#data-node could use an update, but is outside the scope of this PR)", "url": "https://github.com/elastic/elasticsearch/pull/61342#discussion_r477549387", "createdAt": "2020-08-26T19:49:13Z", "author": {"login": "jakelandis"}, "path": "docs/reference/api-conventions.asciidoc", "diffHunk": "@@ -391,6 +391,7 @@ Returns:\n       \"index.creation_date\": \"1474389951325\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed6c3dc8adf8d9f7e1f919abf047d400a27f6e48"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU3NDIzNQ==", "bodyText": "Definitely, I am leaving documentation for a subsequent PR though, in the chance that these end up having a name change. I will make sure they are handled in the documentation PR.", "url": "https://github.com/elastic/elasticsearch/pull/61342#discussion_r477574235", "createdAt": "2020-08-26T20:37:11Z", "author": {"login": "dakrone"}, "path": "docs/reference/api-conventions.asciidoc", "diffHunk": "@@ -391,6 +391,7 @@ Returns:\n       \"index.creation_date\": \"1474389951325\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU0OTM4Nw=="}, "originalCommit": {"oid": "ed6c3dc8adf8d9f7e1f919abf047d400a27f6e48"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4NTU1NzYzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/cluster/node/DiscoveryNodeFilters.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxOTo1MjowNlrOHHbZjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQyMDoyNjo1MlrOHHcfYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU1MDk4OQ==", "bodyText": "outside the scope of this PR, but can you use _tier with the node specification  ?", "url": "https://github.com/elastic/elasticsearch/pull/61342#discussion_r477550989", "createdAt": "2020-08-26T19:52:06Z", "author": {"login": "jakelandis"}, "path": "server/src/main/java/org/elasticsearch/cluster/node/DiscoveryNodeFilters.java", "diffHunk": "@@ -181,6 +181,9 @@ public boolean match(DiscoveryNode node) {\n                         }\n                     }\n                 }\n+            } else if (\"_tier\".equals(attr)) {\n+                // Always allow _tier as an attribute, will be handled elsewhere", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed6c3dc8adf8d9f7e1f919abf047d400a27f6e48"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU2ODg2Nw==", "bodyText": "Yes you can, I added tests for that in #60994", "url": "https://github.com/elastic/elasticsearch/pull/61342#discussion_r477568867", "createdAt": "2020-08-26T20:26:52Z", "author": {"login": "dakrone"}, "path": "server/src/main/java/org/elasticsearch/cluster/node/DiscoveryNodeFilters.java", "diffHunk": "@@ -181,6 +181,9 @@ public boolean match(DiscoveryNode node) {\n                         }\n                     }\n                 }\n+            } else if (\"_tier\".equals(attr)) {\n+                // Always allow _tier as an attribute, will be handled elsewhere", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU1MDk4OQ=="}, "originalCommit": {"oid": "ed6c3dc8adf8d9f7e1f919abf047d400a27f6e48"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4NTU2MDA4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/shard/ExplicitIndexSettingProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxOTo1Mjo1MVrOHHba9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxOTo1Mjo1MVrOHHba9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU1MTM1MQ==", "bodyText": "nit: doesn't return a map", "url": "https://github.com/elastic/elasticsearch/pull/61342#discussion_r477551351", "createdAt": "2020-08-26T19:52:51Z", "author": {"login": "jakelandis"}, "path": "server/src/main/java/org/elasticsearch/index/shard/ExplicitIndexSettingProvider.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.shard;\n+\n+import org.elasticsearch.common.settings.Settings;\n+\n+/**\n+ * An {@link ExplicitIndexSettingProvider} is a provider for index level settings that can be set\n+ * explicitly as a default value (so they show up as \"set\" for newly created indices)\n+ */\n+public interface ExplicitIndexSettingProvider {\n+    /**\n+     * Returns a map of explicitly set default index settings for the given index.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed6c3dc8adf8d9f7e1f919abf047d400a27f6e48"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4NTU2NDMyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/DataTier.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxOTo1NDowOVrOHHbdlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxOTo1NDowOVrOHHbdlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU1MjAyMw==", "bodyText": "a debug message here might be helpful for future troubleshooting.", "url": "https://github.com/elastic/elasticsearch/pull/61342#discussion_r477552023", "createdAt": "2020-08-26T19:54:09Z", "author": {"login": "jakelandis"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/DataTier.java", "diffHunk": "@@ -137,4 +142,28 @@ public static boolean isColdNode(DiscoveryNode discoveryNode) {\n     public static boolean isFrozenNode(DiscoveryNode discoveryNode) {\n         return discoveryNode.getRoles().contains(DATA_FROZEN_NODE_ROLE) || discoveryNode.getRoles().contains(DiscoveryNodeRole.DATA_ROLE);\n     }\n+\n+    /**\n+     * This listener injects the setting allocating all newly created indices with\n+     * {@code index.routing.allocation.include._tier: \"data_hot\"} unless the user overrides the\n+     * setting while the index is being created (in a create index request for instance)\n+     */\n+    public static class DefaultHotAllocationSettingProvider implements ExplicitIndexSettingProvider {\n+        @Override\n+        public Settings getExplicitIndexSettings(String indexName, Settings indexSettings) {\n+            Set<String> settings = indexSettings.keySet();\n+            if (settings.contains(DataTierAllocationDecider.INDEX_ROUTING_INCLUDE)) {\n+                // It's okay to put it, it will be removed or overridden by the template/request settings\n+                return Settings.builder().put(DataTierAllocationDecider.INDEX_ROUTING_INCLUDE, DATA_HOT).build();\n+            } else if (settings.stream().anyMatch(s -> s.startsWith(IndexMetadata.INDEX_ROUTING_REQUIRE_GROUP_PREFIX + \".\")) ||\n+                settings.stream().anyMatch(s -> s.startsWith(IndexMetadata.INDEX_ROUTING_EXCLUDE_GROUP_PREFIX + \".\")) ||\n+                settings.stream().anyMatch(s -> s.startsWith(IndexMetadata.INDEX_ROUTING_INCLUDE_GROUP_PREFIX + \".\"))) {\n+                // A different index level require, include, or exclude has been specified, so don't put the setting", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed6c3dc8adf8d9f7e1f919abf047d400a27f6e48"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4NTU5MjExOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/cluster/routing/allocation/DataTierIT.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQyMDowMjowOFrOHHburQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQyMDozMzo1MFrOHHctQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU1NjM5Nw==", "bodyText": "maybe switch between \"data\" and \"data_hot\" randomly here ... IIUC they are synonymous in this context ?", "url": "https://github.com/elastic/elasticsearch/pull/61342#discussion_r477556397", "createdAt": "2020-08-26T20:02:08Z", "author": {"login": "jakelandis"}, "path": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/cluster/routing/allocation/DataTierIT.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.cluster.routing.allocation;\n+\n+import org.elasticsearch.action.admin.indices.shrink.ResizeType;\n+import org.elasticsearch.action.admin.indices.template.put.PutComposableIndexTemplateAction;\n+import org.elasticsearch.cluster.health.ClusterHealthStatus;\n+import org.elasticsearch.cluster.metadata.ComposableIndexTemplate;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.metadata.Template;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.test.ESIntegTestCase;\n+import org.elasticsearch.xpack.core.DataTier;\n+import org.elasticsearch.xpack.core.LocalStateCompositeXPackPlugin;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+\n+@ESIntegTestCase.ClusterScope(scope = ESIntegTestCase.Scope.TEST, numDataNodes = 0, numClientNodes = 0)\n+public class DataTierIT extends ESIntegTestCase {\n+    private static final String index = \"myindex\";\n+\n+    @Override\n+    protected Collection<Class<? extends Plugin>> nodePlugins() {\n+        return Collections.singleton(LocalStateCompositeXPackPlugin.class);\n+    }\n+\n+    public void testDefaultAllocateToHot() {\n+        startWarmNode();\n+        startColdNode();\n+        ensureGreen();\n+\n+        client().admin().indices().prepareCreate(index).setWaitForActiveShards(0).get();\n+\n+        Settings idxSettings = client().admin().indices().prepareGetIndex().addIndices(index).get().getSettings().get(index);\n+        assertThat(DataTierAllocationDecider.INDEX_ROUTING_INCLUDE_SETTING.get(idxSettings), equalTo(DataTier.DATA_HOT));\n+\n+        // index should be red\n+        assertThat(client().admin().cluster().prepareHealth(index).get().getIndices().get(index).getStatus(),\n+            equalTo(ClusterHealthStatus.RED));\n+\n+        logger.info(\"--> starting hot node\");\n+        startHotNode();\n+\n+        logger.info(\"--> waiting for {} to be yellow\", index);\n+        ensureYellow(index);\n+    }\n+\n+    public void testOverrideDefaultAllocation() {\n+        startWarmNode();\n+        startColdNode();\n+        ensureGreen();\n+\n+        String setting = randomBoolean() ? DataTierAllocationDecider.INDEX_ROUTING_REQUIRE :\n+            DataTierAllocationDecider.INDEX_ROUTING_INCLUDE;\n+\n+        client().admin().indices().prepareCreate(index)\n+            .setWaitForActiveShards(0)\n+            .setSettings(Settings.builder()\n+                .put(setting, DataTier.DATA_WARM))\n+            .get();\n+\n+        Settings idxSettings = client().admin().indices().prepareGetIndex().addIndices(index).get().getSettings().get(index);\n+        assertThat(idxSettings.get(setting), equalTo(DataTier.DATA_WARM));\n+\n+        // index should be yellow\n+        logger.info(\"--> waiting for {} to be yellow\", index);\n+        ensureYellow(index);\n+    }\n+\n+    public void testRequestSettingOverridesAllocation() {\n+        startWarmNode();\n+        startColdNode();\n+        ensureGreen();\n+\n+        client().admin().indices().prepareCreate(index)\n+            .setWaitForActiveShards(0)\n+            .setSettings(Settings.builder()\n+                .putNull(DataTierAllocationDecider.INDEX_ROUTING_INCLUDE))\n+            .get();\n+\n+        Settings idxSettings = client().admin().indices().prepareGetIndex().addIndices(index).get().getSettings().get(index);\n+        assertThat(DataTierAllocationDecider.INDEX_ROUTING_INCLUDE_SETTING.get(idxSettings), equalTo(\"\"));\n+        // Even the key shouldn't exist if it has been nulled out\n+        assertFalse(idxSettings.keySet().toString(), idxSettings.keySet().contains(DataTierAllocationDecider.INDEX_ROUTING_INCLUDE));\n+\n+        // index should be yellow\n+        logger.info(\"--> waiting for {} to be yellow\", index);\n+        ensureYellow(index);\n+\n+        client().admin().indices().prepareDelete(index).get();\n+\n+        // Now test it overriding the \"require\" setting, in which case the include should be skipped\n+        client().admin().indices().prepareCreate(index)\n+            .setWaitForActiveShards(0)\n+            .setSettings(Settings.builder()\n+                .put(DataTierAllocationDecider.INDEX_ROUTING_REQUIRE, DataTier.DATA_COLD))\n+            .get();\n+\n+        idxSettings = client().admin().indices().prepareGetIndex().addIndices(index).get().getSettings().get(index);\n+        assertThat(DataTierAllocationDecider.INDEX_ROUTING_INCLUDE_SETTING.get(idxSettings), equalTo(\"\"));\n+        // The key should not be put in place since it was overridden\n+        assertFalse(idxSettings.keySet().contains(DataTierAllocationDecider.INDEX_ROUTING_INCLUDE));\n+        assertThat(DataTierAllocationDecider.INDEX_ROUTING_REQUIRE_SETTING.get(idxSettings), equalTo(DataTier.DATA_COLD));\n+\n+        // index should be yellow\n+        logger.info(\"--> waiting for {} to be yellow\", index);\n+        ensureYellow(index);\n+    }\n+\n+    /**\n+     * When a new index is created from source metadata (as during a shrink), the data tier\n+     * default setting should *not* be applied. This test checks that behavior.\n+     */\n+    public void testShrinkStaysOnTier() {\n+        startWarmNode();\n+        startHotNode();\n+\n+        client().admin().indices().prepareCreate(index)\n+            .setWaitForActiveShards(0)\n+            .setSettings(Settings.builder()\n+                .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 2)\n+                .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)\n+                .put(DataTierAllocationDecider.INDEX_ROUTING_INCLUDE, \"data_warm\"))\n+            .get();\n+\n+        client().admin().indices().prepareAddBlock(IndexMetadata.APIBlock.READ_ONLY, index).get();\n+        client().admin().indices().prepareResizeIndex(index, index + \"-shrunk\")\n+            .setResizeType(ResizeType.SHRINK)\n+            .setSettings(Settings.builder()\n+                .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)\n+                .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)\n+                .build()).get();\n+\n+        ensureGreen(index + \"-shrunk\");\n+\n+        Settings idxSettings = client().admin().indices().prepareGetIndex().addIndices(index + \"-shrunk\")\n+            .get().getSettings().get(index + \"-shrunk\");\n+        // It should inherit the setting of its originator\n+        assertThat(DataTierAllocationDecider.INDEX_ROUTING_INCLUDE_SETTING.get(idxSettings), equalTo(DataTier.DATA_WARM));\n+\n+        // Required or else the test cleanup fails because it can't delete the indices\n+        client().admin().indices().prepareUpdateSettings(index, index + \"-shrunk\")\n+            .setSettings(Settings.builder()\n+                .put(\"index.blocks.read_only\", false))\n+            .get();\n+    }\n+\n+    public void testTemplateOverridesDefaults() {\n+        startWarmNode();\n+\n+        Template t = new Template(Settings.builder()\n+            .put(DataTierAllocationDecider.INDEX_ROUTING_REQUIRE, DataTier.DATA_WARM)\n+            .build(), null, null);\n+        ComposableIndexTemplate ct = new ComposableIndexTemplate(Collections.singletonList(index), t, null, null, null, null, null);\n+        client().execute(PutComposableIndexTemplateAction.INSTANCE,\n+            new PutComposableIndexTemplateAction.Request(\"template\").indexTemplate(ct)).actionGet();\n+\n+        client().admin().indices().prepareCreate(index).setWaitForActiveShards(0).get();\n+\n+        Settings idxSettings = client().admin().indices().prepareGetIndex().addIndices(index).get().getSettings().get(index);\n+        assertThat(idxSettings.keySet().contains(DataTierAllocationDecider.INDEX_ROUTING_INCLUDE), equalTo(false));\n+\n+        // index should be yellow\n+        ensureYellow(index);\n+\n+        client().admin().indices().prepareDelete(index).get();\n+\n+        t = new Template(Settings.builder()\n+            .putNull(DataTierAllocationDecider.INDEX_ROUTING_INCLUDE)\n+            .build(), null, null);\n+        ct = new ComposableIndexTemplate(Collections.singletonList(index), t, null, null, null, null, null);\n+        client().execute(PutComposableIndexTemplateAction.INSTANCE,\n+            new PutComposableIndexTemplateAction.Request(\"template\").indexTemplate(ct)).actionGet();\n+\n+        client().admin().indices().prepareCreate(index).setWaitForActiveShards(0).get();\n+\n+        idxSettings = client().admin().indices().prepareGetIndex().addIndices(index).get().getSettings().get(index);\n+        assertThat(idxSettings.keySet().contains(DataTierAllocationDecider.INDEX_ROUTING_INCLUDE), equalTo(false));\n+\n+        ensureYellow(index);\n+    }\n+\n+    public void startHotNode() {\n+        Settings nodeSettings = Settings.builder()\n+            .putList(\"node.roles\", Arrays.asList(\"master\", \"data_hot\", \"ingest\"))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed6c3dc8adf8d9f7e1f919abf047d400a27f6e48"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU3MjQxOA==", "bodyText": "They are synonymous in that they can both have hot data, but not for tests that may expect starting a hot node to mean there are no warm/cold/frozen nodes in the cluster. I'll rename these to startHotOnlyNode (for all the node types)", "url": "https://github.com/elastic/elasticsearch/pull/61342#discussion_r477572418", "createdAt": "2020-08-26T20:33:50Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/cluster/routing/allocation/DataTierIT.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.cluster.routing.allocation;\n+\n+import org.elasticsearch.action.admin.indices.shrink.ResizeType;\n+import org.elasticsearch.action.admin.indices.template.put.PutComposableIndexTemplateAction;\n+import org.elasticsearch.cluster.health.ClusterHealthStatus;\n+import org.elasticsearch.cluster.metadata.ComposableIndexTemplate;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.metadata.Template;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.test.ESIntegTestCase;\n+import org.elasticsearch.xpack.core.DataTier;\n+import org.elasticsearch.xpack.core.LocalStateCompositeXPackPlugin;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+\n+@ESIntegTestCase.ClusterScope(scope = ESIntegTestCase.Scope.TEST, numDataNodes = 0, numClientNodes = 0)\n+public class DataTierIT extends ESIntegTestCase {\n+    private static final String index = \"myindex\";\n+\n+    @Override\n+    protected Collection<Class<? extends Plugin>> nodePlugins() {\n+        return Collections.singleton(LocalStateCompositeXPackPlugin.class);\n+    }\n+\n+    public void testDefaultAllocateToHot() {\n+        startWarmNode();\n+        startColdNode();\n+        ensureGreen();\n+\n+        client().admin().indices().prepareCreate(index).setWaitForActiveShards(0).get();\n+\n+        Settings idxSettings = client().admin().indices().prepareGetIndex().addIndices(index).get().getSettings().get(index);\n+        assertThat(DataTierAllocationDecider.INDEX_ROUTING_INCLUDE_SETTING.get(idxSettings), equalTo(DataTier.DATA_HOT));\n+\n+        // index should be red\n+        assertThat(client().admin().cluster().prepareHealth(index).get().getIndices().get(index).getStatus(),\n+            equalTo(ClusterHealthStatus.RED));\n+\n+        logger.info(\"--> starting hot node\");\n+        startHotNode();\n+\n+        logger.info(\"--> waiting for {} to be yellow\", index);\n+        ensureYellow(index);\n+    }\n+\n+    public void testOverrideDefaultAllocation() {\n+        startWarmNode();\n+        startColdNode();\n+        ensureGreen();\n+\n+        String setting = randomBoolean() ? DataTierAllocationDecider.INDEX_ROUTING_REQUIRE :\n+            DataTierAllocationDecider.INDEX_ROUTING_INCLUDE;\n+\n+        client().admin().indices().prepareCreate(index)\n+            .setWaitForActiveShards(0)\n+            .setSettings(Settings.builder()\n+                .put(setting, DataTier.DATA_WARM))\n+            .get();\n+\n+        Settings idxSettings = client().admin().indices().prepareGetIndex().addIndices(index).get().getSettings().get(index);\n+        assertThat(idxSettings.get(setting), equalTo(DataTier.DATA_WARM));\n+\n+        // index should be yellow\n+        logger.info(\"--> waiting for {} to be yellow\", index);\n+        ensureYellow(index);\n+    }\n+\n+    public void testRequestSettingOverridesAllocation() {\n+        startWarmNode();\n+        startColdNode();\n+        ensureGreen();\n+\n+        client().admin().indices().prepareCreate(index)\n+            .setWaitForActiveShards(0)\n+            .setSettings(Settings.builder()\n+                .putNull(DataTierAllocationDecider.INDEX_ROUTING_INCLUDE))\n+            .get();\n+\n+        Settings idxSettings = client().admin().indices().prepareGetIndex().addIndices(index).get().getSettings().get(index);\n+        assertThat(DataTierAllocationDecider.INDEX_ROUTING_INCLUDE_SETTING.get(idxSettings), equalTo(\"\"));\n+        // Even the key shouldn't exist if it has been nulled out\n+        assertFalse(idxSettings.keySet().toString(), idxSettings.keySet().contains(DataTierAllocationDecider.INDEX_ROUTING_INCLUDE));\n+\n+        // index should be yellow\n+        logger.info(\"--> waiting for {} to be yellow\", index);\n+        ensureYellow(index);\n+\n+        client().admin().indices().prepareDelete(index).get();\n+\n+        // Now test it overriding the \"require\" setting, in which case the include should be skipped\n+        client().admin().indices().prepareCreate(index)\n+            .setWaitForActiveShards(0)\n+            .setSettings(Settings.builder()\n+                .put(DataTierAllocationDecider.INDEX_ROUTING_REQUIRE, DataTier.DATA_COLD))\n+            .get();\n+\n+        idxSettings = client().admin().indices().prepareGetIndex().addIndices(index).get().getSettings().get(index);\n+        assertThat(DataTierAllocationDecider.INDEX_ROUTING_INCLUDE_SETTING.get(idxSettings), equalTo(\"\"));\n+        // The key should not be put in place since it was overridden\n+        assertFalse(idxSettings.keySet().contains(DataTierAllocationDecider.INDEX_ROUTING_INCLUDE));\n+        assertThat(DataTierAllocationDecider.INDEX_ROUTING_REQUIRE_SETTING.get(idxSettings), equalTo(DataTier.DATA_COLD));\n+\n+        // index should be yellow\n+        logger.info(\"--> waiting for {} to be yellow\", index);\n+        ensureYellow(index);\n+    }\n+\n+    /**\n+     * When a new index is created from source metadata (as during a shrink), the data tier\n+     * default setting should *not* be applied. This test checks that behavior.\n+     */\n+    public void testShrinkStaysOnTier() {\n+        startWarmNode();\n+        startHotNode();\n+\n+        client().admin().indices().prepareCreate(index)\n+            .setWaitForActiveShards(0)\n+            .setSettings(Settings.builder()\n+                .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 2)\n+                .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)\n+                .put(DataTierAllocationDecider.INDEX_ROUTING_INCLUDE, \"data_warm\"))\n+            .get();\n+\n+        client().admin().indices().prepareAddBlock(IndexMetadata.APIBlock.READ_ONLY, index).get();\n+        client().admin().indices().prepareResizeIndex(index, index + \"-shrunk\")\n+            .setResizeType(ResizeType.SHRINK)\n+            .setSettings(Settings.builder()\n+                .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)\n+                .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)\n+                .build()).get();\n+\n+        ensureGreen(index + \"-shrunk\");\n+\n+        Settings idxSettings = client().admin().indices().prepareGetIndex().addIndices(index + \"-shrunk\")\n+            .get().getSettings().get(index + \"-shrunk\");\n+        // It should inherit the setting of its originator\n+        assertThat(DataTierAllocationDecider.INDEX_ROUTING_INCLUDE_SETTING.get(idxSettings), equalTo(DataTier.DATA_WARM));\n+\n+        // Required or else the test cleanup fails because it can't delete the indices\n+        client().admin().indices().prepareUpdateSettings(index, index + \"-shrunk\")\n+            .setSettings(Settings.builder()\n+                .put(\"index.blocks.read_only\", false))\n+            .get();\n+    }\n+\n+    public void testTemplateOverridesDefaults() {\n+        startWarmNode();\n+\n+        Template t = new Template(Settings.builder()\n+            .put(DataTierAllocationDecider.INDEX_ROUTING_REQUIRE, DataTier.DATA_WARM)\n+            .build(), null, null);\n+        ComposableIndexTemplate ct = new ComposableIndexTemplate(Collections.singletonList(index), t, null, null, null, null, null);\n+        client().execute(PutComposableIndexTemplateAction.INSTANCE,\n+            new PutComposableIndexTemplateAction.Request(\"template\").indexTemplate(ct)).actionGet();\n+\n+        client().admin().indices().prepareCreate(index).setWaitForActiveShards(0).get();\n+\n+        Settings idxSettings = client().admin().indices().prepareGetIndex().addIndices(index).get().getSettings().get(index);\n+        assertThat(idxSettings.keySet().contains(DataTierAllocationDecider.INDEX_ROUTING_INCLUDE), equalTo(false));\n+\n+        // index should be yellow\n+        ensureYellow(index);\n+\n+        client().admin().indices().prepareDelete(index).get();\n+\n+        t = new Template(Settings.builder()\n+            .putNull(DataTierAllocationDecider.INDEX_ROUTING_INCLUDE)\n+            .build(), null, null);\n+        ct = new ComposableIndexTemplate(Collections.singletonList(index), t, null, null, null, null, null);\n+        client().execute(PutComposableIndexTemplateAction.INSTANCE,\n+            new PutComposableIndexTemplateAction.Request(\"template\").indexTemplate(ct)).actionGet();\n+\n+        client().admin().indices().prepareCreate(index).setWaitForActiveShards(0).get();\n+\n+        idxSettings = client().admin().indices().prepareGetIndex().addIndices(index).get().getSettings().get(index);\n+        assertThat(idxSettings.keySet().contains(DataTierAllocationDecider.INDEX_ROUTING_INCLUDE), equalTo(false));\n+\n+        ensureYellow(index);\n+    }\n+\n+    public void startHotNode() {\n+        Settings nodeSettings = Settings.builder()\n+            .putList(\"node.roles\", Arrays.asList(\"master\", \"data_hot\", \"ingest\"))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU1NjM5Nw=="}, "originalCommit": {"oid": "ed6c3dc8adf8d9f7e1f919abf047d400a27f6e48"}, "originalPosition": 194}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4NTYwODUyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataCreateIndexService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQyMDowNzozMlrOHHb44Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQyMDowNzozMlrOHHb44Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU1OTAwOQ==", "bodyText": "mabye a debug message here to help with future troubleshooting ?", "url": "https://github.com/elastic/elasticsearch/pull/61342#discussion_r477559009", "createdAt": "2020-08-26T20:07:32Z", "author": {"login": "jakelandis"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataCreateIndexService.java", "diffHunk": "@@ -595,14 +611,65 @@ private ClusterState applyCreateIndexRequestWithExistingMetadata(final ClusterSt\n      * @return the aggregated settings for the new index\n      */\n     static Settings aggregateIndexSettings(ClusterState currentState, CreateIndexClusterStateUpdateRequest request,\n-                                           Settings templateSettings, @Nullable IndexMetadata sourceMetadata, Settings settings,\n-                                           IndexScopedSettings indexScopedSettings, ShardLimitValidator shardLimitValidator) {\n-        Settings.Builder indexSettingsBuilder = Settings.builder();\n+                                           Settings combinedTemplateSettings, @Nullable IndexMetadata sourceMetadata, Settings settings,\n+                                           IndexScopedSettings indexScopedSettings, ShardLimitValidator shardLimitValidator,\n+                                           Set<ExplicitIndexSettingProvider> explicitIndexSettingProviders) {\n+        // Create builders for the template and request settings. We transform these into builders\n+        // because we may want settings to be \"removed\" from these prior to being set on the new\n+        // index (see more comments below)\n+        final Settings.Builder templateSettings = Settings.builder().put(combinedTemplateSettings);\n+        final Settings.Builder requestSettings = Settings.builder().put(request.settings());\n+\n+        final Settings.Builder indexSettingsBuilder = Settings.builder();\n         if (sourceMetadata == null) {\n-            indexSettingsBuilder.put(templateSettings);\n+            final Settings.Builder explicitDefaultSettings = Settings.builder();\n+            final Settings templateAndRequestSettings = Settings.builder()\n+                .put(combinedTemplateSettings)\n+                .put(request.settings())\n+                .build();\n+\n+            // Loop through all the explicit index setting providers, adding them to the\n+            // explicitDefaultSettings map\n+            for (ExplicitIndexSettingProvider listener : explicitIndexSettingProviders) {\n+                try {\n+                    explicitDefaultSettings.put(listener.getExplicitIndexSettings(request.index(), templateAndRequestSettings));\n+                } catch (Exception e) {\n+                    logger.warn(new ParameterizedMessage(\"failed invoking explicit setting provider for creation of [{}] index\",\n+                        request.index()), e);\n+                }\n+            }\n+\n+            // For all the explicit settings, we go through the template and request level settings\n+            // and see if either a template or the request has \"cancelled out\" an explicit default\n+            // setting. For example, if a plugin had as an explicit setting:\n+            // \"index.mysetting\": \"blah\n+            // And either a template or create index request had:\n+            // \"index.mysetting\": null\n+            // We want to remove the explicit setting not only from the explicitly set settings, but\n+            // also from the template and request settings, so that from the newly create index's\n+            // perspective it is as though the setting has not been set at all (using the default\n+            // value).\n+            for (String explicitSetting : explicitDefaultSettings.keys()) {\n+                if (templateSettings.keys().contains(explicitSetting) && templateSettings.get(explicitSetting) == null) {\n+                    explicitDefaultSettings.remove(explicitSetting);\n+                    templateSettings.remove(explicitSetting);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed6c3dc8adf8d9f7e1f919abf047d400a27f6e48"}, "originalPosition": 120}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4NTYwOTAxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataCreateIndexService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQyMDowNzo0MFrOHHb5Lw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQyMDowNzo0MFrOHHb5Lw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU1OTA4Nw==", "bodyText": "mabye a debug message here to help with future troubleshooting ?", "url": "https://github.com/elastic/elasticsearch/pull/61342#discussion_r477559087", "createdAt": "2020-08-26T20:07:40Z", "author": {"login": "jakelandis"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataCreateIndexService.java", "diffHunk": "@@ -595,14 +611,65 @@ private ClusterState applyCreateIndexRequestWithExistingMetadata(final ClusterSt\n      * @return the aggregated settings for the new index\n      */\n     static Settings aggregateIndexSettings(ClusterState currentState, CreateIndexClusterStateUpdateRequest request,\n-                                           Settings templateSettings, @Nullable IndexMetadata sourceMetadata, Settings settings,\n-                                           IndexScopedSettings indexScopedSettings, ShardLimitValidator shardLimitValidator) {\n-        Settings.Builder indexSettingsBuilder = Settings.builder();\n+                                           Settings combinedTemplateSettings, @Nullable IndexMetadata sourceMetadata, Settings settings,\n+                                           IndexScopedSettings indexScopedSettings, ShardLimitValidator shardLimitValidator,\n+                                           Set<ExplicitIndexSettingProvider> explicitIndexSettingProviders) {\n+        // Create builders for the template and request settings. We transform these into builders\n+        // because we may want settings to be \"removed\" from these prior to being set on the new\n+        // index (see more comments below)\n+        final Settings.Builder templateSettings = Settings.builder().put(combinedTemplateSettings);\n+        final Settings.Builder requestSettings = Settings.builder().put(request.settings());\n+\n+        final Settings.Builder indexSettingsBuilder = Settings.builder();\n         if (sourceMetadata == null) {\n-            indexSettingsBuilder.put(templateSettings);\n+            final Settings.Builder explicitDefaultSettings = Settings.builder();\n+            final Settings templateAndRequestSettings = Settings.builder()\n+                .put(combinedTemplateSettings)\n+                .put(request.settings())\n+                .build();\n+\n+            // Loop through all the explicit index setting providers, adding them to the\n+            // explicitDefaultSettings map\n+            for (ExplicitIndexSettingProvider listener : explicitIndexSettingProviders) {\n+                try {\n+                    explicitDefaultSettings.put(listener.getExplicitIndexSettings(request.index(), templateAndRequestSettings));\n+                } catch (Exception e) {\n+                    logger.warn(new ParameterizedMessage(\"failed invoking explicit setting provider for creation of [{}] index\",\n+                        request.index()), e);\n+                }\n+            }\n+\n+            // For all the explicit settings, we go through the template and request level settings\n+            // and see if either a template or the request has \"cancelled out\" an explicit default\n+            // setting. For example, if a plugin had as an explicit setting:\n+            // \"index.mysetting\": \"blah\n+            // And either a template or create index request had:\n+            // \"index.mysetting\": null\n+            // We want to remove the explicit setting not only from the explicitly set settings, but\n+            // also from the template and request settings, so that from the newly create index's\n+            // perspective it is as though the setting has not been set at all (using the default\n+            // value).\n+            for (String explicitSetting : explicitDefaultSettings.keys()) {\n+                if (templateSettings.keys().contains(explicitSetting) && templateSettings.get(explicitSetting) == null) {\n+                    explicitDefaultSettings.remove(explicitSetting);\n+                    templateSettings.remove(explicitSetting);\n+                }\n+                if (requestSettings.keys().contains(explicitSetting) && requestSettings.get(explicitSetting) == null) {\n+                    explicitDefaultSettings.remove(explicitSetting);\n+                    requestSettings.remove(explicitSetting);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed6c3dc8adf8d9f7e1f919abf047d400a27f6e48"}, "originalPosition": 124}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4NTc4MzIwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/shard/ExplicitIndexSettingProvider.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQyMTowMDo0NlrOHHdjyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQyMzo1MDo0NlrOHHk0Xg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU4NjM3Ng==", "bodyText": "The naming here is a little confusing, because I thought this was about defaults, while \"explicit\" implies to me this is something else.", "url": "https://github.com/elastic/elasticsearch/pull/61342#discussion_r477586376", "createdAt": "2020-08-26T21:00:46Z", "author": {"login": "rjernst"}, "path": "server/src/main/java/org/elasticsearch/index/shard/ExplicitIndexSettingProvider.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.shard;\n+\n+import org.elasticsearch.common.settings.Settings;\n+\n+/**\n+ * An {@link ExplicitIndexSettingProvider} is a provider for index level settings that can be set\n+ * explicitly as a default value (so they show up as \"set\" for newly created indices)\n+ */\n+public interface ExplicitIndexSettingProvider {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a70b0c01d7b5f259e3699ab7a6af02f26b47a9a"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzY1MDI3NQ==", "bodyText": "It's short for \"ExplicitDefaultIndexSettingProvider\", and I should use the full name to be less confusing, I'll change this to use it.", "url": "https://github.com/elastic/elasticsearch/pull/61342#discussion_r477650275", "createdAt": "2020-08-26T23:08:50Z", "author": {"login": "dakrone"}, "path": "server/src/main/java/org/elasticsearch/index/shard/ExplicitIndexSettingProvider.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.shard;\n+\n+import org.elasticsearch.common.settings.Settings;\n+\n+/**\n+ * An {@link ExplicitIndexSettingProvider} is a provider for index level settings that can be set\n+ * explicitly as a default value (so they show up as \"set\" for newly created indices)\n+ */\n+public interface ExplicitIndexSettingProvider {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU4NjM3Ng=="}, "originalCommit": {"oid": "7a70b0c01d7b5f259e3699ab7a6af02f26b47a9a"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzcwNTMxMA==", "bodyText": "Maybe just IndexSettingsProvider? I'm still not understanding where the explicit comes in. I think the method could just be getAdditionalIndexSettings, similar to the getAdditionalSettings() we have on plugins for providing node settings.", "url": "https://github.com/elastic/elasticsearch/pull/61342#discussion_r477705310", "createdAt": "2020-08-26T23:50:46Z", "author": {"login": "rjernst"}, "path": "server/src/main/java/org/elasticsearch/index/shard/ExplicitIndexSettingProvider.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.shard;\n+\n+import org.elasticsearch.common.settings.Settings;\n+\n+/**\n+ * An {@link ExplicitIndexSettingProvider} is a provider for index level settings that can be set\n+ * explicitly as a default value (so they show up as \"set\" for newly created indices)\n+ */\n+public interface ExplicitIndexSettingProvider {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU4NjM3Ng=="}, "originalCommit": {"oid": "7a70b0c01d7b5f259e3699ab7a6af02f26b47a9a"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4NTc5NzY1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/shard/ExplicitIndexSettingProvider.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQyMTowNToxMFrOHHdslw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQyMzowNzozNlrOHHhYnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU4ODYzMQ==", "bodyText": "Can we do without the passed in settings? I had imagined the caller would do the merging/defaulting logic, so it's unclear why we would need the user passed in settings.", "url": "https://github.com/elastic/elasticsearch/pull/61342#discussion_r477588631", "createdAt": "2020-08-26T21:05:10Z", "author": {"login": "rjernst"}, "path": "server/src/main/java/org/elasticsearch/index/shard/ExplicitIndexSettingProvider.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.shard;\n+\n+import org.elasticsearch.common.settings.Settings;\n+\n+/**\n+ * An {@link ExplicitIndexSettingProvider} is a provider for index level settings that can be set\n+ * explicitly as a default value (so they show up as \"set\" for newly created indices)\n+ */\n+public interface ExplicitIndexSettingProvider {\n+    /**\n+     * Returns explicitly set default index {@link Settings} for the given index.\n+     */\n+    default Settings getExplicitIndexSettings(String indexName, Settings templateAndRequestSettings) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a70b0c01d7b5f259e3699ab7a6af02f26b47a9a"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzY0OTA1Mw==", "bodyText": "We need the settings to be able to not set mutually exclusive settings, for example, if a user created an index with:\nPOST /myindex\n{\n  \"settings\": {\n    \"index.routing.allocation.require._name\": \"mynode\"\n  }\n}\n\nWe need to not set index.routing.allocation.include._tier automatically, because otherwise we're constraining a new index to a tier when the user specifically wanted it constrained to single node (we check the all index level filtering settings). These settings are the only way we can make explicit default index settings reactive to other index level settings (such as adding an opt-out index level setting in the future)", "url": "https://github.com/elastic/elasticsearch/pull/61342#discussion_r477649053", "createdAt": "2020-08-26T23:07:36Z", "author": {"login": "dakrone"}, "path": "server/src/main/java/org/elasticsearch/index/shard/ExplicitIndexSettingProvider.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.shard;\n+\n+import org.elasticsearch.common.settings.Settings;\n+\n+/**\n+ * An {@link ExplicitIndexSettingProvider} is a provider for index level settings that can be set\n+ * explicitly as a default value (so they show up as \"set\" for newly created indices)\n+ */\n+public interface ExplicitIndexSettingProvider {\n+    /**\n+     * Returns explicitly set default index {@link Settings} for the given index.\n+     */\n+    default Settings getExplicitIndexSettings(String indexName, Settings templateAndRequestSettings) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU4ODYzMQ=="}, "originalCommit": {"oid": "7a70b0c01d7b5f259e3699ab7a6af02f26b47a9a"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4NTgwNDA5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/plugins/IndexSettingsProviderPlugin.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQyMTowNzoxMlrOHHdwpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQyMTowNzoxMlrOHHdwpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU4OTY2OQ==", "bodyText": "I would put the method on Plugin, where we have the rest of the settings logic. We may want to split that out to eg a SettingsPlugin at some point, but it would be nice to have those related extension points near each other for now.", "url": "https://github.com/elastic/elasticsearch/pull/61342#discussion_r477589669", "createdAt": "2020-08-26T21:07:12Z", "author": {"login": "rjernst"}, "path": "server/src/main/java/org/elasticsearch/plugins/IndexSettingsProviderPlugin.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.plugins;\n+\n+import org.elasticsearch.index.shard.ExplicitIndexSettingProvider;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+\n+/**\n+ * An {@link IndexSettingsProviderPlugin} is a plugin that allows hooking in to parts of an index\n+ * lifecycle to provide explicit default settings for newly created indices. Rather than changing\n+ * the default values for an index-level setting, these act as though the setting has been set\n+ * explicitly, but still allow the setting to be overridden by a template or creation request body.\n+ */\n+public interface IndexSettingsProviderPlugin {\n+    default Collection<ExplicitIndexSettingProvider> getExplicitSettingProviders() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a70b0c01d7b5f259e3699ab7a6af02f26b47a9a"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4NzE5MTA3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/shard/ExplicitIndexSettingProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwMDo1NTo0OVrOHHsAXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwMDo1NTo0OVrOHHsAXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzgyMzA3MA==", "bodyText": "minor: might want to instruct consumers that this method should not return null, nor throw exceptions, and if the conditions dictate that are no settings to apply for this index then return Settings.EMPTY.", "url": "https://github.com/elastic/elasticsearch/pull/61342#discussion_r477823070", "createdAt": "2020-08-27T00:55:49Z", "author": {"login": "jakelandis"}, "path": "server/src/main/java/org/elasticsearch/index/shard/ExplicitIndexSettingProvider.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.shard;\n+\n+import org.elasticsearch.common.settings.Settings;\n+\n+/**\n+ * An {@link ExplicitIndexSettingProvider} is a provider for index level settings that can be set\n+ * explicitly as a default value (so they show up as \"set\" for newly created indices)\n+ */\n+public interface ExplicitIndexSettingProvider {\n+    /**\n+     * Returns explicitly set default index {@link Settings} for the given index.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a70b0c01d7b5f259e3699ab7a6af02f26b47a9a"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MTg3NjM5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/plugins/Plugin.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNzo1MzoyOVrOHIbJZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNzo1MzoyOVrOHIbJZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODU5NTQzMA==", "bodyText": "nit: AdditionalSetting -> AdditionalIndexSetting?", "url": "https://github.com/elastic/elasticsearch/pull/61342#discussion_r478595430", "createdAt": "2020-08-27T17:53:29Z", "author": {"login": "rjernst"}, "path": "server/src/main/java/org/elasticsearch/plugins/Plugin.java", "diffHunk": "@@ -197,4 +198,14 @@ public void onIndexModule(IndexModule indexModule) {}\n     public void close() throws IOException {\n \n     }\n+\n+    /**\n+     * An {@link IndexSettingProvider} allows hooking in to parts of an index\n+     * lifecycle to provide explicit default settings for newly created indices. Rather than changing\n+     * the default values for an index-level setting, these act as though the setting has been set\n+     * explicitly, but still allow the setting to be overridden by a template or creation request body.\n+     */\n+    public Collection<IndexSettingProvider> getAdditionalSettingProviders() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e95e9220a1916034e0f0eab2d3a01f73d3652989"}, "originalPosition": 19}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 858, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}