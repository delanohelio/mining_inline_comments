{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgxNTA5Njk1", "number": 52965, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNzo0Mjo0MlrODlI-Rw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxODoyNjoyM1rODlJ2zA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMjcwOTE5OnYy", "diffSide": "RIGHT", "path": "docs/reference/aggregations/metrics/top-metrics-aggregation.asciidoc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNzo0Mjo0MlrOFx3H7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxODo0MTo1MFrOFx5EHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgyNzY5NA==", "bodyText": "Would be nice to have at least one example of what the output looks like for multiple metrics.  From the other examples, it looks like the metrics return value will always be a map keyed by the field names we're selecting, but I didn't see a place where we actually say that, and it's not 100% clear to me what we get back for multiple metrics.", "url": "https://github.com/elastic/elasticsearch/pull/52965#discussion_r387827694", "createdAt": "2020-03-04T17:42:42Z", "author": {"login": "not-napoleon"}, "path": "docs/reference/aggregations/metrics/top-metrics-aggregation.asciidoc", "diffHunk": "@@ -68,11 +68,40 @@ request. So,\n NOTE: This aggregation doesn't support any sort of \"tie breaking\". If two documents have\n the same sort values then this aggregation could return either document's fields.\n \n-==== `metric`\n+==== `metrics`\n \n-At this point `metric` supports only `{\"field\": \"field_name\"}` and all metrics\n-are returned as double precision floating point numbers. Expect more to\n-come here.\n+`metrics` selects the fields to of the \"top\" document to return. Like most other\n+aggregations, `top_metrics` casts these values cast to `double` precision\n+floating point numbers. So they have to be numeric. Dates *work*, but they\n+come back as a `double` precision floating point containing milliseconds since\n+epoch. `keyword` fields aren't allowed.\n+\n+You can return multiple metrics by providing a list:\n+\n+[source,console,id=search-aggregations-metrics-top-metrics-list-of-metrics]\n+----\n+POST /test/_bulk?refresh\n+{\"index\": {}}\n+{\"s\": 1, \"v\": 3.1415, \"m\": 1.9}\n+{\"index\": {}}\n+{\"s\": 2, \"v\": 1.0, \"m\": 6.7}\n+{\"index\": {}}\n+{\"s\": 3, \"v\": 2.71828, \"m\": -12.2}\n+POST /test/_search?filter_path=aggregations\n+{\n+  \"aggs\": {\n+    \"tm\": {\n+      \"top_metrics\": {\n+        \"metrics\": [\n+          {\"field\": \"v\"},\n+          {\"field\": \"m\"}\n+        ],\n+        \"sort\": {\"s\": \"desc\"}\n+      }\n+    }\n+  }\n+}\n+----", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce163a69f1475961e28e5f21fcbda876a70fc5ea"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg1OTQ4Ng==", "bodyText": "Sure!", "url": "https://github.com/elastic/elasticsearch/pull/52965#discussion_r387859486", "createdAt": "2020-03-04T18:41:50Z", "author": {"login": "nik9000"}, "path": "docs/reference/aggregations/metrics/top-metrics-aggregation.asciidoc", "diffHunk": "@@ -68,11 +68,40 @@ request. So,\n NOTE: This aggregation doesn't support any sort of \"tie breaking\". If two documents have\n the same sort values then this aggregation could return either document's fields.\n \n-==== `metric`\n+==== `metrics`\n \n-At this point `metric` supports only `{\"field\": \"field_name\"}` and all metrics\n-are returned as double precision floating point numbers. Expect more to\n-come here.\n+`metrics` selects the fields to of the \"top\" document to return. Like most other\n+aggregations, `top_metrics` casts these values cast to `double` precision\n+floating point numbers. So they have to be numeric. Dates *work*, but they\n+come back as a `double` precision floating point containing milliseconds since\n+epoch. `keyword` fields aren't allowed.\n+\n+You can return multiple metrics by providing a list:\n+\n+[source,console,id=search-aggregations-metrics-top-metrics-list-of-metrics]\n+----\n+POST /test/_bulk?refresh\n+{\"index\": {}}\n+{\"s\": 1, \"v\": 3.1415, \"m\": 1.9}\n+{\"index\": {}}\n+{\"s\": 2, \"v\": 1.0, \"m\": 6.7}\n+{\"index\": {}}\n+{\"s\": 3, \"v\": 2.71828, \"m\": -12.2}\n+POST /test/_search?filter_path=aggregations\n+{\n+  \"aggs\": {\n+    \"tm\": {\n+      \"top_metrics\": {\n+        \"metrics\": [\n+          {\"field\": \"v\"},\n+          {\"field\": \"m\"}\n+        ],\n+        \"sort\": {\"s\": \"desc\"}\n+      }\n+    }\n+  }\n+}\n+----", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgyNzY5NA=="}, "originalCommit": {"oid": "ce163a69f1475961e28e5f21fcbda876a70fc5ea"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMjcyNDg2OnYy", "diffSide": "RIGHT", "path": "docs/reference/aggregations/metrics/top-metrics-aggregation.asciidoc", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNzo0NzoyMVrOFx3SDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxOToyNDowOVrOFx6drg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgzMDI4Ng==", "bodyText": "so, to be clear, the metrics parameter can be either an object or an array of objects?  Is an array with a single value the same as just passing one object?  I'm a little uncomfortable about dual natured json fields.  Is there any reason to not always make metrics an array?", "url": "https://github.com/elastic/elasticsearch/pull/52965#discussion_r387830286", "createdAt": "2020-03-04T17:47:21Z", "author": {"login": "not-napoleon"}, "path": "docs/reference/aggregations/metrics/top-metrics-aggregation.asciidoc", "diffHunk": "@@ -92,7 +121,7 @@ POST /test/_search?filter_path=aggregations\n   \"aggs\": {\n     \"tm\": {\n       \"top_metrics\": {\n-        \"metric\": {\"field\": \"v\"},\n+        \"metrics\": {\"field\": \"v\"},", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce163a69f1475961e28e5f21fcbda876a70fc5ea"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg2MDAxMA==", "bodyText": "Pretty much every array valued field in Elasticsearch's API allows either. It'd be a ton of work to remove that.", "url": "https://github.com/elastic/elasticsearch/pull/52965#discussion_r387860010", "createdAt": "2020-03-04T18:42:51Z", "author": {"login": "nik9000"}, "path": "docs/reference/aggregations/metrics/top-metrics-aggregation.asciidoc", "diffHunk": "@@ -92,7 +121,7 @@ POST /test/_search?filter_path=aggregations\n   \"aggs\": {\n     \"tm\": {\n       \"top_metrics\": {\n-        \"metric\": {\"field\": \"v\"},\n+        \"metrics\": {\"field\": \"v\"},", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgzMDI4Ng=="}, "originalCommit": {"oid": "ce163a69f1475961e28e5f21fcbda876a70fc5ea"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg4MjQxNA==", "bodyText": "\ud83d\ude22 well, I guess that is what it is then.", "url": "https://github.com/elastic/elasticsearch/pull/52965#discussion_r387882414", "createdAt": "2020-03-04T19:24:09Z", "author": {"login": "not-napoleon"}, "path": "docs/reference/aggregations/metrics/top-metrics-aggregation.asciidoc", "diffHunk": "@@ -92,7 +121,7 @@ POST /test/_search?filter_path=aggregations\n   \"aggs\": {\n     \"tm\": {\n       \"top_metrics\": {\n-        \"metric\": {\"field\": \"v\"},\n+        \"metrics\": {\"field\": \"v\"},", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgzMDI4Ng=="}, "originalCommit": {"oid": "ce163a69f1475961e28e5f21fcbda876a70fc5ea"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMjc0MzAwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/analytics/src/main/java/org/elasticsearch/xpack/analytics/topmetrics/InternalTopMetrics.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNzo1Mjo1MFrOFx3dYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxODo0MzowMVrOFx5GcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgzMzE4NQ==", "bodyText": "Just checking, again, that there are still no released versions of the serialization format, and thus changing it here is safe?", "url": "https://github.com/elastic/elasticsearch/pull/52965#discussion_r387833185", "createdAt": "2020-03-04T17:52:50Z", "author": {"login": "not-napoleon"}, "path": "x-pack/plugin/analytics/src/main/java/org/elasticsearch/xpack/analytics/topmetrics/InternalTopMetrics.java", "diffHunk": "@@ -55,15 +59,15 @@ static InternalTopMetrics buildEmptyAggregation(String name, String metricField,\n     public InternalTopMetrics(StreamInput in) throws IOException {\n         super(in);\n         sortOrder = SortOrder.readFromStream(in);\n-        metricName = in.readString();\n+        metricNames = in.readStringList();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce163a69f1475961e28e5f21fcbda876a70fc5ea"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg2MDA4MQ==", "bodyText": "Still safe!", "url": "https://github.com/elastic/elasticsearch/pull/52965#discussion_r387860081", "createdAt": "2020-03-04T18:43:01Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/analytics/src/main/java/org/elasticsearch/xpack/analytics/topmetrics/InternalTopMetrics.java", "diffHunk": "@@ -55,15 +59,15 @@ static InternalTopMetrics buildEmptyAggregation(String name, String metricField,\n     public InternalTopMetrics(StreamInput in) throws IOException {\n         super(in);\n         sortOrder = SortOrder.readFromStream(in);\n-        metricName = in.readString();\n+        metricNames = in.readStringList();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgzMzE4NQ=="}, "originalCommit": {"oid": "ce163a69f1475961e28e5f21fcbda876a70fc5ea"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMjc2MjgyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/analytics/src/main/java/org/elasticsearch/xpack/analytics/topmetrics/InternalTopMetrics.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNzo1ODozNVrOFx3p3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxODo0NDowNFrOFx5IxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgzNjM4MQ==", "bodyText": "I don't understand what this error message means.   Should it read \"Unknown metric...\"?", "url": "https://github.com/elastic/elasticsearch/pull/52965#discussion_r387836381", "createdAt": "2020-03-04T17:58:35Z", "author": {"login": "not-napoleon"}, "path": "x-pack/plugin/analytics/src/main/java/org/elasticsearch/xpack/analytics/topmetrics/InternalTopMetrics.java", "diffHunk": "@@ -128,37 +136,38 @@ public boolean isMapped() {\n     public XContentBuilder doXContentBody(XContentBuilder builder, Params params) throws IOException {\n         builder.startArray(\"top\");\n         for (TopMetric top : topMetrics) {\n-            top.toXContent(builder, metricName);\n+            top.toXContent(builder, metricNames);\n         }\n         builder.endArray();\n         return builder;\n     }\n \n     @Override\n     public int hashCode() {\n-        return Objects.hash(super.hashCode(), sortOrder, metricName, size, topMetrics);\n+        return Objects.hash(super.hashCode(), sortOrder, metricNames, size, topMetrics);\n     }\n \n     @Override\n     public boolean equals(Object obj) {\n         if (super.equals(obj) == false) return false;\n         InternalTopMetrics other = (InternalTopMetrics) obj;\n         return sortOrder.equals(other.sortOrder) &&\n-            metricName.equals(other.metricName) &&\n+            metricNames.equals(other.metricNames) &&\n             size == other.size &&\n             topMetrics.equals(other.topMetrics);\n     }\n \n     @Override\n     public double value(String name) {\n-        if (metricName.equals(name)) {\n-            if (topMetrics.isEmpty()) {\n-                return Double.NaN;\n-            }\n-            assert topMetrics.size() == 1 : \"property paths should only resolve against top metrics with size == 1.\";\n-            return topMetrics.get(0).metricValue;\n+        int index = metricNames.indexOf(name);\n+        if (index < 0) {\n+            throw new IllegalArgumentException(\"known metric [\" + name + \"]\");            ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce163a69f1475961e28e5f21fcbda876a70fc5ea"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg2MDY3Ng==", "bodyText": "+1 - it should be unknown metric. I don't believe we'll ever throw it because of the interplay with hasValue. Which bothers me, but is a problem for another PR.", "url": "https://github.com/elastic/elasticsearch/pull/52965#discussion_r387860676", "createdAt": "2020-03-04T18:44:04Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/analytics/src/main/java/org/elasticsearch/xpack/analytics/topmetrics/InternalTopMetrics.java", "diffHunk": "@@ -128,37 +136,38 @@ public boolean isMapped() {\n     public XContentBuilder doXContentBody(XContentBuilder builder, Params params) throws IOException {\n         builder.startArray(\"top\");\n         for (TopMetric top : topMetrics) {\n-            top.toXContent(builder, metricName);\n+            top.toXContent(builder, metricNames);\n         }\n         builder.endArray();\n         return builder;\n     }\n \n     @Override\n     public int hashCode() {\n-        return Objects.hash(super.hashCode(), sortOrder, metricName, size, topMetrics);\n+        return Objects.hash(super.hashCode(), sortOrder, metricNames, size, topMetrics);\n     }\n \n     @Override\n     public boolean equals(Object obj) {\n         if (super.equals(obj) == false) return false;\n         InternalTopMetrics other = (InternalTopMetrics) obj;\n         return sortOrder.equals(other.sortOrder) &&\n-            metricName.equals(other.metricName) &&\n+            metricNames.equals(other.metricNames) &&\n             size == other.size &&\n             topMetrics.equals(other.topMetrics);\n     }\n \n     @Override\n     public double value(String name) {\n-        if (metricName.equals(name)) {\n-            if (topMetrics.isEmpty()) {\n-                return Double.NaN;\n-            }\n-            assert topMetrics.size() == 1 : \"property paths should only resolve against top metrics with size == 1.\";\n-            return topMetrics.get(0).metricValue;\n+        int index = metricNames.indexOf(name);\n+        if (index < 0) {\n+            throw new IllegalArgumentException(\"known metric [\" + name + \"]\");            ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgzNjM4MQ=="}, "originalCommit": {"oid": "ce163a69f1475961e28e5f21fcbda876a70fc5ea"}, "originalPosition": 136}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMjc4Mzc1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/analytics/src/main/java/org/elasticsearch/xpack/analytics/topmetrics/TopMetricsAggregationBuilder.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxODowNToxMVrOFx33QQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxOToyNjozOFrOFx6i7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgzOTgwOQ==", "bodyText": "Can you expand on this a bit, and/or open a ticket for it? Feel free to ignore this comment if you're planing to resolve this TODO soon, but I'm worried that if we find this again in a few months we won't remember what it is we intended to do here.\nAlso, it looks like later on, we just turn this into a list of ValuesSourceConfig.  Why not just start with ValuesSourceConfig at this point?", "url": "https://github.com/elastic/elasticsearch/pull/52965#discussion_r387839809", "createdAt": "2020-03-04T18:05:11Z", "author": {"login": "not-napoleon"}, "path": "x-pack/plugin/analytics/src/main/java/org/elasticsearch/xpack/analytics/topmetrics/TopMetricsAggregationBuilder.java", "diffHunk": "@@ -47,34 +47,35 @@\n                 if (size < 1) {\n                     throw new IllegalArgumentException(\"[size] must be more than 0 but was [\" + size + \"]\");\n                 }\n-                MultiValuesSourceFieldConfig metricField = (MultiValuesSourceFieldConfig) args[2];\n-                return new TopMetricsAggregationBuilder(name, sorts, size, metricField);\n+                @SuppressWarnings(\"unchecked\")\n+                List<MultiValuesSourceFieldConfig> metricFields = (List<MultiValuesSourceFieldConfig>) args[2];\n+                return new TopMetricsAggregationBuilder(name, sorts, size, metricFields);\n             });\n     static {\n         PARSER.declareField(constructorArg(), (p, n) -> SortBuilder.fromXContent(p), SORT_FIELD,\n                 ObjectParser.ValueType.OBJECT_ARRAY_OR_STRING);\n         PARSER.declareInt(optionalConstructorArg(), SIZE_FIELD);\n         ContextParser<Void, MultiValuesSourceFieldConfig.Builder> metricParser = MultiValuesSourceFieldConfig.PARSER.apply(true, false);\n-        PARSER.declareObject(constructorArg(), (p, n) -> metricParser.parse(p, null).build(), METRIC_FIELD);\n+        PARSER.declareObjectArray(constructorArg(), (p, n) -> metricParser.parse(p, null).build(), METRIC_FIELD);\n     }\n \n     private final List<SortBuilder<?>> sortBuilders;\n-    // TODO MultiValuesSourceFieldConfig has more things than we support and less things than we want to support\n     private final int size;\n-    private final MultiValuesSourceFieldConfig metricField;\n+    private final List<MultiValuesSourceFieldConfig> metricFields;\n+    // TODO MultiValuesSourceFieldConfig has more things than we support and less things than we want to support", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce163a69f1475961e28e5f21fcbda876a70fc5ea"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg2MTE5MA==", "bodyText": "I inherited this from @polyfractal's original implementation. I can look into changing to directly to ValuesSourceConfig.", "url": "https://github.com/elastic/elasticsearch/pull/52965#discussion_r387861190", "createdAt": "2020-03-04T18:45:00Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/analytics/src/main/java/org/elasticsearch/xpack/analytics/topmetrics/TopMetricsAggregationBuilder.java", "diffHunk": "@@ -47,34 +47,35 @@\n                 if (size < 1) {\n                     throw new IllegalArgumentException(\"[size] must be more than 0 but was [\" + size + \"]\");\n                 }\n-                MultiValuesSourceFieldConfig metricField = (MultiValuesSourceFieldConfig) args[2];\n-                return new TopMetricsAggregationBuilder(name, sorts, size, metricField);\n+                @SuppressWarnings(\"unchecked\")\n+                List<MultiValuesSourceFieldConfig> metricFields = (List<MultiValuesSourceFieldConfig>) args[2];\n+                return new TopMetricsAggregationBuilder(name, sorts, size, metricFields);\n             });\n     static {\n         PARSER.declareField(constructorArg(), (p, n) -> SortBuilder.fromXContent(p), SORT_FIELD,\n                 ObjectParser.ValueType.OBJECT_ARRAY_OR_STRING);\n         PARSER.declareInt(optionalConstructorArg(), SIZE_FIELD);\n         ContextParser<Void, MultiValuesSourceFieldConfig.Builder> metricParser = MultiValuesSourceFieldConfig.PARSER.apply(true, false);\n-        PARSER.declareObject(constructorArg(), (p, n) -> metricParser.parse(p, null).build(), METRIC_FIELD);\n+        PARSER.declareObjectArray(constructorArg(), (p, n) -> metricParser.parse(p, null).build(), METRIC_FIELD);\n     }\n \n     private final List<SortBuilder<?>> sortBuilders;\n-    // TODO MultiValuesSourceFieldConfig has more things than we support and less things than we want to support\n     private final int size;\n-    private final MultiValuesSourceFieldConfig metricField;\n+    private final List<MultiValuesSourceFieldConfig> metricFields;\n+    // TODO MultiValuesSourceFieldConfig has more things than we support and less things than we want to support", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgzOTgwOQ=="}, "originalCommit": {"oid": "ce163a69f1475961e28e5f21fcbda876a70fc5ea"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg4MzM5Mw==", "bodyText": "ha, that's exactly the kind of problem I want to prevent ;)\nWe could leave this as a TODO for now, since we're hoping to merge the new Values Source work soon-ish, and that dramatically reduces the complexity of ValuesSourceConfig, making it more like an actual config object and less like a magic box.", "url": "https://github.com/elastic/elasticsearch/pull/52965#discussion_r387883393", "createdAt": "2020-03-04T19:25:57Z", "author": {"login": "not-napoleon"}, "path": "x-pack/plugin/analytics/src/main/java/org/elasticsearch/xpack/analytics/topmetrics/TopMetricsAggregationBuilder.java", "diffHunk": "@@ -47,34 +47,35 @@\n                 if (size < 1) {\n                     throw new IllegalArgumentException(\"[size] must be more than 0 but was [\" + size + \"]\");\n                 }\n-                MultiValuesSourceFieldConfig metricField = (MultiValuesSourceFieldConfig) args[2];\n-                return new TopMetricsAggregationBuilder(name, sorts, size, metricField);\n+                @SuppressWarnings(\"unchecked\")\n+                List<MultiValuesSourceFieldConfig> metricFields = (List<MultiValuesSourceFieldConfig>) args[2];\n+                return new TopMetricsAggregationBuilder(name, sorts, size, metricFields);\n             });\n     static {\n         PARSER.declareField(constructorArg(), (p, n) -> SortBuilder.fromXContent(p), SORT_FIELD,\n                 ObjectParser.ValueType.OBJECT_ARRAY_OR_STRING);\n         PARSER.declareInt(optionalConstructorArg(), SIZE_FIELD);\n         ContextParser<Void, MultiValuesSourceFieldConfig.Builder> metricParser = MultiValuesSourceFieldConfig.PARSER.apply(true, false);\n-        PARSER.declareObject(constructorArg(), (p, n) -> metricParser.parse(p, null).build(), METRIC_FIELD);\n+        PARSER.declareObjectArray(constructorArg(), (p, n) -> metricParser.parse(p, null).build(), METRIC_FIELD);\n     }\n \n     private final List<SortBuilder<?>> sortBuilders;\n-    // TODO MultiValuesSourceFieldConfig has more things than we support and less things than we want to support\n     private final int size;\n-    private final MultiValuesSourceFieldConfig metricField;\n+    private final List<MultiValuesSourceFieldConfig> metricFields;\n+    // TODO MultiValuesSourceFieldConfig has more things than we support and less things than we want to support", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgzOTgwOQ=="}, "originalCommit": {"oid": "ce163a69f1475961e28e5f21fcbda876a70fc5ea"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg4Mzc1Ng==", "bodyText": "(but if we do leave it as a todo, we should still clarify what we want to do and when)", "url": "https://github.com/elastic/elasticsearch/pull/52965#discussion_r387883756", "createdAt": "2020-03-04T19:26:38Z", "author": {"login": "not-napoleon"}, "path": "x-pack/plugin/analytics/src/main/java/org/elasticsearch/xpack/analytics/topmetrics/TopMetricsAggregationBuilder.java", "diffHunk": "@@ -47,34 +47,35 @@\n                 if (size < 1) {\n                     throw new IllegalArgumentException(\"[size] must be more than 0 but was [\" + size + \"]\");\n                 }\n-                MultiValuesSourceFieldConfig metricField = (MultiValuesSourceFieldConfig) args[2];\n-                return new TopMetricsAggregationBuilder(name, sorts, size, metricField);\n+                @SuppressWarnings(\"unchecked\")\n+                List<MultiValuesSourceFieldConfig> metricFields = (List<MultiValuesSourceFieldConfig>) args[2];\n+                return new TopMetricsAggregationBuilder(name, sorts, size, metricFields);\n             });\n     static {\n         PARSER.declareField(constructorArg(), (p, n) -> SortBuilder.fromXContent(p), SORT_FIELD,\n                 ObjectParser.ValueType.OBJECT_ARRAY_OR_STRING);\n         PARSER.declareInt(optionalConstructorArg(), SIZE_FIELD);\n         ContextParser<Void, MultiValuesSourceFieldConfig.Builder> metricParser = MultiValuesSourceFieldConfig.PARSER.apply(true, false);\n-        PARSER.declareObject(constructorArg(), (p, n) -> metricParser.parse(p, null).build(), METRIC_FIELD);\n+        PARSER.declareObjectArray(constructorArg(), (p, n) -> metricParser.parse(p, null).build(), METRIC_FIELD);\n     }\n \n     private final List<SortBuilder<?>> sortBuilders;\n-    // TODO MultiValuesSourceFieldConfig has more things than we support and less things than we want to support\n     private final int size;\n-    private final MultiValuesSourceFieldConfig metricField;\n+    private final List<MultiValuesSourceFieldConfig> metricFields;\n+    // TODO MultiValuesSourceFieldConfig has more things than we support and less things than we want to support", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgzOTgwOQ=="}, "originalCommit": {"oid": "ce163a69f1475961e28e5f21fcbda876a70fc5ea"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMjgxNDg0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/analytics/src/main/java/org/elasticsearch/xpack/analytics/topmetrics/TopMetricsAggregator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxODoxNDo0M1rOFx4LOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxODo0NjowOFrOFx5NZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg0NDkyMQ==", "bodyText": "Does ValuesSourceConfig#resolve actually return null in some cases? I didn't see a path that would cause that.  Or is this just being defensive?", "url": "https://github.com/elastic/elasticsearch/pull/52965#discussion_r387844921", "createdAt": "2020-03-04T18:14:43Z", "author": {"login": "not-napoleon"}, "path": "x-pack/plugin/analytics/src/main/java/org/elasticsearch/xpack/analytics/topmetrics/TopMetricsAggregator.java", "diffHunk": "@@ -117,41 +117,122 @@ public void setScorer(Scorable s) throws IOException {\n \n     @Override\n     public InternalAggregation buildAggregation(long bucket) throws IOException {\n-        if (metricValueSource == null) {\n-            return buildEmptyAggregation();\n-        }\n-        List<InternalTopMetrics.TopMetric> topMetrics = sort.getValues(bucket, values.resultBuilder(sort.getFormat()));\n+        List<InternalTopMetrics.TopMetric> topMetrics = sort.getValues(bucket, metrics.resultBuilder(sort.getFormat()));\n         assert topMetrics.size() <= size;\n-        return new InternalTopMetrics(name, sort.getOrder(), metricName, size, topMetrics, pipelineAggregators(), metaData());\n+        return new InternalTopMetrics(name, sort.getOrder(), metrics.names, size, topMetrics, pipelineAggregators(), metaData());\n     }\n \n     @Override\n     public InternalTopMetrics buildEmptyAggregation() {\n-        // The sort format and sort order aren't used in reduction so we pass the simplest thing.\n-        return InternalTopMetrics.buildEmptyAggregation(name, metricName, pipelineAggregators(),\n-                metaData());\n+        return InternalTopMetrics.buildEmptyAggregation(name, metrics.names, pipelineAggregators(), metaData());\n     }\n \n     @Override\n     public void doClose() {\n-        Releasables.close(sort, values);\n+        Releasables.close(sort, metrics);\n+    }\n+\n+    private static class Metrics implements BucketedSort.ExtraData, Releasable {\n+        private final List<String> names;\n+        private final MetricValues[] values;\n+\n+        Metrics(int size, QueryShardContext ctx, List<MultiValuesSourceFieldConfig> fieldsConfig) {\n+            names = fieldsConfig.stream().map(MultiValuesSourceFieldConfig::getFieldName).collect(toList());\n+            values = new MetricValues[fieldsConfig.size()];\n+            int i = 0;\n+            for (MultiValuesSourceFieldConfig config : fieldsConfig) {\n+                ValuesSourceConfig<ValuesSource.Numeric> resolved = ValuesSourceConfig.resolve(ctx, ValueType.NUMERIC,\n+                        config.getFieldName(), config.getScript(), config.getMissing(), config.getTimeZone(), null);\n+                if (resolved == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce163a69f1475961e28e5f21fcbda876a70fc5ea"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg2MTg2MA==", "bodyText": "I thought it did. Looks like I was confused. I'll dig.", "url": "https://github.com/elastic/elasticsearch/pull/52965#discussion_r387861860", "createdAt": "2020-03-04T18:46:08Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/analytics/src/main/java/org/elasticsearch/xpack/analytics/topmetrics/TopMetricsAggregator.java", "diffHunk": "@@ -117,41 +117,122 @@ public void setScorer(Scorable s) throws IOException {\n \n     @Override\n     public InternalAggregation buildAggregation(long bucket) throws IOException {\n-        if (metricValueSource == null) {\n-            return buildEmptyAggregation();\n-        }\n-        List<InternalTopMetrics.TopMetric> topMetrics = sort.getValues(bucket, values.resultBuilder(sort.getFormat()));\n+        List<InternalTopMetrics.TopMetric> topMetrics = sort.getValues(bucket, metrics.resultBuilder(sort.getFormat()));\n         assert topMetrics.size() <= size;\n-        return new InternalTopMetrics(name, sort.getOrder(), metricName, size, topMetrics, pipelineAggregators(), metaData());\n+        return new InternalTopMetrics(name, sort.getOrder(), metrics.names, size, topMetrics, pipelineAggregators(), metaData());\n     }\n \n     @Override\n     public InternalTopMetrics buildEmptyAggregation() {\n-        // The sort format and sort order aren't used in reduction so we pass the simplest thing.\n-        return InternalTopMetrics.buildEmptyAggregation(name, metricName, pipelineAggregators(),\n-                metaData());\n+        return InternalTopMetrics.buildEmptyAggregation(name, metrics.names, pipelineAggregators(), metaData());\n     }\n \n     @Override\n     public void doClose() {\n-        Releasables.close(sort, values);\n+        Releasables.close(sort, metrics);\n+    }\n+\n+    private static class Metrics implements BucketedSort.ExtraData, Releasable {\n+        private final List<String> names;\n+        private final MetricValues[] values;\n+\n+        Metrics(int size, QueryShardContext ctx, List<MultiValuesSourceFieldConfig> fieldsConfig) {\n+            names = fieldsConfig.stream().map(MultiValuesSourceFieldConfig::getFieldName).collect(toList());\n+            values = new MetricValues[fieldsConfig.size()];\n+            int i = 0;\n+            for (MultiValuesSourceFieldConfig config : fieldsConfig) {\n+                ValuesSourceConfig<ValuesSource.Numeric> resolved = ValuesSourceConfig.resolve(ctx, ValueType.NUMERIC,\n+                        config.getFieldName(), config.getScript(), config.getMissing(), config.getTimeZone(), null);\n+                if (resolved == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg0NDkyMQ=="}, "originalCommit": {"oid": "ce163a69f1475961e28e5f21fcbda876a70fc5ea"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMjgxNzQwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/analytics/src/main/java/org/elasticsearch/xpack/analytics/topmetrics/TopMetricsAggregator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxODoxNTozMFrOFx4M3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxODoxNTozMFrOFx4M3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg0NTM0Mw==", "bodyText": "Be aware that this can throw on invalid configs (i.e. configs containing neither a script nor a field)", "url": "https://github.com/elastic/elasticsearch/pull/52965#discussion_r387845343", "createdAt": "2020-03-04T18:15:30Z", "author": {"login": "not-napoleon"}, "path": "x-pack/plugin/analytics/src/main/java/org/elasticsearch/xpack/analytics/topmetrics/TopMetricsAggregator.java", "diffHunk": "@@ -117,41 +117,122 @@ public void setScorer(Scorable s) throws IOException {\n \n     @Override\n     public InternalAggregation buildAggregation(long bucket) throws IOException {\n-        if (metricValueSource == null) {\n-            return buildEmptyAggregation();\n-        }\n-        List<InternalTopMetrics.TopMetric> topMetrics = sort.getValues(bucket, values.resultBuilder(sort.getFormat()));\n+        List<InternalTopMetrics.TopMetric> topMetrics = sort.getValues(bucket, metrics.resultBuilder(sort.getFormat()));\n         assert topMetrics.size() <= size;\n-        return new InternalTopMetrics(name, sort.getOrder(), metricName, size, topMetrics, pipelineAggregators(), metaData());\n+        return new InternalTopMetrics(name, sort.getOrder(), metrics.names, size, topMetrics, pipelineAggregators(), metaData());\n     }\n \n     @Override\n     public InternalTopMetrics buildEmptyAggregation() {\n-        // The sort format and sort order aren't used in reduction so we pass the simplest thing.\n-        return InternalTopMetrics.buildEmptyAggregation(name, metricName, pipelineAggregators(),\n-                metaData());\n+        return InternalTopMetrics.buildEmptyAggregation(name, metrics.names, pipelineAggregators(), metaData());\n     }\n \n     @Override\n     public void doClose() {\n-        Releasables.close(sort, values);\n+        Releasables.close(sort, metrics);\n+    }\n+\n+    private static class Metrics implements BucketedSort.ExtraData, Releasable {\n+        private final List<String> names;\n+        private final MetricValues[] values;\n+\n+        Metrics(int size, QueryShardContext ctx, List<MultiValuesSourceFieldConfig> fieldsConfig) {\n+            names = fieldsConfig.stream().map(MultiValuesSourceFieldConfig::getFieldName).collect(toList());\n+            values = new MetricValues[fieldsConfig.size()];\n+            int i = 0;\n+            for (MultiValuesSourceFieldConfig config : fieldsConfig) {\n+                ValuesSourceConfig<ValuesSource.Numeric> resolved = ValuesSourceConfig.resolve(ctx, ValueType.NUMERIC,\n+                        config.getFieldName(), config.getScript(), config.getMissing(), config.getTimeZone(), null);\n+                if (resolved == null) {\n+                    values[i++] = new MissingMetricValues();\n+                    continue;\n+                }\n+                ValuesSource.Numeric valuesSource = resolved.toValuesSource(ctx);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce163a69f1475961e28e5f21fcbda876a70fc5ea"}, "originalPosition": 142}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMjg1Mzg4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/analytics/src/main/java/org/elasticsearch/xpack/analytics/topmetrics/TopMetricsAggregator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxODoyNjoyM1rOFx4jug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxODo0NzoxOVrOFx5P7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg1MTE5NA==", "bodyText": "This seems late in the game to be resolving values sources.  Usually we do that at the border between the builder and the factory, and pass the values source(s) into the aggregator.  If it has to be this way, let's at least leave a comment as to why that's the case, please.", "url": "https://github.com/elastic/elasticsearch/pull/52965#discussion_r387851194", "createdAt": "2020-03-04T18:26:23Z", "author": {"login": "not-napoleon"}, "path": "x-pack/plugin/analytics/src/main/java/org/elasticsearch/xpack/analytics/topmetrics/TopMetricsAggregator.java", "diffHunk": "@@ -117,41 +117,122 @@ public void setScorer(Scorable s) throws IOException {\n \n     @Override\n     public InternalAggregation buildAggregation(long bucket) throws IOException {\n-        if (metricValueSource == null) {\n-            return buildEmptyAggregation();\n-        }\n-        List<InternalTopMetrics.TopMetric> topMetrics = sort.getValues(bucket, values.resultBuilder(sort.getFormat()));\n+        List<InternalTopMetrics.TopMetric> topMetrics = sort.getValues(bucket, metrics.resultBuilder(sort.getFormat()));\n         assert topMetrics.size() <= size;\n-        return new InternalTopMetrics(name, sort.getOrder(), metricName, size, topMetrics, pipelineAggregators(), metaData());\n+        return new InternalTopMetrics(name, sort.getOrder(), metrics.names, size, topMetrics, pipelineAggregators(), metaData());\n     }\n \n     @Override\n     public InternalTopMetrics buildEmptyAggregation() {\n-        // The sort format and sort order aren't used in reduction so we pass the simplest thing.\n-        return InternalTopMetrics.buildEmptyAggregation(name, metricName, pipelineAggregators(),\n-                metaData());\n+        return InternalTopMetrics.buildEmptyAggregation(name, metrics.names, pipelineAggregators(), metaData());\n     }\n \n     @Override\n     public void doClose() {\n-        Releasables.close(sort, values);\n+        Releasables.close(sort, metrics);\n+    }\n+\n+    private static class Metrics implements BucketedSort.ExtraData, Releasable {\n+        private final List<String> names;\n+        private final MetricValues[] values;\n+\n+        Metrics(int size, QueryShardContext ctx, List<MultiValuesSourceFieldConfig> fieldsConfig) {\n+            names = fieldsConfig.stream().map(MultiValuesSourceFieldConfig::getFieldName).collect(toList());\n+            values = new MetricValues[fieldsConfig.size()];\n+            int i = 0;\n+            for (MultiValuesSourceFieldConfig config : fieldsConfig) {\n+                ValuesSourceConfig<ValuesSource.Numeric> resolved = ValuesSourceConfig.resolve(ctx, ValueType.NUMERIC,\n+                        config.getFieldName(), config.getScript(), config.getMissing(), config.getTimeZone(), null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce163a69f1475961e28e5f21fcbda876a70fc5ea"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg2MjUxMA==", "bodyText": "I believe this is right at aggregator construction time - so it is on the boarder, just on the Aggregator side of it. I can see if I can move it if it'd make things nicer.", "url": "https://github.com/elastic/elasticsearch/pull/52965#discussion_r387862510", "createdAt": "2020-03-04T18:47:19Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/analytics/src/main/java/org/elasticsearch/xpack/analytics/topmetrics/TopMetricsAggregator.java", "diffHunk": "@@ -117,41 +117,122 @@ public void setScorer(Scorable s) throws IOException {\n \n     @Override\n     public InternalAggregation buildAggregation(long bucket) throws IOException {\n-        if (metricValueSource == null) {\n-            return buildEmptyAggregation();\n-        }\n-        List<InternalTopMetrics.TopMetric> topMetrics = sort.getValues(bucket, values.resultBuilder(sort.getFormat()));\n+        List<InternalTopMetrics.TopMetric> topMetrics = sort.getValues(bucket, metrics.resultBuilder(sort.getFormat()));\n         assert topMetrics.size() <= size;\n-        return new InternalTopMetrics(name, sort.getOrder(), metricName, size, topMetrics, pipelineAggregators(), metaData());\n+        return new InternalTopMetrics(name, sort.getOrder(), metrics.names, size, topMetrics, pipelineAggregators(), metaData());\n     }\n \n     @Override\n     public InternalTopMetrics buildEmptyAggregation() {\n-        // The sort format and sort order aren't used in reduction so we pass the simplest thing.\n-        return InternalTopMetrics.buildEmptyAggregation(name, metricName, pipelineAggregators(),\n-                metaData());\n+        return InternalTopMetrics.buildEmptyAggregation(name, metrics.names, pipelineAggregators(), metaData());\n     }\n \n     @Override\n     public void doClose() {\n-        Releasables.close(sort, values);\n+        Releasables.close(sort, metrics);\n+    }\n+\n+    private static class Metrics implements BucketedSort.ExtraData, Releasable {\n+        private final List<String> names;\n+        private final MetricValues[] values;\n+\n+        Metrics(int size, QueryShardContext ctx, List<MultiValuesSourceFieldConfig> fieldsConfig) {\n+            names = fieldsConfig.stream().map(MultiValuesSourceFieldConfig::getFieldName).collect(toList());\n+            values = new MetricValues[fieldsConfig.size()];\n+            int i = 0;\n+            for (MultiValuesSourceFieldConfig config : fieldsConfig) {\n+                ValuesSourceConfig<ValuesSource.Numeric> resolved = ValuesSourceConfig.resolve(ctx, ValueType.NUMERIC,\n+                        config.getFieldName(), config.getScript(), config.getMissing(), config.getTimeZone(), null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg1MTE5NA=="}, "originalCommit": {"oid": "ce163a69f1475961e28e5f21fcbda876a70fc5ea"}, "originalPosition": 137}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3469, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}