{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcxNzExMTgx", "number": 61428, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxNTo1MjozMFrOEbBQqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxMDo1MjozOVrOEcA2mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2NzY3NjU5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/action/EqlSearchResponse.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxNTo1MjozMFrOHEygWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQyMTo1MToyMlrOHF3iiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc4MzgzNA==", "bodyText": "This bit caused a lot of wasted time trying to figure out why the response was not working. I had to use the deprecated form since the form above gave incorrect results - the json was mangled with some extra characters and I'm not sure where those occurred. Initially I assumed it's a compressed stream but it's not since the source is always uncompressed from the underlying object.\nSo maybe it's stored in JSON format ... don't know.\n@imotov any ideas?", "url": "https://github.com/elastic/elasticsearch/pull/61428#discussion_r474783834", "createdAt": "2020-08-21T15:52:30Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/action/EqlSearchResponse.java", "diffHunk": "@@ -179,6 +182,110 @@ public String toString() {\n         return Strings.toString(this);\n     }\n \n+    // Event\n+    public static class Event implements Writeable, ToXContentObject {\n+\n+        private static final class Fields {\n+            static final String INDEX = GetResult._INDEX;\n+            static final String ID = GetResult._ID;\n+            static final String SOURCE = SourceFieldMapper.NAME;\n+        }\n+\n+        private static final ParseField INDEX = new ParseField(Fields.INDEX);\n+        private static final ParseField ID = new ParseField(Fields.ID);\n+        private static final ParseField SOURCE = new ParseField(Fields.SOURCE);\n+\n+        private static final ConstructingObjectParser<Event, Void> PARSER =\n+                new ConstructingObjectParser<>(\"eql/search_response_event\", true,\n+                        args -> new Event((String) args[0], (String) args[1], (BytesReference) args[2]));\n+\n+        static {\n+            PARSER.declareString(constructorArg(), INDEX);\n+            PARSER.declareString(constructorArg(), ID);\n+            PARSER.declareObject(constructorArg(), (p, c) -> {\n+                try (XContentBuilder builder = XContentBuilder.builder(p.contentType().xContent())) {\n+                    builder.copyCurrentStructure(p);\n+                    return BytesReference.bytes(builder);\n+                }\n+            }, SOURCE);\n+        }\n+\n+        private final String index;\n+        private final String id;\n+        private final BytesReference source;\n+\n+        public Event(String index, String id, BytesReference source) {\n+            this.index = index;\n+            this.id = id;\n+            this.source = source;\n+        }\n+        \n+        public Event(StreamInput in) throws IOException {\n+            index = in.readString();\n+            id = in.readString();\n+            source = in.readBytesReference();\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            out.writeString(index);\n+            out.writeString(id);\n+            out.writeBytesReference(source);\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+            builder.startObject();\n+            builder.field(Fields.INDEX, index);\n+            builder.field(Fields.ID, id);\n+            //XContentHelper.writeRawField(Fields.SOURCE, source, builder.contentType(), builder, params);\n+            XContentHelper.writeRawField(Fields.SOURCE, source, builder, params);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ddc9ca3fad6309f365d39fd20346bc0923a3d29"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc4Nzg2MQ==", "bodyText": "Where wasn't it working? Can I reproduce it somehow?", "url": "https://github.com/elastic/elasticsearch/pull/61428#discussion_r474787861", "createdAt": "2020-08-21T15:59:59Z", "author": {"login": "imotov"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/action/EqlSearchResponse.java", "diffHunk": "@@ -179,6 +182,110 @@ public String toString() {\n         return Strings.toString(this);\n     }\n \n+    // Event\n+    public static class Event implements Writeable, ToXContentObject {\n+\n+        private static final class Fields {\n+            static final String INDEX = GetResult._INDEX;\n+            static final String ID = GetResult._ID;\n+            static final String SOURCE = SourceFieldMapper.NAME;\n+        }\n+\n+        private static final ParseField INDEX = new ParseField(Fields.INDEX);\n+        private static final ParseField ID = new ParseField(Fields.ID);\n+        private static final ParseField SOURCE = new ParseField(Fields.SOURCE);\n+\n+        private static final ConstructingObjectParser<Event, Void> PARSER =\n+                new ConstructingObjectParser<>(\"eql/search_response_event\", true,\n+                        args -> new Event((String) args[0], (String) args[1], (BytesReference) args[2]));\n+\n+        static {\n+            PARSER.declareString(constructorArg(), INDEX);\n+            PARSER.declareString(constructorArg(), ID);\n+            PARSER.declareObject(constructorArg(), (p, c) -> {\n+                try (XContentBuilder builder = XContentBuilder.builder(p.contentType().xContent())) {\n+                    builder.copyCurrentStructure(p);\n+                    return BytesReference.bytes(builder);\n+                }\n+            }, SOURCE);\n+        }\n+\n+        private final String index;\n+        private final String id;\n+        private final BytesReference source;\n+\n+        public Event(String index, String id, BytesReference source) {\n+            this.index = index;\n+            this.id = id;\n+            this.source = source;\n+        }\n+        \n+        public Event(StreamInput in) throws IOException {\n+            index = in.readString();\n+            id = in.readString();\n+            source = in.readBytesReference();\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            out.writeString(index);\n+            out.writeString(id);\n+            out.writeBytesReference(source);\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+            builder.startObject();\n+            builder.field(Fields.INDEX, index);\n+            builder.field(Fields.ID, id);\n+            //XContentHelper.writeRawField(Fields.SOURCE, source, builder.contentType(), builder, params);\n+            XContentHelper.writeRawField(Fields.SOURCE, source, builder, params);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc4MzgzNA=="}, "originalCommit": {"oid": "8ddc9ca3fad6309f365d39fd20346bc0923a3d29"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgzNTc0OA==", "bodyText": "If you switch the statements above (uncomment the line above and comment the existing one) you should get failures in EqlIT tests.\nI closed the shell with the failure but looking at it, the whitespaces and starting delimiters in JSON for source where replaced with some out of band ASCII ones (hence why I assume it's CBOR or some other binary format).", "url": "https://github.com/elastic/elasticsearch/pull/61428#discussion_r474835748", "createdAt": "2020-08-21T17:37:04Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/action/EqlSearchResponse.java", "diffHunk": "@@ -179,6 +182,110 @@ public String toString() {\n         return Strings.toString(this);\n     }\n \n+    // Event\n+    public static class Event implements Writeable, ToXContentObject {\n+\n+        private static final class Fields {\n+            static final String INDEX = GetResult._INDEX;\n+            static final String ID = GetResult._ID;\n+            static final String SOURCE = SourceFieldMapper.NAME;\n+        }\n+\n+        private static final ParseField INDEX = new ParseField(Fields.INDEX);\n+        private static final ParseField ID = new ParseField(Fields.ID);\n+        private static final ParseField SOURCE = new ParseField(Fields.SOURCE);\n+\n+        private static final ConstructingObjectParser<Event, Void> PARSER =\n+                new ConstructingObjectParser<>(\"eql/search_response_event\", true,\n+                        args -> new Event((String) args[0], (String) args[1], (BytesReference) args[2]));\n+\n+        static {\n+            PARSER.declareString(constructorArg(), INDEX);\n+            PARSER.declareString(constructorArg(), ID);\n+            PARSER.declareObject(constructorArg(), (p, c) -> {\n+                try (XContentBuilder builder = XContentBuilder.builder(p.contentType().xContent())) {\n+                    builder.copyCurrentStructure(p);\n+                    return BytesReference.bytes(builder);\n+                }\n+            }, SOURCE);\n+        }\n+\n+        private final String index;\n+        private final String id;\n+        private final BytesReference source;\n+\n+        public Event(String index, String id, BytesReference source) {\n+            this.index = index;\n+            this.id = id;\n+            this.source = source;\n+        }\n+        \n+        public Event(StreamInput in) throws IOException {\n+            index = in.readString();\n+            id = in.readString();\n+            source = in.readBytesReference();\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            out.writeString(index);\n+            out.writeString(id);\n+            out.writeBytesReference(source);\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+            builder.startObject();\n+            builder.field(Fields.INDEX, index);\n+            builder.field(Fields.ID, id);\n+            //XContentHelper.writeRawField(Fields.SOURCE, source, builder.contentType(), builder, params);\n+            XContentHelper.writeRawField(Fields.SOURCE, source, builder, params);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc4MzgzNA=="}, "originalCommit": {"oid": "8ddc9ca3fad6309f365d39fd20346bc0923a3d29"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg0NTI0Mg==", "bodyText": "Looks the CI managed to reproduce this in the unit tests.\nRunning org.elasticsearch.client.eql.EqlSearchResponseTests using seed 9361DF75459AFCD5 causes the underlying bytearray to different chars - trying to read the byte array gives:\njava.lang.AssertionError: b = 0xfa\n\tat org.apache.lucene.util.UnicodeUtil.UTF8toUTF16(UnicodeUtil.java:601)\n\tat org.apache.lucene.util.BytesRef.utf8ToString(BytesRef.java:137)\n\tat org.elasticsearch.common.bytes.AbstractBytesReference.utf8ToString(AbstractBytesReference.java:68)\n\tat org.elasticsearch.client.eql.EqlSearchResponseTests.assertInstances(EqlSearchResponseTests.java:240)\n\tat org.elasticsearch.client.eql.EqlSearchResponseTests.assertInstances(EqlSearchResponseTests.java:1)\n\nSwitch the lines above and you'll get the same error I seen before:\njava.lang.AssertionError: \nExpected: is <[org.elasticsearch.client.eql.EqlSearchResponse$Event@627ca34b, org.elasticsearch.client.eql.EqlSearchResponse$Event@7dae4c21, org.elasticsearch.client.eql.EqlSearchResponse$Event@8dba81f1, org.elasticsearch.client.eql.EqlSearchResponse$Event@245f1512, org.elasticsearch.client.eql.EqlSearchResponse$Event@cb4a5cb4, org.elasticsearch.client.eql.EqlSearchResponse$Event@5c36c41c, org.elasticsearch.client.eql.EqlSearchResponse$Event@eb88326f]>\n     but: was <[{\n  \"error\" : \"error building toString out of XContent: Unexpected character (':' (code 58)): expected a valid value (JSON String, Number, Array, Object or token 'null', 'true' or 'false')\\n at [Source: (org.elasticsearch.common.bytes.AbstractBytesReference$MarkSupportingStreamInputWrapper); line: 1, column: 2]\",", "url": "https://github.com/elastic/elasticsearch/pull/61428#discussion_r474845242", "createdAt": "2020-08-21T17:57:00Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/action/EqlSearchResponse.java", "diffHunk": "@@ -179,6 +182,110 @@ public String toString() {\n         return Strings.toString(this);\n     }\n \n+    // Event\n+    public static class Event implements Writeable, ToXContentObject {\n+\n+        private static final class Fields {\n+            static final String INDEX = GetResult._INDEX;\n+            static final String ID = GetResult._ID;\n+            static final String SOURCE = SourceFieldMapper.NAME;\n+        }\n+\n+        private static final ParseField INDEX = new ParseField(Fields.INDEX);\n+        private static final ParseField ID = new ParseField(Fields.ID);\n+        private static final ParseField SOURCE = new ParseField(Fields.SOURCE);\n+\n+        private static final ConstructingObjectParser<Event, Void> PARSER =\n+                new ConstructingObjectParser<>(\"eql/search_response_event\", true,\n+                        args -> new Event((String) args[0], (String) args[1], (BytesReference) args[2]));\n+\n+        static {\n+            PARSER.declareString(constructorArg(), INDEX);\n+            PARSER.declareString(constructorArg(), ID);\n+            PARSER.declareObject(constructorArg(), (p, c) -> {\n+                try (XContentBuilder builder = XContentBuilder.builder(p.contentType().xContent())) {\n+                    builder.copyCurrentStructure(p);\n+                    return BytesReference.bytes(builder);\n+                }\n+            }, SOURCE);\n+        }\n+\n+        private final String index;\n+        private final String id;\n+        private final BytesReference source;\n+\n+        public Event(String index, String id, BytesReference source) {\n+            this.index = index;\n+            this.id = id;\n+            this.source = source;\n+        }\n+        \n+        public Event(StreamInput in) throws IOException {\n+            index = in.readString();\n+            id = in.readString();\n+            source = in.readBytesReference();\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            out.writeString(index);\n+            out.writeString(id);\n+            out.writeBytesReference(source);\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+            builder.startObject();\n+            builder.field(Fields.INDEX, index);\n+            builder.field(Fields.ID, id);\n+            //XContentHelper.writeRawField(Fields.SOURCE, source, builder.contentType(), builder, params);\n+            XContentHelper.writeRawField(Fields.SOURCE, source, builder, params);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc4MzgzNA=="}, "originalCommit": {"oid": "8ddc9ca3fad6309f365d39fd20346bc0923a3d29"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDk5NTc5NA==", "bodyText": "Oh, I see, it thinks it is the start of the stream. I will take a look the first thing Monday morning. SDH today - so didn't have a chance to look at it yet.", "url": "https://github.com/elastic/elasticsearch/pull/61428#discussion_r474995794", "createdAt": "2020-08-21T22:28:08Z", "author": {"login": "imotov"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/action/EqlSearchResponse.java", "diffHunk": "@@ -179,6 +182,110 @@ public String toString() {\n         return Strings.toString(this);\n     }\n \n+    // Event\n+    public static class Event implements Writeable, ToXContentObject {\n+\n+        private static final class Fields {\n+            static final String INDEX = GetResult._INDEX;\n+            static final String ID = GetResult._ID;\n+            static final String SOURCE = SourceFieldMapper.NAME;\n+        }\n+\n+        private static final ParseField INDEX = new ParseField(Fields.INDEX);\n+        private static final ParseField ID = new ParseField(Fields.ID);\n+        private static final ParseField SOURCE = new ParseField(Fields.SOURCE);\n+\n+        private static final ConstructingObjectParser<Event, Void> PARSER =\n+                new ConstructingObjectParser<>(\"eql/search_response_event\", true,\n+                        args -> new Event((String) args[0], (String) args[1], (BytesReference) args[2]));\n+\n+        static {\n+            PARSER.declareString(constructorArg(), INDEX);\n+            PARSER.declareString(constructorArg(), ID);\n+            PARSER.declareObject(constructorArg(), (p, c) -> {\n+                try (XContentBuilder builder = XContentBuilder.builder(p.contentType().xContent())) {\n+                    builder.copyCurrentStructure(p);\n+                    return BytesReference.bytes(builder);\n+                }\n+            }, SOURCE);\n+        }\n+\n+        private final String index;\n+        private final String id;\n+        private final BytesReference source;\n+\n+        public Event(String index, String id, BytesReference source) {\n+            this.index = index;\n+            this.id = id;\n+            this.source = source;\n+        }\n+        \n+        public Event(StreamInput in) throws IOException {\n+            index = in.readString();\n+            id = in.readString();\n+            source = in.readBytesReference();\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            out.writeString(index);\n+            out.writeString(id);\n+            out.writeBytesReference(source);\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+            builder.startObject();\n+            builder.field(Fields.INDEX, index);\n+            builder.field(Fields.ID, id);\n+            //XContentHelper.writeRawField(Fields.SOURCE, source, builder.contentType(), builder, params);\n+            XContentHelper.writeRawField(Fields.SOURCE, source, builder, params);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc4MzgzNA=="}, "originalCommit": {"oid": "8ddc9ca3fad6309f365d39fd20346bc0923a3d29"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTkxNDg4OA==", "bodyText": "I don't think we can avoid using this deprecated method as long as it is used by SearchHit for the same basic reason it is used by SearchHit - we have no idea in which format the source was stored so we need to detect it in the run time. We would basically need to store original source content type in order to avoid using this method, which we don't.", "url": "https://github.com/elastic/elasticsearch/pull/61428#discussion_r475914888", "createdAt": "2020-08-24T21:51:22Z", "author": {"login": "imotov"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/action/EqlSearchResponse.java", "diffHunk": "@@ -179,6 +182,110 @@ public String toString() {\n         return Strings.toString(this);\n     }\n \n+    // Event\n+    public static class Event implements Writeable, ToXContentObject {\n+\n+        private static final class Fields {\n+            static final String INDEX = GetResult._INDEX;\n+            static final String ID = GetResult._ID;\n+            static final String SOURCE = SourceFieldMapper.NAME;\n+        }\n+\n+        private static final ParseField INDEX = new ParseField(Fields.INDEX);\n+        private static final ParseField ID = new ParseField(Fields.ID);\n+        private static final ParseField SOURCE = new ParseField(Fields.SOURCE);\n+\n+        private static final ConstructingObjectParser<Event, Void> PARSER =\n+                new ConstructingObjectParser<>(\"eql/search_response_event\", true,\n+                        args -> new Event((String) args[0], (String) args[1], (BytesReference) args[2]));\n+\n+        static {\n+            PARSER.declareString(constructorArg(), INDEX);\n+            PARSER.declareString(constructorArg(), ID);\n+            PARSER.declareObject(constructorArg(), (p, c) -> {\n+                try (XContentBuilder builder = XContentBuilder.builder(p.contentType().xContent())) {\n+                    builder.copyCurrentStructure(p);\n+                    return BytesReference.bytes(builder);\n+                }\n+            }, SOURCE);\n+        }\n+\n+        private final String index;\n+        private final String id;\n+        private final BytesReference source;\n+\n+        public Event(String index, String id, BytesReference source) {\n+            this.index = index;\n+            this.id = id;\n+            this.source = source;\n+        }\n+        \n+        public Event(StreamInput in) throws IOException {\n+            index = in.readString();\n+            id = in.readString();\n+            source = in.readBytesReference();\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            out.writeString(index);\n+            out.writeString(id);\n+            out.writeBytesReference(source);\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+            builder.startObject();\n+            builder.field(Fields.INDEX, index);\n+            builder.field(Fields.ID, id);\n+            //XContentHelper.writeRawField(Fields.SOURCE, source, builder.contentType(), builder, params);\n+            XContentHelper.writeRawField(Fields.SOURCE, source, builder, params);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc4MzgzNA=="}, "originalCommit": {"oid": "8ddc9ca3fad6309f365d39fd20346bc0923a3d29"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2NzcwOTI4OnYy", "diffSide": "LEFT", "path": "docs/reference/eql/eql-search-api.asciidoc", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxNjowMjoyMVrOHEy0nA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxNjowMjoyMVrOHEy0nA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc4OTAyMA==", "bodyText": "We also need to remove docs for _version, seq_no, and primary_term params (located right above this one). I can do that in a follow-up PR if wanted.", "url": "https://github.com/elastic/elasticsearch/pull/61428#discussion_r474789020", "createdAt": "2020-08-21T16:02:21Z", "author": {"login": "jrodewig"}, "path": "docs/reference/eql/eql-search-api.asciidoc", "diffHunk": "@@ -442,11 +442,6 @@ doesn\u2019t overwrite a newer version. See <<optimistic-concurrency-control>>.\n (integer)\n Primary term assigned to the document. See <<optimistic-concurrency-control>>.\n \n-`_score`::", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ddc9ca3fad6309f365d39fd20346bc0923a3d29"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3ODA5NTYzOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/execution/search/AsEventListener.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxMDo1MjozOVrOHGSjWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxMToyNzoyNlrOHGTl-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjM1NzQ2NA==", "bodyText": "What does As mean?", "url": "https://github.com/elastic/elasticsearch/pull/61428#discussion_r476357464", "createdAt": "2020-08-25T10:52:39Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/execution/search/AsEventListener.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.execution.search;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.xpack.eql.execution.payload.EventPayload;\n+import org.elasticsearch.xpack.eql.session.Payload;\n+\n+public class AsEventListener implements ActionListener<SearchResponse> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cda6d22ebc32e5d38ca7cb9052354ef09af9991f"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjM3NDUyMw==", "bodyText": "SearchResponse as Event", "url": "https://github.com/elastic/elasticsearch/pull/61428#discussion_r476374523", "createdAt": "2020-08-25T11:27:26Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/execution/search/AsEventListener.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.execution.search;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.xpack.eql.execution.payload.EventPayload;\n+import org.elasticsearch.xpack.eql.session.Payload;\n+\n+public class AsEventListener implements ActionListener<SearchResponse> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjM1NzQ2NA=="}, "originalCommit": {"oid": "cda6d22ebc32e5d38ca7cb9052354ef09af9991f"}, "originalPosition": 14}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 782, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}