{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI4MDkyNTcw", "number": 57701, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwODo0OTozMlrOEC3x6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOToyMDoyMVrOEC4bpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNDQ2NTA0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataCreateIndexService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwODo0OTozMlrOGfl6jg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwODo0OTozMlrOGfl6jg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc4MDIzOA==", "bodyText": "I thnik this could be expressed as, I find it a bit more readable, but maybe it's a personal preference so feel free to ignore\n        List<String> matchedPrefixes = results.keySet().stream().filter(k -> prefixes.contains(prefix(k))).collect(Collectors.toList())", "url": "https://github.com/elastic/elasticsearch/pull/57701#discussion_r435780238", "createdAt": "2020-06-05T08:49:32Z", "author": {"login": "andreidan"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataCreateIndexService.java", "diffHunk": "@@ -687,18 +687,23 @@ private static void validateValuesAreMapsOfSizeOne(List<Map<String, Object>> sec\n     }\n \n     /**\n-     * Add the objects in the second map to the first, where the keys in the {@code second} map have\n-     * higher predecence and overwrite the keys in the {@code first} map. In the event of a key with\n-     * a dot in it (ie, \"foo.bar\"), the keys are treated as only the prefix counting towards\n-     * equality. If the {@code second} map has a key such as \"foo\", all keys starting from \"foo.\" in\n-     * the {@code first} map are discarded.\n+     * Add the objects in the second map to the first, A duplicated field is treated as illegal and\n+     * an exception is thrown.\n      */\n-    static Map<String, Object> mergeIgnoringDots(Map<String, Object> first, Map<String, Object> second) {\n+    static Map<String, Object> mergeFailingOnReplacement(Map<String, Object> first, Map<String, Object> second) {\n         Objects.requireNonNull(first, \"merging requires two non-null maps but the first map was null\");\n         Objects.requireNonNull(second, \"merging requires two non-null maps but the second map was null\");\n         Map<String, Object> results = new HashMap<>(first);\n         Set<String> prefixes = second.keySet().stream().map(MetadataCreateIndexService::prefix).collect(Collectors.toSet());\n-        results.keySet().removeIf(k -> prefixes.contains(prefix(k)));\n+        List<String> matchedPrefixes = new ArrayList<>();\n+        results.keySet().forEach(k -> {\n+            if (prefixes.contains(prefix(k))) {\n+                matchedPrefixes.add(k);\n+            }\n+        });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b393e30af04a06fa08eff0ad21f43dca603af2e6"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNDQ3MTA4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexTemplateService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwODo1MTowMVrOGfl-MQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwODo1MTowMVrOGfl-MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc4MTE2OQ==", "bodyText": "Nice!", "url": "https://github.com/elastic/elasticsearch/pull/57701#discussion_r435781169", "createdAt": "2020-06-05T08:51:01Z", "author": {"login": "andreidan"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexTemplateService.java", "diffHunk": "@@ -195,15 +195,21 @@ ClusterState addComponentTemplate(final ClusterState currentState, final boolean\n \n         validateTemplate(finalSettings, stringMappings, indicesService, xContentRegistry);\n \n+        // Collect all the composable (index) templates that use this component template, we'll use\n+        // this for validating that they're still going to be valid after this component template\n+        // has been updated\n+        final Map<String, ComposableIndexTemplate> templatesUsingComponent = currentState.metadata().templatesV2().entrySet().stream()\n+            .filter(e -> e.getValue().composedOf().contains(name))\n+            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n+\n         // if we're updating a component template, let's check if it's part of any V2 template that will yield the CT update invalid\n         if (create == false && finalSettings != null) {\n             // if the CT is specifying the `index.hidden` setting it cannot be part of any global template\n             if (IndexMetadata.INDEX_HIDDEN_SETTING.exists(finalSettings)) {\n-                Map<String, ComposableIndexTemplate> existingTemplates = currentState.metadata().templatesV2();\n                 List<String> globalTemplatesThatUseThisComponent = new ArrayList<>();\n-                for (Map.Entry<String, ComposableIndexTemplate> entry : existingTemplates.entrySet()) {\n+                for (Map.Entry<String, ComposableIndexTemplate> entry : templatesUsingComponent.entrySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b393e30af04a06fa08eff0ad21f43dca603af2e6"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNDQ4NDMyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexTemplateService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwODo1NTowNVrOGfmG6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwMzo1NDoxMFrOGgOhQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc4MzQwMw==", "bodyText": "the composite term is a bit confusing (at least for me) - we have composable templates so composite template made me think of a possible v3 template of sorts that might combine other templates. Would it make sense to reuse resolve(d) for the final configuration of a composable template? ie. validateResolvedComposableTemplate ? resolveAndValidateComposableTemplate ?\nWhat do you think?", "url": "https://github.com/elastic/elasticsearch/pull/57701#discussion_r435783403", "createdAt": "2020-06-05T08:55:05Z", "author": {"login": "andreidan"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexTemplateService.java", "diffHunk": "@@ -910,6 +951,77 @@ private static Settings resolveSettings(Metadata metadata, ComposableIndexTempla\n         return Collections.unmodifiableList(aliases);\n     }\n \n+    /**\n+     * Given a state and a composable template, validate that the final composite template\n+     * generated by the composable template and all of its component templates contains valid\n+     * settings, mappings, and aliases.\n+     */\n+    private static void validateCompositeTemplate(final ClusterState state,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b393e30af04a06fa08eff0ad21f43dca603af2e6"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0NTUwNw==", "bodyText": "I dunno, I didn't think they were too different, I wanted to treat \"resolved\" as pertaining to a particular index, so I think the current name isn't too bad.", "url": "https://github.com/elastic/elasticsearch/pull/57701#discussion_r436445507", "createdAt": "2020-06-08T03:54:10Z", "author": {"login": "dakrone"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexTemplateService.java", "diffHunk": "@@ -910,6 +951,77 @@ private static Settings resolveSettings(Metadata metadata, ComposableIndexTempla\n         return Collections.unmodifiableList(aliases);\n     }\n \n+    /**\n+     * Given a state and a composable template, validate that the final composite template\n+     * generated by the composable template and all of its component templates contains valid\n+     * settings, mappings, and aliases.\n+     */\n+    private static void validateCompositeTemplate(final ClusterState state,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc4MzQwMw=="}, "originalCommit": {"oid": "b393e30af04a06fa08eff0ad21f43dca603af2e6"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNDUwMTA5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexTemplateService.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwODo1OTo1NlrOGfmR4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwMzozNDozN1rOGgOULw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc4NjIxMA==", "bodyText": "is this comment obsolete or misplaced?", "url": "https://github.com/elastic/elasticsearch/pull/57701#discussion_r435786210", "createdAt": "2020-06-05T08:59:56Z", "author": {"login": "andreidan"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexTemplateService.java", "diffHunk": "@@ -910,6 +951,77 @@ private static Settings resolveSettings(Metadata metadata, ComposableIndexTempla\n         return Collections.unmodifiableList(aliases);\n     }\n \n+    /**\n+     * Given a state and a composable template, validate that the final composite template\n+     * generated by the composable template and all of its component templates contains valid\n+     * settings, mappings, and aliases.\n+     */\n+    private static void validateCompositeTemplate(final ClusterState state,\n+                                                  final String templateName,\n+                                                  final ComposableIndexTemplate template,\n+                                                  final IndicesService indicesService,\n+                                                  final NamedXContentRegistry xContentRegistry) throws Exception {\n+        final ClusterState stateWithTemplate = ClusterState.builder(state)\n+            .metadata(Metadata.builder(state.metadata()).put(templateName, template))\n+            .build();\n+\n+        Index createdIndex = null;\n+        final String temporaryIndexName = \"validate-template-\" + UUIDs.randomBase64UUID().toLowerCase(Locale.ROOT);\n+        try {\n+            Settings resolvedSettings = resolveSettings(stateWithTemplate.metadata(), templateName);\n+\n+            // use the provided values, otherwise just pick valid dummy values\n+            int dummyPartitionSize = IndexMetadata.INDEX_ROUTING_PARTITION_SIZE_SETTING.get(resolvedSettings);\n+            int dummyShards = resolvedSettings.getAsInt(IndexMetadata.SETTING_NUMBER_OF_SHARDS,\n+                dummyPartitionSize == 1 ? 1 : dummyPartitionSize + 1);\n+            int shardReplicas = resolvedSettings.getAsInt(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0);\n+\n+\n+            //create index service for parsing and validating \"mappings\"\n+            Settings dummySettings = Settings.builder()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b393e30af04a06fa08eff0ad21f43dca603af2e6"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc4NzExMg==", "bodyText": "also maybe dummySettings is not the best name as it includes the actual resolvedSettings? maybe finalIndexSettings or resolvedIndexSettings? What do you think?", "url": "https://github.com/elastic/elasticsearch/pull/57701#discussion_r435787112", "createdAt": "2020-06-05T09:01:25Z", "author": {"login": "andreidan"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexTemplateService.java", "diffHunk": "@@ -910,6 +951,77 @@ private static Settings resolveSettings(Metadata metadata, ComposableIndexTempla\n         return Collections.unmodifiableList(aliases);\n     }\n \n+    /**\n+     * Given a state and a composable template, validate that the final composite template\n+     * generated by the composable template and all of its component templates contains valid\n+     * settings, mappings, and aliases.\n+     */\n+    private static void validateCompositeTemplate(final ClusterState state,\n+                                                  final String templateName,\n+                                                  final ComposableIndexTemplate template,\n+                                                  final IndicesService indicesService,\n+                                                  final NamedXContentRegistry xContentRegistry) throws Exception {\n+        final ClusterState stateWithTemplate = ClusterState.builder(state)\n+            .metadata(Metadata.builder(state.metadata()).put(templateName, template))\n+            .build();\n+\n+        Index createdIndex = null;\n+        final String temporaryIndexName = \"validate-template-\" + UUIDs.randomBase64UUID().toLowerCase(Locale.ROOT);\n+        try {\n+            Settings resolvedSettings = resolveSettings(stateWithTemplate.metadata(), templateName);\n+\n+            // use the provided values, otherwise just pick valid dummy values\n+            int dummyPartitionSize = IndexMetadata.INDEX_ROUTING_PARTITION_SIZE_SETTING.get(resolvedSettings);\n+            int dummyShards = resolvedSettings.getAsInt(IndexMetadata.SETTING_NUMBER_OF_SHARDS,\n+                dummyPartitionSize == 1 ? 1 : dummyPartitionSize + 1);\n+            int shardReplicas = resolvedSettings.getAsInt(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0);\n+\n+\n+            //create index service for parsing and validating \"mappings\"\n+            Settings dummySettings = Settings.builder()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc4NjIxMA=="}, "originalCommit": {"oid": "b393e30af04a06fa08eff0ad21f43dca603af2e6"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0MjE1OQ==", "bodyText": "Yep, I think that makes sense, going with finalResolvedSettings", "url": "https://github.com/elastic/elasticsearch/pull/57701#discussion_r436442159", "createdAt": "2020-06-08T03:34:37Z", "author": {"login": "dakrone"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexTemplateService.java", "diffHunk": "@@ -910,6 +951,77 @@ private static Settings resolveSettings(Metadata metadata, ComposableIndexTempla\n         return Collections.unmodifiableList(aliases);\n     }\n \n+    /**\n+     * Given a state and a composable template, validate that the final composite template\n+     * generated by the composable template and all of its component templates contains valid\n+     * settings, mappings, and aliases.\n+     */\n+    private static void validateCompositeTemplate(final ClusterState state,\n+                                                  final String templateName,\n+                                                  final ComposableIndexTemplate template,\n+                                                  final IndicesService indicesService,\n+                                                  final NamedXContentRegistry xContentRegistry) throws Exception {\n+        final ClusterState stateWithTemplate = ClusterState.builder(state)\n+            .metadata(Metadata.builder(state.metadata()).put(templateName, template))\n+            .build();\n+\n+        Index createdIndex = null;\n+        final String temporaryIndexName = \"validate-template-\" + UUIDs.randomBase64UUID().toLowerCase(Locale.ROOT);\n+        try {\n+            Settings resolvedSettings = resolveSettings(stateWithTemplate.metadata(), templateName);\n+\n+            // use the provided values, otherwise just pick valid dummy values\n+            int dummyPartitionSize = IndexMetadata.INDEX_ROUTING_PARTITION_SIZE_SETTING.get(resolvedSettings);\n+            int dummyShards = resolvedSettings.getAsInt(IndexMetadata.SETTING_NUMBER_OF_SHARDS,\n+                dummyPartitionSize == 1 ? 1 : dummyPartitionSize + 1);\n+            int shardReplicas = resolvedSettings.getAsInt(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0);\n+\n+\n+            //create index service for parsing and validating \"mappings\"\n+            Settings dummySettings = Settings.builder()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc4NjIxMA=="}, "originalCommit": {"oid": "b393e30af04a06fa08eff0ad21f43dca603af2e6"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNDUyMjIzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexTemplateService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOTowNTo1MFrOGfmezw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwMzo0MToxMlrOGgOYwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc4OTUxOQ==", "bodyText": "would using indicesService.withTempIndexService be better as it avoids adding.removing the index from the IndexService and also handles closing the indexService? (we're using this in TransportSimulateIndexTemplateAction)", "url": "https://github.com/elastic/elasticsearch/pull/57701#discussion_r435789519", "createdAt": "2020-06-05T09:05:50Z", "author": {"login": "andreidan"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexTemplateService.java", "diffHunk": "@@ -910,6 +951,77 @@ private static Settings resolveSettings(Metadata metadata, ComposableIndexTempla\n         return Collections.unmodifiableList(aliases);\n     }\n \n+    /**\n+     * Given a state and a composable template, validate that the final composite template\n+     * generated by the composable template and all of its component templates contains valid\n+     * settings, mappings, and aliases.\n+     */\n+    private static void validateCompositeTemplate(final ClusterState state,\n+                                                  final String templateName,\n+                                                  final ComposableIndexTemplate template,\n+                                                  final IndicesService indicesService,\n+                                                  final NamedXContentRegistry xContentRegistry) throws Exception {\n+        final ClusterState stateWithTemplate = ClusterState.builder(state)\n+            .metadata(Metadata.builder(state.metadata()).put(templateName, template))\n+            .build();\n+\n+        Index createdIndex = null;\n+        final String temporaryIndexName = \"validate-template-\" + UUIDs.randomBase64UUID().toLowerCase(Locale.ROOT);\n+        try {\n+            Settings resolvedSettings = resolveSettings(stateWithTemplate.metadata(), templateName);\n+\n+            // use the provided values, otherwise just pick valid dummy values\n+            int dummyPartitionSize = IndexMetadata.INDEX_ROUTING_PARTITION_SIZE_SETTING.get(resolvedSettings);\n+            int dummyShards = resolvedSettings.getAsInt(IndexMetadata.SETTING_NUMBER_OF_SHARDS,\n+                dummyPartitionSize == 1 ? 1 : dummyPartitionSize + 1);\n+            int shardReplicas = resolvedSettings.getAsInt(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0);\n+\n+\n+            //create index service for parsing and validating \"mappings\"\n+            Settings dummySettings = Settings.builder()\n+                .put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT)\n+                .put(resolvedSettings)\n+                .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, dummyShards)\n+                .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, shardReplicas)\n+                .put(IndexMetadata.SETTING_INDEX_UUID, UUIDs.randomBase64UUID())\n+                .build();\n+\n+            // Validate index metadata (settings)\n+            final ClusterState stateWithIndex = ClusterState.builder(stateWithTemplate)\n+                .metadata(Metadata.builder(stateWithTemplate.metadata())\n+                    .put(IndexMetadata.builder(temporaryIndexName).settings(dummySettings))\n+                    .build())\n+                .build();\n+            final IndexMetadata tmpIndexMetadata = stateWithIndex.metadata().index(temporaryIndexName);\n+            IndexService dummyIndexService = indicesService.createIndex(tmpIndexMetadata, Collections.emptyList(), false);\n+            createdIndex = dummyIndexService.index();\n+\n+            // Validate aliases\n+            MetadataCreateIndexService.resolveAndValidateAliases(temporaryIndexName, Collections.emptySet(),\n+                MetadataIndexTemplateService.resolveAliases(stateWithIndex.metadata(), templateName), stateWithIndex.metadata(),\n+                new AliasValidator(),\n+                // the context is only used for validation so it's fine to pass fake values for the\n+                // shard id and the current timestamp\n+                xContentRegistry, dummyIndexService.newQueryShardContext(0, null, () -> 0L, null));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b393e30af04a06fa08eff0ad21f43dca603af2e6"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0MzMzMA==", "bodyText": "Yes absolutely, I'll change this", "url": "https://github.com/elastic/elasticsearch/pull/57701#discussion_r436443330", "createdAt": "2020-06-08T03:41:12Z", "author": {"login": "dakrone"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexTemplateService.java", "diffHunk": "@@ -910,6 +951,77 @@ private static Settings resolveSettings(Metadata metadata, ComposableIndexTempla\n         return Collections.unmodifiableList(aliases);\n     }\n \n+    /**\n+     * Given a state and a composable template, validate that the final composite template\n+     * generated by the composable template and all of its component templates contains valid\n+     * settings, mappings, and aliases.\n+     */\n+    private static void validateCompositeTemplate(final ClusterState state,\n+                                                  final String templateName,\n+                                                  final ComposableIndexTemplate template,\n+                                                  final IndicesService indicesService,\n+                                                  final NamedXContentRegistry xContentRegistry) throws Exception {\n+        final ClusterState stateWithTemplate = ClusterState.builder(state)\n+            .metadata(Metadata.builder(state.metadata()).put(templateName, template))\n+            .build();\n+\n+        Index createdIndex = null;\n+        final String temporaryIndexName = \"validate-template-\" + UUIDs.randomBase64UUID().toLowerCase(Locale.ROOT);\n+        try {\n+            Settings resolvedSettings = resolveSettings(stateWithTemplate.metadata(), templateName);\n+\n+            // use the provided values, otherwise just pick valid dummy values\n+            int dummyPartitionSize = IndexMetadata.INDEX_ROUTING_PARTITION_SIZE_SETTING.get(resolvedSettings);\n+            int dummyShards = resolvedSettings.getAsInt(IndexMetadata.SETTING_NUMBER_OF_SHARDS,\n+                dummyPartitionSize == 1 ? 1 : dummyPartitionSize + 1);\n+            int shardReplicas = resolvedSettings.getAsInt(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0);\n+\n+\n+            //create index service for parsing and validating \"mappings\"\n+            Settings dummySettings = Settings.builder()\n+                .put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT)\n+                .put(resolvedSettings)\n+                .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, dummyShards)\n+                .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, shardReplicas)\n+                .put(IndexMetadata.SETTING_INDEX_UUID, UUIDs.randomBase64UUID())\n+                .build();\n+\n+            // Validate index metadata (settings)\n+            final ClusterState stateWithIndex = ClusterState.builder(stateWithTemplate)\n+                .metadata(Metadata.builder(stateWithTemplate.metadata())\n+                    .put(IndexMetadata.builder(temporaryIndexName).settings(dummySettings))\n+                    .build())\n+                .build();\n+            final IndexMetadata tmpIndexMetadata = stateWithIndex.metadata().index(temporaryIndexName);\n+            IndexService dummyIndexService = indicesService.createIndex(tmpIndexMetadata, Collections.emptyList(), false);\n+            createdIndex = dummyIndexService.index();\n+\n+            // Validate aliases\n+            MetadataCreateIndexService.resolveAndValidateAliases(temporaryIndexName, Collections.emptySet(),\n+                MetadataIndexTemplateService.resolveAliases(stateWithIndex.metadata(), templateName), stateWithIndex.metadata(),\n+                new AliasValidator(),\n+                // the context is only used for validation so it's fine to pass fake values for the\n+                // shard id and the current timestamp\n+                xContentRegistry, dummyIndexService.newQueryShardContext(0, null, () -> 0L, null));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc4OTUxOQ=="}, "originalCommit": {"oid": "b393e30af04a06fa08eff0ad21f43dca603af2e6"}, "originalPosition": 147}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNDU3MTg4OnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/elasticsearch/cluster/metadata/MetadataIndexTemplateServiceTests.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOToyMDoyMVrOGfm-DQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOToyMDoyMVrOGfm-DQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc5NzUxNw==", "bodyText": "this and the next test names are rather confusing to me. It's quite difficult to pick up what they are testing and what's the invalid case. (maybe related to the previous comment too, but  \"composable composite\" adds to the confusion for me)\nwhat do you think of including the cause of failure in the test name?\nWhat do you think of something along the lines of  testIndexTemplateFailsToOverrideComponentTemplateMappingField and respectively testUpdateComponentTemplateFailsIfResolvedIndexTemplatesWouldBeInvalid ?", "url": "https://github.com/elastic/elasticsearch/pull/57701#discussion_r435797517", "createdAt": "2020-06-05T09:20:21Z", "author": {"login": "andreidan"}, "path": "server/src/test/java/org/elasticsearch/cluster/metadata/MetadataIndexTemplateServiceTests.java", "diffHunk": "@@ -859,6 +919,119 @@ public void testRemoveComponentTemplateInUse() throws Exception {\n             containsString(\"component templates [ct] cannot be removed as they are still in use by index templates [template]\"));\n     }\n \n+    /**\n+     * Tests that we check that settings/mappings/etc are valid even after template composition,\n+     * when adding/updating a composable index template\n+     */\n+    public void testInvalidComposableCompositeTemplate() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b393e30af04a06fa08eff0ad21f43dca603af2e6"}, "originalPosition": 91}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3701, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}