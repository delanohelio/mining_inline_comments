{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE2ODg2ODky", "number": 56631, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxOTozMzowNVrOD7y6gA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMDoxNzowNlrOD7z2Dw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MDI2NzUyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/plugin/EqlPlugin.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxOTozMzowNVrOGUV2UQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMDo1NDowNVrOGUYj8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk4MjY3Mw==", "bodyText": "We should share this in core next to AsyncTaskMaintenanceService ?\nI also wonder who should be responsible to start the AsyncTaskMaintenanceService since we don't need to start it twice ?", "url": "https://github.com/elastic/elasticsearch/pull/56631#discussion_r423982673", "createdAt": "2020-05-12T19:33:05Z", "author": {"login": "jimczi"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/plugin/EqlPlugin.java", "diffHunk": "@@ -46,6 +46,8 @@\n import java.util.function.Supplier;\n \n public class EqlPlugin extends Plugin implements ActionPlugin {\n+    // We are going to reuse the same index as normal async search until system indices are implemented\n+    public static final String INDEX = \".async-search\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b770022914d5e8226f635002cc66f098c526cc2d"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAyNzEyMA==", "bodyText": "Yes. Good point. Let's deal with it in the next PR when I start moving stuff around.", "url": "https://github.com/elastic/elasticsearch/pull/56631#discussion_r424027120", "createdAt": "2020-05-12T20:54:05Z", "author": {"login": "imotov"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/plugin/EqlPlugin.java", "diffHunk": "@@ -46,6 +46,8 @@\n import java.util.function.Supplier;\n \n public class EqlPlugin extends Plugin implements ActionPlugin {\n+    // We are going to reuse the same index as normal async search until system indices are implemented\n+    public static final String INDEX = \".async-search\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk4MjY3Mw=="}, "originalCommit": {"oid": "b770022914d5e8226f635002cc66f098c526cc2d"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MDI3MzU3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/plugin/RestEqlSearchAction.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxOTozNDoxN1rOGUV6Kw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxMjoyMjo1M1rOGUu8HQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk4MzY1OQ==", "bodyText": "You should use RestCancellableNodeClient in order to get the automatic cancellation if the user closes the rest channel ?", "url": "https://github.com/elastic/elasticsearch/pull/56631#discussion_r423983659", "createdAt": "2020-05-12T19:34:17Z", "author": {"login": "jimczi"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/plugin/RestEqlSearchAction.java", "diffHunk": "@@ -46,6 +46,14 @@ protected RestChannelConsumer prepareRequest(RestRequest request, NodeClient cli\n             eqlRequest = EqlSearchRequest.fromXContent(parser);\n             eqlRequest.indices(Strings.splitStringByCommaToArray(request.param(\"index\")));\n             eqlRequest.indicesOptions(IndicesOptions.fromRequest(request, eqlRequest.indicesOptions()));\n+            if (request.hasParam(\"wait_for_completion_timeout\")) {\n+                eqlRequest.waitForCompletionTimeout(\n+                    request.paramAsTime(\"wait_for_completion_timeout\", eqlRequest.waitForCompletionTimeout()));\n+            }\n+            if (request.hasParam(\"keep_alive\")) {\n+                eqlRequest.keepAlive(request.paramAsTime(\"keep_alive\", eqlRequest.keepAlive()));\n+            }\n+            eqlRequest.keepOnCompletion(request.paramAsBoolean(\"keep_on_completion\", eqlRequest.keepOnCompletion()));\n         }\n \n         return channel -> client.execute(EqlSearchAction.INSTANCE, eqlRequest, new RestResponseListener<>(channel) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b770022914d5e8226f635002cc66f098c526cc2d"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAyODY0NA==", "bodyText": "Good catch. I am going to open PR against master for that in a bit since it's not async execution-specific.", "url": "https://github.com/elastic/elasticsearch/pull/56631#discussion_r424028644", "createdAt": "2020-05-12T20:56:50Z", "author": {"login": "imotov"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/plugin/RestEqlSearchAction.java", "diffHunk": "@@ -46,6 +46,14 @@ protected RestChannelConsumer prepareRequest(RestRequest request, NodeClient cli\n             eqlRequest = EqlSearchRequest.fromXContent(parser);\n             eqlRequest.indices(Strings.splitStringByCommaToArray(request.param(\"index\")));\n             eqlRequest.indicesOptions(IndicesOptions.fromRequest(request, eqlRequest.indicesOptions()));\n+            if (request.hasParam(\"wait_for_completion_timeout\")) {\n+                eqlRequest.waitForCompletionTimeout(\n+                    request.paramAsTime(\"wait_for_completion_timeout\", eqlRequest.waitForCompletionTimeout()));\n+            }\n+            if (request.hasParam(\"keep_alive\")) {\n+                eqlRequest.keepAlive(request.paramAsTime(\"keep_alive\", eqlRequest.keepAlive()));\n+            }\n+            eqlRequest.keepOnCompletion(request.paramAsBoolean(\"keep_on_completion\", eqlRequest.keepOnCompletion()));\n         }\n \n         return channel -> client.execute(EqlSearchAction.INSTANCE, eqlRequest, new RestResponseListener<>(channel) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk4MzY1OQ=="}, "originalCommit": {"oid": "b770022914d5e8226f635002cc66f098c526cc2d"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM5Mzc1Nw==", "bodyText": "Hmm, I need AbstractEqlBlockingIntegTestCase to do IT testing for it and it only exists in this branch for now. So, I think I will open a separate PR but against this branch.", "url": "https://github.com/elastic/elasticsearch/pull/56631#discussion_r424393757", "createdAt": "2020-05-13T12:22:53Z", "author": {"login": "imotov"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/plugin/RestEqlSearchAction.java", "diffHunk": "@@ -46,6 +46,14 @@ protected RestChannelConsumer prepareRequest(RestRequest request, NodeClient cli\n             eqlRequest = EqlSearchRequest.fromXContent(parser);\n             eqlRequest.indices(Strings.splitStringByCommaToArray(request.param(\"index\")));\n             eqlRequest.indicesOptions(IndicesOptions.fromRequest(request, eqlRequest.indicesOptions()));\n+            if (request.hasParam(\"wait_for_completion_timeout\")) {\n+                eqlRequest.waitForCompletionTimeout(\n+                    request.paramAsTime(\"wait_for_completion_timeout\", eqlRequest.waitForCompletionTimeout()));\n+            }\n+            if (request.hasParam(\"keep_alive\")) {\n+                eqlRequest.keepAlive(request.paramAsTime(\"keep_alive\", eqlRequest.keepAlive()));\n+            }\n+            eqlRequest.keepOnCompletion(request.paramAsBoolean(\"keep_on_completion\", eqlRequest.keepOnCompletion()));\n         }\n \n         return channel -> client.execute(EqlSearchAction.INSTANCE, eqlRequest, new RestResponseListener<>(channel) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk4MzY1OQ=="}, "originalCommit": {"oid": "b770022914d5e8226f635002cc66f098c526cc2d"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MDQxOTk5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/plugin/TransportEqlSearchAction.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMDoxNzowNlrOGUXWow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMTowNTo0N1rOGUY8WA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAwNzMzMQ==", "bodyText": "PlanExecutor already has a Client and NamedWriteableRegistry injected - unless they are different, you could get them from there.", "url": "https://github.com/elastic/elasticsearch/pull/56631#discussion_r424007331", "createdAt": "2020-05-12T20:17:06Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/plugin/TransportEqlSearchAction.java", "diffHunk": "@@ -29,32 +34,72 @@\n import org.elasticsearch.xpack.eql.session.EqlConfiguration;\n import org.elasticsearch.xpack.eql.session.Results;\n \n+import java.io.IOException;\n import java.time.ZoneId;\n+import java.util.Map;\n \n import static org.elasticsearch.action.ActionListener.wrap;\n+import static org.elasticsearch.xpack.core.ClientHelper.ASYNC_SEARCH_ORIGIN;\n+\n+public class TransportEqlSearchAction extends HandledTransportAction<EqlSearchRequest, EqlSearchResponse>\n+    implements AsyncTaskManagementService.AsyncOperation<EqlSearchRequest, EqlSearchResponse, EqlSearchTask> {\n \n-public class TransportEqlSearchAction extends HandledTransportAction<EqlSearchRequest, EqlSearchResponse> {\n     private final SecurityContext securityContext;\n     private final ClusterService clusterService;\n     private final PlanExecutor planExecutor;\n+    private final ThreadPool threadPool;\n+    private final AsyncTaskManagementService<EqlSearchRequest, EqlSearchResponse, EqlSearchTask> asyncTaskManagementService;\n \n     @Inject\n     public TransportEqlSearchAction(Settings settings, ClusterService clusterService, TransportService transportService,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b770022914d5e8226f635002cc66f098c526cc2d"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAzMzM2OA==", "bodyText": "They are the same, I just feel like having client as an explicit dependency is a bit cleaner. Otherwise, I would need to reach into PlanExecutor and possibly mock PlanExecutor in AsyncTaskManagementServiceTests. I also don't feel like providing access to client and writableRegistry shouldn't be a PlainExecutor's concern. Especially considering that writableRegistry is not even used by PlainExecutor at the moment.", "url": "https://github.com/elastic/elasticsearch/pull/56631#discussion_r424033368", "createdAt": "2020-05-12T21:05:47Z", "author": {"login": "imotov"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/plugin/TransportEqlSearchAction.java", "diffHunk": "@@ -29,32 +34,72 @@\n import org.elasticsearch.xpack.eql.session.EqlConfiguration;\n import org.elasticsearch.xpack.eql.session.Results;\n \n+import java.io.IOException;\n import java.time.ZoneId;\n+import java.util.Map;\n \n import static org.elasticsearch.action.ActionListener.wrap;\n+import static org.elasticsearch.xpack.core.ClientHelper.ASYNC_SEARCH_ORIGIN;\n+\n+public class TransportEqlSearchAction extends HandledTransportAction<EqlSearchRequest, EqlSearchResponse>\n+    implements AsyncTaskManagementService.AsyncOperation<EqlSearchRequest, EqlSearchResponse, EqlSearchTask> {\n \n-public class TransportEqlSearchAction extends HandledTransportAction<EqlSearchRequest, EqlSearchResponse> {\n     private final SecurityContext securityContext;\n     private final ClusterService clusterService;\n     private final PlanExecutor planExecutor;\n+    private final ThreadPool threadPool;\n+    private final AsyncTaskManagementService<EqlSearchRequest, EqlSearchResponse, EqlSearchTask> asyncTaskManagementService;\n \n     @Inject\n     public TransportEqlSearchAction(Settings settings, ClusterService clusterService, TransportService transportService,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAwNzMzMQ=="}, "originalCommit": {"oid": "b770022914d5e8226f635002cc66f098c526cc2d"}, "originalPosition": 43}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 470, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}