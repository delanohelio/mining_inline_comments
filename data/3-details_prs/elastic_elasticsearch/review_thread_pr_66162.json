{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM1ODk1MjU3", "number": 66162, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxMjoyNDozNlrOFDc2lQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxMzoxMzoyNlrOFDeHuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MTYyNzczOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/SearchableSnapshots.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxMjoyNDozNlrOIDGutg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxMjoyNDozNlrOIDGutg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDEyNjkwMg==", "bodyText": "Oops, this will almost always work except for cases where we add another character to the encoded generation (think \"1\" < \"10\" < \"2\"). I'll address this.", "url": "https://github.com/elastic/elasticsearch/pull/66162#discussion_r540126902", "createdAt": "2020-12-10T12:24:36Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/SearchableSnapshots.java", "diffHunk": "@@ -271,7 +282,32 @@ public void onIndexModule(IndexModule indexModule) {\n         if (SearchableSnapshotsConstants.isSearchableSnapshotStore(indexSettings.getSettings())\n             && indexSettings.getSettings().getAsBoolean(\"index.frozen\", false) == false) {\n             return Optional.of(\n-                engineConfig -> new ReadOnlyEngine(engineConfig, null, new TranslogStats(), false, Function.identity(), false)\n+                engineConfig -> new ReadOnlyEngine(engineConfig, null, new TranslogStats(), false, Function.identity(), false) {\n+\n+                    // present an empty IndexCommit to the snapshot mechanism so that we copy no shard data to the repository\n+                    private final IndexCommit emptyIndexCommit;\n+\n+                    {\n+                        try {\n+                            final Directory directory = engineConfig.getStore().directory();\n+                            final String oldestSegmentsFile = Arrays.stream(directory.listAll())\n+                                .filter(s -> s.startsWith(IndexFileNames.SEGMENTS + \"_\"))\n+                                .min(Comparator.naturalOrder())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afbf6fda5a499887f5c2c6215df3d6dd88916a3c"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MTY0MDg0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/snapshots/blobstore/SnapshotFiles.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxMjoyNzozMVrOIDG2Rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxMzowNjoxMFrOIDIUoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDEyODgzOA==", "bodyText": "Can we add shardStateIdentifier here while we're at it ? :) (also .toString() isn't necessary?", "url": "https://github.com/elastic/elasticsearch/pull/66162#discussion_r540128838", "createdAt": "2020-12-10T12:27:31Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/index/snapshots/blobstore/SnapshotFiles.java", "diffHunk": "@@ -128,4 +128,8 @@ private FileInfo findPhysicalIndexFile(String physicalName) {\n         return physicalFiles.get(physicalName);\n     }\n \n+    @Override\n+    public String toString() {\n+        return \"SnapshotFiles{\" + indexFiles.toString() + \"}\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afbf6fda5a499887f5c2c6215df3d6dd88916a3c"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE1Mjk5Mw==", "bodyText": "yep, see 63383c7", "url": "https://github.com/elastic/elasticsearch/pull/66162#discussion_r540152993", "createdAt": "2020-12-10T13:06:10Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/index/snapshots/blobstore/SnapshotFiles.java", "diffHunk": "@@ -128,4 +128,8 @@ private FileInfo findPhysicalIndexFile(String physicalName) {\n         return physicalFiles.get(physicalName);\n     }\n \n+    @Override\n+    public String toString() {\n+        return \"SnapshotFiles{\" + indexFiles.toString() + \"}\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDEyODgzOA=="}, "originalCommit": {"oid": "afbf6fda5a499887f5c2c6215df3d6dd88916a3c"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MTY1MzA3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/InMemoryNoOpCommitDirectory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxMjozMDozMVrOIDG9WQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxMzowNzo1MFrOIDIZEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDEzMDY0OQ==", "bodyText": "NIT: drop empty line", "url": "https://github.com/elastic/elasticsearch/pull/66162#discussion_r540130649", "createdAt": "2020-12-10T12:30:31Z", "author": {"login": "original-brownbear"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/InMemoryNoOpCommitDirectory.java", "diffHunk": "@@ -119,7 +119,8 @@ private static void ensureMutable(String name) {\n             || name.startsWith(\"pending_segments_\")\n             || name.matches(\"^recovery\\\\..*\\\\.segments_.*$\")) == false) {\n \n-            throw new IllegalArgumentException(\"file [\" + name + \"] is not mutable\");\n+            throw new ImmutableDirectoryException(\"file [\" + name + \"] is not mutable\");\n         }\n     }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afbf6fda5a499887f5c2c6215df3d6dd88916a3c"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE1NDEzMQ==", "bodyText": "I prefer to have a blank line here, it simplifies merge conflicts when two commits add members to the bottom of a class.", "url": "https://github.com/elastic/elasticsearch/pull/66162#discussion_r540154131", "createdAt": "2020-12-10T13:07:50Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/InMemoryNoOpCommitDirectory.java", "diffHunk": "@@ -119,7 +119,8 @@ private static void ensureMutable(String name) {\n             || name.startsWith(\"pending_segments_\")\n             || name.matches(\"^recovery\\\\..*\\\\.segments_.*$\")) == false) {\n \n-            throw new IllegalArgumentException(\"file [\" + name + \"] is not mutable\");\n+            throw new ImmutableDirectoryException(\"file [\" + name + \"] is not mutable\");\n         }\n     }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDEzMDY0OQ=="}, "originalCommit": {"oid": "afbf6fda5a499887f5c2c6215df3d6dd88916a3c"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MTcwMzk0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/SearchableSnapshots.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxMjo0MjozMlrOIDHaWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxMzowODoyM1rOIDIaPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDEzODA3NQ==", "bodyText": "Just for my own learning probably, but why do we need this? Can't we just always use generation 0? Probably not :) => can we add a comment with why we need this?", "url": "https://github.com/elastic/elasticsearch/pull/66162#discussion_r540138075", "createdAt": "2020-12-10T12:42:32Z", "author": {"login": "original-brownbear"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/SearchableSnapshots.java", "diffHunk": "@@ -271,7 +282,32 @@ public void onIndexModule(IndexModule indexModule) {\n         if (SearchableSnapshotsConstants.isSearchableSnapshotStore(indexSettings.getSettings())\n             && indexSettings.getSettings().getAsBoolean(\"index.frozen\", false) == false) {\n             return Optional.of(\n-                engineConfig -> new ReadOnlyEngine(engineConfig, null, new TranslogStats(), false, Function.identity(), false)\n+                engineConfig -> new ReadOnlyEngine(engineConfig, null, new TranslogStats(), false, Function.identity(), false) {\n+\n+                    // present an empty IndexCommit to the snapshot mechanism so that we copy no shard data to the repository\n+                    private final IndexCommit emptyIndexCommit;\n+\n+                    {\n+                        try {\n+                            final Directory directory = engineConfig.getStore().directory();\n+                            final String oldestSegmentsFile = Arrays.stream(directory.listAll())\n+                                .filter(s -> s.startsWith(IndexFileNames.SEGMENTS + \"_\"))\n+                                .min(Comparator.naturalOrder())\n+                                .orElseThrow(() -> new IOException(\"segments_N file not found\"));\n+                            final SegmentInfos segmentInfos = new SegmentInfos(Version.LATEST.major);\n+                            segmentInfos.updateGeneration(SegmentInfos.readCommit(directory, oldestSegmentsFile));\n+                            emptyIndexCommit = Lucene.getIndexCommit(segmentInfos, directory);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afbf6fda5a499887f5c2c6215df3d6dd88916a3c"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE1NDQyOQ==", "bodyText": "It's a good question and what I spent most of my time on TBH, I added a comment above.", "url": "https://github.com/elastic/elasticsearch/pull/66162#discussion_r540154429", "createdAt": "2020-12-10T13:08:23Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/SearchableSnapshots.java", "diffHunk": "@@ -271,7 +282,32 @@ public void onIndexModule(IndexModule indexModule) {\n         if (SearchableSnapshotsConstants.isSearchableSnapshotStore(indexSettings.getSettings())\n             && indexSettings.getSettings().getAsBoolean(\"index.frozen\", false) == false) {\n             return Optional.of(\n-                engineConfig -> new ReadOnlyEngine(engineConfig, null, new TranslogStats(), false, Function.identity(), false)\n+                engineConfig -> new ReadOnlyEngine(engineConfig, null, new TranslogStats(), false, Function.identity(), false) {\n+\n+                    // present an empty IndexCommit to the snapshot mechanism so that we copy no shard data to the repository\n+                    private final IndexCommit emptyIndexCommit;\n+\n+                    {\n+                        try {\n+                            final Directory directory = engineConfig.getStore().directory();\n+                            final String oldestSegmentsFile = Arrays.stream(directory.listAll())\n+                                .filter(s -> s.startsWith(IndexFileNames.SEGMENTS + \"_\"))\n+                                .min(Comparator.naturalOrder())\n+                                .orElseThrow(() -> new IOException(\"segments_N file not found\"));\n+                            final SegmentInfos segmentInfos = new SegmentInfos(Version.LATEST.major);\n+                            segmentInfos.updateGeneration(SegmentInfos.readCommit(directory, oldestSegmentsFile));\n+                            emptyIndexCommit = Lucene.getIndexCommit(segmentInfos, directory);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDEzODA3NQ=="}, "originalCommit": {"oid": "afbf6fda5a499887f5c2c6215df3d6dd88916a3c"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MTgzMDI2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/repositories/blobstore/FileRestoreContext.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxMzoxMjoyMFrOIDIj4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxMzoyNToyN1rOIDJHDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE1Njg5OQ==", "bodyText": "Could we instead up front check that the directory is \"immutable\" and skip the restore completely? Would feel slightly less hackish to me... Might have to look into a chain of FilterDirectories to see if any are immutable.", "url": "https://github.com/elastic/elasticsearch/pull/66162#discussion_r540156899", "createdAt": "2020-12-10T13:12:20Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/repositories/blobstore/FileRestoreContext.java", "diffHunk": "@@ -190,6 +191,10 @@ private void afterRestore(SnapshotFiles snapshotFiles, Store store, StoreFileMet\n                 try {\n                     store.deleteQuiet(\"restore\", storeFile);\n                     store.directory().deleteFile(storeFile);\n+                } catch (ImmutableDirectoryException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63383c77547a0760a274d83ab026dd62eb6fffc9"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE2NTkwMQ==", "bodyText": "It's possible but uglier IMO. We can't add a method to Directory itself to check that since Lucene owns it, so we'd have to add a marker interface and use instanceof.", "url": "https://github.com/elastic/elasticsearch/pull/66162#discussion_r540165901", "createdAt": "2020-12-10T13:25:27Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/repositories/blobstore/FileRestoreContext.java", "diffHunk": "@@ -190,6 +191,10 @@ private void afterRestore(SnapshotFiles snapshotFiles, Store store, StoreFileMet\n                 try {\n                     store.deleteQuiet(\"restore\", storeFile);\n                     store.directory().deleteFile(storeFile);\n+                } catch (ImmutableDirectoryException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE1Njg5OQ=="}, "originalCommit": {"oid": "63383c77547a0760a274d83ab026dd62eb6fffc9"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MTgzNTQ0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/SearchableSnapshots.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxMzoxMzoyNlrOIDIm4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxNDowOTo1OFrOIDLDoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE1NzY2NQ==", "bodyText": "If we can skip the restore completely (see previous comment), could we then instead return null here and also skip the snapshotting completely?", "url": "https://github.com/elastic/elasticsearch/pull/66162#discussion_r540157665", "createdAt": "2020-12-10T13:13:26Z", "author": {"login": "henningandersen"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/SearchableSnapshots.java", "diffHunk": "@@ -266,12 +277,45 @@ public void onIndexModule(IndexModule indexModule) {\n         });\n     }\n \n+    static final Comparator<String> SEGMENT_FILENAME_COMPARATOR = Comparator.comparingLong(SegmentInfos::generationFromSegmentsFileName);\n+\n     @Override\n     public Optional<EngineFactory> getEngineFactory(IndexSettings indexSettings) {\n         if (SearchableSnapshotsConstants.isSearchableSnapshotStore(indexSettings.getSettings())\n             && indexSettings.getSettings().getAsBoolean(\"index.frozen\", false) == false) {\n             return Optional.of(\n-                engineConfig -> new ReadOnlyEngine(engineConfig, null, new TranslogStats(), false, Function.identity(), false)\n+                engineConfig -> new ReadOnlyEngine(engineConfig, null, new TranslogStats(), false, Function.identity(), false) {\n+\n+                    // present an empty IndexCommit to the snapshot mechanism so that we copy no shard data to the repository\n+                    private final IndexCommit emptyIndexCommit;\n+\n+                    {\n+                        try {\n+                            // We have to use a generation number that corresponds to a real segments_N file since we read this file from\n+                            // the directory during the snapshotting process. The oldest segments_N file is the one in the snapshot\n+                            // (recalling that we may perform some no-op commits which make newer segments_N files too). The good thing\n+                            // about using the oldest segments_N file is that a restore will find that we already have this file \"locally\",\n+                            // avoid overwriting the real one with the bogus one, and then use the real one for the rest of the recovery.\n+\n+                            final Directory directory = engineConfig.getStore().directory();\n+                            final String oldestSegmentsFile = Arrays.stream(directory.listAll())\n+                                .filter(s -> s.startsWith(IndexFileNames.SEGMENTS + \"_\"))\n+                                .min(SEGMENT_FILENAME_COMPARATOR)\n+                                .orElseThrow(() -> new IOException(\"segments_N file not found\"));\n+                            final SegmentInfos segmentInfos = new SegmentInfos(Version.LATEST.major);\n+                            segmentInfos.updateGeneration(SegmentInfos.readCommit(directory, oldestSegmentsFile));\n+                            emptyIndexCommit = Lucene.getIndexCommit(segmentInfos, directory);\n+                        } catch (IOException e) {\n+                            throw new UncheckedIOException(e);\n+                        }\n+                    }\n+\n+                    @Override\n+                    public IndexCommitRef acquireIndexCommitForSnapshot() throws EngineException {\n+                        store.incRef();\n+                        return new IndexCommitRef(emptyIndexCommit, store::decRef);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63383c77547a0760a274d83ab026dd62eb6fffc9"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE5Nzc5Mg==", "bodyText": "Not trivially, no, we want the snapshot of this shard to succeed (without having done much) so we can't just bail out, and we use a null commit to indicate \"find the latest commit\" further down the line.", "url": "https://github.com/elastic/elasticsearch/pull/66162#discussion_r540197792", "createdAt": "2020-12-10T14:09:58Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/SearchableSnapshots.java", "diffHunk": "@@ -266,12 +277,45 @@ public void onIndexModule(IndexModule indexModule) {\n         });\n     }\n \n+    static final Comparator<String> SEGMENT_FILENAME_COMPARATOR = Comparator.comparingLong(SegmentInfos::generationFromSegmentsFileName);\n+\n     @Override\n     public Optional<EngineFactory> getEngineFactory(IndexSettings indexSettings) {\n         if (SearchableSnapshotsConstants.isSearchableSnapshotStore(indexSettings.getSettings())\n             && indexSettings.getSettings().getAsBoolean(\"index.frozen\", false) == false) {\n             return Optional.of(\n-                engineConfig -> new ReadOnlyEngine(engineConfig, null, new TranslogStats(), false, Function.identity(), false)\n+                engineConfig -> new ReadOnlyEngine(engineConfig, null, new TranslogStats(), false, Function.identity(), false) {\n+\n+                    // present an empty IndexCommit to the snapshot mechanism so that we copy no shard data to the repository\n+                    private final IndexCommit emptyIndexCommit;\n+\n+                    {\n+                        try {\n+                            // We have to use a generation number that corresponds to a real segments_N file since we read this file from\n+                            // the directory during the snapshotting process. The oldest segments_N file is the one in the snapshot\n+                            // (recalling that we may perform some no-op commits which make newer segments_N files too). The good thing\n+                            // about using the oldest segments_N file is that a restore will find that we already have this file \"locally\",\n+                            // avoid overwriting the real one with the bogus one, and then use the real one for the rest of the recovery.\n+\n+                            final Directory directory = engineConfig.getStore().directory();\n+                            final String oldestSegmentsFile = Arrays.stream(directory.listAll())\n+                                .filter(s -> s.startsWith(IndexFileNames.SEGMENTS + \"_\"))\n+                                .min(SEGMENT_FILENAME_COMPARATOR)\n+                                .orElseThrow(() -> new IOException(\"segments_N file not found\"));\n+                            final SegmentInfos segmentInfos = new SegmentInfos(Version.LATEST.major);\n+                            segmentInfos.updateGeneration(SegmentInfos.readCommit(directory, oldestSegmentsFile));\n+                            emptyIndexCommit = Lucene.getIndexCommit(segmentInfos, directory);\n+                        } catch (IOException e) {\n+                            throw new UncheckedIOException(e);\n+                        }\n+                    }\n+\n+                    @Override\n+                    public IndexCommitRef acquireIndexCommitForSnapshot() throws EngineException {\n+                        store.incRef();\n+                        return new IndexCommitRef(emptyIndexCommit, store::decRef);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE1NzY2NQ=="}, "originalCommit": {"oid": "63383c77547a0760a274d83ab026dd62eb6fffc9"}, "originalPosition": 84}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4728, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}