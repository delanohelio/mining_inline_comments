{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAyOTU3MTY0", "number": 63644, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQwOTowMDo0MlrOEtYw0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQwOTowMjoyM1rOEtYzqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2MDI3MDg5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/qa/correctness/src/javaRestTest/java/org/elasticsearch/xpack/eql/EsEQLCorrectnessIT.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQwOTowMDo0MlrOHhJRvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQwOToyMDowMFrOHhKBVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDUxNzA1Mg==", "bodyText": "These can be externalized into a properties file.\nThe \"matriv-gcs\" should be changed to something more generic.", "url": "https://github.com/elastic/elasticsearch/pull/63644#discussion_r504517052", "createdAt": "2020-10-14T09:00:42Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/qa/correctness/src/javaRestTest/java/org/elasticsearch/xpack/eql/EsEQLCorrectnessIT.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.annotations.TimeoutSuite;\n+import org.apache.http.HttpHost;\n+import org.apache.lucene.util.TimeUnits;\n+import org.elasticsearch.action.admin.cluster.repositories.put.PutRepositoryRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotRequest;\n+import org.elasticsearch.client.HttpAsyncResponseConsumerFactory;\n+import org.elasticsearch.client.Request;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.client.ResponseException;\n+import org.elasticsearch.client.RestClient;\n+import org.elasticsearch.client.RestClientBuilder;\n+import org.elasticsearch.client.RestHighLevelClient;\n+import org.elasticsearch.client.eql.EqlSearchRequest;\n+import org.elasticsearch.client.eql.EqlSearchResponse;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.test.rest.ESRestTestCase;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.elasticsearch.xpack.ql.TestUtils.assertNoSearchContexts;\n+\n+@TimeoutSuite(millis = 60 * TimeUnits.MINUTE)\n+public class EsEQLCorrectnessIT extends ESRestTestCase {\n+\n+    private static final String PARAM_FORMATTING = \"%1$s\";\n+    private static final String QUERIES_FILENAME = \"queries.toml\";\n+    private static final String INDEX_NAME = \"mitre\";\n+    private static final int FETCH_SIZE = 10000;\n+    private static final String GCS_REPO_NAME = \"eql_correctness_gcs_repo\";\n+    private static final String SNAPSHOT_NAME = \"mitre-snapshot\";\n+    private static final String GCS_BUCKET_NAME = \"matriv-gcs\";\n+    private static final String GCS_BASE_PATH = \"mitre-data\";\n+    private static final String GCS_CLIENT_NAME = \"eql_test\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75a827feb13d29422d5e09a991a18e780892d8e8"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDUyOTIzOQ==", "bodyText": "I'd be meaning to do it, but let's get this in as is, and I will rename the bucket soon.", "url": "https://github.com/elastic/elasticsearch/pull/63644#discussion_r504529239", "createdAt": "2020-10-14T09:20:00Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/eql/qa/correctness/src/javaRestTest/java/org/elasticsearch/xpack/eql/EsEQLCorrectnessIT.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.annotations.TimeoutSuite;\n+import org.apache.http.HttpHost;\n+import org.apache.lucene.util.TimeUnits;\n+import org.elasticsearch.action.admin.cluster.repositories.put.PutRepositoryRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotRequest;\n+import org.elasticsearch.client.HttpAsyncResponseConsumerFactory;\n+import org.elasticsearch.client.Request;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.client.ResponseException;\n+import org.elasticsearch.client.RestClient;\n+import org.elasticsearch.client.RestClientBuilder;\n+import org.elasticsearch.client.RestHighLevelClient;\n+import org.elasticsearch.client.eql.EqlSearchRequest;\n+import org.elasticsearch.client.eql.EqlSearchResponse;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.test.rest.ESRestTestCase;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.elasticsearch.xpack.ql.TestUtils.assertNoSearchContexts;\n+\n+@TimeoutSuite(millis = 60 * TimeUnits.MINUTE)\n+public class EsEQLCorrectnessIT extends ESRestTestCase {\n+\n+    private static final String PARAM_FORMATTING = \"%1$s\";\n+    private static final String QUERIES_FILENAME = \"queries.toml\";\n+    private static final String INDEX_NAME = \"mitre\";\n+    private static final int FETCH_SIZE = 10000;\n+    private static final String GCS_REPO_NAME = \"eql_correctness_gcs_repo\";\n+    private static final String SNAPSHOT_NAME = \"mitre-snapshot\";\n+    private static final String GCS_BUCKET_NAME = \"matriv-gcs\";\n+    private static final String GCS_BASE_PATH = \"mitre-data\";\n+    private static final String GCS_CLIENT_NAME = \"eql_test\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDUxNzA1Mg=="}, "originalCommit": {"oid": "75a827feb13d29422d5e09a991a18e780892d8e8"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2MDI3Njc0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/qa/correctness/src/javaRestTest/java/org/elasticsearch/xpack/eql/EsEQLCorrectnessIT.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQwOTowMjowMVrOHhJVJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQwOTowMjowMVrOHhJVJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDUxNzkyNg==", "bodyText": "This should be moved into a separate method and be guarded by an if statement for a bool flag which can be turned on/off if needed.", "url": "https://github.com/elastic/elasticsearch/pull/63644#discussion_r504517926", "createdAt": "2020-10-14T09:02:01Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/qa/correctness/src/javaRestTest/java/org/elasticsearch/xpack/eql/EsEQLCorrectnessIT.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.annotations.TimeoutSuite;\n+import org.apache.http.HttpHost;\n+import org.apache.lucene.util.TimeUnits;\n+import org.elasticsearch.action.admin.cluster.repositories.put.PutRepositoryRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotRequest;\n+import org.elasticsearch.client.HttpAsyncResponseConsumerFactory;\n+import org.elasticsearch.client.Request;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.client.ResponseException;\n+import org.elasticsearch.client.RestClient;\n+import org.elasticsearch.client.RestClientBuilder;\n+import org.elasticsearch.client.RestHighLevelClient;\n+import org.elasticsearch.client.eql.EqlSearchRequest;\n+import org.elasticsearch.client.eql.EqlSearchResponse;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.test.rest.ESRestTestCase;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.elasticsearch.xpack.ql.TestUtils.assertNoSearchContexts;\n+\n+@TimeoutSuite(millis = 60 * TimeUnits.MINUTE)\n+public class EsEQLCorrectnessIT extends ESRestTestCase {\n+\n+    private static final String PARAM_FORMATTING = \"%1$s\";\n+    private static final String QUERIES_FILENAME = \"queries.toml\";\n+    private static final String INDEX_NAME = \"mitre\";\n+    private static final int FETCH_SIZE = 10000;\n+    private static final String GCS_REPO_NAME = \"eql_correctness_gcs_repo\";\n+    private static final String SNAPSHOT_NAME = \"mitre-snapshot\";\n+    private static final String GCS_BUCKET_NAME = \"matriv-gcs\";\n+    private static final String GCS_BASE_PATH = \"mitre-data\";\n+    private static final String GCS_CLIENT_NAME = \"eql_test\";\n+    private static RestHighLevelClient highLevelClient;\n+    private static RequestOptions COMMON_REQUEST_OPTIONS;\n+\n+    @BeforeClass\n+    public static void init() {\n+        RequestOptions.Builder builder = RequestOptions.DEFAULT.toBuilder();\n+        builder.setHttpAsyncResponseConsumerFactory(\n+            new HttpAsyncResponseConsumerFactory.HeapBufferedResponseConsumerFactory(1000 * 1024 * 1024)\n+        );\n+        COMMON_REQUEST_OPTIONS = builder.build();\n+    }\n+\n+    @Before\n+    public void restoreDataFromGcsRepo() throws Exception {\n+        if (client().performRequest(new Request(\"HEAD\", \"/\" + INDEX_NAME)).getStatusLine().getStatusCode() == 404) {\n+            highLevelClient().snapshot()\n+                .createRepository(\n+                    new PutRepositoryRequest(GCS_REPO_NAME).type(\"gcs\")\n+                        .settings(\n+                            Settings.builder()\n+                                .put(\"bucket\", GCS_BUCKET_NAME)\n+                                .put(\"base_path\", GCS_BASE_PATH)\n+                                .put(\"client\", GCS_CLIENT_NAME)\n+                                .build()\n+                        ),\n+                    RequestOptions.DEFAULT\n+                );\n+            highLevelClient().snapshot()\n+                .restore(new RestoreSnapshotRequest(GCS_REPO_NAME, SNAPSHOT_NAME).waitForCompletion(true), RequestOptions.DEFAULT);\n+        }\n+    }\n+\n+    @After\n+    public void checkSearchContent() throws Exception {\n+        assertNoSearchContexts(client());\n+    }\n+\n+    @AfterClass\n+    public static void wipeTestData() throws IOException {\n+        try {\n+            adminClient().performRequest(new Request(\"DELETE\", \"/*\"));\n+        } catch (ResponseException e) {\n+            // 404 here just means we had no indexes\n+            if (e.getResponse().getStatusLine().getStatusCode() != 404) {\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected boolean preserveClusterUponCompletion() {\n+        // Need to preserve data between parameterized tests runs\n+        return true;\n+    }\n+\n+    @Override\n+    protected RestClient buildClient(Settings settings, HttpHost[] hosts) throws IOException {\n+        RestClientBuilder builder = RestClient.builder(hosts);\n+        configureClient(builder, settings);\n+        builder.setRequestConfigCallback(\n+            requestConfigBuilder -> requestConfigBuilder.setConnectTimeout(30000000)\n+                .setConnectionRequestTimeout(30000000)\n+                .setSocketTimeout(30000000)\n+        );\n+        builder.setStrictDeprecationMode(true);\n+        return builder.build();\n+    }\n+\n+    private EqlSpec spec;\n+\n+    public EsEQLCorrectnessIT(EqlSpec spec) {\n+        this.spec = spec;\n+    }\n+\n+    private RestHighLevelClient highLevelClient() {\n+        if (highLevelClient == null) {\n+            highLevelClient = new RestHighLevelClient(client(), ignore -> {}, Collections.emptyList()) {\n+            };\n+        }\n+        return highLevelClient;\n+    }\n+\n+    @ParametersFactory(shuffle = false, argumentFormatting = PARAM_FORMATTING)\n+    public static Iterable<Object[]> parameters() throws Exception {\n+        Collection<EqlSpec> specs;\n+        try (InputStream is = EsEQLCorrectnessIT.class.getClassLoader().getResourceAsStream(QUERIES_FILENAME)) {\n+            specs = EqlSpecLoader.readFromStream(is);\n+        }\n+        assertFalse(\"Found 0 queries for testing\", specs.isEmpty());\n+\n+        List<Object[]> params = new ArrayList<>(specs.size());\n+        for (EqlSpec spec : specs) {\n+            params.add(new Object[] { spec });\n+        }\n+        return params;\n+    }\n+\n+    public void test() throws Exception {\n+        long totalTime = 0;\n+        int queryNo = spec.queryNo();\n+        /* For debugging\n+        for (int i = 0; i < spec.filters().length; i++) {\n+            String filterQuery = spec.filters()[i];\n+            EqlSearchRequest eqlSearchRequest = new EqlSearchRequest(INDEX_NAME, filterQuery);\n+            eqlSearchRequest.eventCategoryField(\"event_type\");\n+            eqlSearchRequest.size(100000);\n+            EqlSearchResponse response = client.eql().search(eqlSearchRequest, commonRequestOptions);\n+            assertEquals(\"Failed to match filter counts for query No: \" + queryNo + \" filterCount: \" + i,\n+                    spec.filterCounts()[i], response.hits().events().size());\n+        } */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75a827feb13d29422d5e09a991a18e780892d8e8"}, "originalPosition": 161}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2MDI3ODE5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/qa/correctness/src/javaRestTest/java/org/elasticsearch/xpack/eql/EsEQLCorrectnessIT.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQwOTowMjoyM1rOHhJWGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQwOTowMjoyM1rOHhJWGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDUxODE2OA==", "bodyText": "These should be extracted as well to constants to make it easy to tweak.", "url": "https://github.com/elastic/elasticsearch/pull/63644#discussion_r504518168", "createdAt": "2020-10-14T09:02:23Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/qa/correctness/src/javaRestTest/java/org/elasticsearch/xpack/eql/EsEQLCorrectnessIT.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.annotations.TimeoutSuite;\n+import org.apache.http.HttpHost;\n+import org.apache.lucene.util.TimeUnits;\n+import org.elasticsearch.action.admin.cluster.repositories.put.PutRepositoryRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotRequest;\n+import org.elasticsearch.client.HttpAsyncResponseConsumerFactory;\n+import org.elasticsearch.client.Request;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.client.ResponseException;\n+import org.elasticsearch.client.RestClient;\n+import org.elasticsearch.client.RestClientBuilder;\n+import org.elasticsearch.client.RestHighLevelClient;\n+import org.elasticsearch.client.eql.EqlSearchRequest;\n+import org.elasticsearch.client.eql.EqlSearchResponse;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.test.rest.ESRestTestCase;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.elasticsearch.xpack.ql.TestUtils.assertNoSearchContexts;\n+\n+@TimeoutSuite(millis = 60 * TimeUnits.MINUTE)\n+public class EsEQLCorrectnessIT extends ESRestTestCase {\n+\n+    private static final String PARAM_FORMATTING = \"%1$s\";\n+    private static final String QUERIES_FILENAME = \"queries.toml\";\n+    private static final String INDEX_NAME = \"mitre\";\n+    private static final int FETCH_SIZE = 10000;\n+    private static final String GCS_REPO_NAME = \"eql_correctness_gcs_repo\";\n+    private static final String SNAPSHOT_NAME = \"mitre-snapshot\";\n+    private static final String GCS_BUCKET_NAME = \"matriv-gcs\";\n+    private static final String GCS_BASE_PATH = \"mitre-data\";\n+    private static final String GCS_CLIENT_NAME = \"eql_test\";\n+    private static RestHighLevelClient highLevelClient;\n+    private static RequestOptions COMMON_REQUEST_OPTIONS;\n+\n+    @BeforeClass\n+    public static void init() {\n+        RequestOptions.Builder builder = RequestOptions.DEFAULT.toBuilder();\n+        builder.setHttpAsyncResponseConsumerFactory(\n+            new HttpAsyncResponseConsumerFactory.HeapBufferedResponseConsumerFactory(1000 * 1024 * 1024)\n+        );\n+        COMMON_REQUEST_OPTIONS = builder.build();\n+    }\n+\n+    @Before\n+    public void restoreDataFromGcsRepo() throws Exception {\n+        if (client().performRequest(new Request(\"HEAD\", \"/\" + INDEX_NAME)).getStatusLine().getStatusCode() == 404) {\n+            highLevelClient().snapshot()\n+                .createRepository(\n+                    new PutRepositoryRequest(GCS_REPO_NAME).type(\"gcs\")\n+                        .settings(\n+                            Settings.builder()\n+                                .put(\"bucket\", GCS_BUCKET_NAME)\n+                                .put(\"base_path\", GCS_BASE_PATH)\n+                                .put(\"client\", GCS_CLIENT_NAME)\n+                                .build()\n+                        ),\n+                    RequestOptions.DEFAULT\n+                );\n+            highLevelClient().snapshot()\n+                .restore(new RestoreSnapshotRequest(GCS_REPO_NAME, SNAPSHOT_NAME).waitForCompletion(true), RequestOptions.DEFAULT);\n+        }\n+    }\n+\n+    @After\n+    public void checkSearchContent() throws Exception {\n+        assertNoSearchContexts(client());\n+    }\n+\n+    @AfterClass\n+    public static void wipeTestData() throws IOException {\n+        try {\n+            adminClient().performRequest(new Request(\"DELETE\", \"/*\"));\n+        } catch (ResponseException e) {\n+            // 404 here just means we had no indexes\n+            if (e.getResponse().getStatusLine().getStatusCode() != 404) {\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected boolean preserveClusterUponCompletion() {\n+        // Need to preserve data between parameterized tests runs\n+        return true;\n+    }\n+\n+    @Override\n+    protected RestClient buildClient(Settings settings, HttpHost[] hosts) throws IOException {\n+        RestClientBuilder builder = RestClient.builder(hosts);\n+        configureClient(builder, settings);\n+        builder.setRequestConfigCallback(\n+            requestConfigBuilder -> requestConfigBuilder.setConnectTimeout(30000000)\n+                .setConnectionRequestTimeout(30000000)\n+                .setSocketTimeout(30000000)\n+        );\n+        builder.setStrictDeprecationMode(true);\n+        return builder.build();\n+    }\n+\n+    private EqlSpec spec;\n+\n+    public EsEQLCorrectnessIT(EqlSpec spec) {\n+        this.spec = spec;\n+    }\n+\n+    private RestHighLevelClient highLevelClient() {\n+        if (highLevelClient == null) {\n+            highLevelClient = new RestHighLevelClient(client(), ignore -> {}, Collections.emptyList()) {\n+            };\n+        }\n+        return highLevelClient;\n+    }\n+\n+    @ParametersFactory(shuffle = false, argumentFormatting = PARAM_FORMATTING)\n+    public static Iterable<Object[]> parameters() throws Exception {\n+        Collection<EqlSpec> specs;\n+        try (InputStream is = EsEQLCorrectnessIT.class.getClassLoader().getResourceAsStream(QUERIES_FILENAME)) {\n+            specs = EqlSpecLoader.readFromStream(is);\n+        }\n+        assertFalse(\"Found 0 queries for testing\", specs.isEmpty());\n+\n+        List<Object[]> params = new ArrayList<>(specs.size());\n+        for (EqlSpec spec : specs) {\n+            params.add(new Object[] { spec });\n+        }\n+        return params;\n+    }\n+\n+    public void test() throws Exception {\n+        long totalTime = 0;\n+        int queryNo = spec.queryNo();\n+        /* For debugging\n+        for (int i = 0; i < spec.filters().length; i++) {\n+            String filterQuery = spec.filters()[i];\n+            EqlSearchRequest eqlSearchRequest = new EqlSearchRequest(INDEX_NAME, filterQuery);\n+            eqlSearchRequest.eventCategoryField(\"event_type\");\n+            eqlSearchRequest.size(100000);\n+            EqlSearchResponse response = client.eql().search(eqlSearchRequest, commonRequestOptions);\n+            assertEquals(\"Failed to match filter counts for query No: \" + queryNo + \" filterCount: \" + i,\n+                    spec.filterCounts()[i], response.hits().events().size());\n+        } */\n+\n+        EqlSearchRequest eqlSearchRequest = new EqlSearchRequest(INDEX_NAME, spec.query());\n+        eqlSearchRequest.eventCategoryField(\"event_type\");\n+        eqlSearchRequest.tiebreakerField(\"serial_id\");\n+        eqlSearchRequest.size(2000);\n+        eqlSearchRequest.fetchSize(FETCH_SIZE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75a827feb13d29422d5e09a991a18e780892d8e8"}, "originalPosition": 167}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3000, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}