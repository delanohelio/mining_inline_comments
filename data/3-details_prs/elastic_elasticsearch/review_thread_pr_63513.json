{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAwMjE3NjU1", "number": 63513, "reviewThreads": {"totalCount": 28, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QyMToyMjo0OVrOFOVu6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wOFQxNzowMjo1NVrOFX9LvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUwNTgwNDU3OnYy", "diffSide": "RIGHT", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/SnapshotClient.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QyMToyMjo0OVrOITCunA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QyMToyMjo0OVrOITCunA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjgzODU1Ng==", "bodyText": "Let's either fill this in or remove it and open an issue to update it", "url": "https://github.com/elastic/elasticsearch/pull/63513#discussion_r556838556", "createdAt": "2021-01-13T21:22:49Z", "author": {"login": "jaymode"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/SnapshotClient.java", "diffHunk": "@@ -389,4 +391,43 @@ public Cancellable deleteAsync(DeleteSnapshotRequest deleteSnapshotRequest, Requ\n             SnapshotRequestConverters::deleteSnapshot, options,\n             AcknowledgedResponse::fromXContent, listener, emptySet());\n     }\n+\n+    /**\n+     * Get a list of features which can be included in a snapshot as feature states.\n+     * See [link here]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "055adf26fd6bb53fb77b90ca66fcace9446b2d5e"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUwNTgwNzU0OnYy", "diffSide": "RIGHT", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/SnapshotClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QyMToyMzoyMVrOITCw2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QyMToyMzoyMVrOITCw2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjgzOTEyOA==", "bodyText": "Add a blurb about what this does?", "url": "https://github.com/elastic/elasticsearch/pull/63513#discussion_r556839128", "createdAt": "2021-01-13T21:23:21Z", "author": {"login": "jaymode"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/SnapshotClient.java", "diffHunk": "@@ -389,4 +391,43 @@ public Cancellable deleteAsync(DeleteSnapshotRequest deleteSnapshotRequest, Requ\n             SnapshotRequestConverters::deleteSnapshot, options,\n             AcknowledgedResponse::fromXContent, listener, emptySet());\n     }\n+\n+    /**\n+     * Get a list of features which can be included in a snapshot as feature states.\n+     * See [link here]\n+     *\n+     * @param getFeaturesRequest the request\n+     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n+     * @return the response\n+     * @throws IOException in case there is a problem sending the request or parsing back the response\n+     */\n+    public GetSnapshottableFeaturesResponse getFeatures(GetSnapshottableFeaturesRequest getFeaturesRequest, RequestOptions options)\n+        throws IOException {\n+        return restHighLevelClient.performRequestAndParseEntity(\n+            getFeaturesRequest,\n+            SnapshotRequestConverters::getSnapshottableFeatures,\n+            options,\n+            GetSnapshottableFeaturesResponse::parse,\n+            emptySet()\n+        );\n+    }\n+\n+    /**\n+     *", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "055adf26fd6bb53fb77b90ca66fcace9446b2d5e"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUwNTkyMzAxOnYy", "diffSide": "RIGHT", "path": "docs/reference/snapshot-restore/apis/create-snapshot-api.asciidoc", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QyMTo0MTo0N1rOITD_lg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QyMTo0MTo0N1rOITD_lg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg1OTI4Ng==", "bodyText": "There isn't a great place to leave this comment but this is in the section about what the cluster state contains. IMO we should change the wording above to say global state instead of cluster state. Alternatively we can move this out of being included in the cluster state and say that global state also includes data stored in system indices.", "url": "https://github.com/elastic/elasticsearch/pull/63513#discussion_r556859286", "createdAt": "2021-01-13T21:41:47Z", "author": {"login": "jaymode"}, "path": "docs/reference/snapshot-restore/apis/create-snapshot-api.asciidoc", "diffHunk": "@@ -102,10 +102,25 @@ The cluster state includes:\n * Legacy index templates\n * Ingest pipelines\n * {ilm-init} lifecycle policies\n+* Data stored in system indices, such as Watches and task records (configurable via `feature_states`)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "055adf26fd6bb53fb77b90ca66fcace9446b2d5e"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUwNTk3MTMzOnYy", "diffSide": "RIGHT", "path": "docs/reference/snapshot-restore/apis/create-snapshot-api.asciidoc", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QyMTo0OToyMlrOITEhOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxOTo1NDoxNFrOIUrybA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg2Nzg5Ng==", "bodyText": "I have concerns regarding the consistency of what an empty array means. For indices within a CreateSnapshotRequest, it means all open indices. The behavior for features states is different and this feels wrong to me.", "url": "https://github.com/elastic/elasticsearch/pull/63513#discussion_r556867896", "createdAt": "2021-01-13T21:49:22Z", "author": {"login": "jaymode"}, "path": "docs/reference/snapshot-restore/apis/create-snapshot-api.asciidoc", "diffHunk": "@@ -102,10 +102,25 @@ The cluster state includes:\n * Legacy index templates\n * Ingest pipelines\n * {ilm-init} lifecycle policies\n+* Data stored in system indices, such as Watches and task records (configurable via `feature_states`)\n --\n +\n IMPORTANT: By default, the entire snapshot will fail if one or more indices included in the snapshot do not have all primary shards available. You can change this behavior by setting <<create-snapshot-api-partial,`partial`>> to `true`.\n \n+[[create-snapshot-api-feature-states]]\n+`feature_states`::\n+(Optional, array of strings)\n+A list of feature states to be included in this snapshot. A list of features\n+available for inclusion in the snapshot and their descriptions be can be\n+retrieved using the <<get-snapshottable-features-api,get snapshottable features API>>.\n+Each feature state includes one or more system indices containing data necessary\n+for the function of that feature. Providing an empty array will include no feature", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "055adf26fd6bb53fb77b90ca66fcace9446b2d5e"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODQ3MzA3OQ==", "bodyText": "That's fair and a good point - my intent with making it that way was to be able to say \"I want to snapshot/restore my cluster state, and no system indices\". Do you have any suggestions for an alternate way of doing that?\nAlternatively, is that even something we need at all? This feels like something that should be possible given you can omit features, but I don't necessarily have a use case in mind.", "url": "https://github.com/elastic/elasticsearch/pull/63513#discussion_r558473079", "createdAt": "2021-01-15T17:54:26Z", "author": {"login": "gwbrown"}, "path": "docs/reference/snapshot-restore/apis/create-snapshot-api.asciidoc", "diffHunk": "@@ -102,10 +102,25 @@ The cluster state includes:\n * Legacy index templates\n * Ingest pipelines\n * {ilm-init} lifecycle policies\n+* Data stored in system indices, such as Watches and task records (configurable via `feature_states`)\n --\n +\n IMPORTANT: By default, the entire snapshot will fail if one or more indices included in the snapshot do not have all primary shards available. You can change this behavior by setting <<create-snapshot-api-partial,`partial`>> to `true`.\n \n+[[create-snapshot-api-feature-states]]\n+`feature_states`::\n+(Optional, array of strings)\n+A list of feature states to be included in this snapshot. A list of features\n+available for inclusion in the snapshot and their descriptions be can be\n+retrieved using the <<get-snapshottable-features-api,get snapshottable features API>>.\n+Each feature state includes one or more system indices containing data necessary\n+for the function of that feature. Providing an empty array will include no feature", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg2Nzg5Ng=="}, "originalCommit": {"oid": "055adf26fd6bb53fb77b90ca66fcace9446b2d5e"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODUyMTc4Mw==", "bodyText": "A few items that I can think of would be introducing a special none option, completely omitting feature_states, or + - and * support.\nRegarding whether we need it, I guess there could be a case where someone just wants to restore how they did previously and only include items from the cluster state.", "url": "https://github.com/elastic/elasticsearch/pull/63513#discussion_r558521783", "createdAt": "2021-01-15T19:02:20Z", "author": {"login": "jaymode"}, "path": "docs/reference/snapshot-restore/apis/create-snapshot-api.asciidoc", "diffHunk": "@@ -102,10 +102,25 @@ The cluster state includes:\n * Legacy index templates\n * Ingest pipelines\n * {ilm-init} lifecycle policies\n+* Data stored in system indices, such as Watches and task records (configurable via `feature_states`)\n --\n +\n IMPORTANT: By default, the entire snapshot will fail if one or more indices included in the snapshot do not have all primary shards available. You can change this behavior by setting <<create-snapshot-api-partial,`partial`>> to `true`.\n \n+[[create-snapshot-api-feature-states]]\n+`feature_states`::\n+(Optional, array of strings)\n+A list of feature states to be included in this snapshot. A list of features\n+available for inclusion in the snapshot and their descriptions be can be\n+retrieved using the <<get-snapshottable-features-api,get snapshottable features API>>.\n+Each feature state includes one or more system indices containing data necessary\n+for the function of that feature. Providing an empty array will include no feature", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg2Nzg5Ng=="}, "originalCommit": {"oid": "055adf26fd6bb53fb77b90ca66fcace9446b2d5e"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODU1NzI1MQ==", "bodyText": "My favorite of those is the none option I think. Do you think [\"none\"] is acceptable, with an error if none is present but isn't the only value in the array? Just using a bare string complicates parsing.\nWhen feature states are completely omitted I think we should continue to base the default on include_global_state, which if that's true means \"all feature states\" (rather similar to how omitting the indices field implicitly means \"all indices\", at least on the restore side).\nIntroducing +/- support would also be workable, but I think that makes usage more complex. I don't like pattern support here, since feature names don't fall into patterns like indices often do - I think that would just make it more confusing (e.g. \"Do I have to say enrich* to restore all my enrich indices?\").", "url": "https://github.com/elastic/elasticsearch/pull/63513#discussion_r558557251", "createdAt": "2021-01-15T19:49:00Z", "author": {"login": "gwbrown"}, "path": "docs/reference/snapshot-restore/apis/create-snapshot-api.asciidoc", "diffHunk": "@@ -102,10 +102,25 @@ The cluster state includes:\n * Legacy index templates\n * Ingest pipelines\n * {ilm-init} lifecycle policies\n+* Data stored in system indices, such as Watches and task records (configurable via `feature_states`)\n --\n +\n IMPORTANT: By default, the entire snapshot will fail if one or more indices included in the snapshot do not have all primary shards available. You can change this behavior by setting <<create-snapshot-api-partial,`partial`>> to `true`.\n \n+[[create-snapshot-api-feature-states]]\n+`feature_states`::\n+(Optional, array of strings)\n+A list of feature states to be included in this snapshot. A list of features\n+available for inclusion in the snapshot and their descriptions be can be\n+retrieved using the <<get-snapshottable-features-api,get snapshottable features API>>.\n+Each feature state includes one or more system indices containing data necessary\n+for the function of that feature. Providing an empty array will include no feature", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg2Nzg5Ng=="}, "originalCommit": {"oid": "055adf26fd6bb53fb77b90ca66fcace9446b2d5e"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODU1OTg1Mg==", "bodyText": "I agree that the none option is the best and also agree that it must be the only item in the array in that case.", "url": "https://github.com/elastic/elasticsearch/pull/63513#discussion_r558559852", "createdAt": "2021-01-15T19:54:14Z", "author": {"login": "jaymode"}, "path": "docs/reference/snapshot-restore/apis/create-snapshot-api.asciidoc", "diffHunk": "@@ -102,10 +102,25 @@ The cluster state includes:\n * Legacy index templates\n * Ingest pipelines\n * {ilm-init} lifecycle policies\n+* Data stored in system indices, such as Watches and task records (configurable via `feature_states`)\n --\n +\n IMPORTANT: By default, the entire snapshot will fail if one or more indices included in the snapshot do not have all primary shards available. You can change this behavior by setting <<create-snapshot-api-partial,`partial`>> to `true`.\n \n+[[create-snapshot-api-feature-states]]\n+`feature_states`::\n+(Optional, array of strings)\n+A list of feature states to be included in this snapshot. A list of features\n+available for inclusion in the snapshot and their descriptions be can be\n+retrieved using the <<get-snapshottable-features-api,get snapshottable features API>>.\n+Each feature state includes one or more system indices containing data necessary\n+for the function of that feature. Providing an empty array will include no feature", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg2Nzg5Ng=="}, "originalCommit": {"oid": "055adf26fd6bb53fb77b90ca66fcace9446b2d5e"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUwNTk4MDUyOnYy", "diffSide": "RIGHT", "path": "docs/reference/snapshot-restore/apis/get-snapshot-api.asciidoc", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QyMTo1MDo1M1rOITEndg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QyMTo1MDo1M1rOITEndg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg2OTQ5NA==", "bodyText": "Is the part about only being present if one or more feature states are included? In the example below, an empty array is shown.", "url": "https://github.com/elastic/elasticsearch/pull/63513#discussion_r556869494", "createdAt": "2021-01-13T21:50:53Z", "author": {"login": "jaymode"}, "path": "docs/reference/snapshot-restore/apis/get-snapshot-api.asciidoc", "diffHunk": "@@ -115,6 +115,15 @@ List of <<data-streams,data streams>> included in the snapshot.\n (Boolean)\n Indicates whether the current cluster state is included in the snapshot.\n \n+[[get-snapshot-api-feature-states]]\n+`feature_states`::\n+(array)\n+List of feature states which were included when the snapshot was taken,\n+including the list of system indices included as part of the feature state. The\n+`feature_name` field of each can be used in the `feature_states` parameter when\n+restoring the snapshot to restore a subset of feature states. Only present if", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "055adf26fd6bb53fb77b90ca66fcace9446b2d5e"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUwNTk5MTMwOnYy", "diffSide": "RIGHT", "path": "docs/reference/snapshot-restore/apis/restore-snapshot-api.asciidoc", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QyMTo1MjozNlrOITEuww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QyMTo1MjozNlrOITEuww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg3MTM2Mw==", "bodyText": "same comment regarding the docs indicating that this exists in the cluster state.", "url": "https://github.com/elastic/elasticsearch/pull/63513#discussion_r556871363", "createdAt": "2021-01-13T21:52:36Z", "author": {"login": "jaymode"}, "path": "docs/reference/snapshot-restore/apis/restore-snapshot-api.asciidoc", "diffHunk": "@@ -134,10 +134,22 @@ The cluster state includes:\n * Legacy index templates\n * Ingest pipelines\n * {ilm-init} lifecycle policies\n+* For snapshots taken after 7.12.0, data stored in system indices, such as Watches and task records, replacing any existing configuration (configurable via `feature_states`)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "055adf26fd6bb53fb77b90ca66fcace9446b2d5e"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUwNTk5Nzk2OnYy", "diffSide": "RIGHT", "path": "docs/reference/snapshot-restore/apis/restore-snapshot-api.asciidoc", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QyMTo1Mzo0MlrOITEzSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QyMTo1Mzo0MlrOITEzSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg3MjUyMA==", "bodyText": "Is empty array behavior consistent with other aspects of this API?", "url": "https://github.com/elastic/elasticsearch/pull/63513#discussion_r556872520", "createdAt": "2021-01-13T21:53:42Z", "author": {"login": "jaymode"}, "path": "docs/reference/snapshot-restore/apis/restore-snapshot-api.asciidoc", "diffHunk": "@@ -134,10 +134,22 @@ The cluster state includes:\n * Legacy index templates\n * Ingest pipelines\n * {ilm-init} lifecycle policies\n+* For snapshots taken after 7.12.0, data stored in system indices, such as Watches and task records, replacing any existing configuration (configurable via `feature_states`)\n --\n +\n IMPORTANT: By default, the entire restore operation will fail if one or more indices included in the snapshot do not have all primary shards available. You can change this behavior by setting <<restore-snapshot-api-partial,`partial`>> to `true`.\n \n+[[restore-snapshot-api-feature-states]]\n+`feature_states`::\n+(Optional, array of strings)\n+A comma-separated list of feature states you wish to restore. Each feature state contains one or more system indices. The list of feature states\n+available in a given snapshot are returned by the <<get-snapshot-api-feature-states, Get Snapshot API>>. Note that feature\n+states restored this way will completely replace any existing configuration, rather than returning an error if the system index already exists.\n+Providing an empty array will restore no feature states, regardless of the value of `include_global_state`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "055adf26fd6bb53fb77b90ca66fcace9446b2d5e"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUwNjAwMDc2OnYy", "diffSide": "RIGHT", "path": "docs/reference/snapshot-restore/restore-snapshot.asciidoc", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QyMTo1NDowN1rOITE1MA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QyMTo1NDowN1rOITE1MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg3MzAwOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            by default as well,\n          \n          \n            \n            by default as well.", "url": "https://github.com/elastic/elasticsearch/pull/63513#discussion_r556873008", "createdAt": "2021-01-13T21:54:07Z", "author": {"login": "jaymode"}, "path": "docs/reference/snapshot-restore/restore-snapshot.asciidoc", "diffHunk": "@@ -32,6 +32,9 @@ By default, all data streams and indices in the snapshot are restored, but the c\n supports <<multi-index,multi-target syntax>>. To include the global cluster state, set\n `include_global_state` to `true` in the restore request body.\n \n+Because all indices in the snapshot are restored by default, all system indices will be restored\n+by default as well,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "055adf26fd6bb53fb77b90ca66fcace9446b2d5e"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUwNjAwMzMxOnYy", "diffSide": "RIGHT", "path": "docs/reference/snapshot-restore/restore-snapshot.asciidoc", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QyMTo1NDozMVrOITE24Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QyMTo1NDozMVrOITE24Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg3MzQ0MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            cluster state and any feature states are not restored.\n          \n          \n            \n            cluster state and feature states are not restored.", "url": "https://github.com/elastic/elasticsearch/pull/63513#discussion_r556873441", "createdAt": "2021-01-13T21:54:31Z", "author": {"login": "jaymode"}, "path": "docs/reference/snapshot-restore/restore-snapshot.asciidoc", "diffHunk": "@@ -88,7 +91,7 @@ POST /_snapshot/my_backup/snapshot_1/_restore\n // TEST[continued]\n \n <1> By default, `include_global_state` is `false`, meaning the snapshot's\n-cluster state is not restored.\n+cluster state and any feature states are not restored.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "055adf26fd6bb53fb77b90ca66fcace9446b2d5e"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUwOTk4MzYzOnYy", "diffSide": "RIGHT", "path": "docs/reference/snapshot-restore/take-snapshot.asciidoc", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQxNjowMzowMFrOITreFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQxNjowMzowMFrOITreFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzUwNjA3MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            cluster settings and templates as well as data stored in system indices, such as Watches and task records, regardless of whether those system\n          \n          \n            \n            cluster settings, templates, and data stored in system indices, such as Watches and task records, regardless of whether those system", "url": "https://github.com/elastic/elasticsearch/pull/63513#discussion_r557506071", "createdAt": "2021-01-14T16:03:00Z", "author": {"login": "jaymode"}, "path": "docs/reference/snapshot-restore/take-snapshot.asciidoc", "diffHunk": "@@ -77,8 +77,10 @@ The snapshot process starts immediately for the primary shards that have been st\n relocation or initialization of shards to complete before snapshotting them.\n \n Besides creating a copy of each data stream and index, the snapshot process can also store global cluster metadata, which includes persistent\n-cluster settings and templates. The transient settings and registered snapshot repositories are not stored as part of\n-the snapshot.\n+cluster settings and templates as well as data stored in system indices, such as Watches and task records, regardless of whether those system", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "055adf26fd6bb53fb77b90ca66fcace9446b2d5e"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxMDEyOTAwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/indices/IndicesService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQxNjozMzoyMVrOITs4eg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQxNjozMzoyMVrOITs4eg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzUyOTIxMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change", "url": "https://github.com/elastic/elasticsearch/pull/63513#discussion_r557529210", "createdAt": "2021-01-14T16:33:21Z", "author": {"login": "jaymode"}, "path": "server/src/main/java/org/elasticsearch/indices/IndicesService.java", "diffHunk": "@@ -877,23 +877,25 @@ public void afterIndexShardClosed(ShardId shardId, IndexShard indexShard, Settin\n      * but does not deal with in-memory structures. For those call {@link #removeIndex(Index, IndexRemovalReason, String)}\n      */\n     @Override\n-    public void deleteUnassignedIndex(String reason, IndexMetadata metadata, ClusterState clusterState) {\n+    public void deleteUnassignedIndex(String reason, IndexMetadata oldIndexMetadata, ClusterState clusterState) {\n         if (nodeEnv.hasNodeFile()) {\n-            String indexName = metadata.getIndex().getName();\n+            Index index = oldIndexMetadata.getIndex();\n             try {\n-                if (clusterState.metadata().hasIndex(indexName)) {\n-                    final IndexMetadata index = clusterState.metadata().index(indexName);\n-                    throw new IllegalStateException(\"Can't delete unassigned index store for [\" + indexName + \"] - it's still part of \" +\n-                                                    \"the cluster state [\" + index.getIndexUUID() + \"] [\" + metadata.getIndexUUID() + \"]\");\n+                if (clusterState.metadata().hasIndex(index)) {\n+                    final IndexMetadata currentMetadata = clusterState.metadata().index(index);\n+                    throw new IllegalStateException(\"Can't delete unassigned index store for [\" + index.getName() + \"] - it's still part \" +\n+                        \"of the cluster state [\" + currentMetadata.getIndexUUID() + \"] [\" +\n+                        oldIndexMetadata.getIndexUUID() + \"]\");\n                 }\n-                deleteIndexStore(reason, metadata);\n+                deleteIndexStore(reason, oldIndexMetadata);\n             } catch (Exception e) {\n                 logger.warn(() -> new ParameterizedMessage(\"[{}] failed to delete unassigned index (reason [{}])\",\n-                    metadata.getIndex(), reason), e);\n+                    oldIndexMetadata.getIndex(), reason), e);\n             }\n         }\n     }\n \n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "055adf26fd6bb53fb77b90ca66fcace9446b2d5e"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxNjU0NTQ1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/snapshots/RestoreService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQyMDowMjo0M1rOIUsDWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQyMDowMjo0M1rOIUsDWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODU2NDE4NA==", "bodyText": "Map.of() or Collections.emptyMap()?", "url": "https://github.com/elastic/elasticsearch/pull/63513#discussion_r558564184", "createdAt": "2021-01-15T20:02:43Z", "author": {"login": "jaymode"}, "path": "server/src/main/java/org/elasticsearch/snapshots/RestoreService.java", "diffHunk": "@@ -614,6 +658,88 @@ public void clusterStateProcessed(String source, ClusterState oldState, ClusterS\n         }\n     }\n \n+    private boolean isSystemIndex(IndexMetadata indexMetadata) {\n+        return indexMetadata.isSystem() || systemIndices.isSystemIndex(indexMetadata.getIndex());\n+    }\n+\n+    private Map<String, DataStream> getDataStreamsToRestore(Repository repository, SnapshotId snapshotId, SnapshotInfo snapshotInfo,\n+                                                           Metadata globalMetadata, List<String> requestIndices) {\n+        Map<String, DataStream> dataStreams;\n+        List<String> requestedDataStreams = filterIndices(snapshotInfo.dataStreams(), requestIndices.toArray(String[]::new),\n+            IndicesOptions.fromOptions(true, true, true, true));\n+        if (requestedDataStreams.isEmpty()) {\n+            dataStreams = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "055adf26fd6bb53fb77b90ca66fcace9446b2d5e"}, "originalPosition": 258}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxNjU1MTU2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/snapshots/RestoreService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQyMDowNDo1NFrOIUsHJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQyMTozNTo1N1rOIUujSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODU2NTE1OQ==", "bodyText": "shouldn't this be an error and not a log message?", "url": "https://github.com/elastic/elasticsearch/pull/63513#discussion_r558565159", "createdAt": "2021-01-15T20:04:54Z", "author": {"login": "jaymode"}, "path": "server/src/main/java/org/elasticsearch/snapshots/RestoreService.java", "diffHunk": "@@ -614,6 +658,88 @@ public void clusterStateProcessed(String source, ClusterState oldState, ClusterS\n         }\n     }\n \n+    private boolean isSystemIndex(IndexMetadata indexMetadata) {\n+        return indexMetadata.isSystem() || systemIndices.isSystemIndex(indexMetadata.getIndex());\n+    }\n+\n+    private Map<String, DataStream> getDataStreamsToRestore(Repository repository, SnapshotId snapshotId, SnapshotInfo snapshotInfo,\n+                                                           Metadata globalMetadata, List<String> requestIndices) {\n+        Map<String, DataStream> dataStreams;\n+        List<String> requestedDataStreams = filterIndices(snapshotInfo.dataStreams(), requestIndices.toArray(String[]::new),\n+            IndicesOptions.fromOptions(true, true, true, true));\n+        if (requestedDataStreams.isEmpty()) {\n+            dataStreams = new HashMap<>();\n+        } else {\n+            if (globalMetadata == null) {\n+                globalMetadata = repository.getSnapshotGlobalMetadata(snapshotId);\n+            }\n+            final Map<String, DataStream> dataStreamsInSnapshot = globalMetadata.dataStreams();\n+            dataStreams = new HashMap<>(requestedDataStreams.size());\n+            for (String requestedDataStream : requestedDataStreams) {\n+                final DataStream dataStreamInSnapshot = dataStreamsInSnapshot.get(requestedDataStream);\n+                assert dataStreamInSnapshot != null : \"DataStream [\" + requestedDataStream + \"] not found in snapshot\";\n+                dataStreams.put(requestedDataStream, dataStreamInSnapshot);\n+            }\n+        }\n+        return dataStreams;\n+    }\n+\n+    private Map<String, List<String>> getFeatureStatesToRestore(RestoreSnapshotRequest request, SnapshotInfo snapshotInfo,\n+                                                                Snapshot snapshot) {\n+        if (snapshotInfo.featureStates() == null) {\n+            return Collections.emptyMap();\n+        }\n+        final Map<String, List<String>> snapshotFeatureStates = snapshotInfo.featureStates().stream()\n+            .collect(Collectors.toMap(SnapshotFeatureInfo::getPluginName, SnapshotFeatureInfo::getIndices));\n+\n+        final Map<String, List<String>> featureStatesToRestore = new HashMap<>(snapshotFeatureStates);\n+        if (request.featureStates() != null) {\n+            final Set<String> requestedStates = Set.of(request.featureStates());\n+            if (snapshotFeatureStates.keySet().containsAll(requestedStates) == false) {\n+                Set<String> nonExistingRequestedStates = new HashSet<>(requestedStates);\n+                nonExistingRequestedStates.removeAll(snapshotFeatureStates.keySet());\n+                throw new SnapshotRestoreException(snapshot, \"requested feature states [\" + nonExistingRequestedStates +\n+                    \"] are not present in snapshot\");\n+            }\n+            featureStatesToRestore.keySet().retainAll(requestedStates);\n+        } else if (request.includeGlobalState() == false) {\n+            featureStatesToRestore.clear();\n+        }\n+\n+        final List<String> featuresNotOnThisNode = featureStatesToRestore.keySet().stream()\n+            .filter(featureName -> systemIndices.getFeatures().containsKey(featureName))\n+            .collect(Collectors.toList());\n+        if (featuresNotOnThisNode.isEmpty() == false) {\n+            logger.warn(\"while restoring feature states from snapshot [{}], some requested feature states are not present on this node: {}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "055adf26fd6bb53fb77b90ca66fcace9446b2d5e"}, "originalPosition": 300}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODYwNTEyOA==", "bodyText": "Looking at this again, I agree, it probably should be an error. Not certain why I didn't make it one originally. I'll change this, although I'm not sure if it's possible to write a test for this case given how our test infrastructure works.", "url": "https://github.com/elastic/elasticsearch/pull/63513#discussion_r558605128", "createdAt": "2021-01-15T21:35:57Z", "author": {"login": "gwbrown"}, "path": "server/src/main/java/org/elasticsearch/snapshots/RestoreService.java", "diffHunk": "@@ -614,6 +658,88 @@ public void clusterStateProcessed(String source, ClusterState oldState, ClusterS\n         }\n     }\n \n+    private boolean isSystemIndex(IndexMetadata indexMetadata) {\n+        return indexMetadata.isSystem() || systemIndices.isSystemIndex(indexMetadata.getIndex());\n+    }\n+\n+    private Map<String, DataStream> getDataStreamsToRestore(Repository repository, SnapshotId snapshotId, SnapshotInfo snapshotInfo,\n+                                                           Metadata globalMetadata, List<String> requestIndices) {\n+        Map<String, DataStream> dataStreams;\n+        List<String> requestedDataStreams = filterIndices(snapshotInfo.dataStreams(), requestIndices.toArray(String[]::new),\n+            IndicesOptions.fromOptions(true, true, true, true));\n+        if (requestedDataStreams.isEmpty()) {\n+            dataStreams = new HashMap<>();\n+        } else {\n+            if (globalMetadata == null) {\n+                globalMetadata = repository.getSnapshotGlobalMetadata(snapshotId);\n+            }\n+            final Map<String, DataStream> dataStreamsInSnapshot = globalMetadata.dataStreams();\n+            dataStreams = new HashMap<>(requestedDataStreams.size());\n+            for (String requestedDataStream : requestedDataStreams) {\n+                final DataStream dataStreamInSnapshot = dataStreamsInSnapshot.get(requestedDataStream);\n+                assert dataStreamInSnapshot != null : \"DataStream [\" + requestedDataStream + \"] not found in snapshot\";\n+                dataStreams.put(requestedDataStream, dataStreamInSnapshot);\n+            }\n+        }\n+        return dataStreams;\n+    }\n+\n+    private Map<String, List<String>> getFeatureStatesToRestore(RestoreSnapshotRequest request, SnapshotInfo snapshotInfo,\n+                                                                Snapshot snapshot) {\n+        if (snapshotInfo.featureStates() == null) {\n+            return Collections.emptyMap();\n+        }\n+        final Map<String, List<String>> snapshotFeatureStates = snapshotInfo.featureStates().stream()\n+            .collect(Collectors.toMap(SnapshotFeatureInfo::getPluginName, SnapshotFeatureInfo::getIndices));\n+\n+        final Map<String, List<String>> featureStatesToRestore = new HashMap<>(snapshotFeatureStates);\n+        if (request.featureStates() != null) {\n+            final Set<String> requestedStates = Set.of(request.featureStates());\n+            if (snapshotFeatureStates.keySet().containsAll(requestedStates) == false) {\n+                Set<String> nonExistingRequestedStates = new HashSet<>(requestedStates);\n+                nonExistingRequestedStates.removeAll(snapshotFeatureStates.keySet());\n+                throw new SnapshotRestoreException(snapshot, \"requested feature states [\" + nonExistingRequestedStates +\n+                    \"] are not present in snapshot\");\n+            }\n+            featureStatesToRestore.keySet().retainAll(requestedStates);\n+        } else if (request.includeGlobalState() == false) {\n+            featureStatesToRestore.clear();\n+        }\n+\n+        final List<String> featuresNotOnThisNode = featureStatesToRestore.keySet().stream()\n+            .filter(featureName -> systemIndices.getFeatures().containsKey(featureName))\n+            .collect(Collectors.toList());\n+        if (featuresNotOnThisNode.isEmpty() == false) {\n+            logger.warn(\"while restoring feature states from snapshot [{}], some requested feature states are not present on this node: {}\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODU2NTE1OQ=="}, "originalCommit": {"oid": "055adf26fd6bb53fb77b90ca66fcace9446b2d5e"}, "originalPosition": 300}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxNjU4MDIzOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/MachineLearning.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQyMDoxNDoxOFrOIUsYaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQyMDoxNDoxOFrOIUsYaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODU2OTU3Nw==", "bodyText": "I wonder if this should be ml? @droberts195 any thoughts?", "url": "https://github.com/elastic/elasticsearch/pull/63513#discussion_r558569577", "createdAt": "2021-01-15T20:14:18Z", "author": {"login": "jaymode"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/MachineLearning.java", "diffHunk": "@@ -1170,6 +1170,16 @@ static long machineMemoryFromStats(OsStats stats) {\n         );\n     }\n \n+    @Override\n+    public String getFeatureName() {\n+        return \"machine_learning\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "055adf26fd6bb53fb77b90ca66fcace9446b2d5e"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU2MjU3Mzk0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/indices/IndicesService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QyMDowODowMVrOIbZfTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QyMToyOToxNlrOIbcWQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTYwMDA3OQ==", "bodyText": "did something change with formatting the imports in your IDE? I've always seen static imports as going last", "url": "https://github.com/elastic/elasticsearch/pull/63513#discussion_r565600079", "createdAt": "2021-01-27T20:08:01Z", "author": {"login": "jaymode"}, "path": "server/src/main/java/org/elasticsearch/indices/IndicesService.java", "diffHunk": "@@ -19,6 +19,43 @@\n \n package org.elasticsearch.indices;\n \n+import static java.util.Collections.emptyList;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe203f664b1c50bbaa9e69a8d0b72a09b6b08b0a"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTY0NjkxNQ==", "bodyText": "Fascinating. I didn't intentionally change anything, I'll look into that and see if I can undo whatever happened there.", "url": "https://github.com/elastic/elasticsearch/pull/63513#discussion_r565646915", "createdAt": "2021-01-27T21:29:16Z", "author": {"login": "gwbrown"}, "path": "server/src/main/java/org/elasticsearch/indices/IndicesService.java", "diffHunk": "@@ -19,6 +19,43 @@\n \n package org.elasticsearch.indices;\n \n+import static java.util.Collections.emptyList;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTYwMDA3OQ=="}, "originalCommit": {"oid": "fe203f664b1c50bbaa9e69a8d0b72a09b6b08b0a"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU4Mzk0NjA3OnYy", "diffSide": "LEFT", "path": "client/rest-high-level/src/test/java/org/elasticsearch/client/SnapshotIT.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxNzozMDozM1rOIecb4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxNzozMDozM1rOIecb4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODc5NDA4Mg==", "bodyText": "EDIT: please revert noisy format changes in this PR, they're all over the place now that I read through it in full :)", "url": "https://github.com/elastic/elasticsearch/pull/63513#discussion_r568794082", "createdAt": "2021-02-02T17:30:33Z", "author": {"login": "original-brownbear"}, "path": "client/rest-high-level/src/test/java/org/elasticsearch/client/SnapshotIT.java", "diffHunk": "@@ -47,16 +63,6 @@\n import org.elasticsearch.snapshots.RestoreInfo;\n import org.mockito.internal.util.collections.Sets;\n \n-import java.io.IOException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc2ac03a67d97dace051aa07c2c3c9d6a303b879"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU4Mzk1NzI5OnYy", "diffSide": "RIGHT", "path": "server/src/internalClusterTest/java/org/elasticsearch/snapshots/SystemIndicesSnapshotIT.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxNzozMzoyMVrOIecjNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxNzozMzoyMVrOIecjNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODc5NTk1OA==", "bodyText": "You can just use createFullSnapshot(REPO_NAME, \"test-snap\") here that does assert that everything went fine and runs the same snapshot request", "url": "https://github.com/elastic/elasticsearch/pull/63513#discussion_r568795958", "createdAt": "2021-02-02T17:33:21Z", "author": {"login": "original-brownbear"}, "path": "server/src/internalClusterTest/java/org/elasticsearch/snapshots/SystemIndicesSnapshotIT.java", "diffHunk": "@@ -0,0 +1,828 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import static org.elasticsearch.snapshots.SnapshotsService.NO_FEATURE_STATES_VALUE;\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n+import static org.hamcrest.Matchers.allOf;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThan;\n+import static org.hamcrest.Matchers.hasItem;\n+import static org.hamcrest.Matchers.in;\n+import static org.hamcrest.Matchers.not;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.elasticsearch.action.admin.cluster.snapshots.create.CreateSnapshotResponse;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotResponse;\n+import org.elasticsearch.common.logging.DeprecationLogger;\n+import org.elasticsearch.common.logging.Loggers;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.indices.SystemIndexDescriptor;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.plugins.SystemIndexPlugin;\n+import org.elasticsearch.test.MockLogAppender;\n+import org.junit.Before;\n+\n+public class SystemIndicesSnapshotIT extends AbstractSnapshotIntegTestCase {\n+\n+    public static final String REPO_NAME = \"test-repo\";\n+\n+    @Override\n+    protected Collection<Class<? extends Plugin>> nodePlugins() {\n+        List<Class<? extends Plugin>> plugins = new ArrayList<>(super.nodePlugins());\n+        plugins.add(SystemIndexTestPlugin.class);\n+        plugins.add(AnotherSystemIndexTestPlugin.class);\n+        plugins.add(AssociatedIndicesTestPlugin.class);\n+        return plugins;\n+    }\n+\n+    @Before\n+    public void setup() {\n+        createRepository(REPO_NAME, \"fs\");\n+    }\n+\n+    /**\n+     * Test that if a snapshot includes system indices and we restore global state,\n+     * with no reference to feature state, the system indices are restored too.\n+     */\n+    public void testRestoreSystemIndicesAsGlobalState() {\n+        // put a document in a system index\n+        indexDoc(SystemIndexTestPlugin.SYSTEM_INDEX_NAME, \"1\", \"purpose\", \"pre-snapshot doc\");\n+        refresh(SystemIndexTestPlugin.SYSTEM_INDEX_NAME);\n+\n+        // run a snapshot including global state\n+        CreateSnapshotResponse createSnapshotResponse = clusterAdmin().prepareCreateSnapshot(REPO_NAME, \"test-snap\")\n+            .setWaitForCompletion(true)\n+            .setIncludeGlobalState(true)\n+            .get();\n+        assertSnapshotSuccess(createSnapshotResponse);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc2ac03a67d97dace051aa07c2c3c9d6a303b879"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU4Mzk2ODY2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/snapshots/create/CreateSnapshotRequest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxNzozNTo1MlrOIecqPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxNzozNTo1MlrOIecqPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODc5Nzc1Nw==", "bodyText": "NIT: noisy imports", "url": "https://github.com/elastic/elasticsearch/pull/63513#discussion_r568797757", "createdAt": "2021-02-02T17:35:52Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/snapshots/create/CreateSnapshotRequest.java", "diffHunk": "@@ -19,6 +19,18 @@\n \n package org.elasticsearch.action.admin.cluster.snapshots.create;\n \n+import static org.elasticsearch.action.ValidateActions.addValidationError;\n+import static org.elasticsearch.common.Strings.EMPTY_ARRAY;\n+import static org.elasticsearch.common.settings.Settings.readSettingsFromStream;\n+import static org.elasticsearch.common.settings.Settings.writeSettingsToStream;\n+import static org.elasticsearch.common.xcontent.support.XContentMapValues.nodeBooleanValue;\n+\n+import java.io.IOException;\n+import java.util.Arrays;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc2ac03a67d97dace051aa07c2c3c9d6a303b879"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU4Mzk3NTEwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/snapshots/create/CreateSnapshotRequest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxNzozNzoyMFrOIecuQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxNzozNzoyMFrOIecuQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODc5ODc4NA==", "bodyText": "NIT: Strings.EMPTY_ARRAY (less verbose than pre-sizing the array and technically faster :))", "url": "https://github.com/elastic/elasticsearch/pull/63513#discussion_r568798784", "createdAt": "2021-02-02T17:37:20Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/snapshots/create/CreateSnapshotRequest.java", "diffHunk": "@@ -348,6 +360,28 @@ public CreateSnapshotRequest userMetadata(Map<String, Object> userMetadata) {\n         return this;\n     }\n \n+    /**\n+     * @return Which plugin states should be included in the snapshot\n+     */\n+    public String[] featureStates() {\n+        return featureStates;\n+    }\n+\n+    /**\n+     * @param featureStates The plugin states to be included in the snapshot\n+     */\n+    public CreateSnapshotRequest featureStates(String[] featureStates) {\n+        this.featureStates = featureStates;\n+        return this;\n+    }\n+\n+    /**\n+     * @param featureStates The plugin states to be included in the snapshot\n+     */\n+    public CreateSnapshotRequest featureStates(List<String> featureStates) {\n+        return featureStates(featureStates.toArray(new String[featureStates.size()]));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc2ac03a67d97dace051aa07c2c3c9d6a303b879"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU4Mzk4MjU2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/snapshots/restore/RestoreSnapshotRequest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxNzozODo1OFrOIecywg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxNzozODo1OFrOIecywg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODc5OTkzOA==", "bodyText": "NIT: Strings.EMPTY_ARRAY", "url": "https://github.com/elastic/elasticsearch/pull/63513#discussion_r568799938", "createdAt": "2021-02-02T17:38:58Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/snapshots/restore/RestoreSnapshotRequest.java", "diffHunk": "@@ -448,6 +459,29 @@ public String snapshotUuid() {\n         return snapshotUuid;\n     }\n \n+    /**\n+     * @return Which feature states should be included in the snapshot\n+     */\n+    @Nullable\n+    public String[] featureStates() {\n+        return featureStates;\n+    }\n+\n+    /**\n+     * @param featureStates The feature states to be included in the snapshot\n+     */\n+    public RestoreSnapshotRequest featureStates(String[] featureStates) {\n+        this.featureStates = featureStates;\n+        return this;\n+    }\n+\n+    /**\n+     * @param featureStates The feature states to be included in the snapshot\n+     */\n+    public RestoreSnapshotRequest featureStates(List<String> featureStates) {\n+        return featureStates(featureStates.toArray(new String[featureStates.size()]));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc2ac03a67d97dace051aa07c2c3c9d6a303b879"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU4Mzk4Nzk1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/cluster/SnapshotsInProgress.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxNzo0MDowN1rOIec18Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxNzo0MDowN1rOIec18Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODgwMDc1Mw==", "bodyText": "Why switch places here, let's just put this as the last argument to keep noise down when backporting (there's some other ctors in 7.x I think that will be painful otherwise).", "url": "https://github.com/elastic/elasticsearch/pull/63513#discussion_r568800753", "createdAt": "2021-02-02T17:40:07Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/cluster/SnapshotsInProgress.java", "diffHunk": "@@ -93,12 +96,12 @@ public String toString() {\n      * will be in state {@link State#SUCCESS} right away otherwise it will be in state {@link State#STARTED}.\n      */\n     public static Entry startedEntry(Snapshot snapshot, boolean includeGlobalState, boolean partial, List<IndexId> indices,\n-                                     List<String> dataStreams, long startTime, long repositoryStateId,\n+                                     List<String> dataStreams, List<SnapshotFeatureInfo> featureStates, long repositoryStateId,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc2ac03a67d97dace051aa07c2c3c9d6a303b879"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU4NDAxOTgwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxNzo0NzozN1rOIedJ5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxNzo0NzozN1rOIedJ5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODgwNTg2MQ==", "bodyText": "Is this even true for partial snapshots? We can concurrently delete the related system indices for partial snapshots and then not see them in the final snapshot can't we?", "url": "https://github.com/elastic/elasticsearch/pull/63513#discussion_r568805861", "createdAt": "2021-02-02T17:47:37Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -1161,9 +1236,10 @@ private void finalizeSnapshotEntry(SnapshotsInProgress.Entry entry, Metadata met\n             final SnapshotInfo snapshotInfo = new SnapshotInfo(snapshot.getSnapshotId(),\n                 shardGenerations.indices().stream().map(IndexId::getName).collect(Collectors.toList()),\n                 entry.dataStreams(),\n-                entry.startTime(), failure, threadPool.absoluteTimeInMillis(),\n-                entry.partial() ? shardGenerations.totalShards() : entry.shards().size(), shardFailures,\n-                entry.includeGlobalState(), entry.userMetadata());\n+                entry.featureStates(), failure, threadPool.absoluteTimeInMillis(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc2ac03a67d97dace051aa07c2c3c9d6a303b879"}, "originalPosition": 233}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU4NDAzODUzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/snapshots/create/CreateSnapshotRequest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxNzo1MTo1MFrOIedVRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxNzo1MTo1MFrOIedVRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODgwODc3NA==", "bodyText": "We have all the state machine changing version constants in SnapshotsService so far, I think this should go there as well to keep things simple.", "url": "https://github.com/elastic/elasticsearch/pull/63513#discussion_r568808774", "createdAt": "2021-02-02T17:51:50Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/snapshots/create/CreateSnapshotRequest.java", "diffHunk": "@@ -64,6 +64,7 @@\n         implements IndicesRequest.Replaceable, ToXContentObject {\n \n     public static final Version SETTINGS_IN_REQUEST_VERSION = Version.V_8_0_0;\n+    public static final Version FEATURE_STATES_VERSION = Version.V_8_0_0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc2ac03a67d97dace051aa07c2c3c9d6a303b879"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU4NDA1NzQ4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/cluster/SnapshotsInProgress.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxNzo1NjowNVrOIedg3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNFQxNjo0OTozOVrOIf9RPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODgxMTc0Mw==", "bodyText": "Is this true? Shouldn't this be taken from the original snapshot if it contained relevant system indices and the clone operation was set to clone those?", "url": "https://github.com/elastic/elasticsearch/pull/63513#discussion_r568811743", "createdAt": "2021-02-02T17:56:05Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/cluster/SnapshotsInProgress.java", "diffHunk": "@@ -115,8 +118,8 @@ public static Entry startedEntry(Snapshot snapshot, boolean includeGlobalState,\n     public static Entry startClone(Snapshot snapshot, SnapshotId source, List<IndexId> indices, long startTime,\n                                    long repositoryStateId, Version version) {\n         return new SnapshotsInProgress.Entry(snapshot, true, false, State.STARTED, indices, Collections.emptyList(),\n-                startTime, repositoryStateId, ImmutableOpenMap.of(), null, Collections.emptyMap(), version, source,\n-                ImmutableOpenMap.of());\n+            Collections.emptyList(), startTime, repositoryStateId, ImmutableOpenMap.of(), null, Collections.emptyMap(), version, source,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc2ac03a67d97dace051aa07c2c3c9d6a303b879"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODk5MzA3NQ==", "bodyText": "This seems like a good point. Snapshot cloning is relatively new and I don't know much about it - if that's the case though, why are data streams Collections.emptyList() here? Shouldn't they be copied as well?", "url": "https://github.com/elastic/elasticsearch/pull/63513#discussion_r568993075", "createdAt": "2021-02-02T23:06:14Z", "author": {"login": "gwbrown"}, "path": "server/src/main/java/org/elasticsearch/cluster/SnapshotsInProgress.java", "diffHunk": "@@ -115,8 +118,8 @@ public static Entry startedEntry(Snapshot snapshot, boolean includeGlobalState,\n     public static Entry startClone(Snapshot snapshot, SnapshotId source, List<IndexId> indices, long startTime,\n                                    long repositoryStateId, Version version) {\n         return new SnapshotsInProgress.Entry(snapshot, true, false, State.STARTED, indices, Collections.emptyList(),\n-                startTime, repositoryStateId, ImmutableOpenMap.of(), null, Collections.emptyMap(), version, source,\n-                ImmutableOpenMap.of());\n+            Collections.emptyList(), startTime, repositoryStateId, ImmutableOpenMap.of(), null, Collections.emptyMap(), version, source,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODgxMTc0Mw=="}, "originalCommit": {"oid": "dc2ac03a67d97dace051aa07c2c3c9d6a303b879"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDM4MDYwNA==", "bodyText": "\ud83e\udd26 yet another datastream curve-ball :) This should be fixed as well. Let's do what you did here then maybe and add a TODO for this. I don't think it's critical to fix in this PR since it's broken already for datastreams. Thanks for noticing!", "url": "https://github.com/elastic/elasticsearch/pull/63513#discussion_r570380604", "createdAt": "2021-02-04T16:49:39Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/cluster/SnapshotsInProgress.java", "diffHunk": "@@ -115,8 +118,8 @@ public static Entry startedEntry(Snapshot snapshot, boolean includeGlobalState,\n     public static Entry startClone(Snapshot snapshot, SnapshotId source, List<IndexId> indices, long startTime,\n                                    long repositoryStateId, Version version) {\n         return new SnapshotsInProgress.Entry(snapshot, true, false, State.STARTED, indices, Collections.emptyList(),\n-                startTime, repositoryStateId, ImmutableOpenMap.of(), null, Collections.emptyMap(), version, source,\n-                ImmutableOpenMap.of());\n+            Collections.emptyList(), startTime, repositoryStateId, ImmutableOpenMap.of(), null, Collections.emptyMap(), version, source,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODgxMTc0Mw=="}, "originalCommit": {"oid": "dc2ac03a67d97dace051aa07c2c3c9d6a303b879"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU4NDA2MDU1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/cluster/SnapshotsInProgress.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxNzo1Njo0NlrOIeditw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxNzo1Njo0NlrOIeditw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODgxMjIxNQ==", "bodyText": "we tend to use == false through the ES codebase", "url": "https://github.com/elastic/elasticsearch/pull/63513#discussion_r568812215", "createdAt": "2021-02-02T17:56:46Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/cluster/SnapshotsInProgress.java", "diffHunk": "@@ -410,6 +424,7 @@ public boolean equals(Object o) {\n             if (version.equals(entry.version) == false) return false;\n             if (Objects.equals(source, ((Entry) o).source) == false) return false;\n             if (clones.equals(((Entry) o).clones) == false) return false;\n+            if (!featureStates.equals(entry.featureStates)) return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc2ac03a67d97dace051aa07c2c3c9d6a303b879"}, "originalPosition": 170}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU4NDExMDM3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxODowODowNVrOIeeB8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNFQxNjo0ODoyOFrOIf9Niw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODgyMDIxMA==", "bodyText": "I think we need BwC here. We shouldn't be triggering ta snapshot that includes featureStates as long as there's old master nodes in the cluster that don't understand featureStates yet. Even if it might work out magically now (because we redundantly store what to snapshot in indices it's a potential point of failure where we move to a different state machine on master failover.", "url": "https://github.com/elastic/elasticsearch/pull/63513#discussion_r568820210", "createdAt": "2021-02-02T18:08:05Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -257,6 +268,44 @@ public ClusterState execute(ClusterState currentState) {\n                 // Store newSnapshot here to be processed in clusterStateProcessed\n                 List<String> indices = Arrays.asList(indexNameExpressionResolver.concreteIndexNames(currentState, request));\n \n+                List<SnapshotFeatureInfo> featureStates = Collections.emptyList();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc2ac03a67d97dace051aa07c2c3c9d6a303b879"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODk5NTUyOQ==", "bodyText": "To clarify, what you're recommending here is not using featureStates in a mixed cluster where some master nodes are <FEATURE_STATES_VERSION?\nIn that case, f there's a request that explicitly uses feature states, we can just throw an exception that that feature isn't allowed in mixed clusters. But if we have a create snapshot request that implicitly uses feature states (include_global_state: true), should we use the pre-7.12.0 behavior regardless of the current version of the master? I don't like silently using the previous behavior like that, but it seems like we'd still want to be able to take a snapshot in that case.", "url": "https://github.com/elastic/elasticsearch/pull/63513#discussion_r568995529", "createdAt": "2021-02-02T23:12:01Z", "author": {"login": "gwbrown"}, "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -257,6 +268,44 @@ public ClusterState execute(ClusterState currentState) {\n                 // Store newSnapshot here to be processed in clusterStateProcessed\n                 List<String> indices = Arrays.asList(indexNameExpressionResolver.concreteIndexNames(currentState, request));\n \n+                List<SnapshotFeatureInfo> featureStates = Collections.emptyList();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODgyMDIxMA=="}, "originalCommit": {"oid": "dc2ac03a67d97dace051aa07c2c3c9d6a303b879"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDM3OTY1OQ==", "bodyText": "the pre-7.12.0 behavior regardless of the current version of the master?\n\nI think that's the correct approach as long as there's old version nodes in the cluster. At least, it's what we currently do for all the snapshot features/changes, we always keep using the old state machine as long as there's nodes of an old version around. It's just the by far easiest BwC behavior to reason about.\n\nIn that case, f there's a request that explicitly uses feature states, we can just throw an exception that that feature isn't allowed in mixed clusters\n\nYea I'd throw here if the request explicitly requests feature states. If it doesn't specify anything, just using the previous behavior seems the way to go.", "url": "https://github.com/elastic/elasticsearch/pull/63513#discussion_r570379659", "createdAt": "2021-02-04T16:48:28Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -257,6 +268,44 @@ public ClusterState execute(ClusterState currentState) {\n                 // Store newSnapshot here to be processed in clusterStateProcessed\n                 List<String> indices = Arrays.asList(indexNameExpressionResolver.concreteIndexNames(currentState, request));\n \n+                List<SnapshotFeatureInfo> featureStates = Collections.emptyList();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODgyMDIxMA=="}, "originalCommit": {"oid": "dc2ac03a67d97dace051aa07c2c3c9d6a303b879"}, "originalPosition": 143}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYwNjU4NDY0OnYy", "diffSide": "RIGHT", "path": "client/rest-high-level/src/test/java/org/elasticsearch/client/snapshots/GetSnapshottableFeaturesResponseTests.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wOFQxNjo1MTo0N1rOIhsgXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wOFQxNjo1MTo0N1rOIhsgXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjIwMzEwMw==", "bodyText": "NIT: random empty line", "url": "https://github.com/elastic/elasticsearch/pull/63513#discussion_r572203103", "createdAt": "2021-02-08T16:51:47Z", "author": {"login": "original-brownbear"}, "path": "client/rest-high-level/src/test/java/org/elasticsearch/client/snapshots/GetSnapshottableFeaturesResponseTests.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License\n+ * 2.0 and the Server Side Public License, v 1; you may not use this file except\n+ * in compliance with, at your election, the Elastic License 2.0 or the Server\n+ * Side Public License, v 1.\n+ */\n+\n+package org.elasticsearch.client.snapshots;\n+\n+import org.elasticsearch.client.AbstractResponseTestCase;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentType;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import static org.hamcrest.Matchers.everyItem;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.in;\n+import static org.hamcrest.Matchers.is;\n+\n+public class GetSnapshottableFeaturesResponseTests extends AbstractResponseTestCase<\n+    org.elasticsearch.action.admin.cluster.snapshots.features.GetSnapshottableFeaturesResponse,\n+    GetSnapshottableFeaturesResponse> {\n+\n+    @Override\n+    protected org.elasticsearch.action.admin.cluster.snapshots.features.GetSnapshottableFeaturesResponse createServerTestInstance(\n+        XContentType xContentType\n+    ) {\n+        return new org.elasticsearch.action.admin.cluster.snapshots.features.GetSnapshottableFeaturesResponse(\n+            randomList(\n+                10,\n+                () -> new org.elasticsearch.action.admin.cluster.snapshots.features.GetSnapshottableFeaturesResponse.SnapshottableFeature(\n+                    randomAlphaOfLengthBetween(4, 10),\n+                    randomAlphaOfLengthBetween(5, 10)\n+                )\n+            )\n+        );\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9edd800362f7a982e5e019f37fe981c3816e9c"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYwNjYzOTk3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wOFQxNzowMjo1NVrOIhtCZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xMVQxNzowOTo0OFrOIkDbbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjIxMTgxMw==", "bodyText": "I think you need to do this the other way around. If you have a partial snapshot, the indices just disappear from the Entry instead of showing up as failure. So if indices are missing, this will just quietly ignore those. You can just run the logic the other way around and check that all the indices you need for a feature are in the indices list.", "url": "https://github.com/elastic/elasticsearch/pull/63513#discussion_r572211813", "createdAt": "2021-02-08T17:02:55Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -1218,6 +1306,29 @@ private void finalizeSnapshotEntry(SnapshotsInProgress.Entry entry, Metadata met\n         }\n     }\n \n+    /**\n+     * Removes all feature states which have missing or failed shards, as they are no longer safely restorable.\n+     * @param entry The \"in progress\" entry with a list of feature states and one or more failed shards.\n+     * @return The list of feature states which were completed successfully in the given entry.\n+     */\n+    private List<SnapshotFeatureInfo> onlySuccessfulFeatureStates(SnapshotsInProgress.Entry entry) {\n+        assert entry.partial() : \"should not try to filter feature states from a non-partial entry\";\n+\n+        // Figure out which indices have unsuccessful shards\n+        Set<String> indicesWithUnsuccessfulShards = new HashSet<>();\n+        entry.shards().keysIt().forEachRemaining(shardId -> {\n+            final ShardState shardState = entry.shards().get(shardId).state();\n+            if (shardState.failed() || shardState.completed() == false) {\n+                indicesWithUnsuccessfulShards.add(shardId.getIndexName());\n+            }\n+        });\n+\n+        // Now remove any feature states which contain any of those indices, as the feature state is not intact and not safely restorable\n+        return entry.featureStates().stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9edd800362f7a982e5e019f37fe981c3816e9c"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjQ1NDc1OQ==", "bodyText": "I'm not entirely sure what you mean here - I tried replacing this method with:\nfinal Set<String> indicesInSnapshot = entry.indices().stream()\n    .map(IndexId::getName)\n    .collect(Collectors.toUnmodifiableSet());\n\nreturn entry.featureStates().stream()\n    .filter(stateInfo -> indicesInSnapshot.containsAll(stateInfo.getIndices()))\n    .collect(Collectors.toList());\nAnd the test I added to check partial snapshots failed - the index which was only partially captured was still in entry.indices(). What I did was apply both approaches (see this commit) - check for any indices which had failed shards and remove any feature states which include those indices AND check for any indices in feature states which aren't in entry.indices(), but I couldn't figure out how to force that case in a test.\nIs that what you mean? Or did I misunderstand you?", "url": "https://github.com/elastic/elasticsearch/pull/63513#discussion_r572454759", "createdAt": "2021-02-08T23:39:41Z", "author": {"login": "gwbrown"}, "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -1218,6 +1306,29 @@ private void finalizeSnapshotEntry(SnapshotsInProgress.Entry entry, Metadata met\n         }\n     }\n \n+    /**\n+     * Removes all feature states which have missing or failed shards, as they are no longer safely restorable.\n+     * @param entry The \"in progress\" entry with a list of feature states and one or more failed shards.\n+     * @return The list of feature states which were completed successfully in the given entry.\n+     */\n+    private List<SnapshotFeatureInfo> onlySuccessfulFeatureStates(SnapshotsInProgress.Entry entry) {\n+        assert entry.partial() : \"should not try to filter feature states from a non-partial entry\";\n+\n+        // Figure out which indices have unsuccessful shards\n+        Set<String> indicesWithUnsuccessfulShards = new HashSet<>();\n+        entry.shards().keysIt().forEachRemaining(shardId -> {\n+            final ShardState shardState = entry.shards().get(shardId).state();\n+            if (shardState.failed() || shardState.completed() == false) {\n+                indicesWithUnsuccessfulShards.add(shardId.getIndexName());\n+            }\n+        });\n+\n+        // Now remove any feature states which contain any of those indices, as the feature state is not intact and not safely restorable\n+        return entry.featureStates().stream()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjIxMTgxMw=="}, "originalCommit": {"oid": "6d9edd800362f7a982e5e019f37fe981c3816e9c"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzk0MzM3OQ==", "bodyText": "@gwbrown\n\nIs that what you mean?\n\nYea exactly we gotta check both. Sorry I missed that you did that correctly in that commit :) Looks good.\nCan we still add a test for this please?\n\ncheck for any indices in feature states which aren't in entry.indices(), but I couldn't figure out how to force that case in a test.\n\nThis should be easy:\n\nStart partial=true snapshot and block it somewhere\nWait for block\nDelete index\nLet snapshot continue\nThe finalisation should go through fine and and the feature should not become part of the snapshot.\n\nThat should work?", "url": "https://github.com/elastic/elasticsearch/pull/63513#discussion_r573943379", "createdAt": "2021-02-10T17:48:49Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -1218,6 +1306,29 @@ private void finalizeSnapshotEntry(SnapshotsInProgress.Entry entry, Metadata met\n         }\n     }\n \n+    /**\n+     * Removes all feature states which have missing or failed shards, as they are no longer safely restorable.\n+     * @param entry The \"in progress\" entry with a list of feature states and one or more failed shards.\n+     * @return The list of feature states which were completed successfully in the given entry.\n+     */\n+    private List<SnapshotFeatureInfo> onlySuccessfulFeatureStates(SnapshotsInProgress.Entry entry) {\n+        assert entry.partial() : \"should not try to filter feature states from a non-partial entry\";\n+\n+        // Figure out which indices have unsuccessful shards\n+        Set<String> indicesWithUnsuccessfulShards = new HashSet<>();\n+        entry.shards().keysIt().forEachRemaining(shardId -> {\n+            final ShardState shardState = entry.shards().get(shardId).state();\n+            if (shardState.failed() || shardState.completed() == false) {\n+                indicesWithUnsuccessfulShards.add(shardId.getIndexName());\n+            }\n+        });\n+\n+        // Now remove any feature states which contain any of those indices, as the feature state is not intact and not safely restorable\n+        return entry.featureStates().stream()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjIxMTgxMw=="}, "originalCommit": {"oid": "6d9edd800362f7a982e5e019f37fe981c3816e9c"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDIwODk3NA==", "bodyText": "@original-brownbear\nI've written a test that follows that pattern, and it passes, but I'm concerned because if I comment out this line, which applies the logic you recommended of checking entry.indices():\n\n  \n    \n      elasticsearch/server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java\n    \n    \n         Line 1354\n      in\n      90bf18d\n    \n    \n    \n    \n\n        \n          \n           .filter(stateInfo -> indicesInSnapshot.containsAll(stateInfo.getIndices())) \n        \n    \n  \n\n\n...then the test still passes, which it sounds like it shouldn't. As far as I can tell, when this test runs, the featureStates field in the initial Entry doesn't get populated until after the index is deleted, so that feature state is never included in the entry to begin with.\nI've tried blocking on data nodes instead of blocking the master (see the commented-out lines removed in this commit), and that version also passes, and again still passes if I comment out the same line - in that case, at least one shard fails and the feature state is removed via the logic I originally had in place.\nI also tried using, instead of blockNodeOnAnyFiles:\n\nblockMasterOnWriteIndexFile, which results in the snapshot completing with all shards successful (including the index that got deleted)\nblockMasterFromFinalizingSnapshotOnSnapFile, which results in the snapshot entirely failing (SnapshotMissingException when attempting to get the SnapshotInfo)\nblockMasterFromFinalizingSnapshotOnIndexFile, which has the same results as blockMasterFromFinalizingSnapshotOnSnapFile\n\nSo I'm still confused about how to actually get the original situation you describe, where we can get a feature state in the Entry that references an index not in entry.indices().\nIf you have bandwidth, I'd be happy to talk synchronously on this.", "url": "https://github.com/elastic/elasticsearch/pull/63513#discussion_r574208974", "createdAt": "2021-02-11T01:52:42Z", "author": {"login": "gwbrown"}, "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -1218,6 +1306,29 @@ private void finalizeSnapshotEntry(SnapshotsInProgress.Entry entry, Metadata met\n         }\n     }\n \n+    /**\n+     * Removes all feature states which have missing or failed shards, as they are no longer safely restorable.\n+     * @param entry The \"in progress\" entry with a list of feature states and one or more failed shards.\n+     * @return The list of feature states which were completed successfully in the given entry.\n+     */\n+    private List<SnapshotFeatureInfo> onlySuccessfulFeatureStates(SnapshotsInProgress.Entry entry) {\n+        assert entry.partial() : \"should not try to filter feature states from a non-partial entry\";\n+\n+        // Figure out which indices have unsuccessful shards\n+        Set<String> indicesWithUnsuccessfulShards = new HashSet<>();\n+        entry.shards().keysIt().forEachRemaining(shardId -> {\n+            final ShardState shardState = entry.shards().get(shardId).state();\n+            if (shardState.failed() || shardState.completed() == false) {\n+                indicesWithUnsuccessfulShards.add(shardId.getIndexName());\n+            }\n+        });\n+\n+        // Now remove any feature states which contain any of those indices, as the feature state is not intact and not safely restorable\n+        return entry.featureStates().stream()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjIxMTgxMw=="}, "originalCommit": {"oid": "6d9edd800362f7a982e5e019f37fe981c3816e9c"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDY3NTgyMQ==", "bodyText": "I talked with @original-brownbear synchronously and figured out what was going on. It turned out that with some recent snapshot optimizations, it's more difficult to trigger the case he originally described.\nIn order to trigger the case reliably, the test now:\n\nAfter creating the system indices, starts a new data node\nCreates an index allocated only on the new data node\nBlocks the new data node and starts a snapshot\nWaits for the block to be hit\nDeletes the index\nUnblocks the data node\n\nThis allows all shards of the system index to be snapshotted, so that there are no failed shards, but still have that index removed from the snapshot.\nThere was also something else I misunderstood - when the index is deleted, it's removed from the final SnapshotInfo, but not the Entry - the final list of indices is generated via ShardGenerations. So the method to filter feature states now takes the final list of indices as well as the Entry and checks against that, rather than against Entry#indices() as the latter does not change.", "url": "https://github.com/elastic/elasticsearch/pull/63513#discussion_r574675821", "createdAt": "2021-02-11T17:09:48Z", "author": {"login": "gwbrown"}, "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -1218,6 +1306,29 @@ private void finalizeSnapshotEntry(SnapshotsInProgress.Entry entry, Metadata met\n         }\n     }\n \n+    /**\n+     * Removes all feature states which have missing or failed shards, as they are no longer safely restorable.\n+     * @param entry The \"in progress\" entry with a list of feature states and one or more failed shards.\n+     * @return The list of feature states which were completed successfully in the given entry.\n+     */\n+    private List<SnapshotFeatureInfo> onlySuccessfulFeatureStates(SnapshotsInProgress.Entry entry) {\n+        assert entry.partial() : \"should not try to filter feature states from a non-partial entry\";\n+\n+        // Figure out which indices have unsuccessful shards\n+        Set<String> indicesWithUnsuccessfulShards = new HashSet<>();\n+        entry.shards().keysIt().forEachRemaining(shardId -> {\n+            final ShardState shardState = entry.shards().get(shardId).state();\n+            if (shardState.failed() || shardState.completed() == false) {\n+                indicesWithUnsuccessfulShards.add(shardId.getIndexName());\n+            }\n+        });\n+\n+        // Now remove any feature states which contain any of those indices, as the feature state is not intact and not safely restorable\n+        return entry.featureStates().stream()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjIxMTgxMw=="}, "originalCommit": {"oid": "6d9edd800362f7a982e5e019f37fe981c3816e9c"}, "originalPosition": 212}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3086, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}