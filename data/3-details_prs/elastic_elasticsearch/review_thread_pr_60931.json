{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY1Njc2ODYz", "number": 60931, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxOTowNzo1NVrOEW7Ekw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNTo1NjozOVrOEXRs-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNDcxOTU1OnYy", "diffSide": "LEFT", "path": "rest-api-spec/src/main/resources/rest-api-spec/test/search.aggregation/20_terms.yml", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxOTowNzo1NVrOG-bpNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxOTowNzo1NVrOG-bpNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODExNzgxNA==", "bodyText": "I wrote this one so I figured I could fix it while I was here. Runtime fields don't have global ordinals so rather than skip the entire test for them I split it into two tests, one that runtime fields can run (below) and this one which runtime fields will skip.", "url": "https://github.com/elastic/elasticsearch/pull/60931#discussion_r468117814", "createdAt": "2020-08-10T19:07:55Z", "author": {"login": "nik9000"}, "path": "rest-api-spec/src/main/resources/rest-api-spec/test/search.aggregation/20_terms.yml", "diffHunk": "@@ -724,7 +724,7 @@ setup:\n         body: { \"size\" : 0, \"aggs\" : { \"no_field_terms\" : { \"terms\" : { \"size\": 1 } } } }\n \n ---\n-\"string profiler\":", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb8402f6ca5839d6118f10f3df224803ee3f8389"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNDg5NDc3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/runtime-fields/qa/rest/build.gradle", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxOTo1NTowNVrOG-dWXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQyMTo0NjoyNVrOG-g6YQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE0NTc1OA==", "bodyText": "This is quite the list of exclusions. Seems a bit brittle. One issue I anticipate is future newly added tests also being incompatible with this approach for one reason or another.", "url": "https://github.com/elastic/elasticsearch/pull/60931#discussion_r468145758", "createdAt": "2020-08-10T19:55:05Z", "author": {"login": "mark-vieira"}, "path": "x-pack/plugin/runtime-fields/qa/rest/build.gradle", "diffHunk": "@@ -0,0 +1,45 @@\n+apply plugin: 'elasticsearch.testclusters'\n+apply plugin: 'elasticsearch.standalone-rest-test'\n+apply plugin: 'elasticsearch.rest-test'\n+apply plugin: 'elasticsearch.rest-resources'\n+\n+restResources {\n+  restTests {\n+    includeCore '*'\n+  }\n+}\n+\n+testClusters.integTest {\n+  testDistribution = 'DEFAULT'\n+}\n+\n+integTest {\n+  systemProperty 'tests.rest.blacklist',\n+    [", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb8402f6ca5839d6118f10f3df224803ee3f8389"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE0OTY5Mg==", "bodyText": "My goal is to fix the ones between here and line 36 fairly soon. At least theoretically, tests that fetch the mapping are never going to work but other sorts of tests should work. I could scan the test configuration for the command to fetch the mapping and skip those. It wouldn't be too bad and would shrink these.", "url": "https://github.com/elastic/elasticsearch/pull/60931#discussion_r468149692", "createdAt": "2020-08-10T20:02:50Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/runtime-fields/qa/rest/build.gradle", "diffHunk": "@@ -0,0 +1,45 @@\n+apply plugin: 'elasticsearch.testclusters'\n+apply plugin: 'elasticsearch.standalone-rest-test'\n+apply plugin: 'elasticsearch.rest-test'\n+apply plugin: 'elasticsearch.rest-resources'\n+\n+restResources {\n+  restTests {\n+    includeCore '*'\n+  }\n+}\n+\n+testClusters.integTest {\n+  testDistribution = 'DEFAULT'\n+}\n+\n+integTest {\n+  systemProperty 'tests.rest.blacklist',\n+    [", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE0NTc1OA=="}, "originalCommit": {"oid": "fb8402f6ca5839d6118f10f3df224803ee3f8389"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE2NTcyMg==", "bodyText": "Another option is to add skip style property so these tests can opt themselves out of running against runtime field.", "url": "https://github.com/elastic/elasticsearch/pull/60931#discussion_r468165722", "createdAt": "2020-08-10T20:25:24Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/runtime-fields/qa/rest/build.gradle", "diffHunk": "@@ -0,0 +1,45 @@\n+apply plugin: 'elasticsearch.testclusters'\n+apply plugin: 'elasticsearch.standalone-rest-test'\n+apply plugin: 'elasticsearch.rest-test'\n+apply plugin: 'elasticsearch.rest-resources'\n+\n+restResources {\n+  restTests {\n+    includeCore '*'\n+  }\n+}\n+\n+testClusters.integTest {\n+  testDistribution = 'DEFAULT'\n+}\n+\n+integTest {\n+  systemProperty 'tests.rest.blacklist',\n+    [", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE0NTc1OA=="}, "originalCommit": {"oid": "fb8402f6ca5839d6118f10f3df224803ee3f8389"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE3NTQ4OA==", "bodyText": "I like the idea of a skip property -- that way the 'skip reason' is discoverable and right next to the test itself.", "url": "https://github.com/elastic/elasticsearch/pull/60931#discussion_r468175488", "createdAt": "2020-08-10T20:45:17Z", "author": {"login": "jtibshirani"}, "path": "x-pack/plugin/runtime-fields/qa/rest/build.gradle", "diffHunk": "@@ -0,0 +1,45 @@\n+apply plugin: 'elasticsearch.testclusters'\n+apply plugin: 'elasticsearch.standalone-rest-test'\n+apply plugin: 'elasticsearch.rest-test'\n+apply plugin: 'elasticsearch.rest-resources'\n+\n+restResources {\n+  restTests {\n+    includeCore '*'\n+  }\n+}\n+\n+testClusters.integTest {\n+  testDistribution = 'DEFAULT'\n+}\n+\n+integTest {\n+  systemProperty 'tests.rest.blacklist',\n+    [", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE0NTc1OA=="}, "originalCommit": {"oid": "fb8402f6ca5839d6118f10f3df224803ee3f8389"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIwNDEyOQ==", "bodyText": "We'd have to bring this notion of runtime fields testing up into the test framework itself though, which seems a bit awkward given how this is currently structured as a specific qa project.", "url": "https://github.com/elastic/elasticsearch/pull/60931#discussion_r468204129", "createdAt": "2020-08-10T21:46:25Z", "author": {"login": "mark-vieira"}, "path": "x-pack/plugin/runtime-fields/qa/rest/build.gradle", "diffHunk": "@@ -0,0 +1,45 @@\n+apply plugin: 'elasticsearch.testclusters'\n+apply plugin: 'elasticsearch.standalone-rest-test'\n+apply plugin: 'elasticsearch.rest-test'\n+apply plugin: 'elasticsearch.rest-resources'\n+\n+restResources {\n+  restTests {\n+    includeCore '*'\n+  }\n+}\n+\n+testClusters.integTest {\n+  testDistribution = 'DEFAULT'\n+}\n+\n+integTest {\n+  systemProperty 'tests.rest.blacklist',\n+    [", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE0NTc1OA=="}, "originalCommit": {"oid": "fb8402f6ca5839d6118f10f3df224803ee3f8389"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNDk0NTk4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/runtime-fields/qa/rest/build.gradle", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQyMDoxMToxN1rOG-d1jg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQyMDoxODozNVrOG-eWvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE1Mzc0Mg==", "bodyText": "We should replace all of this with the elasticsearch.yaml-rest-test plugin. Additionally the test suite should move from src/test to src/yamlRestTest to comply with new conventions.", "url": "https://github.com/elastic/elasticsearch/pull/60931#discussion_r468153742", "createdAt": "2020-08-10T20:11:17Z", "author": {"login": "mark-vieira"}, "path": "x-pack/plugin/runtime-fields/qa/rest/build.gradle", "diffHunk": "@@ -0,0 +1,45 @@\n+apply plugin: 'elasticsearch.testclusters'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb8402f6ca5839d6118f10f3df224803ee3f8389"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE1NTEwNA==", "bodyText": "Sure.", "url": "https://github.com/elastic/elasticsearch/pull/60931#discussion_r468155104", "createdAt": "2020-08-10T20:13:02Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/runtime-fields/qa/rest/build.gradle", "diffHunk": "@@ -0,0 +1,45 @@\n+apply plugin: 'elasticsearch.testclusters'", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE1Mzc0Mg=="}, "originalCommit": {"oid": "fb8402f6ca5839d6118f10f3df224803ee3f8389"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE2MjIzOQ==", "bodyText": "b392332", "url": "https://github.com/elastic/elasticsearch/pull/60931#discussion_r468162239", "createdAt": "2020-08-10T20:18:35Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/runtime-fields/qa/rest/build.gradle", "diffHunk": "@@ -0,0 +1,45 @@\n+apply plugin: 'elasticsearch.testclusters'", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE1Mzc0Mg=="}, "originalCommit": {"oid": "fb8402f6ca5839d6118f10f3df224803ee3f8389"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNTEwNTAzOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/runtime-fields/qa/rest/src/yamlRestTest/java/org/elasticsearch/xpack/runtimefields/rest/CoreTestsWithRuntimeFieldsIT.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQyMDo1MjozN1rOG-fYsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMzo1NTo1M1rOG-4-qQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE3OTEyMw==", "bodyText": "Is there ever a time when the rest of the Object array is relevant (beyond the first element)? Maybe we could replace orig[0] and still return orig, or simply assert orig.length == 1 ?", "url": "https://github.com/elastic/elasticsearch/pull/60931#discussion_r468179123", "createdAt": "2020-08-10T20:52:37Z", "author": {"login": "jtibshirani"}, "path": "x-pack/plugin/runtime-fields/qa/rest/src/yamlRestTest/java/org/elasticsearch/xpack/runtimefields/rest/CoreTestsWithRuntimeFieldsIT.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.runtimefields.rest;\n+\n+import com.carrotsearch.randomizedtesting.annotations.Name;\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+\n+import org.elasticsearch.index.mapper.IpFieldMapper;\n+import org.elasticsearch.index.mapper.KeywordFieldMapper;\n+import org.elasticsearch.index.mapper.NumberFieldMapper.NumberType;\n+import org.elasticsearch.test.rest.yaml.ClientYamlTestCandidate;\n+import org.elasticsearch.test.rest.yaml.ESClientYamlSuiteTestCase;\n+import org.elasticsearch.test.rest.yaml.section.DoSection;\n+import org.elasticsearch.test.rest.yaml.section.ExecutableSection;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+public class CoreTestsWithRuntimeFieldsIT extends ESClientYamlSuiteTestCase {\n+    public CoreTestsWithRuntimeFieldsIT(@Name(\"yaml\") ClientYamlTestCandidate testCandidate) {\n+        super(testCandidate);\n+    }\n+\n+    /**\n+     * Builds test parameters similarly to {@link ESClientYamlSuiteTestCase#createParameters()},\n+     * replacing the body of index creation commands so that fields are {@code runtime_script}s\n+     * that load from {@code source} instead of their original type. Test configurations that\n+     * do are not modified to contain runtime fields are not returned as they are tested\n+     * elsewhere.\n+     */\n+    @ParametersFactory\n+    public static Iterable<Object[]> parameters() throws Exception {\n+        /*\n+         * Map of \"setup\"s that we've seen - from path to whether or\n+         * not we the setup was modified to include a runtime_script\n+         */\n+        Map<String, Boolean> seenSetups = new HashMap<>();\n+        List<Object[]> result = new ArrayList<>();\n+        for (Object[] orig : ESClientYamlSuiteTestCase.createParameters()) {\n+            ClientYamlTestCandidate candidate = (ClientYamlTestCandidate) orig[0];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b392332ced3a2f896b962453b45600c397ef7602"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU5ODQ0MQ==", "bodyText": "The array only ever has a single entry, but I'll add an assert just to make sure it stays that way. The funny shape of the return here comes from the method being used primarily for junit's parameterized tests.", "url": "https://github.com/elastic/elasticsearch/pull/60931#discussion_r468598441", "createdAt": "2020-08-11T13:55:53Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/runtime-fields/qa/rest/src/yamlRestTest/java/org/elasticsearch/xpack/runtimefields/rest/CoreTestsWithRuntimeFieldsIT.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.runtimefields.rest;\n+\n+import com.carrotsearch.randomizedtesting.annotations.Name;\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+\n+import org.elasticsearch.index.mapper.IpFieldMapper;\n+import org.elasticsearch.index.mapper.KeywordFieldMapper;\n+import org.elasticsearch.index.mapper.NumberFieldMapper.NumberType;\n+import org.elasticsearch.test.rest.yaml.ClientYamlTestCandidate;\n+import org.elasticsearch.test.rest.yaml.ESClientYamlSuiteTestCase;\n+import org.elasticsearch.test.rest.yaml.section.DoSection;\n+import org.elasticsearch.test.rest.yaml.section.ExecutableSection;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+public class CoreTestsWithRuntimeFieldsIT extends ESClientYamlSuiteTestCase {\n+    public CoreTestsWithRuntimeFieldsIT(@Name(\"yaml\") ClientYamlTestCandidate testCandidate) {\n+        super(testCandidate);\n+    }\n+\n+    /**\n+     * Builds test parameters similarly to {@link ESClientYamlSuiteTestCase#createParameters()},\n+     * replacing the body of index creation commands so that fields are {@code runtime_script}s\n+     * that load from {@code source} instead of their original type. Test configurations that\n+     * do are not modified to contain runtime fields are not returned as they are tested\n+     * elsewhere.\n+     */\n+    @ParametersFactory\n+    public static Iterable<Object[]> parameters() throws Exception {\n+        /*\n+         * Map of \"setup\"s that we've seen - from path to whether or\n+         * not we the setup was modified to include a runtime_script\n+         */\n+        Map<String, Boolean> seenSetups = new HashMap<>();\n+        List<Object[]> result = new ArrayList<>();\n+        for (Object[] orig : ESClientYamlSuiteTestCase.createParameters()) {\n+            ClientYamlTestCandidate candidate = (ClientYamlTestCandidate) orig[0];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE3OTEyMw=="}, "originalCommit": {"oid": "b392332ced3a2f896b962453b45600c397ef7602"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNTEyOTA2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/runtime-fields/qa/rest/src/yamlRestTest/java/org/elasticsearch/xpack/runtimefields/rest/CoreTestsWithRuntimeFieldsIT.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQyMDo1OTo1OVrOG-fnVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMzo1Mjo1M1rOG-41vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE4Mjg2OA==", "bodyText": "I find the formatting hard to follow, does it work to just do return settings.containsKey(\"sort.field\"); ? Also maybe we could use the phrase 'index sort' to clarify what this setting refers to.", "url": "https://github.com/elastic/elasticsearch/pull/60931#discussion_r468182868", "createdAt": "2020-08-10T20:59:59Z", "author": {"login": "jtibshirani"}, "path": "x-pack/plugin/runtime-fields/qa/rest/src/yamlRestTest/java/org/elasticsearch/xpack/runtimefields/rest/CoreTestsWithRuntimeFieldsIT.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.runtimefields.rest;\n+\n+import com.carrotsearch.randomizedtesting.annotations.Name;\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+\n+import org.elasticsearch.index.mapper.IpFieldMapper;\n+import org.elasticsearch.index.mapper.KeywordFieldMapper;\n+import org.elasticsearch.index.mapper.NumberFieldMapper.NumberType;\n+import org.elasticsearch.test.rest.yaml.ClientYamlTestCandidate;\n+import org.elasticsearch.test.rest.yaml.ESClientYamlSuiteTestCase;\n+import org.elasticsearch.test.rest.yaml.section.DoSection;\n+import org.elasticsearch.test.rest.yaml.section.ExecutableSection;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+public class CoreTestsWithRuntimeFieldsIT extends ESClientYamlSuiteTestCase {\n+    public CoreTestsWithRuntimeFieldsIT(@Name(\"yaml\") ClientYamlTestCandidate testCandidate) {\n+        super(testCandidate);\n+    }\n+\n+    /**\n+     * Builds test parameters similarly to {@link ESClientYamlSuiteTestCase#createParameters()},\n+     * replacing the body of index creation commands so that fields are {@code runtime_script}s\n+     * that load from {@code source} instead of their original type. Test configurations that\n+     * do are not modified to contain runtime fields are not returned as they are tested\n+     * elsewhere.\n+     */\n+    @ParametersFactory\n+    public static Iterable<Object[]> parameters() throws Exception {\n+        /*\n+         * Map of \"setup\"s that we've seen - from path to whether or\n+         * not we the setup was modified to include a runtime_script\n+         */\n+        Map<String, Boolean> seenSetups = new HashMap<>();\n+        List<Object[]> result = new ArrayList<>();\n+        for (Object[] orig : ESClientYamlSuiteTestCase.createParameters()) {\n+            ClientYamlTestCandidate candidate = (ClientYamlTestCandidate) orig[0];\n+            boolean modifiedSetup = seenSetups.computeIfAbsent(\n+                candidate.getName(),\n+                k -> modifySection(candidate.getSuitePath() + \"/setup\", candidate.getSetupSection().getExecutableSections())\n+            );\n+            boolean modifiedTest = modifySection(candidate.getTestPath(), candidate.getTestSection().getExecutableSections());\n+            if (modifiedSetup || modifiedTest) {\n+                result.add(new Object[] { candidate });\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Replace property configuration in {@code indices.create} with scripts\n+     * that load from the source.\n+     * @return {@code true} if any fields were rewritten into runtime_scripts, {@code false} otherwise.\n+     */\n+    private static boolean modifySection(String sectionName, List<ExecutableSection> executables) {\n+        boolean include = false;\n+        for (ExecutableSection section : executables) {\n+            if (false == (section instanceof DoSection)) {\n+                continue;\n+            }\n+            DoSection doSection = (DoSection) section;\n+            if (false == doSection.getApiCallSection().getApi().equals(\"indices.create\")) {\n+                continue;\n+            }\n+            for (Map<?, ?> body : doSection.getApiCallSection().getBodies()) {\n+                Object settings = body.get(\"settings\");\n+                if (settings instanceof Map && containsUnsupportedSettings((Map<?, ?>) settings)) {\n+                    continue;\n+                }\n+                Object mappings = body.get(\"mappings\");\n+                if (false == (mappings instanceof Map)) {\n+                    continue;\n+                }\n+                Object properties = ((Map<?, ?>) mappings).get(\"properties\");\n+                if (false == (properties instanceof Map)) {\n+                    continue;\n+                }\n+                for (Map.Entry<?, ?> property : ((Map<?, ?>) properties).entrySet()) {\n+                    if (false == property.getValue() instanceof Map) {\n+                        continue;\n+                    }\n+                    @SuppressWarnings(\"unchecked\")\n+                    Map<String, Object> propertyMap = (Map<String, Object>) property.getValue();\n+                    String name = property.getKey().toString();\n+                    String type = Objects.toString(propertyMap.get(\"type\"));\n+                    if (\"false\".equals(Objects.toString(propertyMap.get(\"doc_values\")))) {\n+                        // If doc_values is false we can't emulate with scripts. `null` and `true` are fine.\n+                        continue;\n+                    }\n+                    if (\"false\".equals(Objects.toString(propertyMap.get(\"index\")))) {\n+                        // If index is false we can't emulate with scripts\n+                        continue;\n+                    }\n+                    if (\"true\".equals(Objects.toString(propertyMap.get(\"store\")))) {\n+                        // If store is true we can't emulate with scripts\n+                        continue;\n+                    }\n+                    if (propertyMap.containsKey(\"ignore_above\")) {\n+                        // Scripts don't support ignore_above so we skip those fields\n+                        continue;\n+                    }\n+                    if (propertyMap.containsKey(\"ignore_malformed\")) {\n+                        // Our source reading script doesn't emulate ignore_malformed\n+                        continue;\n+                    }\n+                    String toLoad = painlessToLoadFromSource(name, type);\n+                    if (toLoad == null) {\n+                        continue;\n+                    }\n+                    propertyMap.put(\"type\", \"runtime_script\");\n+                    propertyMap.put(\"runtime_type\", type);\n+                    propertyMap.put(\"script\", toLoad);\n+                    propertyMap.remove(\"store\");\n+                    propertyMap.remove(\"index\");\n+                    propertyMap.remove(\"doc_values\");\n+                    include = true;\n+                }\n+            }\n+        }\n+        return include;\n+    }\n+\n+    private static boolean containsUnsupportedSettings(Map<?, ?> settings) {\n+        return", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b392332ced3a2f896b962453b45600c397ef7602"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU5NjE1OA==", "bodyText": "I super thought there'd be other things to add here. But it turned out this was it. I'll remove the method and move the check into the caller.", "url": "https://github.com/elastic/elasticsearch/pull/60931#discussion_r468596158", "createdAt": "2020-08-11T13:52:53Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/runtime-fields/qa/rest/src/yamlRestTest/java/org/elasticsearch/xpack/runtimefields/rest/CoreTestsWithRuntimeFieldsIT.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.runtimefields.rest;\n+\n+import com.carrotsearch.randomizedtesting.annotations.Name;\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+\n+import org.elasticsearch.index.mapper.IpFieldMapper;\n+import org.elasticsearch.index.mapper.KeywordFieldMapper;\n+import org.elasticsearch.index.mapper.NumberFieldMapper.NumberType;\n+import org.elasticsearch.test.rest.yaml.ClientYamlTestCandidate;\n+import org.elasticsearch.test.rest.yaml.ESClientYamlSuiteTestCase;\n+import org.elasticsearch.test.rest.yaml.section.DoSection;\n+import org.elasticsearch.test.rest.yaml.section.ExecutableSection;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+public class CoreTestsWithRuntimeFieldsIT extends ESClientYamlSuiteTestCase {\n+    public CoreTestsWithRuntimeFieldsIT(@Name(\"yaml\") ClientYamlTestCandidate testCandidate) {\n+        super(testCandidate);\n+    }\n+\n+    /**\n+     * Builds test parameters similarly to {@link ESClientYamlSuiteTestCase#createParameters()},\n+     * replacing the body of index creation commands so that fields are {@code runtime_script}s\n+     * that load from {@code source} instead of their original type. Test configurations that\n+     * do are not modified to contain runtime fields are not returned as they are tested\n+     * elsewhere.\n+     */\n+    @ParametersFactory\n+    public static Iterable<Object[]> parameters() throws Exception {\n+        /*\n+         * Map of \"setup\"s that we've seen - from path to whether or\n+         * not we the setup was modified to include a runtime_script\n+         */\n+        Map<String, Boolean> seenSetups = new HashMap<>();\n+        List<Object[]> result = new ArrayList<>();\n+        for (Object[] orig : ESClientYamlSuiteTestCase.createParameters()) {\n+            ClientYamlTestCandidate candidate = (ClientYamlTestCandidate) orig[0];\n+            boolean modifiedSetup = seenSetups.computeIfAbsent(\n+                candidate.getName(),\n+                k -> modifySection(candidate.getSuitePath() + \"/setup\", candidate.getSetupSection().getExecutableSections())\n+            );\n+            boolean modifiedTest = modifySection(candidate.getTestPath(), candidate.getTestSection().getExecutableSections());\n+            if (modifiedSetup || modifiedTest) {\n+                result.add(new Object[] { candidate });\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Replace property configuration in {@code indices.create} with scripts\n+     * that load from the source.\n+     * @return {@code true} if any fields were rewritten into runtime_scripts, {@code false} otherwise.\n+     */\n+    private static boolean modifySection(String sectionName, List<ExecutableSection> executables) {\n+        boolean include = false;\n+        for (ExecutableSection section : executables) {\n+            if (false == (section instanceof DoSection)) {\n+                continue;\n+            }\n+            DoSection doSection = (DoSection) section;\n+            if (false == doSection.getApiCallSection().getApi().equals(\"indices.create\")) {\n+                continue;\n+            }\n+            for (Map<?, ?> body : doSection.getApiCallSection().getBodies()) {\n+                Object settings = body.get(\"settings\");\n+                if (settings instanceof Map && containsUnsupportedSettings((Map<?, ?>) settings)) {\n+                    continue;\n+                }\n+                Object mappings = body.get(\"mappings\");\n+                if (false == (mappings instanceof Map)) {\n+                    continue;\n+                }\n+                Object properties = ((Map<?, ?>) mappings).get(\"properties\");\n+                if (false == (properties instanceof Map)) {\n+                    continue;\n+                }\n+                for (Map.Entry<?, ?> property : ((Map<?, ?>) properties).entrySet()) {\n+                    if (false == property.getValue() instanceof Map) {\n+                        continue;\n+                    }\n+                    @SuppressWarnings(\"unchecked\")\n+                    Map<String, Object> propertyMap = (Map<String, Object>) property.getValue();\n+                    String name = property.getKey().toString();\n+                    String type = Objects.toString(propertyMap.get(\"type\"));\n+                    if (\"false\".equals(Objects.toString(propertyMap.get(\"doc_values\")))) {\n+                        // If doc_values is false we can't emulate with scripts. `null` and `true` are fine.\n+                        continue;\n+                    }\n+                    if (\"false\".equals(Objects.toString(propertyMap.get(\"index\")))) {\n+                        // If index is false we can't emulate with scripts\n+                        continue;\n+                    }\n+                    if (\"true\".equals(Objects.toString(propertyMap.get(\"store\")))) {\n+                        // If store is true we can't emulate with scripts\n+                        continue;\n+                    }\n+                    if (propertyMap.containsKey(\"ignore_above\")) {\n+                        // Scripts don't support ignore_above so we skip those fields\n+                        continue;\n+                    }\n+                    if (propertyMap.containsKey(\"ignore_malformed\")) {\n+                        // Our source reading script doesn't emulate ignore_malformed\n+                        continue;\n+                    }\n+                    String toLoad = painlessToLoadFromSource(name, type);\n+                    if (toLoad == null) {\n+                        continue;\n+                    }\n+                    propertyMap.put(\"type\", \"runtime_script\");\n+                    propertyMap.put(\"runtime_type\", type);\n+                    propertyMap.put(\"script\", toLoad);\n+                    propertyMap.remove(\"store\");\n+                    propertyMap.remove(\"index\");\n+                    propertyMap.remove(\"doc_values\");\n+                    include = true;\n+                }\n+            }\n+        }\n+        return include;\n+    }\n+\n+    private static boolean containsUnsupportedSettings(Map<?, ?> settings) {\n+        return", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE4Mjg2OA=="}, "originalCommit": {"oid": "b392332ced3a2f896b962453b45600c397ef7602"}, "originalPosition": 134}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNTE5MDMzOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/runtime-fields/qa/rest/src/yamlRestTest/java/org/elasticsearch/xpack/runtimefields/rest/CoreTestsWithRuntimeFieldsIT.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQyMToyMDoxMFrOG-gMjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNTo1OTozNlrOG--oiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE5MjM5Ng==", "bodyText": "This seems like the best approach for now but feels a bit fragile -- we're essentially duplicating the source parsing logic, which can be pretty nuanced. For example, for boolean fields, the value \"\" is interpreted as false. We also don't cover cases where the value is malformed or missing from _source.\nTo make this more robust, I guess we could switch to 'source-only fields' when those are available?  That way we could reuse the logic from fields retrieval for parsing values from source. Or we could consider adding a way to access nicely-formatted source fields from painless?", "url": "https://github.com/elastic/elasticsearch/pull/60931#discussion_r468192396", "createdAt": "2020-08-10T21:20:10Z", "author": {"login": "jtibshirani"}, "path": "x-pack/plugin/runtime-fields/qa/rest/src/yamlRestTest/java/org/elasticsearch/xpack/runtimefields/rest/CoreTestsWithRuntimeFieldsIT.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.runtimefields.rest;\n+\n+import com.carrotsearch.randomizedtesting.annotations.Name;\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+\n+import org.elasticsearch.index.mapper.IpFieldMapper;\n+import org.elasticsearch.index.mapper.KeywordFieldMapper;\n+import org.elasticsearch.index.mapper.NumberFieldMapper.NumberType;\n+import org.elasticsearch.test.rest.yaml.ClientYamlTestCandidate;\n+import org.elasticsearch.test.rest.yaml.ESClientYamlSuiteTestCase;\n+import org.elasticsearch.test.rest.yaml.section.DoSection;\n+import org.elasticsearch.test.rest.yaml.section.ExecutableSection;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+public class CoreTestsWithRuntimeFieldsIT extends ESClientYamlSuiteTestCase {\n+    public CoreTestsWithRuntimeFieldsIT(@Name(\"yaml\") ClientYamlTestCandidate testCandidate) {\n+        super(testCandidate);\n+    }\n+\n+    /**\n+     * Builds test parameters similarly to {@link ESClientYamlSuiteTestCase#createParameters()},\n+     * replacing the body of index creation commands so that fields are {@code runtime_script}s\n+     * that load from {@code source} instead of their original type. Test configurations that\n+     * do are not modified to contain runtime fields are not returned as they are tested\n+     * elsewhere.\n+     */\n+    @ParametersFactory\n+    public static Iterable<Object[]> parameters() throws Exception {\n+        /*\n+         * Map of \"setup\"s that we've seen - from path to whether or\n+         * not we the setup was modified to include a runtime_script\n+         */\n+        Map<String, Boolean> seenSetups = new HashMap<>();\n+        List<Object[]> result = new ArrayList<>();\n+        for (Object[] orig : ESClientYamlSuiteTestCase.createParameters()) {\n+            ClientYamlTestCandidate candidate = (ClientYamlTestCandidate) orig[0];\n+            boolean modifiedSetup = seenSetups.computeIfAbsent(\n+                candidate.getName(),\n+                k -> modifySection(candidate.getSuitePath() + \"/setup\", candidate.getSetupSection().getExecutableSections())\n+            );\n+            boolean modifiedTest = modifySection(candidate.getTestPath(), candidate.getTestSection().getExecutableSections());\n+            if (modifiedSetup || modifiedTest) {\n+                result.add(new Object[] { candidate });\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Replace property configuration in {@code indices.create} with scripts\n+     * that load from the source.\n+     * @return {@code true} if any fields were rewritten into runtime_scripts, {@code false} otherwise.\n+     */\n+    private static boolean modifySection(String sectionName, List<ExecutableSection> executables) {\n+        boolean include = false;\n+        for (ExecutableSection section : executables) {\n+            if (false == (section instanceof DoSection)) {\n+                continue;\n+            }\n+            DoSection doSection = (DoSection) section;\n+            if (false == doSection.getApiCallSection().getApi().equals(\"indices.create\")) {\n+                continue;\n+            }\n+            for (Map<?, ?> body : doSection.getApiCallSection().getBodies()) {\n+                Object settings = body.get(\"settings\");\n+                if (settings instanceof Map && containsUnsupportedSettings((Map<?, ?>) settings)) {\n+                    continue;\n+                }\n+                Object mappings = body.get(\"mappings\");\n+                if (false == (mappings instanceof Map)) {\n+                    continue;\n+                }\n+                Object properties = ((Map<?, ?>) mappings).get(\"properties\");\n+                if (false == (properties instanceof Map)) {\n+                    continue;\n+                }\n+                for (Map.Entry<?, ?> property : ((Map<?, ?>) properties).entrySet()) {\n+                    if (false == property.getValue() instanceof Map) {\n+                        continue;\n+                    }\n+                    @SuppressWarnings(\"unchecked\")\n+                    Map<String, Object> propertyMap = (Map<String, Object>) property.getValue();\n+                    String name = property.getKey().toString();\n+                    String type = Objects.toString(propertyMap.get(\"type\"));\n+                    if (\"false\".equals(Objects.toString(propertyMap.get(\"doc_values\")))) {\n+                        // If doc_values is false we can't emulate with scripts. `null` and `true` are fine.\n+                        continue;\n+                    }\n+                    if (\"false\".equals(Objects.toString(propertyMap.get(\"index\")))) {\n+                        // If index is false we can't emulate with scripts\n+                        continue;\n+                    }\n+                    if (\"true\".equals(Objects.toString(propertyMap.get(\"store\")))) {\n+                        // If store is true we can't emulate with scripts\n+                        continue;\n+                    }\n+                    if (propertyMap.containsKey(\"ignore_above\")) {\n+                        // Scripts don't support ignore_above so we skip those fields\n+                        continue;\n+                    }\n+                    if (propertyMap.containsKey(\"ignore_malformed\")) {\n+                        // Our source reading script doesn't emulate ignore_malformed\n+                        continue;\n+                    }\n+                    String toLoad = painlessToLoadFromSource(name, type);\n+                    if (toLoad == null) {\n+                        continue;\n+                    }\n+                    propertyMap.put(\"type\", \"runtime_script\");\n+                    propertyMap.put(\"runtime_type\", type);\n+                    propertyMap.put(\"script\", toLoad);\n+                    propertyMap.remove(\"store\");\n+                    propertyMap.remove(\"index\");\n+                    propertyMap.remove(\"doc_values\");\n+                    include = true;\n+                }\n+            }\n+        }\n+        return include;\n+    }\n+\n+    private static boolean containsUnsupportedSettings(Map<?, ?> settings) {\n+        return\n+        /*\n+         * You can't sort on a runtime_keyword and it is hard to figure out\n+         * if the sort was a runtime_keyword so lets just skip this test.\n+         */\n+        settings.containsKey(\"sort.field\");\n+    }\n+\n+    private static String painlessToLoadFromSource(String name, String type) {\n+        String emit = PAINLESS_TO_EMIT.get(type);\n+        if (emit == null) {\n+            return null;\n+        }\n+        StringBuilder b = new StringBuilder();\n+        b.append(\"def v = source['\").append(name).append(\"'];\\n\");\n+        b.append(\"if (v instanceof Iterable) {\\n\");\n+        b.append(\"  for (def vv : ((Iterable) v)) {\\n\");\n+        b.append(\"    if (vv != null) {\\n\");\n+        b.append(\"      def value = vv;\\n\");\n+        b.append(\"      \").append(emit).append(\"\\n\");\n+        b.append(\"    }\\n\");\n+        b.append(\"  }\\n\");\n+        b.append(\"} else {\\n\");\n+        b.append(\"  if (v != null) {\\n\");\n+        b.append(\"    def value = v;\\n\");\n+        b.append(\"    \").append(emit).append(\"\\n\");\n+        b.append(\"  }\\n\");\n+        b.append(\"}\\n\");\n+        return b.toString();\n+    }\n+\n+    private static final Map<String, String> PAINLESS_TO_EMIT = Map.ofEntries(\n+        // TODO implement dates against the parser\n+        Map.entry(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b392332ced3a2f896b962453b45600c397ef7602"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU5NTcyMg==", "bodyText": "It really is pretty fragile. I was thinking of something similar to what you said - steal the source parsing and expose it to the script. That wouldn't be a \"painless feature\" so much as a feature of the script context of the runtime field. The advantage of this is that I know exactly which runtime field I'm running against so, for example, dates could use the the field's date parsing logic.", "url": "https://github.com/elastic/elasticsearch/pull/60931#discussion_r468595722", "createdAt": "2020-08-11T13:52:20Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/runtime-fields/qa/rest/src/yamlRestTest/java/org/elasticsearch/xpack/runtimefields/rest/CoreTestsWithRuntimeFieldsIT.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.runtimefields.rest;\n+\n+import com.carrotsearch.randomizedtesting.annotations.Name;\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+\n+import org.elasticsearch.index.mapper.IpFieldMapper;\n+import org.elasticsearch.index.mapper.KeywordFieldMapper;\n+import org.elasticsearch.index.mapper.NumberFieldMapper.NumberType;\n+import org.elasticsearch.test.rest.yaml.ClientYamlTestCandidate;\n+import org.elasticsearch.test.rest.yaml.ESClientYamlSuiteTestCase;\n+import org.elasticsearch.test.rest.yaml.section.DoSection;\n+import org.elasticsearch.test.rest.yaml.section.ExecutableSection;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+public class CoreTestsWithRuntimeFieldsIT extends ESClientYamlSuiteTestCase {\n+    public CoreTestsWithRuntimeFieldsIT(@Name(\"yaml\") ClientYamlTestCandidate testCandidate) {\n+        super(testCandidate);\n+    }\n+\n+    /**\n+     * Builds test parameters similarly to {@link ESClientYamlSuiteTestCase#createParameters()},\n+     * replacing the body of index creation commands so that fields are {@code runtime_script}s\n+     * that load from {@code source} instead of their original type. Test configurations that\n+     * do are not modified to contain runtime fields are not returned as they are tested\n+     * elsewhere.\n+     */\n+    @ParametersFactory\n+    public static Iterable<Object[]> parameters() throws Exception {\n+        /*\n+         * Map of \"setup\"s that we've seen - from path to whether or\n+         * not we the setup was modified to include a runtime_script\n+         */\n+        Map<String, Boolean> seenSetups = new HashMap<>();\n+        List<Object[]> result = new ArrayList<>();\n+        for (Object[] orig : ESClientYamlSuiteTestCase.createParameters()) {\n+            ClientYamlTestCandidate candidate = (ClientYamlTestCandidate) orig[0];\n+            boolean modifiedSetup = seenSetups.computeIfAbsent(\n+                candidate.getName(),\n+                k -> modifySection(candidate.getSuitePath() + \"/setup\", candidate.getSetupSection().getExecutableSections())\n+            );\n+            boolean modifiedTest = modifySection(candidate.getTestPath(), candidate.getTestSection().getExecutableSections());\n+            if (modifiedSetup || modifiedTest) {\n+                result.add(new Object[] { candidate });\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Replace property configuration in {@code indices.create} with scripts\n+     * that load from the source.\n+     * @return {@code true} if any fields were rewritten into runtime_scripts, {@code false} otherwise.\n+     */\n+    private static boolean modifySection(String sectionName, List<ExecutableSection> executables) {\n+        boolean include = false;\n+        for (ExecutableSection section : executables) {\n+            if (false == (section instanceof DoSection)) {\n+                continue;\n+            }\n+            DoSection doSection = (DoSection) section;\n+            if (false == doSection.getApiCallSection().getApi().equals(\"indices.create\")) {\n+                continue;\n+            }\n+            for (Map<?, ?> body : doSection.getApiCallSection().getBodies()) {\n+                Object settings = body.get(\"settings\");\n+                if (settings instanceof Map && containsUnsupportedSettings((Map<?, ?>) settings)) {\n+                    continue;\n+                }\n+                Object mappings = body.get(\"mappings\");\n+                if (false == (mappings instanceof Map)) {\n+                    continue;\n+                }\n+                Object properties = ((Map<?, ?>) mappings).get(\"properties\");\n+                if (false == (properties instanceof Map)) {\n+                    continue;\n+                }\n+                for (Map.Entry<?, ?> property : ((Map<?, ?>) properties).entrySet()) {\n+                    if (false == property.getValue() instanceof Map) {\n+                        continue;\n+                    }\n+                    @SuppressWarnings(\"unchecked\")\n+                    Map<String, Object> propertyMap = (Map<String, Object>) property.getValue();\n+                    String name = property.getKey().toString();\n+                    String type = Objects.toString(propertyMap.get(\"type\"));\n+                    if (\"false\".equals(Objects.toString(propertyMap.get(\"doc_values\")))) {\n+                        // If doc_values is false we can't emulate with scripts. `null` and `true` are fine.\n+                        continue;\n+                    }\n+                    if (\"false\".equals(Objects.toString(propertyMap.get(\"index\")))) {\n+                        // If index is false we can't emulate with scripts\n+                        continue;\n+                    }\n+                    if (\"true\".equals(Objects.toString(propertyMap.get(\"store\")))) {\n+                        // If store is true we can't emulate with scripts\n+                        continue;\n+                    }\n+                    if (propertyMap.containsKey(\"ignore_above\")) {\n+                        // Scripts don't support ignore_above so we skip those fields\n+                        continue;\n+                    }\n+                    if (propertyMap.containsKey(\"ignore_malformed\")) {\n+                        // Our source reading script doesn't emulate ignore_malformed\n+                        continue;\n+                    }\n+                    String toLoad = painlessToLoadFromSource(name, type);\n+                    if (toLoad == null) {\n+                        continue;\n+                    }\n+                    propertyMap.put(\"type\", \"runtime_script\");\n+                    propertyMap.put(\"runtime_type\", type);\n+                    propertyMap.put(\"script\", toLoad);\n+                    propertyMap.remove(\"store\");\n+                    propertyMap.remove(\"index\");\n+                    propertyMap.remove(\"doc_values\");\n+                    include = true;\n+                }\n+            }\n+        }\n+        return include;\n+    }\n+\n+    private static boolean containsUnsupportedSettings(Map<?, ?> settings) {\n+        return\n+        /*\n+         * You can't sort on a runtime_keyword and it is hard to figure out\n+         * if the sort was a runtime_keyword so lets just skip this test.\n+         */\n+        settings.containsKey(\"sort.field\");\n+    }\n+\n+    private static String painlessToLoadFromSource(String name, String type) {\n+        String emit = PAINLESS_TO_EMIT.get(type);\n+        if (emit == null) {\n+            return null;\n+        }\n+        StringBuilder b = new StringBuilder();\n+        b.append(\"def v = source['\").append(name).append(\"'];\\n\");\n+        b.append(\"if (v instanceof Iterable) {\\n\");\n+        b.append(\"  for (def vv : ((Iterable) v)) {\\n\");\n+        b.append(\"    if (vv != null) {\\n\");\n+        b.append(\"      def value = vv;\\n\");\n+        b.append(\"      \").append(emit).append(\"\\n\");\n+        b.append(\"    }\\n\");\n+        b.append(\"  }\\n\");\n+        b.append(\"} else {\\n\");\n+        b.append(\"  if (v != null) {\\n\");\n+        b.append(\"    def value = v;\\n\");\n+        b.append(\"    \").append(emit).append(\"\\n\");\n+        b.append(\"  }\\n\");\n+        b.append(\"}\\n\");\n+        return b.toString();\n+    }\n+\n+    private static final Map<String, String> PAINLESS_TO_EMIT = Map.ofEntries(\n+        // TODO implement dates against the parser\n+        Map.entry(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE5MjM5Ng=="}, "originalCommit": {"oid": "b392332ced3a2f896b962453b45600c397ef7602"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY5MTA4MQ==", "bodyText": "That makes sense. I think this is the right way to go for this feature branch, but it'd be good to follow-up on source parsing improvements at a later point.", "url": "https://github.com/elastic/elasticsearch/pull/60931#discussion_r468691081", "createdAt": "2020-08-11T15:59:36Z", "author": {"login": "jtibshirani"}, "path": "x-pack/plugin/runtime-fields/qa/rest/src/yamlRestTest/java/org/elasticsearch/xpack/runtimefields/rest/CoreTestsWithRuntimeFieldsIT.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.runtimefields.rest;\n+\n+import com.carrotsearch.randomizedtesting.annotations.Name;\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+\n+import org.elasticsearch.index.mapper.IpFieldMapper;\n+import org.elasticsearch.index.mapper.KeywordFieldMapper;\n+import org.elasticsearch.index.mapper.NumberFieldMapper.NumberType;\n+import org.elasticsearch.test.rest.yaml.ClientYamlTestCandidate;\n+import org.elasticsearch.test.rest.yaml.ESClientYamlSuiteTestCase;\n+import org.elasticsearch.test.rest.yaml.section.DoSection;\n+import org.elasticsearch.test.rest.yaml.section.ExecutableSection;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+public class CoreTestsWithRuntimeFieldsIT extends ESClientYamlSuiteTestCase {\n+    public CoreTestsWithRuntimeFieldsIT(@Name(\"yaml\") ClientYamlTestCandidate testCandidate) {\n+        super(testCandidate);\n+    }\n+\n+    /**\n+     * Builds test parameters similarly to {@link ESClientYamlSuiteTestCase#createParameters()},\n+     * replacing the body of index creation commands so that fields are {@code runtime_script}s\n+     * that load from {@code source} instead of their original type. Test configurations that\n+     * do are not modified to contain runtime fields are not returned as they are tested\n+     * elsewhere.\n+     */\n+    @ParametersFactory\n+    public static Iterable<Object[]> parameters() throws Exception {\n+        /*\n+         * Map of \"setup\"s that we've seen - from path to whether or\n+         * not we the setup was modified to include a runtime_script\n+         */\n+        Map<String, Boolean> seenSetups = new HashMap<>();\n+        List<Object[]> result = new ArrayList<>();\n+        for (Object[] orig : ESClientYamlSuiteTestCase.createParameters()) {\n+            ClientYamlTestCandidate candidate = (ClientYamlTestCandidate) orig[0];\n+            boolean modifiedSetup = seenSetups.computeIfAbsent(\n+                candidate.getName(),\n+                k -> modifySection(candidate.getSuitePath() + \"/setup\", candidate.getSetupSection().getExecutableSections())\n+            );\n+            boolean modifiedTest = modifySection(candidate.getTestPath(), candidate.getTestSection().getExecutableSections());\n+            if (modifiedSetup || modifiedTest) {\n+                result.add(new Object[] { candidate });\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Replace property configuration in {@code indices.create} with scripts\n+     * that load from the source.\n+     * @return {@code true} if any fields were rewritten into runtime_scripts, {@code false} otherwise.\n+     */\n+    private static boolean modifySection(String sectionName, List<ExecutableSection> executables) {\n+        boolean include = false;\n+        for (ExecutableSection section : executables) {\n+            if (false == (section instanceof DoSection)) {\n+                continue;\n+            }\n+            DoSection doSection = (DoSection) section;\n+            if (false == doSection.getApiCallSection().getApi().equals(\"indices.create\")) {\n+                continue;\n+            }\n+            for (Map<?, ?> body : doSection.getApiCallSection().getBodies()) {\n+                Object settings = body.get(\"settings\");\n+                if (settings instanceof Map && containsUnsupportedSettings((Map<?, ?>) settings)) {\n+                    continue;\n+                }\n+                Object mappings = body.get(\"mappings\");\n+                if (false == (mappings instanceof Map)) {\n+                    continue;\n+                }\n+                Object properties = ((Map<?, ?>) mappings).get(\"properties\");\n+                if (false == (properties instanceof Map)) {\n+                    continue;\n+                }\n+                for (Map.Entry<?, ?> property : ((Map<?, ?>) properties).entrySet()) {\n+                    if (false == property.getValue() instanceof Map) {\n+                        continue;\n+                    }\n+                    @SuppressWarnings(\"unchecked\")\n+                    Map<String, Object> propertyMap = (Map<String, Object>) property.getValue();\n+                    String name = property.getKey().toString();\n+                    String type = Objects.toString(propertyMap.get(\"type\"));\n+                    if (\"false\".equals(Objects.toString(propertyMap.get(\"doc_values\")))) {\n+                        // If doc_values is false we can't emulate with scripts. `null` and `true` are fine.\n+                        continue;\n+                    }\n+                    if (\"false\".equals(Objects.toString(propertyMap.get(\"index\")))) {\n+                        // If index is false we can't emulate with scripts\n+                        continue;\n+                    }\n+                    if (\"true\".equals(Objects.toString(propertyMap.get(\"store\")))) {\n+                        // If store is true we can't emulate with scripts\n+                        continue;\n+                    }\n+                    if (propertyMap.containsKey(\"ignore_above\")) {\n+                        // Scripts don't support ignore_above so we skip those fields\n+                        continue;\n+                    }\n+                    if (propertyMap.containsKey(\"ignore_malformed\")) {\n+                        // Our source reading script doesn't emulate ignore_malformed\n+                        continue;\n+                    }\n+                    String toLoad = painlessToLoadFromSource(name, type);\n+                    if (toLoad == null) {\n+                        continue;\n+                    }\n+                    propertyMap.put(\"type\", \"runtime_script\");\n+                    propertyMap.put(\"runtime_type\", type);\n+                    propertyMap.put(\"script\", toLoad);\n+                    propertyMap.remove(\"store\");\n+                    propertyMap.remove(\"index\");\n+                    propertyMap.remove(\"doc_values\");\n+                    include = true;\n+                }\n+            }\n+        }\n+        return include;\n+    }\n+\n+    private static boolean containsUnsupportedSettings(Map<?, ?> settings) {\n+        return\n+        /*\n+         * You can't sort on a runtime_keyword and it is hard to figure out\n+         * if the sort was a runtime_keyword so lets just skip this test.\n+         */\n+        settings.containsKey(\"sort.field\");\n+    }\n+\n+    private static String painlessToLoadFromSource(String name, String type) {\n+        String emit = PAINLESS_TO_EMIT.get(type);\n+        if (emit == null) {\n+            return null;\n+        }\n+        StringBuilder b = new StringBuilder();\n+        b.append(\"def v = source['\").append(name).append(\"'];\\n\");\n+        b.append(\"if (v instanceof Iterable) {\\n\");\n+        b.append(\"  for (def vv : ((Iterable) v)) {\\n\");\n+        b.append(\"    if (vv != null) {\\n\");\n+        b.append(\"      def value = vv;\\n\");\n+        b.append(\"      \").append(emit).append(\"\\n\");\n+        b.append(\"    }\\n\");\n+        b.append(\"  }\\n\");\n+        b.append(\"} else {\\n\");\n+        b.append(\"  if (v != null) {\\n\");\n+        b.append(\"    def value = v;\\n\");\n+        b.append(\"    \").append(emit).append(\"\\n\");\n+        b.append(\"  }\\n\");\n+        b.append(\"}\\n\");\n+        return b.toString();\n+    }\n+\n+    private static final Map<String, String> PAINLESS_TO_EMIT = Map.ofEntries(\n+        // TODO implement dates against the parser\n+        Map.entry(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE5MjM5Ng=="}, "originalCommit": {"oid": "b392332ced3a2f896b962453b45600c397ef7602"}, "originalPosition": 167}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyODQyNzQ1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/runtime-fields/qa/rest/src/yamlRestTest/java/org/elasticsearch/xpack/runtimefields/rest/CoreTestsWithRuntimeFieldsIT.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNTo1NjozOVrOG--hCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNjoxMjo0OFrOG-_KEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY4OTE2Mg==", "bodyText": "Small comment, we could say 'index sort' for clarity?", "url": "https://github.com/elastic/elasticsearch/pull/60931#discussion_r468689162", "createdAt": "2020-08-11T15:56:39Z", "author": {"login": "jtibshirani"}, "path": "x-pack/plugin/runtime-fields/qa/rest/src/yamlRestTest/java/org/elasticsearch/xpack/runtimefields/rest/CoreTestsWithRuntimeFieldsIT.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.runtimefields.rest;\n+\n+import com.carrotsearch.randomizedtesting.annotations.Name;\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+\n+import org.elasticsearch.index.mapper.IpFieldMapper;\n+import org.elasticsearch.index.mapper.KeywordFieldMapper;\n+import org.elasticsearch.index.mapper.NumberFieldMapper.NumberType;\n+import org.elasticsearch.test.rest.yaml.ClientYamlTestCandidate;\n+import org.elasticsearch.test.rest.yaml.ESClientYamlSuiteTestCase;\n+import org.elasticsearch.test.rest.yaml.section.DoSection;\n+import org.elasticsearch.test.rest.yaml.section.ExecutableSection;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+public class CoreTestsWithRuntimeFieldsIT extends ESClientYamlSuiteTestCase {\n+    public CoreTestsWithRuntimeFieldsIT(@Name(\"yaml\") ClientYamlTestCandidate testCandidate) {\n+        super(testCandidate);\n+    }\n+\n+    /**\n+     * Builds test parameters similarly to {@link ESClientYamlSuiteTestCase#createParameters()},\n+     * replacing the body of index creation commands so that fields are {@code runtime_script}s\n+     * that load from {@code source} instead of their original type. Test configurations that\n+     * do are not modified to contain runtime fields are not returned as they are tested\n+     * elsewhere.\n+     */\n+    @ParametersFactory\n+    public static Iterable<Object[]> parameters() throws Exception {\n+        /*\n+         * Map of \"setup\"s that we've seen - from path to whether or\n+         * not we the setup was modified to include a runtime_script\n+         */\n+        Map<String, Boolean> seenSetups = new HashMap<>();\n+        List<Object[]> result = new ArrayList<>();\n+        for (Object[] orig : ESClientYamlSuiteTestCase.createParameters()) {\n+            assert orig.length == 1;\n+            ClientYamlTestCandidate candidate = (ClientYamlTestCandidate) orig[0];\n+            boolean modifiedSetup = seenSetups.computeIfAbsent(\n+                candidate.getName(),\n+                k -> modifySection(candidate.getSuitePath() + \"/setup\", candidate.getSetupSection().getExecutableSections())\n+            );\n+            boolean modifiedTest = modifySection(candidate.getTestPath(), candidate.getTestSection().getExecutableSections());\n+            if (modifiedSetup || modifiedTest) {\n+                result.add(new Object[] { candidate });\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Replace property configuration in {@code indices.create} with scripts\n+     * that load from the source.\n+     * @return {@code true} if any fields were rewritten into runtime_scripts, {@code false} otherwise.\n+     */\n+    private static boolean modifySection(String sectionName, List<ExecutableSection> executables) {\n+        boolean include = false;\n+        for (ExecutableSection section : executables) {\n+            if (false == (section instanceof DoSection)) {\n+                continue;\n+            }\n+            DoSection doSection = (DoSection) section;\n+            if (false == doSection.getApiCallSection().getApi().equals(\"indices.create\")) {\n+                continue;\n+            }\n+            for (Map<?, ?> body : doSection.getApiCallSection().getBodies()) {\n+                Object settings = body.get(\"settings\");\n+                if (settings instanceof Map && ((Map<?, ?>) settings).containsKey(\"sort.field\")) {\n+                    /*\n+                     * You can't sort on a runtime_keyword and it is hard to figure out", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eccfcdbc357f72044d8724bdd7e73c9904b8b0c"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY5OTY2NA==", "bodyText": "++", "url": "https://github.com/elastic/elasticsearch/pull/60931#discussion_r468699664", "createdAt": "2020-08-11T16:12:48Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/runtime-fields/qa/rest/src/yamlRestTest/java/org/elasticsearch/xpack/runtimefields/rest/CoreTestsWithRuntimeFieldsIT.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.runtimefields.rest;\n+\n+import com.carrotsearch.randomizedtesting.annotations.Name;\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+\n+import org.elasticsearch.index.mapper.IpFieldMapper;\n+import org.elasticsearch.index.mapper.KeywordFieldMapper;\n+import org.elasticsearch.index.mapper.NumberFieldMapper.NumberType;\n+import org.elasticsearch.test.rest.yaml.ClientYamlTestCandidate;\n+import org.elasticsearch.test.rest.yaml.ESClientYamlSuiteTestCase;\n+import org.elasticsearch.test.rest.yaml.section.DoSection;\n+import org.elasticsearch.test.rest.yaml.section.ExecutableSection;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+public class CoreTestsWithRuntimeFieldsIT extends ESClientYamlSuiteTestCase {\n+    public CoreTestsWithRuntimeFieldsIT(@Name(\"yaml\") ClientYamlTestCandidate testCandidate) {\n+        super(testCandidate);\n+    }\n+\n+    /**\n+     * Builds test parameters similarly to {@link ESClientYamlSuiteTestCase#createParameters()},\n+     * replacing the body of index creation commands so that fields are {@code runtime_script}s\n+     * that load from {@code source} instead of their original type. Test configurations that\n+     * do are not modified to contain runtime fields are not returned as they are tested\n+     * elsewhere.\n+     */\n+    @ParametersFactory\n+    public static Iterable<Object[]> parameters() throws Exception {\n+        /*\n+         * Map of \"setup\"s that we've seen - from path to whether or\n+         * not we the setup was modified to include a runtime_script\n+         */\n+        Map<String, Boolean> seenSetups = new HashMap<>();\n+        List<Object[]> result = new ArrayList<>();\n+        for (Object[] orig : ESClientYamlSuiteTestCase.createParameters()) {\n+            assert orig.length == 1;\n+            ClientYamlTestCandidate candidate = (ClientYamlTestCandidate) orig[0];\n+            boolean modifiedSetup = seenSetups.computeIfAbsent(\n+                candidate.getName(),\n+                k -> modifySection(candidate.getSuitePath() + \"/setup\", candidate.getSetupSection().getExecutableSections())\n+            );\n+            boolean modifiedTest = modifySection(candidate.getTestPath(), candidate.getTestSection().getExecutableSections());\n+            if (modifiedSetup || modifiedTest) {\n+                result.add(new Object[] { candidate });\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Replace property configuration in {@code indices.create} with scripts\n+     * that load from the source.\n+     * @return {@code true} if any fields were rewritten into runtime_scripts, {@code false} otherwise.\n+     */\n+    private static boolean modifySection(String sectionName, List<ExecutableSection> executables) {\n+        boolean include = false;\n+        for (ExecutableSection section : executables) {\n+            if (false == (section instanceof DoSection)) {\n+                continue;\n+            }\n+            DoSection doSection = (DoSection) section;\n+            if (false == doSection.getApiCallSection().getApi().equals(\"indices.create\")) {\n+                continue;\n+            }\n+            for (Map<?, ?> body : doSection.getApiCallSection().getBodies()) {\n+                Object settings = body.get(\"settings\");\n+                if (settings instanceof Map && ((Map<?, ?>) settings).containsKey(\"sort.field\")) {\n+                    /*\n+                     * You can't sort on a runtime_keyword and it is hard to figure out", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY4OTE2Mg=="}, "originalCommit": {"oid": "5eccfcdbc357f72044d8724bdd7e73c9904b8b0c"}, "originalPosition": 80}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2537, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}