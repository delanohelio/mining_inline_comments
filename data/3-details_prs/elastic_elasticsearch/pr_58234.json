{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM1NzQ0MTY0", "number": 58234, "title": "Improved ExtensiblePlugin", "bodyText": "Rather than let ExtensiblePlugins know extending plugins' classloaders,\nwe now pass along an explicit ExtensionLoader that loads the extensions\nasked for. Extensions constructed that way can optionally receive their\nown Plugin instance in the constructor.\nA demonstration that this works for adding an ML decider for autoscaling is here\nThis also demonstrates one possible solution to loading extensions in integration tests\nbut I would prefer to tackle that in a follow-up.", "createdAt": "2020-06-17T10:05:48Z", "url": "https://github.com/elastic/elasticsearch/pull/58234", "merged": true, "mergeCommit": {"oid": "3ff6e83f0044b78a6e0e55be3b8d69e7df7c122a"}, "closed": true, "closedAt": "2020-06-25T11:39:04Z", "author": {"login": "henningandersen"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcsG227AH2gAyNDM1NzQ0MTY0OjlhZjM1N2I4MzIwMDMwNWExNzhiYjQ4ZWI5Y2M3YzI1N2MxZmRjNjI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcuqKdRAH2gAyNDM1NzQ0MTY0Ojg4MTdmZTQ3NWZhYmQyZGY1NjljMzExZGQ0Mzc3NWFmYjJhMGYyNzA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "9af357b83200305a178bb48eb9cc7c257c1fdc62", "author": {"user": {"login": "henningandersen", "name": "Henning Andersen"}}, "url": "https://github.com/elastic/elasticsearch/commit/9af357b83200305a178bb48eb9cc7c257c1fdc62", "committedDate": "2020-06-17T09:58:06Z", "message": "Improved ExtensiblePlugin\n\nRather than let ExtensiblePlugins know extending plugins' classloaders,\nwe now pass along an explicit ExtensionLoader that loads the extensions\nasked for. Extensions constructed that way can optionally receive their\nown Plugin instance in the constructor."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cdf98d2851094f3aa9ae9db4a6dac7e23940bbbd", "author": {"user": {"login": "henningandersen", "name": "Henning Andersen"}}, "url": "https://github.com/elastic/elasticsearch/commit/cdf98d2851094f3aa9ae9db4a6dac7e23940bbbd", "committedDate": "2020-06-17T11:04:35Z", "message": "Fix Security.java"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNzE5Njgw", "url": "https://github.com/elastic/elasticsearch/pull/58234#pullrequestreview-433719680", "createdAt": "2020-06-18T23:55:05Z", "commit": {"oid": "cdf98d2851094f3aa9ae9db4a6dac7e23940bbbd"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMzo1NTowNlrOGmDyWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwMDowOToxNlrOGmEAxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU2MTExNQ==", "bodyText": "We have a utility method for this instanceof pattern, filterPlugins. I think it would also be clearer to use a normal for loop rather than forEach?", "url": "https://github.com/elastic/elasticsearch/pull/58234#discussion_r442561115", "createdAt": "2020-06-18T23:55:06Z", "author": {"login": "rjernst"}, "path": "server/src/main/java/org/elasticsearch/plugins/PluginsService.java", "diffHunk": "@@ -426,17 +429,66 @@ private static void addSortedBundle(Bundle bundle, Map<String, Bundle> bundles,\n         Map<String, Plugin> loaded = new HashMap<>();\n         Map<String, Set<URL>> transitiveUrls = new HashMap<>();\n         List<Bundle> sortedBundles = sortBundles(bundles);\n-\n         for (Bundle bundle : sortedBundles) {\n             checkBundleJarHell(JarHell.parseClassPath(), bundle, transitiveUrls);\n \n             final Plugin plugin = loadBundle(bundle, loaded);\n             plugins.add(new Tuple<>(bundle.plugin, plugin));\n         }\n \n+        loadExtensions(plugins);\n         return Collections.unmodifiableList(plugins);\n     }\n \n+    // package-private for test visibility\n+    static void loadExtensions(List<Tuple<PluginInfo, Plugin>> plugins) {\n+        Map<String, List<Plugin>> extendingPlugins = plugins.stream()\n+            .flatMap(t -> t.v1().getExtendedPlugins().stream().map(extendedPlugin -> Tuple.tuple(extendedPlugin, t.v2())))\n+            .collect(Collectors.groupingBy(Tuple::v1, Collectors.mapping(Tuple::v2, Collectors.toList())));\n+        plugins.stream().filter(t -> t.v2() instanceof ExtensiblePlugin).forEach(t -> loadExtensionsForPlugin((ExtensiblePlugin) t.v2(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cdf98d2851094f3aa9ae9db4a6dac7e23940bbbd"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU2MjgwNQ==", "bodyText": "This could just be created in loadExtensions, no need to create a new one for each individual plugin? AFAICT it always operates on the same stream of plugins passed in.", "url": "https://github.com/elastic/elasticsearch/pull/58234#discussion_r442562805", "createdAt": "2020-06-19T00:01:22Z", "author": {"login": "rjernst"}, "path": "server/src/main/java/org/elasticsearch/plugins/PluginsService.java", "diffHunk": "@@ -426,17 +429,66 @@ private static void addSortedBundle(Bundle bundle, Map<String, Bundle> bundles,\n         Map<String, Plugin> loaded = new HashMap<>();\n         Map<String, Set<URL>> transitiveUrls = new HashMap<>();\n         List<Bundle> sortedBundles = sortBundles(bundles);\n-\n         for (Bundle bundle : sortedBundles) {\n             checkBundleJarHell(JarHell.parseClassPath(), bundle, transitiveUrls);\n \n             final Plugin plugin = loadBundle(bundle, loaded);\n             plugins.add(new Tuple<>(bundle.plugin, plugin));\n         }\n \n+        loadExtensions(plugins);\n         return Collections.unmodifiableList(plugins);\n     }\n \n+    // package-private for test visibility\n+    static void loadExtensions(List<Tuple<PluginInfo, Plugin>> plugins) {\n+        Map<String, List<Plugin>> extendingPlugins = plugins.stream()\n+            .flatMap(t -> t.v1().getExtendedPlugins().stream().map(extendedPlugin -> Tuple.tuple(extendedPlugin, t.v2())))\n+            .collect(Collectors.groupingBy(Tuple::v1, Collectors.mapping(Tuple::v2, Collectors.toList())));\n+        plugins.stream().filter(t -> t.v2() instanceof ExtensiblePlugin).forEach(t -> loadExtensionsForPlugin((ExtensiblePlugin) t.v2(),\n+            extendingPlugins.getOrDefault(t.v1().getName(), List.of())));\n+    }\n+\n+    private static void loadExtensionsForPlugin(ExtensiblePlugin extensiblePlugin, List<Plugin> extendingPlugins) {\n+        ExtensiblePlugin.ExtensionLoader extensionLoader = new ExtensiblePlugin.ExtensionLoader() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cdf98d2851094f3aa9ae9db4a6dac7e23940bbbd"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU2MzY4Nw==", "bodyText": "Why a stream? It seems to lend itself to longer lines, but not easier to read code in this case, especially in the implementation below", "url": "https://github.com/elastic/elasticsearch/pull/58234#discussion_r442563687", "createdAt": "2020-06-19T00:04:38Z", "author": {"login": "rjernst"}, "path": "server/src/main/java/org/elasticsearch/plugins/ExtensiblePlugin.java", "diffHunk": "@@ -27,8 +29,22 @@\n  */\n public interface ExtensiblePlugin {\n \n+    interface ExtensionLoader {\n+        /**\n+         * Load extensions of the type from all extending plugins. The concrete extensions must have either a no-arg constructor\n+         * or a single-arg constructor accepting the specific plugin class.\n+         * @param extensionPointType the extension point type\n+         * @param <T> extension point type\n+         * @return stream of all implementing extensions.\n+         */\n+        <T> Stream<T> loadExtensions(Class<T> extensionPointType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cdf98d2851094f3aa9ae9db4a6dac7e23940bbbd"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU2MzkzMA==", "bodyText": "I think we should lookup constructors just like in loadPlugin, rather than using exceptions as control flow here. The suppressed exception in the case we use the zero arg constructor would be especially confusing.", "url": "https://github.com/elastic/elasticsearch/pull/58234#discussion_r442563930", "createdAt": "2020-06-19T00:05:42Z", "author": {"login": "rjernst"}, "path": "server/src/main/java/org/elasticsearch/plugins/PluginsService.java", "diffHunk": "@@ -426,17 +429,66 @@ private static void addSortedBundle(Bundle bundle, Map<String, Bundle> bundles,\n         Map<String, Plugin> loaded = new HashMap<>();\n         Map<String, Set<URL>> transitiveUrls = new HashMap<>();\n         List<Bundle> sortedBundles = sortBundles(bundles);\n-\n         for (Bundle bundle : sortedBundles) {\n             checkBundleJarHell(JarHell.parseClassPath(), bundle, transitiveUrls);\n \n             final Plugin plugin = loadBundle(bundle, loaded);\n             plugins.add(new Tuple<>(bundle.plugin, plugin));\n         }\n \n+        loadExtensions(plugins);\n         return Collections.unmodifiableList(plugins);\n     }\n \n+    // package-private for test visibility\n+    static void loadExtensions(List<Tuple<PluginInfo, Plugin>> plugins) {\n+        Map<String, List<Plugin>> extendingPlugins = plugins.stream()\n+            .flatMap(t -> t.v1().getExtendedPlugins().stream().map(extendedPlugin -> Tuple.tuple(extendedPlugin, t.v2())))\n+            .collect(Collectors.groupingBy(Tuple::v1, Collectors.mapping(Tuple::v2, Collectors.toList())));\n+        plugins.stream().filter(t -> t.v2() instanceof ExtensiblePlugin).forEach(t -> loadExtensionsForPlugin((ExtensiblePlugin) t.v2(),\n+            extendingPlugins.getOrDefault(t.v1().getName(), List.of())));\n+    }\n+\n+    private static void loadExtensionsForPlugin(ExtensiblePlugin extensiblePlugin, List<Plugin> extendingPlugins) {\n+        ExtensiblePlugin.ExtensionLoader extensionLoader = new ExtensiblePlugin.ExtensionLoader() {\n+            @Override\n+            public <T> Stream<T> loadExtensions(Class<T> extensionPointType) {\n+                return extendingPlugins.stream().flatMap(plugin -> createExtensions(extensionPointType, plugin));\n+            }\n+        };\n+\n+        extensiblePlugin.loadExtensions(extensionLoader);\n+    }\n+\n+    private static <T> Stream<? extends T> createExtensions(Class<T> extensionPointType, Plugin plugin) {\n+        SPIClassIterator<T> classIterator = SPIClassIterator.get(extensionPointType, plugin.getClass().getClassLoader());\n+        List<T> extensions = new ArrayList<>();\n+        while (classIterator.hasNext()) {\n+            Class<? extends T> extensionClass = classIterator.next();\n+            extensions.add(createExtension(extensionClass, plugin, extensionPointType));\n+        }\n+        return extensions.stream();\n+    }\n+\n+    private static <T> T createExtension(Class<? extends T> extensionClass, Plugin plugin, Class<T> extensionPointType) {\n+        try {\n+            try {\n+                return extensionClass.getConstructor(plugin.getClass()).newInstance(plugin);\n+            } catch (NoSuchMethodException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cdf98d2851094f3aa9ae9db4a6dac7e23940bbbd"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU2NDU2NA==", "bodyText": "When can this happen?", "url": "https://github.com/elastic/elasticsearch/pull/58234#discussion_r442564564", "createdAt": "2020-06-19T00:08:14Z", "author": {"login": "rjernst"}, "path": "server/src/main/java/org/elasticsearch/plugins/PluginsService.java", "diffHunk": "@@ -509,12 +561,13 @@ private Plugin loadBundle(Bundle bundle, Map<String, Plugin> loaded) {\n \n         // reload SPI with any new services from the plugin\n         reloadLuceneSPI(loader);\n-        for (String extendedPluginName : bundle.plugin.getExtendedPlugins()) {\n-            // note: already asserted above that extended plugins are loaded and extensible\n-            ExtensiblePlugin.class.cast(loaded.get(extendedPluginName)).reloadSPI(loader);\n-        }\n \n         Class<? extends Plugin> pluginClass = loadPluginClass(bundle.plugin.getClassname(), loader);\n+        if (loader != pluginClass.getClassLoader()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cdf98d2851094f3aa9ae9db4a6dac7e23940bbbd"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU2NDgwNA==", "bodyText": "Can we have some tests for the error cases? For example, no valid ctor exists, or we fail when calling the ctor?", "url": "https://github.com/elastic/elasticsearch/pull/58234#discussion_r442564804", "createdAt": "2020-06-19T00:09:16Z", "author": {"login": "rjernst"}, "path": "server/src/test/java/org/elasticsearch/plugins/PluginsServiceTests.java", "diffHunk": "@@ -690,4 +695,54 @@ public void testExistingMandatoryInstalledPlugin() throws IOException {\n                         .build();\n         newPluginsService(settings);\n     }\n+\n+    public void testExtensiblePlugin() {\n+        TestExtensiblePlugin extensiblePlugin = new TestExtensiblePlugin();\n+        PluginsService.loadExtensions(List.of(\n+            Tuple.tuple(new PluginInfo(\"extensible\", null, null, null, null, null, List.of(), false), extensiblePlugin)\n+        ));\n+\n+        assertThat(extensiblePlugin.extensions, notNullValue());\n+        assertThat(extensiblePlugin.extensions, hasSize(0));\n+\n+        extensiblePlugin = new TestExtensiblePlugin();\n+        TestPlugin testPlugin = new TestPlugin();\n+        PluginsService.loadExtensions(List.of(\n+            Tuple.tuple(new PluginInfo(\"extensible\", null, null, null, null, null, List.of(), false), extensiblePlugin),\n+            Tuple.tuple(new PluginInfo(\"test\", null, null, null, null, null, List.of(\"extensible\"), false), testPlugin)\n+        ));\n+\n+        assertThat(extensiblePlugin.extensions, notNullValue());\n+        assertThat(extensiblePlugin.extensions, hasSize(2));\n+        assertThat(extensiblePlugin.extensions.get(0), instanceOf(TestExtension1.class));\n+        assertThat(extensiblePlugin.extensions.get(1), instanceOf(TestExtension2.class));\n+        assertThat(((TestExtension2) extensiblePlugin.extensions.get(1)).plugin, sameInstance(testPlugin));\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cdf98d2851094f3aa9ae9db4a6dac7e23940bbbd"}, "originalPosition": 54}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "58e39e75e8334f49346a3ff2d7cab21afcefb06f", "author": {"user": {"login": "henningandersen", "name": "Henning Andersen"}}, "url": "https://github.com/elastic/elasticsearch/commit/58e39e75e8334f49346a3ff2d7cab21afcefb06f", "committedDate": "2020-06-23T08:59:06Z", "message": "Nicer errors on bad constructors."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a261f6c599e0a048d11617f8cb985fa5968fda6a", "author": {"user": {"login": "henningandersen", "name": "Henning Andersen"}}, "url": "https://github.com/elastic/elasticsearch/commit/a261f6c599e0a048d11617f8cb985fa5968fda6a", "committedDate": "2020-06-23T09:16:59Z", "message": "Verify exception in constructor."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "91eb29697b5b9d4df658a52f90b1d364d8ba50f7", "author": {"user": {"login": "henningandersen", "name": "Henning Andersen"}}, "url": "https://github.com/elastic/elasticsearch/commit/91eb29697b5b9d4df658a52f90b1d364d8ba50f7", "committedDate": "2020-06-23T10:02:21Z", "message": "Remove some stream usages."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4e6e55b9c21a01b946ec95f8f7b224ad7f4859fe", "author": {"user": {"login": "elasticmachine", "name": "Elastic Machine"}}, "url": "https://github.com/elastic/elasticsearch/commit/4e6e55b9c21a01b946ec95f8f7b224ad7f4859fe", "committedDate": "2020-06-23T11:51:04Z", "message": "Merge branch 'master' into enhance_extensible_plugin"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM1OTQ0ODc3", "url": "https://github.com/elastic/elasticsearch/pull/58234#pullrequestreview-435944877", "createdAt": "2020-06-23T16:17:49Z", "commit": {"oid": "4e6e55b9c21a01b946ec95f8f7b224ad7f4859fe"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxNjoxNzo0OVrOGnwysw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxNjo0MDozNVrOGnxpKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM0NzA1OQ==", "bodyText": "Thanks for the explanation. I missed the lookup in calling of this method, thinking the extendingPlugins in the calling function (a map) was the same as extendingPlugins here (the value from that map, a list). Maybe consider changing the variable name to clarify they are different.", "url": "https://github.com/elastic/elasticsearch/pull/58234#discussion_r444347059", "createdAt": "2020-06-23T16:17:49Z", "author": {"login": "rjernst"}, "path": "server/src/main/java/org/elasticsearch/plugins/PluginsService.java", "diffHunk": "@@ -426,17 +429,66 @@ private static void addSortedBundle(Bundle bundle, Map<String, Bundle> bundles,\n         Map<String, Plugin> loaded = new HashMap<>();\n         Map<String, Set<URL>> transitiveUrls = new HashMap<>();\n         List<Bundle> sortedBundles = sortBundles(bundles);\n-\n         for (Bundle bundle : sortedBundles) {\n             checkBundleJarHell(JarHell.parseClassPath(), bundle, transitiveUrls);\n \n             final Plugin plugin = loadBundle(bundle, loaded);\n             plugins.add(new Tuple<>(bundle.plugin, plugin));\n         }\n \n+        loadExtensions(plugins);\n         return Collections.unmodifiableList(plugins);\n     }\n \n+    // package-private for test visibility\n+    static void loadExtensions(List<Tuple<PluginInfo, Plugin>> plugins) {\n+        Map<String, List<Plugin>> extendingPlugins = plugins.stream()\n+            .flatMap(t -> t.v1().getExtendedPlugins().stream().map(extendedPlugin -> Tuple.tuple(extendedPlugin, t.v2())))\n+            .collect(Collectors.groupingBy(Tuple::v1, Collectors.mapping(Tuple::v2, Collectors.toList())));\n+        plugins.stream().filter(t -> t.v2() instanceof ExtensiblePlugin).forEach(t -> loadExtensionsForPlugin((ExtensiblePlugin) t.v2(),\n+            extendingPlugins.getOrDefault(t.v1().getName(), List.of())));\n+    }\n+\n+    private static void loadExtensionsForPlugin(ExtensiblePlugin extensiblePlugin, List<Plugin> extendingPlugins) {\n+        ExtensiblePlugin.ExtensionLoader extensionLoader = new ExtensiblePlugin.ExtensionLoader() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU2MjgwNQ=="}, "originalCommit": {"oid": "cdf98d2851094f3aa9ae9db4a6dac7e23940bbbd"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM2MTAwMA==", "bodyText": "I understand now. Could we possibly have a test for this case?", "url": "https://github.com/elastic/elasticsearch/pull/58234#discussion_r444361000", "createdAt": "2020-06-23T16:40:35Z", "author": {"login": "rjernst"}, "path": "server/src/main/java/org/elasticsearch/plugins/PluginsService.java", "diffHunk": "@@ -509,12 +561,13 @@ private Plugin loadBundle(Bundle bundle, Map<String, Plugin> loaded) {\n \n         // reload SPI with any new services from the plugin\n         reloadLuceneSPI(loader);\n-        for (String extendedPluginName : bundle.plugin.getExtendedPlugins()) {\n-            // note: already asserted above that extended plugins are loaded and extensible\n-            ExtensiblePlugin.class.cast(loaded.get(extendedPluginName)).reloadSPI(loader);\n-        }\n \n         Class<? extends Plugin> pluginClass = loadPluginClass(bundle.plugin.getClassname(), loader);\n+        if (loader != pluginClass.getClassLoader()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU2NDU2NA=="}, "originalCommit": {"oid": "cdf98d2851094f3aa9ae9db4a6dac7e23940bbbd"}, "originalPosition": 98}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "377fb10d500aba60826e25b0bffef727ce9fe468", "author": {"user": {"login": "henningandersen", "name": "Henning Andersen"}}, "url": "https://github.com/elastic/elasticsearch/commit/377fb10d500aba60826e25b0bffef727ce9fe468", "committedDate": "2020-06-25T05:41:03Z", "message": "Rename variable to avoid confusion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eec9b68203ba9748543d2b4f5709dc19a2accc61", "author": {"user": {"login": "henningandersen", "name": "Henning Andersen"}}, "url": "https://github.com/elastic/elasticsearch/commit/eec9b68203ba9748543d2b4f5709dc19a2accc61", "committedDate": "2020-06-25T06:03:25Z", "message": "Add test case\n\nAdded test case for defining a plugin using a Plugin class from the\nparent class loader."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "82b977d21d22bb05632aa5c6bff85201a0065b21", "author": {"user": {"login": "henningandersen", "name": "Henning Andersen"}}, "url": "https://github.com/elastic/elasticsearch/commit/82b977d21d22bb05632aa5c6bff85201a0065b21", "committedDate": "2020-06-25T06:03:53Z", "message": "Merge remote-tracking branch 'origin/master' into enhance_extensible_plugin"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8817fe475fabd2df569c311dd43775afb2a0f270", "author": {"user": {"login": "elasticmachine", "name": "Elastic Machine"}}, "url": "https://github.com/elastic/elasticsearch/commit/8817fe475fabd2df569c311dd43775afb2a0f270", "committedDate": "2020-06-25T08:14:02Z", "message": "Merge branch 'master' into enhance_extensible_plugin"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 593, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}