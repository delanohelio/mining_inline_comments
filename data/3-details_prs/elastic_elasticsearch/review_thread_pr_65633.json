{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI5Nzc1MTEz", "number": 65633, "reviewThreads": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNToyODo1N1rOFC_C5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOVQwNzo0OTowNlrOFUZPZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4Njc0NDA0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/RollupILMAction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNToyODo1N1rOICaklQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNjoyNDo0NFrOICdfbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQwMzQxMw==", "bodyText": "I realize this is a matter of taste, but this function name really sounds like it's intended to take an action (delete), not return a flag value.  Normally I don't care, but in this case I really think getDeleteOriginalIndex() (or maybe shouldDeleteOriginalIndex) would be a better name.", "url": "https://github.com/elastic/elasticsearch/pull/65633#discussion_r539403413", "createdAt": "2020-12-09T15:28:57Z", "author": {"login": "not-napoleon"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/RollupILMAction.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.xpack.core.ilm.Step.StepKey;\n+import org.elasticsearch.xpack.core.rollup.v2.RollupActionConfig;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * A {@link LifecycleAction} which calls {@link org.elasticsearch.xpack.core.rollup.v2.RollupAction} on an index\n+ */\n+public class RollupILMAction implements LifecycleAction {\n+    public static final String NAME = \"rollup\";\n+\n+    private static final ParseField CONFIG_FIELD = new ParseField(\"config\");\n+    private static final ParseField DELETE_FIELD = new ParseField(\"delete_original\");\n+    private static final ParseField POLICY_FIELD = new ParseField(\"rollup_policy\");\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static final ConstructingObjectParser<RollupILMAction, Void> PARSER = new ConstructingObjectParser<>(NAME,\n+        a -> new RollupILMAction((RollupActionConfig) a[0], (boolean) a[1], (String) a[2]));\n+\n+    private final RollupActionConfig config;\n+    private final boolean deleteOriginalIndex;\n+    private final String rollupPolicy;\n+\n+    static {\n+        PARSER.declareField(ConstructingObjectParser.constructorArg(),\n+            (p, c) -> RollupActionConfig.fromXContent(p), CONFIG_FIELD, ObjectParser.ValueType.OBJECT);\n+        PARSER.declareBoolean(ConstructingObjectParser.optionalConstructorArg(), DELETE_FIELD);\n+        PARSER.declareString(ConstructingObjectParser.optionalConstructorArg(), POLICY_FIELD);\n+    }\n+\n+    public static RollupILMAction parse(XContentParser parser) {\n+        return PARSER.apply(parser, null);\n+    }\n+\n+    public RollupILMAction(RollupActionConfig config, boolean deleteOriginalIndex, @Nullable String rollupPolicy) {\n+        this.config = config;\n+        this.deleteOriginalIndex = deleteOriginalIndex;\n+        this.rollupPolicy = rollupPolicy;\n+    }\n+\n+    public RollupILMAction(StreamInput in) throws IOException {\n+        this(new RollupActionConfig(in), in.readBoolean(), in.readOptionalString());\n+    }\n+\n+    @Override\n+    public String getWriteableName() {\n+        return NAME;\n+    }\n+\n+    RollupActionConfig config() {\n+        return config;\n+    }\n+\n+    boolean deleteOriginalIndex() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3631adc00350833f8c5e73df82d59561e44d8356"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ1MTI0Nw==", "bodyText": "totally valid! I think I sometimes find myself going away from what I prefer: having boolean instance-get method names to be is<varName>. I will rename \ud83d\udc4d", "url": "https://github.com/elastic/elasticsearch/pull/65633#discussion_r539451247", "createdAt": "2020-12-09T16:24:44Z", "author": {"login": "talevy"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/RollupILMAction.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.xpack.core.ilm.Step.StepKey;\n+import org.elasticsearch.xpack.core.rollup.v2.RollupActionConfig;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * A {@link LifecycleAction} which calls {@link org.elasticsearch.xpack.core.rollup.v2.RollupAction} on an index\n+ */\n+public class RollupILMAction implements LifecycleAction {\n+    public static final String NAME = \"rollup\";\n+\n+    private static final ParseField CONFIG_FIELD = new ParseField(\"config\");\n+    private static final ParseField DELETE_FIELD = new ParseField(\"delete_original\");\n+    private static final ParseField POLICY_FIELD = new ParseField(\"rollup_policy\");\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static final ConstructingObjectParser<RollupILMAction, Void> PARSER = new ConstructingObjectParser<>(NAME,\n+        a -> new RollupILMAction((RollupActionConfig) a[0], (boolean) a[1], (String) a[2]));\n+\n+    private final RollupActionConfig config;\n+    private final boolean deleteOriginalIndex;\n+    private final String rollupPolicy;\n+\n+    static {\n+        PARSER.declareField(ConstructingObjectParser.constructorArg(),\n+            (p, c) -> RollupActionConfig.fromXContent(p), CONFIG_FIELD, ObjectParser.ValueType.OBJECT);\n+        PARSER.declareBoolean(ConstructingObjectParser.optionalConstructorArg(), DELETE_FIELD);\n+        PARSER.declareString(ConstructingObjectParser.optionalConstructorArg(), POLICY_FIELD);\n+    }\n+\n+    public static RollupILMAction parse(XContentParser parser) {\n+        return PARSER.apply(parser, null);\n+    }\n+\n+    public RollupILMAction(RollupActionConfig config, boolean deleteOriginalIndex, @Nullable String rollupPolicy) {\n+        this.config = config;\n+        this.deleteOriginalIndex = deleteOriginalIndex;\n+        this.rollupPolicy = rollupPolicy;\n+    }\n+\n+    public RollupILMAction(StreamInput in) throws IOException {\n+        this(new RollupActionConfig(in), in.readBoolean(), in.readOptionalString());\n+    }\n+\n+    @Override\n+    public String getWriteableName() {\n+        return NAME;\n+    }\n+\n+    RollupActionConfig config() {\n+        return config;\n+    }\n+\n+    boolean deleteOriginalIndex() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQwMzQxMw=="}, "originalCommit": {"oid": "3631adc00350833f8c5e73df82d59561e44d8356"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwODEzODQ1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/RollupStep.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxNDo1OToyN1rOIFUiVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxNjoyNzo1MVrOIFY4MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjQ1MDI2Mw==", "bodyText": "Should rollup index name prefix and postfix be configurable?\nShould we allow users to configure behavior (fail, overrwrite, no-op) in case the rollup index already exists?", "url": "https://github.com/elastic/elasticsearch/pull/65633#discussion_r542450263", "createdAt": "2020-12-14T14:59:27Z", "author": {"login": "csoulios"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/RollupStep.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateObserver;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.xpack.core.rollup.v2.RollupAction;\n+import org.elasticsearch.xpack.core.rollup.v2.RollupActionConfig;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Rolls up index using a {@link RollupActionConfig}\n+ */\n+public class RollupStep extends AsyncActionStep {\n+    public static final String NAME = \"rollup\";\n+    public static final String ROLLUP_INDEX_NAME_POSTFIX = \"-rollup\";\n+\n+    private final RollupActionConfig config;\n+    private final String rollupPolicy;\n+\n+    public RollupStep(StepKey key, StepKey nextStepKey, Client client, RollupActionConfig config, String rollupPolicy) {\n+        super(key, nextStepKey, client);\n+        this.config = config;\n+        this.rollupPolicy = rollupPolicy;\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return false;\n+    }\n+\n+    @Override\n+    public void performAction(IndexMetadata indexMetadata, ClusterState currentState, ClusterStateObserver observer, Listener listener) {\n+        String originalIndex = indexMetadata.getIndex().getName();\n+        String rollupIndex = originalIndex + ROLLUP_INDEX_NAME_POSTFIX;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "434f49cfdebf188fa2ccc21464baecf252965a43"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjUyMTM5Mg==", "bodyText": "I am not sure this needs to be configurable? Specifically if this is used against a data-stream, then this would not be a concern. We can discuss! I would like to reduce the concerns, but if this type of conflict is expected, we do need a work-around for users. you're right", "url": "https://github.com/elastic/elasticsearch/pull/65633#discussion_r542521392", "createdAt": "2020-12-14T16:27:51Z", "author": {"login": "talevy"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/RollupStep.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateObserver;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.xpack.core.rollup.v2.RollupAction;\n+import org.elasticsearch.xpack.core.rollup.v2.RollupActionConfig;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Rolls up index using a {@link RollupActionConfig}\n+ */\n+public class RollupStep extends AsyncActionStep {\n+    public static final String NAME = \"rollup\";\n+    public static final String ROLLUP_INDEX_NAME_POSTFIX = \"-rollup\";\n+\n+    private final RollupActionConfig config;\n+    private final String rollupPolicy;\n+\n+    public RollupStep(StepKey key, StepKey nextStepKey, Client client, RollupActionConfig config, String rollupPolicy) {\n+        super(key, nextStepKey, client);\n+        this.config = config;\n+        this.rollupPolicy = rollupPolicy;\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return false;\n+    }\n+\n+    @Override\n+    public void performAction(IndexMetadata indexMetadata, ClusterState currentState, ClusterStateObserver observer, Listener listener) {\n+        String originalIndex = indexMetadata.getIndex().getName();\n+        String rollupIndex = originalIndex + ROLLUP_INDEX_NAME_POSTFIX;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjQ1MDI2Mw=="}, "originalCommit": {"oid": "434f49cfdebf188fa2ccc21464baecf252965a43"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwODI5MDE3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/RollupILMAction.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxNToyNzozNlrOIFV8Lg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxNDowODozMlrOIJ8Y6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjQ3MzI2Mg==", "bodyText": "nit: I guess this is the optional policy field for the rollup index. I understand this will be explained in the docs but maybe we should find a more representative name. Something like rollup_index_policy", "url": "https://github.com/elastic/elasticsearch/pull/65633#discussion_r542473262", "createdAt": "2020-12-14T15:27:36Z", "author": {"login": "csoulios"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/RollupILMAction.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.xpack.core.ilm.Step.StepKey;\n+import org.elasticsearch.xpack.core.rollup.v2.RollupActionConfig;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * A {@link LifecycleAction} which calls {@link org.elasticsearch.xpack.core.rollup.v2.RollupAction} on an index\n+ */\n+public class RollupILMAction implements LifecycleAction {\n+    public static final String NAME = \"rollup\";\n+\n+    private static final ParseField CONFIG_FIELD = new ParseField(\"config\");\n+    private static final ParseField DELETE_FIELD = new ParseField(\"delete_original\");\n+    private static final ParseField POLICY_FIELD = new ParseField(\"rollup_policy\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "434f49cfdebf188fa2ccc21464baecf252965a43"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjUyMTYxMg==", "bodyText": "sure, will rename!", "url": "https://github.com/elastic/elasticsearch/pull/65633#discussion_r542521612", "createdAt": "2020-12-14T16:28:09Z", "author": {"login": "talevy"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/RollupILMAction.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.xpack.core.ilm.Step.StepKey;\n+import org.elasticsearch.xpack.core.rollup.v2.RollupActionConfig;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * A {@link LifecycleAction} which calls {@link org.elasticsearch.xpack.core.rollup.v2.RollupAction} on an index\n+ */\n+public class RollupILMAction implements LifecycleAction {\n+    public static final String NAME = \"rollup\";\n+\n+    private static final ParseField CONFIG_FIELD = new ParseField(\"config\");\n+    private static final ParseField DELETE_FIELD = new ParseField(\"delete_original\");\n+    private static final ParseField POLICY_FIELD = new ParseField(\"rollup_policy\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjQ3MzI2Mg=="}, "originalCommit": {"oid": "434f49cfdebf188fa2ccc21464baecf252965a43"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI5NzUxMw==", "bodyText": "After our last discussion on defining the ILM policy of the rollup index separately. Is this still the place to set the rollup index policy?", "url": "https://github.com/elastic/elasticsearch/pull/65633#discussion_r547297513", "createdAt": "2020-12-22T14:08:32Z", "author": {"login": "csoulios"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/RollupILMAction.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.xpack.core.ilm.Step.StepKey;\n+import org.elasticsearch.xpack.core.rollup.v2.RollupActionConfig;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * A {@link LifecycleAction} which calls {@link org.elasticsearch.xpack.core.rollup.v2.RollupAction} on an index\n+ */\n+public class RollupILMAction implements LifecycleAction {\n+    public static final String NAME = \"rollup\";\n+\n+    private static final ParseField CONFIG_FIELD = new ParseField(\"config\");\n+    private static final ParseField DELETE_FIELD = new ParseField(\"delete_original\");\n+    private static final ParseField POLICY_FIELD = new ParseField(\"rollup_policy\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjQ3MzI2Mg=="}, "originalCommit": {"oid": "434f49cfdebf188fa2ccc21464baecf252965a43"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwODMxNjc4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/TimeseriesLifecycleType.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxNTozMjoyOFrOIFWLfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQyMDozMTo0MFrOIFm00w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjQ3NzE4Mw==", "bodyText": "I thought we would allow RollupILMAction in \"hot\" phase similar to SearchableSnapshotAction. Is this a next step?", "url": "https://github.com/elastic/elasticsearch/pull/65633#discussion_r542477183", "createdAt": "2020-12-14T15:32:28Z", "author": {"login": "csoulios"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/TimeseriesLifecycleType.java", "diffHunk": "@@ -44,25 +45,36 @@\n         ReadOnlyAction.NAME, ShrinkAction.NAME, ForceMergeAction.NAME, SearchableSnapshotAction.NAME);\n     static final List<String> ORDERED_VALID_WARM_ACTIONS = Arrays.asList(SetPriorityAction.NAME, UnfollowAction.NAME, ReadOnlyAction.NAME,\n         AllocateAction.NAME, MigrateAction.NAME, ShrinkAction.NAME, ForceMergeAction.NAME);\n-    static final List<String> ORDERED_VALID_COLD_ACTIONS = Arrays.asList(SetPriorityAction.NAME, UnfollowAction.NAME, AllocateAction.NAME,\n-        MigrateAction.NAME, FreezeAction.NAME, SearchableSnapshotAction.NAME);\n+    static final List<String> ORDERED_VALID_COLD_ACTIONS;\n     static final List<String> ORDERED_VALID_DELETE_ACTIONS = Arrays.asList(WaitForSnapshotAction.NAME, DeleteAction.NAME);\n     static final Set<String> VALID_HOT_ACTIONS = Sets.newHashSet(ORDERED_VALID_HOT_ACTIONS);\n     static final Set<String> VALID_WARM_ACTIONS = Sets.newHashSet(ORDERED_VALID_WARM_ACTIONS);\n-    static final Set<String> VALID_COLD_ACTIONS = Sets.newHashSet(ORDERED_VALID_COLD_ACTIONS);\n+    static final Set<String> VALID_COLD_ACTIONS;\n     static final Set<String> VALID_DELETE_ACTIONS = Sets.newHashSet(ORDERED_VALID_DELETE_ACTIONS);\n-    private static final Map<String, Set<String>> ALLOWED_ACTIONS = Map.of(\n-        HOT_PHASE, VALID_HOT_ACTIONS,\n-        WARM_PHASE, VALID_WARM_ACTIONS,\n-        COLD_PHASE, VALID_COLD_ACTIONS,\n-        DELETE_PHASE, VALID_DELETE_ACTIONS);\n+    private static final Map<String, Set<String>> ALLOWED_ACTIONS;\n \n     static final Set<String> HOT_ACTIONS_THAT_REQUIRE_ROLLOVER = Sets.newHashSet(ReadOnlyAction.NAME, ShrinkAction.NAME,\n         ForceMergeAction.NAME, SearchableSnapshotAction.NAME);\n     // a set of actions that cannot be defined (executed) after the managed index has been mounted as searchable snapshot\n     static final Set<String> ACTIONS_CANNOT_FOLLOW_SEARCHABLE_SNAPSHOT = Sets.newHashSet(ShrinkAction.NAME, ForceMergeAction.NAME,\n         FreezeAction.NAME, SearchableSnapshotAction.NAME);\n \n+    static {\n+        if (RollupV2.isEnabled()) {\n+            ORDERED_VALID_COLD_ACTIONS = Arrays.asList(SetPriorityAction.NAME, UnfollowAction.NAME, AllocateAction.NAME,\n+                MigrateAction.NAME, FreezeAction.NAME, SearchableSnapshotAction.NAME, RollupILMAction.NAME);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "434f49cfdebf188fa2ccc21464baecf252965a43"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjUxOTU2MA==", "bodyText": "yeah... I consider that something we can work on in a follow-up. it will require some more conditionals etc that I thought would distract this PR.", "url": "https://github.com/elastic/elasticsearch/pull/65633#discussion_r542519560", "createdAt": "2020-12-14T16:25:35Z", "author": {"login": "talevy"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/TimeseriesLifecycleType.java", "diffHunk": "@@ -44,25 +45,36 @@\n         ReadOnlyAction.NAME, ShrinkAction.NAME, ForceMergeAction.NAME, SearchableSnapshotAction.NAME);\n     static final List<String> ORDERED_VALID_WARM_ACTIONS = Arrays.asList(SetPriorityAction.NAME, UnfollowAction.NAME, ReadOnlyAction.NAME,\n         AllocateAction.NAME, MigrateAction.NAME, ShrinkAction.NAME, ForceMergeAction.NAME);\n-    static final List<String> ORDERED_VALID_COLD_ACTIONS = Arrays.asList(SetPriorityAction.NAME, UnfollowAction.NAME, AllocateAction.NAME,\n-        MigrateAction.NAME, FreezeAction.NAME, SearchableSnapshotAction.NAME);\n+    static final List<String> ORDERED_VALID_COLD_ACTIONS;\n     static final List<String> ORDERED_VALID_DELETE_ACTIONS = Arrays.asList(WaitForSnapshotAction.NAME, DeleteAction.NAME);\n     static final Set<String> VALID_HOT_ACTIONS = Sets.newHashSet(ORDERED_VALID_HOT_ACTIONS);\n     static final Set<String> VALID_WARM_ACTIONS = Sets.newHashSet(ORDERED_VALID_WARM_ACTIONS);\n-    static final Set<String> VALID_COLD_ACTIONS = Sets.newHashSet(ORDERED_VALID_COLD_ACTIONS);\n+    static final Set<String> VALID_COLD_ACTIONS;\n     static final Set<String> VALID_DELETE_ACTIONS = Sets.newHashSet(ORDERED_VALID_DELETE_ACTIONS);\n-    private static final Map<String, Set<String>> ALLOWED_ACTIONS = Map.of(\n-        HOT_PHASE, VALID_HOT_ACTIONS,\n-        WARM_PHASE, VALID_WARM_ACTIONS,\n-        COLD_PHASE, VALID_COLD_ACTIONS,\n-        DELETE_PHASE, VALID_DELETE_ACTIONS);\n+    private static final Map<String, Set<String>> ALLOWED_ACTIONS;\n \n     static final Set<String> HOT_ACTIONS_THAT_REQUIRE_ROLLOVER = Sets.newHashSet(ReadOnlyAction.NAME, ShrinkAction.NAME,\n         ForceMergeAction.NAME, SearchableSnapshotAction.NAME);\n     // a set of actions that cannot be defined (executed) after the managed index has been mounted as searchable snapshot\n     static final Set<String> ACTIONS_CANNOT_FOLLOW_SEARCHABLE_SNAPSHOT = Sets.newHashSet(ShrinkAction.NAME, ForceMergeAction.NAME,\n         FreezeAction.NAME, SearchableSnapshotAction.NAME);\n \n+    static {\n+        if (RollupV2.isEnabled()) {\n+            ORDERED_VALID_COLD_ACTIONS = Arrays.asList(SetPriorityAction.NAME, UnfollowAction.NAME, AllocateAction.NAME,\n+                MigrateAction.NAME, FreezeAction.NAME, SearchableSnapshotAction.NAME, RollupILMAction.NAME);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjQ3NzE4Mw=="}, "originalCommit": {"oid": "434f49cfdebf188fa2ccc21464baecf252965a43"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc0OTkwNw==", "bodyText": "It makes sense. Thanks", "url": "https://github.com/elastic/elasticsearch/pull/65633#discussion_r542749907", "createdAt": "2020-12-14T20:31:40Z", "author": {"login": "csoulios"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/TimeseriesLifecycleType.java", "diffHunk": "@@ -44,25 +45,36 @@\n         ReadOnlyAction.NAME, ShrinkAction.NAME, ForceMergeAction.NAME, SearchableSnapshotAction.NAME);\n     static final List<String> ORDERED_VALID_WARM_ACTIONS = Arrays.asList(SetPriorityAction.NAME, UnfollowAction.NAME, ReadOnlyAction.NAME,\n         AllocateAction.NAME, MigrateAction.NAME, ShrinkAction.NAME, ForceMergeAction.NAME);\n-    static final List<String> ORDERED_VALID_COLD_ACTIONS = Arrays.asList(SetPriorityAction.NAME, UnfollowAction.NAME, AllocateAction.NAME,\n-        MigrateAction.NAME, FreezeAction.NAME, SearchableSnapshotAction.NAME);\n+    static final List<String> ORDERED_VALID_COLD_ACTIONS;\n     static final List<String> ORDERED_VALID_DELETE_ACTIONS = Arrays.asList(WaitForSnapshotAction.NAME, DeleteAction.NAME);\n     static final Set<String> VALID_HOT_ACTIONS = Sets.newHashSet(ORDERED_VALID_HOT_ACTIONS);\n     static final Set<String> VALID_WARM_ACTIONS = Sets.newHashSet(ORDERED_VALID_WARM_ACTIONS);\n-    static final Set<String> VALID_COLD_ACTIONS = Sets.newHashSet(ORDERED_VALID_COLD_ACTIONS);\n+    static final Set<String> VALID_COLD_ACTIONS;\n     static final Set<String> VALID_DELETE_ACTIONS = Sets.newHashSet(ORDERED_VALID_DELETE_ACTIONS);\n-    private static final Map<String, Set<String>> ALLOWED_ACTIONS = Map.of(\n-        HOT_PHASE, VALID_HOT_ACTIONS,\n-        WARM_PHASE, VALID_WARM_ACTIONS,\n-        COLD_PHASE, VALID_COLD_ACTIONS,\n-        DELETE_PHASE, VALID_DELETE_ACTIONS);\n+    private static final Map<String, Set<String>> ALLOWED_ACTIONS;\n \n     static final Set<String> HOT_ACTIONS_THAT_REQUIRE_ROLLOVER = Sets.newHashSet(ReadOnlyAction.NAME, ShrinkAction.NAME,\n         ForceMergeAction.NAME, SearchableSnapshotAction.NAME);\n     // a set of actions that cannot be defined (executed) after the managed index has been mounted as searchable snapshot\n     static final Set<String> ACTIONS_CANNOT_FOLLOW_SEARCHABLE_SNAPSHOT = Sets.newHashSet(ShrinkAction.NAME, ForceMergeAction.NAME,\n         FreezeAction.NAME, SearchableSnapshotAction.NAME);\n \n+    static {\n+        if (RollupV2.isEnabled()) {\n+            ORDERED_VALID_COLD_ACTIONS = Arrays.asList(SetPriorityAction.NAME, UnfollowAction.NAME, AllocateAction.NAME,\n+                MigrateAction.NAME, FreezeAction.NAME, SearchableSnapshotAction.NAME, RollupILMAction.NAME);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjQ3NzE4Mw=="}, "originalCommit": {"oid": "434f49cfdebf188fa2ccc21464baecf252965a43"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwODQ0OTkzOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/RollupILMAction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxNTo1NzowOFrOIFXaFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxNjoyNjoxNVrOIFYzDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjQ5NzMwMw==", "bodyText": "Is it enough to only check for index being read-only?\nDoes it make sense to check that rollover has completed? (Maybe checking the index.lifecycle.indexing_complete index setting?", "url": "https://github.com/elastic/elasticsearch/pull/65633#discussion_r542497303", "createdAt": "2020-12-14T15:57:08Z", "author": {"login": "csoulios"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/RollupILMAction.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.xpack.core.ilm.Step.StepKey;\n+import org.elasticsearch.xpack.core.rollup.v2.RollupActionConfig;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * A {@link LifecycleAction} which calls {@link org.elasticsearch.xpack.core.rollup.v2.RollupAction} on an index\n+ */\n+public class RollupILMAction implements LifecycleAction {\n+    public static final String NAME = \"rollup\";\n+\n+    private static final ParseField CONFIG_FIELD = new ParseField(\"config\");\n+    private static final ParseField DELETE_FIELD = new ParseField(\"delete_original\");\n+    private static final ParseField POLICY_FIELD = new ParseField(\"rollup_policy\");\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static final ConstructingObjectParser<RollupILMAction, Void> PARSER = new ConstructingObjectParser<>(NAME,\n+        a -> new RollupILMAction((RollupActionConfig) a[0], (boolean) a[1], (String) a[2]));\n+\n+    private final RollupActionConfig config;\n+    private final boolean deleteOriginalIndex;\n+    private final String rollupPolicy;\n+\n+    static {\n+        PARSER.declareField(ConstructingObjectParser.constructorArg(),\n+            (p, c) -> RollupActionConfig.fromXContent(p), CONFIG_FIELD, ObjectParser.ValueType.OBJECT);\n+        PARSER.declareBoolean(ConstructingObjectParser.optionalConstructorArg(), DELETE_FIELD);\n+        PARSER.declareString(ConstructingObjectParser.optionalConstructorArg(), POLICY_FIELD);\n+    }\n+\n+    public static RollupILMAction parse(XContentParser parser) {\n+        return PARSER.apply(parser, null);\n+    }\n+\n+    public RollupILMAction(RollupActionConfig config, boolean deleteOriginalIndex, @Nullable String rollupPolicy) {\n+        this.config = config;\n+        this.deleteOriginalIndex = deleteOriginalIndex;\n+        this.rollupPolicy = rollupPolicy;\n+    }\n+\n+    public RollupILMAction(StreamInput in) throws IOException {\n+        this(new RollupActionConfig(in), in.readBoolean(), in.readOptionalString());\n+    }\n+\n+    @Override\n+    public String getWriteableName() {\n+        return NAME;\n+    }\n+\n+    RollupActionConfig config() {\n+        return config;\n+    }\n+\n+    boolean shouldDeleteOriginalIndex() {\n+        return deleteOriginalIndex;\n+    }\n+\n+    String rollupPolicy() {\n+        return rollupPolicy;\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject();\n+        builder.field(CONFIG_FIELD.getPreferredName(), config);\n+        builder.field(DELETE_FIELD.getPreferredName(), deleteOriginalIndex);\n+        if (rollupPolicy != null) {\n+            builder.field(POLICY_FIELD.getPreferredName(), rollupPolicy);\n+        }\n+        builder.endObject();\n+        return builder;\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        config.writeTo(out);\n+        out.writeBoolean(deleteOriginalIndex);\n+        out.writeOptionalString(rollupPolicy);\n+    }\n+\n+    @Override\n+    public boolean isSafeAction() {\n+        return false;\n+    }\n+\n+    @Override\n+    public List<Step> toSteps(Client client, String phase, StepKey nextStepKey) {\n+        StepKey checkNotWriteIndex = new StepKey(phase, NAME, CheckNotDataStreamWriteIndexStep.NAME);\n+        StepKey readOnlyKey = new StepKey(phase, NAME, ReadOnlyAction.NAME);\n+        StepKey rollupKey = new StepKey(phase, NAME, NAME);\n+        StepKey waitForNoFollowerStepKey = new StepKey(phase, NAME, WaitForNoFollowersStep.NAME);\n+        StepKey deleteStepKey = new StepKey(phase, NAME, DeleteStep.NAME);\n+\n+        Settings readOnlySettings = Settings.builder().put(IndexMetadata.SETTING_BLOCKS_WRITE, true).build();\n+\n+        CheckNotDataStreamWriteIndexStep checkNotWriteIndexStep = new CheckNotDataStreamWriteIndexStep(checkNotWriteIndex,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "434f49cfdebf188fa2ccc21464baecf252965a43"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjUyMDA3Nw==", "bodyText": "I will double-check with the ILM team, but this is what most of the other actions are doing", "url": "https://github.com/elastic/elasticsearch/pull/65633#discussion_r542520077", "createdAt": "2020-12-14T16:26:15Z", "author": {"login": "talevy"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/RollupILMAction.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.xpack.core.ilm.Step.StepKey;\n+import org.elasticsearch.xpack.core.rollup.v2.RollupActionConfig;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * A {@link LifecycleAction} which calls {@link org.elasticsearch.xpack.core.rollup.v2.RollupAction} on an index\n+ */\n+public class RollupILMAction implements LifecycleAction {\n+    public static final String NAME = \"rollup\";\n+\n+    private static final ParseField CONFIG_FIELD = new ParseField(\"config\");\n+    private static final ParseField DELETE_FIELD = new ParseField(\"delete_original\");\n+    private static final ParseField POLICY_FIELD = new ParseField(\"rollup_policy\");\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static final ConstructingObjectParser<RollupILMAction, Void> PARSER = new ConstructingObjectParser<>(NAME,\n+        a -> new RollupILMAction((RollupActionConfig) a[0], (boolean) a[1], (String) a[2]));\n+\n+    private final RollupActionConfig config;\n+    private final boolean deleteOriginalIndex;\n+    private final String rollupPolicy;\n+\n+    static {\n+        PARSER.declareField(ConstructingObjectParser.constructorArg(),\n+            (p, c) -> RollupActionConfig.fromXContent(p), CONFIG_FIELD, ObjectParser.ValueType.OBJECT);\n+        PARSER.declareBoolean(ConstructingObjectParser.optionalConstructorArg(), DELETE_FIELD);\n+        PARSER.declareString(ConstructingObjectParser.optionalConstructorArg(), POLICY_FIELD);\n+    }\n+\n+    public static RollupILMAction parse(XContentParser parser) {\n+        return PARSER.apply(parser, null);\n+    }\n+\n+    public RollupILMAction(RollupActionConfig config, boolean deleteOriginalIndex, @Nullable String rollupPolicy) {\n+        this.config = config;\n+        this.deleteOriginalIndex = deleteOriginalIndex;\n+        this.rollupPolicy = rollupPolicy;\n+    }\n+\n+    public RollupILMAction(StreamInput in) throws IOException {\n+        this(new RollupActionConfig(in), in.readBoolean(), in.readOptionalString());\n+    }\n+\n+    @Override\n+    public String getWriteableName() {\n+        return NAME;\n+    }\n+\n+    RollupActionConfig config() {\n+        return config;\n+    }\n+\n+    boolean shouldDeleteOriginalIndex() {\n+        return deleteOriginalIndex;\n+    }\n+\n+    String rollupPolicy() {\n+        return rollupPolicy;\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject();\n+        builder.field(CONFIG_FIELD.getPreferredName(), config);\n+        builder.field(DELETE_FIELD.getPreferredName(), deleteOriginalIndex);\n+        if (rollupPolicy != null) {\n+            builder.field(POLICY_FIELD.getPreferredName(), rollupPolicy);\n+        }\n+        builder.endObject();\n+        return builder;\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        config.writeTo(out);\n+        out.writeBoolean(deleteOriginalIndex);\n+        out.writeOptionalString(rollupPolicy);\n+    }\n+\n+    @Override\n+    public boolean isSafeAction() {\n+        return false;\n+    }\n+\n+    @Override\n+    public List<Step> toSteps(Client client, String phase, StepKey nextStepKey) {\n+        StepKey checkNotWriteIndex = new StepKey(phase, NAME, CheckNotDataStreamWriteIndexStep.NAME);\n+        StepKey readOnlyKey = new StepKey(phase, NAME, ReadOnlyAction.NAME);\n+        StepKey rollupKey = new StepKey(phase, NAME, NAME);\n+        StepKey waitForNoFollowerStepKey = new StepKey(phase, NAME, WaitForNoFollowersStep.NAME);\n+        StepKey deleteStepKey = new StepKey(phase, NAME, DeleteStep.NAME);\n+\n+        Settings readOnlySettings = Settings.builder().put(IndexMetadata.SETTING_BLOCKS_WRITE, true).build();\n+\n+        CheckNotDataStreamWriteIndexStep checkNotWriteIndexStep = new CheckNotDataStreamWriteIndexStep(checkNotWriteIndex,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjQ5NzMwMw=="}, "originalCommit": {"oid": "434f49cfdebf188fa2ccc21464baecf252965a43"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0MTE3OTQyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/TimeseriesLifecycleType.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxNDoyNjoyOFrOIJ89dg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxNzo0OToyNVrOIKDkvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzMwNjg3MA==", "bodyText": "should RollupILMAction be added in a if (RolupV2.isEnabled() {.....} block?", "url": "https://github.com/elastic/elasticsearch/pull/65633#discussion_r547306870", "createdAt": "2020-12-22T14:26:28Z", "author": {"login": "csoulios"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/TimeseriesLifecycleType.java", "diffHunk": "@@ -41,27 +42,38 @@\n     static final String DELETE_PHASE = \"delete\";\n     static final List<String> VALID_PHASES = Arrays.asList(HOT_PHASE, WARM_PHASE, COLD_PHASE, DELETE_PHASE);\n     static final List<String> ORDERED_VALID_HOT_ACTIONS = Arrays.asList(SetPriorityAction.NAME, UnfollowAction.NAME, RolloverAction.NAME,\n-        ReadOnlyAction.NAME, ShrinkAction.NAME, ForceMergeAction.NAME, SearchableSnapshotAction.NAME);\n+        ReadOnlyAction.NAME, ShrinkAction.NAME, ForceMergeAction.NAME, RollupILMAction.NAME, SearchableSnapshotAction.NAME);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e46d4ec99c6d411670a2772060517ee5dc5b8f2c"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzQxNTIyOQ==", "bodyText": "yes, indeed! I slipped here because I was eager to see CI run the integration tests. will fix", "url": "https://github.com/elastic/elasticsearch/pull/65633#discussion_r547415229", "createdAt": "2020-12-22T17:49:25Z", "author": {"login": "talevy"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/TimeseriesLifecycleType.java", "diffHunk": "@@ -41,27 +42,38 @@\n     static final String DELETE_PHASE = \"delete\";\n     static final List<String> VALID_PHASES = Arrays.asList(HOT_PHASE, WARM_PHASE, COLD_PHASE, DELETE_PHASE);\n     static final List<String> ORDERED_VALID_HOT_ACTIONS = Arrays.asList(SetPriorityAction.NAME, UnfollowAction.NAME, RolloverAction.NAME,\n-        ReadOnlyAction.NAME, ShrinkAction.NAME, ForceMergeAction.NAME, SearchableSnapshotAction.NAME);\n+        ReadOnlyAction.NAME, ShrinkAction.NAME, ForceMergeAction.NAME, RollupILMAction.NAME, SearchableSnapshotAction.NAME);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzMwNjg3MA=="}, "originalCommit": {"oid": "e46d4ec99c6d411670a2772060517ee5dc5b8f2c"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3OTcxMjk5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/RollupStep.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxODoxNTo0M1rOIPRFLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxODoxNTo0M1rOIPRFLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjg3OTQwNg==", "bodyText": "We use prefixes for most of the other ILM actions (searchable snapshot and shrinking), I think it'd be nice to stick with that convention for rollup indices also", "url": "https://github.com/elastic/elasticsearch/pull/65633#discussion_r552879406", "createdAt": "2021-01-06T18:15:43Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/RollupStep.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateObserver;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.xpack.core.rollup.v2.RollupAction;\n+import org.elasticsearch.xpack.core.rollup.v2.RollupActionConfig;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Rolls up index using a {@link RollupActionConfig}\n+ */\n+public class RollupStep extends AsyncActionStep {\n+    public static final String NAME = \"rollup\";\n+    public static final String ROLLUP_INDEX_NAME_POSTFIX = \"-rollup\";\n+\n+    private final RollupActionConfig config;\n+    private final String rollupPolicy;\n+\n+    public RollupStep(StepKey key, StepKey nextStepKey, Client client, RollupActionConfig config, String rollupPolicy) {\n+        super(key, nextStepKey, client);\n+        this.config = config;\n+        this.rollupPolicy = rollupPolicy;\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return false;\n+    }\n+\n+    @Override\n+    public void performAction(IndexMetadata indexMetadata, ClusterState currentState, ClusterStateObserver observer, Listener listener) {\n+        String originalIndex = indexMetadata.getIndex().getName();\n+        String rollupIndex = originalIndex + ROLLUP_INDEX_NAME_POSTFIX;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5b1bb94e1ee359a092e5d88410e8f7a1d33074e"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3OTcxNzg5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/RollupStep.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxODoxNjoyOVrOIPRIXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQyMzozMjoyM1rOISZq6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjg4MDIyMA==", "bodyText": "What happens if response.isAcknowledge() is false here?", "url": "https://github.com/elastic/elasticsearch/pull/65633#discussion_r552880220", "createdAt": "2021-01-06T18:16:29Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/RollupStep.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateObserver;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.xpack.core.rollup.v2.RollupAction;\n+import org.elasticsearch.xpack.core.rollup.v2.RollupActionConfig;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Rolls up index using a {@link RollupActionConfig}\n+ */\n+public class RollupStep extends AsyncActionStep {\n+    public static final String NAME = \"rollup\";\n+    public static final String ROLLUP_INDEX_NAME_POSTFIX = \"-rollup\";\n+\n+    private final RollupActionConfig config;\n+    private final String rollupPolicy;\n+\n+    public RollupStep(StepKey key, StepKey nextStepKey, Client client, RollupActionConfig config, String rollupPolicy) {\n+        super(key, nextStepKey, client);\n+        this.config = config;\n+        this.rollupPolicy = rollupPolicy;\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return false;\n+    }\n+\n+    @Override\n+    public void performAction(IndexMetadata indexMetadata, ClusterState currentState, ClusterStateObserver observer, Listener listener) {\n+        String originalIndex = indexMetadata.getIndex().getName();\n+        String rollupIndex = originalIndex + ROLLUP_INDEX_NAME_POSTFIX;\n+        RollupAction.Request request = new RollupAction.Request(originalIndex, rollupIndex, config);\n+        if (rollupPolicy == null) {\n+            getClient().execute(RollupAction.INSTANCE, request,\n+                ActionListener.wrap(response -> listener.onResponse(true), listener::onFailure));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5b1bb94e1ee359a092e5d88410e8f7a1d33074e"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjE2NTg2NQ==", "bodyText": "there is more work to do with regards to the RollupAction itself, which will evolve the response from the action. For now it either throws exception or returns true as a placeholder before we introduce more subtle edge-case behaviors (e.g. #66423)", "url": "https://github.com/elastic/elasticsearch/pull/65633#discussion_r556165865", "createdAt": "2021-01-12T23:32:23Z", "author": {"login": "talevy"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/RollupStep.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateObserver;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.xpack.core.rollup.v2.RollupAction;\n+import org.elasticsearch.xpack.core.rollup.v2.RollupActionConfig;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Rolls up index using a {@link RollupActionConfig}\n+ */\n+public class RollupStep extends AsyncActionStep {\n+    public static final String NAME = \"rollup\";\n+    public static final String ROLLUP_INDEX_NAME_POSTFIX = \"-rollup\";\n+\n+    private final RollupActionConfig config;\n+    private final String rollupPolicy;\n+\n+    public RollupStep(StepKey key, StepKey nextStepKey, Client client, RollupActionConfig config, String rollupPolicy) {\n+        super(key, nextStepKey, client);\n+        this.config = config;\n+        this.rollupPolicy = rollupPolicy;\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return false;\n+    }\n+\n+    @Override\n+    public void performAction(IndexMetadata indexMetadata, ClusterState currentState, ClusterStateObserver observer, Listener listener) {\n+        String originalIndex = indexMetadata.getIndex().getName();\n+        String rollupIndex = originalIndex + ROLLUP_INDEX_NAME_POSTFIX;\n+        RollupAction.Request request = new RollupAction.Request(originalIndex, rollupIndex, config);\n+        if (rollupPolicy == null) {\n+            getClient().execute(RollupAction.INSTANCE, request,\n+                ActionListener.wrap(response -> listener.onResponse(true), listener::onFailure));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjg4MDIyMA=="}, "originalCommit": {"oid": "a5b1bb94e1ee359a092e5d88410e8f7a1d33074e"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3OTc4MzY4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/RollupStep.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxODozMjozN1rOIPRy-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxODozMjozN1rOIPRy-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjg5MTEzMQ==", "bodyText": "I think these can be split into two steps, that way the update settings request can be retryable, rather than a failure of that step causing the entire rollup to fail", "url": "https://github.com/elastic/elasticsearch/pull/65633#discussion_r552891131", "createdAt": "2021-01-06T18:32:37Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/RollupStep.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateObserver;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.xpack.core.rollup.v2.RollupAction;\n+import org.elasticsearch.xpack.core.rollup.v2.RollupActionConfig;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Rolls up index using a {@link RollupActionConfig}\n+ */\n+public class RollupStep extends AsyncActionStep {\n+    public static final String NAME = \"rollup\";\n+    public static final String ROLLUP_INDEX_NAME_POSTFIX = \"-rollup\";\n+\n+    private final RollupActionConfig config;\n+    private final String rollupPolicy;\n+\n+    public RollupStep(StepKey key, StepKey nextStepKey, Client client, RollupActionConfig config, String rollupPolicy) {\n+        super(key, nextStepKey, client);\n+        this.config = config;\n+        this.rollupPolicy = rollupPolicy;\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return false;\n+    }\n+\n+    @Override\n+    public void performAction(IndexMetadata indexMetadata, ClusterState currentState, ClusterStateObserver observer, Listener listener) {\n+        String originalIndex = indexMetadata.getIndex().getName();\n+        String rollupIndex = originalIndex + ROLLUP_INDEX_NAME_POSTFIX;\n+        RollupAction.Request request = new RollupAction.Request(originalIndex, rollupIndex, config);\n+        if (rollupPolicy == null) {\n+            getClient().execute(RollupAction.INSTANCE, request,\n+                ActionListener.wrap(response -> listener.onResponse(true), listener::onFailure));\n+        } else {\n+            Settings setPolicySettings = Settings.builder().put(LifecycleSettings.LIFECYCLE_NAME, rollupPolicy).build();\n+            UpdateSettingsRequest updateSettingsRequest = new UpdateSettingsRequest(rollupIndex)\n+                .masterNodeTimeout(getMasterTimeout(currentState)).settings(setPolicySettings);\n+            getClient().execute(RollupAction.INSTANCE, request,\n+                ActionListener.wrap(rollupResponse -> {\n+                    getClient().admin().indices().updateSettings(updateSettingsRequest,\n+                        ActionListener.wrap(settingsResponse -> listener.onResponse(true), listener::onFailure));\n+                }, listener::onFailure));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5b1bb94e1ee359a092e5d88410e8f7a1d33074e"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3OTc4ODYwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/RollupStep.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxODozNDoxNVrOIPR2OQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxODozNDoxNVrOIPR2OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjg5MTk2MQ==", "bodyText": "I think it would be really nice to have this be retryable for the first release, maybe we can brainstorm why it isn't retryable and how to make it so? Otherwise I think we may end up having to do surgery on the indices if they get into an error and can't proceed past the rollup stage", "url": "https://github.com/elastic/elasticsearch/pull/65633#discussion_r552891961", "createdAt": "2021-01-06T18:34:15Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/RollupStep.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateObserver;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.xpack.core.rollup.v2.RollupAction;\n+import org.elasticsearch.xpack.core.rollup.v2.RollupActionConfig;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Rolls up index using a {@link RollupActionConfig}\n+ */\n+public class RollupStep extends AsyncActionStep {\n+    public static final String NAME = \"rollup\";\n+    public static final String ROLLUP_INDEX_NAME_POSTFIX = \"-rollup\";\n+\n+    private final RollupActionConfig config;\n+    private final String rollupPolicy;\n+\n+    public RollupStep(StepKey key, StepKey nextStepKey, Client client, RollupActionConfig config, String rollupPolicy) {\n+        super(key, nextStepKey, client);\n+        this.config = config;\n+        this.rollupPolicy = rollupPolicy;\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5b1bb94e1ee359a092e5d88410e8f7a1d33074e"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3OTgwNzc5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/RollupILMAction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxODo0MDoyN1rOIPSCIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxODo0MDoyN1rOIPSCIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjg5NTAxMQ==", "bodyText": "This should use the ReadOnlyStep (which uses the new API for marking things as read only) rather than updating the settings manually", "url": "https://github.com/elastic/elasticsearch/pull/65633#discussion_r552895011", "createdAt": "2021-01-06T18:40:27Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/RollupILMAction.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.xpack.core.ilm.Step.StepKey;\n+import org.elasticsearch.xpack.core.rollup.v2.RollupActionConfig;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * A {@link LifecycleAction} which calls {@link org.elasticsearch.xpack.core.rollup.v2.RollupAction} on an index\n+ */\n+public class RollupILMAction implements LifecycleAction {\n+    public static final String NAME = \"rollup\";\n+\n+    private static final ParseField CONFIG_FIELD = new ParseField(\"config\");\n+    private static final ParseField POLICY_FIELD = new ParseField(\"rollup_policy\");\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static final ConstructingObjectParser<RollupILMAction, Void> PARSER = new ConstructingObjectParser<>(NAME,\n+        a -> new RollupILMAction((RollupActionConfig) a[0], (String) a[1]));\n+\n+    private final RollupActionConfig config;\n+    private final String rollupPolicy;\n+\n+    static {\n+        PARSER.declareField(ConstructingObjectParser.constructorArg(),\n+            (p, c) -> RollupActionConfig.fromXContent(p), CONFIG_FIELD, ObjectParser.ValueType.OBJECT);\n+        PARSER.declareString(ConstructingObjectParser.optionalConstructorArg(), POLICY_FIELD);\n+    }\n+\n+    public static RollupILMAction parse(XContentParser parser) {\n+        return PARSER.apply(parser, null);\n+    }\n+\n+    public RollupILMAction(RollupActionConfig config, @Nullable String rollupPolicy) {\n+        this.config = config;\n+        this.rollupPolicy = rollupPolicy;\n+    }\n+\n+    public RollupILMAction(StreamInput in) throws IOException {\n+        this(new RollupActionConfig(in), in.readOptionalString());\n+    }\n+\n+    @Override\n+    public String getWriteableName() {\n+        return NAME;\n+    }\n+\n+    RollupActionConfig config() {\n+        return config;\n+    }\n+\n+    String rollupPolicy() {\n+        return rollupPolicy;\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject();\n+        builder.field(CONFIG_FIELD.getPreferredName(), config);\n+        if (rollupPolicy != null) {\n+            builder.field(POLICY_FIELD.getPreferredName(), rollupPolicy);\n+        }\n+        builder.endObject();\n+        return builder;\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        config.writeTo(out);\n+        out.writeOptionalString(rollupPolicy);\n+    }\n+\n+    @Override\n+    public boolean isSafeAction() {\n+        return false;\n+    }\n+\n+    @Override\n+    public List<Step> toSteps(Client client, String phase, StepKey nextStepKey) {\n+        StepKey checkNotWriteIndex = new StepKey(phase, NAME, CheckNotDataStreamWriteIndexStep.NAME);\n+        StepKey readOnlyKey = new StepKey(phase, NAME, ReadOnlyAction.NAME);\n+        StepKey rollupKey = new StepKey(phase, NAME, NAME);\n+        Settings readOnlySettings = Settings.builder().put(IndexMetadata.SETTING_BLOCKS_WRITE, true).build();\n+        CheckNotDataStreamWriteIndexStep checkNotWriteIndexStep = new CheckNotDataStreamWriteIndexStep(checkNotWriteIndex,\n+            readOnlyKey);\n+        UpdateSettingsStep readOnlyStep = new UpdateSettingsStep(readOnlyKey, rollupKey, client, readOnlySettings);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5b1bb94e1ee359a092e5d88410e8f7a1d33074e"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU1Mjk0MTU1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/RollupStep.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNVQyMjo1NjowN1rOIZ959Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNVQyMjo1NjowN1rOIZ959Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDA5OTU3Mw==", "bodyText": "Can we add a comment here about why this is okay to hardcode to true? ie, is it truly okay to ignore if the request is not acknowledged?", "url": "https://github.com/elastic/elasticsearch/pull/65633#discussion_r564099573", "createdAt": "2021-01-25T22:56:07Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/RollupStep.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateObserver;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.xpack.core.rollup.RollupActionConfig;\n+import org.elasticsearch.xpack.core.rollup.action.RollupAction;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Rolls up index using a {@link RollupActionConfig}\n+ */\n+public class RollupStep extends AsyncActionStep {\n+    public static final String NAME = \"rollup\";\n+    public static final String ROLLUP_INDEX_NAME_PREFIX = \"rollup-\";\n+\n+    private final RollupActionConfig config;\n+\n+    public RollupStep(StepKey key, StepKey nextStepKey, Client client, RollupActionConfig config) {\n+        super(key, nextStepKey, client);\n+        this.config = config;\n+    }\n+\n+    public static String getRollupIndexName(String index) {\n+        return ROLLUP_INDEX_NAME_PREFIX + index;\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void performAction(IndexMetadata indexMetadata, ClusterState currentState, ClusterStateObserver observer, Listener listener) {\n+        String originalIndex = indexMetadata.getIndex().getName();\n+        RollupAction.Request request = new RollupAction.Request(originalIndex, getRollupIndexName(originalIndex), config);\n+        getClient().execute(RollupAction.INSTANCE, request,\n+            ActionListener.wrap(response -> listener.onResponse(true), listener::onFailure));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d03113bdf55d7bb1747c4d5560657834f88f996"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU1Mjk1MTI0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/UpdateRollupIndexPolicyStep.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNVQyMjo1OTowNFrOIZ9_bw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNVQyMjo1OTowNFrOIZ9_bw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDEwMDk3NQ==", "bodyText": "This should check the acknowledged flag, throwing an exception if it was not acknowledged (so that the settings update will be retried)", "url": "https://github.com/elastic/elasticsearch/pull/65633#discussion_r564100975", "createdAt": "2021-01-25T22:59:04Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/UpdateRollupIndexPolicyStep.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateObserver;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.common.settings.Settings;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Updates the lifecycle policy for the rollup index for the original/currently managed index\n+ */\n+public class UpdateRollupIndexPolicyStep extends AsyncActionStep {\n+    public static final String NAME = \"update-rollup-policy\";\n+\n+    private final String rollupPolicy;\n+\n+    public UpdateRollupIndexPolicyStep(StepKey key, StepKey nextStepKey, Client client, String rollupPolicy) {\n+        super(key, nextStepKey, client);\n+        this.rollupPolicy = rollupPolicy;\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    public String getRollupPolicy() {\n+        return rollupPolicy;\n+    }\n+\n+    @Override\n+    public void performAction(IndexMetadata indexMetadata, ClusterState currentState, ClusterStateObserver observer, Listener listener) {\n+        String rollupIndex = RollupStep.getRollupIndexName(indexMetadata.getIndex().getName());\n+        Settings settings = Settings.builder().put(LifecycleSettings.LIFECYCLE_NAME, rollupPolicy).build();\n+        UpdateSettingsRequest updateSettingsRequest = new UpdateSettingsRequest(rollupIndex)\n+            .masterNodeTimeout(getMasterTimeout(currentState))\n+            .settings(settings);\n+        getClient().admin().indices().updateSettings(updateSettingsRequest,\n+                ActionListener.wrap(response -> listener.onResponse(true), listener::onFailure));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d03113bdf55d7bb1747c4d5560657834f88f996"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU1NzkwMDA0OnYy", "diffSide": "RIGHT", "path": "docs/reference/ilm/ilm-actions.asciidoc", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNlQyMjoyMDoyMVrOIatJMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QyMDozNDo1MFrOIbaahA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDg3MzUyMA==", "bodyText": "Hey @jrodewig, mind letting me know if I did this right? thanks!", "url": "https://github.com/elastic/elasticsearch/pull/65633#discussion_r564873520", "createdAt": "2021-01-26T22:20:21Z", "author": {"login": "talevy"}, "path": "docs/reference/ilm/ilm-actions.asciidoc", "diffHunk": "@@ -63,4 +67,7 @@ include::actions/ilm-set-priority.asciidoc[]\n include::actions/ilm-shrink.asciidoc[]\n include::actions/ilm-unfollow.asciidoc[]\n include::actions/ilm-wait-for-snapshot.asciidoc[]\n+\n+ifdef::permanently-unreleased-branch[]\n include::actions/ilm-rollup.asciidoc[]\n+endif::[]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49b58022be6b6b197dbafe25f58ed3fc23474aca"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTMxMDY4Ng==", "bodyText": "This looks correct to me!", "url": "https://github.com/elastic/elasticsearch/pull/65633#discussion_r565310686", "createdAt": "2021-01-27T13:34:08Z", "author": {"login": "jrodewig"}, "path": "docs/reference/ilm/ilm-actions.asciidoc", "diffHunk": "@@ -63,4 +67,7 @@ include::actions/ilm-set-priority.asciidoc[]\n include::actions/ilm-shrink.asciidoc[]\n include::actions/ilm-unfollow.asciidoc[]\n include::actions/ilm-wait-for-snapshot.asciidoc[]\n+\n+ifdef::permanently-unreleased-branch[]\n include::actions/ilm-rollup.asciidoc[]\n+endif::[]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDg3MzUyMA=="}, "originalCommit": {"oid": "49b58022be6b6b197dbafe25f58ed3fc23474aca"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTYxNTIzNg==", "bodyText": "thanks!", "url": "https://github.com/elastic/elasticsearch/pull/65633#discussion_r565615236", "createdAt": "2021-01-27T20:34:50Z", "author": {"login": "talevy"}, "path": "docs/reference/ilm/ilm-actions.asciidoc", "diffHunk": "@@ -63,4 +67,7 @@ include::actions/ilm-set-priority.asciidoc[]\n include::actions/ilm-shrink.asciidoc[]\n include::actions/ilm-unfollow.asciidoc[]\n include::actions/ilm-wait-for-snapshot.asciidoc[]\n+\n+ifdef::permanently-unreleased-branch[]\n include::actions/ilm-rollup.asciidoc[]\n+endif::[]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDg3MzUyMA=="}, "originalCommit": {"oid": "49b58022be6b6b197dbafe25f58ed3fc23474aca"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU2MDc2Mjk5OnYy", "diffSide": "RIGHT", "path": "docs/reference/ilm/actions/ilm-rollup.asciidoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QxMzozNTo0MlrOIbH5Ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QxMzozNTo0MlrOIbH5Ag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTMxMTc0Ng==", "bodyText": "I don't think we need the caps here.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            For more information about Rollup, check out the <<rollup-api, Rollup Action Documentation>>\n          \n          \n            \n            For more information about rollup, see the <<rollup-api, rollup action documentation>>", "url": "https://github.com/elastic/elasticsearch/pull/65633#discussion_r565311746", "createdAt": "2021-01-27T13:35:42Z", "author": {"login": "jrodewig"}, "path": "docs/reference/ilm/actions/ilm-rollup.asciidoc", "diffHunk": "@@ -0,0 +1,56 @@\n+[role=\"xpack\"]\n+[[ilm-rollup]]\n+=== Rollup\n+\n+Phases allowed: hot, cold.\n+\n+Aggregates an index's time series data and stores the results in a new read-only\n+index. For example, you can roll up hourly data into daily or weekly summaries.\n+\n+For more information about Rollup, check out the <<rollup-api, Rollup Action Documentation>>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49b58022be6b6b197dbafe25f58ed3fc23474aca"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU2MDc2MzQ5OnYy", "diffSide": "RIGHT", "path": "docs/reference/ilm/actions/ilm-rollup.asciidoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QxMzozNTo1MFrOIbH5Wg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QxMzozNTo1MFrOIbH5Wg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTMxMTgzNA==", "bodyText": "Ditto on caps.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The Rollup configuration, a more detailed description of the\n          \n          \n            \n            Rollup configuration specification can be found <<rollup-api-request-body,here>>.\n          \n          \n            \n            The rollup configuration, a more detailed description of the\n          \n          \n            \n            rollup configuration specification can be found <<rollup-api-request-body,here>>.", "url": "https://github.com/elastic/elasticsearch/pull/65633#discussion_r565311834", "createdAt": "2021-01-27T13:35:50Z", "author": {"login": "jrodewig"}, "path": "docs/reference/ilm/actions/ilm-rollup.asciidoc", "diffHunk": "@@ -0,0 +1,56 @@\n+[role=\"xpack\"]\n+[[ilm-rollup]]\n+=== Rollup\n+\n+Phases allowed: hot, cold.\n+\n+Aggregates an index's time series data and stores the results in a new read-only\n+index. For example, you can roll up hourly data into daily or weekly summaries.\n+\n+For more information about Rollup, check out the <<rollup-api, Rollup Action Documentation>>\n+\n+The name of the rolled up index will be the original index name of the managed index prefixed\n+with `rollup-`.\n+\n+[[ilm-rollup-options]]\n+==== Rollup options\n+`config`::\n+(Required, integer)\n+The Rollup configuration, a more detailed description of the\n+Rollup configuration specification can be found <<rollup-api-request-body,here>>.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49b58022be6b6b197dbafe25f58ed3fc23474aca"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU2MDk0MTUyOnYy", "diffSide": "RIGHT", "path": "docs/reference/ilm/actions/ilm-rollup.asciidoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QxNDoxMzo0N1rOIbJmxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QxNDoxMzo0N1rOIbJmxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTMzOTg0Ng==", "bodyText": "Removes a duplicate space.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The name of an  <<index-lifecycle-management, {ilm}>> ({ilm-init}) policy to associate\n          \n          \n            \n            The name of an <<index-lifecycle-management, {ilm}>> ({ilm-init}) policy to associate", "url": "https://github.com/elastic/elasticsearch/pull/65633#discussion_r565339846", "createdAt": "2021-01-27T14:13:47Z", "author": {"login": "jrodewig"}, "path": "docs/reference/ilm/actions/ilm-rollup.asciidoc", "diffHunk": "@@ -0,0 +1,56 @@\n+[role=\"xpack\"]\n+[[ilm-rollup]]\n+=== Rollup\n+\n+Phases allowed: hot, cold.\n+\n+Aggregates an index's time series data and stores the results in a new read-only\n+index. For example, you can roll up hourly data into daily or weekly summaries.\n+\n+For more information about Rollup, check out the <<rollup-api, Rollup Action Documentation>>\n+\n+The name of the rolled up index will be the original index name of the managed index prefixed\n+with `rollup-`.\n+\n+[[ilm-rollup-options]]\n+==== Rollup options\n+`config`::\n+(Required, integer)\n+The Rollup configuration, a more detailed description of the\n+Rollup configuration specification can be found <<rollup-api-request-body,here>>.\n+\n+`rollup_policy`::\n+(Optional, string)\n+The name of an  <<index-lifecycle-management, {ilm}>> ({ilm-init}) policy to associate", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49b58022be6b6b197dbafe25f58ed3fc23474aca"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU2ODAwMDE2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/TimeseriesLifecycleType.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOFQyMjoxMDo1MFrOIcM3FQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOFQyMzoxODoyOVrOIcOy1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjQ0MTc0OQ==", "bodyText": "I missed this before, but if we're going to rollup right after a shrink and force merge, what's the point of shrinking and force merging? Should we just rollup first and then do the shrink/forcemerge?\n(I think this is okay to leave as is for now, but we might want to investigate making them mutually exclusive in the future so we don't waste resources doing a shrink and force merge right before we rollup and create a new index anyway. At the very least I think maybe force merge should move to after the Rollup?)", "url": "https://github.com/elastic/elasticsearch/pull/65633#discussion_r566441749", "createdAt": "2021-01-28T22:10:50Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/TimeseriesLifecycleType.java", "diffHunk": "@@ -40,28 +41,43 @@\n     static final String COLD_PHASE = \"cold\";\n     static final String DELETE_PHASE = \"delete\";\n     static final List<String> VALID_PHASES = Arrays.asList(HOT_PHASE, WARM_PHASE, COLD_PHASE, DELETE_PHASE);\n-    static final List<String> ORDERED_VALID_HOT_ACTIONS = Arrays.asList(SetPriorityAction.NAME, UnfollowAction.NAME, RolloverAction.NAME,\n-        ReadOnlyAction.NAME, ShrinkAction.NAME, ForceMergeAction.NAME, SearchableSnapshotAction.NAME);\n+    static final List<String> ORDERED_VALID_HOT_ACTIONS;\n     static final List<String> ORDERED_VALID_WARM_ACTIONS = Arrays.asList(SetPriorityAction.NAME, UnfollowAction.NAME, ReadOnlyAction.NAME,\n         AllocateAction.NAME, MigrateAction.NAME, ShrinkAction.NAME, ForceMergeAction.NAME);\n-    static final List<String> ORDERED_VALID_COLD_ACTIONS = Arrays.asList(SetPriorityAction.NAME, UnfollowAction.NAME, AllocateAction.NAME,\n-        MigrateAction.NAME, FreezeAction.NAME, SearchableSnapshotAction.NAME);\n+    static final List<String> ORDERED_VALID_COLD_ACTIONS;\n     static final List<String> ORDERED_VALID_DELETE_ACTIONS = Arrays.asList(WaitForSnapshotAction.NAME, DeleteAction.NAME);\n-    static final Set<String> VALID_HOT_ACTIONS = Sets.newHashSet(ORDERED_VALID_HOT_ACTIONS);\n+    static final Set<String> VALID_HOT_ACTIONS;\n     static final Set<String> VALID_WARM_ACTIONS = Sets.newHashSet(ORDERED_VALID_WARM_ACTIONS);\n-    static final Set<String> VALID_COLD_ACTIONS = Sets.newHashSet(ORDERED_VALID_COLD_ACTIONS);\n+    static final Set<String> VALID_COLD_ACTIONS;\n     static final Set<String> VALID_DELETE_ACTIONS = Sets.newHashSet(ORDERED_VALID_DELETE_ACTIONS);\n-    private static final Map<String, Set<String>> ALLOWED_ACTIONS = Map.of(\n-        HOT_PHASE, VALID_HOT_ACTIONS,\n-        WARM_PHASE, VALID_WARM_ACTIONS,\n-        COLD_PHASE, VALID_COLD_ACTIONS,\n-        DELETE_PHASE, VALID_DELETE_ACTIONS);\n+    private static final Map<String, Set<String>> ALLOWED_ACTIONS;\n \n     static final Set<String> HOT_ACTIONS_THAT_REQUIRE_ROLLOVER = Sets.newHashSet(ReadOnlyAction.NAME, ShrinkAction.NAME,\n-        ForceMergeAction.NAME, SearchableSnapshotAction.NAME);\n+        ForceMergeAction.NAME, RollupILMAction.NAME, SearchableSnapshotAction.NAME);\n     // a set of actions that cannot be defined (executed) after the managed index has been mounted as searchable snapshot\n     static final Set<String> ACTIONS_CANNOT_FOLLOW_SEARCHABLE_SNAPSHOT = Sets.newHashSet(ShrinkAction.NAME, ForceMergeAction.NAME,\n-        FreezeAction.NAME, SearchableSnapshotAction.NAME);\n+        FreezeAction.NAME, SearchableSnapshotAction.NAME, RollupILMAction.NAME);\n+\n+    static {\n+        if (RollupV2.isEnabled()) {\n+            ORDERED_VALID_HOT_ACTIONS = Arrays.asList(SetPriorityAction.NAME, UnfollowAction.NAME, RolloverAction.NAME,\n+                ReadOnlyAction.NAME, ShrinkAction.NAME, ForceMergeAction.NAME, RollupILMAction.NAME, SearchableSnapshotAction.NAME);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "382915d803b5cf755fef06bd7f6e3a2b4c594c7a"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjQ3MzQzMQ==", "bodyText": "these are fair points. I figured these things would occur anyways, so order should not matter at the end of the day. That being said, waiting to do these operations before rolling up is not necessary. it might be interesting to benchmark and see if fewer shards ends up resulting in a faster rollup or not. but this should not be of concern to the user anyways.\nI will move Rollup to happen before Shrink, but will bring this up with the team to see if there are any other opinions", "url": "https://github.com/elastic/elasticsearch/pull/65633#discussion_r566473431", "createdAt": "2021-01-28T23:18:29Z", "author": {"login": "talevy"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/TimeseriesLifecycleType.java", "diffHunk": "@@ -40,28 +41,43 @@\n     static final String COLD_PHASE = \"cold\";\n     static final String DELETE_PHASE = \"delete\";\n     static final List<String> VALID_PHASES = Arrays.asList(HOT_PHASE, WARM_PHASE, COLD_PHASE, DELETE_PHASE);\n-    static final List<String> ORDERED_VALID_HOT_ACTIONS = Arrays.asList(SetPriorityAction.NAME, UnfollowAction.NAME, RolloverAction.NAME,\n-        ReadOnlyAction.NAME, ShrinkAction.NAME, ForceMergeAction.NAME, SearchableSnapshotAction.NAME);\n+    static final List<String> ORDERED_VALID_HOT_ACTIONS;\n     static final List<String> ORDERED_VALID_WARM_ACTIONS = Arrays.asList(SetPriorityAction.NAME, UnfollowAction.NAME, ReadOnlyAction.NAME,\n         AllocateAction.NAME, MigrateAction.NAME, ShrinkAction.NAME, ForceMergeAction.NAME);\n-    static final List<String> ORDERED_VALID_COLD_ACTIONS = Arrays.asList(SetPriorityAction.NAME, UnfollowAction.NAME, AllocateAction.NAME,\n-        MigrateAction.NAME, FreezeAction.NAME, SearchableSnapshotAction.NAME);\n+    static final List<String> ORDERED_VALID_COLD_ACTIONS;\n     static final List<String> ORDERED_VALID_DELETE_ACTIONS = Arrays.asList(WaitForSnapshotAction.NAME, DeleteAction.NAME);\n-    static final Set<String> VALID_HOT_ACTIONS = Sets.newHashSet(ORDERED_VALID_HOT_ACTIONS);\n+    static final Set<String> VALID_HOT_ACTIONS;\n     static final Set<String> VALID_WARM_ACTIONS = Sets.newHashSet(ORDERED_VALID_WARM_ACTIONS);\n-    static final Set<String> VALID_COLD_ACTIONS = Sets.newHashSet(ORDERED_VALID_COLD_ACTIONS);\n+    static final Set<String> VALID_COLD_ACTIONS;\n     static final Set<String> VALID_DELETE_ACTIONS = Sets.newHashSet(ORDERED_VALID_DELETE_ACTIONS);\n-    private static final Map<String, Set<String>> ALLOWED_ACTIONS = Map.of(\n-        HOT_PHASE, VALID_HOT_ACTIONS,\n-        WARM_PHASE, VALID_WARM_ACTIONS,\n-        COLD_PHASE, VALID_COLD_ACTIONS,\n-        DELETE_PHASE, VALID_DELETE_ACTIONS);\n+    private static final Map<String, Set<String>> ALLOWED_ACTIONS;\n \n     static final Set<String> HOT_ACTIONS_THAT_REQUIRE_ROLLOVER = Sets.newHashSet(ReadOnlyAction.NAME, ShrinkAction.NAME,\n-        ForceMergeAction.NAME, SearchableSnapshotAction.NAME);\n+        ForceMergeAction.NAME, RollupILMAction.NAME, SearchableSnapshotAction.NAME);\n     // a set of actions that cannot be defined (executed) after the managed index has been mounted as searchable snapshot\n     static final Set<String> ACTIONS_CANNOT_FOLLOW_SEARCHABLE_SNAPSHOT = Sets.newHashSet(ShrinkAction.NAME, ForceMergeAction.NAME,\n-        FreezeAction.NAME, SearchableSnapshotAction.NAME);\n+        FreezeAction.NAME, SearchableSnapshotAction.NAME, RollupILMAction.NAME);\n+\n+    static {\n+        if (RollupV2.isEnabled()) {\n+            ORDERED_VALID_HOT_ACTIONS = Arrays.asList(SetPriorityAction.NAME, UnfollowAction.NAME, RolloverAction.NAME,\n+                ReadOnlyAction.NAME, ShrinkAction.NAME, ForceMergeAction.NAME, RollupILMAction.NAME, SearchableSnapshotAction.NAME);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjQ0MTc0OQ=="}, "originalCommit": {"oid": "382915d803b5cf755fef06bd7f6e3a2b4c594c7a"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU2OTI5MzgxOnYy", "diffSide": "RIGHT", "path": "docs/reference/ilm/actions/ilm-rollup.asciidoc", "isResolved": false, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOVQwNzo0OTowNlrOIcYnOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wM1QwODowNTowNVrOIe1ZPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjYzNDI5OQ==", "bodyText": "@talevy How does this work in the context of data streams? Does it work in the context of data streams? What are the index names there?", "url": "https://github.com/elastic/elasticsearch/pull/65633#discussion_r566634299", "createdAt": "2021-01-29T07:49:06Z", "author": {"login": "ruflin"}, "path": "docs/reference/ilm/actions/ilm-rollup.asciidoc", "diffHunk": "@@ -0,0 +1,56 @@\n+[role=\"xpack\"]\n+[[ilm-rollup]]\n+=== Rollup\n+\n+Phases allowed: hot, cold.\n+\n+Aggregates an index's time series data and stores the results in a new read-only\n+index. For example, you can roll up hourly data into daily or weekly summaries.\n+\n+For more information about rollup, see the <<rollup-api, rollup action documentation>>\n+\n+The name of the rolled up index will be the original index name of the managed index prefixed", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec30764aa31ee8910b7d850492246198e201e70c"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Njg1NTYxNg==", "bodyText": "ILM works on the index level, not directly on data streams. You can roll up a backing index for a data stream but not a data stream itself.\nIf the index is a backing index for a data stream, the rollup index is a backing index for the same stream. The name of the new rollup index is based on the name of the backing index. For example, the name of a rollup index for .ds-my-data-stream-2021.01.29-000001 would be rollup-.ds-my-data-stream-2021.01.29-000001.\nI hope that helps. I'll open up a follow-up PR to better clarify this in the docs.", "url": "https://github.com/elastic/elasticsearch/pull/65633#discussion_r566855616", "createdAt": "2021-01-29T14:24:00Z", "author": {"login": "jrodewig"}, "path": "docs/reference/ilm/actions/ilm-rollup.asciidoc", "diffHunk": "@@ -0,0 +1,56 @@\n+[role=\"xpack\"]\n+[[ilm-rollup]]\n+=== Rollup\n+\n+Phases allowed: hot, cold.\n+\n+Aggregates an index's time series data and stores the results in a new read-only\n+index. For example, you can roll up hourly data into daily or weekly summaries.\n+\n+For more information about rollup, see the <<rollup-api, rollup action documentation>>\n+\n+The name of the rolled up index will be the original index name of the managed index prefixed", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjYzNDI5OQ=="}, "originalCommit": {"oid": "ec30764aa31ee8910b7d850492246198e201e70c"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjkxMTUyNw==", "bodyText": "Hey @ruflin and @jrodewig,\nthis is exactly how it works today, but due to some failure-scenarios we discussed recently, we're going to change this behavior.\nIn the context of datastreams, we will likely randomize the name of the rollup index to prevent collision and conflict with any past or rogue rollup actions. The belief is that the underlying name of the index should not be of concern to users since they will be added into the datastream and managed in ILM. Do you see any problems with this on your end @ruflin?\nFor this reason, it might make sense to hold off just a little bit on your docs change PR @jrodewig, but much appreciated!\nI've opened #68225 to track it. Will likely change next week", "url": "https://github.com/elastic/elasticsearch/pull/65633#discussion_r566911527", "createdAt": "2021-01-29T15:44:44Z", "author": {"login": "talevy"}, "path": "docs/reference/ilm/actions/ilm-rollup.asciidoc", "diffHunk": "@@ -0,0 +1,56 @@\n+[role=\"xpack\"]\n+[[ilm-rollup]]\n+=== Rollup\n+\n+Phases allowed: hot, cold.\n+\n+Aggregates an index's time series data and stores the results in a new read-only\n+index. For example, you can roll up hourly data into daily or weekly summaries.\n+\n+For more information about rollup, see the <<rollup-api, rollup action documentation>>\n+\n+The name of the rolled up index will be the original index name of the managed index prefixed", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjYzNDI5OQ=="}, "originalCommit": {"oid": "ec30764aa31ee8910b7d850492246198e201e70c"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjkxNzA1MQ==", "bodyText": "Thanks for the update, @talevy!", "url": "https://github.com/elastic/elasticsearch/pull/65633#discussion_r566917051", "createdAt": "2021-01-29T15:52:38Z", "author": {"login": "jrodewig"}, "path": "docs/reference/ilm/actions/ilm-rollup.asciidoc", "diffHunk": "@@ -0,0 +1,56 @@\n+[role=\"xpack\"]\n+[[ilm-rollup]]\n+=== Rollup\n+\n+Phases allowed: hot, cold.\n+\n+Aggregates an index's time series data and stores the results in a new read-only\n+index. For example, you can roll up hourly data into daily or weekly summaries.\n+\n+For more information about rollup, see the <<rollup-api, rollup action documentation>>\n+\n+The name of the rolled up index will be the original index name of the managed index prefixed", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjYzNDI5OQ=="}, "originalCommit": {"oid": "ec30764aa31ee8910b7d850492246198e201e70c"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzY4NjY4MA==", "bodyText": "The belief is that the underlying name of the index should not be of concern to users since they will be added into the datastream and managed in ILM\n\nIf this is the case, it is great. I was under the assumption all indices belong to a data stream must use the .ds-* prefix and be hidden. So I expect index names like .ds-rollup-* or something similar. This would also ensure there are no conflicts and makes it clear that these rollups belong to the data streams.\nThe rollup- prefix is what put me on the wrong track here and made me assume it does not belong to the data stream.", "url": "https://github.com/elastic/elasticsearch/pull/65633#discussion_r567686680", "createdAt": "2021-02-01T09:46:22Z", "author": {"login": "ruflin"}, "path": "docs/reference/ilm/actions/ilm-rollup.asciidoc", "diffHunk": "@@ -0,0 +1,56 @@\n+[role=\"xpack\"]\n+[[ilm-rollup]]\n+=== Rollup\n+\n+Phases allowed: hot, cold.\n+\n+Aggregates an index's time series data and stores the results in a new read-only\n+index. For example, you can roll up hourly data into daily or weekly summaries.\n+\n+For more information about rollup, see the <<rollup-api, rollup action documentation>>\n+\n+The name of the rolled up index will be the original index name of the managed index prefixed", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjYzNDI5OQ=="}, "originalCommit": {"oid": "ec30764aa31ee8910b7d850492246198e201e70c"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODIzODcyNw==", "bodyText": "it is actually common for indices managed by ILM to be renamed with a new prefix. For example, shrunken indices start with the shrunk- prefix.\nindependent of the name, the indices will be hidden and added to the backing datastream", "url": "https://github.com/elastic/elasticsearch/pull/65633#discussion_r568238727", "createdAt": "2021-02-02T00:32:34Z", "author": {"login": "talevy"}, "path": "docs/reference/ilm/actions/ilm-rollup.asciidoc", "diffHunk": "@@ -0,0 +1,56 @@\n+[role=\"xpack\"]\n+[[ilm-rollup]]\n+=== Rollup\n+\n+Phases allowed: hot, cold.\n+\n+Aggregates an index's time series data and stores the results in a new read-only\n+index. For example, you can roll up hourly data into daily or weekly summaries.\n+\n+For more information about rollup, see the <<rollup-api, rollup action documentation>>\n+\n+The name of the rolled up index will be the original index name of the managed index prefixed", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjYzNDI5OQ=="}, "originalCommit": {"oid": "ec30764aa31ee8910b7d850492246198e201e70c"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTIwMzAwNw==", "bodyText": "@talevy Interesting. Why are these not prefixed by a . and not inside .ds-*-shrunk-* or similar to indicate they belong together? I think I'm derailing but could you share a link where I can read up on this? The part I'm concerned is that this not seem to fully fit into our naming scheme: https://www.elastic.co/blog/an-introduction-to-the-elastic-data-stream-naming-scheme", "url": "https://github.com/elastic/elasticsearch/pull/65633#discussion_r569203007", "createdAt": "2021-02-03T08:05:05Z", "author": {"login": "ruflin"}, "path": "docs/reference/ilm/actions/ilm-rollup.asciidoc", "diffHunk": "@@ -0,0 +1,56 @@\n+[role=\"xpack\"]\n+[[ilm-rollup]]\n+=== Rollup\n+\n+Phases allowed: hot, cold.\n+\n+Aggregates an index's time series data and stores the results in a new read-only\n+index. For example, you can roll up hourly data into daily or weekly summaries.\n+\n+For more information about rollup, see the <<rollup-api, rollup action documentation>>\n+\n+The name of the rolled up index will be the original index name of the managed index prefixed", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjYzNDI5OQ=="}, "originalCommit": {"oid": "ec30764aa31ee8910b7d850492246198e201e70c"}, "originalPosition": 12}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1855, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}