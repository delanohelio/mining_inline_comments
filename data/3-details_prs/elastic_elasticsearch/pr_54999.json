{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAxMjI3MTgz", "number": 54999, "title": "Handle TLS file updates during startup", "bodyText": "This change reworks the loading and monitoring of files that are used\nfor the construction of SSLContexts so that updates to these files are\nnot lost if the updates occur during startup. Previously, the\nSSLService would parse the settings, build the SSLConfiguration\nobjects, and construct the SSLContexts prior to the\nSSLConfigurationReloader starting to monitor these files for changes.\nThis allowed for a small window where updates to these files may never\nbe observed until the node restarted.\nTo remove the potential miss of a change to these files, the code now\nparses the settings and builds SSLConfiguration instances prior to the\nconstruction of the SSLService. The files back the SSLConfiguration\ninstances are then registered for monitoring and finally the SSLService\nis constructed from the previously parse SSLConfiguration instances. As\nthe SSLService is not constructed when the code starts monitoring the\nfiles for changes, a CompleteableFuture is used to obtain a reference\nto the SSLService; this allows for construction of the SSLService to\ncomplete and ensures that we do not miss any file updates during the\nconstruction of the SSLService.\nWhile working on this change, the SSLConfigurationReloader was also\nrefactored to reflect how it is currently used. When the\nSSLConfigurationReloader was originally written the files that it\nmonitored could change during runtime. This is no longer the case as\nwe stopped the monitoring of files that back dynamic SSLContext\ninstances. In order to support the ability for items to change during\nruntime, the class made use of concurrent data structures. The use of\nthese concurrent datastructures has been removed.\nCloses #54867", "createdAt": "2020-04-09T06:04:22Z", "url": "https://github.com/elastic/elasticsearch/pull/54999", "merged": true, "mergeCommit": {"oid": "f9de7ce82e0c8bec589ddb5201e44e3a83054cd1"}, "closed": true, "closedAt": "2020-04-16T16:47:36Z", "author": {"login": "jaymode"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcV15GrAH2gAyNDAxMjI3MTgzOjYwNzg4ZjEwZGQzY2IxNGU3ZDFhOTA0MTc0ZWQ1N2M0NDRiYTIxMTM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcYD88mgFqTM5NDI3MTM0OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "60788f10dd3cb14e7d1a904174ed57c444ba2113", "author": {"user": {"login": "jaymode", "name": "Jay Modi"}}, "url": "https://github.com/elastic/elasticsearch/commit/60788f10dd3cb14e7d1a904174ed57c444ba2113", "committedDate": "2020-04-09T05:45:50Z", "message": "Handle TLS file updates during startup\n\nThis change reworks the loading and monitoring of files that are used\nfor the construction of SSLContexts so that updates to these files are\nnot lost if the updates occur during startup. Previously, the\nSSLService would parse the settings, build the SSLConfiguration\nobjects, and construct the SSLContexts prior to the\nSSLConfigurationReloader starting to monitor these files for changes.\nThis allowed for a small window where updates to these files may never\nbe observed until the node restarted.\n\nTo remove the potential miss of a change to these files, the code now\nparses the settings and builds SSLConfiguration instances prior to the\nconstruction of the SSLService. The files back the SSLConfiguration\ninstances are then registered for monitoring and finally the SSLService\nis constructed from the previously parse SSLConfiguration instances. As\nthe SSLService is not constructed when the code starts monitoring the\nfiles for changes, a CompleteableFuture is used to obtain a reference\nto the SSLService; this allows for construction of the SSLService to\ncomplete and ensures that we do not miss any file updates during the\nconstruction of the SSLService.\n\nWhile working on this change, the SSLConfigurationReloader was also\nrefactored to reflect how it is currently used. When the\nSSLConfigurationReloader was originally written the files that it\nmonitored could change during runtime. This is no longer the case as\nwe stopped the monitoring of files that back dynamic SSLContext\ninstances. In order to support the ability for items to change during\nruntime, the class made use of concurrent data structures. The use of\nthese concurrent datastructures has been removed and the class is now\nprimarily a utility class that no longer needs to be instantiated.\n\nCloses #54867"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyNTM3NjIy", "url": "https://github.com/elastic/elasticsearch/pull/54999#pullrequestreview-392537622", "createdAt": "2020-04-14T01:08:06Z", "commit": {"oid": "60788f10dd3cb14e7d1a904174ed57c444ba2113"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwMTowODowNlrOGE6itA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwMjowMzo1NVrOGE7e4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgwNjY0NA==", "bodyText": "This is a nice change to have immutable list of SSLConfiguration and avoid the overhead of CopyOnWriteArraySet.", "url": "https://github.com/elastic/elasticsearch/pull/54999#discussion_r407806644", "createdAt": "2020-04-14T01:08:06Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ssl/SSLConfigurationReloader.java", "diffHunk": "@@ -17,68 +17,55 @@\n \n import java.io.IOException;\n import java.nio.file.Path;\n+import java.util.ArrayList;\n import java.util.Collection;\n+import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.function.Consumer;\n \n /**\n  * Ensures that the files backing an {@link SSLConfiguration} are monitored for changes and the underlying key/trust material is reloaded\n  * and the {@link SSLContext} has existing sessions invalidated to force the use of the new key/trust material\n  */\n-public class SSLConfigurationReloader {\n+public final class SSLConfigurationReloader {\n \n     private static final Logger logger = LogManager.getLogger(SSLConfigurationReloader.class);\n \n-    private final ConcurrentHashMap<Path, ChangeListener> pathToChangeListenerMap = new ConcurrentHashMap<>();\n-    private final Environment environment;\n-    private final ResourceWatcherService resourceWatcherService;\n-    private final SSLService sslService;\n-\n-    public SSLConfigurationReloader(Environment env, SSLService sslService, ResourceWatcherService resourceWatcher) {\n-        this.environment = env;\n-        this.resourceWatcherService = resourceWatcher;\n-        this.sslService = sslService;\n-        startWatching(sslService.getLoadedSSLConfigurations());\n-    }\n+    private SSLConfigurationReloader() { }\n \n     /**\n      * Collects all of the directories that need to be monitored for the provided {@link SSLConfiguration} instances and ensures that\n      * they are being watched for changes\n      */\n-    private void startWatching(Collection<SSLConfiguration> sslConfigurations) {\n+    public static void startWatching(Environment environment, Consumer<SSLConfiguration> reloadConsumer,\n+                                      ResourceWatcherService resourceWatcherService, Collection<SSLConfiguration> sslConfigurations) {\n+        Map<Path, List<SSLConfiguration>> pathToConfigurationsMap = new HashMap<>();\n         for (SSLConfiguration sslConfiguration : sslConfigurations) {\n             for (Path directory : directoriesToMonitor(sslConfiguration.filesToMonitor(environment))) {\n-                pathToChangeListenerMap.compute(directory, (path, listener) -> {\n-                    if (listener != null) {\n-                        listener.addSSLConfiguration(sslConfiguration);\n-                        return listener;\n+                pathToConfigurationsMap.compute(directory, (path, list) -> {\n+                    if (list == null) {\n+                        list = new ArrayList<>();\n                     }\n-\n-                    ChangeListener changeListener = new ChangeListener();\n-                    changeListener.addSSLConfiguration(sslConfiguration);\n-                    FileWatcher fileWatcher = new FileWatcher(path);\n-                    fileWatcher.addListener(changeListener);\n-                    try {\n-                        resourceWatcherService.add(fileWatcher, Frequency.HIGH);\n-                        return changeListener;\n-                    } catch (IOException e) {\n-                        logger.error(\"failed to start watching directory [{}] for ssl configuration [{}]\", path, sslConfiguration);\n-                    }\n-                    return null;\n+                    list.add(sslConfiguration);\n+                    return list;\n                 });\n             }\n         }\n-    }\n \n-    /**\n-     * Reloads the ssl context associated with this configuration. It is visible so that tests can override as needed\n-     */\n-    void reloadSSLContext(SSLConfiguration configuration) {\n-        logger.debug(\"reloading ssl configuration [{}]\", configuration);\n-        sslService.sslContextHolder(configuration).reload();\n+        for (Entry<Path, List<SSLConfiguration>> entry : pathToConfigurationsMap.entrySet()) {\n+            ChangeListener changeListener = new ChangeListener(environment, List.copyOf(entry.getValue()), reloadConsumer);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60788f10dd3cb14e7d1a904174ed57c444ba2113"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgxMDMyNg==", "bodyText": "What is this extra setting for?", "url": "https://github.com/elastic/elasticsearch/pull/54999#discussion_r407810326", "createdAt": "2020-04-14T01:21:44Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/test/SecuritySettingsSource.java", "diffHunk": "@@ -130,6 +131,7 @@ public Settings nodeSettings(int nodeOrdinal) {\n         writeFile(xpackConf, \"users_roles\", configUsersRoles());\n \n         Settings.Builder builder = Settings.builder()\n+                .put(Environment.PATH_HOME_SETTING.getKey(), home)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60788f10dd3cb14e7d1a904174ed57c444ba2113"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgxODIwNQ==", "bodyText": "I am not clear about the intention of these 2 latches. Why is it necessary? Could you please help me understand? Also would it be better to use Phaser here?", "url": "https://github.com/elastic/elasticsearch/pull/54999#discussion_r407818205", "createdAt": "2020-04-14T01:49:54Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/ssl/SSLReloadDuringStartupIntegTests.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.xpack.ssl;\n+\n+import org.elasticsearch.common.settings.MockSecureSettings;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.env.Environment;\n+import org.elasticsearch.env.TestEnvironment;\n+import org.elasticsearch.test.InternalTestCluster.RestartCallback;\n+import org.elasticsearch.test.SecurityIntegTestCase;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.AtomicMoveNotSupportedException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.util.concurrent.CountDownLatch;\n+\n+public class SSLReloadDuringStartupIntegTests extends SecurityIntegTestCase {\n+\n+    @Override\n+    public Settings nodeSettings(int nodeOrdinal) {\n+        Settings settings = super.nodeSettings(nodeOrdinal);\n+        Environment tmpEnv = TestEnvironment.newEnvironment(settings);\n+        // each node gets its own keystore under its home/config dir\n+        Path origKeystorePath = getDataPath(\"/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks\");\n+        Path nodeSpecificPath = tmpEnv.configFile().resolve(\"testnode.jks\");\n+        try {\n+            Files.copy(origKeystorePath, nodeSpecificPath, StandardCopyOption.REPLACE_EXISTING);\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+\n+        Settings.Builder builder = Settings.builder()\n+            .put(settings.filter((s) -> s.startsWith(\"xpack.security.transport.ssl.\") == false), false);\n+        MockSecureSettings secureSettings = new MockSecureSettings();\n+        builder.setSecureSettings(secureSettings);\n+        builder.put(\"xpack.security.transport.ssl.keystore.path\", nodeSpecificPath)\n+            .put(\"resource.reload.interval.high\", \"1s\")\n+            .put(\"xpack.security.transport.ssl.enabled\", true);\n+        secureSettings.setString(\"xpack.security.transport.ssl.keystore.secure_password\", \"testnode\");\n+        return builder.build();\n+    }\n+\n+    @Override\n+    protected boolean transportSSLEnabled() {\n+        return true;\n+    }\n+\n+    public void testReloadDuringStartup() throws Exception {\n+        final String node = randomFrom(internalCluster().getNodeNames());\n+        final Environment env = internalCluster().getInstance(Environment.class, node);\n+        final CountDownLatch latch = new CountDownLatch(2);\n+        final CountDownLatch writtenLatch = new CountDownLatch(1);\n+\n+        // restart the node\n+        internalCluster().restartNode(node, new RestartCallback() {\n+            @Override\n+            public Settings onNodeStopped(String nodeName) throws Exception {\n+                Path origKeystorePath = getDataPath(\"/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode.jks\");\n+                Path keystorePath = env.configFile().resolve(\"testnode.jks\");\n+                Path updatedKeystorePath = getDataPath(\"/org/elasticsearch/xpack/security/transport/ssl/certs/simple/testnode_updated.jks\");\n+                assertTrue(Files.exists(keystorePath));\n+                // replace the keystore\n+                copyAndAtomicMoveIfPossible(updatedKeystorePath, keystorePath);\n+                new Thread(() -> {\n+                    latch.countDown();\n+                    try {\n+                        latch.await();\n+                        Thread.sleep(randomLongBetween(1L, 2000L));\n+                    } catch (InterruptedException e) {\n+                        Thread.currentThread().interrupt();\n+                    }\n+\n+                    try {\n+                        copyAndAtomicMoveIfPossible(origKeystorePath, keystorePath);\n+                        writtenLatch.countDown();\n+                    } catch (IOException e) {\n+                        throw new UncheckedIOException(e);\n+                    }\n+                }).start();\n+\n+                latch.countDown();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60788f10dd3cb14e7d1a904174ed57c444ba2113"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgyMjA0OQ==", "bodyText": "Can we encapsulate this logic inside SSLConfigurationReloader like how it was before? I personally prefer to have SSLConfigurationReloader hide the complexitiy as much as possible. How about have APIs like the follows:\n\nsslConfigurationReloader = new SSLConfigurationReloader(...) to prepare everything and also create the Future object internally. So everything is ready just waiting for the future to be completed.\nsslConfigurationReloader.startWatching(sslService) to resolve the future internally. Effectively this method is just oneline of sslServiceFuture.complete(sslService)", "url": "https://github.com/elastic/elasticsearch/pull/54999#discussion_r407822049", "createdAt": "2020-04-14T02:03:55Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/XPackPlugin.java", "diffHunk": "@@ -233,10 +238,23 @@ public Settings additionalSettings() {\n                                                IndexNameExpressionResolver expressionResolver) {\n         List<Object> components = new ArrayList<>();\n \n-        final SSLService sslService = new SSLService(environment);\n+        final Map<String, SSLConfiguration> sslConfigurations = SSLService.getSSLConfigurations(environment.settings());\n+        final CompletableFuture<SSLService> sslServiceFuture = new CompletableFuture<>();\n+        final Consumer<SSLConfiguration> reloadConsumer = sslConfiguration -> {\n+            try {\n+                final SSLService sslService = sslServiceFuture.get();\n+                logger.debug(\"reloading ssl configuration [{}]\", sslConfiguration);\n+                sslService.reloadSSLContext(sslConfiguration);\n+            } catch (InterruptedException e) {\n+                Thread.currentThread().interrupt();\n+            } catch (ExecutionException e) {\n+                throw new ElasticsearchException(\"failed to obtain ssl service\", e);\n+            }\n+        };", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60788f10dd3cb14e7d1a904174ed57c444ba2113"}, "originalPosition": 43}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "25a1c9c3ff43d5a853925e3ff9932733ba6e34b6", "author": {"user": {"login": "jaymode", "name": "Jay Modi"}}, "url": "https://github.com/elastic/elasticsearch/commit/25a1c9c3ff43d5a853925e3ff9932733ba6e34b6", "committedDate": "2020-04-15T17:31:43Z", "message": "Merge branch 'master' into refactor_ssl_reloader"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6830389674428336d0ef21883d1e4b04c3e0c1e3", "author": {"user": {"login": "jaymode", "name": "Jay Modi"}}, "url": "https://github.com/elastic/elasticsearch/commit/6830389674428336d0ef21883d1e4b04c3e0c1e3", "committedDate": "2020-04-15T19:43:23Z", "message": "move to private method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2db3a9a6b724bdf6adf01972a9be8e2504a74698", "author": {"user": {"login": "jaymode", "name": "Jay Modi"}}, "url": "https://github.com/elastic/elasticsearch/commit/2db3a9a6b724bdf6adf01972a9be8e2504a74698", "committedDate": "2020-04-15T19:47:47Z", "message": "add comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "16196ed51005ed1edb3feb2903e4a7d1207f38c9", "author": {"user": {"login": "jaymode", "name": "Jay Modi"}}, "url": "https://github.com/elastic/elasticsearch/commit/16196ed51005ed1edb3feb2903e4a7d1207f38c9", "committedDate": "2020-04-16T01:44:47Z", "message": "Merge branch 'master' into refactor_ssl_reloader"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8f48415bbe4ad8e8dd3db1a4561a783b3a5533b0", "author": {"user": {"login": "jaymode", "name": "Jay Modi"}}, "url": "https://github.com/elastic/elasticsearch/commit/8f48415bbe4ad8e8dd3db1a4561a783b3a5533b0", "committedDate": "2020-04-16T02:17:26Z", "message": "refactor"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0MjcxMzQ4", "url": "https://github.com/elastic/elasticsearch/pull/54999#pullrequestreview-394271348", "createdAt": "2020-04-16T03:16:33Z", "commit": {"oid": "8f48415bbe4ad8e8dd3db1a4561a783b3a5533b0"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3637, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}