{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgyNjUzOTk2", "number": 53037, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNDowNzowM1rODlDopQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNDozNzo0NlrODlEZbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMTgzNDYxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/geogrid/GeoHashGridAggregatorFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNDowNzowM1rOFxujtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxODoxNzowMlrOFyej1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY4NzM0OA==", "bodyText": "I didn't know you could type cast a lambda, that's a really elegant solution.   I kind of want to go back and change some of the others to use this pattern.", "url": "https://github.com/elastic/elasticsearch/pull/53037#discussion_r387687348", "createdAt": "2020-03-04T14:07:03Z", "author": {"login": "not-napoleon"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/geogrid/GeoHashGridAggregatorFactory.java", "diffHunk": "@@ -79,15 +83,26 @@ protected Aggregator doCreateInternal(final ValuesSource valuesSource,\n                                             boolean collectsFromSingleBucket,\n                                             List<PipelineAggregator> pipelineAggregators,\n                                             Map<String, Object> metaData) throws IOException {\n-        if (valuesSource instanceof ValuesSource.GeoPoint  == false) {\n-            throw new AggregationExecutionException(\"ValuesSource type \" + valuesSource.toString() + \"is not supported for aggregation \" +\n-                this.name());\n+        AggregatorSupplier aggregatorSupplier = queryShardContext.getValuesSourceRegistry()\n+            .getAggregator(config.valueSourceType(), GeoHashGridAggregationBuilder.NAME);\n+        if (aggregatorSupplier instanceof GeoGridAggregatorSupplier == false) {\n+            throw new AggregationExecutionException(\"Registry miss-match - expected \"\n+                + GeoGridAggregatorSupplier.class.getName() + \", found [\" + aggregatorSupplier.getClass().toString() + \"]\");\n         }\n         if (collectsFromSingleBucket == false) {\n             return asMultiBucketAggregator(this, searchContext, parent);\n         }\n         CellIdSource cellIdSource = new CellIdSource((ValuesSource.GeoPoint) valuesSource, precision, geoBoundingBox, Geohash::longEncode);\n-        return new GeoHashGridAggregator(name, factories, cellIdSource, requiredSize, shardSize,\n+\n+        return ((GeoGridAggregatorSupplier) aggregatorSupplier).build(name, factories, cellIdSource, requiredSize, shardSize,\n             searchContext, parent, pipelineAggregators, metaData);\n     }\n+\n+    static void registerAggregators(ValuesSourceRegistry valuesSourceRegistry) {\n+        valuesSourceRegistry.register(GeoHashGridAggregationBuilder.NAME, CoreValuesSourceType.GEOPOINT,\n+            (GeoGridAggregatorSupplier) (name, factories, valuesSource, requiredSize, shardSize, aggregationContext, parent,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c2f63bfa507a5b89a2dcffa8298b875d69c6239"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ3MzgxNQ==", "bodyText": "I didn't either, but Intellij recommended it and then auto-wrote it for me!", "url": "https://github.com/elastic/elasticsearch/pull/53037#discussion_r388473815", "createdAt": "2020-03-05T18:17:02Z", "author": {"login": "talevy"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/geogrid/GeoHashGridAggregatorFactory.java", "diffHunk": "@@ -79,15 +83,26 @@ protected Aggregator doCreateInternal(final ValuesSource valuesSource,\n                                             boolean collectsFromSingleBucket,\n                                             List<PipelineAggregator> pipelineAggregators,\n                                             Map<String, Object> metaData) throws IOException {\n-        if (valuesSource instanceof ValuesSource.GeoPoint  == false) {\n-            throw new AggregationExecutionException(\"ValuesSource type \" + valuesSource.toString() + \"is not supported for aggregation \" +\n-                this.name());\n+        AggregatorSupplier aggregatorSupplier = queryShardContext.getValuesSourceRegistry()\n+            .getAggregator(config.valueSourceType(), GeoHashGridAggregationBuilder.NAME);\n+        if (aggregatorSupplier instanceof GeoGridAggregatorSupplier == false) {\n+            throw new AggregationExecutionException(\"Registry miss-match - expected \"\n+                + GeoGridAggregatorSupplier.class.getName() + \", found [\" + aggregatorSupplier.getClass().toString() + \"]\");\n         }\n         if (collectsFromSingleBucket == false) {\n             return asMultiBucketAggregator(this, searchContext, parent);\n         }\n         CellIdSource cellIdSource = new CellIdSource((ValuesSource.GeoPoint) valuesSource, precision, geoBoundingBox, Geohash::longEncode);\n-        return new GeoHashGridAggregator(name, factories, cellIdSource, requiredSize, shardSize,\n+\n+        return ((GeoGridAggregatorSupplier) aggregatorSupplier).build(name, factories, cellIdSource, requiredSize, shardSize,\n             searchContext, parent, pipelineAggregators, metaData);\n     }\n+\n+    static void registerAggregators(ValuesSourceRegistry valuesSourceRegistry) {\n+        valuesSourceRegistry.register(GeoHashGridAggregationBuilder.NAME, CoreValuesSourceType.GEOPOINT,\n+            (GeoGridAggregatorSupplier) (name, factories, valuesSource, requiredSize, shardSize, aggregationContext, parent,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY4NzM0OA=="}, "originalCommit": {"oid": "7c2f63bfa507a5b89a2dcffa8298b875d69c6239"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMTg2OTQ0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/geogrid/GeoHashGridAggregatorFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNDoxNjoyMFrOFxu4_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxODoxNzoyMlrOFyekiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY5Mjc5Ng==", "bodyText": "I think we need to move creating the CellIdSource into the supplier.  This line is casting to a GeoPoint, but we don't know that we always have a GeoPoint here, because we can't know at compile time what Values Sources have been registered for this aggregation.  My guideline has been that we should only care about ValuesSource subclasses at the supplier layer or the aggregator itself, not the factory or the builder.", "url": "https://github.com/elastic/elasticsearch/pull/53037#discussion_r387692796", "createdAt": "2020-03-04T14:16:20Z", "author": {"login": "not-napoleon"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/geogrid/GeoHashGridAggregatorFactory.java", "diffHunk": "@@ -79,15 +83,26 @@ protected Aggregator doCreateInternal(final ValuesSource valuesSource,\n                                             boolean collectsFromSingleBucket,\n                                             List<PipelineAggregator> pipelineAggregators,\n                                             Map<String, Object> metaData) throws IOException {\n-        if (valuesSource instanceof ValuesSource.GeoPoint  == false) {\n-            throw new AggregationExecutionException(\"ValuesSource type \" + valuesSource.toString() + \"is not supported for aggregation \" +\n-                this.name());\n+        AggregatorSupplier aggregatorSupplier = queryShardContext.getValuesSourceRegistry()\n+            .getAggregator(config.valueSourceType(), GeoHashGridAggregationBuilder.NAME);\n+        if (aggregatorSupplier instanceof GeoGridAggregatorSupplier == false) {\n+            throw new AggregationExecutionException(\"Registry miss-match - expected \"\n+                + GeoGridAggregatorSupplier.class.getName() + \", found [\" + aggregatorSupplier.getClass().toString() + \"]\");\n         }\n         if (collectsFromSingleBucket == false) {\n             return asMultiBucketAggregator(this, searchContext, parent);\n         }\n         CellIdSource cellIdSource = new CellIdSource((ValuesSource.GeoPoint) valuesSource, precision, geoBoundingBox, Geohash::longEncode);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c2f63bfa507a5b89a2dcffa8298b875d69c6239"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ3Mzk5Mg==", "bodyText": "++ will do", "url": "https://github.com/elastic/elasticsearch/pull/53037#discussion_r388473992", "createdAt": "2020-03-05T18:17:22Z", "author": {"login": "talevy"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/geogrid/GeoHashGridAggregatorFactory.java", "diffHunk": "@@ -79,15 +83,26 @@ protected Aggregator doCreateInternal(final ValuesSource valuesSource,\n                                             boolean collectsFromSingleBucket,\n                                             List<PipelineAggregator> pipelineAggregators,\n                                             Map<String, Object> metaData) throws IOException {\n-        if (valuesSource instanceof ValuesSource.GeoPoint  == false) {\n-            throw new AggregationExecutionException(\"ValuesSource type \" + valuesSource.toString() + \"is not supported for aggregation \" +\n-                this.name());\n+        AggregatorSupplier aggregatorSupplier = queryShardContext.getValuesSourceRegistry()\n+            .getAggregator(config.valueSourceType(), GeoHashGridAggregationBuilder.NAME);\n+        if (aggregatorSupplier instanceof GeoGridAggregatorSupplier == false) {\n+            throw new AggregationExecutionException(\"Registry miss-match - expected \"\n+                + GeoGridAggregatorSupplier.class.getName() + \", found [\" + aggregatorSupplier.getClass().toString() + \"]\");\n         }\n         if (collectsFromSingleBucket == false) {\n             return asMultiBucketAggregator(this, searchContext, parent);\n         }\n         CellIdSource cellIdSource = new CellIdSource((ValuesSource.GeoPoint) valuesSource, precision, geoBoundingBox, Geohash::longEncode);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY5Mjc5Ng=="}, "originalCommit": {"oid": "7c2f63bfa507a5b89a2dcffa8298b875d69c6239"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMTk1OTUwOnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/elasticsearch/search/aggregations/bucket/geogrid/GeoGridAggregatorTestCase.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNDozNzo0NlrOFxvwZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxODoyNjozMlrOFye34A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzcwNjk4Mg==", "bodyText": "My preference is to PR these tests separately against master first, so we can validate that the type support hasn't changed in the registry branch.", "url": "https://github.com/elastic/elasticsearch/pull/53037#discussion_r387706982", "createdAt": "2020-03-04T14:37:46Z", "author": {"login": "not-napoleon"}, "path": "server/src/test/java/org/elasticsearch/search/aggregations/bucket/geogrid/GeoGridAggregatorTestCase.java", "diffHunk": "@@ -240,4 +243,14 @@ private void testCase(Query query, int precision, GeoBoundingBox geoBoundingBox,\n         indexReader.close();\n         directory.close();\n     }\n+\n+    @Override\n+    protected AggregationBuilder createAggBuilderForTypeTest(MappedFieldType fieldType, String fieldName) {\n+        return createBuilder(\"foo\").field(fieldName);\n+    }\n+\n+    @Override\n+    protected List<ValuesSourceType> getSupportedValuesSourceTypes() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c2f63bfa507a5b89a2dcffa8298b875d69c6239"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ3NDk1Mw==", "bodyText": "will do this in a separate PR", "url": "https://github.com/elastic/elasticsearch/pull/53037#discussion_r388474953", "createdAt": "2020-03-05T18:19:08Z", "author": {"login": "talevy"}, "path": "server/src/test/java/org/elasticsearch/search/aggregations/bucket/geogrid/GeoGridAggregatorTestCase.java", "diffHunk": "@@ -240,4 +243,14 @@ private void testCase(Query query, int precision, GeoBoundingBox geoBoundingBox,\n         indexReader.close();\n         directory.close();\n     }\n+\n+    @Override\n+    protected AggregationBuilder createAggBuilderForTypeTest(MappedFieldType fieldType, String fieldName) {\n+        return createBuilder(\"foo\").field(fieldName);\n+    }\n+\n+    @Override\n+    protected List<ValuesSourceType> getSupportedValuesSourceTypes() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzcwNjk4Mg=="}, "originalCommit": {"oid": "7c2f63bfa507a5b89a2dcffa8298b875d69c6239"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ3ODk0NA==", "bodyText": "opened #53180", "url": "https://github.com/elastic/elasticsearch/pull/53037#discussion_r388478944", "createdAt": "2020-03-05T18:26:32Z", "author": {"login": "talevy"}, "path": "server/src/test/java/org/elasticsearch/search/aggregations/bucket/geogrid/GeoGridAggregatorTestCase.java", "diffHunk": "@@ -240,4 +243,14 @@ private void testCase(Query query, int precision, GeoBoundingBox geoBoundingBox,\n         indexReader.close();\n         directory.close();\n     }\n+\n+    @Override\n+    protected AggregationBuilder createAggBuilderForTypeTest(MappedFieldType fieldType, String fieldName) {\n+        return createBuilder(\"foo\").field(fieldName);\n+    }\n+\n+    @Override\n+    protected List<ValuesSourceType> getSupportedValuesSourceTypes() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzcwNjk4Mg=="}, "originalCommit": {"oid": "7c2f63bfa507a5b89a2dcffa8298b875d69c6239"}, "originalPosition": 24}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3493, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}