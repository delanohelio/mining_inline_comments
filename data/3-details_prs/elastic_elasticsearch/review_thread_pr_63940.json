{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA2ODI2ODY2", "number": 63940, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNDowODo1MVrOEvzKUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNDozMzo1MVrOEvz-MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NTU2NzUyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/pivot/SchemaUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNDowODo1MVrOHk-0sA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNDo1NDoxMFrOHlBO9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU0MDA4MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static Object convertToIntegerTypeIfNeeded(String type, double value) {\n          \n          \n            \n                public static Object convertToDiscreteNumeralTypeIfNeeded(String type, double value) {\n          \n      \n    \n    \n  \n\nOr some better name as this is is not an integer but instead some possibly large discrete numeral (big int or a long).", "url": "https://github.com/elastic/elasticsearch/pull/63940#discussion_r508540080", "createdAt": "2020-10-20T14:08:51Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/pivot/SchemaUtil.java", "diffHunk": "@@ -23,30 +23,59 @@\n import org.elasticsearch.xpack.core.ClientHelper;\n import org.elasticsearch.xpack.core.transform.transforms.pivot.PivotConfig;\n \n+import java.math.BigDecimal;\n import java.util.HashMap;\n import java.util.Map;\n import java.util.Objects;\n-import java.util.Set;\n import java.util.stream.Collectors;\n import java.util.stream.Stream;\n \n public final class SchemaUtil {\n     private static final Logger logger = LogManager.getLogger(SchemaUtil.class);\n \n-    // Full collection of numeric field type strings\n-    private static final Set<String> NUMERIC_FIELD_MAPPER_TYPES;\n+    // Full collection of numeric field type strings and whether they are floating point or not\n+    private static final Map<String, Boolean> NUMERIC_FIELD_MAPPER_TYPES;\n     static {\n-        Set<String> types = Stream.of(NumberFieldMapper.NumberType.values())\n-            .map(NumberFieldMapper.NumberType::typeName)\n-            .collect(Collectors.toSet());\n-        types.add(\"scaled_float\"); // have to add manually since scaled_float is in a module\n+        Map<String, Boolean> types = Stream.of(NumberFieldMapper.NumberType.values())\n+            .collect(Collectors.toMap(t -> t.typeName(), t -> t.numericType().isFloatingPoint()));\n+\n+        // have to add manually since they are in a module\n+        types.put(\"scaled_float\", true);\n+        types.put(\"unsigned_long\", false);\n         NUMERIC_FIELD_MAPPER_TYPES = types;\n     }\n \n     private SchemaUtil() {}\n \n     public static boolean isNumericType(String type) {\n-        return type != null && NUMERIC_FIELD_MAPPER_TYPES.contains(type);\n+        return type != null && NUMERIC_FIELD_MAPPER_TYPES.containsKey(type);\n+    }\n+\n+    /**\n+     * Convert a numeric value to an integer if it's not a floating point number.\n+     *\n+     * Implementation decision: We do not care about the concrete type, but only if its floating point or not.\n+     * Further checks (e.g. range) are done at indexing.\n+     *\n+     * If type is floating point and value could be an integer (ends with `.0`), we still preserve `.0` in case\n+     * the destination index uses dynamic mappings as well as being json friendly.\n+     *\n+     * @param type the type of the value according to the schema we know\n+     * @param value the value as double (aggs return double for everything)\n+     * @return value if its floating point, a integer\n+     */\n+    public static Object convertToIntegerTypeIfNeeded(String type, double value) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61a0c60116a872e8495e19079328ee2182ed71b8"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU3OTU3Mw==", "bodyText": "its referring to the mathematical definition of integer, that's why integer type, not integer. I can try to find a better name, maybe dropFloatingPointComponentIfNeeded, but lets not over-complicate it, the doc string defines what it does.", "url": "https://github.com/elastic/elasticsearch/pull/63940#discussion_r508579573", "createdAt": "2020-10-20T14:54:10Z", "author": {"login": "hendrikmuhs"}, "path": "x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/pivot/SchemaUtil.java", "diffHunk": "@@ -23,30 +23,59 @@\n import org.elasticsearch.xpack.core.ClientHelper;\n import org.elasticsearch.xpack.core.transform.transforms.pivot.PivotConfig;\n \n+import java.math.BigDecimal;\n import java.util.HashMap;\n import java.util.Map;\n import java.util.Objects;\n-import java.util.Set;\n import java.util.stream.Collectors;\n import java.util.stream.Stream;\n \n public final class SchemaUtil {\n     private static final Logger logger = LogManager.getLogger(SchemaUtil.class);\n \n-    // Full collection of numeric field type strings\n-    private static final Set<String> NUMERIC_FIELD_MAPPER_TYPES;\n+    // Full collection of numeric field type strings and whether they are floating point or not\n+    private static final Map<String, Boolean> NUMERIC_FIELD_MAPPER_TYPES;\n     static {\n-        Set<String> types = Stream.of(NumberFieldMapper.NumberType.values())\n-            .map(NumberFieldMapper.NumberType::typeName)\n-            .collect(Collectors.toSet());\n-        types.add(\"scaled_float\"); // have to add manually since scaled_float is in a module\n+        Map<String, Boolean> types = Stream.of(NumberFieldMapper.NumberType.values())\n+            .collect(Collectors.toMap(t -> t.typeName(), t -> t.numericType().isFloatingPoint()));\n+\n+        // have to add manually since they are in a module\n+        types.put(\"scaled_float\", true);\n+        types.put(\"unsigned_long\", false);\n         NUMERIC_FIELD_MAPPER_TYPES = types;\n     }\n \n     private SchemaUtil() {}\n \n     public static boolean isNumericType(String type) {\n-        return type != null && NUMERIC_FIELD_MAPPER_TYPES.contains(type);\n+        return type != null && NUMERIC_FIELD_MAPPER_TYPES.containsKey(type);\n+    }\n+\n+    /**\n+     * Convert a numeric value to an integer if it's not a floating point number.\n+     *\n+     * Implementation decision: We do not care about the concrete type, but only if its floating point or not.\n+     * Further checks (e.g. range) are done at indexing.\n+     *\n+     * If type is floating point and value could be an integer (ends with `.0`), we still preserve `.0` in case\n+     * the destination index uses dynamic mappings as well as being json friendly.\n+     *\n+     * @param type the type of the value according to the schema we know\n+     * @param value the value as double (aggs return double for everything)\n+     * @return value if its floating point, a integer\n+     */\n+    public static Object convertToIntegerTypeIfNeeded(String type, double value) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU0MDA4MA=="}, "originalCommit": {"oid": "61a0c60116a872e8495e19079328ee2182ed71b8"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NTcwMDMzOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/pivot/SchemaUtil.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNDozMzo1MVrOHlAKfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNDozMzo1MVrOHlAKfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU2MjA0NQ==", "bodyText": "Its weird to me that there is not a blanket map doc value -> indexable value :(\nThis works in a pinch, I wonder if there is anyway to use DocValueFormat.UNSIGNED_LONG_SHIFTED.\nBut looking at it, there isn't a clean cut solution :/", "url": "https://github.com/elastic/elasticsearch/pull/63940#discussion_r508562045", "createdAt": "2020-10-20T14:33:51Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/pivot/SchemaUtil.java", "diffHunk": "@@ -23,30 +23,59 @@\n import org.elasticsearch.xpack.core.ClientHelper;\n import org.elasticsearch.xpack.core.transform.transforms.pivot.PivotConfig;\n \n+import java.math.BigDecimal;\n import java.util.HashMap;\n import java.util.Map;\n import java.util.Objects;\n-import java.util.Set;\n import java.util.stream.Collectors;\n import java.util.stream.Stream;\n \n public final class SchemaUtil {\n     private static final Logger logger = LogManager.getLogger(SchemaUtil.class);\n \n-    // Full collection of numeric field type strings\n-    private static final Set<String> NUMERIC_FIELD_MAPPER_TYPES;\n+    // Full collection of numeric field type strings and whether they are floating point or not\n+    private static final Map<String, Boolean> NUMERIC_FIELD_MAPPER_TYPES;\n     static {\n-        Set<String> types = Stream.of(NumberFieldMapper.NumberType.values())\n-            .map(NumberFieldMapper.NumberType::typeName)\n-            .collect(Collectors.toSet());\n-        types.add(\"scaled_float\"); // have to add manually since scaled_float is in a module\n+        Map<String, Boolean> types = Stream.of(NumberFieldMapper.NumberType.values())\n+            .collect(Collectors.toMap(t -> t.typeName(), t -> t.numericType().isFloatingPoint()));\n+\n+        // have to add manually since they are in a module\n+        types.put(\"scaled_float\", true);\n+        types.put(\"unsigned_long\", false);\n         NUMERIC_FIELD_MAPPER_TYPES = types;\n     }\n \n     private SchemaUtil() {}\n \n     public static boolean isNumericType(String type) {\n-        return type != null && NUMERIC_FIELD_MAPPER_TYPES.contains(type);\n+        return type != null && NUMERIC_FIELD_MAPPER_TYPES.containsKey(type);\n+    }\n+\n+    /**\n+     * Convert a numeric value to an integer if it's not a floating point number.\n+     *\n+     * Implementation decision: We do not care about the concrete type, but only if its floating point or not.\n+     * Further checks (e.g. range) are done at indexing.\n+     *\n+     * If type is floating point and value could be an integer (ends with `.0`), we still preserve `.0` in case\n+     * the destination index uses dynamic mappings as well as being json friendly.\n+     *\n+     * @param type the type of the value according to the schema we know\n+     * @param value the value as double (aggs return double for everything)\n+     * @return value if its floating point, a integer\n+     */\n+    public static Object convertToIntegerTypeIfNeeded(String type, double value) {\n+        if (NUMERIC_FIELD_MAPPER_TYPES.getOrDefault(type, true) == false) {\n+            assert value % 1 == 0;\n+            if (value < Long.MAX_VALUE) {\n+                return (long) value;\n+            }\n+\n+            // special case for unsigned long\n+            return BigDecimal.valueOf(value).toBigInteger();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61a0c60116a872e8495e19079328ee2182ed71b8"}, "originalPosition": 61}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4341, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}