{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA4NjEyNTYy", "number": 55732, "reviewThreads": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNTo0Mjo1MlrOD11j1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNjoxMjoxMVrOD3swZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3Nzc4NjQ0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/aggregations/support/ValuesSourceType.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNTo0Mjo1MlrOGLdwWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNTo0Mjo1MlrOGLdwWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY3NTAzNQ==", "bodyText": "Maybe typeName() instead? we're already using value for a lot of things in aggregations support.", "url": "https://github.com/elastic/elasticsearch/pull/55732#discussion_r414675035", "createdAt": "2020-04-24T15:42:52Z", "author": {"login": "not-napoleon"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/support/ValuesSourceType.java", "diffHunk": "@@ -98,4 +98,10 @@ ValuesSource replaceMissing(ValuesSource valuesSource, Object rawMissing, DocVal\n     default DocValueFormat getFormatter(String format, ZoneId tz) {\n         return DocValueFormat.RAW;\n     }\n+\n+    /**\n+     * Returns the name of the Values Source Type for stats purposes\n+     * @return the name of the Values Source Type\n+     */\n+    String value();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0a7dd4142816e01727a8e4120014727201a1cbc"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3NzgzMjY3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/aggregations/support/ValuesSourceRegistry.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNTo1MjoyOVrOGLeLPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNTo1MjoyOVrOGLeLPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY4MTkxOA==", "bodyText": "I don't think Multi should be it's own case.  Instead, we can loop in the list version of register and just create multiple SingleRegistryEntry records.  That way, report usage can still track to a single ValuesSourceType, and the only \"special case\" is around Any, which we're planning to remove.", "url": "https://github.com/elastic/elasticsearch/pull/55732#discussion_r414681918", "createdAt": "2020-04-24T15:52:29Z", "author": {"login": "not-napoleon"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/support/ValuesSourceRegistry.java", "diffHunk": "@@ -26,136 +26,251 @@\n import org.elasticsearch.index.query.QueryShardContext;\n import org.elasticsearch.search.SearchModule;\n import org.elasticsearch.search.aggregations.AggregationExecutionException;\n+import org.elasticsearch.usage.UsageService;\n \n-import java.util.AbstractMap;\n import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n-import java.util.function.Predicate;\n+import java.util.concurrent.atomic.AtomicLong;\n \n /**\n  * {@link ValuesSourceRegistry} holds the mapping from {@link ValuesSourceType}s to {@link AggregatorSupplier}s.  DO NOT directly\n  * instantiate this class, instead get an already-configured copy from {@link QueryShardContext#getValuesSourceRegistry()}, or (in the case\n  * of some test scenarios only) directly from {@link SearchModule#getValuesSourceRegistry()}\n- *\n  */\n public class ValuesSourceRegistry {\n+    /**\n+     * Base class for the aggregation registration.\n+     * <p>\n+     * TODO: we can get rid of this entire hierarchy and shrink it to a single class or even Tuple when we get rid of registerAny\n+     */\n+    public abstract static class RegistryEntry {\n+\n+        private final AggregatorSupplier supplier;\n+\n+        /**\n+         * @param supplier An Aggregation-specific specialization of AggregatorSupplier which will construct the mapped aggregator\n+         *                 from the aggregation standard set of parameters\n+         */\n+        protected RegistryEntry(AggregatorSupplier supplier) {\n+            this.supplier = supplier;\n+        }\n+\n+        /**\n+         * Returns true if this aggregation can be applied to the given value source type, false otherwise\n+         */\n+        protected abstract boolean appliesTo(ValuesSourceType type);\n+\n+        /**\n+         * Increments usage counter for the given aggregetion\n+         */\n+        protected abstract void inc(ValuesSourceType type);\n+\n+        /**\n+         * Registers the aggregation usage with the usage service\n+         */\n+        protected abstract void registerUsage(String aggName, UsageService usageService);\n+\n+    }\n+\n+    private static class AnyRegistryEntry extends RegistryEntry {\n+        private final AtomicLong stats;\n+\n+        private AnyRegistryEntry(AggregatorSupplier supplier) {\n+            super(supplier);\n+            this.stats = new AtomicLong();\n+        }\n+\n+        @Override\n+        protected void inc(ValuesSourceType type) {\n+            stats.incrementAndGet();\n+        }\n+\n+        @Override\n+        protected void registerUsage(String aggName, UsageService usageService) {\n+            usageService.addAggregationUsage(aggName, \"*\", stats);\n+        }\n+\n+        @Override\n+        protected boolean appliesTo(ValuesSourceType type) {\n+            return true;\n+        }\n+    }\n+\n+\n+    private static class SingleRegistryEntry extends RegistryEntry {\n+        private final AtomicLong stats;\n+        private final ValuesSourceType type;\n+\n+        private SingleRegistryEntry(AggregatorSupplier supplier, ValuesSourceType type) {\n+            super(supplier);\n+            this.stats = new AtomicLong();\n+            this.type = type;\n+        }\n+\n+        @Override\n+        protected void inc(ValuesSourceType type) {\n+            stats.incrementAndGet();\n+        }\n+\n+        @Override\n+        protected void registerUsage(String aggName, UsageService usageService) {\n+            usageService.addAggregationUsage(aggName, type.value(), stats);\n+        }\n+\n+        @Override\n+        protected boolean appliesTo(ValuesSourceType type) {\n+            return this.type == type;\n+        }\n+    }\n+\n+    private static class MultiRegistryEntry extends RegistryEntry {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0a7dd4142816e01727a8e4120014727201a1cbc"}, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3NzkzMDQ5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/aggregations/support/ValuesSourceRegistry.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNjoxNTowMFrOGLfGiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQyMDoxOToxM1rOGLnwRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY5NzA5OQ==", "bodyText": "So, @csoulios is working on a near term plan to get rid of the literal any, and replace registerAny with just registering all the CoreValuesSourceTypes.  We could adopt something like that here, and just register an explicit list of SingleRegistryEntry cases instead.  Or leave this as is and change it over when the rest of Christos's ANY work merges.", "url": "https://github.com/elastic/elasticsearch/pull/55732#discussion_r414697099", "createdAt": "2020-04-24T16:15:00Z", "author": {"login": "not-napoleon"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/support/ValuesSourceRegistry.java", "diffHunk": "@@ -26,136 +26,251 @@\n import org.elasticsearch.index.query.QueryShardContext;\n import org.elasticsearch.search.SearchModule;\n import org.elasticsearch.search.aggregations.AggregationExecutionException;\n+import org.elasticsearch.usage.UsageService;\n \n-import java.util.AbstractMap;\n import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n-import java.util.function.Predicate;\n+import java.util.concurrent.atomic.AtomicLong;\n \n /**\n  * {@link ValuesSourceRegistry} holds the mapping from {@link ValuesSourceType}s to {@link AggregatorSupplier}s.  DO NOT directly\n  * instantiate this class, instead get an already-configured copy from {@link QueryShardContext#getValuesSourceRegistry()}, or (in the case\n  * of some test scenarios only) directly from {@link SearchModule#getValuesSourceRegistry()}\n- *\n  */\n public class ValuesSourceRegistry {\n+    /**\n+     * Base class for the aggregation registration.\n+     * <p>\n+     * TODO: we can get rid of this entire hierarchy and shrink it to a single class or even Tuple when we get rid of registerAny\n+     */\n+    public abstract static class RegistryEntry {\n+\n+        private final AggregatorSupplier supplier;\n+\n+        /**\n+         * @param supplier An Aggregation-specific specialization of AggregatorSupplier which will construct the mapped aggregator\n+         *                 from the aggregation standard set of parameters\n+         */\n+        protected RegistryEntry(AggregatorSupplier supplier) {\n+            this.supplier = supplier;\n+        }\n+\n+        /**\n+         * Returns true if this aggregation can be applied to the given value source type, false otherwise\n+         */\n+        protected abstract boolean appliesTo(ValuesSourceType type);\n+\n+        /**\n+         * Increments usage counter for the given aggregetion\n+         */\n+        protected abstract void inc(ValuesSourceType type);\n+\n+        /**\n+         * Registers the aggregation usage with the usage service\n+         */\n+        protected abstract void registerUsage(String aggName, UsageService usageService);\n+\n+    }\n+\n+    private static class AnyRegistryEntry extends RegistryEntry {\n+        private final AtomicLong stats;\n+\n+        private AnyRegistryEntry(AggregatorSupplier supplier) {\n+            super(supplier);\n+            this.stats = new AtomicLong();\n+        }\n+\n+        @Override\n+        protected void inc(ValuesSourceType type) {\n+            stats.incrementAndGet();\n+        }\n+\n+        @Override\n+        protected void registerUsage(String aggName, UsageService usageService) {\n+            usageService.addAggregationUsage(aggName, \"*\", stats);\n+        }\n+\n+        @Override\n+        protected boolean appliesTo(ValuesSourceType type) {\n+            return true;\n+        }\n+    }\n+\n+\n+    private static class SingleRegistryEntry extends RegistryEntry {\n+        private final AtomicLong stats;\n+        private final ValuesSourceType type;\n+\n+        private SingleRegistryEntry(AggregatorSupplier supplier, ValuesSourceType type) {\n+            super(supplier);\n+            this.stats = new AtomicLong();\n+            this.type = type;\n+        }\n+\n+        @Override\n+        protected void inc(ValuesSourceType type) {\n+            stats.incrementAndGet();\n+        }\n+\n+        @Override\n+        protected void registerUsage(String aggName, UsageService usageService) {\n+            usageService.addAggregationUsage(aggName, type.value(), stats);\n+        }\n+\n+        @Override\n+        protected boolean appliesTo(ValuesSourceType type) {\n+            return this.type == type;\n+        }\n+    }\n+\n+    private static class MultiRegistryEntry extends RegistryEntry {\n+        private final Map<ValuesSourceType, AtomicLong> stats;\n+        private final List<ValuesSourceType> valuesSourceTypes;\n+\n+        private MultiRegistryEntry(AggregatorSupplier supplier, List<ValuesSourceType> valuesSourceTypes) {\n+            super(supplier);\n+            this.stats = new HashMap<>();\n+            this.valuesSourceTypes = valuesSourceTypes;\n+            for (ValuesSourceType valuesSourceType : valuesSourceTypes) {\n+                AtomicLong stat = new AtomicLong();\n+                stats.put(valuesSourceType, stat);\n+            }\n+        }\n+\n+        @Override\n+        protected void inc(ValuesSourceType type) {\n+            stats.get(type).incrementAndGet();\n+        }\n+\n+        @Override\n+        protected boolean appliesTo(ValuesSourceType type) {\n+            for (ValuesSourceType valuesSourceType : valuesSourceTypes) {\n+                if (valuesSourceType.equals(type)) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        protected void registerUsage(String aggName, UsageService usageService) {\n+            for (ValuesSourceType valuesSourceType : valuesSourceTypes) {\n+                usageService.addAggregationUsage(aggName, valuesSourceType.value(), stats.get(valuesSourceType));\n+            }\n+        }\n+    }\n+\n     public static class Builder {\n-        private Map<String, List<Map.Entry<Predicate<ValuesSourceType>, AggregatorSupplier>>> aggregatorRegistry = new HashMap<>();\n+        private final Map<String, List<RegistryEntry>> aggregatorRegistry = new HashMap<>();\n+\n         /**\n          * Register a ValuesSource to Aggregator mapping.\n          *\n-         * @param aggregationName The name of the family of aggregations, typically found via\n-         *                        {@link ValuesSourceAggregationBuilder#getType()}\n-         * @param appliesTo A predicate which accepts the resolved {@link ValuesSourceType} and decides if the given aggregator can be\n-         *                  applied to that type.\n-         * @param aggregatorSupplier An Aggregation-specific specialization of AggregatorSupplier which will construct the mapped aggregator\n+         * @param aggregationName    The name of the family of aggregations, typically found via\n+         *                           {@link ValuesSourceAggregationBuilder#getType()}\n+         * @param registryEntry An Aggregation-specific specialization of AggregatorSupplier which will construct the mapped aggregator\n          */\n-        private void register(String aggregationName, Predicate<ValuesSourceType> appliesTo,\n-                                          AggregatorSupplier aggregatorSupplier) {\n+        private void register(String aggregationName, RegistryEntry registryEntry) {\n             if (aggregatorRegistry.containsKey(aggregationName) == false) {\n                 aggregatorRegistry.put(aggregationName, new ArrayList<>());\n             }\n-            aggregatorRegistry.get(aggregationName).add( new AbstractMap.SimpleEntry<>(appliesTo, aggregatorSupplier));\n+            aggregatorRegistry.get(aggregationName).add(registryEntry);\n         }\n \n         /**\n          * Register a ValuesSource to Aggregator mapping.  This version provides a convenience method for mappings that only apply to a\n          * single {@link ValuesSourceType}, to allow passing in the type and auto-wrapping it in a predicate\n-         * @param aggregationName The name of the family of aggregations, typically found via\n-         *                        {@link ValuesSourceAggregationBuilder#getType()}\n-         * @param valuesSourceType The ValuesSourceType this mapping applies to.\n+         *\n+         * @param aggregationName    The name of the family of aggregations, typically found via\n+         *                           {@link ValuesSourceAggregationBuilder#getType()}\n+         * @param valuesSourceType   The ValuesSourceType this mapping applies to.\n          * @param aggregatorSupplier An Aggregation-specific specialization of AggregatorSupplier which will construct the mapped aggregator\n          *                           from the aggregation standard set of parameters\n          */\n         public void register(String aggregationName, ValuesSourceType valuesSourceType, AggregatorSupplier aggregatorSupplier) {\n-            register(aggregationName, (candidate) -> valuesSourceType.equals(candidate), aggregatorSupplier);\n+            register(aggregationName, new SingleRegistryEntry(aggregatorSupplier, valuesSourceType));\n         }\n \n         /**\n          * Register a ValuesSource to Aggregator mapping.  This version provides a convenience method for mappings that only apply to a\n          * known list of {@link ValuesSourceType}, to allow passing in the type and auto-wrapping it in a predicate\n-         *  @param aggregationName The name of the family of aggregations, typically found via\n-         *                         {@link ValuesSourceAggregationBuilder#getType()}\n-         * @param valuesSourceTypes The ValuesSourceTypes this mapping applies to.\n+         *\n+         * @param aggregationName    The name of the family of aggregations, typically found via\n+         *                           {@link ValuesSourceAggregationBuilder#getType()}\n+         * @param valuesSourceTypes  The ValuesSourceTypes this mapping applies to.\n          * @param aggregatorSupplier An Aggregation-specific specialization of AggregatorSupplier which will construct the mapped aggregator\n          *                           from the aggregation standard set of parameters\n          */\n         public void register(String aggregationName, List<ValuesSourceType> valuesSourceTypes, AggregatorSupplier aggregatorSupplier) {\n-            register(aggregationName, (candidate) -> {\n-                for (ValuesSourceType valuesSourceType : valuesSourceTypes) {\n-                    if (valuesSourceType.equals(candidate)) {\n-                        return true;\n-                    }\n-                }\n-                return false;\n-            }, aggregatorSupplier);\n+            register(aggregationName, new MultiRegistryEntry(aggregatorSupplier, valuesSourceTypes));\n         }\n \n         /**\n          * Register an aggregator that applies to any values source type.  This is a convenience method for aggregations that do not care at\n          * all about the types of their inputs.  Aggregations using this version of registration should not make any other registrations, as\n          * the aggregator registered using this function will be applied in all cases.\n          *\n-         * @param aggregationName The name of the family of aggregations, typically found via\n-         *                        {@link ValuesSourceAggregationBuilder#getType()}\n+         * @param aggregationName    The name of the family of aggregations, typically found via\n+         *                           {@link ValuesSourceAggregationBuilder#getType()}\n          * @param aggregatorSupplier An Aggregation-specific specialization of AggregatorSupplier which will construct the mapped aggregator\n          *                           from the aggregation standard set of parameters.\n          */\n         public void registerAny(String aggregationName, AggregatorSupplier aggregatorSupplier) {\n-            register(aggregationName, (ignored) -> true, aggregatorSupplier);\n+            register(aggregationName, new AnyRegistryEntry(aggregatorSupplier));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0a7dd4142816e01727a8e4120014727201a1cbc"}, "originalPosition": 226}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgzODg1Mw==", "bodyText": "Just pushed PR #55747 that removes registerAny() method", "url": "https://github.com/elastic/elasticsearch/pull/55732#discussion_r414838853", "createdAt": "2020-04-24T20:19:13Z", "author": {"login": "csoulios"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/support/ValuesSourceRegistry.java", "diffHunk": "@@ -26,136 +26,251 @@\n import org.elasticsearch.index.query.QueryShardContext;\n import org.elasticsearch.search.SearchModule;\n import org.elasticsearch.search.aggregations.AggregationExecutionException;\n+import org.elasticsearch.usage.UsageService;\n \n-import java.util.AbstractMap;\n import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n-import java.util.function.Predicate;\n+import java.util.concurrent.atomic.AtomicLong;\n \n /**\n  * {@link ValuesSourceRegistry} holds the mapping from {@link ValuesSourceType}s to {@link AggregatorSupplier}s.  DO NOT directly\n  * instantiate this class, instead get an already-configured copy from {@link QueryShardContext#getValuesSourceRegistry()}, or (in the case\n  * of some test scenarios only) directly from {@link SearchModule#getValuesSourceRegistry()}\n- *\n  */\n public class ValuesSourceRegistry {\n+    /**\n+     * Base class for the aggregation registration.\n+     * <p>\n+     * TODO: we can get rid of this entire hierarchy and shrink it to a single class or even Tuple when we get rid of registerAny\n+     */\n+    public abstract static class RegistryEntry {\n+\n+        private final AggregatorSupplier supplier;\n+\n+        /**\n+         * @param supplier An Aggregation-specific specialization of AggregatorSupplier which will construct the mapped aggregator\n+         *                 from the aggregation standard set of parameters\n+         */\n+        protected RegistryEntry(AggregatorSupplier supplier) {\n+            this.supplier = supplier;\n+        }\n+\n+        /**\n+         * Returns true if this aggregation can be applied to the given value source type, false otherwise\n+         */\n+        protected abstract boolean appliesTo(ValuesSourceType type);\n+\n+        /**\n+         * Increments usage counter for the given aggregetion\n+         */\n+        protected abstract void inc(ValuesSourceType type);\n+\n+        /**\n+         * Registers the aggregation usage with the usage service\n+         */\n+        protected abstract void registerUsage(String aggName, UsageService usageService);\n+\n+    }\n+\n+    private static class AnyRegistryEntry extends RegistryEntry {\n+        private final AtomicLong stats;\n+\n+        private AnyRegistryEntry(AggregatorSupplier supplier) {\n+            super(supplier);\n+            this.stats = new AtomicLong();\n+        }\n+\n+        @Override\n+        protected void inc(ValuesSourceType type) {\n+            stats.incrementAndGet();\n+        }\n+\n+        @Override\n+        protected void registerUsage(String aggName, UsageService usageService) {\n+            usageService.addAggregationUsage(aggName, \"*\", stats);\n+        }\n+\n+        @Override\n+        protected boolean appliesTo(ValuesSourceType type) {\n+            return true;\n+        }\n+    }\n+\n+\n+    private static class SingleRegistryEntry extends RegistryEntry {\n+        private final AtomicLong stats;\n+        private final ValuesSourceType type;\n+\n+        private SingleRegistryEntry(AggregatorSupplier supplier, ValuesSourceType type) {\n+            super(supplier);\n+            this.stats = new AtomicLong();\n+            this.type = type;\n+        }\n+\n+        @Override\n+        protected void inc(ValuesSourceType type) {\n+            stats.incrementAndGet();\n+        }\n+\n+        @Override\n+        protected void registerUsage(String aggName, UsageService usageService) {\n+            usageService.addAggregationUsage(aggName, type.value(), stats);\n+        }\n+\n+        @Override\n+        protected boolean appliesTo(ValuesSourceType type) {\n+            return this.type == type;\n+        }\n+    }\n+\n+    private static class MultiRegistryEntry extends RegistryEntry {\n+        private final Map<ValuesSourceType, AtomicLong> stats;\n+        private final List<ValuesSourceType> valuesSourceTypes;\n+\n+        private MultiRegistryEntry(AggregatorSupplier supplier, List<ValuesSourceType> valuesSourceTypes) {\n+            super(supplier);\n+            this.stats = new HashMap<>();\n+            this.valuesSourceTypes = valuesSourceTypes;\n+            for (ValuesSourceType valuesSourceType : valuesSourceTypes) {\n+                AtomicLong stat = new AtomicLong();\n+                stats.put(valuesSourceType, stat);\n+            }\n+        }\n+\n+        @Override\n+        protected void inc(ValuesSourceType type) {\n+            stats.get(type).incrementAndGet();\n+        }\n+\n+        @Override\n+        protected boolean appliesTo(ValuesSourceType type) {\n+            for (ValuesSourceType valuesSourceType : valuesSourceTypes) {\n+                if (valuesSourceType.equals(type)) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        protected void registerUsage(String aggName, UsageService usageService) {\n+            for (ValuesSourceType valuesSourceType : valuesSourceTypes) {\n+                usageService.addAggregationUsage(aggName, valuesSourceType.value(), stats.get(valuesSourceType));\n+            }\n+        }\n+    }\n+\n     public static class Builder {\n-        private Map<String, List<Map.Entry<Predicate<ValuesSourceType>, AggregatorSupplier>>> aggregatorRegistry = new HashMap<>();\n+        private final Map<String, List<RegistryEntry>> aggregatorRegistry = new HashMap<>();\n+\n         /**\n          * Register a ValuesSource to Aggregator mapping.\n          *\n-         * @param aggregationName The name of the family of aggregations, typically found via\n-         *                        {@link ValuesSourceAggregationBuilder#getType()}\n-         * @param appliesTo A predicate which accepts the resolved {@link ValuesSourceType} and decides if the given aggregator can be\n-         *                  applied to that type.\n-         * @param aggregatorSupplier An Aggregation-specific specialization of AggregatorSupplier which will construct the mapped aggregator\n+         * @param aggregationName    The name of the family of aggregations, typically found via\n+         *                           {@link ValuesSourceAggregationBuilder#getType()}\n+         * @param registryEntry An Aggregation-specific specialization of AggregatorSupplier which will construct the mapped aggregator\n          */\n-        private void register(String aggregationName, Predicate<ValuesSourceType> appliesTo,\n-                                          AggregatorSupplier aggregatorSupplier) {\n+        private void register(String aggregationName, RegistryEntry registryEntry) {\n             if (aggregatorRegistry.containsKey(aggregationName) == false) {\n                 aggregatorRegistry.put(aggregationName, new ArrayList<>());\n             }\n-            aggregatorRegistry.get(aggregationName).add( new AbstractMap.SimpleEntry<>(appliesTo, aggregatorSupplier));\n+            aggregatorRegistry.get(aggregationName).add(registryEntry);\n         }\n \n         /**\n          * Register a ValuesSource to Aggregator mapping.  This version provides a convenience method for mappings that only apply to a\n          * single {@link ValuesSourceType}, to allow passing in the type and auto-wrapping it in a predicate\n-         * @param aggregationName The name of the family of aggregations, typically found via\n-         *                        {@link ValuesSourceAggregationBuilder#getType()}\n-         * @param valuesSourceType The ValuesSourceType this mapping applies to.\n+         *\n+         * @param aggregationName    The name of the family of aggregations, typically found via\n+         *                           {@link ValuesSourceAggregationBuilder#getType()}\n+         * @param valuesSourceType   The ValuesSourceType this mapping applies to.\n          * @param aggregatorSupplier An Aggregation-specific specialization of AggregatorSupplier which will construct the mapped aggregator\n          *                           from the aggregation standard set of parameters\n          */\n         public void register(String aggregationName, ValuesSourceType valuesSourceType, AggregatorSupplier aggregatorSupplier) {\n-            register(aggregationName, (candidate) -> valuesSourceType.equals(candidate), aggregatorSupplier);\n+            register(aggregationName, new SingleRegistryEntry(aggregatorSupplier, valuesSourceType));\n         }\n \n         /**\n          * Register a ValuesSource to Aggregator mapping.  This version provides a convenience method for mappings that only apply to a\n          * known list of {@link ValuesSourceType}, to allow passing in the type and auto-wrapping it in a predicate\n-         *  @param aggregationName The name of the family of aggregations, typically found via\n-         *                         {@link ValuesSourceAggregationBuilder#getType()}\n-         * @param valuesSourceTypes The ValuesSourceTypes this mapping applies to.\n+         *\n+         * @param aggregationName    The name of the family of aggregations, typically found via\n+         *                           {@link ValuesSourceAggregationBuilder#getType()}\n+         * @param valuesSourceTypes  The ValuesSourceTypes this mapping applies to.\n          * @param aggregatorSupplier An Aggregation-specific specialization of AggregatorSupplier which will construct the mapped aggregator\n          *                           from the aggregation standard set of parameters\n          */\n         public void register(String aggregationName, List<ValuesSourceType> valuesSourceTypes, AggregatorSupplier aggregatorSupplier) {\n-            register(aggregationName, (candidate) -> {\n-                for (ValuesSourceType valuesSourceType : valuesSourceTypes) {\n-                    if (valuesSourceType.equals(candidate)) {\n-                        return true;\n-                    }\n-                }\n-                return false;\n-            }, aggregatorSupplier);\n+            register(aggregationName, new MultiRegistryEntry(aggregatorSupplier, valuesSourceTypes));\n         }\n \n         /**\n          * Register an aggregator that applies to any values source type.  This is a convenience method for aggregations that do not care at\n          * all about the types of their inputs.  Aggregations using this version of registration should not make any other registrations, as\n          * the aggregator registered using this function will be applied in all cases.\n          *\n-         * @param aggregationName The name of the family of aggregations, typically found via\n-         *                        {@link ValuesSourceAggregationBuilder#getType()}\n+         * @param aggregationName    The name of the family of aggregations, typically found via\n+         *                           {@link ValuesSourceAggregationBuilder#getType()}\n          * @param aggregatorSupplier An Aggregation-specific specialization of AggregatorSupplier which will construct the mapped aggregator\n          *                           from the aggregation standard set of parameters.\n          */\n         public void registerAny(String aggregationName, AggregatorSupplier aggregatorSupplier) {\n-            register(aggregationName, (ignored) -> true, aggregatorSupplier);\n+            register(aggregationName, new AnyRegistryEntry(aggregatorSupplier));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY5NzA5OQ=="}, "originalCommit": {"oid": "c0a7dd4142816e01727a8e4120014727201a1cbc"}, "originalPosition": 226}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5MzIwODMyOnYy", "diffSide": "RIGHT", "path": "distribution/archives/integ-test-zip/src/test/java/org/elasticsearch/test/rest/NodeRestUsageIT.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNzozOTozM1rOGNfhhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNzozOTozM1rOGNfhhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjgwMTE1OA==", "bodyText": "Should we refresh after indexing?  Or does it not matter for the usage stats if the fields are potentially  unmapped?\nIf it doesn' matter, maybe we could skip indexing to save some time?", "url": "https://github.com/elastic/elasticsearch/pull/55732#discussion_r416801158", "createdAt": "2020-04-28T17:39:33Z", "author": {"login": "polyfractal"}, "path": "distribution/archives/integ-test-zip/src/test/java/org/elasticsearch/test/rest/NodeRestUsageIT.java", "diffHunk": "@@ -143,4 +133,99 @@ public void testMetricsWithAll() throws IOException {\n                 + \"\\\"reason\\\":\\\"request [_nodes/usage/_all,rest_actions] contains _all and individual metrics [_all,rest_actions]\\\"\"));\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n+    public void testAggregationUsage() throws IOException {\n+        // First get the current usage figures\n+        String path = randomFrom(\"_nodes/usage\", \"_nodes/usage/aggregations\", \"_nodes/usage/_all\");\n+        Response beforeResponse = client().performRequest(new Request(\"GET\", path));\n+        Map<String, Object> beforeResponseBodyMap = entityAsMap(beforeResponse);\n+        assertThat(beforeResponseBodyMap, notNullValue());\n+        int beforeSuccessful = assertSuccess(beforeResponseBodyMap);\n+\n+        Map<String, Object> beforeNodesMap = (Map<String, Object>) beforeResponseBodyMap.get(\"nodes\");\n+        assertThat(beforeNodesMap, notNullValue());\n+        assertThat(beforeNodesMap.size(), equalTo(beforeSuccessful));\n+\n+        Map<String, Map<String, Long>> beforeCombinedAggsUsage = getTotalUsage(beforeNodesMap);\n+        // Do some requests to get some rest usage stats\n+        client().performRequest(new Request(\"PUT\", \"/test\"));\n+        for (int i = 0; i < 3; i++) {\n+            final Request index = new Request(\"POST\", \"/test/_doc/\" + i);\n+            index.setJsonEntity(\"{\\\"str\\\": \\\"val\\\", \\\"foo\\\":\\\"bar\\\", \\\"num\\\": 5, \\\"start\\\": \\\"2020-03-15\\\"}\");\n+            client().performRequest(index);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "424884a4bf37001f1072f32283d7d04f49baac69"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5MzIxNjA2OnYy", "diffSide": "RIGHT", "path": "docs/reference/cluster/nodes-usage.asciidoc", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNzo0MToyN1rOGNfmVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxODo1ODo1OVrOGNihkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjgwMjM4OQ==", "bodyText": "Was this name change due to the PR, or were the docs always incorrect?", "url": "https://github.com/elastic/elasticsearch/pull/55732#discussion_r416802389", "createdAt": "2020-04-28T17:41:27Z", "author": {"login": "polyfractal"}, "path": "docs/reference/cluster/nodes-usage.asciidoc", "diffHunk": "@@ -79,11 +79,14 @@ The API returns the following response:\n       \"timestamp\": 1492553961812, <1>\n       \"since\": 1492553906606, <2>\n       \"rest_actions\": {\n-        \"org.elasticsearch.rest.action.admin.cluster.RestNodesUsageAction\": 1,\n-        \"org.elasticsearch.rest.action.admin.indices.RestCreateIndexAction\": 1,\n-        \"org.elasticsearch.rest.action.document.RestGetAction\": 1,\n-        \"org.elasticsearch.rest.action.search.RestSearchAction\": 19, <3>\n-        \"org.elasticsearch.rest.action.admin.cluster.RestNodesInfoAction\": 36\n+        \"nodes_usage_action\": 1,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "424884a4bf37001f1072f32283d7d04f49baac69"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjg1MDMyMw==", "bodyText": "No, we ignore this section. So when it was refactored in May 2017 we didn't update the docs.", "url": "https://github.com/elastic/elasticsearch/pull/55732#discussion_r416850323", "createdAt": "2020-04-28T18:58:59Z", "author": {"login": "imotov"}, "path": "docs/reference/cluster/nodes-usage.asciidoc", "diffHunk": "@@ -79,11 +79,14 @@ The API returns the following response:\n       \"timestamp\": 1492553961812, <1>\n       \"since\": 1492553906606, <2>\n       \"rest_actions\": {\n-        \"org.elasticsearch.rest.action.admin.cluster.RestNodesUsageAction\": 1,\n-        \"org.elasticsearch.rest.action.admin.indices.RestCreateIndexAction\": 1,\n-        \"org.elasticsearch.rest.action.document.RestGetAction\": 1,\n-        \"org.elasticsearch.rest.action.search.RestSearchAction\": 19, <3>\n-        \"org.elasticsearch.rest.action.admin.cluster.RestNodesInfoAction\": 36\n+        \"nodes_usage_action\": 1,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjgwMjM4OQ=="}, "originalCommit": {"oid": "424884a4bf37001f1072f32283d7d04f49baac69"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5MzI0NDU3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/SearchModule.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNzo0ODoxNlrOGNf3wA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxOTowMDo1MlrOGNilqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjgwNjg0OA==", "bodyText": "Could we add a comment here, to the effect of the registry handles usage tracking, but since not all aggs use it we need to track the other ones explicitly?  I feel like I'll stumble on this in the future and be confused :)", "url": "https://github.com/elastic/elasticsearch/pull/55732#discussion_r416806848", "createdAt": "2020-04-28T17:48:16Z", "author": {"login": "polyfractal"}, "path": "server/src/main/java/org/elasticsearch/search/SearchModule.java", "diffHunk": "@@ -483,6 +488,8 @@ private void registerAggregation(AggregationSpec spec, ValuesSourceRegistry.Buil\n         Consumer<ValuesSourceRegistry.Builder> register = spec.getAggregatorRegistrar();\n         if (register != null) {\n             register.accept(builder);\n+        } else {\n+            usageService.registerAggregationUsage(spec.getName().getPreferredName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "424884a4bf37001f1072f32283d7d04f49baac69"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjg1MTM2OQ==", "bodyText": "Hmm, I was 100% I had this comment there. Strange.", "url": "https://github.com/elastic/elasticsearch/pull/55732#discussion_r416851369", "createdAt": "2020-04-28T19:00:52Z", "author": {"login": "imotov"}, "path": "server/src/main/java/org/elasticsearch/search/SearchModule.java", "diffHunk": "@@ -483,6 +488,8 @@ private void registerAggregation(AggregationSpec spec, ValuesSourceRegistry.Buil\n         Consumer<ValuesSourceRegistry.Builder> register = spec.getAggregatorRegistrar();\n         if (register != null) {\n             register.accept(builder);\n+        } else {\n+            usageService.registerAggregationUsage(spec.getName().getPreferredName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjgwNjg0OA=="}, "originalCommit": {"oid": "424884a4bf37001f1072f32283d7d04f49baac69"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5MzI3Mzg4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/aggregations/AggregatorFactory.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNzo1NTozN1rOGNgJ_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNzo1NTozN1rOGNgJ_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjgxMTUxOA==", "bodyText": "Could we add a javadoc for what this is/used for?", "url": "https://github.com/elastic/elasticsearch/pull/55732#discussion_r416811518", "createdAt": "2020-04-28T17:55:37Z", "author": {"login": "polyfractal"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/AggregatorFactory.java", "diffHunk": "@@ -238,4 +240,7 @@ protected static Aggregator asMultiBucketAggregator(final AggregatorFactory fact\n         return new MultiBucketAggregatorWrapper(bigArrays, searchContext, parent, factory, first);\n     }\n \n+    public String getStatsSubtype() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "424884a4bf37001f1072f32283d7d04f49baac69"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5MzMwODUyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/SearchModule.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxODowNDowMVrOGNgflQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxODowNDowMVrOGNgflQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjgxNzA0NQ==", "bodyText": "Heh, this is a bit cheeky...took me a minute to figure out what was going on here :)", "url": "https://github.com/elastic/elasticsearch/pull/55732#discussion_r416817045", "createdAt": "2020-04-28T18:04:01Z", "author": {"login": "polyfractal"}, "path": "server/src/main/java/org/elasticsearch/search/SearchModule.java", "diffHunk": "@@ -322,13 +326,14 @@ public ValuesSourceRegistry getValuesSourceRegistry() {\n     }\n \n     private ValuesSourceRegistry registerAggregations(List<SearchPlugin> plugins) {\n-        ValuesSourceRegistry.Builder builder = new ValuesSourceRegistry.Builder();\n+        ValuesSourceRegistry.Builder builder = new ValuesSourceRegistry.Builder(usageService);\n \n         registerAggregation(new AggregationSpec(AvgAggregationBuilder.NAME, AvgAggregationBuilder::new, AvgAggregationBuilder.PARSER)\n             .addResultReader(InternalAvg::new)\n             .setAggregatorRegistrar(AvgAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(WeightedAvgAggregationBuilder.NAME, WeightedAvgAggregationBuilder::new,\n-            WeightedAvgAggregationBuilder.PARSER).addResultReader(InternalWeightedAvg::new), builder);\n+            WeightedAvgAggregationBuilder.PARSER).addResultReader(InternalWeightedAvg::new)\n+            .setAggregatorRegistrar(WeightedAvgAggregationBuilder::registerUsage), builder);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "424884a4bf37001f1072f32283d7d04f49baac69"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5MzMxOTAxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/usage/UsageService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxODowNjo0NVrOGNgmAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxOToxNjoxMlrOGNjIYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjgxODY4OQ==", "bodyText": "Are there other aggs that aren't caught by the else in SearchModule (using registerAggregationUsage(String aggregationName) )?", "url": "https://github.com/elastic/elasticsearch/pull/55732#discussion_r416818689", "createdAt": "2020-04-28T18:06:45Z", "author": {"login": "polyfractal"}, "path": "server/src/main/java/org/elasticsearch/usage/UsageService.java", "diffHunk": "@@ -89,6 +92,33 @@ public void addRestHandler(BaseRestHandler handler) {\n         }\n     }\n \n+    public static final String OTHER_SUBTYPE = \"other\";\n+\n+    public void registerAggregationUsage(String aggregationName) {\n+        registerAggregationUsage(aggregationName, OTHER_SUBTYPE);\n+    }\n+\n+    public void registerAggregationUsage(String aggregationName, String valuesSourceType) {\n+        Map<String, LongAdder> subAgg = aggs.computeIfAbsent(aggregationName, k -> new HashMap<>());\n+        if ( subAgg.put(valuesSourceType, new LongAdder()) != null) {\n+            throw new IllegalArgumentException(\"stats for aggregation [\" + aggregationName + \"][\" + valuesSourceType +\n+                \"] already registered\");\n+        }\n+    }\n+\n+    public void incAggregationUsage(String aggregationName, String valuesSourceType) {\n+        Map<String, LongAdder> valuesSourceMap = aggs.get(aggregationName);\n+        // Not all aggs register their usage at the moment we also don't register them in test context", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "424884a4bf37001f1072f32283d7d04f49baac69"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjg2MDI1Ng==", "bodyText": "Hmm, good point. Let's find out.", "url": "https://github.com/elastic/elasticsearch/pull/55732#discussion_r416860256", "createdAt": "2020-04-28T19:16:12Z", "author": {"login": "imotov"}, "path": "server/src/main/java/org/elasticsearch/usage/UsageService.java", "diffHunk": "@@ -89,6 +92,33 @@ public void addRestHandler(BaseRestHandler handler) {\n         }\n     }\n \n+    public static final String OTHER_SUBTYPE = \"other\";\n+\n+    public void registerAggregationUsage(String aggregationName) {\n+        registerAggregationUsage(aggregationName, OTHER_SUBTYPE);\n+    }\n+\n+    public void registerAggregationUsage(String aggregationName, String valuesSourceType) {\n+        Map<String, LongAdder> subAgg = aggs.computeIfAbsent(aggregationName, k -> new HashMap<>());\n+        if ( subAgg.put(valuesSourceType, new LongAdder()) != null) {\n+            throw new IllegalArgumentException(\"stats for aggregation [\" + aggregationName + \"][\" + valuesSourceType +\n+                \"] already registered\");\n+        }\n+    }\n+\n+    public void incAggregationUsage(String aggregationName, String valuesSourceType) {\n+        Map<String, LongAdder> valuesSourceMap = aggs.get(aggregationName);\n+        // Not all aggs register their usage at the moment we also don't register them in test context", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjgxODY4OQ=="}, "originalCommit": {"oid": "424884a4bf37001f1072f32283d7d04f49baac69"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5MzMyNjMyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/usage/UsageService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxODowODo1MVrOGNgqrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxOToxNToyMlrOGNjGeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjgxOTg4Nw==", "bodyText": "I wonder if we should just log an error but not actually throw an exception?  I'm thinking if we end up breaking something on the usage side, it'd be a shame if it actually broke the aggs until we got a bugfix out", "url": "https://github.com/elastic/elasticsearch/pull/55732#discussion_r416819887", "createdAt": "2020-04-28T18:08:51Z", "author": {"login": "polyfractal"}, "path": "server/src/main/java/org/elasticsearch/usage/UsageService.java", "diffHunk": "@@ -89,6 +92,33 @@ public void addRestHandler(BaseRestHandler handler) {\n         }\n     }\n \n+    public static final String OTHER_SUBTYPE = \"other\";\n+\n+    public void registerAggregationUsage(String aggregationName) {\n+        registerAggregationUsage(aggregationName, OTHER_SUBTYPE);\n+    }\n+\n+    public void registerAggregationUsage(String aggregationName, String valuesSourceType) {\n+        Map<String, LongAdder> subAgg = aggs.computeIfAbsent(aggregationName, k -> new HashMap<>());\n+        if ( subAgg.put(valuesSourceType, new LongAdder()) != null) {\n+            throw new IllegalArgumentException(\"stats for aggregation [\" + aggregationName + \"][\" + valuesSourceType +\n+                \"] already registered\");\n+        }\n+    }\n+\n+    public void incAggregationUsage(String aggregationName, String valuesSourceType) {\n+        Map<String, LongAdder> valuesSourceMap = aggs.get(aggregationName);\n+        // Not all aggs register their usage at the moment we also don't register them in test context\n+        if (valuesSourceMap != null) {\n+            LongAdder adder = valuesSourceMap.get(valuesSourceType);\n+            if (adder != null) {\n+                adder.increment();\n+            } else {\n+                throw new IllegalArgumentException(\"Unknown subtype [\" + aggregationName + \"][\" + valuesSourceType + \"]\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "424884a4bf37001f1072f32283d7d04f49baac69"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjg1OTc2OA==", "bodyText": "That helped me to find a lot of strange behaving aggregations. But you are right, I might just replace this with assert for now.", "url": "https://github.com/elastic/elasticsearch/pull/55732#discussion_r416859768", "createdAt": "2020-04-28T19:15:22Z", "author": {"login": "imotov"}, "path": "server/src/main/java/org/elasticsearch/usage/UsageService.java", "diffHunk": "@@ -89,6 +92,33 @@ public void addRestHandler(BaseRestHandler handler) {\n         }\n     }\n \n+    public static final String OTHER_SUBTYPE = \"other\";\n+\n+    public void registerAggregationUsage(String aggregationName) {\n+        registerAggregationUsage(aggregationName, OTHER_SUBTYPE);\n+    }\n+\n+    public void registerAggregationUsage(String aggregationName, String valuesSourceType) {\n+        Map<String, LongAdder> subAgg = aggs.computeIfAbsent(aggregationName, k -> new HashMap<>());\n+        if ( subAgg.put(valuesSourceType, new LongAdder()) != null) {\n+            throw new IllegalArgumentException(\"stats for aggregation [\" + aggregationName + \"][\" + valuesSourceType +\n+                \"] already registered\");\n+        }\n+    }\n+\n+    public void incAggregationUsage(String aggregationName, String valuesSourceType) {\n+        Map<String, LongAdder> valuesSourceMap = aggs.get(aggregationName);\n+        // Not all aggs register their usage at the moment we also don't register them in test context\n+        if (valuesSourceMap != null) {\n+            LongAdder adder = valuesSourceMap.get(valuesSourceType);\n+            if (adder != null) {\n+                adder.increment();\n+            } else {\n+                throw new IllegalArgumentException(\"Unknown subtype [\" + aggregationName + \"][\" + valuesSourceType + \"]\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjgxOTg4Nw=="}, "originalCommit": {"oid": "424884a4bf37001f1072f32283d7d04f49baac69"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5MzMzNTgxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/analytics/src/main/java/org/elasticsearch/xpack/analytics/AnalyticsPlugin.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxODoxMToxOVrOGNgwlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxODoxMToxOVrOGNgwlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjgyMTM5Ng==", "bodyText": "Hmm... we should probably discuss if we still want these being tracked separately? Unrelated to this PR though, just something I hadn't thought about :)", "url": "https://github.com/elastic/elasticsearch/pull/55732#discussion_r416821396", "createdAt": "2020-04-28T18:11:19Z", "author": {"login": "polyfractal"}, "path": "x-pack/plugin/analytics/src/main/java/org/elasticsearch/xpack/analytics/AnalyticsPlugin.java", "diffHunk": "@@ -105,6 +105,7 @@ public AnalyticsPlugin() { }\n                 TTestAggregationBuilder::new,\n                 usage.track(AnalyticsStatsAction.Item.T_TEST, checkLicense(TTestAggregationBuilder.PARSER)))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "424884a4bf37001f1072f32283d7d04f49baac69"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NzAwMzIyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/aggregations/support/ValuesSourceType.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNTowMjoyNlrOGODQRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxOTowMDoxM1rOGOMxpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzM4NjU2Ng==", "bodyText": "I might be overthinking this, but there's nothing that prevents two plugins from registering a values source type with the same name.  I'm wondering if we should just default this in the interface to use canonical names (aka fully qualified class names) to avoid collisions.  Then we'd only need to override it for the \"other\" case, I think?", "url": "https://github.com/elastic/elasticsearch/pull/55732#discussion_r417386566", "createdAt": "2020-04-29T15:02:26Z", "author": {"login": "not-napoleon"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/support/ValuesSourceType.java", "diffHunk": "@@ -98,4 +98,10 @@ ValuesSource replaceMissing(ValuesSource valuesSource, Object rawMissing, DocVal\n     default DocValueFormat getFormatter(String format, ZoneId tz) {\n         return DocValueFormat.RAW;\n     }\n+\n+    /**\n+     * Returns the name of the Values Source Type for stats purposes\n+     * @return the name of the Values Source Type\n+     */\n+    String typeName();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9bed396d6e5ad2a10c107287a0efe86bd59e9b4"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU0MjU2Ng==", "bodyText": "This name is used only under the aggregation name so \"foo\" in aggregation \"bar\" can be different from \"foo\" in the aggregation  \"baz\"  and it is perfectly fine because this \"foo\" will be \"assessed\" only in the context of aggregation usage. In usage, we are trying to use user-friendly names. So fully qualified class names will be very out of place there.", "url": "https://github.com/elastic/elasticsearch/pull/55732#discussion_r417542566", "createdAt": "2020-04-29T19:00:13Z", "author": {"login": "imotov"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/support/ValuesSourceType.java", "diffHunk": "@@ -98,4 +98,10 @@ ValuesSource replaceMissing(ValuesSource valuesSource, Object rawMissing, DocVal\n     default DocValueFormat getFormatter(String format, ZoneId tz) {\n         return DocValueFormat.RAW;\n     }\n+\n+    /**\n+     * Returns the name of the Values Source Type for stats purposes\n+     * @return the name of the Values Source Type\n+     */\n+    String typeName();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzM4NjU2Ng=="}, "originalCommit": {"oid": "c9bed396d6e5ad2a10c107287a0efe86bd59e9b4"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NzAwODcyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/usage/UsageService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNTowMzo0NVrOGODT2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxOTowMTo0N1rOGOM0vQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzM4NzQ4MQ==", "bodyText": "Nit: Javadoc.  Especially since this looks like it's used concurrently, we should document the expected concurrency behavior.\nAlso, am I missing something or is this not called right now?  I only saw a few uses in tests.", "url": "https://github.com/elastic/elasticsearch/pull/55732#discussion_r417387481", "createdAt": "2020-04-29T15:03:45Z", "author": {"login": "not-napoleon"}, "path": "server/src/main/java/org/elasticsearch/usage/UsageService.java", "diffHunk": "@@ -89,6 +92,33 @@ public void addRestHandler(BaseRestHandler handler) {\n         }\n     }\n \n+    public static final String OTHER_SUBTYPE = \"other\";\n+\n+    public void registerAggregationUsage(String aggregationName) {\n+        registerAggregationUsage(aggregationName, OTHER_SUBTYPE);\n+    }\n+\n+    public void registerAggregationUsage(String aggregationName, String valuesSourceType) {\n+        Map<String, LongAdder> subAgg = aggs.computeIfAbsent(aggregationName, k -> new HashMap<>());\n+        if ( subAgg.put(valuesSourceType, new LongAdder()) != null) {\n+            throw new IllegalArgumentException(\"stats for aggregation [\" + aggregationName + \"][\" + valuesSourceType +\n+                \"] already registered\");\n+        }\n+    }\n+\n+    public void incAggregationUsage(String aggregationName, String valuesSourceType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9bed396d6e5ad2a10c107287a0efe86bd59e9b4"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU0MzM1Nw==", "bodyText": "It is called in AbstractAggregationBuilder#build", "url": "https://github.com/elastic/elasticsearch/pull/55732#discussion_r417543357", "createdAt": "2020-04-29T19:01:47Z", "author": {"login": "imotov"}, "path": "server/src/main/java/org/elasticsearch/usage/UsageService.java", "diffHunk": "@@ -89,6 +92,33 @@ public void addRestHandler(BaseRestHandler handler) {\n         }\n     }\n \n+    public static final String OTHER_SUBTYPE = \"other\";\n+\n+    public void registerAggregationUsage(String aggregationName) {\n+        registerAggregationUsage(aggregationName, OTHER_SUBTYPE);\n+    }\n+\n+    public void registerAggregationUsage(String aggregationName, String valuesSourceType) {\n+        Map<String, LongAdder> subAgg = aggs.computeIfAbsent(aggregationName, k -> new HashMap<>());\n+        if ( subAgg.put(valuesSourceType, new LongAdder()) != null) {\n+            throw new IllegalArgumentException(\"stats for aggregation [\" + aggregationName + \"][\" + valuesSourceType +\n+                \"] already registered\");\n+        }\n+    }\n+\n+    public void incAggregationUsage(String aggregationName, String valuesSourceType) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzM4NzQ4MQ=="}, "originalCommit": {"oid": "c9bed396d6e5ad2a10c107287a0efe86bd59e9b4"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NzMxNTU3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/aggregations/support/ValuesSourceRegistry.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNjoxMjoxMVrOGOGYpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNjoxMjoxMVrOGOGYpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQzNzg2Mw==", "bodyText": "I made a note below about documenting the concurrency behavior, but we should also call it out here.  In particular, nothing else we return out of the registry has a mutable internal state, but this does.", "url": "https://github.com/elastic/elasticsearch/pull/55732#discussion_r417437863", "createdAt": "2020-04-29T16:12:11Z", "author": {"login": "not-napoleon"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/support/ValuesSourceRegistry.java", "diffHunk": "@@ -152,4 +168,8 @@ public ValuesSourceType getValuesSourceType(MappedFieldType fieldType, String ag\n             }\n         }\n     }\n+\n+    public UsageService getUsageService() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9bed396d6e5ad2a10c107287a0efe86bd59e9b4"}, "originalPosition": 76}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2723, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}