{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk1NzYxNzAw", "number": 54442, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxNjo1NzoyMVrODsxBPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQyMDo1MDo1MFrODs2TxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MjY3MDY5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/EndsWithFunctionPipe.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxNjo1NzoyMVrOF9zQEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxNjo1NzoyMVrOF9zQEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM0NzE1NA==", "bodyText": "nit: the getters were used instead in the previous PR and EndsWithFunctionProcessor. maybe make it consistent.", "url": "https://github.com/elastic/elasticsearch/pull/54442#discussion_r400347154", "createdAt": "2020-03-30T16:57:21Z", "author": {"login": "aleksmaus"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/EndsWithFunctionPipe.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.ql.execution.search.QlSourceBuilder;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class EndsWithFunctionPipe extends Pipe {\n+\n+    private final Pipe source;\n+    private final Pipe pattern;\n+\n+    public EndsWithFunctionPipe(Source source, Expression expression, Pipe src, Pipe pattern) {\n+        super(source, expression, Arrays.asList(src, pattern));\n+        this.source = src;\n+        this.pattern = pattern;\n+    }\n+\n+    @Override\n+    public final Pipe replaceChildren(List<Pipe> newChildren) {\n+        if (newChildren.size() != 2) {\n+            throw new IllegalArgumentException(\"expected [2] children but received [\" + newChildren.size() + \"]\");\n+        }\n+        return replaceChildren(newChildren.get(0), newChildren.get(1));\n+    }\n+\n+    @Override\n+    public final Pipe resolveAttributes(AttributeResolver resolver) {\n+        Pipe newSource = source.resolveAttributes(resolver);\n+        Pipe newPattern = pattern.resolveAttributes(resolver);\n+        if (newSource == source && newPattern == pattern) {\n+            return this;\n+        }\n+        return replaceChildren(newSource, newPattern);\n+    }\n+\n+    @Override\n+    public boolean supportedByAggsOnlyQuery() {\n+        return source.supportedByAggsOnlyQuery() && pattern.supportedByAggsOnlyQuery();\n+    }\n+\n+    @Override\n+    public boolean resolved() {\n+        return source.resolved() && pattern.resolved();\n+    }\n+\n+    protected Pipe replaceChildren(Pipe newSource, Pipe newPattern) {\n+        return new EndsWithFunctionPipe(source(), expression(), newSource, newPattern);\n+    }\n+\n+    @Override\n+    public final void collectFields(QlSourceBuilder sourceBuilder) {\n+        source.collectFields(sourceBuilder);\n+        pattern.collectFields(sourceBuilder);\n+    }\n+\n+    @Override\n+    protected NodeInfo<EndsWithFunctionPipe> info() {\n+        return NodeInfo.create(this, EndsWithFunctionPipe::new, expression(), source, pattern);\n+    }\n+\n+    @Override\n+    public EndsWithFunctionProcessor asProcessor() {\n+        return new EndsWithFunctionProcessor(source.asProcessor(), pattern.asProcessor());\n+    }\n+    \n+    public Pipe src() {\n+        return source;\n+    }\n+\n+    public Pipe pattern() {\n+        return pattern;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(source, pattern);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+\n+        if (obj == null || getClass() != obj.getClass()) {\n+            return false;\n+        }\n+\n+        EndsWithFunctionPipe other = (EndsWithFunctionPipe) obj;\n+        return Objects.equals(source, other.source)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93a3b14761609aca2573ef3632733a33952871ea"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MzUzNzMzOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/EndsWithFunctionProcessor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQyMDo1MDo1MFrOF97s4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQyMjoyNDo0NFrOF9-eVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ4NTYwMA==", "bodyText": "based off some of the conversations that have been happening, I think we're going to outsource this to something else eventually.\nI don't know if that  means we should do case-sensitivity in all PRs now, or come back to this later", "url": "https://github.com/elastic/elasticsearch/pull/54442#discussion_r400485600", "createdAt": "2020-03-30T20:50:50Z", "author": {"login": "rw-access"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/EndsWithFunctionProcessor.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.xpack.eql.EqlIllegalArgumentException;\n+import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n+\n+import java.io.IOException;\n+import java.util.Locale;\n+import java.util.Objects;\n+\n+public class EndsWithFunctionProcessor implements Processor {\n+\n+    public static final String NAME = \"senw\";\n+\n+    private final Processor source;\n+    private final Processor pattern;\n+\n+    public EndsWithFunctionProcessor(Processor source, Processor pattern) {\n+        this.source = source;\n+        this.pattern = pattern;\n+    }\n+\n+    public EndsWithFunctionProcessor(StreamInput in) throws IOException {\n+        source = in.readNamedWriteable(Processor.class);\n+        pattern = in.readNamedWriteable(Processor.class);\n+    }\n+\n+    @Override\n+    public final void writeTo(StreamOutput out) throws IOException {\n+        out.writeNamedWriteable(source);\n+        out.writeNamedWriteable(pattern);\n+    }\n+\n+    @Override\n+    public Object process(Object input) {\n+        return doProcess(source.process(input), pattern.process(input));\n+    }\n+\n+    public static Object doProcess(Object source, Object pattern) {\n+        if (source == null) {\n+            return null;\n+        }\n+        if (source instanceof String == false && source instanceof Character == false) {\n+            throw new EqlIllegalArgumentException(\"A string/char is required; received [{}]\", source);\n+        }\n+        if (pattern == null) {\n+            return null;\n+        }\n+        if (pattern instanceof String == false && pattern instanceof Character == false) {\n+            throw new EqlIllegalArgumentException(\"A string/char is required; received [{}]\", pattern);\n+        }\n+\n+        return source.toString().toLowerCase(Locale.ROOT).endsWith(pattern.toString().toLowerCase(Locale.ROOT));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93a3b14761609aca2573ef3632733a33952871ea"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUzMTAzMA==", "bodyText": "IMHO, this covers the feature parity with the original EQL implementation, and passes test against the EQL test data/queries.\nWe can merge this as is and keep iterating and moving forward.\nAlso this gives us a chance to refactor some of the code that can be better shared/reused across all of the functions implementations better.", "url": "https://github.com/elastic/elasticsearch/pull/54442#discussion_r400531030", "createdAt": "2020-03-30T22:24:44Z", "author": {"login": "aleksmaus"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/EndsWithFunctionProcessor.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.xpack.eql.EqlIllegalArgumentException;\n+import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n+\n+import java.io.IOException;\n+import java.util.Locale;\n+import java.util.Objects;\n+\n+public class EndsWithFunctionProcessor implements Processor {\n+\n+    public static final String NAME = \"senw\";\n+\n+    private final Processor source;\n+    private final Processor pattern;\n+\n+    public EndsWithFunctionProcessor(Processor source, Processor pattern) {\n+        this.source = source;\n+        this.pattern = pattern;\n+    }\n+\n+    public EndsWithFunctionProcessor(StreamInput in) throws IOException {\n+        source = in.readNamedWriteable(Processor.class);\n+        pattern = in.readNamedWriteable(Processor.class);\n+    }\n+\n+    @Override\n+    public final void writeTo(StreamOutput out) throws IOException {\n+        out.writeNamedWriteable(source);\n+        out.writeNamedWriteable(pattern);\n+    }\n+\n+    @Override\n+    public Object process(Object input) {\n+        return doProcess(source.process(input), pattern.process(input));\n+    }\n+\n+    public static Object doProcess(Object source, Object pattern) {\n+        if (source == null) {\n+            return null;\n+        }\n+        if (source instanceof String == false && source instanceof Character == false) {\n+            throw new EqlIllegalArgumentException(\"A string/char is required; received [{}]\", source);\n+        }\n+        if (pattern == null) {\n+            return null;\n+        }\n+        if (pattern instanceof String == false && pattern instanceof Character == false) {\n+            throw new EqlIllegalArgumentException(\"A string/char is required; received [{}]\", pattern);\n+        }\n+\n+        return source.toString().toLowerCase(Locale.ROOT).endsWith(pattern.toString().toLowerCase(Locale.ROOT));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ4NTYwMA=="}, "originalCommit": {"oid": "93a3b14761609aca2573ef3632733a33952871ea"}, "originalPosition": 59}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3987, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}