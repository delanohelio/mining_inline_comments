{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYzNTQxNDg0", "number": 51088, "title": "SQL: Add optimisations for not-equalities", "bodyText": "This PR adds optimisations of not-equalities in conjunctions and\ndisjunctions:\n\nfor conjunctions, the not-equality can be optimized away when applied\ntogether with a range or inequality, in case the not-equality point\nfalls outside the domain of the later condition; if its on the boarder,\nit will modify the bound, to simply exclude the equality, if present;\notherwise no optimisation can be applied;\nfor disjunctions, the not-equals filters away the ranges and\ninequalities, unless these include an equality on the bound, in which\ncase the entire condition becomes always true.\n\nIt also fixes the aggregation of inequalities into ranges.\nAdresses #49637.", "createdAt": "2020-01-16T09:27:51Z", "url": "https://github.com/elastic/elasticsearch/pull/51088", "merged": true, "mergeCommit": {"oid": "789724ac2cc726de603849b4eeb8194da7528bcc"}, "closed": true, "closedAt": "2020-01-30T19:17:07Z", "author": {"login": "bpintea"}, "timelineItems": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb62a3IgH2gAyMzYzNTQxNDg0OjA4ZGNmZTdiZDhiNDc4NjMzZmEwN2UxYTljODk4Nzc5OTVhZmRlN2I=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb_eLzSAH2gAyMzYzNTQxNDg0OmY4M2M5OGFkZDk5OTdjOGVkMWJlOGFmNzdlMzU2YWJmYjM0NmZiYTA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "08dcfe7bd8b478633fa07e1a9c89877995afde7b", "author": {"user": {"login": "bpintea", "name": "Bogdan Pintea"}}, "url": "https://github.com/elastic/elasticsearch/commit/08dcfe7bd8b478633fa07e1a9c89877995afde7b", "committedDate": "2020-01-16T09:06:45Z", "message": "Optimize not-equalities in con-/disjunctions\n\nThis commit adds optimisations of not-equalities in conjunctions and\ndisjunctions:\n* for conjunctions, the not-equality can be optimized away when applied\ntogether with a range or inequality, in case the not-equality point\nfalls outside the domain of the later condition; if its on the boarder,\nit will modify the bound, to simply exclude the equality, if present;\notherwise no optimisation can be applied;\n* for disjunctions, the not-equals filters away the ranges and\ninequalities, unless these include an equality on the bound, in which\ncase the entire condition becomes always true."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "50e4fbb0bd94f6c6b1ee739bafe7711d4a92a442", "author": {"user": {"login": "bpintea", "name": "Bogdan Pintea"}}, "url": "https://github.com/elastic/elasticsearch/commit/50e4fbb0bd94f6c6b1ee739bafe7711d4a92a442", "committedDate": "2020-01-16T09:14:35Z", "message": "fix aggregations of inequalities in ranges\n\nThis commit fixes the loop that aggregates inequalities into ranges:\n- it won't advance the outer loop index in case of a merge, since the\ncurrent element is removed;\n- it will break the inner loop, since comparision against the element\nselected in the outer loop can't continue, as it had been removed."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzOTQwMzA0", "url": "https://github.com/elastic/elasticsearch/pull/51088#pullrequestreview-343940304", "createdAt": "2020-01-16T14:14:00Z", "commit": {"oid": "50e4fbb0bd94f6c6b1ee739bafe7711d4a92a442"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNDoxNDowMFrOFeasKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNDoxNDowMFrOFeasKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQzODg5MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                return 0; // kep NotEquals' order\n          \n          \n            \n                                return 0; // keep NotEquals' order", "url": "https://github.com/elastic/elasticsearch/pull/51088#discussion_r367438890", "createdAt": "2020-01-16T14:14:00Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -1290,14 +1290,20 @@ private Expression combine(And and) {\n             boolean changed = false;\n \n             List<Expression> andExps = Predicates.splitAnd(and);\n-            // Ranges need to show up before BinaryComparisons in list, to allow the latter be optimized away into a Range, if possible\n+            // Ranges need to show up before BinaryComparisons in list, to allow the latter be optimized away into a Range, if possible.\n+            // NotEquals need to be last in list, to have a complete set of Ranges (ranges) and BinaryComparisons (bcs) and allow these to\n+            // optimize the NotEquals away.\n             andExps.sort((o1, o2) -> {\n                 if (o1 instanceof Range && o2 instanceof Range) {\n                     return 0; // keep ranges' order\n                 } else if (o1 instanceof Range || o2 instanceof Range) {\n-                    return o2 instanceof Range ? 1 : -1;\n+                    return o2 instanceof Range ? 1 : -1; // push Ranges down\n+                } else if (o1 instanceof NotEquals && o2 instanceof NotEquals) {\n+                    return 0; // kep NotEquals' order", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50e4fbb0bd94f6c6b1ee739bafe7711d4a92a442"}, "originalPosition": 51}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "23e3aac6ab9b77c3902ca45772da4c2c0b7ae676", "author": {"user": {"login": "bpintea", "name": "Bogdan Pintea"}}, "url": "https://github.com/elastic/elasticsearch/commit/23e3aac6ab9b77c3902ca45772da4c2c0b7ae676", "committedDate": "2020-01-16T14:51:07Z", "message": "Update x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java\r\n\r\napply review suggestion\n\nCo-Authored-By: Marios Trivyzas <matriv@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzOTQxMDYw", "url": "https://github.com/elastic/elasticsearch/pull/51088#pullrequestreview-343941060", "createdAt": "2020-01-16T14:15:06Z", "commit": {"oid": "50e4fbb0bd94f6c6b1ee739bafe7711d4a92a442"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNDoxNTowN1rOFeauUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNjozOToyNVrOFegBGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQzOTQ0MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                return 0; // keep non-Ranges' and non-NotEquals order\n          \n          \n            \n                                return 0; // keep non-Ranges' and non-NotEquals' order", "url": "https://github.com/elastic/elasticsearch/pull/51088#discussion_r367439440", "createdAt": "2020-01-16T14:15:07Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -1290,14 +1290,20 @@ private Expression combine(And and) {\n             boolean changed = false;\n \n             List<Expression> andExps = Predicates.splitAnd(and);\n-            // Ranges need to show up before BinaryComparisons in list, to allow the latter be optimized away into a Range, if possible\n+            // Ranges need to show up before BinaryComparisons in list, to allow the latter be optimized away into a Range, if possible.\n+            // NotEquals need to be last in list, to have a complete set of Ranges (ranges) and BinaryComparisons (bcs) and allow these to\n+            // optimize the NotEquals away.\n             andExps.sort((o1, o2) -> {\n                 if (o1 instanceof Range && o2 instanceof Range) {\n                     return 0; // keep ranges' order\n                 } else if (o1 instanceof Range || o2 instanceof Range) {\n-                    return o2 instanceof Range ? 1 : -1;\n+                    return o2 instanceof Range ? 1 : -1; // push Ranges down\n+                } else if (o1 instanceof NotEquals && o2 instanceof NotEquals) {\n+                    return 0; // kep NotEquals' order\n+                } else if (o1 instanceof NotEquals || o2 instanceof NotEquals) {\n+                    return o1 instanceof NotEquals ? 1 : -1; // push NotEquals up\n                 } else {\n-                    return 0; // keep non-ranges' order\n+                    return 0; // keep non-Ranges' and non-NotEquals order", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50e4fbb0bd94f6c6b1ee739bafe7711d4a92a442"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUyNjE3MA==", "bodyText": "I would prefer the return value of the function to be boolean and not Boolean since false is never returned currently. Or if I'm confused if false is also a valid return value then why do we return a below literal with Boolean.TRUE instead of using the updated variable there?", "url": "https://github.com/elastic/elasticsearch/pull/51088#discussion_r367526170", "createdAt": "2020-01-16T16:39:25Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -1391,7 +1412,14 @@ private Expression combine(Or or) {\n                 }\n             }\n \n-            return changed ? Predicates.combineOr(CollectionUtils.combine(exps, bcs, ranges)) : or;\n+            Boolean updated = filterDisjunctionByNotEquals(notEquals, bcs, ranges);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23e3aac6ab9b77c3902ca45772da4c2c0b7ae676"}, "originalPosition": 156}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4b7fc42accf23af586c4bc780b3215db99619af2", "author": {"user": {"login": "bpintea", "name": "Bogdan Pintea"}}, "url": "https://github.com/elastic/elasticsearch/commit/4b7fc42accf23af586c4bc780b3215db99619af2", "committedDate": "2020-01-16T17:31:58Z", "message": "Update x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java\r\n\r\napply review suggestion.\n\nCo-Authored-By: Marios Trivyzas <matriv@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0NjYzNDA1", "url": "https://github.com/elastic/elasticsearch/pull/51088#pullrequestreview-344663405", "createdAt": "2020-01-17T15:41:46Z", "commit": {"oid": "4b7fc42accf23af586c4bc780b3215db99619af2"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1NjY2MDkz", "url": "https://github.com/elastic/elasticsearch/pull/51088#pullrequestreview-345666093", "createdAt": "2020-01-21T07:00:55Z", "commit": {"oid": "4b7fc42accf23af586c4bc780b3215db99619af2"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQwNzowMDo1NVrOFfwB-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQwNzoyMzo1NVrOFfwZYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODgzNzExMg==", "bodyText": "I find a bit confusing and potentially problematic, in the future if this code will change, re-using the comp variable in this block. Initially, it has a value assigned to it in on an upper level, it goes through two if branches, then in a separate, distinct conditional branch on an inner level gets another value and is treated similarly as before. I am not suggesting to change this, I am just mentioning it as a nitpick.", "url": "https://github.com/elastic/elasticsearch/pull/51088#discussion_r368837112", "createdAt": "2020-01-21T07:00:55Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -1643,6 +1671,137 @@ else if ((other instanceof LessThan || other instanceof LessThanOrEqual) &&\n \n             return false;\n         }\n+\n+        private static boolean notEqualsIsRemovableFromConjunction(NotEquals notEquals, List<Range> ranges, List<BinaryComparison> bcs) {\n+            Object neqVal = notEquals.right().fold();\n+            Integer comp;\n+\n+            // check on \"condition-overlapping\" ranges:\n+            // a != 2 AND 3 < a < 5 -> 3 < a < 5; a != 2 AND 0 < a < 1 -> 0 < a < 1 (discard NotEquals)\n+            // a != 2 AND 2 <= a < 3 -> 2 < a < 3; a != 3 AND 2 < a <= 3 -> 2 < a < 3 (discard NotEquals, plus update Range)\n+            // a != 2 AND 1 < a < 3 -> nop (do nothing)\n+            for (int i = 0; i < ranges.size(); i ++) {\n+                Range range = ranges.get(i);\n+\n+                if (notEquals.left().semanticEquals(range.value())) {\n+                    comp = range.lower().foldable() ? BinaryComparison.compare(neqVal, range.lower().fold()) : null;\n+                    if (comp != null) {\n+                        if (comp <= 0) {\n+                            if (comp == 0 && range.includeLower()) { // a != 2 AND 2 <= a < ? -> 2 < a < ?\n+                                ranges.set(i, new Range(range.source(), range.value(), range.lower(), false, range.upper(),\n+                                    range.includeUpper()));\n+                            }\n+                            // else: !.includeLower() : a != 2 AND 2 < a < 3 -> 2 < a < 3; or:\n+                            // else: comp < 0 : a != 2 AND 3 < a < ? ->  3 < a < ?\n+\n+                            return true;\n+                        } else { // comp > 0 : a != 4 AND 2 < a < ? : can only remove NotEquals if outside the range\n+                            comp = range.upper().foldable() ? BinaryComparison.compare(neqVal, range.upper().fold()) : null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b7fc42accf23af586c4bc780b3215db99619af2"}, "originalPosition": 196}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg0MzEwNg==", "bodyText": "I don't understand this simplification here. If the not-equality and a < or > act on the same variable (a in this case) why is a != 2 OR a < 3 resulting in a a != 2 condition?\nOne edge case is a = 2 and in this case it matches a < 3. The other edge case is anything >= 3 and in this case it matches the condition a != 2. The way I see it, a != 2 OR a < 3 is always TRUE.\nBUT, in Elasticsearch these two conditions being existent in a query (even if they can be simplified), they can contribute to the scoring of a document: an OR is translated into a bool query with two should statements. And, even if, the documents being returned are the same in a simplified (assuming the simplification returns always TRUE) and non-simplified way, if the user also asks for SCORE(), the actual results will be different in the two cases. I would take a step back and re-evaluate the OR simplification in general to make sure it doesn't affect the scoring of documents, in case SCORE() is returned.", "url": "https://github.com/elastic/elasticsearch/pull/51088#discussion_r368843106", "createdAt": "2020-01-21T07:23:55Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -1643,6 +1671,137 @@ else if ((other instanceof LessThan || other instanceof LessThanOrEqual) &&\n \n             return false;\n         }\n+\n+        private static boolean notEqualsIsRemovableFromConjunction(NotEquals notEquals, List<Range> ranges, List<BinaryComparison> bcs) {\n+            Object neqVal = notEquals.right().fold();\n+            Integer comp;\n+\n+            // check on \"condition-overlapping\" ranges:\n+            // a != 2 AND 3 < a < 5 -> 3 < a < 5; a != 2 AND 0 < a < 1 -> 0 < a < 1 (discard NotEquals)\n+            // a != 2 AND 2 <= a < 3 -> 2 < a < 3; a != 3 AND 2 < a <= 3 -> 2 < a < 3 (discard NotEquals, plus update Range)\n+            // a != 2 AND 1 < a < 3 -> nop (do nothing)\n+            for (int i = 0; i < ranges.size(); i ++) {\n+                Range range = ranges.get(i);\n+\n+                if (notEquals.left().semanticEquals(range.value())) {\n+                    comp = range.lower().foldable() ? BinaryComparison.compare(neqVal, range.lower().fold()) : null;\n+                    if (comp != null) {\n+                        if (comp <= 0) {\n+                            if (comp == 0 && range.includeLower()) { // a != 2 AND 2 <= a < ? -> 2 < a < ?\n+                                ranges.set(i, new Range(range.source(), range.value(), range.lower(), false, range.upper(),\n+                                    range.includeUpper()));\n+                            }\n+                            // else: !.includeLower() : a != 2 AND 2 < a < 3 -> 2 < a < 3; or:\n+                            // else: comp < 0 : a != 2 AND 3 < a < ? ->  3 < a < ?\n+\n+                            return true;\n+                        } else { // comp > 0 : a != 4 AND 2 < a < ? : can only remove NotEquals if outside the range\n+                            comp = range.upper().foldable() ? BinaryComparison.compare(neqVal, range.upper().fold()) : null;\n+                            if (comp != null && comp >= 0) {\n+                                if (comp == 0 && range.includeUpper()) { // a != 4 AND 2 < a <= 4 -> 2 < a < 4\n+                                    ranges.set(i, new Range(range.source(), range.value(), range.lower(), range.includeLower(),\n+                                        range.upper(), false));\n+                                }\n+                                // else: !.includeUpper() : a != 4 AND 2 < a < 4 -> 2 < a < 4\n+                                // else: comp > 0 : a != 4 AND 2 < a < 3 -> 2 < a < 3\n+\n+                                return true;\n+                            }\n+                            // else: comp < 0 : a != 4 AND 2 < a < 5 -> nop; or:\n+                            // else: comp == null : upper bound not comparable -> nop\n+                        }\n+                    } // else: comp == null : lower bound not comparable: evaluate upper bound, in case non-equality value is \">=\"\n+\n+                    comp = range.upper().foldable() ? BinaryComparison.compare(neqVal, range.upper().fold()) : null;\n+                    if (comp != null && comp >= 0) {\n+                        if (comp == 0 && range.includeUpper()) { // a != 3 AND ?? < a <= 3 -> ?? < a < 3\n+                            ranges.set(i, new Range(range.source(), range.value(), range.lower(), range.includeLower(), range.upper(),\n+                                false));\n+                        }\n+                        // else: !.includeUpper() : a != 3 AND ?? < a < 3 -> ?? < a < 3\n+                        // else: comp > 0 : a != 3 and ?? < a < 2 -> ?? < a < 2\n+\n+                        return true;\n+                    }\n+                    // else: comp < 0 : a != 3 AND ?? < a < 4 -> nop, as a decision can't be drawn; or:\n+                    // else: comp == null : a != 3 AND ?? < a < ?? -> nop\n+                }\n+            }\n+\n+            // check on \"condition-overlapping\" inequalities:\n+            // a != 2 AND a > 3 -> a > 3 (discard NotEquals)\n+            // a != 2 AND a >= 2 -> a > 2 (discard NotEquals plus update inequality)\n+            // a != 2 AND a > 1 -> nop (do nothing)\n+            //\n+            // a != 2 AND a < 3 -> nop\n+            // a != 2 AND a <= 2 -> a < 2\n+            // a != 2 AND a < 1 -> a < 1\n+            for (int i = 0; i < bcs.size(); i ++) {\n+                BinaryComparison bc = bcs.get(i);\n+\n+                if (bc instanceof LessThan || bc instanceof LessThanOrEqual) {\n+                    comp = bc.right().foldable() ? BinaryComparison.compare(neqVal, bc.right().fold()) : null;\n+                    if (comp != null) {\n+                        if (comp >= 0) {\n+                            if (comp == 0 && bc instanceof LessThanOrEqual) { // a != 2 AND a <= 2 -> a < 2\n+                                bcs.set(i, new LessThan(bc.source(), bc.left(), bc.right()));\n+                            } // else : comp > 0 (a != 2 AND a </<= 1 -> a </<= 1), or == 0 && bc i.of \"<\" (a != 2 AND a < 2 -> a < 2)\n+                            return true;\n+                        } // else: comp < 0 : a != 2 AND a </<= 3 -> nop\n+                    } // else: non-comparable, nop\n+                } else if (bc instanceof GreaterThan || bc instanceof GreaterThanOrEqual) {\n+                    comp = bc.right().foldable() ? BinaryComparison.compare(neqVal, bc.right().fold()) : null;\n+                    if (comp != null) {\n+                        if (comp <= 0) {\n+                            if (comp == 0 && bc instanceof GreaterThanOrEqual) { // a != 2 AND a >= 2 -> a > 2\n+                                bcs.set(i, new GreaterThan(bc.source(), bc.left(), bc.right()));\n+                            } // else: comp < 0 (a != 2 AND a >/>= 3 -> a >/>= 3), or == 0 && bc i.of \">\" (a != 2 AND a > 2 -> a > 2)\n+                            return true;\n+                        } // else: comp > 0 : a != 2 AND a >/>= 1 -> nop\n+                    } // else: non-comparable, nop\n+                } // else: other non-relevant type\n+            }\n+\n+            return false;\n+        }\n+\n+        // a != X OR Y < a < Z -> a != X (plus equivalent inequalities)\n+        // a != X OR X <= a < Z -> TRUE (plus equality on upper bound, plus equivalent inequalities)\n+        private static Boolean filterDisjunctionByNotEquals(List<NotEquals> notEquals, List<BinaryComparison> bcs, List<Range> ranges) {\n+            Boolean updated = false;\n+\n+            for (NotEquals neq : notEquals) {\n+                for (Iterator<BinaryComparison> bcIterator = bcs.iterator(); bcIterator.hasNext(); ) {\n+                    BinaryComparison bc = bcIterator.next();\n+                    if (neq.left().semanticEquals(bc.left())) {\n+                        if (bc instanceof LessThan || bc instanceof GreaterThan) { // a != 2 OR a < 3 -> a != 2 (plus LessThen)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b7fc42accf23af586c4bc780b3215db99619af2"}, "originalPosition": 274}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "29263289b76fa8651e3fed649e6172af6d86bf67", "author": {"user": {"login": "bpintea", "name": "Bogdan Pintea"}}, "url": "https://github.com/elastic/elasticsearch/commit/29263289b76fa8651e3fed649e6172af6d86bf67", "committedDate": "2020-01-23T20:46:15Z", "message": "remove optimisations of ORs influencing scoring\n\nRevert the optimisations of inequalities and ranges against not-equals,\nsince this can influence the scoring."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4bb889909ba5c9616ea68940a5de364bfddc3f9e", "author": {"user": {"login": "elasticmachine", "name": "Elastic Machine"}}, "url": "https://github.com/elastic/elasticsearch/commit/4bb889909ba5c9616ea68940a5de364bfddc3f9e", "committedDate": "2020-01-23T21:07:39Z", "message": "Merge branch 'master' into enh/not-equals-optimisations"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwMDUxNjM0", "url": "https://github.com/elastic/elasticsearch/pull/51088#pullrequestreview-350051634", "createdAt": "2020-01-29T11:56:30Z", "commit": {"oid": "4bb889909ba5c9616ea68940a5de364bfddc3f9e"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMTo1NjozMFrOFjF3iA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMTo1NjozMFrOFjF3iA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM0MDYxNg==", "bodyText": "Wouldn't here be more correct to also assert that the expression resulted from applying the rule is the same And as before? Meaning, is it enough to assume the type of the expression is And?", "url": "https://github.com/elastic/elasticsearch/pull/51088#discussion_r372340616", "createdAt": "2020-01-29T11:56:30Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/optimizer/OptimizerTests.java", "diffHunk": "@@ -1241,6 +1267,173 @@ public void testRangesOverlappingConjunctionNoLowerBoundary() {\n         assertEquals(r1, exp);\n     }\n \n+    // a != 2 AND 3 < a < 5 -> 3 < a < 5\n+    public void testCombineBinaryComparisonsConjunction_Neq2AndRangeGt3Lt5() {\n+        FieldAttribute fa = getFieldAttribute();\n+\n+        NotEquals neq = new NotEquals(EMPTY, fa, TWO);\n+        Range range = new Range(EMPTY, fa, THREE, false, FIVE, false);\n+        And and = new And(EMPTY, range, neq);\n+\n+        CombineBinaryComparisons rule = new CombineBinaryComparisons();\n+        Expression exp = rule.rule(and);\n+        assertEquals(Range.class, exp.getClass());\n+        Range r = (Range) exp;\n+        assertEquals(THREE, r.lower());\n+        assertFalse(r.includeLower());\n+        assertEquals(FIVE, r.upper());\n+        assertFalse(r.includeUpper());\n+    }\n+\n+    // a != 2 AND 0 < a < 1 -> 0 < a < 1\n+    public void testCombineBinaryComparisonsConjunction_Neq2AndRangeGt0Lt1() {\n+        FieldAttribute fa = getFieldAttribute();\n+\n+        NotEquals neq = new NotEquals(EMPTY, fa, TWO);\n+        Range range = new Range(EMPTY, fa, L(0), false, ONE, false);\n+        And and = new And(EMPTY, neq, range);\n+\n+        CombineBinaryComparisons rule = new CombineBinaryComparisons();\n+        Expression exp = rule.rule(and);\n+        assertEquals(Range.class, exp.getClass());\n+        Range r = (Range) exp;\n+        assertEquals(L(0), r.lower());\n+        assertFalse(r.includeLower());\n+        assertEquals(ONE, r.upper());\n+        assertFalse(r.includeUpper());\n+    }\n+\n+    // a != 2 AND 2 <= a < 3 -> 2 < a < 3\n+    public void testCombineBinaryComparisonsConjunction_Neq2AndRangeGte2Lt3() {\n+        FieldAttribute fa = getFieldAttribute();\n+\n+        NotEquals neq = new NotEquals(EMPTY, fa, TWO);\n+        Range range = new Range(EMPTY, fa, TWO, true, THREE, false);\n+        And and = new And(EMPTY, neq, range);\n+\n+        CombineBinaryComparisons rule = new CombineBinaryComparisons();\n+        Expression exp = rule.rule(and);\n+        assertEquals(Range.class, exp.getClass());\n+        Range r = (Range) exp;\n+        assertEquals(TWO, r.lower());\n+        assertFalse(r.includeLower());\n+        assertEquals(THREE, r.upper());\n+        assertFalse(r.includeUpper());\n+    }\n+\n+    // a != 3 AND 2 < a <= 3 -> 2 < a < 3\n+    public void testCombineBinaryComparisonsConjunction_Neq3AndRangeGt2Lte3() {\n+        FieldAttribute fa = getFieldAttribute();\n+\n+        NotEquals neq = new NotEquals(EMPTY, fa, THREE);\n+        Range range = new Range(EMPTY, fa, TWO, false, THREE, true);\n+        And and = new And(EMPTY, neq, range);\n+\n+        CombineBinaryComparisons rule = new CombineBinaryComparisons();\n+        Expression exp = rule.rule(and);\n+        assertEquals(Range.class, exp.getClass());\n+        Range r = (Range) exp;\n+        assertEquals(TWO, r.lower());\n+        assertFalse(r.includeLower());\n+        assertEquals(THREE, r.upper());\n+        assertFalse(r.includeUpper());\n+    }\n+\n+    // a != 2 AND 1 < a < 3\n+    public void testCombineBinaryComparisonsConjunction_Neq2AndRangeGt1Lt3() {\n+        FieldAttribute fa = getFieldAttribute();\n+\n+        NotEquals neq = new NotEquals(EMPTY, fa, TWO);\n+        Range range = new Range(EMPTY, fa, ONE, false, THREE, false);\n+        And and = new And(EMPTY, neq, range);\n+\n+        CombineBinaryComparisons rule = new CombineBinaryComparisons();\n+        Expression exp = rule.rule(and);\n+        assertEquals(And.class, exp.getClass()); // can't optimize\n+    }\n+\n+    // a != 2 AND a > 3 -> a > 3\n+    public void testCombineBinaryComparisonsConjunction_Neq2AndGt3() {\n+        FieldAttribute fa = getFieldAttribute();\n+\n+        NotEquals neq = new NotEquals(EMPTY, fa, TWO);\n+        GreaterThan gt = new GreaterThan(EMPTY, fa, THREE);\n+        And and = new And(EMPTY, neq, gt);\n+\n+        CombineBinaryComparisons rule = new CombineBinaryComparisons();\n+        Expression exp = rule.rule(and);\n+        assertEquals(gt, exp);\n+    }\n+\n+    // a != 2 AND a >= 2 -> a > 2\n+    public void testCombineBinaryComparisonsConjunction_Neq2AndGte2() {\n+        FieldAttribute fa = getFieldAttribute();\n+\n+        NotEquals neq = new NotEquals(EMPTY, fa, TWO);\n+        GreaterThanOrEqual gte = new GreaterThanOrEqual(EMPTY, fa, TWO);\n+        And and = new And(EMPTY, neq, gte);\n+\n+        CombineBinaryComparisons rule = new CombineBinaryComparisons();\n+        Expression exp = rule.rule(and);\n+        assertEquals(GreaterThan.class, exp.getClass());\n+        GreaterThan gt = (GreaterThan) exp;\n+        assertEquals(TWO, gt.right());\n+    }\n+\n+    // a != 2 AND a >= 1 -> nop\n+    public void testCombineBinaryComparisonsConjunction_Neq2AndGte1() {\n+        FieldAttribute fa = getFieldAttribute();\n+\n+        NotEquals neq = new NotEquals(EMPTY, fa, TWO);\n+        GreaterThanOrEqual gte = new GreaterThanOrEqual(EMPTY, fa, ONE);\n+        And and = new And(EMPTY, neq, gte);\n+\n+        CombineBinaryComparisons rule = new CombineBinaryComparisons();\n+        Expression exp = rule.rule(and);\n+        assertEquals(And.class, exp.getClass()); // can't optimize\n+    }\n+\n+    // a != 2 AND a <= 3 -> nop\n+    public void testCombineBinaryComparisonsConjunction_Neq2AndLte3() {\n+        FieldAttribute fa = getFieldAttribute();\n+\n+        NotEquals neq = new NotEquals(EMPTY, fa, TWO);\n+        LessThanOrEqual lte = new LessThanOrEqual(EMPTY, fa, THREE);\n+        And and = new And(EMPTY, neq, lte);\n+\n+        CombineBinaryComparisons rule = new CombineBinaryComparisons();\n+        Expression exp = rule.rule(and);\n+        assertEquals(And.class, exp.getClass()); // can't optimize", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4bb889909ba5c9616ea68940a5de364bfddc3f9e"}, "originalPosition": 173}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwNDUxNTk2", "url": "https://github.com/elastic/elasticsearch/pull/51088#pullrequestreview-350451596", "createdAt": "2020-01-29T21:54:13Z", "commit": {"oid": "4bb889909ba5c9616ea68940a5de364bfddc3f9e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d63e4f43dc851133f26068811efc88d05050850b", "author": {"user": {"login": "bpintea", "name": "Bogdan Pintea"}}, "url": "https://github.com/elastic/elasticsearch/commit/d63e4f43dc851133f26068811efc88d05050850b", "committedDate": "2020-01-30T17:26:35Z", "message": "address review comments\n\n- make one test assumption tighter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f83c98add9997c8ed1be8af77e356abfb346fba0", "author": {"user": {"login": "bpintea", "name": "Bogdan Pintea"}}, "url": "https://github.com/elastic/elasticsearch/commit/f83c98add9997c8ed1be8af77e356abfb346fba0", "committedDate": "2020-01-30T17:42:12Z", "message": "Merge remote-tracking branch 'upstream/master' into enh/not-equals-optimisations"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3141, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}