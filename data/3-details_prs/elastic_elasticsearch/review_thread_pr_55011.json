{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAxNDE3OTQx", "number": 55011, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNDo1MzoyNlrODxRH9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQwODozMToyNlrOD1qJcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyOTg3MzgxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNDo1MzoyNlrOGEpBeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxMzozMjo0MFrOGFOzUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUxOTYwOQ==", "bodyText": "Since this is not synchronized, I am not sure if private synchronized void reQueueThrottledSearch() or private synchronized void triggerThrottledSearchNow() actually work :/. The scheduledNextSearch could get set out from under those blocks. Unless we are ONLY worried about reQueueThrottledSearch and triggerThrottledSearchNow conflicting.", "url": "https://github.com/elastic/elasticsearch/pull/55011#discussion_r407519609", "createdAt": "2020-04-13T14:53:26Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexer.java", "diffHunk": "@@ -410,25 +473,43 @@ private void onSearchResponse(SearchResponse searchResponse) {\n     private void onBulkResponse(BulkResponse response, JobPosition position) {\n         stats.markEndIndexing();\n         try {\n-            ActionListener<SearchResponse> listener = ActionListener.wrap(this::onSearchResponse, this::finishWithSearchFailure);\n             // TODO probably something more intelligent than every-50 is needed\n             if (stats.getNumPages() > 0 && stats.getNumPages() % 50 == 0) {\n                 doSaveState(IndexerState.INDEXING, position, () -> {\n-                    nextSearch(listener);\n+                    nextSearch();\n                 });\n             } else {\n-                nextSearch(listener);\n+                nextSearch();\n             }\n         } catch (Exception e) {\n             finishWithIndexingFailure(e);\n         }\n     }\n \n-    private void nextSearch(ActionListener<SearchResponse> listener) {\n+    protected void nextSearch() {\n+        if (maximumRequestsPerSecond > 0 && lastDocCount > 0) {\n+            TimeValue executionDelay = calculateThrottlingDelay(maximumRequestsPerSecond, lastDocCount, lastSearchStartTimeNanos,\n+                    getTimeNanos());\n+\n+            if (executionDelay.duration() > 0) {\n+                logger.debug(\"throttling job [{}], wait for {} ({} {})\", getJobId(), executionDelay, maximumRequestsPerSecond,\n+                        lastDocCount);\n+                scheduledNextSearch = threadPool.schedule(() -> triggerNextSearch(), executionDelay, executorName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc0a4bc9ccb8cb58da69def30129226bf1e285c0"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODEzODU3Ng==", "bodyText": "good point. Synchronized for re-throttle and stop is required, because there could be parallel calls to it. nextSearch only runs in the indexer thread, so its never called more than once at the same time.\nThe purpose of triggerThrottledSearchNow is to avoid a long waiting time between calling stop and the actual stop. For this case the idea is to trigger the search immediately. However its still possible that stop is called but the search ends in the wait queue.\nI will revisit it. Maybe its better to cancel the search request instead of re-queuing, e.g. if stop is called, because of cluster trouble.", "url": "https://github.com/elastic/elasticsearch/pull/55011#discussion_r408138576", "createdAt": "2020-04-14T13:32:40Z", "author": {"login": "hendrikmuhs"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexer.java", "diffHunk": "@@ -410,25 +473,43 @@ private void onSearchResponse(SearchResponse searchResponse) {\n     private void onBulkResponse(BulkResponse response, JobPosition position) {\n         stats.markEndIndexing();\n         try {\n-            ActionListener<SearchResponse> listener = ActionListener.wrap(this::onSearchResponse, this::finishWithSearchFailure);\n             // TODO probably something more intelligent than every-50 is needed\n             if (stats.getNumPages() > 0 && stats.getNumPages() % 50 == 0) {\n                 doSaveState(IndexerState.INDEXING, position, () -> {\n-                    nextSearch(listener);\n+                    nextSearch();\n                 });\n             } else {\n-                nextSearch(listener);\n+                nextSearch();\n             }\n         } catch (Exception e) {\n             finishWithIndexingFailure(e);\n         }\n     }\n \n-    private void nextSearch(ActionListener<SearchResponse> listener) {\n+    protected void nextSearch() {\n+        if (maximumRequestsPerSecond > 0 && lastDocCount > 0) {\n+            TimeValue executionDelay = calculateThrottlingDelay(maximumRequestsPerSecond, lastDocCount, lastSearchStartTimeNanos,\n+                    getTimeNanos());\n+\n+            if (executionDelay.duration() > 0) {\n+                logger.debug(\"throttling job [{}], wait for {} ({} {})\", getJobId(), executionDelay, maximumRequestsPerSecond,\n+                        lastDocCount);\n+                scheduledNextSearch = threadPool.schedule(() -> triggerNextSearch(), executionDelay, executorName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUxOTYwOQ=="}, "originalCommit": {"oid": "dc0a4bc9ccb8cb58da69def30129226bf1e285c0"}, "originalPosition": 194}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MTc0Njg0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNToyNzozN1rOGJL7sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNToyNzozN1rOGJL7sg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI4NTg3NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Cancels a scheduled search request and issues the search request immediately\n          \n          \n            \n                 * Cancels a scheduled search request", "url": "https://github.com/elastic/elasticsearch/pull/55011#discussion_r412285874", "createdAt": "2020-04-21T15:27:37Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexer.java", "diffHunk": "@@ -178,6 +208,35 @@ public synchronized boolean maybeTriggerAsyncJob(long now) {\n         }\n     }\n \n+    /**\n+     * Cancels a scheduled search request and issues the search request immediately", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f922f21e48acf6a3b70b7ed88341aa31796ca91"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MjA5OTM5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNzoxMzoxN1rOGJPNVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNzoxMzoxN1rOGJPNVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMzOTU0Mg==", "bodyText": "From what I understand around cancel, the only times it will return false are:\n\nIf the action has already been completed\nIf the action has already been cancelled.\n\nThis means it will return true if the thread is executing.\nthreadPool.executor(executorName).execute(() -> checkState(getState()));\n\nCould happen in the middle of triggerNextSearch. This MIGHT be ok, but the call to checkState(getState()) might transition from STOPPING -> STOPPED while a search is still in flight. I am not sure this is intended behavior.", "url": "https://github.com/elastic/elasticsearch/pull/55011#discussion_r412339542", "createdAt": "2020-04-21T17:13:17Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexer.java", "diffHunk": "@@ -178,6 +208,35 @@ public synchronized boolean maybeTriggerAsyncJob(long now) {\n         }\n     }\n \n+    /**\n+     * Cancels a scheduled search request and issues the search request immediately\n+     */\n+    private synchronized void stopThrottledSearch() {\n+        if (scheduledNextSearch != null && scheduledNextSearch.cancel()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f922f21e48acf6a3b70b7ed88341aa31796ca91"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MjEwOTg5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNzoxNTozMVrOGJPTbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNzoxNTozMVrOGJPTbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM0MTEwMw==", "bodyText": "Similar comment to above, a current search could be inflight. This means that if the next delay is 0L, we could have two searches occurring in parallel.\nAs long as this method is NEVER called out of band, I think this might be ok.", "url": "https://github.com/elastic/elasticsearch/pull/55011#discussion_r412341103", "createdAt": "2020-04-21T17:15:31Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexer.java", "diffHunk": "@@ -461,4 +562,37 @@ private boolean checkState(IndexerState currentState) {\n         }\n     }\n \n+    private synchronized void reQueueThrottledSearch() {\n+        if (scheduledNextSearch != null && scheduledNextSearch.cancel()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f922f21e48acf6a3b70b7ed88341aa31796ca91"}, "originalPosition": 252}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MzUzNDkzOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxOTowODoyNlrOGK3yPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxOTowODoyNlrOGK3yPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA1MjkyNw==", "bodyText": "I realized its developer unfriendly to pass maximumRequestsPerSecond as parameter of the constructor.\nIt seems better to have getMaximumRequestsPerSecond() which can be overridden. I still need the rethrottle method, but without a parameter. To avoid that rethrottle kicks in although it hasn't changed, I would still cache the last value for comparison.", "url": "https://github.com/elastic/elasticsearch/pull/55011#discussion_r414052927", "createdAt": "2020-04-23T19:08:26Z", "author": {"login": "hendrikmuhs"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexer.java", "diffHunk": "@@ -38,18 +42,69 @@\n public abstract class AsyncTwoPhaseIndexer<JobPosition, JobStats extends IndexerJobStats> {\n     private static final Logger logger = LogManager.getLogger(AsyncTwoPhaseIndexer.class.getName());\n \n+    // max time to wait for throttling\n+    private static final TimeValue MAX_THROTTLE_WAIT_TIME =  TimeValue.timeValueHours(1);\n+    // min time to trigger delayed execution\n+    private static final TimeValue MIN_THROTTLE_WAIT_TIME =  TimeValue.timeValueMillis(10);\n+\n+    private final ActionListener<SearchResponse> searchResponseListener =\n+        ActionListener.wrap(this::onSearchResponse, this::finishWithSearchFailure);\n+\n     private final JobStats stats;\n \n     private final AtomicReference<IndexerState> state;\n     private final AtomicReference<JobPosition> position;\n-    private final Executor executor;\n+    private final ThreadPool threadPool;\n+    private final String executorName;\n+\n+    // throttling\n+    private volatile float maximumRequestsPerSecond;\n+    private volatile long lastSearchStartTimeNanos = 0;\n+    private volatile long lastDocCount = 0;\n+    private volatile ScheduledRunnable scheduledNextSearch;\n+\n+    class ScheduledRunnable {\n+        private final ThreadPool threadPool;\n+        private final String executorName;\n+        private final Runnable command;\n+        private Scheduler.ScheduledCancellable scheduled;\n+\n+        ScheduledRunnable(ThreadPool threadPool, String executorName, TimeValue delay, Runnable command) {\n+            this.threadPool = threadPool;\n+            this.executorName = executorName;\n+\n+            // with wrapping the command in RunOnce we ensure the command isn't executed twice, e.g. if the\n+            // future is already running and cancel returns true\n+            this.command = new RunOnce(command);\n+            this.scheduled = threadPool.schedule(() -> {command.run();}, delay, executorName);\n+        }\n+\n+        public void reschedule(TimeValue delay) {\n+            // note: cancel return true if the runnable is currently executing\n+            if (scheduled.cancel()) {\n+                if (delay.duration() > 0) {\n+                    scheduled = threadPool.schedule(() -> command.run(), delay, executorName);\n+                } else {\n+                    threadPool.executor(executorName).execute(() -> command.run());\n+                }\n+            }\n+        }\n \n-    protected AsyncTwoPhaseIndexer(Executor executor, AtomicReference<IndexerState> initialState,\n+    }\n+\n+    protected AsyncTwoPhaseIndexer(ThreadPool threadPool, String executorName, AtomicReference<IndexerState> initialState,\n                                    JobPosition initialPosition, JobStats jobStats) {\n-        this.executor = executor;\n+        this(threadPool, executorName, initialState, initialPosition, jobStats, -1);\n+    }\n+\n+    protected AsyncTwoPhaseIndexer(ThreadPool threadPool, String executorName, AtomicReference<IndexerState> initialState,\n+            JobPosition initialPosition, JobStats jobStats, float maximumRequestsPerSecond) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a247d15d98fa947e37d7391fb1dc3b1f6f49ad8"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3NTg4ODE1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexerTests.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQwODoyNDo0N1rOGLMYlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQwODoyNDo0N1rOGLMYlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM5MDQyMA==", "bodyText": "nit: these two arguments should be camelCase", "url": "https://github.com/elastic/elasticsearch/pull/55011#discussion_r414390420", "createdAt": "2020-04-24T08:24:47Z", "author": {"login": "droberts195"}, "path": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexerTests.java", "diffHunk": "@@ -382,22 +457,135 @@ public void testStop_WhileIndexing() throws Exception {\n             assertBusy(() -> assertTrue(isStopped.get()));\n             assertFalse(isFinished.get());\n         } finally {\n-            executor.shutdownNow();\n+            ThreadPool.terminate(threadPool, 30, TimeUnit.SECONDS);\n         }\n     }\n \n     public void testFiveRuns() throws Exception {\n+        doTestFiveRuns(-1, Collections.emptyList());\n+    }\n+\n+    public void testFiveRunsThrottled100() throws Exception {\n+        // expect throttling to kick in\n+        doTestFiveRuns(100, timeValueCollectionFromMilliseconds(9950L, 9950L, 9950L, 9950L));\n+    }\n+\n+    public void testFiveRunsThrottled1000() throws Exception {\n+        // expect throttling to kick in\n+        doTestFiveRuns(1_000, timeValueCollectionFromMilliseconds(950L, 950L, 950L, 950L));\n+    }\n+\n+    public void testFiveRunsThrottled18000() throws Exception {\n+        // expect throttling to not kick in due to min wait time\n+        doTestFiveRuns(18_000, Collections.emptyList());\n+    }\n+\n+    public void testFiveRunsThrottled1000000() throws Exception {\n+        // request per seconds is set high, so throttling does not kick in\n+        doTestFiveRuns(1_000_000, Collections.emptyList());\n+    }\n+\n+    public void doTestFiveRuns(float requests_per_second, Collection<TimeValue> expectedDelays) throws Exception {\n         AtomicReference<IndexerState> state = new AtomicReference<>(IndexerState.STOPPED);\n-        final ExecutorService executor = Executors.newFixedThreadPool(1);\n+        final MockThreadPool threadPool = new MockThreadPool(getTestName());\n         try {\n-            MockIndexerFiveRuns indexer = new MockIndexerFiveRuns (executor, state, 2);\n+            MockIndexerFiveRuns indexer = new MockIndexerFiveRuns (threadPool, ThreadPool.Names.GENERIC, state, 2, requests_per_second,\n+                null);\n             indexer.start();\n             assertThat(indexer.getState(), equalTo(IndexerState.STARTED));\n             assertTrue(indexer.maybeTriggerAsyncJob(System.currentTimeMillis()));\n             assertBusy(() -> assertTrue(isFinished.get()));\n             indexer.assertCounters();\n+            threadPool.assertCountersAndDelay(expectedDelays);\n         } finally {\n-            executor.shutdownNow();\n+            ThreadPool.terminate(threadPool, 30, TimeUnit.SECONDS);\n         }\n     }\n+\n+    public void testFiveRunsRethrottle0_100() throws Exception {\n+        doTestFiveRunsRethrottle(-1, 100, timeValueCollectionFromMilliseconds(9950L));\n+    }\n+\n+    public void testFiveRunsRethrottle100_0() throws Exception {\n+        doTestFiveRunsRethrottle(100, 0, timeValueCollectionFromMilliseconds(9950L, 9950L, 9950L));\n+    }\n+\n+    public void testFiveRunsRethrottle100_1000() throws Exception {\n+        doTestFiveRunsRethrottle(100, 1000, timeValueCollectionFromMilliseconds(9950L, 9950L, 9950L, 950L));\n+    }\n+\n+    public void testFiveRunsRethrottle1000_100() throws Exception {\n+        doTestFiveRunsRethrottle(1000, 100, timeValueCollectionFromMilliseconds(950L, 950L, 950L, 9950L));\n+    }\n+\n+    public void doTestFiveRunsRethrottle(\n+        float requests_per_second,\n+        float requests_per_second_rethrottle,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0942bce8274f080ee0fb1c50ca3314ee646be7a"}, "originalPosition": 334}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3NTg5NDM4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexerTests.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQwODoyNjoxM1rOGLMcOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQwODoyNjoxM1rOGLMcOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM5MTM1NA==", "bodyText": "This comment initially confused me.  It might be clear to say:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        // wait until the indexer reached latch await\n          \n          \n            \n                        // wait until the indexer starts waiting on the latch", "url": "https://github.com/elastic/elasticsearch/pull/55011#discussion_r414391354", "createdAt": "2020-04-24T08:26:13Z", "author": {"login": "droberts195"}, "path": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexerTests.java", "diffHunk": "@@ -382,22 +457,135 @@ public void testStop_WhileIndexing() throws Exception {\n             assertBusy(() -> assertTrue(isStopped.get()));\n             assertFalse(isFinished.get());\n         } finally {\n-            executor.shutdownNow();\n+            ThreadPool.terminate(threadPool, 30, TimeUnit.SECONDS);\n         }\n     }\n \n     public void testFiveRuns() throws Exception {\n+        doTestFiveRuns(-1, Collections.emptyList());\n+    }\n+\n+    public void testFiveRunsThrottled100() throws Exception {\n+        // expect throttling to kick in\n+        doTestFiveRuns(100, timeValueCollectionFromMilliseconds(9950L, 9950L, 9950L, 9950L));\n+    }\n+\n+    public void testFiveRunsThrottled1000() throws Exception {\n+        // expect throttling to kick in\n+        doTestFiveRuns(1_000, timeValueCollectionFromMilliseconds(950L, 950L, 950L, 950L));\n+    }\n+\n+    public void testFiveRunsThrottled18000() throws Exception {\n+        // expect throttling to not kick in due to min wait time\n+        doTestFiveRuns(18_000, Collections.emptyList());\n+    }\n+\n+    public void testFiveRunsThrottled1000000() throws Exception {\n+        // request per seconds is set high, so throttling does not kick in\n+        doTestFiveRuns(1_000_000, Collections.emptyList());\n+    }\n+\n+    public void doTestFiveRuns(float requests_per_second, Collection<TimeValue> expectedDelays) throws Exception {\n         AtomicReference<IndexerState> state = new AtomicReference<>(IndexerState.STOPPED);\n-        final ExecutorService executor = Executors.newFixedThreadPool(1);\n+        final MockThreadPool threadPool = new MockThreadPool(getTestName());\n         try {\n-            MockIndexerFiveRuns indexer = new MockIndexerFiveRuns (executor, state, 2);\n+            MockIndexerFiveRuns indexer = new MockIndexerFiveRuns (threadPool, ThreadPool.Names.GENERIC, state, 2, requests_per_second,\n+                null);\n             indexer.start();\n             assertThat(indexer.getState(), equalTo(IndexerState.STARTED));\n             assertTrue(indexer.maybeTriggerAsyncJob(System.currentTimeMillis()));\n             assertBusy(() -> assertTrue(isFinished.get()));\n             indexer.assertCounters();\n+            threadPool.assertCountersAndDelay(expectedDelays);\n         } finally {\n-            executor.shutdownNow();\n+            ThreadPool.terminate(threadPool, 30, TimeUnit.SECONDS);\n         }\n     }\n+\n+    public void testFiveRunsRethrottle0_100() throws Exception {\n+        doTestFiveRunsRethrottle(-1, 100, timeValueCollectionFromMilliseconds(9950L));\n+    }\n+\n+    public void testFiveRunsRethrottle100_0() throws Exception {\n+        doTestFiveRunsRethrottle(100, 0, timeValueCollectionFromMilliseconds(9950L, 9950L, 9950L));\n+    }\n+\n+    public void testFiveRunsRethrottle100_1000() throws Exception {\n+        doTestFiveRunsRethrottle(100, 1000, timeValueCollectionFromMilliseconds(9950L, 9950L, 9950L, 950L));\n+    }\n+\n+    public void testFiveRunsRethrottle1000_100() throws Exception {\n+        doTestFiveRunsRethrottle(1000, 100, timeValueCollectionFromMilliseconds(950L, 950L, 950L, 9950L));\n+    }\n+\n+    public void doTestFiveRunsRethrottle(\n+        float requests_per_second,\n+        float requests_per_second_rethrottle,\n+        Collection<TimeValue> expectedDelays\n+    ) throws Exception {\n+        AtomicReference<IndexerState> state = new AtomicReference<>(IndexerState.STOPPED);\n+\n+        final MockThreadPool threadPool = new MockThreadPool(getTestName());\n+        try {\n+            CountDownLatch latch = new CountDownLatch(1);\n+            MockIndexerFiveRuns indexer = new MockIndexerFiveRuns (threadPool, ThreadPool.Names.GENERIC, state, 2, requests_per_second,\n+                latch);\n+            indexer.start();\n+            assertThat(indexer.getState(), equalTo(IndexerState.STARTED));\n+            assertTrue(indexer.maybeTriggerAsyncJob(System.currentTimeMillis()));\n+            // wait until the indexer reached latch await", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0942bce8274f080ee0fb1c50ca3314ee646be7a"}, "originalPosition": 347}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3NTkxNjY0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexer.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQwODozMToyNlrOGLMpPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQwOToyMjoxMVrOGLOr1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM5NDY4Ng==", "bodyText": "This formula implies that requestsPerSecond is really desiredDocsPerSecond.  If that's correct then requestsPerSecond seems like it will cause confusion in the future because I would assume requestsPerSecond referred to the number of searches, each of which could return many documents.\nFor example, if I saw a configuration parameter requests_per_second I might decide to set it to 2 so that I'd get a maximum of 2 search requests per second from this functionality.  But then if one of my searches returns 1000 documents then I get a 500 second wait until the next search.", "url": "https://github.com/elastic/elasticsearch/pull/55011#discussion_r414394686", "createdAt": "2020-04-24T08:31:26Z", "author": {"login": "droberts195"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexer.java", "diffHunk": "@@ -461,4 +608,43 @@ private boolean checkState(IndexerState currentState) {\n         }\n     }\n \n+    private synchronized void reQueueThrottledSearch() {\n+        currentMaximumRequestsPerSecond = getMaximumRequestsPerSecond();\n+\n+        if (scheduledNextSearch != null) {\n+            TimeValue executionDelay = calculateThrottlingDelay(\n+                currentMaximumRequestsPerSecond,\n+                lastDocCount,\n+                lastSearchStartTimeNanos,\n+                getTimeNanos()\n+            );\n+\n+            logger.debug(\n+                \"rethrottling job [{}], wait for {} ({} {})\",\n+                getJobId(),\n+                executionDelay,\n+                currentMaximumRequestsPerSecond,\n+                lastDocCount\n+            );\n+            scheduledNextSearch.reschedule(executionDelay);\n+        }\n+    }\n+\n+    static TimeValue calculateThrottlingDelay(float requestsPerSecond, long docCount, long startTimeNanos, long now) {\n+        if (requestsPerSecond <= 0) {\n+            return TimeValue.ZERO;\n+        }\n+        float timeToWaitNanos = (docCount / requestsPerSecond) * TimeUnit.SECONDS.toNanos(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0942bce8274f080ee0fb1c50ca3314ee646be7a"}, "originalPosition": 321}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQxMjQ3OA==", "bodyText": "I saw a couple of nits but I stopped reviewing when I saw the throttling formula because it seems to highlight a fundamental issue: are we intending to throttle based on search requests per second or documents retrieved per second? What changes are required will depend on the answer to that.\n\nThis design and the reasons for that are discussed in the tracking issue: #54862. In a nutshell: You are right that requests_per_second is misleading. The name has still been chosen, because its a existing concept from reindex. It's wrong there, too.", "url": "https://github.com/elastic/elasticsearch/pull/55011#discussion_r414412478", "createdAt": "2020-04-24T08:58:21Z", "author": {"login": "hendrikmuhs"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexer.java", "diffHunk": "@@ -461,4 +608,43 @@ private boolean checkState(IndexerState currentState) {\n         }\n     }\n \n+    private synchronized void reQueueThrottledSearch() {\n+        currentMaximumRequestsPerSecond = getMaximumRequestsPerSecond();\n+\n+        if (scheduledNextSearch != null) {\n+            TimeValue executionDelay = calculateThrottlingDelay(\n+                currentMaximumRequestsPerSecond,\n+                lastDocCount,\n+                lastSearchStartTimeNanos,\n+                getTimeNanos()\n+            );\n+\n+            logger.debug(\n+                \"rethrottling job [{}], wait for {} ({} {})\",\n+                getJobId(),\n+                executionDelay,\n+                currentMaximumRequestsPerSecond,\n+                lastDocCount\n+            );\n+            scheduledNextSearch.reschedule(executionDelay);\n+        }\n+    }\n+\n+    static TimeValue calculateThrottlingDelay(float requestsPerSecond, long docCount, long startTimeNanos, long now) {\n+        if (requestsPerSecond <= 0) {\n+            return TimeValue.ZERO;\n+        }\n+        float timeToWaitNanos = (docCount / requestsPerSecond) * TimeUnit.SECONDS.toNanos(1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM5NDY4Ng=="}, "originalCommit": {"oid": "d0942bce8274f080ee0fb1c50ca3314ee646be7a"}, "originalPosition": 321}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQyODExOQ==", "bodyText": "Ah yes, I missed that requests_per_second is used in this way for reindex already.  In that case consistency with reindex is more important.", "url": "https://github.com/elastic/elasticsearch/pull/55011#discussion_r414428119", "createdAt": "2020-04-24T09:22:11Z", "author": {"login": "droberts195"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexer.java", "diffHunk": "@@ -461,4 +608,43 @@ private boolean checkState(IndexerState currentState) {\n         }\n     }\n \n+    private synchronized void reQueueThrottledSearch() {\n+        currentMaximumRequestsPerSecond = getMaximumRequestsPerSecond();\n+\n+        if (scheduledNextSearch != null) {\n+            TimeValue executionDelay = calculateThrottlingDelay(\n+                currentMaximumRequestsPerSecond,\n+                lastDocCount,\n+                lastSearchStartTimeNanos,\n+                getTimeNanos()\n+            );\n+\n+            logger.debug(\n+                \"rethrottling job [{}], wait for {} ({} {})\",\n+                getJobId(),\n+                executionDelay,\n+                currentMaximumRequestsPerSecond,\n+                lastDocCount\n+            );\n+            scheduledNextSearch.reschedule(executionDelay);\n+        }\n+    }\n+\n+    static TimeValue calculateThrottlingDelay(float requestsPerSecond, long docCount, long startTimeNanos, long now) {\n+        if (requestsPerSecond <= 0) {\n+            return TimeValue.ZERO;\n+        }\n+        float timeToWaitNanos = (docCount / requestsPerSecond) * TimeUnit.SECONDS.toNanos(1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM5NDY4Ng=="}, "originalCommit": {"oid": "d0942bce8274f080ee0fb1c50ca3314ee646be7a"}, "originalPosition": 321}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1215, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}