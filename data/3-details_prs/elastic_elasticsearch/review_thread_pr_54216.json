{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkzNzQxNDE4", "number": 54216, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNjozNDozM1rODwEpNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNjozNDozM1rODwEpNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNzM0MzI2OnYy", "diffSide": "RIGHT", "path": "docs/reference/eql/functions.asciidoc", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNjozNDozM1rOGC3cOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQwODoxOToxMFrOGLMLDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY1ODY4Mw==", "bodyText": "@aleksmaus When I tested this using the EQL search API, it didn't return results as expected. I included duplication steps below in case I made an error somewhere.\nCreate an index mapping to ensure source.address is an IP field.\nPUT /my_index\n{\n  \"mappings\": {\n    \"properties\": {\n      \"source\": {\n        \"properties\": {\n          \"address\": {\n            \"type\": \"ip\"\n          }\n        }\n      }\n    }\n  }\n}\n\nIndex \"192.168.152.12\" as a source.address value.\nPUT /my_index/_doc/1\n{\n  \"@timestamp\": \"2020-12-06T11:04:05.000Z\",\n  \"event\": {\n    \"category\": \"process\"\n  },\n  \"source\": {\n    \"address\": \"192.168.152.12\"\n  }\n}\n\nUse cidrMatch to search for \"192.168.152.12\" in the \"192.168.0.0/16\" CIDR block. This should be true and return _doc 1 as a result.\n{\nGET /my_index/_eql/search\n  \"query\": \"process where cidrMatch(source.address, \\\"192.168.0.0/16\\\") == true \"\n}\n\nInstead, I get no results.\n{\n  \"took\" : 2,\n  \"timed_out\" : false,\n  \"hits\" : {\n    \"total\" : {\n      \"value\" : 0,\n      \"relation\" : \"eq\"\n    },\n    \"events\" : [ ]\n  }\n}\n\nIf I change true to false, the _doc is returned.\n{\nGET /my_index/_eql/search\n  \"query\": \"process where cidrMatch(source.address, \\\"192.168.0.0/16\\\") == false \"\n}\n\nResults:\n{\n  \"took\" : 2,\n  \"timed_out\" : false,\n  \"hits\" : {\n    \"total\" : {\n      \"value\" : 1,\n      \"relation\" : \"eq\"\n    },\n    \"events\" : [\n      {\n        \"_index\" : \"my_index\",\n        \"_id\" : \"1\",\n        \"_score\" : null,\n        \"_source\" : {\n          \"@timestamp\" : \"2020-12-06T11:04:05.000Z\",\n          \"event\" : {\n            \"category\" : \"process\"\n          },\n          \"source\" : {\n            \"address\" : \"192.168.152.12\"\n          }\n        },\n        \"sort\" : [\n          1607252645000\n        ]\n      }\n    ]\n  }\n}", "url": "https://github.com/elastic/elasticsearch/pull/54216#discussion_r405658683", "createdAt": "2020-04-08T16:34:33Z", "author": {"login": "jrodewig"}, "path": "docs/reference/eql/functions.asciidoc", "diffHunk": "@@ -8,11 +8,60 @@ experimental::[]\n \n {es} supports the following EQL functions:\n \n+* <<eql-fn-cidrmatch>>\n * <<eql-fn-endswith>>\n * <<eql-fn-length>>\n * <<eql-fn-startswith>>\n * <<eql-fn-substring>>\n \n+[discrete]\n+[[eql-fn-cidrmatch]]\n+==== `cidrMatch`\n+\n+Returns `true` if an IP address is contained in one or more provided\n+https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing[CIDR] blocks.\n+\n+[%collapsible]\n+====\n+*Example*\n+\n+[source,eql]\n+----\n+// source.address = \"192.168.152.12\"\n+cidrMatch(source.address, \"192.168.0.0/16\")               // returns true\n+cidrMatch(source.address, \"192.168.0.0/16\", \"10.0.0.0/8\") // returns true\n+cidrMatch(source.address, \"10.0.0.0/8\")                   // returns false\n+cidrMatch(source.address, \"10.0.0.0/8\", \"10.128.0.0/9\")   // returns false", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5629888134baa800c99dbdc7585b5d6f63622765"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM4Njk1OA==", "bodyText": "I created #55709 to track this bug.", "url": "https://github.com/elastic/elasticsearch/pull/54216#discussion_r414386958", "createdAt": "2020-04-24T08:19:10Z", "author": {"login": "astefan"}, "path": "docs/reference/eql/functions.asciidoc", "diffHunk": "@@ -8,11 +8,60 @@ experimental::[]\n \n {es} supports the following EQL functions:\n \n+* <<eql-fn-cidrmatch>>\n * <<eql-fn-endswith>>\n * <<eql-fn-length>>\n * <<eql-fn-startswith>>\n * <<eql-fn-substring>>\n \n+[discrete]\n+[[eql-fn-cidrmatch]]\n+==== `cidrMatch`\n+\n+Returns `true` if an IP address is contained in one or more provided\n+https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing[CIDR] blocks.\n+\n+[%collapsible]\n+====\n+*Example*\n+\n+[source,eql]\n+----\n+// source.address = \"192.168.152.12\"\n+cidrMatch(source.address, \"192.168.0.0/16\")               // returns true\n+cidrMatch(source.address, \"192.168.0.0/16\", \"10.0.0.0/8\") // returns true\n+cidrMatch(source.address, \"10.0.0.0/8\")                   // returns false\n+cidrMatch(source.address, \"10.0.0.0/8\", \"10.128.0.0/9\")   // returns false", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY1ODY4Mw=="}, "originalCommit": {"oid": "5629888134baa800c99dbdc7585b5d6f63622765"}, "originalPosition": 27}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4106, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}