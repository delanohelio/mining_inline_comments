{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkzMDY0MjMx", "number": 54103, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwMToxNDowN1rODtwtcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwOTowMzowN1rODyaHtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MzEwNTc4OnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/elasticsearch/rest/RestControllerTests.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwMToxNDowN1rOF_YDOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMjoyMzoxNVrOF_oqCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk5ODY0OQ==", "bodyText": "don't think you need the randomFrom", "url": "https://github.com/elastic/elasticsearch/pull/54103#discussion_r401998649", "createdAt": "2020-04-02T01:14:07Z", "author": {"login": "jakelandis"}, "path": "server/src/test/java/org/elasticsearch/rest/RestControllerTests.java", "diffHunk": "@@ -640,6 +641,41 @@ public boolean compatibilityRequired() {\n         assertTrue(channel.getSendResponseCalled());\n     }\n \n+    public void testIncorrectCompatibleHandlersDoNotDispatch() {\n+        final byte version = (byte) (Version.CURRENT.major - 1);\n+\n+        final String mimeType = randomFrom(\"application/vnd.elasticsearch+json;compatible-with=\"+version);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7d9b2906d23dbe5971f3a56ac95757411ad7beb"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI3MDczMQ==", "bodyText": "refactored this to actually use a random subtype (yml, cbor, etc)", "url": "https://github.com/elastic/elasticsearch/pull/54103#discussion_r402270731", "createdAt": "2020-04-02T12:23:15Z", "author": {"login": "pgomulka"}, "path": "server/src/test/java/org/elasticsearch/rest/RestControllerTests.java", "diffHunk": "@@ -640,6 +641,41 @@ public boolean compatibilityRequired() {\n         assertTrue(channel.getSendResponseCalled());\n     }\n \n+    public void testIncorrectCompatibleHandlersDoNotDispatch() {\n+        final byte version = (byte) (Version.CURRENT.major - 1);\n+\n+        final String mimeType = randomFrom(\"application/vnd.elasticsearch+json;compatible-with=\"+version);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk5ODY0OQ=="}, "originalCommit": {"oid": "e7d9b2906d23dbe5971f3a56ac95757411ad7beb"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MzEwNzEyOnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/elasticsearch/rest/RestControllerTests.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwMToxNTowMVrOF_YEDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwMToxNTowMVrOF_YEDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk5ODg2MA==", "bodyText": "nit: git :)  (I do that all the time!)", "url": "https://github.com/elastic/elasticsearch/pull/54103#discussion_r401998860", "createdAt": "2020-04-02T01:15:01Z", "author": {"login": "jakelandis"}, "path": "server/src/test/java/org/elasticsearch/rest/RestControllerTests.java", "diffHunk": "@@ -640,6 +641,41 @@ public boolean compatibilityRequired() {\n         assertTrue(channel.getSendResponseCalled());\n     }\n \n+    public void testIncorrectCompatibleHandlersDoNotDispatch() {\n+        final byte version = (byte) (Version.CURRENT.major - 1);\n+\n+        final String mimeType = randomFrom(\"application/vnd.elasticsearch+json;compatible-with=\"+version);\n+        String content = randomAlphaOfLength((int) Math.round(BREAKER_LIMIT.getBytes() / inFlightRequestsBreaker.getOverhead()));\n+        final List<String> contentTypeHeader = Collections.singletonList(mimeType);\n+\n+        // request to compatible api with body requires a content-type header.\n+        // this one does no have it, making it non compatiblegit", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7d9b2906d23dbe5971f3a56ac95757411ad7beb"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MzExNjQzOnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/elasticsearch/rest/RestControllerTests.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwMToyMDozMVrOF_YJUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxODowODo1MFrOF_3c6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjAwMDIxMQ==", "bodyText": "doesn't this request have content-type and accept header and a body ? (the body is withContent right?)\nSo with a body, matching accept and content-type headers , shouldn't this be an example of a good request ?", "url": "https://github.com/elastic/elasticsearch/pull/54103#discussion_r402000211", "createdAt": "2020-04-02T01:20:31Z", "author": {"login": "jakelandis"}, "path": "server/src/test/java/org/elasticsearch/rest/RestControllerTests.java", "diffHunk": "@@ -640,6 +641,41 @@ public boolean compatibilityRequired() {\n         assertTrue(channel.getSendResponseCalled());\n     }\n \n+    public void testIncorrectCompatibleHandlersDoNotDispatch() {\n+        final byte version = (byte) (Version.CURRENT.major - 1);\n+\n+        final String mimeType = randomFrom(\"application/vnd.elasticsearch+json;compatible-with=\"+version);\n+        String content = randomAlphaOfLength((int) Math.round(BREAKER_LIMIT.getBytes() / inFlightRequestsBreaker.getOverhead()));\n+        final List<String> contentTypeHeader = Collections.singletonList(mimeType);\n+\n+        // request to compatible api with body requires a content-type header.\n+        // this one does no have it, making it non compatiblegit\n+        FakeRestRequest fakeRestRequest = new FakeRestRequest.Builder(NamedXContentRegistry.EMPTY)\n+            .withContent(new BytesArray(content), RestRequest.parseContentType(contentTypeHeader)).withPath(\"/foo\")\n+            .withHeaders(Map.of(\"Accept\", contentTypeHeader))\n+            .build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7d9b2906d23dbe5971f3a56ac95757411ad7beb"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI4MzE4Nw==", "bodyText": "good point, contentTypeHeader misleadingly named,\nwithContentalso setsContent-Type` behind the scenes, but it is the overriden by a withHeaders method that only has Accept header\nwill rename this to\n            .withHeaders(Map.of(\"Accept\", mimeTypeList))", "url": "https://github.com/elastic/elasticsearch/pull/54103#discussion_r402283187", "createdAt": "2020-04-02T12:44:01Z", "author": {"login": "pgomulka"}, "path": "server/src/test/java/org/elasticsearch/rest/RestControllerTests.java", "diffHunk": "@@ -640,6 +641,41 @@ public boolean compatibilityRequired() {\n         assertTrue(channel.getSendResponseCalled());\n     }\n \n+    public void testIncorrectCompatibleHandlersDoNotDispatch() {\n+        final byte version = (byte) (Version.CURRENT.major - 1);\n+\n+        final String mimeType = randomFrom(\"application/vnd.elasticsearch+json;compatible-with=\"+version);\n+        String content = randomAlphaOfLength((int) Math.round(BREAKER_LIMIT.getBytes() / inFlightRequestsBreaker.getOverhead()));\n+        final List<String> contentTypeHeader = Collections.singletonList(mimeType);\n+\n+        // request to compatible api with body requires a content-type header.\n+        // this one does no have it, making it non compatiblegit\n+        FakeRestRequest fakeRestRequest = new FakeRestRequest.Builder(NamedXContentRegistry.EMPTY)\n+            .withContent(new BytesArray(content), RestRequest.parseContentType(contentTypeHeader)).withPath(\"/foo\")\n+            .withHeaders(Map.of(\"Accept\", contentTypeHeader))\n+            .build();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjAwMDIxMQ=="}, "originalCommit": {"oid": "e7d9b2906d23dbe5971f3a56ac95757411ad7beb"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUxMzEzMQ==", "bodyText": "thanks, I missed that.", "url": "https://github.com/elastic/elasticsearch/pull/54103#discussion_r402513131", "createdAt": "2020-04-02T18:08:50Z", "author": {"login": "jakelandis"}, "path": "server/src/test/java/org/elasticsearch/rest/RestControllerTests.java", "diffHunk": "@@ -640,6 +641,41 @@ public boolean compatibilityRequired() {\n         assertTrue(channel.getSendResponseCalled());\n     }\n \n+    public void testIncorrectCompatibleHandlersDoNotDispatch() {\n+        final byte version = (byte) (Version.CURRENT.major - 1);\n+\n+        final String mimeType = randomFrom(\"application/vnd.elasticsearch+json;compatible-with=\"+version);\n+        String content = randomAlphaOfLength((int) Math.round(BREAKER_LIMIT.getBytes() / inFlightRequestsBreaker.getOverhead()));\n+        final List<String> contentTypeHeader = Collections.singletonList(mimeType);\n+\n+        // request to compatible api with body requires a content-type header.\n+        // this one does no have it, making it non compatiblegit\n+        FakeRestRequest fakeRestRequest = new FakeRestRequest.Builder(NamedXContentRegistry.EMPTY)\n+            .withContent(new BytesArray(content), RestRequest.parseContentType(contentTypeHeader)).withPath(\"/foo\")\n+            .withHeaders(Map.of(\"Accept\", contentTypeHeader))\n+            .build();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjAwMDIxMQ=="}, "originalCommit": {"oid": "e7d9b2906d23dbe5971f3a56ac95757411ad7beb"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMDIxMTM4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/Version.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNjozMDo1MFrOGEsPhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwODoxNjo0NVrOGGZ0mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU3MjM1OQ==", "bodyText": "This is a bit ambiguous, and probably not a necessary as a static constant.\nCan we add in a method like minimumRestCompatibilityVersion ?", "url": "https://github.com/elastic/elasticsearch/pull/54103#discussion_r407572359", "createdAt": "2020-04-13T16:30:50Z", "author": {"login": "jakelandis"}, "path": "server/src/main/java/org/elasticsearch/Version.java", "diffHunk": "@@ -80,6 +80,7 @@\n     public static final Version V_7_8_0 = new Version(7080099, org.apache.lucene.util.Version.LUCENE_8_5_0);\n     public static final Version V_8_0_0 = new Version(8000099, org.apache.lucene.util.Version.LUCENE_8_5_0);\n     public static final Version CURRENT = V_8_0_0;\n+    public static final Version PREVIOUS = V_7_0_0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bcb11fddf07df33c24fb05b4d3dc9e47aaa9c5b6"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA3NjgwNA==", "bodyText": "In doing so, can you please make the method static? It should only apply to the CURRENT version. The fact the other compatibility methods are on Version instances makes testing and modifying the rules difficult, even though in practice the CURRENT version's compatibility is all we need, and the others are just artificial for testing.", "url": "https://github.com/elastic/elasticsearch/pull/54103#discussion_r409076804", "createdAt": "2020-04-15T19:18:27Z", "author": {"login": "rjernst"}, "path": "server/src/main/java/org/elasticsearch/Version.java", "diffHunk": "@@ -80,6 +80,7 @@\n     public static final Version V_7_8_0 = new Version(7080099, org.apache.lucene.util.Version.LUCENE_8_5_0);\n     public static final Version V_8_0_0 = new Version(8000099, org.apache.lucene.util.Version.LUCENE_8_5_0);\n     public static final Version CURRENT = V_8_0_0;\n+    public static final Version PREVIOUS = V_7_0_0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU3MjM1OQ=="}, "originalCommit": {"oid": "bcb11fddf07df33c24fb05b4d3dc9e47aaa9c5b6"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM2NzcwNg==", "bodyText": "agree, the method should be static", "url": "https://github.com/elastic/elasticsearch/pull/54103#discussion_r409367706", "createdAt": "2020-04-16T08:16:45Z", "author": {"login": "pgomulka"}, "path": "server/src/main/java/org/elasticsearch/Version.java", "diffHunk": "@@ -80,6 +80,7 @@\n     public static final Version V_7_8_0 = new Version(7080099, org.apache.lucene.util.Version.LUCENE_8_5_0);\n     public static final Version V_8_0_0 = new Version(8000099, org.apache.lucene.util.Version.LUCENE_8_5_0);\n     public static final Version CURRENT = V_8_0_0;\n+    public static final Version PREVIOUS = V_7_0_0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU3MjM1OQ=="}, "originalCommit": {"oid": "bcb11fddf07df33c24fb05b4d3dc9e47aaa9c5b6"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMDYyMjQ5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/http/AbstractHttpServerTransport.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxODozMDo0NVrOGEwRmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxMToxNzo0MFrOGFJ63w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYzODQyNg==", "bodyText": "can you clean up the this todo abit ? Not sure I follow.", "url": "https://github.com/elastic/elasticsearch/pull/54103#discussion_r407638426", "createdAt": "2020-04-13T18:30:45Z", "author": {"login": "jakelandis"}, "path": "server/src/main/java/org/elasticsearch/http/AbstractHttpServerTransport.java", "diffHunk": "@@ -352,6 +352,11 @@ private void handleIncomingRequest(final HttpRequest httpRequest, final HttpChan\n             } catch (final RestRequest.BadParameterException e) {\n                 badRequestCause = ExceptionsHelper.useOrSuppress(badRequestCause, e);\n                 innerRestRequest = RestRequest.requestWithoutParameters(xContentRegistry, httpRequest, httpChannel);\n+            } catch (final RestRequest.CompatibleApiHeadersCombinationException e){\n+                badRequestCause = ExceptionsHelper.useOrSuppress(badRequestCause, e);\n+                //todo // tempting to just rethrow. removing content type is just making this less obvious\n+                throw e;\n+//                innerRestRequest = requestWithoutContentTypeHeader(httpRequest, httpChannel, badRequestCause);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bcb11fddf07df33c24fb05b4d3dc9e47aaa9c5b6"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA1ODU5MQ==", "bodyText": "just throwing an exception was helping checking the logs, but indeed was breaking the channel creation and there was no response sent back..\nwill fix", "url": "https://github.com/elastic/elasticsearch/pull/54103#discussion_r408058591", "createdAt": "2020-04-14T11:17:40Z", "author": {"login": "pgomulka"}, "path": "server/src/main/java/org/elasticsearch/http/AbstractHttpServerTransport.java", "diffHunk": "@@ -352,6 +352,11 @@ private void handleIncomingRequest(final HttpRequest httpRequest, final HttpChan\n             } catch (final RestRequest.BadParameterException e) {\n                 badRequestCause = ExceptionsHelper.useOrSuppress(badRequestCause, e);\n                 innerRestRequest = RestRequest.requestWithoutParameters(xContentRegistry, httpRequest, httpChannel);\n+            } catch (final RestRequest.CompatibleApiHeadersCombinationException e){\n+                badRequestCause = ExceptionsHelper.useOrSuppress(badRequestCause, e);\n+                //todo // tempting to just rethrow. removing content type is just making this less obvious\n+                throw e;\n+//                innerRestRequest = requestWithoutContentTypeHeader(httpRequest, httpChannel, badRequestCause);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYzODQyNg=="}, "originalCommit": {"oid": "bcb11fddf07df33c24fb05b4d3dc9e47aaa9c5b6"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMDcyNzI2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/rest/RestRequest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxOTowMDo1OVrOGExTIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxMToyMToxMlrOGFKBzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY1NTIwMA==", "bodyText": "Throwing the exception here results in an abrupt termination of the connection (no error code or proper response). Not sure the fix, but we should add a REST test to ensure the error code.", "url": "https://github.com/elastic/elasticsearch/pull/54103#discussion_r407655200", "createdAt": "2020-04-13T19:00:59Z", "author": {"login": "jakelandis"}, "path": "server/src/main/java/org/elasticsearch/rest/RestRequest.java", "diffHunk": "@@ -132,29 +134,91 @@ void ensureSafeBuffers() {\n     public static RestRequest request(NamedXContentRegistry xContentRegistry, HttpRequest httpRequest, HttpChannel httpChannel) {\n         Map<String, String> params = params(httpRequest.uri());\n         String path = path(httpRequest.uri());\n-        RestRequest restRequest = new RestRequest(xContentRegistry, params, path, httpRequest.getHeaders(), httpRequest, httpChannel,\n+        return new RestRequest(xContentRegistry, params, path, httpRequest.getHeaders(), httpRequest, httpChannel,\n             requestIdGenerator.incrementAndGet());\n-        return restRequest;\n     }\n \n     private void addCompatibleParameter() {\n-        if (isRequestCompatible()) {\n-            String compatibleVersion = XContentType.parseVersion(header(CompatibleConstants.COMPATIBLE_HEADER));\n-            params().put(CompatibleConstants.COMPATIBLE_PARAMS_KEY, compatibleVersion);\n+        Version compatible = compatibleWithVersion();\n+        if (Version.PREVIOUS.equals(compatible)) {\n+            params().put(CompatibleConstants.COMPATIBLE_PARAMS_KEY, String.valueOf(compatible.major));\n             //use it so it won't fail request validation with unused parameter\n             param(CompatibleConstants.COMPATIBLE_PARAMS_KEY);\n         }\n     }\n \n-    private boolean isRequestCompatible() {\n-        return isHeaderCompatible(header(CompatibleConstants.COMPATIBLE_HEADER));\n-    }\n+    private Version compatibleWithVersion() {\n+        String currentVersion = String.valueOf(Version.CURRENT.major);\n+        String previousVersion = String.valueOf(Version.CURRENT.major - 1);\n \n-    private boolean isHeaderCompatible(String headerValue) {\n-        String version = XContentType.parseVersion(headerValue);\n-        return CompatibleConstants.COMPATIBLE_VERSION.equals(version);\n-    }\n+        String acceptHeader = header(CompatibleConstants.COMPATIBLE_ACCEPT_HEADER);\n+        String acceptVersion = XContentType.parseVersion(acceptHeader);\n+        String contentTypeHeader = header(CompatibleConstants.COMPATIBLE_CONTENT_TYPE_HEADER);\n+        String contentTypeVersion = XContentType.parseVersion(contentTypeHeader);\n+\n+        //TODO not sure about this one as this does not cover text formats\n+        boolean isSupportedMediaTypeAccept = acceptHeader == null || XContentType.parseMediaType(acceptHeader) != null;\n \n+        boolean isSupportedMediaTypeContentType = contentTypeHeader == null || XContentType.parseMediaType(contentTypeHeader) != null;\n+\n+        if (hasContent()) {\n+            //both headers versioned\n+            if (acceptVersion != null && contentTypeVersion != null) {\n+                // both Accept and Content-Type are versioned and set to a previous version\n+                if (previousVersion.equals(acceptVersion) && previousVersion.equals(contentTypeVersion)) {\n+                    return Version.PREVIOUS;\n+                }\n+                // both Accept and Content-Type are versioned to a current version\n+                if (currentVersion.equals(acceptVersion) && currentVersion.equals(contentTypeVersion)) {\n+                    return Version.CURRENT;\n+                }\n+                // both headers are versioned but set to incorrect version\n+                throw new CompatibleApiHeadersCombinationException(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bcb11fddf07df33c24fb05b4d3dc9e47aaa9c5b6"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA2MDM2NA==", "bodyText": "I think that we allow RestRequest to be in an incorrect state. When creating a request and it fails due to Content-Type validation https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/rest/RestRequest.java#L93 or parameter validation https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/rest/RestRequest.java#L145\nwe try create again without either content-type or without parameters.\nThis makes it harder to create a validation of headers.. we would need to allow to have an incorrect state that would be used for channel creation in order to response back..", "url": "https://github.com/elastic/elasticsearch/pull/54103#discussion_r408060364", "createdAt": "2020-04-14T11:21:12Z", "author": {"login": "pgomulka"}, "path": "server/src/main/java/org/elasticsearch/rest/RestRequest.java", "diffHunk": "@@ -132,29 +134,91 @@ void ensureSafeBuffers() {\n     public static RestRequest request(NamedXContentRegistry xContentRegistry, HttpRequest httpRequest, HttpChannel httpChannel) {\n         Map<String, String> params = params(httpRequest.uri());\n         String path = path(httpRequest.uri());\n-        RestRequest restRequest = new RestRequest(xContentRegistry, params, path, httpRequest.getHeaders(), httpRequest, httpChannel,\n+        return new RestRequest(xContentRegistry, params, path, httpRequest.getHeaders(), httpRequest, httpChannel,\n             requestIdGenerator.incrementAndGet());\n-        return restRequest;\n     }\n \n     private void addCompatibleParameter() {\n-        if (isRequestCompatible()) {\n-            String compatibleVersion = XContentType.parseVersion(header(CompatibleConstants.COMPATIBLE_HEADER));\n-            params().put(CompatibleConstants.COMPATIBLE_PARAMS_KEY, compatibleVersion);\n+        Version compatible = compatibleWithVersion();\n+        if (Version.PREVIOUS.equals(compatible)) {\n+            params().put(CompatibleConstants.COMPATIBLE_PARAMS_KEY, String.valueOf(compatible.major));\n             //use it so it won't fail request validation with unused parameter\n             param(CompatibleConstants.COMPATIBLE_PARAMS_KEY);\n         }\n     }\n \n-    private boolean isRequestCompatible() {\n-        return isHeaderCompatible(header(CompatibleConstants.COMPATIBLE_HEADER));\n-    }\n+    private Version compatibleWithVersion() {\n+        String currentVersion = String.valueOf(Version.CURRENT.major);\n+        String previousVersion = String.valueOf(Version.CURRENT.major - 1);\n \n-    private boolean isHeaderCompatible(String headerValue) {\n-        String version = XContentType.parseVersion(headerValue);\n-        return CompatibleConstants.COMPATIBLE_VERSION.equals(version);\n-    }\n+        String acceptHeader = header(CompatibleConstants.COMPATIBLE_ACCEPT_HEADER);\n+        String acceptVersion = XContentType.parseVersion(acceptHeader);\n+        String contentTypeHeader = header(CompatibleConstants.COMPATIBLE_CONTENT_TYPE_HEADER);\n+        String contentTypeVersion = XContentType.parseVersion(contentTypeHeader);\n+\n+        //TODO not sure about this one as this does not cover text formats\n+        boolean isSupportedMediaTypeAccept = acceptHeader == null || XContentType.parseMediaType(acceptHeader) != null;\n \n+        boolean isSupportedMediaTypeContentType = contentTypeHeader == null || XContentType.parseMediaType(contentTypeHeader) != null;\n+\n+        if (hasContent()) {\n+            //both headers versioned\n+            if (acceptVersion != null && contentTypeVersion != null) {\n+                // both Accept and Content-Type are versioned and set to a previous version\n+                if (previousVersion.equals(acceptVersion) && previousVersion.equals(contentTypeVersion)) {\n+                    return Version.PREVIOUS;\n+                }\n+                // both Accept and Content-Type are versioned to a current version\n+                if (currentVersion.equals(acceptVersion) && currentVersion.equals(contentTypeVersion)) {\n+                    return Version.CURRENT;\n+                }\n+                // both headers are versioned but set to incorrect version\n+                throw new CompatibleApiHeadersCombinationException(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY1NTIwMA=="}, "originalCommit": {"oid": "bcb11fddf07df33c24fb05b4d3dc9e47aaa9c5b6"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMDkxNzAxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/rest/RestRequest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxOTo1ODoyM1rOGEzJQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxOTo1ODoyM1rOGEzJQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY4NTQ0Mg==", "bodyText": "I think this can be greatly simplified and read easier if this returns a boolean and only concerns itself with the version (not the supported media types (that can happen later if need be)).\nI think something like this below the same level of validation.\n    private void addCompatibleParameter() {\n        if (isRequestingCompatibility()) {\n            params().put(CompatibleConstants.COMPATIBLE_PARAMS_KEY, String.valueOf(Version.CURRENT.major - 1));\n            param(CompatibleConstants.COMPATIBLE_PARAMS_KEY);\n        }\n    }\n\n    private boolean isRequestingCompatibility() {\n        String acceptHeader = header(CompatibleConstants.COMPATIBLE_ACCEPT_HEADER);\n        String aVersion = XContentType.parseVersion(acceptHeader);\n        byte acceptVersion = aVersion == null ? Version.CURRENT.major : Integer.valueOf(aVersion).byteValue();\n        String contentTypeHeader = header(CompatibleConstants.COMPATIBLE_CONTENT_TYPE_HEADER);\n        String cVersion = XContentType.parseVersion(contentTypeHeader);\n        byte contentTypeVersion = cVersion == null ? Version.CURRENT.major : Integer.valueOf(cVersion).byteValue();\n\n        if(Version.CURRENT.major < acceptVersion || Version.CURRENT.major - acceptVersion > 1 ){\n            throw new IllegalStateException(\"something about only 1 major version support\");\n        }\n\n        if (hasContent()) {\n            if(Version.CURRENT.major < contentTypeVersion || Version.CURRENT.major - contentTypeVersion > 1 ){\n                throw new IllegalStateException(\"something about only 1 major version support\");\n            }\n\n            if (contentTypeVersion != acceptVersion) {\n                throw new IllegalStateException(\"something about needing to match\");\n            }\n        }\n\n        return contentTypeVersion < Version.CURRENT.major || acceptVersion < Version.CURRENT.major;\n    }", "url": "https://github.com/elastic/elasticsearch/pull/54103#discussion_r407685442", "createdAt": "2020-04-13T19:58:23Z", "author": {"login": "jakelandis"}, "path": "server/src/main/java/org/elasticsearch/rest/RestRequest.java", "diffHunk": "@@ -132,29 +134,91 @@ void ensureSafeBuffers() {\n     public static RestRequest request(NamedXContentRegistry xContentRegistry, HttpRequest httpRequest, HttpChannel httpChannel) {\n         Map<String, String> params = params(httpRequest.uri());\n         String path = path(httpRequest.uri());\n-        RestRequest restRequest = new RestRequest(xContentRegistry, params, path, httpRequest.getHeaders(), httpRequest, httpChannel,\n+        return new RestRequest(xContentRegistry, params, path, httpRequest.getHeaders(), httpRequest, httpChannel,\n             requestIdGenerator.incrementAndGet());\n-        return restRequest;\n     }\n \n     private void addCompatibleParameter() {\n-        if (isRequestCompatible()) {\n-            String compatibleVersion = XContentType.parseVersion(header(CompatibleConstants.COMPATIBLE_HEADER));\n-            params().put(CompatibleConstants.COMPATIBLE_PARAMS_KEY, compatibleVersion);\n+        Version compatible = compatibleWithVersion();\n+        if (Version.PREVIOUS.equals(compatible)) {\n+            params().put(CompatibleConstants.COMPATIBLE_PARAMS_KEY, String.valueOf(compatible.major));\n             //use it so it won't fail request validation with unused parameter\n             param(CompatibleConstants.COMPATIBLE_PARAMS_KEY);\n         }\n     }\n \n-    private boolean isRequestCompatible() {\n-        return isHeaderCompatible(header(CompatibleConstants.COMPATIBLE_HEADER));\n-    }\n+    private Version compatibleWithVersion() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bcb11fddf07df33c24fb05b4d3dc9e47aaa9c5b6"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0MTY1OTU4OnYy", "diffSide": "RIGHT", "path": "modules/transport-netty4/src/test/java/org/elasticsearch/rest/Netty4BadRequestIT.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwODoxOTo0NVrOGGZ8Aw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMDoyODozNFrOGHcIZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM2OTYwMw==", "bodyText": "how much details do we want on this exception?\nat the moment it helped debugging tests when seeing which failed validation", "url": "https://github.com/elastic/elasticsearch/pull/54103#discussion_r409369603", "createdAt": "2020-04-16T08:19:45Z", "author": {"login": "pgomulka"}, "path": "modules/transport-netty4/src/test/java/org/elasticsearch/rest/Netty4BadRequestIT.java", "diffHunk": "@@ -101,4 +101,27 @@ public void testInvalidHeaderValue() throws IOException {\n         assertThat(map.get(\"type\"), equalTo(\"content_type_header_exception\"));\n         assertThat(map.get(\"reason\"), equalTo(\"java.lang.IllegalArgumentException: invalid Content-Type header []\"));\n     }\n+\n+    public void testInvalidHeaderCombinations() throws IOException {\n+        final Request request = new Request(\"GET\", \"/_cluster/settings\");\n+        final RequestOptions.Builder options = request.getOptions().toBuilder();\n+        options.addHeader(\"Content-Type\", \"application/vnd.elasticsearch+json;compatible-with=7\");\n+        options.addHeader(\"Accept\", \"application/vnd.elasticsearch+json;compatible-with=8\");\n+        request.setOptions(options);\n+        request.setJsonEntity(\"{\\\"transient\\\":{\\\"search.*\\\":null}}\");\n+\n+        final ResponseException e = expectThrows(ResponseException.class, () -> client().performRequest(request));\n+        final Response response = e.getResponse();\n+        assertThat(response.getStatusLine().getStatusCode(), equalTo(400));\n+        final ObjectPath objectPath = ObjectPath.createFromResponse(response);\n+        final Map<String, Object> map = objectPath.evaluate(\"error\");\n+        assertThat(map.get(\"type\"), equalTo(\"compatible_api_headers_combination_exception\"));\n+        assertThat(map.get(\"reason\"), equalTo(\"Content-Type and Accept headers have to match when content is present. \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10e8d1bf5ddaf664927d22e3d27de779a3fc46c5"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1NDExNw==", "bodyText": "I think this is a good level of detail.", "url": "https://github.com/elastic/elasticsearch/pull/54103#discussion_r410454117", "createdAt": "2020-04-17T20:28:34Z", "author": {"login": "jakelandis"}, "path": "modules/transport-netty4/src/test/java/org/elasticsearch/rest/Netty4BadRequestIT.java", "diffHunk": "@@ -101,4 +101,27 @@ public void testInvalidHeaderValue() throws IOException {\n         assertThat(map.get(\"type\"), equalTo(\"content_type_header_exception\"));\n         assertThat(map.get(\"reason\"), equalTo(\"java.lang.IllegalArgumentException: invalid Content-Type header []\"));\n     }\n+\n+    public void testInvalidHeaderCombinations() throws IOException {\n+        final Request request = new Request(\"GET\", \"/_cluster/settings\");\n+        final RequestOptions.Builder options = request.getOptions().toBuilder();\n+        options.addHeader(\"Content-Type\", \"application/vnd.elasticsearch+json;compatible-with=7\");\n+        options.addHeader(\"Accept\", \"application/vnd.elasticsearch+json;compatible-with=8\");\n+        request.setOptions(options);\n+        request.setJsonEntity(\"{\\\"transient\\\":{\\\"search.*\\\":null}}\");\n+\n+        final ResponseException e = expectThrows(ResponseException.class, () -> client().performRequest(request));\n+        final Response response = e.getResponse();\n+        assertThat(response.getStatusLine().getStatusCode(), equalTo(400));\n+        final ObjectPath objectPath = ObjectPath.createFromResponse(response);\n+        final Map<String, Object> map = objectPath.evaluate(\"error\");\n+        assertThat(map.get(\"type\"), equalTo(\"compatible_api_headers_combination_exception\"));\n+        assertThat(map.get(\"reason\"), equalTo(\"Content-Type and Accept headers have to match when content is present. \" +", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM2OTYwMw=="}, "originalCommit": {"oid": "10e8d1bf5ddaf664927d22e3d27de779a3fc46c5"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0MTgwMjg5OnYy", "diffSide": "RIGHT", "path": "qa/rest-compat-tests/src/main/java/org/elasticsearch/rest/compat/AbstractCompatRestTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwODo1NTozMlrOGGbWUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMDozMToyMlrOGHcM6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM5MjcyMQ==", "bodyText": "we have tests that need Accept header to be empty - expecting text response\nmaybe we should extend XContentType to text\nbut then again, we don't expect content-type to be text, and adding text there would allow this", "url": "https://github.com/elastic/elasticsearch/pull/54103#discussion_r409392721", "createdAt": "2020-04-16T08:55:32Z", "author": {"login": "pgomulka"}, "path": "qa/rest-compat-tests/src/main/java/org/elasticsearch/rest/compat/AbstractCompatRestTest.java", "diffHunk": "@@ -66,38 +66,48 @@ protected AbstractCompatRestTest(@Name(\"yaml\") ClientYamlTestCandidate testCandi\n             });\n             finalTestCandidates.add(testCandidates.toArray());\n         }\n-        localCandidates.keySet().forEach(lc -> finalTestCandidates.add(new Object[]{lc}));\n+        localCandidates.keySet().forEach(lc -> finalTestCandidates.add(new Object[] { lc }));\n         return finalTestCandidates;\n     }\n \n-\n     private static void mutateTestCandidate(ClientYamlTestCandidate testCandidate) {\n-        testCandidate.getTestSection().getExecutableSections().stream().filter(s -> s instanceof DoSection).forEach(ds -> {\n+        testCandidate.getSetupSection().getExecutableSections().stream().filter(s -> s instanceof DoSection).forEach(updateDoSection());\n+        testCandidate.getTestSection().getExecutableSections().stream().filter(s -> s instanceof DoSection).forEach(updateDoSection());\n+    }\n+\n+    private static Consumer<? super ExecutableSection> updateDoSection() {\n+        return ds -> {\n             DoSection doSection = (DoSection) ds;\n-            //TODO: be more selective here\n+            // TODO: be more selective here\n             doSection.setIgnoreWarnings(true);\n \n             String compatibleHeader = createCompatibleHeader();\n-            //TODO decide which one to use - Accept or Content-Type\n-            doSection.getApiCallSection()\n-                     .addHeaders(Map.of(\n-                         CompatibleConstants.COMPATIBLE_HEADER, compatibleHeader,\n-                         \"Content-Type\", compatibleHeader\n-                         ));\n-        });\n+            // for cat apis accept headers would break tests which expect txt response\n+            if (doSection.getApiCallSection().getApi().startsWith(\"cat\") == false) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10e8d1bf5ddaf664927d22e3d27de779a3fc46c5"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1NTI3Mg==", "bodyText": "I think we can punt on the cat api's for now, and this is sufficient for now. this code is temporary and i can address this later.", "url": "https://github.com/elastic/elasticsearch/pull/54103#discussion_r410455272", "createdAt": "2020-04-17T20:31:22Z", "author": {"login": "jakelandis"}, "path": "qa/rest-compat-tests/src/main/java/org/elasticsearch/rest/compat/AbstractCompatRestTest.java", "diffHunk": "@@ -66,38 +66,48 @@ protected AbstractCompatRestTest(@Name(\"yaml\") ClientYamlTestCandidate testCandi\n             });\n             finalTestCandidates.add(testCandidates.toArray());\n         }\n-        localCandidates.keySet().forEach(lc -> finalTestCandidates.add(new Object[]{lc}));\n+        localCandidates.keySet().forEach(lc -> finalTestCandidates.add(new Object[] { lc }));\n         return finalTestCandidates;\n     }\n \n-\n     private static void mutateTestCandidate(ClientYamlTestCandidate testCandidate) {\n-        testCandidate.getTestSection().getExecutableSections().stream().filter(s -> s instanceof DoSection).forEach(ds -> {\n+        testCandidate.getSetupSection().getExecutableSections().stream().filter(s -> s instanceof DoSection).forEach(updateDoSection());\n+        testCandidate.getTestSection().getExecutableSections().stream().filter(s -> s instanceof DoSection).forEach(updateDoSection());\n+    }\n+\n+    private static Consumer<? super ExecutableSection> updateDoSection() {\n+        return ds -> {\n             DoSection doSection = (DoSection) ds;\n-            //TODO: be more selective here\n+            // TODO: be more selective here\n             doSection.setIgnoreWarnings(true);\n \n             String compatibleHeader = createCompatibleHeader();\n-            //TODO decide which one to use - Accept or Content-Type\n-            doSection.getApiCallSection()\n-                     .addHeaders(Map.of(\n-                         CompatibleConstants.COMPATIBLE_HEADER, compatibleHeader,\n-                         \"Content-Type\", compatibleHeader\n-                         ));\n-        });\n+            // for cat apis accept headers would break tests which expect txt response\n+            if (doSection.getApiCallSection().getApi().startsWith(\"cat\") == false) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM5MjcyMQ=="}, "originalCommit": {"oid": "10e8d1bf5ddaf664927d22e3d27de779a3fc46c5"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0MTgzMzQ4OnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/elasticsearch/common/xcontent/XContentTypeTests.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwOTowMzowN1rOGGbqCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMDo0MDoxMlrOGHca3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM5Nzc3MQ==", "bodyText": "as per my comment https://github.com/elastic/elasticsearch/pull/54103/files#r409392721\nmaybe we should also extend parsing media types that are text? Should we unify this with SQL?\nsee RestSqlQueryAction at the moment sql has to use format parameter\ncc @astefan", "url": "https://github.com/elastic/elasticsearch/pull/54103#discussion_r409397771", "createdAt": "2020-04-16T09:03:07Z", "author": {"login": "pgomulka"}, "path": "server/src/test/java/org/elasticsearch/common/xcontent/XContentTypeTests.java", "diffHunk": "@@ -121,4 +121,21 @@ public void testVersionParsing() {\n         assertThat(XContentType.parseVersion(\"APPLICATION/JSON\"),\n             nullValue());\n     }\n+\n+    public void testVersionParsingOnText() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10e8d1bf5ddaf664927d22e3d27de779a3fc46c5"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1ODg0NA==", "bodyText": "Can we postpone that decision for now and work and in future work ensure that text based APIs are good ?", "url": "https://github.com/elastic/elasticsearch/pull/54103#discussion_r410458844", "createdAt": "2020-04-17T20:40:12Z", "author": {"login": "jakelandis"}, "path": "server/src/test/java/org/elasticsearch/common/xcontent/XContentTypeTests.java", "diffHunk": "@@ -121,4 +121,21 @@ public void testVersionParsing() {\n         assertThat(XContentType.parseVersion(\"APPLICATION/JSON\"),\n             nullValue());\n     }\n+\n+    public void testVersionParsingOnText() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM5Nzc3MQ=="}, "originalCommit": {"oid": "10e8d1bf5ddaf664927d22e3d27de779a3fc46c5"}, "originalPosition": 5}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4171, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}