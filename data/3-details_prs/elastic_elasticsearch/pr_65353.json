{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI1NjU3NzU4", "number": 65353, "title": "QL: Combine multiple equal queries into In", "bodyText": "Some queries can have an excessive number of OR clauses on the same\nfield (typically by being generated). This can lead to large query\nrequests that can cause SO errors.\nThis PR tries to address this pattern by combining the equals into an\nIn expression which in turn gets compressed into a terms query vs one\nterm query per entry.\nFix #62804\nFix #46477", "createdAt": "2020-11-23T11:20:53Z", "url": "https://github.com/elastic/elasticsearch/pull/65353", "merged": true, "mergeCommit": {"oid": "7505d7d61caee245604f3f828925c2346ecc256c"}, "closed": true, "closedAt": "2020-11-24T15:20:47Z", "author": {"login": "costin"}, "timelineItems": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdfTW40gBqjQwMjcxMzQyNjA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdfqe9bgH2gAyNTI1NjU3NzU4OjMwNjhmZmJiY2JmZjJiOGUxNDM4Mzc1NzU2OGY5Yjg4MzAwMjM1Yjg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b8145f65bceb79850a57bcefad1b2f8d8c01a8d3", "author": {"user": {"login": "costin", "name": "Costin Leau"}}, "url": "https://github.com/elastic/elasticsearch/commit/b8145f65bceb79850a57bcefad1b2f8d8c01a8d3", "committedDate": "2020-11-23T11:18:17Z", "message": "QL: Combine multiple equal queries into In\n\nSome queries can have an excessive number of OR clauses on the same\nfield (typically by being generated). This can lead to large query\nrequests that can cause SO errors.\nThis PR tries to address this pattern by combining the equals into an\nIn expression which in turn gets compressed into a terms query vs one\nterm query per entry.\n\nFix #62804\nFix #46477"}, "afterCommit": {"oid": "437b89310d6fd731214739f08be36748864231e4", "author": {"user": {"login": "costin", "name": "Costin Leau"}}, "url": "https://github.com/elastic/elasticsearch/commit/437b89310d6fd731214739f08be36748864231e4", "committedDate": "2020-11-23T11:21:44Z", "message": "QL: Combine multiple equal queries into In\n\nSome queries can have an excessive number of OR clauses on the same\nfield (typically by being generated). This can lead to large query\nrequests that can cause SO errors.\nThis PR tries to address this pattern by combining the equals into an\nIn expression which in turn gets compressed into a terms query vs one\nterm query per entry.\n\nFix #62804\nFix #46477"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "437b89310d6fd731214739f08be36748864231e4", "author": {"user": {"login": "costin", "name": "Costin Leau"}}, "url": "https://github.com/elastic/elasticsearch/commit/437b89310d6fd731214739f08be36748864231e4", "committedDate": "2020-11-23T11:21:44Z", "message": "QL: Combine multiple equal queries into In\n\nSome queries can have an excessive number of OR clauses on the same\nfield (typically by being generated). This can lead to large query\nrequests that can cause SO errors.\nThis PR tries to address this pattern by combining the equals into an\nIn expression which in turn gets compressed into a terms query vs one\nterm query per entry.\n\nFix #62804\nFix #46477"}, "afterCommit": {"oid": "593c63dae6cb74f9517b11af7a1eb75a5b286b72", "author": {"user": {"login": "costin", "name": "Costin Leau"}}, "url": "https://github.com/elastic/elasticsearch/commit/593c63dae6cb74f9517b11af7a1eb75a5b286b72", "committedDate": "2020-11-23T11:41:31Z", "message": "QL: Combine multiple equal queries into In\n\nSome queries can have an excessive number of OR clauses on the same\nfield (typically by being generated). This can lead to large query\nrequests that can cause SO errors.\nThis PR tries to address this pattern by combining the equals into an\nIn expression which in turn gets compressed into a terms query vs one\nterm query per entry.\n\nFix #62804\nFix #46477"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "593c63dae6cb74f9517b11af7a1eb75a5b286b72", "author": {"user": {"login": "costin", "name": "Costin Leau"}}, "url": "https://github.com/elastic/elasticsearch/commit/593c63dae6cb74f9517b11af7a1eb75a5b286b72", "committedDate": "2020-11-23T11:41:31Z", "message": "QL: Combine multiple equal queries into In\n\nSome queries can have an excessive number of OR clauses on the same\nfield (typically by being generated). This can lead to large query\nrequests that can cause SO errors.\nThis PR tries to address this pattern by combining the equals into an\nIn expression which in turn gets compressed into a terms query vs one\nterm query per entry.\n\nFix #62804\nFix #46477"}, "afterCommit": {"oid": "4509198c29d1290315a91ba10cb04ef2c6b451c6", "author": {"user": {"login": "costin", "name": "Costin Leau"}}, "url": "https://github.com/elastic/elasticsearch/commit/4509198c29d1290315a91ba10cb04ef2c6b451c6", "committedDate": "2020-11-23T15:03:21Z", "message": "Don't lose unpicked expressions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "28d351dbbe6d6429bf093cd31ca8d53ebb64cab7", "author": {"user": {"login": "costin", "name": "Costin Leau"}}, "url": "https://github.com/elastic/elasticsearch/commit/28d351dbbe6d6429bf093cd31ca8d53ebb64cab7", "committedDate": "2020-11-23T15:38:38Z", "message": "QL: Combine multiple equal queries into In\n\nSome queries can have an excessive number of OR clauses on the same\nfield (typically by being generated). This can lead to large query\nrequests that can cause SO errors.\nThis PR tries to address this pattern by combining the equals into an\nIn expression which in turn gets compressed into a terms query vs one\nterm query per entry.\n\nFix #62804\nFix #46477"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4509198c29d1290315a91ba10cb04ef2c6b451c6", "author": {"user": {"login": "costin", "name": "Costin Leau"}}, "url": "https://github.com/elastic/elasticsearch/commit/4509198c29d1290315a91ba10cb04ef2c6b451c6", "committedDate": "2020-11-23T15:03:21Z", "message": "Don't lose unpicked expressions"}, "afterCommit": {"oid": "28d351dbbe6d6429bf093cd31ca8d53ebb64cab7", "author": {"user": {"login": "costin", "name": "Costin Leau"}}, "url": "https://github.com/elastic/elasticsearch/commit/28d351dbbe6d6429bf093cd31ca8d53ebb64cab7", "committedDate": "2020-11-23T15:38:38Z", "message": "QL: Combine multiple equal queries into In\n\nSome queries can have an excessive number of OR clauses on the same\nfield (typically by being generated). This can lead to large query\nrequests that can cause SO errors.\nThis PR tries to address this pattern by combining the equals into an\nIn expression which in turn gets compressed into a terms query vs one\nterm query per entry.\n\nFix #62804\nFix #46477"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2NjI3NDY1", "url": "https://github.com/elastic/elasticsearch/pull/65353#pullrequestreview-536627465", "createdAt": "2020-11-23T16:13:02Z", "commit": {"oid": "28d351dbbe6d6429bf093cd31ca8d53ebb64cab7"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxNjoxMzowMlrOH4U1XA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxNjoyMTo0NVrOH4VOqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODgyMzY0NA==", "bodyText": "Why do you need a second zoneid variable? You could use zoneId.", "url": "https://github.com/elastic/elasticsearch/pull/65353#discussion_r528823644", "createdAt": "2020-11-23T16:13:02Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1036,6 +1042,79 @@ private static boolean notEqualsIsRemovableFromConjunction(NotEquals notEquals,\n \n     }\n \n+    /**\n+     * Combine disjunctions on the same field into an In expression.\n+     * This rule looks for both simple equalities:\n+     * 1. a == 1 OR a == 2 becomes a IN (1, 2)\n+     * and combinations of In\n+     * 2. a == 1 OR a IN (2) becomes a IN (1, 2)\n+     * 3. a IN (1) OR a IN (2) becomes a IN (1, 2)\n+     *\n+     * This rule does NOT check for type compatibility as that phase has been\n+     * already be verified in the analyzer.\n+     */\n+    public static class CombineDisjunctionsToIn extends OptimizerExpressionRule {\n+        public CombineDisjunctionsToIn() {\n+            super(TransformDirection.UP);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof Or) {\n+                // look only at equals and In\n+                List<Expression> exps = splitOr(e);\n+\n+                Map<Expression, Set<Expression>> found = new LinkedHashMap<>();\n+                ZoneId zoneId = null;\n+                List<Expression> ors = new ArrayList<>();\n+\n+                for (Expression exp : exps) {\n+                    if (exp instanceof Equals) {\n+                        Equals eq = (Equals) exp;\n+                        // consider only equals against foldables\n+                        if (eq.right().foldable()) {\n+                            found.computeIfAbsent(eq.left(), k -> new LinkedHashSet<>()).add(eq.right());\n+                        } else {\n+                            ors.add(exp);\n+                        }\n+                        if (zoneId == null) {\n+                            zoneId = eq.zoneId();\n+                        }\n+                    }\n+                    else if (exp instanceof In) {\n+                        In in = (In) exp;\n+                        found.computeIfAbsent(in.value(), k -> new LinkedHashSet<>()).addAll(in.list());\n+                        if (zoneId == null) {\n+                            zoneId = in.zoneId();\n+                        }\n+                    } else {\n+                        ors.add(exp);\n+                    }\n+                }\n+\n+                if (found.isEmpty() == false) {\n+                    // combine equals alongside the existing ors\n+                    ZoneId finalZoneId = zoneId;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28d351dbbe6d6429bf093cd31ca8d53ebb64cab7"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODgzMDEyMA==", "bodyText": "Leftover?", "url": "https://github.com/elastic/elasticsearch/pull/65353#discussion_r528830120", "createdAt": "2020-11-23T16:21:45Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/planner/QueryTranslatorTests.java", "diffHunk": "@@ -106,6 +107,7 @@\n import static org.hamcrest.Matchers.is;\n import static org.hamcrest.Matchers.startsWith;\n \n+@TestLogging(value = \"org.elasticsearch.xpack.sql:TRACE\", reason = \"debug\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28d351dbbe6d6429bf093cd31ca8d53ebb64cab7"}, "originalPosition": 12}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2NjI4MDA5", "url": "https://github.com/elastic/elasticsearch/pull/65353#pullrequestreview-536628009", "createdAt": "2020-11-23T16:13:37Z", "commit": {"oid": "28d351dbbe6d6429bf093cd31ca8d53ebb64cab7"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxNjoxMzozN1rOH4U2vQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxNjozMzoxMVrOH4VvLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODgyMzk5Nw==", "bodyText": "nit: any reason to use the proxy finalZoneId? good practice?", "url": "https://github.com/elastic/elasticsearch/pull/65353#discussion_r528823997", "createdAt": "2020-11-23T16:13:37Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1036,6 +1042,79 @@ private static boolean notEqualsIsRemovableFromConjunction(NotEquals notEquals,\n \n     }\n \n+    /**\n+     * Combine disjunctions on the same field into an In expression.\n+     * This rule looks for both simple equalities:\n+     * 1. a == 1 OR a == 2 becomes a IN (1, 2)\n+     * and combinations of In\n+     * 2. a == 1 OR a IN (2) becomes a IN (1, 2)\n+     * 3. a IN (1) OR a IN (2) becomes a IN (1, 2)\n+     *\n+     * This rule does NOT check for type compatibility as that phase has been\n+     * already be verified in the analyzer.\n+     */\n+    public static class CombineDisjunctionsToIn extends OptimizerExpressionRule {\n+        public CombineDisjunctionsToIn() {\n+            super(TransformDirection.UP);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof Or) {\n+                // look only at equals and In\n+                List<Expression> exps = splitOr(e);\n+\n+                Map<Expression, Set<Expression>> found = new LinkedHashMap<>();\n+                ZoneId zoneId = null;\n+                List<Expression> ors = new ArrayList<>();\n+\n+                for (Expression exp : exps) {\n+                    if (exp instanceof Equals) {\n+                        Equals eq = (Equals) exp;\n+                        // consider only equals against foldables\n+                        if (eq.right().foldable()) {\n+                            found.computeIfAbsent(eq.left(), k -> new LinkedHashSet<>()).add(eq.right());\n+                        } else {\n+                            ors.add(exp);\n+                        }\n+                        if (zoneId == null) {\n+                            zoneId = eq.zoneId();\n+                        }\n+                    }\n+                    else if (exp instanceof In) {\n+                        In in = (In) exp;\n+                        found.computeIfAbsent(in.value(), k -> new LinkedHashSet<>()).addAll(in.list());\n+                        if (zoneId == null) {\n+                            zoneId = in.zoneId();\n+                        }\n+                    } else {\n+                        ors.add(exp);\n+                    }\n+                }\n+\n+                if (found.isEmpty() == false) {\n+                    // combine equals alongside the existing ors\n+                    ZoneId finalZoneId = zoneId;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28d351dbbe6d6429bf093cd31ca8d53ebb64cab7"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODgzNDQxOQ==", "bodyText": "QQ: I guess the IN could contain non foldable expressions? Wouldn't a similar check be useful for IN's elements?", "url": "https://github.com/elastic/elasticsearch/pull/65353#discussion_r528834419", "createdAt": "2020-11-23T16:27:39Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1036,6 +1042,79 @@ private static boolean notEqualsIsRemovableFromConjunction(NotEquals notEquals,\n \n     }\n \n+    /**\n+     * Combine disjunctions on the same field into an In expression.\n+     * This rule looks for both simple equalities:\n+     * 1. a == 1 OR a == 2 becomes a IN (1, 2)\n+     * and combinations of In\n+     * 2. a == 1 OR a IN (2) becomes a IN (1, 2)\n+     * 3. a IN (1) OR a IN (2) becomes a IN (1, 2)\n+     *\n+     * This rule does NOT check for type compatibility as that phase has been\n+     * already be verified in the analyzer.\n+     */\n+    public static class CombineDisjunctionsToIn extends OptimizerExpressionRule {\n+        public CombineDisjunctionsToIn() {\n+            super(TransformDirection.UP);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof Or) {\n+                // look only at equals and In\n+                List<Expression> exps = splitOr(e);\n+\n+                Map<Expression, Set<Expression>> found = new LinkedHashMap<>();\n+                ZoneId zoneId = null;\n+                List<Expression> ors = new ArrayList<>();\n+\n+                for (Expression exp : exps) {\n+                    if (exp instanceof Equals) {\n+                        Equals eq = (Equals) exp;\n+                        // consider only equals against foldables", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28d351dbbe6d6429bf093cd31ca8d53ebb64cab7"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODgzODQ0NQ==", "bodyText": "was this left intentionally?", "url": "https://github.com/elastic/elasticsearch/pull/65353#discussion_r528838445", "createdAt": "2020-11-23T16:33:11Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/planner/QueryTranslatorTests.java", "diffHunk": "@@ -106,6 +107,7 @@\n import static org.hamcrest.Matchers.is;\n import static org.hamcrest.Matchers.startsWith;\n \n+@TestLogging(value = \"org.elasticsearch.xpack.sql:TRACE\", reason = \"debug\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28d351dbbe6d6429bf093cd31ca8d53ebb64cab7"}, "originalPosition": 12}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "87561e86590374104ef3dabf857bf6519d80ac9d", "author": {"user": {"login": "costin", "name": "Costin Leau"}}, "url": "https://github.com/elastic/elasticsearch/commit/87561e86590374104ef3dabf857bf6519d80ac9d", "committedDate": "2020-11-23T17:05:39Z", "message": "Apply semantic check"}, "afterCommit": {"oid": "bae8eaf6d9314667a3d4ac7c5055230728a930a6", "author": {"user": {"login": "costin", "name": "Costin Leau"}}, "url": "https://github.com/elastic/elasticsearch/commit/bae8eaf6d9314667a3d4ac7c5055230728a930a6", "committedDate": "2020-11-23T17:06:28Z", "message": "Apply semantic check"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bae8eaf6d9314667a3d4ac7c5055230728a930a6", "author": {"user": {"login": "costin", "name": "Costin Leau"}}, "url": "https://github.com/elastic/elasticsearch/commit/bae8eaf6d9314667a3d4ac7c5055230728a930a6", "committedDate": "2020-11-23T17:06:28Z", "message": "Apply semantic check"}, "afterCommit": {"oid": "246a453df2307e4c8073bf38dddbf54a1b6a3e7e", "author": {"user": {"login": "costin", "name": "Costin Leau"}}, "url": "https://github.com/elastic/elasticsearch/commit/246a453df2307e4c8073bf38dddbf54a1b6a3e7e", "committedDate": "2020-11-23T17:07:50Z", "message": "Apply semantic check"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ed2f9bcafe95ee4f85bdb3b4fdb9daed60dd0500", "author": {"user": {"login": "costin", "name": "Costin Leau"}}, "url": "https://github.com/elastic/elasticsearch/commit/ed2f9bcafe95ee4f85bdb3b4fdb9daed60dd0500", "committedDate": "2020-11-23T17:48:29Z", "message": "Apply semantic check"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "246a453df2307e4c8073bf38dddbf54a1b6a3e7e", "author": {"user": {"login": "costin", "name": "Costin Leau"}}, "url": "https://github.com/elastic/elasticsearch/commit/246a453df2307e4c8073bf38dddbf54a1b6a3e7e", "committedDate": "2020-11-23T17:07:50Z", "message": "Apply semantic check"}, "afterCommit": {"oid": "ed2f9bcafe95ee4f85bdb3b4fdb9daed60dd0500", "author": {"user": {"login": "costin", "name": "Costin Leau"}}, "url": "https://github.com/elastic/elasticsearch/commit/ed2f9bcafe95ee4f85bdb3b4fdb9daed60dd0500", "committedDate": "2020-11-23T17:48:29Z", "message": "Apply semantic check"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e4ba0f99d6cf89e1986b365abb730c894e571aba", "author": {"user": {"login": "costin", "name": "Costin Leau"}}, "url": "https://github.com/elastic/elasticsearch/commit/e4ba0f99d6cf89e1986b365abb730c894e571aba", "committedDate": "2020-11-23T21:29:36Z", "message": "Fix tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2OTExODQy", "url": "https://github.com/elastic/elasticsearch/pull/65353#pullrequestreview-536911842", "createdAt": "2020-11-23T22:59:51Z", "commit": {"oid": "e4ba0f99d6cf89e1986b365abb730c894e571aba"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMjo1OTo1MVrOH4itpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMzowNjowMFrOH4i3-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA1MTA0Nw==", "bodyText": "Typo.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    assertEquals(e, e);\n          \n          \n            \n                    assertEquals(or, e);", "url": "https://github.com/elastic/elasticsearch/pull/65353#discussion_r529051047", "createdAt": "2020-11-23T22:59:51Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/ql/src/test/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRulesTests.java", "diffHunk": "@@ -1377,10 +1382,131 @@ public void testExactMatchRLike() throws Exception {\n         RLikePattern pattern = new RLikePattern(\"abc\");\n         FieldAttribute fa = getFieldAttribute();\n         RLike l = new RLike(EMPTY, fa, pattern);\n-        Expression e = new OptimizerRules.ReplaceRegexMatch().rule(l);\n+        Expression e = new ReplaceRegexMatch().rule(l);\n         assertEquals(Equals.class, e.getClass());\n         Equals eq = (Equals) e;\n         assertEquals(fa, eq.left());\n         assertEquals(\"abc\", eq.right().fold());\n     }\n+\n+    //\n+    // CombineDisjunction in Equals\n+    //\n+    public void testTwoEqualsWithOr() throws Exception {\n+        FieldAttribute fa = getFieldAttribute();\n+        Literal one = of(1);\n+        Literal two = of(2);\n+\n+        Or or = new Or(EMPTY, equalsOf(fa, one), equalsOf(fa, two));\n+        Expression e = new CombineDisjunctionsToIn().rule(or);\n+        assertEquals(In.class, e.getClass());\n+        In in = (In) e;\n+        assertEquals(fa, in.value());\n+        assertThat(in.list(), contains(one, two));\n+    }\n+\n+    public void testTwoEqualsWithSameValue() throws Exception {\n+        FieldAttribute fa = getFieldAttribute();\n+        Literal one = of(1);\n+\n+        Or or = new Or(EMPTY, equalsOf(fa, one), equalsOf(fa, one));\n+        Expression e = new CombineDisjunctionsToIn().rule(or);\n+        assertEquals(Equals.class, e.getClass());\n+        Equals eq = (Equals) e;\n+        assertEquals(fa, eq.left());\n+        assertEquals(one, eq.right());\n+    }\n+\n+    public void testOneEqualsOneIn() throws Exception {\n+        FieldAttribute fa = getFieldAttribute();\n+        Literal one = of(1);\n+        Literal two = of(2);\n+\n+        Or or = new Or(EMPTY, equalsOf(fa, one), new In(EMPTY, fa, singletonList(two)));\n+        Expression e = new CombineDisjunctionsToIn().rule(or);\n+        assertEquals(In.class, e.getClass());\n+        In in = (In) e;\n+        assertEquals(fa, in.value());\n+        assertThat(in.list(), contains(one, two));\n+    }\n+\n+    public void testOneEqualsOneInWithSameValue() throws Exception {\n+        FieldAttribute fa = getFieldAttribute();\n+        Literal one = of(1);\n+        Literal two = of(2);\n+\n+        Or or = new Or(EMPTY, equalsOf(fa, one), new In(EMPTY, fa, asList(one, two)));\n+        Expression e = new CombineDisjunctionsToIn().rule(or);\n+        assertEquals(In.class, e.getClass());\n+        In in = (In) e;\n+        assertEquals(fa, in.value());\n+        assertThat(in.list(), contains(one, two));\n+    }\n+\n+    public void testSingleValueInToEquals() throws Exception {\n+        FieldAttribute fa = getFieldAttribute();\n+        Literal one = of(1);\n+\n+        Equals equals = equalsOf(fa, one);\n+        Or or = new Or(EMPTY, equals, new In(EMPTY, fa, singletonList(one)));\n+        Expression e = new CombineDisjunctionsToIn().rule(or);\n+        assertEquals(equals, e);\n+    }\n+\n+    public void testEqualsBehindAnd() throws Exception {\n+        FieldAttribute fa = getFieldAttribute();\n+        Literal one = of(1);\n+        Literal two = of(2);\n+\n+        And and = new And(EMPTY, equalsOf(fa, one), equalsOf(fa, two));\n+        Expression e = new CombineDisjunctionsToIn().rule(and);\n+        assertEquals(and, e);\n+    }\n+\n+    public void testTwoEqualsDifferentFields() throws Exception {\n+        FieldAttribute fieldOne = getFieldAttribute(\"one\");\n+        FieldAttribute fieldTwo = getFieldAttribute(\"two\");\n+        Literal one = of(1);\n+        Literal two = of(2);\n+\n+        Or or = new Or(EMPTY, equalsOf(fieldOne, one), equalsOf(fieldTwo, two));\n+        Expression e = new CombineDisjunctionsToIn().rule(or);\n+        assertEquals(e, e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4ba0f99d6cf89e1986b365abb730c894e571aba"}, "originalPosition": 219}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA1MzY4OA==", "bodyText": "Super nit-picky. Would just test that there are no changes:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    assertEquals(LessThan.class, or.right().getClass());\n          \n          \n            \n                    LessThan lt = (LessThan) or.right();\n          \n          \n            \n                    assertEquals(fa, lt.left());\n          \n          \n            \n                    assertEquals(two, lt.right());\n          \n          \n            \n                    assertEquals(or.right(), firstOr.right());", "url": "https://github.com/elastic/elasticsearch/pull/65353#discussion_r529053688", "createdAt": "2020-11-23T23:06:00Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/ql/src/test/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRulesTests.java", "diffHunk": "@@ -1377,10 +1382,131 @@ public void testExactMatchRLike() throws Exception {\n         RLikePattern pattern = new RLikePattern(\"abc\");\n         FieldAttribute fa = getFieldAttribute();\n         RLike l = new RLike(EMPTY, fa, pattern);\n-        Expression e = new OptimizerRules.ReplaceRegexMatch().rule(l);\n+        Expression e = new ReplaceRegexMatch().rule(l);\n         assertEquals(Equals.class, e.getClass());\n         Equals eq = (Equals) e;\n         assertEquals(fa, eq.left());\n         assertEquals(\"abc\", eq.right().fold());\n     }\n+\n+    //\n+    // CombineDisjunction in Equals\n+    //\n+    public void testTwoEqualsWithOr() throws Exception {\n+        FieldAttribute fa = getFieldAttribute();\n+        Literal one = of(1);\n+        Literal two = of(2);\n+\n+        Or or = new Or(EMPTY, equalsOf(fa, one), equalsOf(fa, two));\n+        Expression e = new CombineDisjunctionsToIn().rule(or);\n+        assertEquals(In.class, e.getClass());\n+        In in = (In) e;\n+        assertEquals(fa, in.value());\n+        assertThat(in.list(), contains(one, two));\n+    }\n+\n+    public void testTwoEqualsWithSameValue() throws Exception {\n+        FieldAttribute fa = getFieldAttribute();\n+        Literal one = of(1);\n+\n+        Or or = new Or(EMPTY, equalsOf(fa, one), equalsOf(fa, one));\n+        Expression e = new CombineDisjunctionsToIn().rule(or);\n+        assertEquals(Equals.class, e.getClass());\n+        Equals eq = (Equals) e;\n+        assertEquals(fa, eq.left());\n+        assertEquals(one, eq.right());\n+    }\n+\n+    public void testOneEqualsOneIn() throws Exception {\n+        FieldAttribute fa = getFieldAttribute();\n+        Literal one = of(1);\n+        Literal two = of(2);\n+\n+        Or or = new Or(EMPTY, equalsOf(fa, one), new In(EMPTY, fa, singletonList(two)));\n+        Expression e = new CombineDisjunctionsToIn().rule(or);\n+        assertEquals(In.class, e.getClass());\n+        In in = (In) e;\n+        assertEquals(fa, in.value());\n+        assertThat(in.list(), contains(one, two));\n+    }\n+\n+    public void testOneEqualsOneInWithSameValue() throws Exception {\n+        FieldAttribute fa = getFieldAttribute();\n+        Literal one = of(1);\n+        Literal two = of(2);\n+\n+        Or or = new Or(EMPTY, equalsOf(fa, one), new In(EMPTY, fa, asList(one, two)));\n+        Expression e = new CombineDisjunctionsToIn().rule(or);\n+        assertEquals(In.class, e.getClass());\n+        In in = (In) e;\n+        assertEquals(fa, in.value());\n+        assertThat(in.list(), contains(one, two));\n+    }\n+\n+    public void testSingleValueInToEquals() throws Exception {\n+        FieldAttribute fa = getFieldAttribute();\n+        Literal one = of(1);\n+\n+        Equals equals = equalsOf(fa, one);\n+        Or or = new Or(EMPTY, equals, new In(EMPTY, fa, singletonList(one)));\n+        Expression e = new CombineDisjunctionsToIn().rule(or);\n+        assertEquals(equals, e);\n+    }\n+\n+    public void testEqualsBehindAnd() throws Exception {\n+        FieldAttribute fa = getFieldAttribute();\n+        Literal one = of(1);\n+        Literal two = of(2);\n+\n+        And and = new And(EMPTY, equalsOf(fa, one), equalsOf(fa, two));\n+        Expression e = new CombineDisjunctionsToIn().rule(and);\n+        assertEquals(and, e);\n+    }\n+\n+    public void testTwoEqualsDifferentFields() throws Exception {\n+        FieldAttribute fieldOne = getFieldAttribute(\"one\");\n+        FieldAttribute fieldTwo = getFieldAttribute(\"two\");\n+        Literal one = of(1);\n+        Literal two = of(2);\n+\n+        Or or = new Or(EMPTY, equalsOf(fieldOne, one), equalsOf(fieldTwo, two));\n+        Expression e = new CombineDisjunctionsToIn().rule(or);\n+        assertEquals(e, e);\n+    }\n+\n+    public void testMultipleIn() throws Exception {\n+        FieldAttribute fa = getFieldAttribute();\n+        Literal one = of(1);\n+        Literal two = of(2);\n+        Literal three = of(3);\n+\n+        Or firstOr = new Or(EMPTY, new In(EMPTY, fa, singletonList(one)), new In(EMPTY, fa, singletonList(two)));\n+        Or secondOr = new Or(EMPTY, firstOr, new In(EMPTY, fa, singletonList(three)));\n+        Expression e = new CombineDisjunctionsToIn().rule(secondOr);\n+        assertEquals(In.class, e.getClass());\n+        In in = (In) e;\n+        assertEquals(fa, in.value());\n+        assertThat(in.list(), contains(one, two, three));\n+    }\n+\n+    public void testOrWithNonCombinableExpressions() throws Exception {\n+        FieldAttribute fa = getFieldAttribute();\n+        Literal one = of(1);\n+        Literal two = of(2);\n+        Literal three = of(3);\n+\n+        Or firstOr = new Or(EMPTY, new In(EMPTY, fa, singletonList(one)), lessThanOf(fa, two));\n+        Or secondOr = new Or(EMPTY, firstOr, new In(EMPTY, fa, singletonList(three)));\n+        Expression e = new CombineDisjunctionsToIn().rule(secondOr);\n+        assertEquals(Or.class, e.getClass());\n+        Or or = (Or) e;\n+        assertEquals(LessThan.class, or.right().getClass());\n+        LessThan lt = (LessThan) or.right();\n+        assertEquals(fa, lt.left());\n+        assertEquals(two, lt.right());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4ba0f99d6cf89e1986b365abb730c894e571aba"}, "originalPosition": 251}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e80d4a4d1a41d4c9ec145d2f7011b55b78cce2d1", "author": {"user": {"login": "costin", "name": "Costin Leau"}}, "url": "https://github.com/elastic/elasticsearch/commit/e80d4a4d1a41d4c9ec145d2f7011b55b78cce2d1", "committedDate": "2020-11-24T08:16:59Z", "message": "Polish"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3068ffbbcbff2b8e14383757568f9b88300235b8", "author": {"user": {"login": "elasticmachine", "name": "Elastic Machine"}}, "url": "https://github.com/elastic/elasticsearch/commit/3068ffbbcbff2b8e14383757568f9b88300235b8", "committedDate": "2020-11-24T14:18:43Z", "message": "Merge branch 'master' into fix/46477"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4388, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}