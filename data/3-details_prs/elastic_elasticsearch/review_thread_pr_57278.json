{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI0NDU5NTkz", "number": 57278, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwODo1OTozNlrOEAz_pA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwODo1OTozNlrOEAz_pA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5Mjg3MzMyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/annotations/AnnotationPersister.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwODo1OTozNlrOGcUmOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxMDo0NzoxN1rOGcX5VA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM1MDc3OA==", "bodyText": "nit: make bulkRequest.numberOfActions() a Supplier so it is only called if trace logging is enabled.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.trace(\"[{}] ES API CALL: bulk request with {} actions\", jobId, bulkRequest.numberOfActions());\n          \n          \n            \n                        logger.trace(\"[{}] ES API CALL: bulk request with {} actions\",  () -> jobId, () -> bulkRequest.numberOfActions());", "url": "https://github.com/elastic/elasticsearch/pull/57278#discussion_r432350778", "createdAt": "2020-05-29T08:59:36Z", "author": {"login": "davidkyle"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/annotations/AnnotationPersister.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.ml.annotations;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.action.bulk.BulkRequest;\n+import org.elasticsearch.action.bulk.BulkResponse;\n+import org.elasticsearch.action.index.IndexRequest;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.collect.Tuple;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.xpack.core.common.notifications.AbstractAuditor;\n+import org.elasticsearch.xpack.core.ml.annotations.Annotation;\n+import org.elasticsearch.xpack.core.ml.annotations.AnnotationIndex;\n+import org.elasticsearch.xpack.ml.utils.persistence.ResultsPersisterService;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+import java.util.function.Supplier;\n+\n+/**\n+ * Persists annotations to Elasticsearch index.\n+ */\n+public class AnnotationPersister {\n+\n+    private static final Logger logger = LogManager.getLogger(AnnotationPersister.class);\n+\n+    private static final int DEFAULT_BULK_LIMIT = 10_000;\n+\n+    private final ResultsPersisterService resultsPersisterService;\n+    private final AbstractAuditor<?> auditor;\n+    /**\n+     * Execute bulk requests when they reach this size\n+     */\n+    private final int bulkLimit;\n+\n+    public AnnotationPersister(ResultsPersisterService resultsPersisterService, AbstractAuditor<?> auditor) {\n+        this(resultsPersisterService, auditor, DEFAULT_BULK_LIMIT);\n+    }\n+\n+    // For testing\n+    AnnotationPersister(ResultsPersisterService resultsPersisterService, AbstractAuditor<?> auditor, int bulkLimit) {\n+        this.resultsPersisterService = Objects.requireNonNull(resultsPersisterService);\n+        this.auditor = Objects.requireNonNull(auditor);\n+        this.bulkLimit = bulkLimit;\n+    }\n+\n+    /**\n+     * Persists the given annotation to annotations index.\n+     *\n+     * @param annotationId existing annotation id. If {@code null}, a new annotation will be created and id will be assigned automatically\n+     * @param annotation annotation to be persisted\n+     * @return tuple of the form (annotation id, annotation object)\n+     */\n+    public Tuple<String, Annotation> persistAnnotation(@Nullable String annotationId, Annotation annotation) {\n+        Objects.requireNonNull(annotation);\n+        String jobId = annotation.getJobId();\n+        BulkResponse bulkResponse = bulkPersisterBuilder(jobId).persistAnnotation(annotationId, annotation).executeRequest();\n+        assert bulkResponse.getItems().length == 1;\n+        return Tuple.tuple(bulkResponse.getItems()[0].getId(), annotation);\n+    }\n+\n+    public Builder bulkPersisterBuilder(String jobId) {\n+        return new Builder(jobId);\n+    }\n+\n+    public class Builder {\n+\n+        private final String jobId;\n+        private BulkRequest bulkRequest = new BulkRequest(AnnotationIndex.WRITE_ALIAS_NAME);\n+        private Supplier<Boolean> shouldRetry = () -> true;\n+\n+        private Builder(String jobId) {\n+            this.jobId = Objects.requireNonNull(jobId);\n+        }\n+\n+        public Builder shouldRetry(Supplier<Boolean> shouldRetry) {\n+            this.shouldRetry = Objects.requireNonNull(shouldRetry);\n+            return this;\n+        }\n+\n+        public Builder persistAnnotation(Annotation annotation) {\n+            return persistAnnotation(null, annotation);\n+        }\n+\n+        public Builder persistAnnotation(@Nullable String annotationId, Annotation annotation) {\n+            Objects.requireNonNull(annotation);\n+            try (XContentBuilder xContentBuilder = annotation.toXContent(XContentFactory.jsonBuilder(), ToXContent.EMPTY_PARAMS)) {\n+                bulkRequest.add(new IndexRequest().id(annotationId).source(xContentBuilder));\n+            } catch (IOException e) {\n+                logger.error(new ParameterizedMessage(\"[{}] Error serialising annotation\", jobId), e);\n+            }\n+\n+            if (bulkRequest.numberOfActions() >= bulkLimit) {\n+                executeRequest();\n+            }\n+            return this;\n+        }\n+\n+        /**\n+         * Execute the bulk action\n+         */\n+        public BulkResponse executeRequest() {\n+            if (bulkRequest.numberOfActions() == 0) {\n+                return null;\n+            }\n+            logger.trace(\"[{}] ES API CALL: bulk request with {} actions\", jobId, bulkRequest.numberOfActions());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f6e6dde2ebcfa2325d7818a4737ff02ac523dca7"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQwNDgyMA==", "bodyText": "Done.", "url": "https://github.com/elastic/elasticsearch/pull/57278#discussion_r432404820", "createdAt": "2020-05-29T10:47:17Z", "author": {"login": "przemekwitek"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/annotations/AnnotationPersister.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.ml.annotations;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.action.bulk.BulkRequest;\n+import org.elasticsearch.action.bulk.BulkResponse;\n+import org.elasticsearch.action.index.IndexRequest;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.collect.Tuple;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.xpack.core.common.notifications.AbstractAuditor;\n+import org.elasticsearch.xpack.core.ml.annotations.Annotation;\n+import org.elasticsearch.xpack.core.ml.annotations.AnnotationIndex;\n+import org.elasticsearch.xpack.ml.utils.persistence.ResultsPersisterService;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+import java.util.function.Supplier;\n+\n+/**\n+ * Persists annotations to Elasticsearch index.\n+ */\n+public class AnnotationPersister {\n+\n+    private static final Logger logger = LogManager.getLogger(AnnotationPersister.class);\n+\n+    private static final int DEFAULT_BULK_LIMIT = 10_000;\n+\n+    private final ResultsPersisterService resultsPersisterService;\n+    private final AbstractAuditor<?> auditor;\n+    /**\n+     * Execute bulk requests when they reach this size\n+     */\n+    private final int bulkLimit;\n+\n+    public AnnotationPersister(ResultsPersisterService resultsPersisterService, AbstractAuditor<?> auditor) {\n+        this(resultsPersisterService, auditor, DEFAULT_BULK_LIMIT);\n+    }\n+\n+    // For testing\n+    AnnotationPersister(ResultsPersisterService resultsPersisterService, AbstractAuditor<?> auditor, int bulkLimit) {\n+        this.resultsPersisterService = Objects.requireNonNull(resultsPersisterService);\n+        this.auditor = Objects.requireNonNull(auditor);\n+        this.bulkLimit = bulkLimit;\n+    }\n+\n+    /**\n+     * Persists the given annotation to annotations index.\n+     *\n+     * @param annotationId existing annotation id. If {@code null}, a new annotation will be created and id will be assigned automatically\n+     * @param annotation annotation to be persisted\n+     * @return tuple of the form (annotation id, annotation object)\n+     */\n+    public Tuple<String, Annotation> persistAnnotation(@Nullable String annotationId, Annotation annotation) {\n+        Objects.requireNonNull(annotation);\n+        String jobId = annotation.getJobId();\n+        BulkResponse bulkResponse = bulkPersisterBuilder(jobId).persistAnnotation(annotationId, annotation).executeRequest();\n+        assert bulkResponse.getItems().length == 1;\n+        return Tuple.tuple(bulkResponse.getItems()[0].getId(), annotation);\n+    }\n+\n+    public Builder bulkPersisterBuilder(String jobId) {\n+        return new Builder(jobId);\n+    }\n+\n+    public class Builder {\n+\n+        private final String jobId;\n+        private BulkRequest bulkRequest = new BulkRequest(AnnotationIndex.WRITE_ALIAS_NAME);\n+        private Supplier<Boolean> shouldRetry = () -> true;\n+\n+        private Builder(String jobId) {\n+            this.jobId = Objects.requireNonNull(jobId);\n+        }\n+\n+        public Builder shouldRetry(Supplier<Boolean> shouldRetry) {\n+            this.shouldRetry = Objects.requireNonNull(shouldRetry);\n+            return this;\n+        }\n+\n+        public Builder persistAnnotation(Annotation annotation) {\n+            return persistAnnotation(null, annotation);\n+        }\n+\n+        public Builder persistAnnotation(@Nullable String annotationId, Annotation annotation) {\n+            Objects.requireNonNull(annotation);\n+            try (XContentBuilder xContentBuilder = annotation.toXContent(XContentFactory.jsonBuilder(), ToXContent.EMPTY_PARAMS)) {\n+                bulkRequest.add(new IndexRequest().id(annotationId).source(xContentBuilder));\n+            } catch (IOException e) {\n+                logger.error(new ParameterizedMessage(\"[{}] Error serialising annotation\", jobId), e);\n+            }\n+\n+            if (bulkRequest.numberOfActions() >= bulkLimit) {\n+                executeRequest();\n+            }\n+            return this;\n+        }\n+\n+        /**\n+         * Execute the bulk action\n+         */\n+        public BulkResponse executeRequest() {\n+            if (bulkRequest.numberOfActions() == 0) {\n+                return null;\n+            }\n+            logger.trace(\"[{}] ES API CALL: bulk request with {} actions\", jobId, bulkRequest.numberOfActions());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM1MDc3OA=="}, "originalCommit": {"oid": "f6e6dde2ebcfa2325d7818a4737ff02ac523dca7"}, "originalPosition": 114}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3847, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}