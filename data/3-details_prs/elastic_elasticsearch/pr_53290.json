{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg1NjY3ODA0", "number": 53290, "title": "Add ComponentTemplate to MetaData", "bodyText": "This adds a ComponentTemplate datastructure that will be used as part of #53101 (Index Templates\nv2) to the MetaData class. Currently there are no APIs for interacting with this class, so it will\nalways be an empty map (other than in tests). This infrastructure will be built upon to add APIs in\na subsequent commit.\nA ComponentTemplate is made up of a Template, a version, and an arbitrary metadata map. The\nTemplate contains similar information to an IndexTemplateMetaData object\u2014 settings, mappings,\nand alias configuration.", "createdAt": "2020-03-09T15:49:52Z", "url": "https://github.com/elastic/elasticsearch/pull/53290", "merged": true, "mergeCommit": {"oid": "ae55e06253aa39e8e242e3e2feceab0e8e18e424"}, "closed": true, "closedAt": "2020-03-12T15:27:26Z", "author": {"login": "dakrone"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcL_gDqgH2gAyMzg1NjY3ODA0OjUwNmVhNjQwZjRiYTY0NjJjODQ0ZTdlOGQ4YTdmODYwYzQwZWZjYTg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcM8e9zAH2gAyMzg1NjY3ODA0OjE4OGY0NzkzZDk1N2ZhMjg5M2ZlZTdjYjVmOTVmODU1NGU3NmQzODI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "506ea640f4ba6462c844e7e8d8a7f860c40efca8", "author": {"user": {"login": "dakrone", "name": "Lee Hinman"}}, "url": "https://github.com/elastic/elasticsearch/commit/506ea640f4ba6462c844e7e8d8a7f860c40efca8", "committedDate": "2020-03-09T15:18:17Z", "message": "Add ComponentTemplate to MetaData\n\nThis adds a `ComponentTemplate` datastructure that will be used as part of #53101 (Index Templates\nv2) to the `MetaData` class. Currently there are no APIs for interacting with this class, so it will\nalways be an empty map (other than in tests). This infrastructure will be built upon to add APIs in\na subsequent commit.\n\nA `ComponentTemplate` is made up of a `Template`, a version, and an arbitrary metadata map. The\n`Template` contains similar information to an `IndexTemplateMetaData` object\u2014 settings, mappings,\nand alias configuration."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxNTg1Mjc0", "url": "https://github.com/elastic/elasticsearch/pull/53290#pullrequestreview-371585274", "createdAt": "2020-03-09T23:06:16Z", "commit": {"oid": "506ea640f4ba6462c844e7e8d8a7f860c40efca8"}, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMzowNjoxNlrOFz8Q6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMzoxNDo0N1rOFz8blQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwOTA2Nw==", "bodyText": "nit: this is not needed, but can be left if you think it's more readable that way", "url": "https://github.com/elastic/elasticsearch/pull/53290#discussion_r390009067", "createdAt": "2020-03-09T23:06:16Z", "author": {"login": "probakowski"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/ComponentTemplate.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.cluster.metadata;\n+\n+import org.elasticsearch.cluster.AbstractDiffable;\n+import org.elasticsearch.cluster.Diff;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.bytes.BytesArray;\n+import org.elasticsearch.common.compress.CompressedXContent;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.common.xcontent.XContentHelper;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentType;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * A component template is a re-usable template as well as metadata about the template. Each\n+ * component template is expected to be valid on its own. For example, if a component template\n+ * contains a field \"foo\", it's expected to contain all the necessary settings/mappings/etc for the\n+ * \"foo\" field. These component templates make up the individual pieces composing an index template.\n+ */\n+public class ComponentTemplate extends AbstractDiffable<ComponentTemplate> implements ToXContentObject {\n+    private static final ParseField TEMPLATE = new ParseField(\"template\");\n+    private static final ParseField VERSION = new ParseField(\"version\");\n+    private static final ParseField METADATA = new ParseField(\"_meta\");\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static final ConstructingObjectParser<ComponentTemplate, Void> PARSER =\n+        new ConstructingObjectParser<>(\"component_template\", false,\n+            a -> new ComponentTemplate((Template) a[0], (Long) a[1], (Map<String, Object>) a[2]));\n+\n+    static {\n+        PARSER.declareObject(ConstructingObjectParser.constructorArg(), Template.PARSER, TEMPLATE);\n+        PARSER.declareLong(ConstructingObjectParser.optionalConstructorArg(), VERSION);\n+        PARSER.declareObject(ConstructingObjectParser.optionalConstructorArg(), (p, c) -> p.map(), METADATA);\n+    }\n+\n+    private final Template template;\n+    @Nullable\n+    private final Long version;\n+    @Nullable\n+    private final Map<String, Object> metadata;\n+\n+    static Diff<ComponentTemplate> readComponentTemplateDiffFrom(StreamInput in) throws IOException {\n+        return AbstractDiffable.readDiffFrom(ComponentTemplate::new, in);\n+    }\n+\n+    public static ComponentTemplate parse(XContentParser parser) {\n+        return PARSER.apply(parser, null);\n+    }\n+\n+    public ComponentTemplate(Template template, @Nullable Long version, @Nullable Map<String, Object> metadata) {\n+        this.template = template;\n+        this.version = version;\n+        this.metadata = metadata;\n+    }\n+\n+    public ComponentTemplate(StreamInput in) throws IOException {\n+        this.template = new Template(in);\n+        this.version = in.readOptionalVLong();\n+        if (in.readBoolean()) {\n+            this.metadata = in.readMap();\n+        } else {\n+            this.metadata = null;\n+        }\n+    }\n+\n+    public Template template() {\n+        return template;\n+    }\n+\n+    @Nullable\n+    public Long version() {\n+        return version;\n+    }\n+\n+    @Nullable\n+    public Map<String, Object> metadata() {\n+        return metadata;\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        this.template.writeTo(out);\n+        out.writeOptionalVLong(this.version);\n+        if (this.metadata == null) {\n+            out.writeBoolean(false);\n+        } else {\n+            out.writeBoolean(true);\n+            out.writeMap(this.metadata);\n+        }\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(template, version, metadata);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj == null) {\n+            return false;\n+        }\n+        if (obj.getClass() != getClass()) {\n+            return false;\n+        }\n+        ComponentTemplate other = (ComponentTemplate) obj;\n+        return Objects.equals(template, other.template) &&\n+            Objects.equals(version, other.version) &&\n+            Objects.equals(metadata, other.metadata);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return Strings.toString(this);\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject();\n+        builder.field(TEMPLATE.getPreferredName(), this.template);\n+        if (this.version != null) {\n+            builder.field(VERSION.getPreferredName(), this.version);\n+        }\n+        if (this.metadata != null) {\n+            builder.field(METADATA.getPreferredName(), this.metadata);\n+        }\n+        builder.endObject();\n+        return builder;\n+    }\n+\n+    static class Template extends AbstractDiffable<Template> implements ToXContentObject {\n+        private static final ParseField SETTINGS = new ParseField(\"settings\");\n+        private static final ParseField MAPPINGS = new ParseField(\"mappings\");\n+        private static final ParseField ALIASES = new ParseField(\"aliases\");\n+\n+        @SuppressWarnings(\"unchecked\")\n+        private static final ConstructingObjectParser<Template, Void> PARSER = new ConstructingObjectParser<>(\"template\", false,\n+            a -> new Template((Settings) a[0], (CompressedXContent) a[1], (Map<String, AliasMetaData>) a[2]));\n+\n+        static {\n+            PARSER.declareObject(ConstructingObjectParser.optionalConstructorArg(), (p, c) -> Settings.fromXContent(p), SETTINGS);\n+            PARSER.declareObject(ConstructingObjectParser.optionalConstructorArg(), (p, c) ->\n+                new CompressedXContent(Strings.toString(XContentFactory.jsonBuilder().map(p.mapOrdered()))), MAPPINGS);\n+            PARSER.declareObject(ConstructingObjectParser.optionalConstructorArg(), (p, c) -> {\n+                Map<String, AliasMetaData> aliasMap = new HashMap<>();\n+                while ((p.nextToken()) != XContentParser.Token.END_OBJECT) {\n+                    AliasMetaData alias = AliasMetaData.Builder.fromXContent(p);\n+                    aliasMap.put(alias.alias(), alias);\n+                }\n+                return aliasMap;\n+            }, ALIASES);\n+        }\n+\n+        @Nullable\n+        private final Settings settings;\n+        @Nullable\n+        private final CompressedXContent mappings;\n+        @Nullable\n+        private final Map<String, AliasMetaData> aliases;\n+\n+        Template(@Nullable Settings settings, @Nullable CompressedXContent mappings, @Nullable Map<String, AliasMetaData> aliases) {\n+            this.settings = settings;\n+            this.mappings = mappings;\n+            this.aliases = aliases;\n+        }\n+\n+        Template(StreamInput in) throws IOException {\n+            if (in.readBoolean()) {\n+                this.settings = Settings.readSettingsFromStream(in);\n+            } else {\n+                this.settings = null;\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "506ea640f4ba6462c844e7e8d8a7f860c40efca8"}, "originalPosition": 202}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwOTEwOA==", "bodyText": "same as above", "url": "https://github.com/elastic/elasticsearch/pull/53290#discussion_r390009108", "createdAt": "2020-03-09T23:06:25Z", "author": {"login": "probakowski"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/ComponentTemplate.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.cluster.metadata;\n+\n+import org.elasticsearch.cluster.AbstractDiffable;\n+import org.elasticsearch.cluster.Diff;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.bytes.BytesArray;\n+import org.elasticsearch.common.compress.CompressedXContent;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.common.xcontent.XContentHelper;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentType;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * A component template is a re-usable template as well as metadata about the template. Each\n+ * component template is expected to be valid on its own. For example, if a component template\n+ * contains a field \"foo\", it's expected to contain all the necessary settings/mappings/etc for the\n+ * \"foo\" field. These component templates make up the individual pieces composing an index template.\n+ */\n+public class ComponentTemplate extends AbstractDiffable<ComponentTemplate> implements ToXContentObject {\n+    private static final ParseField TEMPLATE = new ParseField(\"template\");\n+    private static final ParseField VERSION = new ParseField(\"version\");\n+    private static final ParseField METADATA = new ParseField(\"_meta\");\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static final ConstructingObjectParser<ComponentTemplate, Void> PARSER =\n+        new ConstructingObjectParser<>(\"component_template\", false,\n+            a -> new ComponentTemplate((Template) a[0], (Long) a[1], (Map<String, Object>) a[2]));\n+\n+    static {\n+        PARSER.declareObject(ConstructingObjectParser.constructorArg(), Template.PARSER, TEMPLATE);\n+        PARSER.declareLong(ConstructingObjectParser.optionalConstructorArg(), VERSION);\n+        PARSER.declareObject(ConstructingObjectParser.optionalConstructorArg(), (p, c) -> p.map(), METADATA);\n+    }\n+\n+    private final Template template;\n+    @Nullable\n+    private final Long version;\n+    @Nullable\n+    private final Map<String, Object> metadata;\n+\n+    static Diff<ComponentTemplate> readComponentTemplateDiffFrom(StreamInput in) throws IOException {\n+        return AbstractDiffable.readDiffFrom(ComponentTemplate::new, in);\n+    }\n+\n+    public static ComponentTemplate parse(XContentParser parser) {\n+        return PARSER.apply(parser, null);\n+    }\n+\n+    public ComponentTemplate(Template template, @Nullable Long version, @Nullable Map<String, Object> metadata) {\n+        this.template = template;\n+        this.version = version;\n+        this.metadata = metadata;\n+    }\n+\n+    public ComponentTemplate(StreamInput in) throws IOException {\n+        this.template = new Template(in);\n+        this.version = in.readOptionalVLong();\n+        if (in.readBoolean()) {\n+            this.metadata = in.readMap();\n+        } else {\n+            this.metadata = null;\n+        }\n+    }\n+\n+    public Template template() {\n+        return template;\n+    }\n+\n+    @Nullable\n+    public Long version() {\n+        return version;\n+    }\n+\n+    @Nullable\n+    public Map<String, Object> metadata() {\n+        return metadata;\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        this.template.writeTo(out);\n+        out.writeOptionalVLong(this.version);\n+        if (this.metadata == null) {\n+            out.writeBoolean(false);\n+        } else {\n+            out.writeBoolean(true);\n+            out.writeMap(this.metadata);\n+        }\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(template, version, metadata);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj == null) {\n+            return false;\n+        }\n+        if (obj.getClass() != getClass()) {\n+            return false;\n+        }\n+        ComponentTemplate other = (ComponentTemplate) obj;\n+        return Objects.equals(template, other.template) &&\n+            Objects.equals(version, other.version) &&\n+            Objects.equals(metadata, other.metadata);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return Strings.toString(this);\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject();\n+        builder.field(TEMPLATE.getPreferredName(), this.template);\n+        if (this.version != null) {\n+            builder.field(VERSION.getPreferredName(), this.version);\n+        }\n+        if (this.metadata != null) {\n+            builder.field(METADATA.getPreferredName(), this.metadata);\n+        }\n+        builder.endObject();\n+        return builder;\n+    }\n+\n+    static class Template extends AbstractDiffable<Template> implements ToXContentObject {\n+        private static final ParseField SETTINGS = new ParseField(\"settings\");\n+        private static final ParseField MAPPINGS = new ParseField(\"mappings\");\n+        private static final ParseField ALIASES = new ParseField(\"aliases\");\n+\n+        @SuppressWarnings(\"unchecked\")\n+        private static final ConstructingObjectParser<Template, Void> PARSER = new ConstructingObjectParser<>(\"template\", false,\n+            a -> new Template((Settings) a[0], (CompressedXContent) a[1], (Map<String, AliasMetaData>) a[2]));\n+\n+        static {\n+            PARSER.declareObject(ConstructingObjectParser.optionalConstructorArg(), (p, c) -> Settings.fromXContent(p), SETTINGS);\n+            PARSER.declareObject(ConstructingObjectParser.optionalConstructorArg(), (p, c) ->\n+                new CompressedXContent(Strings.toString(XContentFactory.jsonBuilder().map(p.mapOrdered()))), MAPPINGS);\n+            PARSER.declareObject(ConstructingObjectParser.optionalConstructorArg(), (p, c) -> {\n+                Map<String, AliasMetaData> aliasMap = new HashMap<>();\n+                while ((p.nextToken()) != XContentParser.Token.END_OBJECT) {\n+                    AliasMetaData alias = AliasMetaData.Builder.fromXContent(p);\n+                    aliasMap.put(alias.alias(), alias);\n+                }\n+                return aliasMap;\n+            }, ALIASES);\n+        }\n+\n+        @Nullable\n+        private final Settings settings;\n+        @Nullable\n+        private final CompressedXContent mappings;\n+        @Nullable\n+        private final Map<String, AliasMetaData> aliases;\n+\n+        Template(@Nullable Settings settings, @Nullable CompressedXContent mappings, @Nullable Map<String, AliasMetaData> aliases) {\n+            this.settings = settings;\n+            this.mappings = mappings;\n+            this.aliases = aliases;\n+        }\n+\n+        Template(StreamInput in) throws IOException {\n+            if (in.readBoolean()) {\n+                this.settings = Settings.readSettingsFromStream(in);\n+            } else {\n+                this.settings = null;\n+            }\n+            if (in.readBoolean()) {\n+                this.mappings = CompressedXContent.readCompressedString(in);\n+            } else {\n+                this.mappings = null;\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "506ea640f4ba6462c844e7e8d8a7f860c40efca8"}, "originalPosition": 207}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwOTE2MQ==", "bodyText": "same here", "url": "https://github.com/elastic/elasticsearch/pull/53290#discussion_r390009161", "createdAt": "2020-03-09T23:06:34Z", "author": {"login": "probakowski"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/ComponentTemplate.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.cluster.metadata;\n+\n+import org.elasticsearch.cluster.AbstractDiffable;\n+import org.elasticsearch.cluster.Diff;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.bytes.BytesArray;\n+import org.elasticsearch.common.compress.CompressedXContent;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.common.xcontent.XContentHelper;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentType;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * A component template is a re-usable template as well as metadata about the template. Each\n+ * component template is expected to be valid on its own. For example, if a component template\n+ * contains a field \"foo\", it's expected to contain all the necessary settings/mappings/etc for the\n+ * \"foo\" field. These component templates make up the individual pieces composing an index template.\n+ */\n+public class ComponentTemplate extends AbstractDiffable<ComponentTemplate> implements ToXContentObject {\n+    private static final ParseField TEMPLATE = new ParseField(\"template\");\n+    private static final ParseField VERSION = new ParseField(\"version\");\n+    private static final ParseField METADATA = new ParseField(\"_meta\");\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static final ConstructingObjectParser<ComponentTemplate, Void> PARSER =\n+        new ConstructingObjectParser<>(\"component_template\", false,\n+            a -> new ComponentTemplate((Template) a[0], (Long) a[1], (Map<String, Object>) a[2]));\n+\n+    static {\n+        PARSER.declareObject(ConstructingObjectParser.constructorArg(), Template.PARSER, TEMPLATE);\n+        PARSER.declareLong(ConstructingObjectParser.optionalConstructorArg(), VERSION);\n+        PARSER.declareObject(ConstructingObjectParser.optionalConstructorArg(), (p, c) -> p.map(), METADATA);\n+    }\n+\n+    private final Template template;\n+    @Nullable\n+    private final Long version;\n+    @Nullable\n+    private final Map<String, Object> metadata;\n+\n+    static Diff<ComponentTemplate> readComponentTemplateDiffFrom(StreamInput in) throws IOException {\n+        return AbstractDiffable.readDiffFrom(ComponentTemplate::new, in);\n+    }\n+\n+    public static ComponentTemplate parse(XContentParser parser) {\n+        return PARSER.apply(parser, null);\n+    }\n+\n+    public ComponentTemplate(Template template, @Nullable Long version, @Nullable Map<String, Object> metadata) {\n+        this.template = template;\n+        this.version = version;\n+        this.metadata = metadata;\n+    }\n+\n+    public ComponentTemplate(StreamInput in) throws IOException {\n+        this.template = new Template(in);\n+        this.version = in.readOptionalVLong();\n+        if (in.readBoolean()) {\n+            this.metadata = in.readMap();\n+        } else {\n+            this.metadata = null;\n+        }\n+    }\n+\n+    public Template template() {\n+        return template;\n+    }\n+\n+    @Nullable\n+    public Long version() {\n+        return version;\n+    }\n+\n+    @Nullable\n+    public Map<String, Object> metadata() {\n+        return metadata;\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        this.template.writeTo(out);\n+        out.writeOptionalVLong(this.version);\n+        if (this.metadata == null) {\n+            out.writeBoolean(false);\n+        } else {\n+            out.writeBoolean(true);\n+            out.writeMap(this.metadata);\n+        }\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(template, version, metadata);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj == null) {\n+            return false;\n+        }\n+        if (obj.getClass() != getClass()) {\n+            return false;\n+        }\n+        ComponentTemplate other = (ComponentTemplate) obj;\n+        return Objects.equals(template, other.template) &&\n+            Objects.equals(version, other.version) &&\n+            Objects.equals(metadata, other.metadata);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return Strings.toString(this);\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject();\n+        builder.field(TEMPLATE.getPreferredName(), this.template);\n+        if (this.version != null) {\n+            builder.field(VERSION.getPreferredName(), this.version);\n+        }\n+        if (this.metadata != null) {\n+            builder.field(METADATA.getPreferredName(), this.metadata);\n+        }\n+        builder.endObject();\n+        return builder;\n+    }\n+\n+    static class Template extends AbstractDiffable<Template> implements ToXContentObject {\n+        private static final ParseField SETTINGS = new ParseField(\"settings\");\n+        private static final ParseField MAPPINGS = new ParseField(\"mappings\");\n+        private static final ParseField ALIASES = new ParseField(\"aliases\");\n+\n+        @SuppressWarnings(\"unchecked\")\n+        private static final ConstructingObjectParser<Template, Void> PARSER = new ConstructingObjectParser<>(\"template\", false,\n+            a -> new Template((Settings) a[0], (CompressedXContent) a[1], (Map<String, AliasMetaData>) a[2]));\n+\n+        static {\n+            PARSER.declareObject(ConstructingObjectParser.optionalConstructorArg(), (p, c) -> Settings.fromXContent(p), SETTINGS);\n+            PARSER.declareObject(ConstructingObjectParser.optionalConstructorArg(), (p, c) ->\n+                new CompressedXContent(Strings.toString(XContentFactory.jsonBuilder().map(p.mapOrdered()))), MAPPINGS);\n+            PARSER.declareObject(ConstructingObjectParser.optionalConstructorArg(), (p, c) -> {\n+                Map<String, AliasMetaData> aliasMap = new HashMap<>();\n+                while ((p.nextToken()) != XContentParser.Token.END_OBJECT) {\n+                    AliasMetaData alias = AliasMetaData.Builder.fromXContent(p);\n+                    aliasMap.put(alias.alias(), alias);\n+                }\n+                return aliasMap;\n+            }, ALIASES);\n+        }\n+\n+        @Nullable\n+        private final Settings settings;\n+        @Nullable\n+        private final CompressedXContent mappings;\n+        @Nullable\n+        private final Map<String, AliasMetaData> aliases;\n+\n+        Template(@Nullable Settings settings, @Nullable CompressedXContent mappings, @Nullable Map<String, AliasMetaData> aliases) {\n+            this.settings = settings;\n+            this.mappings = mappings;\n+            this.aliases = aliases;\n+        }\n+\n+        Template(StreamInput in) throws IOException {\n+            if (in.readBoolean()) {\n+                this.settings = Settings.readSettingsFromStream(in);\n+            } else {\n+                this.settings = null;\n+            }\n+            if (in.readBoolean()) {\n+                this.mappings = CompressedXContent.readCompressedString(in);\n+            } else {\n+                this.mappings = null;\n+            }\n+            if (in.readBoolean()) {\n+                this.aliases = in.readMap(StreamInput::readString, AliasMetaData::new);\n+            } else {\n+                this.aliases = null;\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "506ea640f4ba6462c844e7e8d8a7f860c40efca8"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMTc5Nw==", "bodyText": "If we have empty settings or mappings section we still have corresponding field but we skip it in case of mappings, any reason for that?", "url": "https://github.com/elastic/elasticsearch/pull/53290#discussion_r390011797", "createdAt": "2020-03-09T23:14:47Z", "author": {"login": "probakowski"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/ComponentTemplate.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.cluster.metadata;\n+\n+import org.elasticsearch.cluster.AbstractDiffable;\n+import org.elasticsearch.cluster.Diff;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.bytes.BytesArray;\n+import org.elasticsearch.common.compress.CompressedXContent;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.common.xcontent.XContentHelper;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentType;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * A component template is a re-usable template as well as metadata about the template. Each\n+ * component template is expected to be valid on its own. For example, if a component template\n+ * contains a field \"foo\", it's expected to contain all the necessary settings/mappings/etc for the\n+ * \"foo\" field. These component templates make up the individual pieces composing an index template.\n+ */\n+public class ComponentTemplate extends AbstractDiffable<ComponentTemplate> implements ToXContentObject {\n+    private static final ParseField TEMPLATE = new ParseField(\"template\");\n+    private static final ParseField VERSION = new ParseField(\"version\");\n+    private static final ParseField METADATA = new ParseField(\"_meta\");\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static final ConstructingObjectParser<ComponentTemplate, Void> PARSER =\n+        new ConstructingObjectParser<>(\"component_template\", false,\n+            a -> new ComponentTemplate((Template) a[0], (Long) a[1], (Map<String, Object>) a[2]));\n+\n+    static {\n+        PARSER.declareObject(ConstructingObjectParser.constructorArg(), Template.PARSER, TEMPLATE);\n+        PARSER.declareLong(ConstructingObjectParser.optionalConstructorArg(), VERSION);\n+        PARSER.declareObject(ConstructingObjectParser.optionalConstructorArg(), (p, c) -> p.map(), METADATA);\n+    }\n+\n+    private final Template template;\n+    @Nullable\n+    private final Long version;\n+    @Nullable\n+    private final Map<String, Object> metadata;\n+\n+    static Diff<ComponentTemplate> readComponentTemplateDiffFrom(StreamInput in) throws IOException {\n+        return AbstractDiffable.readDiffFrom(ComponentTemplate::new, in);\n+    }\n+\n+    public static ComponentTemplate parse(XContentParser parser) {\n+        return PARSER.apply(parser, null);\n+    }\n+\n+    public ComponentTemplate(Template template, @Nullable Long version, @Nullable Map<String, Object> metadata) {\n+        this.template = template;\n+        this.version = version;\n+        this.metadata = metadata;\n+    }\n+\n+    public ComponentTemplate(StreamInput in) throws IOException {\n+        this.template = new Template(in);\n+        this.version = in.readOptionalVLong();\n+        if (in.readBoolean()) {\n+            this.metadata = in.readMap();\n+        } else {\n+            this.metadata = null;\n+        }\n+    }\n+\n+    public Template template() {\n+        return template;\n+    }\n+\n+    @Nullable\n+    public Long version() {\n+        return version;\n+    }\n+\n+    @Nullable\n+    public Map<String, Object> metadata() {\n+        return metadata;\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        this.template.writeTo(out);\n+        out.writeOptionalVLong(this.version);\n+        if (this.metadata == null) {\n+            out.writeBoolean(false);\n+        } else {\n+            out.writeBoolean(true);\n+            out.writeMap(this.metadata);\n+        }\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(template, version, metadata);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj == null) {\n+            return false;\n+        }\n+        if (obj.getClass() != getClass()) {\n+            return false;\n+        }\n+        ComponentTemplate other = (ComponentTemplate) obj;\n+        return Objects.equals(template, other.template) &&\n+            Objects.equals(version, other.version) &&\n+            Objects.equals(metadata, other.metadata);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return Strings.toString(this);\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject();\n+        builder.field(TEMPLATE.getPreferredName(), this.template);\n+        if (this.version != null) {\n+            builder.field(VERSION.getPreferredName(), this.version);\n+        }\n+        if (this.metadata != null) {\n+            builder.field(METADATA.getPreferredName(), this.metadata);\n+        }\n+        builder.endObject();\n+        return builder;\n+    }\n+\n+    static class Template extends AbstractDiffable<Template> implements ToXContentObject {\n+        private static final ParseField SETTINGS = new ParseField(\"settings\");\n+        private static final ParseField MAPPINGS = new ParseField(\"mappings\");\n+        private static final ParseField ALIASES = new ParseField(\"aliases\");\n+\n+        @SuppressWarnings(\"unchecked\")\n+        private static final ConstructingObjectParser<Template, Void> PARSER = new ConstructingObjectParser<>(\"template\", false,\n+            a -> new Template((Settings) a[0], (CompressedXContent) a[1], (Map<String, AliasMetaData>) a[2]));\n+\n+        static {\n+            PARSER.declareObject(ConstructingObjectParser.optionalConstructorArg(), (p, c) -> Settings.fromXContent(p), SETTINGS);\n+            PARSER.declareObject(ConstructingObjectParser.optionalConstructorArg(), (p, c) ->\n+                new CompressedXContent(Strings.toString(XContentFactory.jsonBuilder().map(p.mapOrdered()))), MAPPINGS);\n+            PARSER.declareObject(ConstructingObjectParser.optionalConstructorArg(), (p, c) -> {\n+                Map<String, AliasMetaData> aliasMap = new HashMap<>();\n+                while ((p.nextToken()) != XContentParser.Token.END_OBJECT) {\n+                    AliasMetaData alias = AliasMetaData.Builder.fromXContent(p);\n+                    aliasMap.put(alias.alias(), alias);\n+                }\n+                return aliasMap;\n+            }, ALIASES);\n+        }\n+\n+        @Nullable\n+        private final Settings settings;\n+        @Nullable\n+        private final CompressedXContent mappings;\n+        @Nullable\n+        private final Map<String, AliasMetaData> aliases;\n+\n+        Template(@Nullable Settings settings, @Nullable CompressedXContent mappings, @Nullable Map<String, AliasMetaData> aliases) {\n+            this.settings = settings;\n+            this.mappings = mappings;\n+            this.aliases = aliases;\n+        }\n+\n+        Template(StreamInput in) throws IOException {\n+            if (in.readBoolean()) {\n+                this.settings = Settings.readSettingsFromStream(in);\n+            } else {\n+                this.settings = null;\n+            }\n+            if (in.readBoolean()) {\n+                this.mappings = CompressedXContent.readCompressedString(in);\n+            } else {\n+                this.mappings = null;\n+            }\n+            if (in.readBoolean()) {\n+                this.aliases = in.readMap(StreamInput::readString, AliasMetaData::new);\n+            } else {\n+                this.aliases = null;\n+            }\n+        }\n+\n+        public Settings settings() {\n+            return settings;\n+        }\n+\n+        public CompressedXContent mappings() {\n+            return mappings;\n+        }\n+\n+        public Map<String, AliasMetaData> aliases() {\n+            return aliases;\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            if (this.settings == null) {\n+                out.writeBoolean(false);\n+            } else {\n+                out.writeBoolean(true);\n+                Settings.writeSettingsToStream(this.settings, out);\n+            }\n+            if (this.mappings == null) {\n+                out.writeBoolean(false);\n+            } else {\n+                out.writeBoolean(true);\n+                this.mappings.writeTo(out);\n+            }\n+            if (this.aliases == null) {\n+                out.writeBoolean(false);\n+            } else {\n+                out.writeBoolean(true);\n+                out.writeMap(this.aliases, StreamOutput::writeString, (stream, aliasMetaData) -> aliasMetaData.writeTo(stream));\n+            }\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(settings, mappings, aliases);\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (obj == null) {\n+                return false;\n+            }\n+            if (obj.getClass() != getClass()) {\n+                return false;\n+            }\n+            Template other = (Template) obj;\n+            return Objects.equals(settings, other.settings) &&\n+                Objects.equals(mappings, other.mappings) &&\n+                Objects.equals(aliases, other.aliases);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return Strings.toString(this);\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+            builder.startObject();\n+            if (this.settings != null) {\n+                builder.startObject(SETTINGS.getPreferredName());\n+                this.settings.toXContent(builder, params);\n+                builder.endObject();\n+            }\n+            if (this.mappings != null) {\n+                Map<String, Object> uncompressedMapping =\n+                    XContentHelper.convertToMap(new BytesArray(this.mappings.uncompressed()), true, XContentType.JSON).v2();\n+                if (uncompressedMapping.size() > 0) {\n+                    builder.field(MAPPINGS.getPreferredName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "506ea640f4ba6462c844e7e8d8a7f860c40efca8"}, "originalPosition": 285}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxNzQ0MzU1", "url": "https://github.com/elastic/elasticsearch/pull/53290#pullrequestreview-371744355", "createdAt": "2020-03-10T08:11:56Z", "commit": {"oid": "506ea640f4ba6462c844e7e8d8a7f860c40efca8"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQwODoxMTo1NlrOF0EuOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQwODoxNToxOVrOF0EzJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE0NzY0Mw==", "bodyText": "I think that component templates should be stored as custom metadata (like stored scripts or ingest pipelines). This way a lot of the repetitive serialization / diffable code is not needed.", "url": "https://github.com/elastic/elasticsearch/pull/53290#discussion_r390147643", "createdAt": "2020-03-10T08:11:56Z", "author": {"login": "martijnvg"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetaData.java", "diffHunk": "@@ -171,6 +171,7 @@\n     private final DiffableStringMap hashesOfConsistentSettings;\n     private final ImmutableOpenMap<String, IndexMetaData> indices;\n     private final ImmutableOpenMap<String, IndexTemplateMetaData> templates;\n+    private final ImmutableOpenMap<String, ComponentTemplate> componentTemplates;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "506ea640f4ba6462c844e7e8d8a7f860c40efca8"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE0ODkwMQ==", "bodyText": "maybe move this class to its own file (with its own test)? This can then also be reused in the index templates v2 format.", "url": "https://github.com/elastic/elasticsearch/pull/53290#discussion_r390148901", "createdAt": "2020-03-10T08:15:19Z", "author": {"login": "martijnvg"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/ComponentTemplate.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.cluster.metadata;\n+\n+import org.elasticsearch.cluster.AbstractDiffable;\n+import org.elasticsearch.cluster.Diff;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.bytes.BytesArray;\n+import org.elasticsearch.common.compress.CompressedXContent;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.common.xcontent.XContentHelper;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentType;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * A component template is a re-usable template as well as metadata about the template. Each\n+ * component template is expected to be valid on its own. For example, if a component template\n+ * contains a field \"foo\", it's expected to contain all the necessary settings/mappings/etc for the\n+ * \"foo\" field. These component templates make up the individual pieces composing an index template.\n+ */\n+public class ComponentTemplate extends AbstractDiffable<ComponentTemplate> implements ToXContentObject {\n+    private static final ParseField TEMPLATE = new ParseField(\"template\");\n+    private static final ParseField VERSION = new ParseField(\"version\");\n+    private static final ParseField METADATA = new ParseField(\"_meta\");\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static final ConstructingObjectParser<ComponentTemplate, Void> PARSER =\n+        new ConstructingObjectParser<>(\"component_template\", false,\n+            a -> new ComponentTemplate((Template) a[0], (Long) a[1], (Map<String, Object>) a[2]));\n+\n+    static {\n+        PARSER.declareObject(ConstructingObjectParser.constructorArg(), Template.PARSER, TEMPLATE);\n+        PARSER.declareLong(ConstructingObjectParser.optionalConstructorArg(), VERSION);\n+        PARSER.declareObject(ConstructingObjectParser.optionalConstructorArg(), (p, c) -> p.map(), METADATA);\n+    }\n+\n+    private final Template template;\n+    @Nullable\n+    private final Long version;\n+    @Nullable\n+    private final Map<String, Object> metadata;\n+\n+    static Diff<ComponentTemplate> readComponentTemplateDiffFrom(StreamInput in) throws IOException {\n+        return AbstractDiffable.readDiffFrom(ComponentTemplate::new, in);\n+    }\n+\n+    public static ComponentTemplate parse(XContentParser parser) {\n+        return PARSER.apply(parser, null);\n+    }\n+\n+    public ComponentTemplate(Template template, @Nullable Long version, @Nullable Map<String, Object> metadata) {\n+        this.template = template;\n+        this.version = version;\n+        this.metadata = metadata;\n+    }\n+\n+    public ComponentTemplate(StreamInput in) throws IOException {\n+        this.template = new Template(in);\n+        this.version = in.readOptionalVLong();\n+        if (in.readBoolean()) {\n+            this.metadata = in.readMap();\n+        } else {\n+            this.metadata = null;\n+        }\n+    }\n+\n+    public Template template() {\n+        return template;\n+    }\n+\n+    @Nullable\n+    public Long version() {\n+        return version;\n+    }\n+\n+    @Nullable\n+    public Map<String, Object> metadata() {\n+        return metadata;\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        this.template.writeTo(out);\n+        out.writeOptionalVLong(this.version);\n+        if (this.metadata == null) {\n+            out.writeBoolean(false);\n+        } else {\n+            out.writeBoolean(true);\n+            out.writeMap(this.metadata);\n+        }\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(template, version, metadata);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj == null) {\n+            return false;\n+        }\n+        if (obj.getClass() != getClass()) {\n+            return false;\n+        }\n+        ComponentTemplate other = (ComponentTemplate) obj;\n+        return Objects.equals(template, other.template) &&\n+            Objects.equals(version, other.version) &&\n+            Objects.equals(metadata, other.metadata);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return Strings.toString(this);\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject();\n+        builder.field(TEMPLATE.getPreferredName(), this.template);\n+        if (this.version != null) {\n+            builder.field(VERSION.getPreferredName(), this.version);\n+        }\n+        if (this.metadata != null) {\n+            builder.field(METADATA.getPreferredName(), this.metadata);\n+        }\n+        builder.endObject();\n+        return builder;\n+    }\n+\n+    static class Template extends AbstractDiffable<Template> implements ToXContentObject {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "506ea640f4ba6462c844e7e8d8a7f860c40efca8"}, "originalPosition": 161}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "85dfb14a6a3a0fe6b01ece3eb3c2fe1d44d11281", "author": {"user": {"login": "dakrone", "name": "Lee Hinman"}}, "url": "https://github.com/elastic/elasticsearch/commit/85dfb14a6a3a0fe6b01ece3eb3c2fe1d44d11281", "committedDate": "2020-03-11T18:29:51Z", "message": "Introduce ComponentTemplateMetadata as MetaData.Custom class"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "51e744b14e67b3c3407ac0504f946574fbac17f0", "author": {"user": {"login": "dakrone", "name": "Lee Hinman"}}, "url": "https://github.com/elastic/elasticsearch/commit/51e744b14e67b3c3407ac0504f946574fbac17f0", "committedDate": "2020-03-11T18:31:05Z", "message": "Undo line formatting in MetaData"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "faadfd501ee7dff7f4135e3e2d578b8cc7c4b91b", "author": {"user": {"login": "elasticmachine", "name": "Elastic Machine"}}, "url": "https://github.com/elastic/elasticsearch/commit/faadfd501ee7dff7f4135e3e2d578b8cc7c4b91b", "committedDate": "2020-03-11T18:45:30Z", "message": "Merge branch 'master' into itv2-component-templates"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczMzE4MTg4", "url": "https://github.com/elastic/elasticsearch/pull/53290#pullrequestreview-373318188", "createdAt": "2020-03-12T07:07:58Z", "commit": {"oid": "faadfd501ee7dff7f4135e3e2d578b8cc7c4b91b"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQwNzowNzo1OFrOF1TOzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQwNzowNzo1OFrOF1TOzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQzMzkzNQ==", "bodyText": "I don't think this change is needed in the file? Because the new method isn't used?", "url": "https://github.com/elastic/elasticsearch/pull/53290#discussion_r391433935", "createdAt": "2020-03-12T07:07:58Z", "author": {"login": "martijnvg"}, "path": "server/src/main/java/org/elasticsearch/cluster/DiffableUtils.java", "diffHunk": "@@ -148,6 +149,15 @@ private DiffableUtils() {\n         return new ImmutableOpenMapDiff<>(in, keySerializer, new DiffableValueReader<>(reader, diffReader));\n     }\n \n+    /**\n+     * Returns an empty diff for the given key and value serializers\n+     */\n+    public static <K, T extends Diffable<T>> MapDiff<K, T, ImmutableOpenMap<K, T>> emptyOpenMapDiff(KeySerializer<K> keySerializer,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "faadfd501ee7dff7f4135e3e2d578b8cc7c4b91b"}, "originalPosition": 15}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c6d6653a6bc56acc7459924ba370ea228138b6f", "author": {"user": {"login": "dakrone", "name": "Lee Hinman"}}, "url": "https://github.com/elastic/elasticsearch/commit/6c6d6653a6bc56acc7459924ba370ea228138b6f", "committedDate": "2020-03-12T14:08:44Z", "message": "Remove unneeded emptyOpenMapDiff"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "188f4793d957fa2893fee7cb5f95f8554e76d382", "author": {"user": {"login": "elasticmachine", "name": "Elastic Machine"}}, "url": "https://github.com/elastic/elasticsearch/commit/188f4793d957fa2893fee7cb5f95f8554e76d382", "committedDate": "2020-03-12T14:21:18Z", "message": "Merge branch 'master' into itv2-component-templates"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1643, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}