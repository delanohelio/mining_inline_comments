{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU1MjYxMjA5", "number": 60072, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QwMDozNTo0NVrOERRAwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzoyOTo1MVrOERi_QQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NTM5OTY4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QwMDozNTo0NVrOG14zSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDoyOTo0MFrOG7Hryw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE1ODM0NQ==", "bodyText": "To me it feels fragile to put these checks in a method that can be overridden. If an implementor forgets to call super.validate(...) then we would forget to enforce these important constraints. Perhaps we could keep this logic in a higher-level (non-pluggable) class instead.", "url": "https://github.com/elastic/elasticsearch/pull/60072#discussion_r459158345", "createdAt": "2020-07-23T00:35:45Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java", "diffHunk": "@@ -292,6 +292,46 @@ protected FieldMapper clone() {\n         }\n     }\n \n+    @Override\n+    public void validate(DocumentFieldMappers mappers) {\n+        if (this.copyTo() != null && this.copyTo().copyToFields().isEmpty() == false) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4827184df4f069a9d3eac7762ee35536968c948f"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYyMjUyNw==", "bodyText": "We've done this sort of thing a lot in the aggs framework and it has led to some weird methods, doValidate, innerValidate, doInnerValidate and stuff like that. I really wish there were a clean way to force an overrides to call super. Its not something you can force with checkstyle. At least, I don't think it is.", "url": "https://github.com/elastic/elasticsearch/pull/60072#discussion_r459622527", "createdAt": "2020-07-23T17:46:52Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java", "diffHunk": "@@ -292,6 +292,46 @@ protected FieldMapper clone() {\n         }\n     }\n \n+    @Override\n+    public void validate(DocumentFieldMappers mappers) {\n+        if (this.copyTo() != null && this.copyTo().copyToFields().isEmpty() == false) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE1ODM0NQ=="}, "originalCommit": {"oid": "4827184df4f069a9d3eac7762ee35536968c948f"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM1NDEwMw==", "bodyText": "I've made validate final and added a doValidate() subclassable method.", "url": "https://github.com/elastic/elasticsearch/pull/60072#discussion_r464354103", "createdAt": "2020-08-03T11:27:29Z", "author": {"login": "romseygeek"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java", "diffHunk": "@@ -292,6 +292,46 @@ protected FieldMapper clone() {\n         }\n     }\n \n+    @Override\n+    public void validate(DocumentFieldMappers mappers) {\n+        if (this.copyTo() != null && this.copyTo().copyToFields().isEmpty() == false) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE1ODM0NQ=="}, "originalCommit": {"oid": "4827184df4f069a9d3eac7762ee35536968c948f"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYwODYxNA==", "bodyText": "It makes me sad, but if @jtibshirani prefers it that is ok with me.", "url": "https://github.com/elastic/elasticsearch/pull/60072#discussion_r464608614", "createdAt": "2020-08-03T19:09:30Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java", "diffHunk": "@@ -292,6 +292,46 @@ protected FieldMapper clone() {\n         }\n     }\n \n+    @Override\n+    public void validate(DocumentFieldMappers mappers) {\n+        if (this.copyTo() != null && this.copyTo().copyToFields().isEmpty() == false) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE1ODM0NQ=="}, "originalCommit": {"oid": "4827184df4f069a9d3eac7762ee35536968c948f"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYyMDk2NQ==", "bodyText": "I do prefer it as it's more robust. Unfortunately I can't see a cleaner way to handle this. Would smoothing over the naming make you a bit less sad, perhaps using validateOptions instead of doValidate?", "url": "https://github.com/elastic/elasticsearch/pull/60072#discussion_r464620965", "createdAt": "2020-08-03T19:35:59Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java", "diffHunk": "@@ -292,6 +292,46 @@ protected FieldMapper clone() {\n         }\n     }\n \n+    @Override\n+    public void validate(DocumentFieldMappers mappers) {\n+        if (this.copyTo() != null && this.copyTo().copyToFields().isEmpty() == false) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE1ODM0NQ=="}, "originalCommit": {"oid": "4827184df4f069a9d3eac7762ee35536968c948f"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0NTA2Nw==", "bodyText": "Would smoothing over the naming make you a bit less sad, perhaps using validateOptions instead of doValidate?\n\nThe name doesn't really matter. I'll know in my heart that we're doing it because we can't force subclasses to call the superclass implementation. It's cool. Compromise is a way of life.", "url": "https://github.com/elastic/elasticsearch/pull/60072#discussion_r464645067", "createdAt": "2020-08-03T20:29:40Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java", "diffHunk": "@@ -292,6 +292,46 @@ protected FieldMapper clone() {\n         }\n     }\n \n+    @Override\n+    public void validate(DocumentFieldMappers mappers) {\n+        if (this.copyTo() != null && this.copyTo().copyToFields().isEmpty() == false) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE1ODM0NQ=="}, "originalCommit": {"oid": "4827184df4f069a9d3eac7762ee35536968c948f"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NzI1MjY5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/mapper/DocumentFieldMappers.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMzoxMjoyNVrOG2J2gQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNDowODoxMFrOG2MRBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQzNzY5Nw==", "bodyText": "Should this be in FieldAliasMapper?", "url": "https://github.com/elastic/elasticsearch/pull/60072#discussion_r459437697", "createdAt": "2020-07-23T13:12:25Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/DocumentFieldMappers.java", "diffHunk": "@@ -83,4 +123,89 @@ public Analyzer indexAnalyzer() {\n     public Iterator<Mapper> iterator() {\n         return fieldMappers.values().iterator();\n     }\n+\n+    public void checkFieldLimit(long limit) {\n+        if (fieldMappers.size() + objectMappers.size() - metadataFieldCount > limit) {\n+            throw new IllegalArgumentException(\"Limit of total fields [\" + limit + \"] has been exceeded\");\n+        }\n+    }\n+\n+    public void checkObjectDepthLimit(long limit) {\n+        for (String objectPath : objectMappers.keySet()) {\n+            int numDots = 0;\n+            for (int i = 0; i < objectPath.length(); ++i) {\n+                if (objectPath.charAt(i) == '.') {\n+                    numDots += 1;\n+                }\n+            }\n+            final int depth = numDots + 2;\n+            if (depth > limit) {\n+                throw new IllegalArgumentException(\"Limit of mapping depth [\" + limit +\n+                    \"] has been exceeded due to object field [\" + objectPath + \"]\");\n+            }\n+        }\n+    }\n+\n+    public void checkFieldNameLengthLimit(long limit) {\n+        Stream.of(objectMappers.values().stream(), fieldMappers.values().stream())\n+            .reduce(Stream::concat)\n+            .orElseGet(Stream::empty)\n+            .forEach(mapper -> {\n+                String name = mapper.simpleName();\n+                if (name.length() > limit) {\n+                    throw new IllegalArgumentException(\"Field name [\" + name + \"] is longer than the limit of [\" + limit + \"] characters\");\n+                }\n+            });\n+    }\n+\n+    public void checkNestedLimit(long limit) {\n+        long actualNestedFields = 0;\n+        for (ObjectMapper objectMapper : objectMappers.values()) {\n+            if (objectMapper.nested().isNested()) {\n+                actualNestedFields++;\n+            }\n+        }\n+        if (actualNestedFields > limit) {\n+            throw new IllegalArgumentException(\"Limit of nested fields [\" + limit + \"] has been exceeded\");\n+        }\n+    }\n+\n+    public boolean hasNested() {\n+        return hasNested;\n+    }\n+\n+    public Map<String, ObjectMapper> objectMappers() {\n+        return objectMappers;\n+    }\n+\n+    public boolean isAlias(String path) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "423b27618d5967348bfddb1d25b1f1ccf62d8833"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ3NzI1NA==", "bodyText": "++", "url": "https://github.com/elastic/elasticsearch/pull/60072#discussion_r459477254", "createdAt": "2020-07-23T14:08:10Z", "author": {"login": "romseygeek"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/DocumentFieldMappers.java", "diffHunk": "@@ -83,4 +123,89 @@ public Analyzer indexAnalyzer() {\n     public Iterator<Mapper> iterator() {\n         return fieldMappers.values().iterator();\n     }\n+\n+    public void checkFieldLimit(long limit) {\n+        if (fieldMappers.size() + objectMappers.size() - metadataFieldCount > limit) {\n+            throw new IllegalArgumentException(\"Limit of total fields [\" + limit + \"] has been exceeded\");\n+        }\n+    }\n+\n+    public void checkObjectDepthLimit(long limit) {\n+        for (String objectPath : objectMappers.keySet()) {\n+            int numDots = 0;\n+            for (int i = 0; i < objectPath.length(); ++i) {\n+                if (objectPath.charAt(i) == '.') {\n+                    numDots += 1;\n+                }\n+            }\n+            final int depth = numDots + 2;\n+            if (depth > limit) {\n+                throw new IllegalArgumentException(\"Limit of mapping depth [\" + limit +\n+                    \"] has been exceeded due to object field [\" + objectPath + \"]\");\n+            }\n+        }\n+    }\n+\n+    public void checkFieldNameLengthLimit(long limit) {\n+        Stream.of(objectMappers.values().stream(), fieldMappers.values().stream())\n+            .reduce(Stream::concat)\n+            .orElseGet(Stream::empty)\n+            .forEach(mapper -> {\n+                String name = mapper.simpleName();\n+                if (name.length() > limit) {\n+                    throw new IllegalArgumentException(\"Field name [\" + name + \"] is longer than the limit of [\" + limit + \"] characters\");\n+                }\n+            });\n+    }\n+\n+    public void checkNestedLimit(long limit) {\n+        long actualNestedFields = 0;\n+        for (ObjectMapper objectMapper : objectMappers.values()) {\n+            if (objectMapper.nested().isNested()) {\n+                actualNestedFields++;\n+            }\n+        }\n+        if (actualNestedFields > limit) {\n+            throw new IllegalArgumentException(\"Limit of nested fields [\" + limit + \"] has been exceeded\");\n+        }\n+    }\n+\n+    public boolean hasNested() {\n+        return hasNested;\n+    }\n+\n+    public Map<String, ObjectMapper> objectMappers() {\n+        return objectMappers;\n+    }\n+\n+    public boolean isAlias(String path) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQzNzY5Nw=="}, "originalCommit": {"oid": "423b27618d5967348bfddb1d25b1f1ccf62d8833"}, "originalPosition": 145}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NzI1OTkwOnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/elasticsearch/index/mapper/MapperValidatorTests.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMzoxNDoxN1rOG2J64g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNDowODowMlrOG2MQnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQzODgxOA==", "bodyText": "Do you think these should be on tests for the mappers you are validating?", "url": "https://github.com/elastic/elasticsearch/pull/60072#discussion_r459438818", "createdAt": "2020-07-23T13:14:17Z", "author": {"login": "nik9000"}, "path": "server/src/test/java/org/elasticsearch/index/mapper/MapperValidatorTests.java", "diffHunk": "@@ -21,56 +21,60 @@\n import org.elasticsearch.Version;\n import org.elasticsearch.cluster.metadata.IndexMetadata;\n import org.elasticsearch.common.Explicit;\n+import org.elasticsearch.common.lucene.Lucene;\n import org.elasticsearch.common.settings.Settings;\n import org.elasticsearch.test.ESTestCase;\n \n import java.util.Arrays;\n import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n+import java.util.List;\n \n import static java.util.Collections.emptyList;\n import static java.util.Collections.emptyMap;\n import static java.util.Collections.singletonList;\n \n-public class MapperMergeValidatorTests extends ESTestCase {\n+public class MapperValidatorTests extends ESTestCase {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "423b27618d5967348bfddb1d25b1f1ccf62d8833"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ3NzE1MQ==", "bodyText": "They're all for aliases, I'll rename the class to FieldAliasMapperValidationTests - I think it's probably still worth having as a separate class.", "url": "https://github.com/elastic/elasticsearch/pull/60072#discussion_r459477151", "createdAt": "2020-07-23T14:08:02Z", "author": {"login": "romseygeek"}, "path": "server/src/test/java/org/elasticsearch/index/mapper/MapperValidatorTests.java", "diffHunk": "@@ -21,56 +21,60 @@\n import org.elasticsearch.Version;\n import org.elasticsearch.cluster.metadata.IndexMetadata;\n import org.elasticsearch.common.Explicit;\n+import org.elasticsearch.common.lucene.Lucene;\n import org.elasticsearch.common.settings.Settings;\n import org.elasticsearch.test.ESTestCase;\n \n import java.util.Arrays;\n import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n+import java.util.List;\n \n import static java.util.Collections.emptyList;\n import static java.util.Collections.emptyMap;\n import static java.util.Collections.singletonList;\n \n-public class MapperMergeValidatorTests extends ESTestCase {\n+public class MapperValidatorTests extends ESTestCase {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQzODgxOA=="}, "originalCommit": {"oid": "423b27618d5967348bfddb1d25b1f1ccf62d8833"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NzI2MzQ5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/mapper/Mapper.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMzoxNTowOFrOG2J9FA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNDowODoxN1rOG2MRag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQzOTM4MA==", "bodyText": "Probably worth javadoc just because all the mappers are going to have to deal with it.", "url": "https://github.com/elastic/elasticsearch/pull/60072#discussion_r459439380", "createdAt": "2020-07-23T13:15:08Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/Mapper.java", "diffHunk": "@@ -190,4 +190,6 @@ public final String simpleName() {\n      *  Both {@code this} and {@code mergeWith} will be left unmodified. */\n     public abstract Mapper merge(Mapper mergeWith);\n \n+    public abstract void validate(DocumentFieldMappers mappers);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "423b27618d5967348bfddb1d25b1f1ccf62d8833"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ3NzM1NA==", "bodyText": "++", "url": "https://github.com/elastic/elasticsearch/pull/60072#discussion_r459477354", "createdAt": "2020-07-23T14:08:17Z", "author": {"login": "romseygeek"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/Mapper.java", "diffHunk": "@@ -190,4 +190,6 @@ public final String simpleName() {\n      *  Both {@code this} and {@code mergeWith} will be left unmodified. */\n     public abstract Mapper merge(Mapper mergeWith);\n \n+    public abstract void validate(DocumentFieldMappers mappers);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQzOTM4MA=="}, "originalCommit": {"oid": "423b27618d5967348bfddb1d25b1f1ccf62d8833"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2ODE3NDAyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/mapper/DocumentFieldMappers.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNjo0MzoxNVrOG2S26A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxMToyNzo0M1rOG617kw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU4NTI1Ng==", "bodyText": "It would be nice to rework the name DocumentFieldMappers -- it doesn't fit so well now that it contains object mappers, as well as FieldTypeLookup. Maybe something like MappingLookup?", "url": "https://github.com/elastic/elasticsearch/pull/60072#discussion_r459585256", "createdAt": "2020-07-23T16:43:15Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/DocumentFieldMappers.java", "diffHunk": "@@ -27,12 +27,16 @@\n import java.util.HashMap;\n import java.util.Iterator;\n import java.util.Map;\n+import java.util.stream.Stream;\n \n public final class DocumentFieldMappers implements Iterable<Mapper> {\n \n     /** Full field name to mapper */\n     private final Map<String, Mapper> fieldMappers;\n-\n+    private final Map<String, ObjectMapper> objectMappers;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9faebee05dd01681ea4430c75295b6532b796485"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM1NDE5NQ==", "bodyText": "++ to MappingLookup", "url": "https://github.com/elastic/elasticsearch/pull/60072#discussion_r464354195", "createdAt": "2020-08-03T11:27:43Z", "author": {"login": "romseygeek"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/DocumentFieldMappers.java", "diffHunk": "@@ -27,12 +27,16 @@\n import java.util.HashMap;\n import java.util.Iterator;\n import java.util.Map;\n+import java.util.stream.Stream;\n \n public final class DocumentFieldMappers implements Iterable<Mapper> {\n \n     /** Full field name to mapper */\n     private final Map<String, Mapper> fieldMappers;\n-\n+    private final Map<String, ObjectMapper> objectMappers;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU4NTI1Ng=="}, "originalCommit": {"oid": "9faebee05dd01681ea4430c75295b6532b796485"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2ODIzNzc0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/mapper/MapperService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzowMDoyNlrOG2Te8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxMToyNzo1MlrOG6177w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU5NTUwNA==", "bodyText": "Instead of storing these data structures again, MapperService could just delegate to mapper to retrieve field types, etc. That would clarify who actually 'owns' this data.", "url": "https://github.com/elastic/elasticsearch/pull/60072#discussion_r459595504", "createdAt": "2020-07-23T17:00:26Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/MapperService.java", "diffHunk": "@@ -347,67 +341,17 @@ private synchronized DocumentMapper internalMerge(DocumentMapper mapper, MergeRe\n             newMapper = mapper;\n         }\n         newMapper.root().fixRedundantIncludes();\n-\n-        // check basic sanity of the new mapping\n-        List<ObjectMapper> objectMappers = new ArrayList<>();\n-        List<FieldMapper> fieldMappers = new ArrayList<>();\n-        List<FieldAliasMapper> fieldAliasMappers = new ArrayList<>();\n-        MetadataFieldMapper[] metadataMappers = newMapper.mapping().metadataMappers;\n-        Collections.addAll(fieldMappers, metadataMappers);\n-        MapperUtils.collect(newMapper.mapping().root(), objectMappers, fieldMappers, fieldAliasMappers);\n-\n-        MapperMergeValidator.validateNewMappers(objectMappers, fieldMappers, fieldAliasMappers);\n-        checkPartitionedIndexConstraints(newMapper);\n-\n-        // update lookup data-structures\n-        FieldTypeLookup newFieldTypes = new FieldTypeLookup(fieldMappers, fieldAliasMappers);\n-\n-        for (ObjectMapper objectMapper : objectMappers) {\n-            if (fullPathObjectMappers == this.fullPathObjectMappers) {\n-                // first time through the loops\n-                fullPathObjectMappers = new HashMap<>(this.fullPathObjectMappers);\n-            }\n-            fullPathObjectMappers.put(objectMapper.fullPath(), objectMapper);\n-\n-            if (objectMapper.nested().isNested()) {\n-                hasNested = true;\n-            }\n-        }\n-\n-        MapperMergeValidator.validateFieldReferences(fieldMappers, fieldAliasMappers,\n-            fullPathObjectMappers, newFieldTypes, metadataMappers, newMapper);\n-\n-        ContextMapping.validateContextPaths(indexSettings.getIndexVersionCreated(), fieldMappers, newFieldTypes::get);\n-\n-        if (reason != MergeReason.MAPPING_RECOVERY) {\n-            // These checks will only be performed on the master node when an index is created, or\n-            // there is a call to the update mapping API. For all other cases like the master node\n-            // restoring mappings from disk or data nodes deserializing cluster state that was sent\n-            // by the master node, these checks will be skipped.\n-            // Also, don't take metadata mappers into account for the field limit check\n-            checkTotalFieldsLimit(objectMappers.size() + fieldMappers.size() - metadataMappers.length\n-                + fieldAliasMappers.size() );\n-            checkFieldNameSoftLimit(objectMappers, fieldMappers, fieldAliasMappers);\n-            checkNestedFieldsLimit(fullPathObjectMappers);\n-            checkDepthLimit(fullPathObjectMappers.keySet());\n-        }\n-        checkIndexSortCompatibility(indexSettings.getIndexSortConfig(), hasNested);\n+        newMapper.validate(indexSettings, reason != MergeReason.MAPPING_RECOVERY);\n \n         if (reason == MergeReason.MAPPING_UPDATE_PREFLIGHT) {\n             return newMapper;\n         }\n \n-        // only need to immutably rewrap these if the previous reference was changed.\n-        // if not then they are already implicitly immutable.\n-        if (fullPathObjectMappers != this.fullPathObjectMappers) {\n-            fullPathObjectMappers = Collections.unmodifiableMap(fullPathObjectMappers);\n-        }\n-\n         // commit the change\n         this.mapper = newMapper;\n-        this.fieldTypes = newFieldTypes;\n-        this.hasNested = hasNested;\n-        this.fullPathObjectMappers = fullPathObjectMappers;\n+        this.fieldTypes = newMapper.fieldTypes();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9faebee05dd01681ea4430c75295b6532b796485"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM1NDI4Nw==", "bodyText": "++", "url": "https://github.com/elastic/elasticsearch/pull/60072#discussion_r464354287", "createdAt": "2020-08-03T11:27:52Z", "author": {"login": "romseygeek"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/MapperService.java", "diffHunk": "@@ -347,67 +341,17 @@ private synchronized DocumentMapper internalMerge(DocumentMapper mapper, MergeRe\n             newMapper = mapper;\n         }\n         newMapper.root().fixRedundantIncludes();\n-\n-        // check basic sanity of the new mapping\n-        List<ObjectMapper> objectMappers = new ArrayList<>();\n-        List<FieldMapper> fieldMappers = new ArrayList<>();\n-        List<FieldAliasMapper> fieldAliasMappers = new ArrayList<>();\n-        MetadataFieldMapper[] metadataMappers = newMapper.mapping().metadataMappers;\n-        Collections.addAll(fieldMappers, metadataMappers);\n-        MapperUtils.collect(newMapper.mapping().root(), objectMappers, fieldMappers, fieldAliasMappers);\n-\n-        MapperMergeValidator.validateNewMappers(objectMappers, fieldMappers, fieldAliasMappers);\n-        checkPartitionedIndexConstraints(newMapper);\n-\n-        // update lookup data-structures\n-        FieldTypeLookup newFieldTypes = new FieldTypeLookup(fieldMappers, fieldAliasMappers);\n-\n-        for (ObjectMapper objectMapper : objectMappers) {\n-            if (fullPathObjectMappers == this.fullPathObjectMappers) {\n-                // first time through the loops\n-                fullPathObjectMappers = new HashMap<>(this.fullPathObjectMappers);\n-            }\n-            fullPathObjectMappers.put(objectMapper.fullPath(), objectMapper);\n-\n-            if (objectMapper.nested().isNested()) {\n-                hasNested = true;\n-            }\n-        }\n-\n-        MapperMergeValidator.validateFieldReferences(fieldMappers, fieldAliasMappers,\n-            fullPathObjectMappers, newFieldTypes, metadataMappers, newMapper);\n-\n-        ContextMapping.validateContextPaths(indexSettings.getIndexVersionCreated(), fieldMappers, newFieldTypes::get);\n-\n-        if (reason != MergeReason.MAPPING_RECOVERY) {\n-            // These checks will only be performed on the master node when an index is created, or\n-            // there is a call to the update mapping API. For all other cases like the master node\n-            // restoring mappings from disk or data nodes deserializing cluster state that was sent\n-            // by the master node, these checks will be skipped.\n-            // Also, don't take metadata mappers into account for the field limit check\n-            checkTotalFieldsLimit(objectMappers.size() + fieldMappers.size() - metadataMappers.length\n-                + fieldAliasMappers.size() );\n-            checkFieldNameSoftLimit(objectMappers, fieldMappers, fieldAliasMappers);\n-            checkNestedFieldsLimit(fullPathObjectMappers);\n-            checkDepthLimit(fullPathObjectMappers.keySet());\n-        }\n-        checkIndexSortCompatibility(indexSettings.getIndexSortConfig(), hasNested);\n+        newMapper.validate(indexSettings, reason != MergeReason.MAPPING_RECOVERY);\n \n         if (reason == MergeReason.MAPPING_UPDATE_PREFLIGHT) {\n             return newMapper;\n         }\n \n-        // only need to immutably rewrap these if the previous reference was changed.\n-        // if not then they are already implicitly immutable.\n-        if (fullPathObjectMappers != this.fullPathObjectMappers) {\n-            fullPathObjectMappers = Collections.unmodifiableMap(fullPathObjectMappers);\n-        }\n-\n         // commit the change\n         this.mapper = newMapper;\n-        this.fieldTypes = newFieldTypes;\n-        this.hasNested = hasNested;\n-        this.fullPathObjectMappers = fullPathObjectMappers;\n+        this.fieldTypes = newMapper.fieldTypes();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU5NTUwNA=="}, "originalCommit": {"oid": "9faebee05dd01681ea4430c75295b6532b796485"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2ODIzOTI1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/mapper/MetadataFieldMapper.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzowMDo1M1rOG2Tf9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxMToyODowMFrOG618HA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU5NTc2NQ==", "bodyText": "We can also add an @Override to DataStreamTimestampMapper#validate.", "url": "https://github.com/elastic/elasticsearch/pull/60072#discussion_r459595765", "createdAt": "2020-07-23T17:00:53Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/MetadataFieldMapper.java", "diffHunk": "@@ -70,6 +70,7 @@ protected MetadataFieldMapper(FieldType fieldType, MappedFieldType mappedFieldTy\n      * Called when mapping gets merged. Provides the opportunity to validate other fields a metadata field mapper\n      * is supposed to work with before a mapping update is completed.\n      */\n+    @Override", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9faebee05dd01681ea4430c75295b6532b796485"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM1NDMzMg==", "bodyText": "++", "url": "https://github.com/elastic/elasticsearch/pull/60072#discussion_r464354332", "createdAt": "2020-08-03T11:28:00Z", "author": {"login": "romseygeek"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/MetadataFieldMapper.java", "diffHunk": "@@ -70,6 +70,7 @@ protected MetadataFieldMapper(FieldType fieldType, MappedFieldType mappedFieldTy\n      * Called when mapping gets merged. Provides the opportunity to validate other fields a metadata field mapper\n      * is supposed to work with before a mapping update is completed.\n      */\n+    @Override", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU5NTc2NQ=="}, "originalCommit": {"oid": "9faebee05dd01681ea4430c75295b6532b796485"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2ODI3Mzk1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/mapper/DocumentMapper.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzoxMDozMVrOG2T11g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxMToyODoxMVrOG618bA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYwMTM2Ng==", "bodyText": "Small comment, we could expose all these checks as a single method DocumentFieldMappers#checkLimits(IndexSettings settings).", "url": "https://github.com/elastic/elasticsearch/pull/60072#discussion_r459601366", "createdAt": "2020-07-23T17:10:31Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/DocumentMapper.java", "diffHunk": "@@ -306,6 +289,25 @@ public DocumentMapper merge(Mapping mapping, MergeReason reason) {\n         return new DocumentMapper(mapperService, merged);\n     }\n \n+    public void validate(IndexSettings settings, boolean checkLimits) {\n+        this.mapping.validate(this.fieldMappers);\n+        if (settings.getIndexMetadata().isRoutingPartitionedIndex()) {\n+            if (routingFieldMapper().required() == false) {\n+                throw new IllegalArgumentException(\"mapping type [\" + type() + \"] must have routing \"\n+                    + \"required for partitioned index [\" + settings.getIndex().getName() + \"]\");\n+            }\n+        }\n+        if (settings.getIndexSortConfig().hasIndexSort() && hasNestedObjects()) {\n+            throw new IllegalArgumentException(\"cannot have nested fields when index sort is activated\");\n+        }\n+        if (checkLimits) {\n+            this.fieldMappers.checkFieldLimit(settings.getMappingTotalFieldsLimit());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9faebee05dd01681ea4430c75295b6532b796485"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM1NDQxMg==", "bodyText": "++", "url": "https://github.com/elastic/elasticsearch/pull/60072#discussion_r464354412", "createdAt": "2020-08-03T11:28:11Z", "author": {"login": "romseygeek"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/DocumentMapper.java", "diffHunk": "@@ -306,6 +289,25 @@ public DocumentMapper merge(Mapping mapping, MergeReason reason) {\n         return new DocumentMapper(mapperService, merged);\n     }\n \n+    public void validate(IndexSettings settings, boolean checkLimits) {\n+        this.mapping.validate(this.fieldMappers);\n+        if (settings.getIndexMetadata().isRoutingPartitionedIndex()) {\n+            if (routingFieldMapper().required() == false) {\n+                throw new IllegalArgumentException(\"mapping type [\" + type() + \"] must have routing \"\n+                    + \"required for partitioned index [\" + settings.getIndex().getName() + \"]\");\n+            }\n+        }\n+        if (settings.getIndexSortConfig().hasIndexSort() && hasNestedObjects()) {\n+            throw new IllegalArgumentException(\"cannot have nested fields when index sort is activated\");\n+        }\n+        if (checkLimits) {\n+            this.fieldMappers.checkFieldLimit(settings.getMappingTotalFieldsLimit());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYwMTM2Ng=="}, "originalCommit": {"oid": "9faebee05dd01681ea4430c75295b6532b796485"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2ODM0NDk3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/mapper/DocumentFieldMappers.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzoyOTo1MVrOG2UhqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxOTowNDozMlrOG7FUSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYxMjU4NQ==", "bodyText": "Instead of recalculating this, could we pass in the metadata field mappers directly from DocumentMapper?", "url": "https://github.com/elastic/elasticsearch/pull/60072#discussion_r459612585", "createdAt": "2020-07-23T17:29:51Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/DocumentFieldMappers.java", "diffHunk": "@@ -43,22 +47,54 @@ private static void put(Map<String, Analyzer> analyzers, String key, Analyzer va\n     }\n \n     public DocumentFieldMappers(Collection<FieldMapper> mappers,\n+                                Collection<ObjectMapper> objectMappers,\n                                 Collection<FieldAliasMapper> aliasMappers,\n                                 Analyzer defaultIndex) {\n         Map<String, Mapper> fieldMappers = new HashMap<>();\n         Map<String, Analyzer> indexAnalyzers = new HashMap<>();\n+        Map<String, ObjectMapper> objects = new HashMap<>();\n+\n+        boolean hasNested = false;\n+        for (ObjectMapper mapper : objectMappers) {\n+            if (objects.put(mapper.fullPath(), mapper) != null) {\n+                throw new MapperParsingException(\"Object mapper [\" + mapper.fullPath() + \"] is defined more than once\");\n+            }\n+            if (mapper.nested().isNested()) {\n+                hasNested = true;\n+            }\n+        }\n+        this.hasNested = hasNested;\n+\n+        int metadataFieldCount = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9faebee05dd01681ea4430c75295b6532b796485"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM1NTE2OQ==", "bodyText": "I've changed things slightly so that the constructor takes the field count directly, but also added a static factory method that will build a MappingLookup from a Mapper and Analyzer.  This also means that we can move MapperUtils.collect into a private static method on MappingLookup and remove the MapperUtils enum entirely.", "url": "https://github.com/elastic/elasticsearch/pull/60072#discussion_r464355169", "createdAt": "2020-08-03T11:29:59Z", "author": {"login": "romseygeek"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/DocumentFieldMappers.java", "diffHunk": "@@ -43,22 +47,54 @@ private static void put(Map<String, Analyzer> analyzers, String key, Analyzer va\n     }\n \n     public DocumentFieldMappers(Collection<FieldMapper> mappers,\n+                                Collection<ObjectMapper> objectMappers,\n                                 Collection<FieldAliasMapper> aliasMappers,\n                                 Analyzer defaultIndex) {\n         Map<String, Mapper> fieldMappers = new HashMap<>();\n         Map<String, Analyzer> indexAnalyzers = new HashMap<>();\n+        Map<String, ObjectMapper> objects = new HashMap<>();\n+\n+        boolean hasNested = false;\n+        for (ObjectMapper mapper : objectMappers) {\n+            if (objects.put(mapper.fullPath(), mapper) != null) {\n+                throw new MapperParsingException(\"Object mapper [\" + mapper.fullPath() + \"] is defined more than once\");\n+            }\n+            if (mapper.nested().isNested()) {\n+                hasNested = true;\n+            }\n+        }\n+        this.hasNested = hasNested;\n+\n+        int metadataFieldCount = 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYxMjU4NQ=="}, "originalCommit": {"oid": "9faebee05dd01681ea4430c75295b6532b796485"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYwNjI4Mw==", "bodyText": "Great, this turned out nicely.", "url": "https://github.com/elastic/elasticsearch/pull/60072#discussion_r464606283", "createdAt": "2020-08-03T19:04:32Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/DocumentFieldMappers.java", "diffHunk": "@@ -43,22 +47,54 @@ private static void put(Map<String, Analyzer> analyzers, String key, Analyzer va\n     }\n \n     public DocumentFieldMappers(Collection<FieldMapper> mappers,\n+                                Collection<ObjectMapper> objectMappers,\n                                 Collection<FieldAliasMapper> aliasMappers,\n                                 Analyzer defaultIndex) {\n         Map<String, Mapper> fieldMappers = new HashMap<>();\n         Map<String, Analyzer> indexAnalyzers = new HashMap<>();\n+        Map<String, ObjectMapper> objects = new HashMap<>();\n+\n+        boolean hasNested = false;\n+        for (ObjectMapper mapper : objectMappers) {\n+            if (objects.put(mapper.fullPath(), mapper) != null) {\n+                throw new MapperParsingException(\"Object mapper [\" + mapper.fullPath() + \"] is defined more than once\");\n+            }\n+            if (mapper.nested().isNested()) {\n+                hasNested = true;\n+            }\n+        }\n+        this.hasNested = hasNested;\n+\n+        int metadataFieldCount = 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYxMjU4NQ=="}, "originalCommit": {"oid": "9faebee05dd01681ea4430c75295b6532b796485"}, "originalPosition": 40}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2116, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}