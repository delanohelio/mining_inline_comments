{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc4Njk2NTg0", "number": 52680, "title": "Adds resiliency to read-only filesystems #45286", "bodyText": "Fixes read only file system, part of the overall proposal for #45286\nPending\n\n Finalisation on TODOs\n API Backward compatibility\n Covering missing cases\n Unit and Integration tests", "createdAt": "2020-02-23T11:45:38Z", "url": "https://github.com/elastic/elasticsearch/pull/52680", "merged": true, "mergeCommit": {"oid": "ef4cdb0303fd4578250073eea4c47e9737186fe3"}, "closed": true, "closedAt": "2020-07-07T10:33:27Z", "author": {"login": "Bukhtawar"}, "timelineItems": {"totalCount": 60, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABa7u7OlAH2gAyMzc4Njk2NTg0OjU2OWU4Y2NkMGQ3MjlmMDE3NzgzYjM2ZjU1ODcyZWNkNDM2MWI0ZmU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcyjPY_gFqTQ0Mzc2MTQwOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "569e8ccd0d729f017783b36f55872ecd4361b4fe", "author": {"user": {"login": "Bukhtawar", "name": "Bukhtawar Khan"}}, "url": "https://github.com/elastic/elasticsearch/commit/569e8ccd0d729f017783b36f55872ecd4361b4fe", "committedDate": "2019-07-04T06:45:38Z", "message": "Merge pull request #2 from elastic/master\n\nRebase from fork"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "64815f13a38bb47ac0cc5188f15e0b0ba3b27ebd", "author": {"user": {"login": "Bukhtawar", "name": "Bukhtawar Khan"}}, "url": "https://github.com/elastic/elasticsearch/commit/64815f13a38bb47ac0cc5188f15e0b0ba3b27ebd", "committedDate": "2020-02-22T18:16:13Z", "message": "Merge remote-tracking branch 'upstream/master'"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b598944ca305f803b27c817e860133ebfd1a7d78", "author": {"user": {"login": "Bukhtawar", "name": "Bukhtawar Khan"}}, "url": "https://github.com/elastic/elasticsearch/commit/b598944ca305f803b27c817e860133ebfd1a7d78", "committedDate": "2020-02-23T11:37:45Z", "message": " [Initial DRAFT] Adds a FsHealthService that periodically tries to write to all paths and emits a stats is_writable as a part of node stats API.\n FsReadOnlyMonitor pulls up the stats and tries to remove the node if not all paths are found to be writable.\n Addresses #45286."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzMjI5NzEy", "url": "https://github.com/elastic/elasticsearch/pull/52680#pullrequestreview-363229712", "createdAt": "2020-02-24T08:46:40Z", "commit": {"oid": "b598944ca305f803b27c817e860133ebfd1a7d78"}, "state": "DISMISSED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQwODo0Njo0MFrOFtYvWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQwOTo1NDo1NlrOFtaqZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEzNTU3Nw==", "bodyText": "This (and the extensions to ClusterInfoService) seem unnecessary. It would be preferable for the FollowersChecker to report a node as unhealthy directly.", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r383135577", "createdAt": "2020-02-24T08:46:40Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsReadOnlyMonitor.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import com.carrotsearch.hppc.cursors.ObjectObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.cluster.*;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.node.DiscoveryNodes;\n+import org.elasticsearch.common.collect.ImmutableOpenMap;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.BiConsumer;\n+import java.util.function.Supplier;\n+\n+/**\n+ * Monitor runs on master and listens for events from #ClusterInfoService on node stats. It checks to see if\n+ * a node has all paths writable if not removes the node from the cluster based on the setting monitor.fs.unhealthy.remove_enabled\n+ */\n+public class FsReadOnlyMonitor {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b598944ca305f803b27c817e860133ebfd1a7d78"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEzNjQxMg==", "bodyText": "This is too weak a check IMO. It doesn't write any data or fsync anything.", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r383136412", "createdAt": "2020-02-24T08:48:52Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.LongSupplier;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private volatile TimeValue refreshInterval;\n+    private volatile TimeValue healthcheckTimeoutInterval;\n+    private final NodeEnvironment nodeEnv;\n+    private final LongSupplier currentTimeMillisSupplier;\n+    private AtomicLong lastSuccessfulRunTimeMillis = new AtomicLong(Long.MIN_VALUE);\n+    private Map<Path, Status> pathHealthStats;\n+    private volatile Scheduler.Cancellable scheduledFuture;\n+\n+    enum Status { HEALTHY, UNHEALTHY, UNKNOWN }\n+\n+    public static final Setting<Boolean> ENABLED_SETTING =\n+        Setting.boolSetting(\"monitor.fs.health.enabled\", true, Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> REFRESH_INTERVAL_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.refresh_interval\", TimeValue.timeValueSeconds(5), TimeValue.timeValueSeconds(1),\n+            Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> HEALTHCHECK_TIMEOUT_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.unhealthy_timeout\", TimeValue.timeValueMinutes(5), TimeValue.timeValueMinutes(2),\n+            Setting.Property.NodeScope, Setting.Property.Dynamic);\n+\n+\n+    FsHealthService(Settings settings, ClusterSettings clusterSettings, ThreadPool threadPool, NodeEnvironment nodeEnv,\n+                    LongSupplier currentTimeMillisSupplier) {\n+        this.threadPool = threadPool;\n+        this.enabled = ENABLED_SETTING.get(settings);\n+        this.refreshInterval = REFRESH_INTERVAL_SETTING.get(settings);\n+        this.healthcheckTimeoutInterval = HEALTHCHECK_TIMEOUT_SETTING.get(settings);\n+        this.currentTimeMillisSupplier = currentTimeMillisSupplier;\n+        this.nodeEnv = nodeEnv;\n+        this.pathHealthStats = new HashMap<>();\n+        clusterSettings.addSettingsUpdateConsumer(REFRESH_INTERVAL_SETTING, this::setRefreshInterval);\n+        clusterSettings.addSettingsUpdateConsumer(HEALTHCHECK_TIMEOUT_SETTING, this::setHealthcheckTimeoutInterval);\n+        clusterSettings.addSettingsUpdateConsumer(ENABLED_SETTING, this::setEnabled);\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        //TODO check if this needs to be a part of a dedicated threadpool\n+        scheduledFuture = threadPool.scheduleWithFixedDelay(new FsHealthMonitor(), refreshInterval, ThreadPool.Names.SAME);\n+    }\n+\n+\n+    @Override\n+    protected void doStop() {\n+        scheduledFuture.cancel();\n+    }\n+\n+    @Override\n+    protected void doClose() throws IOException {\n+\n+    }\n+\n+    public void setEnabled(boolean enabled) {\n+        this.enabled = enabled;\n+    }\n+\n+    public void setRefreshInterval(TimeValue refreshInterval) {\n+        this.refreshInterval = refreshInterval;\n+    }\n+\n+    public void setHealthcheckTimeoutInterval(TimeValue healthcheckTimeoutInterval) {\n+        this.healthcheckTimeoutInterval = healthcheckTimeoutInterval;\n+    }\n+\n+    public Boolean isWritable(Path path){\n+        if (!enabled){\n+            return null;\n+        }\n+        Status status = pathHealthStats.getOrDefault(path, Status.UNKNOWN);\n+        if (status == Status.UNHEALTHY)\n+            return Boolean.FALSE;\n+        else if (lastSuccessfulRunTimeMillis.get() < currentTimeMillisSupplier.getAsLong() - healthcheckTimeoutInterval.getMillis()){\n+            return Boolean.FALSE;\n+        }\n+        return Boolean.TRUE;\n+    }\n+\n+    private class FsHealthMonitor implements Runnable {\n+\n+        private static final String TEMP_FILE_NAME = \".es_temp_file\";\n+\n+        @Override\n+        public void run() {\n+            try {\n+                if (enabled) {\n+                    monitorFSHealth();\n+                    logger.debug(\"Monitor for disk health ran successfully {}\", pathHealthStats);\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"Exception monitoring disk health\", e);\n+            }\n+        }\n+\n+        private void monitorFSHealth(){\n+\n+            Map<Path, Status> pathHealthStats = new HashMap<>();\n+            try {\n+                for (Path path : nodeEnv.nodeDataPaths()) {\n+                    try {\n+                        if (Files.exists(path)) {\n+                            Path resolve = path.resolve(TEMP_FILE_NAME);\n+                            // delete any lingering file from a previous failure\n+                            Files.deleteIfExists(resolve);\n+                            Files.createFile(resolve);\n+                            Files.delete(resolve);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b598944ca305f803b27c817e860133ebfd1a7d78"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEzNjcyNA==", "bodyText": "I don't understand why we don't count this as UNHEALTHY too. Can you explain?", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r383136724", "createdAt": "2020-02-24T08:49:45Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.LongSupplier;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private volatile TimeValue refreshInterval;\n+    private volatile TimeValue healthcheckTimeoutInterval;\n+    private final NodeEnvironment nodeEnv;\n+    private final LongSupplier currentTimeMillisSupplier;\n+    private AtomicLong lastSuccessfulRunTimeMillis = new AtomicLong(Long.MIN_VALUE);\n+    private Map<Path, Status> pathHealthStats;\n+    private volatile Scheduler.Cancellable scheduledFuture;\n+\n+    enum Status { HEALTHY, UNHEALTHY, UNKNOWN }\n+\n+    public static final Setting<Boolean> ENABLED_SETTING =\n+        Setting.boolSetting(\"monitor.fs.health.enabled\", true, Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> REFRESH_INTERVAL_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.refresh_interval\", TimeValue.timeValueSeconds(5), TimeValue.timeValueSeconds(1),\n+            Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> HEALTHCHECK_TIMEOUT_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.unhealthy_timeout\", TimeValue.timeValueMinutes(5), TimeValue.timeValueMinutes(2),\n+            Setting.Property.NodeScope, Setting.Property.Dynamic);\n+\n+\n+    FsHealthService(Settings settings, ClusterSettings clusterSettings, ThreadPool threadPool, NodeEnvironment nodeEnv,\n+                    LongSupplier currentTimeMillisSupplier) {\n+        this.threadPool = threadPool;\n+        this.enabled = ENABLED_SETTING.get(settings);\n+        this.refreshInterval = REFRESH_INTERVAL_SETTING.get(settings);\n+        this.healthcheckTimeoutInterval = HEALTHCHECK_TIMEOUT_SETTING.get(settings);\n+        this.currentTimeMillisSupplier = currentTimeMillisSupplier;\n+        this.nodeEnv = nodeEnv;\n+        this.pathHealthStats = new HashMap<>();\n+        clusterSettings.addSettingsUpdateConsumer(REFRESH_INTERVAL_SETTING, this::setRefreshInterval);\n+        clusterSettings.addSettingsUpdateConsumer(HEALTHCHECK_TIMEOUT_SETTING, this::setHealthcheckTimeoutInterval);\n+        clusterSettings.addSettingsUpdateConsumer(ENABLED_SETTING, this::setEnabled);\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        //TODO check if this needs to be a part of a dedicated threadpool\n+        scheduledFuture = threadPool.scheduleWithFixedDelay(new FsHealthMonitor(), refreshInterval, ThreadPool.Names.SAME);\n+    }\n+\n+\n+    @Override\n+    protected void doStop() {\n+        scheduledFuture.cancel();\n+    }\n+\n+    @Override\n+    protected void doClose() throws IOException {\n+\n+    }\n+\n+    public void setEnabled(boolean enabled) {\n+        this.enabled = enabled;\n+    }\n+\n+    public void setRefreshInterval(TimeValue refreshInterval) {\n+        this.refreshInterval = refreshInterval;\n+    }\n+\n+    public void setHealthcheckTimeoutInterval(TimeValue healthcheckTimeoutInterval) {\n+        this.healthcheckTimeoutInterval = healthcheckTimeoutInterval;\n+    }\n+\n+    public Boolean isWritable(Path path){\n+        if (!enabled){\n+            return null;\n+        }\n+        Status status = pathHealthStats.getOrDefault(path, Status.UNKNOWN);\n+        if (status == Status.UNHEALTHY)\n+            return Boolean.FALSE;\n+        else if (lastSuccessfulRunTimeMillis.get() < currentTimeMillisSupplier.getAsLong() - healthcheckTimeoutInterval.getMillis()){\n+            return Boolean.FALSE;\n+        }\n+        return Boolean.TRUE;\n+    }\n+\n+    private class FsHealthMonitor implements Runnable {\n+\n+        private static final String TEMP_FILE_NAME = \".es_temp_file\";\n+\n+        @Override\n+        public void run() {\n+            try {\n+                if (enabled) {\n+                    monitorFSHealth();\n+                    logger.debug(\"Monitor for disk health ran successfully {}\", pathHealthStats);\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"Exception monitoring disk health\", e);\n+            }\n+        }\n+\n+        private void monitorFSHealth(){\n+\n+            Map<Path, Status> pathHealthStats = new HashMap<>();\n+            try {\n+                for (Path path : nodeEnv.nodeDataPaths()) {\n+                    try {\n+                        if (Files.exists(path)) {\n+                            Path resolve = path.resolve(TEMP_FILE_NAME);\n+                            // delete any lingering file from a previous failure\n+                            Files.deleteIfExists(resolve);\n+                            Files.createFile(resolve);\n+                            Files.delete(resolve);\n+                            pathHealthStats.put(path, Status.HEALTHY);\n+                        }\n+                    }catch(IOException ex){\n+                        logger.error(\"Failed to perform writes on path {} due to {}\", path, ex);\n+                        pathHealthStats.put(path, Status.UNHEALTHY);\n+                    } catch(Exception ex){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b598944ca305f803b27c817e860133ebfd1a7d78"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE2MTIzOQ==", "bodyText": "5 minutes seems a very long timeout to me. Do we really want to consider a node healthy if it's taking literally minutes to pass this simple check?\nI also think we should be stricter about the UNHEALTHY -> HEALTHY transition to try and avoid flapping. What about keeping the node UNHEALTHY until the check passes very quickly (~1 second?)", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r383161239", "createdAt": "2020-02-24T09:43:52Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.LongSupplier;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private volatile TimeValue refreshInterval;\n+    private volatile TimeValue healthcheckTimeoutInterval;\n+    private final NodeEnvironment nodeEnv;\n+    private final LongSupplier currentTimeMillisSupplier;\n+    private AtomicLong lastSuccessfulRunTimeMillis = new AtomicLong(Long.MIN_VALUE);\n+    private Map<Path, Status> pathHealthStats;\n+    private volatile Scheduler.Cancellable scheduledFuture;\n+\n+    enum Status { HEALTHY, UNHEALTHY, UNKNOWN }\n+\n+    public static final Setting<Boolean> ENABLED_SETTING =\n+        Setting.boolSetting(\"monitor.fs.health.enabled\", true, Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> REFRESH_INTERVAL_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.refresh_interval\", TimeValue.timeValueSeconds(5), TimeValue.timeValueSeconds(1),\n+            Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> HEALTHCHECK_TIMEOUT_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.unhealthy_timeout\", TimeValue.timeValueMinutes(5), TimeValue.timeValueMinutes(2),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b598944ca305f803b27c817e860133ebfd1a7d78"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE2NzA3Nw==", "bodyText": "I think this should not be on the SAME threadpool since it's doing IO that's potentially slow. GENERIC would be ok, but then I think we need protection to make sure there's only one check running at once.", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r383167077", "createdAt": "2020-02-24T09:54:56Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.LongSupplier;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private volatile TimeValue refreshInterval;\n+    private volatile TimeValue healthcheckTimeoutInterval;\n+    private final NodeEnvironment nodeEnv;\n+    private final LongSupplier currentTimeMillisSupplier;\n+    private AtomicLong lastSuccessfulRunTimeMillis = new AtomicLong(Long.MIN_VALUE);\n+    private Map<Path, Status> pathHealthStats;\n+    private volatile Scheduler.Cancellable scheduledFuture;\n+\n+    enum Status { HEALTHY, UNHEALTHY, UNKNOWN }\n+\n+    public static final Setting<Boolean> ENABLED_SETTING =\n+        Setting.boolSetting(\"monitor.fs.health.enabled\", true, Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> REFRESH_INTERVAL_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.refresh_interval\", TimeValue.timeValueSeconds(5), TimeValue.timeValueSeconds(1),\n+            Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> HEALTHCHECK_TIMEOUT_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.unhealthy_timeout\", TimeValue.timeValueMinutes(5), TimeValue.timeValueMinutes(2),\n+            Setting.Property.NodeScope, Setting.Property.Dynamic);\n+\n+\n+    FsHealthService(Settings settings, ClusterSettings clusterSettings, ThreadPool threadPool, NodeEnvironment nodeEnv,\n+                    LongSupplier currentTimeMillisSupplier) {\n+        this.threadPool = threadPool;\n+        this.enabled = ENABLED_SETTING.get(settings);\n+        this.refreshInterval = REFRESH_INTERVAL_SETTING.get(settings);\n+        this.healthcheckTimeoutInterval = HEALTHCHECK_TIMEOUT_SETTING.get(settings);\n+        this.currentTimeMillisSupplier = currentTimeMillisSupplier;\n+        this.nodeEnv = nodeEnv;\n+        this.pathHealthStats = new HashMap<>();\n+        clusterSettings.addSettingsUpdateConsumer(REFRESH_INTERVAL_SETTING, this::setRefreshInterval);\n+        clusterSettings.addSettingsUpdateConsumer(HEALTHCHECK_TIMEOUT_SETTING, this::setHealthcheckTimeoutInterval);\n+        clusterSettings.addSettingsUpdateConsumer(ENABLED_SETTING, this::setEnabled);\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        //TODO check if this needs to be a part of a dedicated threadpool\n+        scheduledFuture = threadPool.scheduleWithFixedDelay(new FsHealthMonitor(), refreshInterval, ThreadPool.Names.SAME);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b598944ca305f803b27c817e860133ebfd1a7d78"}, "originalPosition": 88}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d4fb892602213f62cff1c191eea3ddb3d2f9f8c8", "author": {"user": {"login": "Bukhtawar", "name": "Bukhtawar Khan"}}, "url": "https://github.com/elastic/elasticsearch/commit/d4fb892602213f62cff1c191eea3ddb3d2f9f8c8", "committedDate": "2020-03-25T13:35:02Z", "message": "Test case addition and PR comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "38f1a4eabe9952b98d138322c4faa5a88b204a68", "author": {"user": {"login": "Bukhtawar", "name": "Bukhtawar Khan"}}, "url": "https://github.com/elastic/elasticsearch/commit/38f1a4eabe9952b98d138322c4faa5a88b204a68", "committedDate": "2020-03-25T13:56:53Z", "message": "Merge remote-tracking branch 'upstream/master'"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f3ac906bb0a67da98c5070a80085e3e2ab435b26", "author": {"user": {"login": "Bukhtawar", "name": "Bukhtawar Khan"}}, "url": "https://github.com/elastic/elasticsearch/commit/f3ac906bb0a67da98c5070a80085e3e2ab435b26", "committedDate": "2020-03-25T14:03:45Z", "message": "Merge branch 'master' into ro-fs-handling"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "79948f3fc5938a837696bdfda98b186d1c81d2b5", "author": {"user": {"login": "Bukhtawar", "name": "Bukhtawar Khan"}}, "url": "https://github.com/elastic/elasticsearch/commit/79948f3fc5938a837696bdfda98b186d1c81d2b5", "committedDate": "2020-03-25T18:08:26Z", "message": "Changes for FsHealthService and tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgxNDIxNjcy", "url": "https://github.com/elastic/elasticsearch/pull/52680#pullrequestreview-381421672", "createdAt": "2020-03-25T18:24:04Z", "commit": {"oid": "79948f3fc5938a837696bdfda98b186d1c81d2b5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxODoyNDowNFrOF7onSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxODoyNDowNFrOF7onSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA3NTcyMg==", "bodyText": "Accidentally removed the test. I'll add it back", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r398075722", "createdAt": "2020-03-25T18:24:04Z", "author": {"login": "Bukhtawar"}, "path": "server/src/test/java/org/elasticsearch/cluster/coordination/PreVoteCollectorTests.java", "diffHunk": "@@ -165,11 +184,14 @@ public void testStartsElectionIfOtherNodeIsQuorum() {\n         assertTrue(electionOccurred);\n     }\n \n-    public void testDoesNotStartsElectionIfOtherNodeIsQuorumAndDoesNotRespond() {\n+    public void testNonWritableNodeDoesNotOfferPreVote() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79948f3fc5938a837696bdfda98b186d1c81d2b5"}, "originalPosition": 73}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgxNDIzMjQ2", "url": "https://github.com/elastic/elasticsearch/pull/52680#pullrequestreview-381423246", "createdAt": "2020-03-25T18:26:08Z", "commit": {"oid": "79948f3fc5938a837696bdfda98b186d1c81d2b5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxODoyNjowOFrOF7osJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxODoyNjowOFrOF7osJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA3Njk2Ng==", "bodyText": "I have left out spaces assuming checkStyles would catch. But unfortunate. I'll fix white spacing", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r398076966", "createdAt": "2020-03-25T18:26:08Z", "author": {"login": "Bukhtawar"}, "path": "server/src/main/java/org/elasticsearch/cluster/coordination/Coordinator.java", "diffHunk": "@@ -1173,6 +1179,12 @@ public void run() {\n                             return;\n                         }\n \n+                        if(fsService.stats().getTotal().isWritable() == Boolean.FALSE){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79948f3fc5938a837696bdfda98b186d1c81d2b5"}, "originalPosition": 73}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2MjU4NDQ5", "url": "https://github.com/elastic/elasticsearch/pull/52680#pullrequestreview-396258449", "createdAt": "2020-04-20T08:50:10Z", "commit": {"oid": "79948f3fc5938a837696bdfda98b186d1c81d2b5"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwODo1MDoxMFrOGIJ9uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwOTowMjowNVrOGIKcww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIwNTA1MQ==", "bodyText": "These tests are very weak, they simply override the checks that FsHealthService performs which means we're not really checking its behaviour at all.\nI would prefer to see tests that use a custom FileSystemProvider to inject failures that the real FsHealthService can detect. Most should use a DeterministicTaskQueue to verify that the checks keep on being scheduled at the right times, without needing to wait for timeouts to occur. Since we also want to detect things hanging I think we'll also need a genuinely multithreaded test with short timeouts to show that we do indeed detect that IO hangs.", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r411205051", "createdAt": "2020-04-20T08:50:10Z", "author": {"login": "DaveCTurner"}, "path": "server/src/test/java/org/elasticsearch/monitor/fs/FsHealthServiceTests.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.TestThreadPool;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.LongSupplier;\n+\n+import static org.mockito.Mockito.mock;\n+\n+\n+public class FsHealthServiceTests extends ESTestCase {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79948f3fc5938a837696bdfda98b186d1c81d2b5"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIwNzMzNw==", "bodyText": "This doesn't seem necessary, it's enough for followers to reject the today's health checks.", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r411207337", "createdAt": "2020-04-20T08:53:42Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/cluster/coordination/NodeFsHealthChecker.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.cluster.coordination;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.admin.cluster.node.stats.NodeStats;\n+import org.elasticsearch.action.admin.cluster.node.stats.NodesStatsRequest;\n+import org.elasticsearch.action.admin.cluster.node.stats.NodesStatsResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.common.TriConsumer;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.monitor.fs.FsHealthService;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.ReceiveTimeoutTransportException;\n+import org.elasticsearch.transport.TransportService;\n+\n+import java.util.Set;\n+import java.util.function.Supplier;\n+\n+public class NodeFsHealthChecker {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79948f3fc5938a837696bdfda98b186d1c81d2b5"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIwOTQwMw==", "bodyText": "I don't think we should add this to the stats -- we aim to remove read-only nodes from the cluster, so this will effectively always be true when collecting stats.", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r411209403", "createdAt": "2020-04-20T08:56:46Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsInfo.java", "diffHunk": "@@ -48,16 +48,19 @@\n         long total = -1;\n         long free = -1;\n         long available = -1;\n+        @Nullable\n+        Boolean isWritable;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79948f3fc5938a837696bdfda98b186d1c81d2b5"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIxMDU3MA==", "bodyText": "I think we only need to schedule one task which loops through all paths itself. There's no need to check them in parallel like this.", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r411210570", "createdAt": "2020-04-20T08:58:37Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.core.internal.io.IOUtils;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.LongSupplier;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private volatile TimeValue refreshInterval;\n+    private volatile TimeValue healthCheckTimeoutInterval;\n+    private final NodeEnvironment nodeEnv;\n+    private final LongSupplier currentTimeMillisSupplier;\n+    private Map<Path, TimeStampedStatus> pathHealthStats;\n+    private volatile Set<Scheduler.Cancellable> scheduledFutures;\n+\n+    enum Status { HEALTHY, UNHEALTHY, UNKNOWN }\n+\n+    public static final Setting<Boolean> ENABLED_SETTING =\n+        Setting.boolSetting(\"monitor.fs.health.enabled\", true, Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> REFRESH_INTERVAL_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.refresh_interval\", TimeValue.timeValueSeconds(1), TimeValue.timeValueSeconds(1),\n+            Setting.Property.NodeScope);\n+    public static final Setting<TimeValue> HEALTHY_TIMEOUT_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.healthy_timeout\", TimeValue.timeValueSeconds(1), TimeValue.timeValueSeconds(1),\n+            Setting.Property.NodeScope, Setting.Property.Dynamic);\n+\n+    FsHealthService(Settings settings, ClusterSettings clusterSettings, ThreadPool threadPool, NodeEnvironment nodeEnv,\n+                    LongSupplier currentTimeMillisSupplier) {\n+        this.scheduledFutures = new HashSet<>();\n+        this.threadPool = threadPool;\n+        this.enabled = ENABLED_SETTING.get(settings);\n+        this.refreshInterval = REFRESH_INTERVAL_SETTING.get(settings);\n+        this.healthCheckTimeoutInterval = HEALTHY_TIMEOUT_SETTING.get(settings);\n+        this.currentTimeMillisSupplier = currentTimeMillisSupplier;\n+        this.nodeEnv = nodeEnv;\n+        this.pathHealthStats = new HashMap<>();\n+        clusterSettings.addSettingsUpdateConsumer(HEALTHY_TIMEOUT_SETTING, this::setHealthCheckTimeoutInterval);\n+        clusterSettings.addSettingsUpdateConsumer(ENABLED_SETTING, this::setEnabled);\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        for (Path path : nodeEnv.nodeDataPaths()) {\n+            scheduledFutures.add(threadPool.scheduleWithFixedDelay(new FsPathHealthMonitor(path), refreshInterval,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79948f3fc5938a837696bdfda98b186d1c81d2b5"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIxMjk5NQ==", "bodyText": "This seems unnecessarily detailed. I think we only really need to keep track of the time of the last successful check.", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r411212995", "createdAt": "2020-04-20T09:02:05Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.core.internal.io.IOUtils;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.LongSupplier;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private volatile TimeValue refreshInterval;\n+    private volatile TimeValue healthCheckTimeoutInterval;\n+    private final NodeEnvironment nodeEnv;\n+    private final LongSupplier currentTimeMillisSupplier;\n+    private Map<Path, TimeStampedStatus> pathHealthStats;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79948f3fc5938a837696bdfda98b186d1c81d2b5"}, "originalPosition": 61}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "20d9ba2374db52764f4bff520d375d5a3aa21bec", "author": {"user": {"login": "Bukhtawar", "name": "Bukhtawar Khan"}}, "url": "https://github.com/elastic/elasticsearch/commit/20d9ba2374db52764f4bff520d375d5a3aa21bec", "committedDate": "2020-05-03T10:50:04Z", "message": "Review comments for simplication and better tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa3ed380323c163bf0131cb4193b06b671f775ef", "author": {"user": {"login": "Bukhtawar", "name": "Bukhtawar Khan"}}, "url": "https://github.com/elastic/elasticsearch/commit/fa3ed380323c163bf0131cb4193b06b671f775ef", "committedDate": "2020-05-03T10:53:08Z", "message": "Merge remote-tracking branch 'upstream/master'"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1646319e6613f7baef5779c62d451bca9ed0bce0", "author": {"user": {"login": "Bukhtawar", "name": "Bukhtawar Khan"}}, "url": "https://github.com/elastic/elasticsearch/commit/1646319e6613f7baef5779c62d451bca9ed0bce0", "committedDate": "2020-05-03T16:03:52Z", "message": "Merge branch 'master' into ro-fs-handling"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5305ebb1b39a812f7d64dae67889750bb311355a", "author": {"user": {"login": "Bukhtawar", "name": "Bukhtawar Khan"}}, "url": "https://github.com/elastic/elasticsearch/commit/5305ebb1b39a812f7d64dae67889750bb311355a", "committedDate": "2020-05-03T23:22:04Z", "message": "Fixing tests and check styles"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1MTIxNjA4", "url": "https://github.com/elastic/elasticsearch/pull/52680#pullrequestreview-405121608", "createdAt": "2020-05-04T15:55:50Z", "commit": {"oid": "5305ebb1b39a812f7d64dae67889750bb311355a"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNTo1NTo1MFrOGQGzHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNjozMToyNVrOGQISbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU0MTc4OA==", "bodyText": "Suggest collapsing UNKNOWN with HEALTHY, there's no need to distinguish these cases IMO.", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r419541788", "createdAt": "2020-05-04T15:55:50Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/monitor/NodeHealthService.java", "diffHunk": "@@ -0,0 +1,28 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor;\n+\n+@FunctionalInterface\n+public interface NodeHealthService {\n+\n+    enum Status { HEALTHY, UNHEALTHY, UNKNOWN }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5305ebb1b39a812f7d64dae67889750bb311355a"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU0NTg1Ng==", "bodyText": "I checked a few example systems in production and it seems like it's not that unusual to see delays of a few 10s of seconds that eventually succeed. This is common enough that I think it would be bad to start failing nodes in those cases by default. I will follow up with some of my systems engineering colleagues to agree on a sensible default here, but 1s is certainly too low.\nAlso a reminder about having a shorter timeout for the UNHEALTHY -> HEALTHY transition vs the HEALTHY -> UNHEALTHY one, mentioned first here: #52680 (comment)", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r419545856", "createdAt": "2020-05-04T16:01:32Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.core.internal.io.IOUtils;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.monitor.NodeHealthService;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.LongSupplier;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent implements NodeHealthService {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private volatile TimeValue refreshInterval;\n+    private volatile TimeValue healthCheckTimeoutInterval;\n+    private final NodeEnvironment nodeEnv;\n+    private final LongSupplier currentTimeMillisSupplier;\n+    private Map<Path, Status> pathHealthStats;\n+    private volatile Scheduler.Cancellable scheduledFuture;\n+    private final AtomicLong lastRunTimeMillis = new AtomicLong();\n+    private AtomicBoolean checkInProgress = new AtomicBoolean();\n+\n+\n+    public static final Setting<Boolean> ENABLED_SETTING =\n+        Setting.boolSetting(\"monitor.fs.health.enabled\", true, Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> REFRESH_INTERVAL_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.refresh_interval\", TimeValue.timeValueSeconds(1), TimeValue.timeValueMillis(10),\n+            Setting.Property.NodeScope);\n+    public static final Setting<TimeValue> HEALTHY_TIMEOUT_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.healthy_timeout\", TimeValue.timeValueSeconds(1), TimeValue.timeValueMillis(1),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5305ebb1b39a812f7d64dae67889750bb311355a"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU0NjE4Nw==", "bodyText": "I think Status.HEALTHY is fine here.", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r419546187", "createdAt": "2020-05-04T16:01:59Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.core.internal.io.IOUtils;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.monitor.NodeHealthService;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.LongSupplier;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent implements NodeHealthService {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private volatile TimeValue refreshInterval;\n+    private volatile TimeValue healthCheckTimeoutInterval;\n+    private final NodeEnvironment nodeEnv;\n+    private final LongSupplier currentTimeMillisSupplier;\n+    private Map<Path, Status> pathHealthStats;\n+    private volatile Scheduler.Cancellable scheduledFuture;\n+    private final AtomicLong lastRunTimeMillis = new AtomicLong();\n+    private AtomicBoolean checkInProgress = new AtomicBoolean();\n+\n+\n+    public static final Setting<Boolean> ENABLED_SETTING =\n+        Setting.boolSetting(\"monitor.fs.health.enabled\", true, Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> REFRESH_INTERVAL_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.refresh_interval\", TimeValue.timeValueSeconds(1), TimeValue.timeValueMillis(10),\n+            Setting.Property.NodeScope);\n+    public static final Setting<TimeValue> HEALTHY_TIMEOUT_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.healthy_timeout\", TimeValue.timeValueSeconds(1), TimeValue.timeValueMillis(1),\n+            Setting.Property.NodeScope, Setting.Property.Dynamic);\n+\n+    public FsHealthService(Settings settings, ClusterSettings clusterSettings, ThreadPool threadPool, NodeEnvironment nodeEnv) {\n+        this.threadPool = threadPool;\n+        this.enabled = ENABLED_SETTING.get(settings);\n+        this.refreshInterval = REFRESH_INTERVAL_SETTING.get(settings);\n+        this.healthCheckTimeoutInterval = HEALTHY_TIMEOUT_SETTING.get(settings);\n+        this.currentTimeMillisSupplier = threadPool::relativeTimeInMillis;\n+        this.nodeEnv = nodeEnv;\n+        this.pathHealthStats = new HashMap<>(1);\n+        clusterSettings.addSettingsUpdateConsumer(HEALTHY_TIMEOUT_SETTING, this::setHealthCheckTimeoutInterval);\n+        clusterSettings.addSettingsUpdateConsumer(ENABLED_SETTING, this::setEnabled);\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        scheduledFuture = threadPool.scheduleWithFixedDelay(new FsHealthMonitor(), refreshInterval,\n+                ThreadPool.Names.GENERIC);\n+    }\n+\n+\n+    @Override\n+    protected void doStop() {\n+        scheduledFuture.cancel();\n+    }\n+\n+    @Override\n+    protected void doClose() throws IOException {\n+\n+    }\n+\n+    public void setEnabled(boolean enabled) { this.enabled = enabled; }\n+\n+\n+    public void setHealthCheckTimeoutInterval(TimeValue healthCheckTimeoutInterval) {\n+        this.healthCheckTimeoutInterval = healthCheckTimeoutInterval;\n+    }\n+\n+    @Override\n+    public Status getHealth() {\n+        if (enabled == false) {\n+            return Status.UNKNOWN;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5305ebb1b39a812f7d64dae67889750bb311355a"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU0ODU3Mw==", "bodyText": "If this individual check saw no exceptions but took longer than the timeout interval then I don't think we should record it as a successful run as is done here, since that will result in a fatally-slow node still occasionally reporting itself as healthy, joining the cluster, and then failing again.", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r419548573", "createdAt": "2020-05-04T16:05:34Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.core.internal.io.IOUtils;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.monitor.NodeHealthService;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.LongSupplier;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent implements NodeHealthService {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private volatile TimeValue refreshInterval;\n+    private volatile TimeValue healthCheckTimeoutInterval;\n+    private final NodeEnvironment nodeEnv;\n+    private final LongSupplier currentTimeMillisSupplier;\n+    private Map<Path, Status> pathHealthStats;\n+    private volatile Scheduler.Cancellable scheduledFuture;\n+    private final AtomicLong lastRunTimeMillis = new AtomicLong();\n+    private AtomicBoolean checkInProgress = new AtomicBoolean();\n+\n+\n+    public static final Setting<Boolean> ENABLED_SETTING =\n+        Setting.boolSetting(\"monitor.fs.health.enabled\", true, Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> REFRESH_INTERVAL_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.refresh_interval\", TimeValue.timeValueSeconds(1), TimeValue.timeValueMillis(10),\n+            Setting.Property.NodeScope);\n+    public static final Setting<TimeValue> HEALTHY_TIMEOUT_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.healthy_timeout\", TimeValue.timeValueSeconds(1), TimeValue.timeValueMillis(1),\n+            Setting.Property.NodeScope, Setting.Property.Dynamic);\n+\n+    public FsHealthService(Settings settings, ClusterSettings clusterSettings, ThreadPool threadPool, NodeEnvironment nodeEnv) {\n+        this.threadPool = threadPool;\n+        this.enabled = ENABLED_SETTING.get(settings);\n+        this.refreshInterval = REFRESH_INTERVAL_SETTING.get(settings);\n+        this.healthCheckTimeoutInterval = HEALTHY_TIMEOUT_SETTING.get(settings);\n+        this.currentTimeMillisSupplier = threadPool::relativeTimeInMillis;\n+        this.nodeEnv = nodeEnv;\n+        this.pathHealthStats = new HashMap<>(1);\n+        clusterSettings.addSettingsUpdateConsumer(HEALTHY_TIMEOUT_SETTING, this::setHealthCheckTimeoutInterval);\n+        clusterSettings.addSettingsUpdateConsumer(ENABLED_SETTING, this::setEnabled);\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        scheduledFuture = threadPool.scheduleWithFixedDelay(new FsHealthMonitor(), refreshInterval,\n+                ThreadPool.Names.GENERIC);\n+    }\n+\n+\n+    @Override\n+    protected void doStop() {\n+        scheduledFuture.cancel();\n+    }\n+\n+    @Override\n+    protected void doClose() throws IOException {\n+\n+    }\n+\n+    public void setEnabled(boolean enabled) { this.enabled = enabled; }\n+\n+\n+    public void setHealthCheckTimeoutInterval(TimeValue healthCheckTimeoutInterval) {\n+        this.healthCheckTimeoutInterval = healthCheckTimeoutInterval;\n+    }\n+\n+    @Override\n+    public Status getHealth() {\n+        if (enabled == false) {\n+            return Status.UNKNOWN;\n+        }\n+        else if ((currentTimeMillisSupplier.getAsLong() - lastRunTimeMillis.get()) >\n+            (refreshInterval.millis() + healthCheckTimeoutInterval.millis())) {\n+            return Status.UNHEALTHY;\n+        }\n+        return pathHealthStats.entrySet().stream().anyMatch(map -> map.getValue() == Status.UNHEALTHY) ? Status.UNHEALTHY\n+            : Status.HEALTHY;\n+    }\n+\n+     class FsHealthMonitor implements Runnable {\n+\n+        static final String TEMP_FILE_NAME = \".es_temp_file\";\n+        private byte[] byteToWrite;\n+\n+        FsHealthMonitor(){\n+            this.byteToWrite = new byte[20];\n+        }\n+        @Override\n+        public void run() {\n+            try {\n+                if (enabled) {\n+                    monitorFSHealth();\n+                    logger.debug(\"Monitor for disk health ran successfully {}\", pathHealthStats);\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"Exception monitoring disk health\", e);\n+            }\n+        }\n+\n+        private void monitorFSHealth() {\n+            if (checkInProgress.compareAndSet(false, true) == false) {\n+                logger.warn(\"Skipping Monitor for disk health as a check is already in progress\");\n+                return;\n+            }\n+            for (Path path : nodeEnv.nodeDataPaths()) {\n+                try {\n+                    if (Files.exists(path)) {\n+                        Path tempDataPath = path.resolve(TEMP_FILE_NAME);\n+                        Files.deleteIfExists(tempDataPath);\n+                        try (OutputStream os = Files.newOutputStream(tempDataPath, StandardOpenOption.CREATE_NEW)) {\n+                            new Random().nextBytes(byteToWrite);\n+                            os.write(byteToWrite);\n+                            IOUtils.fsync(tempDataPath, false);\n+                            pathHealthStats.put(path, Status.HEALTHY);\n+                        }\n+                        Files.delete(tempDataPath);\n+                    }\n+                } catch (Exception ex) {\n+                    logger.error(\"Failed to perform writes on path {} due to {}\", path, ex);\n+                    pathHealthStats.put(path,  Status.UNHEALTHY);\n+                }\n+            }\n+            lastRunTimeMillis.getAndUpdate(l -> Math.max(l, currentTimeMillisSupplier.getAsLong()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5305ebb1b39a812f7d64dae67889750bb311355a"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU1NDU5MA==", "bodyText": "I would like us to log when we become unhealthy in this service rather than relying on its clients logging warnings/errors, since I am concerned that the clients' messages may be hard to interpret and they vary a lot which will make analysis a good deal harder. That means I think we'll need to schedule a timeout handler for each check. It would be mightily useful if that log message were to include which path(s) were faulty, and how long it took to check each path.\nI'd also like us to log when a check takes longer than some threshold (say, 10s by default) but not long enough to fail the node. This kind of sub-threshold warning can be a useful leading indicator of impending doom. See e.g. cluster.publish.info_timeout vs cluster.publish.timeout.", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r419554590", "createdAt": "2020-05-04T16:14:07Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.core.internal.io.IOUtils;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.monitor.NodeHealthService;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.LongSupplier;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent implements NodeHealthService {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5305ebb1b39a812f7d64dae67889750bb311355a"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2MjcyNA==", "bodyText": "Also why Math.max? I think that currentTimeMillisSupplier is ThreadPool#relativeTimeInMillis which is monotonic.", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r419562724", "createdAt": "2020-05-04T16:26:10Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.core.internal.io.IOUtils;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.monitor.NodeHealthService;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.LongSupplier;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent implements NodeHealthService {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private volatile TimeValue refreshInterval;\n+    private volatile TimeValue healthCheckTimeoutInterval;\n+    private final NodeEnvironment nodeEnv;\n+    private final LongSupplier currentTimeMillisSupplier;\n+    private Map<Path, Status> pathHealthStats;\n+    private volatile Scheduler.Cancellable scheduledFuture;\n+    private final AtomicLong lastRunTimeMillis = new AtomicLong();\n+    private AtomicBoolean checkInProgress = new AtomicBoolean();\n+\n+\n+    public static final Setting<Boolean> ENABLED_SETTING =\n+        Setting.boolSetting(\"monitor.fs.health.enabled\", true, Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> REFRESH_INTERVAL_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.refresh_interval\", TimeValue.timeValueSeconds(1), TimeValue.timeValueMillis(10),\n+            Setting.Property.NodeScope);\n+    public static final Setting<TimeValue> HEALTHY_TIMEOUT_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.healthy_timeout\", TimeValue.timeValueSeconds(1), TimeValue.timeValueMillis(1),\n+            Setting.Property.NodeScope, Setting.Property.Dynamic);\n+\n+    public FsHealthService(Settings settings, ClusterSettings clusterSettings, ThreadPool threadPool, NodeEnvironment nodeEnv) {\n+        this.threadPool = threadPool;\n+        this.enabled = ENABLED_SETTING.get(settings);\n+        this.refreshInterval = REFRESH_INTERVAL_SETTING.get(settings);\n+        this.healthCheckTimeoutInterval = HEALTHY_TIMEOUT_SETTING.get(settings);\n+        this.currentTimeMillisSupplier = threadPool::relativeTimeInMillis;\n+        this.nodeEnv = nodeEnv;\n+        this.pathHealthStats = new HashMap<>(1);\n+        clusterSettings.addSettingsUpdateConsumer(HEALTHY_TIMEOUT_SETTING, this::setHealthCheckTimeoutInterval);\n+        clusterSettings.addSettingsUpdateConsumer(ENABLED_SETTING, this::setEnabled);\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        scheduledFuture = threadPool.scheduleWithFixedDelay(new FsHealthMonitor(), refreshInterval,\n+                ThreadPool.Names.GENERIC);\n+    }\n+\n+\n+    @Override\n+    protected void doStop() {\n+        scheduledFuture.cancel();\n+    }\n+\n+    @Override\n+    protected void doClose() throws IOException {\n+\n+    }\n+\n+    public void setEnabled(boolean enabled) { this.enabled = enabled; }\n+\n+\n+    public void setHealthCheckTimeoutInterval(TimeValue healthCheckTimeoutInterval) {\n+        this.healthCheckTimeoutInterval = healthCheckTimeoutInterval;\n+    }\n+\n+    @Override\n+    public Status getHealth() {\n+        if (enabled == false) {\n+            return Status.UNKNOWN;\n+        }\n+        else if ((currentTimeMillisSupplier.getAsLong() - lastRunTimeMillis.get()) >\n+            (refreshInterval.millis() + healthCheckTimeoutInterval.millis())) {\n+            return Status.UNHEALTHY;\n+        }\n+        return pathHealthStats.entrySet().stream().anyMatch(map -> map.getValue() == Status.UNHEALTHY) ? Status.UNHEALTHY\n+            : Status.HEALTHY;\n+    }\n+\n+     class FsHealthMonitor implements Runnable {\n+\n+        static final String TEMP_FILE_NAME = \".es_temp_file\";\n+        private byte[] byteToWrite;\n+\n+        FsHealthMonitor(){\n+            this.byteToWrite = new byte[20];\n+        }\n+        @Override\n+        public void run() {\n+            try {\n+                if (enabled) {\n+                    monitorFSHealth();\n+                    logger.debug(\"Monitor for disk health ran successfully {}\", pathHealthStats);\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"Exception monitoring disk health\", e);\n+            }\n+        }\n+\n+        private void monitorFSHealth() {\n+            if (checkInProgress.compareAndSet(false, true) == false) {\n+                logger.warn(\"Skipping Monitor for disk health as a check is already in progress\");\n+                return;\n+            }\n+            for (Path path : nodeEnv.nodeDataPaths()) {\n+                try {\n+                    if (Files.exists(path)) {\n+                        Path tempDataPath = path.resolve(TEMP_FILE_NAME);\n+                        Files.deleteIfExists(tempDataPath);\n+                        try (OutputStream os = Files.newOutputStream(tempDataPath, StandardOpenOption.CREATE_NEW)) {\n+                            new Random().nextBytes(byteToWrite);\n+                            os.write(byteToWrite);\n+                            IOUtils.fsync(tempDataPath, false);\n+                            pathHealthStats.put(path, Status.HEALTHY);\n+                        }\n+                        Files.delete(tempDataPath);\n+                    }\n+                } catch (Exception ex) {\n+                    logger.error(\"Failed to perform writes on path {} due to {}\", path, ex);\n+                    pathHealthStats.put(path,  Status.UNHEALTHY);\n+                }\n+            }\n+            lastRunTimeMillis.getAndUpdate(l -> Math.max(l, currentTimeMillisSupplier.getAsLong()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5305ebb1b39a812f7d64dae67889750bb311355a"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NDQ2MQ==", "bodyText": "Can that happen? I think threadPool.scheduleWithFixedDelay avoids this?", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r419564461", "createdAt": "2020-05-04T16:28:44Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.core.internal.io.IOUtils;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.monitor.NodeHealthService;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.LongSupplier;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent implements NodeHealthService {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private volatile TimeValue refreshInterval;\n+    private volatile TimeValue healthCheckTimeoutInterval;\n+    private final NodeEnvironment nodeEnv;\n+    private final LongSupplier currentTimeMillisSupplier;\n+    private Map<Path, Status> pathHealthStats;\n+    private volatile Scheduler.Cancellable scheduledFuture;\n+    private final AtomicLong lastRunTimeMillis = new AtomicLong();\n+    private AtomicBoolean checkInProgress = new AtomicBoolean();\n+\n+\n+    public static final Setting<Boolean> ENABLED_SETTING =\n+        Setting.boolSetting(\"monitor.fs.health.enabled\", true, Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> REFRESH_INTERVAL_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.refresh_interval\", TimeValue.timeValueSeconds(1), TimeValue.timeValueMillis(10),\n+            Setting.Property.NodeScope);\n+    public static final Setting<TimeValue> HEALTHY_TIMEOUT_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.healthy_timeout\", TimeValue.timeValueSeconds(1), TimeValue.timeValueMillis(1),\n+            Setting.Property.NodeScope, Setting.Property.Dynamic);\n+\n+    public FsHealthService(Settings settings, ClusterSettings clusterSettings, ThreadPool threadPool, NodeEnvironment nodeEnv) {\n+        this.threadPool = threadPool;\n+        this.enabled = ENABLED_SETTING.get(settings);\n+        this.refreshInterval = REFRESH_INTERVAL_SETTING.get(settings);\n+        this.healthCheckTimeoutInterval = HEALTHY_TIMEOUT_SETTING.get(settings);\n+        this.currentTimeMillisSupplier = threadPool::relativeTimeInMillis;\n+        this.nodeEnv = nodeEnv;\n+        this.pathHealthStats = new HashMap<>(1);\n+        clusterSettings.addSettingsUpdateConsumer(HEALTHY_TIMEOUT_SETTING, this::setHealthCheckTimeoutInterval);\n+        clusterSettings.addSettingsUpdateConsumer(ENABLED_SETTING, this::setEnabled);\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        scheduledFuture = threadPool.scheduleWithFixedDelay(new FsHealthMonitor(), refreshInterval,\n+                ThreadPool.Names.GENERIC);\n+    }\n+\n+\n+    @Override\n+    protected void doStop() {\n+        scheduledFuture.cancel();\n+    }\n+\n+    @Override\n+    protected void doClose() throws IOException {\n+\n+    }\n+\n+    public void setEnabled(boolean enabled) { this.enabled = enabled; }\n+\n+\n+    public void setHealthCheckTimeoutInterval(TimeValue healthCheckTimeoutInterval) {\n+        this.healthCheckTimeoutInterval = healthCheckTimeoutInterval;\n+    }\n+\n+    @Override\n+    public Status getHealth() {\n+        if (enabled == false) {\n+            return Status.UNKNOWN;\n+        }\n+        else if ((currentTimeMillisSupplier.getAsLong() - lastRunTimeMillis.get()) >\n+            (refreshInterval.millis() + healthCheckTimeoutInterval.millis())) {\n+            return Status.UNHEALTHY;\n+        }\n+        return pathHealthStats.entrySet().stream().anyMatch(map -> map.getValue() == Status.UNHEALTHY) ? Status.UNHEALTHY\n+            : Status.HEALTHY;\n+    }\n+\n+     class FsHealthMonitor implements Runnable {\n+\n+        static final String TEMP_FILE_NAME = \".es_temp_file\";\n+        private byte[] byteToWrite;\n+\n+        FsHealthMonitor(){\n+            this.byteToWrite = new byte[20];\n+        }\n+        @Override\n+        public void run() {\n+            try {\n+                if (enabled) {\n+                    monitorFSHealth();\n+                    logger.debug(\"Monitor for disk health ran successfully {}\", pathHealthStats);\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"Exception monitoring disk health\", e);\n+            }\n+        }\n+\n+        private void monitorFSHealth() {\n+            if (checkInProgress.compareAndSet(false, true) == false) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5305ebb1b39a812f7d64dae67889750bb311355a"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NTIzNA==", "bodyText": "Nit: \"health check\" is two words:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class FsHealthcheckFailureException extends ElasticsearchException {\n          \n          \n            \n            public class FsHealthCheckFailureException extends ElasticsearchException {", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r419565234", "createdAt": "2020-05-04T16:29:57Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/cluster/coordination/FsHealthcheckFailureException.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.cluster.coordination;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+\n+import java.io.IOException;\n+\n+/**\n+ * This exception is thrown if the File system is reported unhealthy by @{@link org.elasticsearch.monitor.fs.FsHealthService}\n+ * and this nodes needs to be removed from the cluster\n+ */\n+\n+public class FsHealthcheckFailureException extends ElasticsearchException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5305ebb1b39a812f7d64dae67889750bb311355a"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NjE4OA==", "bodyText": "nit: two words\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    FS_HEALTHCHECK_FAILURE_EXCEPTION(org.elasticsearch.cluster.coordination.FsHealthcheckFailureException.class,\n          \n          \n            \n                    FS_HEALTH_CHECK_FAILURE_EXCEPTION(org.elasticsearch.cluster.coordination.FsHealthCheckFailureException.class,", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r419566188", "createdAt": "2020-05-04T16:31:25Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/ElasticsearchException.java", "diffHunk": "@@ -1041,7 +1041,9 @@ public String toString() {\n                 org.elasticsearch.ingest.IngestProcessorException.class,\n                 org.elasticsearch.ingest.IngestProcessorException::new,\n                 157,\n-                Version.V_7_5_0);\n+                Version.V_7_5_0),\n+        FS_HEALTHCHECK_FAILURE_EXCEPTION(org.elasticsearch.cluster.coordination.FsHealthcheckFailureException.class,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5305ebb1b39a812f7d64dae67889750bb311355a"}, "originalPosition": 6}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "26fbce7f91d6fa9c34e39ceab9d9d0f0e375f2b9", "author": {"user": {"login": "Bukhtawar", "name": "Bukhtawar Khan"}}, "url": "https://github.com/elastic/elasticsearch/commit/26fbce7f91d6fa9c34e39ceab9d9d0f0e375f2b9", "committedDate": "2020-05-05T14:49:44Z", "message": "FsHealthService comments on slow IO"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8a8605145cd69f1bab3c7f66121714df7aa6a5c2", "author": {"user": {"login": "Bukhtawar", "name": "Bukhtawar Khan"}}, "url": "https://github.com/elastic/elasticsearch/commit/8a8605145cd69f1bab3c7f66121714df7aa6a5c2", "committedDate": "2020-05-11T12:12:18Z", "message": "Restricting FS health checks to IOExceptions"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEzNjg5Njkz", "url": "https://github.com/elastic/elasticsearch/pull/52680#pullrequestreview-413689693", "createdAt": "2020-05-18T15:12:11Z", "commit": {"oid": "8a8605145cd69f1bab3c7f66121714df7aa6a5c2"}, "state": "COMMENTED", "comments": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNToxMjoxMVrOGW7qGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNTo1MTowNlrOGW9TmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY5OTI5MA==", "bodyText": "Please format this like the other declarations:\n\nmultiple lines\nfully-qualified class names rather than an import\nno trailing comma", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r426699290", "createdAt": "2020-05-18T15:12:11Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/ElasticsearchException.java", "diffHunk": "@@ -1041,7 +1042,9 @@ public String toString() {\n                 org.elasticsearch.ingest.IngestProcessorException.class,\n                 org.elasticsearch.ingest.IngestProcessorException::new,\n                 157,\n-                Version.V_7_5_0);\n+                Version.V_7_5_0),\n+        FS_HEALTH_CHECK_FAILURE_EXCEPTION(FsHealthCheckFailureException.class,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a8605145cd69f1bab3c7f66121714df7aa6a5c2"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcwMDQ5OA==", "bodyText": "A warning here isn't helpful, we should be logging the failure elsewhere so this will simply result in confusion.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        logger.warn(\"skip prevoting as local node is not writable: {}\",\n          \n          \n            \n                                        logger.debug(\"skip prevoting as local node is not writable: {}\",\n          \n      \n    \n    \n  \n\nAlso, we have this generic NodeHealthService but the log message is very specific: local node is not writeable. Maybe the NodeHealthService should describe the problem rather than returning a simple boolean.", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r426700498", "createdAt": "2020-05-18T15:13:52Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/cluster/coordination/Coordinator.java", "diffHunk": "@@ -1197,6 +1202,12 @@ public void run() {\n                             return;\n                         }\n \n+                        if (nodeHealthService.getHealth() == NodeHealthService.Status.UNHEALTHY) {\n+                            logger.warn(\"skip prevoting as local node is not writable: {}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a8605145cd69f1bab3c7f66121714df7aa6a5c2"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcwMTA0Mg==", "bodyText": "An error here isn't helpful, we should be logging the failure elsewhere so this will simply result in confusion.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.error(\"Rejecting health check request {} as all data paths are not writable\", request);\n          \n          \n            \n                        logger.debug(\"Rejecting health check request {} as all data paths are not writable\", request);\n          \n      \n    \n    \n  \n\nAlso, we have this generic NodeHealthService but the log message is very specific: all data paths are not writable. Maybe the NodeHealthService should describe the problem rather than returning a simple boolean. Possibly makes sense to construct the exception within the NodeHealthService.", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r426701042", "createdAt": "2020-05-18T15:14:36Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/cluster/coordination/FollowersChecker.java", "diffHunk": "@@ -160,8 +162,12 @@ public void updateFastResponseState(final long term, final Mode mode) {\n     }\n \n     private void handleFollowerCheck(FollowerCheckRequest request, TransportChannel transportChannel) throws IOException {\n-        FastResponseState responder = this.fastResponseState;\n+        if (nodeHealthService.getHealth() == NodeHealthService.Status.UNHEALTHY) {\n+            logger.error(\"Rejecting health check request {} as all data paths are not writable\", request);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a8605145cd69f1bab3c7f66121714df7aa6a5c2"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcwMzMwMw==", "bodyText": "Suggest removing this from the message, it's not relevant for the exception.", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r426703303", "createdAt": "2020-05-18T15:17:49Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/cluster/coordination/FollowersChecker.java", "diffHunk": "@@ -160,8 +162,12 @@ public void updateFastResponseState(final long term, final Mode mode) {\n     }\n \n     private void handleFollowerCheck(FollowerCheckRequest request, TransportChannel transportChannel) throws IOException {\n-        FastResponseState responder = this.fastResponseState;\n+        if (nodeHealthService.getHealth() == NodeHealthService.Status.UNHEALTHY) {\n+            logger.error(\"Rejecting health check request {} as all data paths are not writable\", request);\n+            throw new FsHealthCheckFailureException(\"rejecting \" + request + \" since not all paths are writable \" + this);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a8605145cd69f1bab3c7f66121714df7aa6a5c2"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcwMzY5NA==", "bodyText": "A warning here isn't helpful, we should be logging the failure elsewhere so this will simply result in confusion.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.warn(\"All paths are not writable. Blocking join request\");\n          \n          \n            \n                        logger.debug(\"All paths are not writable. Blocking join request\");\n          \n      \n    \n    \n  \n\nAlso, we have this generic NodeHealthService but the log message is very specific: all paths are not writable. Maybe the NodeHealthService should describe the problem rather than returning a simple boolean.", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r426703694", "createdAt": "2020-05-18T15:18:27Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/cluster/coordination/JoinHelper.java", "diffHunk": "@@ -232,6 +237,10 @@ void logLastFailedJoinAttempt() {\n \n     public void sendJoinRequest(DiscoveryNode destination, long term, Optional<Join> optionalJoin) {\n         assert destination.isMasterNode() : \"trying to join master-ineligible \" + destination;\n+        if (nodeHealthService.getHealth() == NodeHealthService.Status.UNHEALTHY) {\n+            logger.warn(\"All paths are not writable. Blocking join request\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a8605145cd69f1bab3c7f66121714df7aa6a5c2"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcwNzIyNw==", "bodyText": "A warning here isn't helpful, we should be logging the failure elsewhere so this will simply result in confusion.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.warn(\"Reject offering pre-vote as all paths are not writable\");\n          \n          \n            \n                        logger.debug(\"Reject offering pre-vote as all paths are not writable\");\n          \n      \n    \n    \n  \n\nAlso, we have this generic NodeHealthService but the log message is very specific: all data paths are not writable. Maybe the NodeHealthService should describe the problem rather than returning a simple boolean. Possibly makes sense to construct the exception within the NodeHealthService.", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r426707227", "createdAt": "2020-05-18T15:23:31Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/cluster/coordination/PreVoteCollector.java", "diffHunk": "@@ -105,6 +108,12 @@ private PreVoteResponse handlePreVoteRequest(final PreVoteRequest request) {\n         final DiscoveryNode leader = state.v1();\n         final PreVoteResponse response = state.v2();\n \n+        //TODO verify if the placement makes sense\n+        if (nodeHealthService.getHealth() == NodeHealthService.Status.UNHEALTHY) {\n+            logger.warn(\"Reject offering pre-vote as all paths are not writable\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a8605145cd69f1bab3c7f66121714df7aa6a5c2"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcxNTgzNw==", "bodyText": "This spawns (and hopefully cancels) a lot of tasks each iteration. Given that we're not considering timing out here, let's just log at the end of each path's check if it was slow. This has the added advantage that we can report exactly how long it took, not just that it took >5s.", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r426715837", "createdAt": "2020-05-18T15:36:07Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.Level;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.core.internal.io.IOUtils;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.monitor.NodeHealthService;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.LongSupplier;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent implements NodeHealthService {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private volatile TimeValue refreshInterval;\n+    private volatile TimeValue slowPathLoggingThreshold;\n+    private final NodeEnvironment nodeEnv;\n+    private final LongSupplier currentTimeMillisSupplier;\n+    private Map<Path, Status> pathHealthStats;\n+    private volatile Scheduler.Cancellable scheduledFuture;\n+    private volatile Scheduler.Cancellable slowPathHealthCheckTimeoutHandler;\n+    private final AtomicLong lastRunTimeMillis = new AtomicLong();\n+\n+    public static final Setting<Boolean> ENABLED_SETTING =\n+        Setting.boolSetting(\"monitor.fs.health.enabled\", true, Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> REFRESH_INTERVAL_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.refresh_interval\", TimeValue.timeValueSeconds(1), TimeValue.timeValueMillis(1),\n+            Setting.Property.NodeScope);\n+    public static final Setting<TimeValue> SLOW_PATH_LOGGING_THRESHOLD_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.slow_path_logging_threshold\", TimeValue.timeValueSeconds(5), TimeValue.timeValueMillis(1),\n+            Setting.Property.NodeScope, Setting.Property.Dynamic);\n+\n+\n+    public FsHealthService(Settings settings, ClusterSettings clusterSettings, ThreadPool threadPool, NodeEnvironment nodeEnv) {\n+        this.threadPool = threadPool;\n+        this.enabled = ENABLED_SETTING.get(settings);\n+        this.refreshInterval = REFRESH_INTERVAL_SETTING.get(settings);\n+        this.slowPathLoggingThreshold = SLOW_PATH_LOGGING_THRESHOLD_SETTING.get(settings);\n+        this.currentTimeMillisSupplier = threadPool::relativeTimeInMillis;\n+        this.nodeEnv = nodeEnv;\n+        this.pathHealthStats = new HashMap<>(1);\n+        clusterSettings.addSettingsUpdateConsumer(SLOW_PATH_LOGGING_THRESHOLD_SETTING, this::setSlowPathLoggingThreshold);\n+        clusterSettings.addSettingsUpdateConsumer(ENABLED_SETTING, this::setEnabled);\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        scheduledFuture = threadPool.scheduleWithFixedDelay(new FsHealthMonitor(), refreshInterval,\n+                ThreadPool.Names.GENERIC);\n+    }\n+\n+\n+    @Override\n+    protected void doStop() {\n+        scheduledFuture.cancel();\n+        slowPathHealthCheckTimeoutHandler.cancel();\n+    }\n+\n+    @Override\n+    protected void doClose() throws IOException {\n+\n+    }\n+\n+    public void setEnabled(boolean enabled) { this.enabled = enabled; }\n+\n+    public void setSlowPathLoggingThreshold(TimeValue slowPathLoggingThreshold) {\n+        this.slowPathLoggingThreshold = slowPathLoggingThreshold;\n+    }\n+\n+    @Override\n+    public Status getHealth() {\n+        if (enabled == false) {\n+            return Status.HEALTHY;\n+        }\n+        return pathHealthStats.entrySet().stream().anyMatch(map -> map.getValue() == Status.UNHEALTHY) ? Status.UNHEALTHY\n+            : Status.HEALTHY;\n+    }\n+\n+     class FsHealthMonitor implements Runnable {\n+\n+        static final String TEMP_FILE_NAME = \".es_temp_file\";\n+        private byte[] byteToWrite;\n+\n+        FsHealthMonitor(){\n+            this.byteToWrite = new byte[20];\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                if (enabled) {\n+                    monitorFSHealth();\n+                    logger.debug(\"Monitor for FS health ran successfully {}\", pathHealthStats);\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"Exception monitoring FS health\", e);\n+            }\n+        }\n+\n+        private void monitorFSHealth() {\n+            for (Path path : nodeEnv.nodeDataPaths()) {\n+                long executionStartTime = currentTimeMillisSupplier.getAsLong();\n+                slowPathHealthCheckTimeoutHandler = threadPool.schedule(new Runnable() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a8605145cd69f1bab3c7f66121714df7aa6a5c2"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcxNjE0MQ==", "bodyText": "Is this used? I think we can drop it.", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r426716141", "createdAt": "2020-05-18T15:36:32Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.Level;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.core.internal.io.IOUtils;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.monitor.NodeHealthService;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.LongSupplier;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent implements NodeHealthService {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private volatile TimeValue refreshInterval;\n+    private volatile TimeValue slowPathLoggingThreshold;\n+    private final NodeEnvironment nodeEnv;\n+    private final LongSupplier currentTimeMillisSupplier;\n+    private Map<Path, Status> pathHealthStats;\n+    private volatile Scheduler.Cancellable scheduledFuture;\n+    private volatile Scheduler.Cancellable slowPathHealthCheckTimeoutHandler;\n+    private final AtomicLong lastRunTimeMillis = new AtomicLong();\n+\n+    public static final Setting<Boolean> ENABLED_SETTING =\n+        Setting.boolSetting(\"monitor.fs.health.enabled\", true, Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> REFRESH_INTERVAL_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.refresh_interval\", TimeValue.timeValueSeconds(1), TimeValue.timeValueMillis(1),\n+            Setting.Property.NodeScope);\n+    public static final Setting<TimeValue> SLOW_PATH_LOGGING_THRESHOLD_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.slow_path_logging_threshold\", TimeValue.timeValueSeconds(5), TimeValue.timeValueMillis(1),\n+            Setting.Property.NodeScope, Setting.Property.Dynamic);\n+\n+\n+    public FsHealthService(Settings settings, ClusterSettings clusterSettings, ThreadPool threadPool, NodeEnvironment nodeEnv) {\n+        this.threadPool = threadPool;\n+        this.enabled = ENABLED_SETTING.get(settings);\n+        this.refreshInterval = REFRESH_INTERVAL_SETTING.get(settings);\n+        this.slowPathLoggingThreshold = SLOW_PATH_LOGGING_THRESHOLD_SETTING.get(settings);\n+        this.currentTimeMillisSupplier = threadPool::relativeTimeInMillis;\n+        this.nodeEnv = nodeEnv;\n+        this.pathHealthStats = new HashMap<>(1);\n+        clusterSettings.addSettingsUpdateConsumer(SLOW_PATH_LOGGING_THRESHOLD_SETTING, this::setSlowPathLoggingThreshold);\n+        clusterSettings.addSettingsUpdateConsumer(ENABLED_SETTING, this::setEnabled);\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        scheduledFuture = threadPool.scheduleWithFixedDelay(new FsHealthMonitor(), refreshInterval,\n+                ThreadPool.Names.GENERIC);\n+    }\n+\n+\n+    @Override\n+    protected void doStop() {\n+        scheduledFuture.cancel();\n+        slowPathHealthCheckTimeoutHandler.cancel();\n+    }\n+\n+    @Override\n+    protected void doClose() throws IOException {\n+\n+    }\n+\n+    public void setEnabled(boolean enabled) { this.enabled = enabled; }\n+\n+    public void setSlowPathLoggingThreshold(TimeValue slowPathLoggingThreshold) {\n+        this.slowPathLoggingThreshold = slowPathLoggingThreshold;\n+    }\n+\n+    @Override\n+    public Status getHealth() {\n+        if (enabled == false) {\n+            return Status.HEALTHY;\n+        }\n+        return pathHealthStats.entrySet().stream().anyMatch(map -> map.getValue() == Status.UNHEALTHY) ? Status.UNHEALTHY\n+            : Status.HEALTHY;\n+    }\n+\n+     class FsHealthMonitor implements Runnable {\n+\n+        static final String TEMP_FILE_NAME = \".es_temp_file\";\n+        private byte[] byteToWrite;\n+\n+        FsHealthMonitor(){\n+            this.byteToWrite = new byte[20];\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                if (enabled) {\n+                    monitorFSHealth();\n+                    logger.debug(\"Monitor for FS health ran successfully {}\", pathHealthStats);\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"Exception monitoring FS health\", e);\n+            }\n+        }\n+\n+        private void monitorFSHealth() {\n+            for (Path path : nodeEnv.nodeDataPaths()) {\n+                long executionStartTime = currentTimeMillisSupplier.getAsLong();\n+                slowPathHealthCheckTimeoutHandler = threadPool.schedule(new Runnable() {\n+                    @Override\n+                    public void run() {\n+                        logSlowDataPath(Level.WARN, path, executionStartTime);\n+                    }\n+                    @Override\n+                    public String toString() {\n+                        return \"Scheduled timeout for logging slow IO \" + FsHealthService.FsHealthMonitor.this;\n+                    }\n+                }, slowPathLoggingThreshold, ThreadPool.Names.GENERIC);\n+\n+                try {\n+                    if (Files.exists(path)) {\n+                        Path tempDataPath = path.resolve(TEMP_FILE_NAME);\n+                        Files.deleteIfExists(tempDataPath);\n+                        try (OutputStream os = Files.newOutputStream(tempDataPath, StandardOpenOption.CREATE_NEW)) {\n+                            new Random().nextBytes(byteToWrite);\n+                            os.write(byteToWrite);\n+                            IOUtils.fsync(tempDataPath, false);\n+                        }\n+                        Files.delete(tempDataPath);\n+                        pathHealthStats.put(path, Status.HEALTHY);\n+                    }\n+                } catch (Exception ex) {\n+                    logger.error(\"Failed to perform FS health check on path {} due to {} \", path, ex);\n+                    pathHealthStats.put(path,  Status.UNHEALTHY);\n+\n+                }\n+                cancelTimeoutHandler();\n+            }\n+            lastRunTimeMillis.getAndUpdate(l -> currentTimeMillisSupplier.getAsLong());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a8605145cd69f1bab3c7f66121714df7aa6a5c2"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcxNjU2Mw==", "bodyText": "This is only called in one place, I think we can inline it.", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r426716563", "createdAt": "2020-05-18T15:37:06Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.Level;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.core.internal.io.IOUtils;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.monitor.NodeHealthService;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.LongSupplier;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent implements NodeHealthService {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private volatile TimeValue refreshInterval;\n+    private volatile TimeValue slowPathLoggingThreshold;\n+    private final NodeEnvironment nodeEnv;\n+    private final LongSupplier currentTimeMillisSupplier;\n+    private Map<Path, Status> pathHealthStats;\n+    private volatile Scheduler.Cancellable scheduledFuture;\n+    private volatile Scheduler.Cancellable slowPathHealthCheckTimeoutHandler;\n+    private final AtomicLong lastRunTimeMillis = new AtomicLong();\n+\n+    public static final Setting<Boolean> ENABLED_SETTING =\n+        Setting.boolSetting(\"monitor.fs.health.enabled\", true, Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> REFRESH_INTERVAL_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.refresh_interval\", TimeValue.timeValueSeconds(1), TimeValue.timeValueMillis(1),\n+            Setting.Property.NodeScope);\n+    public static final Setting<TimeValue> SLOW_PATH_LOGGING_THRESHOLD_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.slow_path_logging_threshold\", TimeValue.timeValueSeconds(5), TimeValue.timeValueMillis(1),\n+            Setting.Property.NodeScope, Setting.Property.Dynamic);\n+\n+\n+    public FsHealthService(Settings settings, ClusterSettings clusterSettings, ThreadPool threadPool, NodeEnvironment nodeEnv) {\n+        this.threadPool = threadPool;\n+        this.enabled = ENABLED_SETTING.get(settings);\n+        this.refreshInterval = REFRESH_INTERVAL_SETTING.get(settings);\n+        this.slowPathLoggingThreshold = SLOW_PATH_LOGGING_THRESHOLD_SETTING.get(settings);\n+        this.currentTimeMillisSupplier = threadPool::relativeTimeInMillis;\n+        this.nodeEnv = nodeEnv;\n+        this.pathHealthStats = new HashMap<>(1);\n+        clusterSettings.addSettingsUpdateConsumer(SLOW_PATH_LOGGING_THRESHOLD_SETTING, this::setSlowPathLoggingThreshold);\n+        clusterSettings.addSettingsUpdateConsumer(ENABLED_SETTING, this::setEnabled);\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        scheduledFuture = threadPool.scheduleWithFixedDelay(new FsHealthMonitor(), refreshInterval,\n+                ThreadPool.Names.GENERIC);\n+    }\n+\n+\n+    @Override\n+    protected void doStop() {\n+        scheduledFuture.cancel();\n+        slowPathHealthCheckTimeoutHandler.cancel();\n+    }\n+\n+    @Override\n+    protected void doClose() throws IOException {\n+\n+    }\n+\n+    public void setEnabled(boolean enabled) { this.enabled = enabled; }\n+\n+    public void setSlowPathLoggingThreshold(TimeValue slowPathLoggingThreshold) {\n+        this.slowPathLoggingThreshold = slowPathLoggingThreshold;\n+    }\n+\n+    @Override\n+    public Status getHealth() {\n+        if (enabled == false) {\n+            return Status.HEALTHY;\n+        }\n+        return pathHealthStats.entrySet().stream().anyMatch(map -> map.getValue() == Status.UNHEALTHY) ? Status.UNHEALTHY\n+            : Status.HEALTHY;\n+    }\n+\n+     class FsHealthMonitor implements Runnable {\n+\n+        static final String TEMP_FILE_NAME = \".es_temp_file\";\n+        private byte[] byteToWrite;\n+\n+        FsHealthMonitor(){\n+            this.byteToWrite = new byte[20];\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                if (enabled) {\n+                    monitorFSHealth();\n+                    logger.debug(\"Monitor for FS health ran successfully {}\", pathHealthStats);\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"Exception monitoring FS health\", e);\n+            }\n+        }\n+\n+        private void monitorFSHealth() {\n+            for (Path path : nodeEnv.nodeDataPaths()) {\n+                long executionStartTime = currentTimeMillisSupplier.getAsLong();\n+                slowPathHealthCheckTimeoutHandler = threadPool.schedule(new Runnable() {\n+                    @Override\n+                    public void run() {\n+                        logSlowDataPath(Level.WARN, path, executionStartTime);\n+                    }\n+                    @Override\n+                    public String toString() {\n+                        return \"Scheduled timeout for logging slow IO \" + FsHealthService.FsHealthMonitor.this;\n+                    }\n+                }, slowPathLoggingThreshold, ThreadPool.Names.GENERIC);\n+\n+                try {\n+                    if (Files.exists(path)) {\n+                        Path tempDataPath = path.resolve(TEMP_FILE_NAME);\n+                        Files.deleteIfExists(tempDataPath);\n+                        try (OutputStream os = Files.newOutputStream(tempDataPath, StandardOpenOption.CREATE_NEW)) {\n+                            new Random().nextBytes(byteToWrite);\n+                            os.write(byteToWrite);\n+                            IOUtils.fsync(tempDataPath, false);\n+                        }\n+                        Files.delete(tempDataPath);\n+                        pathHealthStats.put(path, Status.HEALTHY);\n+                    }\n+                } catch (Exception ex) {\n+                    logger.error(\"Failed to perform FS health check on path {} due to {} \", path, ex);\n+                    pathHealthStats.put(path,  Status.UNHEALTHY);\n+\n+                }\n+                cancelTimeoutHandler();\n+            }\n+            lastRunTimeMillis.getAndUpdate(l -> currentTimeMillisSupplier.getAsLong());\n+        }\n+\n+         private void cancelTimeoutHandler() {\n+             if (slowPathHealthCheckTimeoutHandler != null) {\n+                 slowPathHealthCheckTimeoutHandler.cancel();\n+             }\n+         }\n+\n+         private void logSlowDataPath(Level level, Path path, long executionStartTime) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a8605145cd69f1bab3c7f66121714df7aa6a5c2"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcxNzgyMg==", "bodyText": "Suggest a message of the form checking writability of [{}] took [{}ms] which is above the warn threshold of [{}] since this is the wording used in other similar messages.", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r426717822", "createdAt": "2020-05-18T15:38:52Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.Level;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.core.internal.io.IOUtils;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.monitor.NodeHealthService;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.LongSupplier;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent implements NodeHealthService {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private volatile TimeValue refreshInterval;\n+    private volatile TimeValue slowPathLoggingThreshold;\n+    private final NodeEnvironment nodeEnv;\n+    private final LongSupplier currentTimeMillisSupplier;\n+    private Map<Path, Status> pathHealthStats;\n+    private volatile Scheduler.Cancellable scheduledFuture;\n+    private volatile Scheduler.Cancellable slowPathHealthCheckTimeoutHandler;\n+    private final AtomicLong lastRunTimeMillis = new AtomicLong();\n+\n+    public static final Setting<Boolean> ENABLED_SETTING =\n+        Setting.boolSetting(\"monitor.fs.health.enabled\", true, Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> REFRESH_INTERVAL_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.refresh_interval\", TimeValue.timeValueSeconds(1), TimeValue.timeValueMillis(1),\n+            Setting.Property.NodeScope);\n+    public static final Setting<TimeValue> SLOW_PATH_LOGGING_THRESHOLD_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.slow_path_logging_threshold\", TimeValue.timeValueSeconds(5), TimeValue.timeValueMillis(1),\n+            Setting.Property.NodeScope, Setting.Property.Dynamic);\n+\n+\n+    public FsHealthService(Settings settings, ClusterSettings clusterSettings, ThreadPool threadPool, NodeEnvironment nodeEnv) {\n+        this.threadPool = threadPool;\n+        this.enabled = ENABLED_SETTING.get(settings);\n+        this.refreshInterval = REFRESH_INTERVAL_SETTING.get(settings);\n+        this.slowPathLoggingThreshold = SLOW_PATH_LOGGING_THRESHOLD_SETTING.get(settings);\n+        this.currentTimeMillisSupplier = threadPool::relativeTimeInMillis;\n+        this.nodeEnv = nodeEnv;\n+        this.pathHealthStats = new HashMap<>(1);\n+        clusterSettings.addSettingsUpdateConsumer(SLOW_PATH_LOGGING_THRESHOLD_SETTING, this::setSlowPathLoggingThreshold);\n+        clusterSettings.addSettingsUpdateConsumer(ENABLED_SETTING, this::setEnabled);\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        scheduledFuture = threadPool.scheduleWithFixedDelay(new FsHealthMonitor(), refreshInterval,\n+                ThreadPool.Names.GENERIC);\n+    }\n+\n+\n+    @Override\n+    protected void doStop() {\n+        scheduledFuture.cancel();\n+        slowPathHealthCheckTimeoutHandler.cancel();\n+    }\n+\n+    @Override\n+    protected void doClose() throws IOException {\n+\n+    }\n+\n+    public void setEnabled(boolean enabled) { this.enabled = enabled; }\n+\n+    public void setSlowPathLoggingThreshold(TimeValue slowPathLoggingThreshold) {\n+        this.slowPathLoggingThreshold = slowPathLoggingThreshold;\n+    }\n+\n+    @Override\n+    public Status getHealth() {\n+        if (enabled == false) {\n+            return Status.HEALTHY;\n+        }\n+        return pathHealthStats.entrySet().stream().anyMatch(map -> map.getValue() == Status.UNHEALTHY) ? Status.UNHEALTHY\n+            : Status.HEALTHY;\n+    }\n+\n+     class FsHealthMonitor implements Runnable {\n+\n+        static final String TEMP_FILE_NAME = \".es_temp_file\";\n+        private byte[] byteToWrite;\n+\n+        FsHealthMonitor(){\n+            this.byteToWrite = new byte[20];\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                if (enabled) {\n+                    monitorFSHealth();\n+                    logger.debug(\"Monitor for FS health ran successfully {}\", pathHealthStats);\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"Exception monitoring FS health\", e);\n+            }\n+        }\n+\n+        private void monitorFSHealth() {\n+            for (Path path : nodeEnv.nodeDataPaths()) {\n+                long executionStartTime = currentTimeMillisSupplier.getAsLong();\n+                slowPathHealthCheckTimeoutHandler = threadPool.schedule(new Runnable() {\n+                    @Override\n+                    public void run() {\n+                        logSlowDataPath(Level.WARN, path, executionStartTime);\n+                    }\n+                    @Override\n+                    public String toString() {\n+                        return \"Scheduled timeout for logging slow IO \" + FsHealthService.FsHealthMonitor.this;\n+                    }\n+                }, slowPathLoggingThreshold, ThreadPool.Names.GENERIC);\n+\n+                try {\n+                    if (Files.exists(path)) {\n+                        Path tempDataPath = path.resolve(TEMP_FILE_NAME);\n+                        Files.deleteIfExists(tempDataPath);\n+                        try (OutputStream os = Files.newOutputStream(tempDataPath, StandardOpenOption.CREATE_NEW)) {\n+                            new Random().nextBytes(byteToWrite);\n+                            os.write(byteToWrite);\n+                            IOUtils.fsync(tempDataPath, false);\n+                        }\n+                        Files.delete(tempDataPath);\n+                        pathHealthStats.put(path, Status.HEALTHY);\n+                    }\n+                } catch (Exception ex) {\n+                    logger.error(\"Failed to perform FS health check on path {} due to {} \", path, ex);\n+                    pathHealthStats.put(path,  Status.UNHEALTHY);\n+\n+                }\n+                cancelTimeoutHandler();\n+            }\n+            lastRunTimeMillis.getAndUpdate(l -> currentTimeMillisSupplier.getAsLong());\n+        }\n+\n+         private void cancelTimeoutHandler() {\n+             if (slowPathHealthCheckTimeoutHandler != null) {\n+                 slowPathHealthCheckTimeoutHandler.cancel();\n+             }\n+         }\n+\n+         private void logSlowDataPath(Level level, Path path, long executionStartTime) {\n+             final TimeValue elapsedTime = TimeValue.timeValueMillis(currentTimeMillisSupplier.getAsLong() - executionStartTime);\n+             logger.log(level, \"Slow IO detected on path [{}], FS health check elapsed time [{}]\", path, elapsedTime);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a8605145cd69f1bab3c7f66121714df7aa6a5c2"}, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcxOTg2MA==", "bodyText": "Could we instead dynamically change a node to become unhealthy and verify that it's removed from the cluster?", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r426719860", "createdAt": "2020-05-18T15:41:46Z", "author": {"login": "DaveCTurner"}, "path": "server/src/test/java/org/elasticsearch/cluster/coordination/CoordinatorTests.java", "diffHunk": "@@ -158,6 +161,48 @@ public void testDoesNotElectNonMasterNode() {\n         }\n     }\n \n+    public void testNoElectedLeaderForNonWritableNodes() {\n+        try (Cluster cluster = new Cluster(randomIntBetween(1, 5), true, Settings.EMPTY, () -> NodeHealthService.Status.UNHEALTHY)) {\n+            cluster.runRandomly();\n+            cluster.runFor(DEFAULT_STABILISATION_TIME, \"allowing time for stabilization\");\n+            final List<ClusterNode> leaders = cluster.getAllLeaders();\n+            assertThat(leaders, empty());\n+        }\n+    }\n+\n+    public void testNonWritableNodeCannotBecomeLeader() {\n+        try (Cluster cluster = new Cluster(randomIntBetween(3, 5))) {\n+            cluster.runRandomly();\n+            cluster.stabilise();\n+\n+            final ClusterNode leader = cluster.getAnyLeader();\n+            ClusterNode nonWritableNode = cluster.new ClusterNode(nextNodeIndex.getAndIncrement(), true, leader.nodeSettings,\n+                () -> NodeHealthService.Status.UNHEALTHY);\n+            cluster.clusterNodes.add(nonWritableNode);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a8605145cd69f1bab3c7f66121714df7aa6a5c2"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcyMDM5OQ==", "bodyText": "I think we can strengthen cluster.stabilise() to work correctly in the light of unhealthy nodes, so we get the benefits of all the assertions it makes that the cluster has stabilised.", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r426720399", "createdAt": "2020-05-18T15:42:38Z", "author": {"login": "DaveCTurner"}, "path": "server/src/test/java/org/elasticsearch/cluster/coordination/CoordinatorTests.java", "diffHunk": "@@ -158,6 +161,48 @@ public void testDoesNotElectNonMasterNode() {\n         }\n     }\n \n+    public void testNoElectedLeaderForNonWritableNodes() {\n+        try (Cluster cluster = new Cluster(randomIntBetween(1, 5), true, Settings.EMPTY, () -> NodeHealthService.Status.UNHEALTHY)) {\n+            cluster.runRandomly();\n+            cluster.runFor(DEFAULT_STABILISATION_TIME, \"allowing time for stabilization\");\n+            final List<ClusterNode> leaders = cluster.getAllLeaders();\n+            assertThat(leaders, empty());\n+        }\n+    }\n+\n+    public void testNonWritableNodeCannotBecomeLeader() {\n+        try (Cluster cluster = new Cluster(randomIntBetween(3, 5))) {\n+            cluster.runRandomly();\n+            cluster.stabilise();\n+\n+            final ClusterNode leader = cluster.getAnyLeader();\n+            ClusterNode nonWritableNode = cluster.new ClusterNode(nextNodeIndex.getAndIncrement(), true, leader.nodeSettings,\n+                () -> NodeHealthService.Status.UNHEALTHY);\n+            cluster.clusterNodes.add(nonWritableNode);\n+            cluster.runFor(DEFAULT_STABILISATION_TIME, \"allowing time for stabilization\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a8605145cd69f1bab3c7f66121714df7aa6a5c2"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcyMTkyMw==", "bodyText": "Suspect this comment was removed from master recently.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    }, ElectionStrategy.DEFAULT_INSTANCE, () -> healthStatus); // TODO need tests that check that the max term seen is updated\n          \n          \n            \n                    }, ElectionStrategy.DEFAULT_INSTANCE, () -> healthStatus);", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r426721923", "createdAt": "2020-05-18T15:44:54Z", "author": {"login": "DaveCTurner"}, "path": "server/src/test/java/org/elasticsearch/cluster/coordination/PreVoteCollectorTests.java", "diffHunk": "@@ -112,7 +120,7 @@ public String toString() {\n             assert electionOccurred == false;\n             electionOccurred = true;\n         }, l -> {\n-        }, ElectionStrategy.DEFAULT_INSTANCE);\n+        }, ElectionStrategy.DEFAULT_INSTANCE, () -> healthStatus); // TODO need tests that check that the max term seen is updated", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a8605145cd69f1bab3c7f66121714df7aa6a5c2"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcyNTQ1Nw==", "bodyText": "I'd rather not add this to the public interface of DeterministicTaskQueue and instead test the behaviour we want: if we keep on advancing time then we keep on executing this task. See e.g. ClusterFormationFailureHelperTests#testScheduling.", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r426725457", "createdAt": "2020-05-18T15:49:56Z", "author": {"login": "DaveCTurner"}, "path": "server/src/test/java/org/elasticsearch/monitor/fs/FsHealthServiceTests.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.monitor.fs;\n+\n+\n+import org.apache.lucene.mockfile.FilterFileSystemProvider;\n+import org.elasticsearch.cluster.coordination.DeterministicTaskQueue;\n+import org.elasticsearch.common.io.PathUtils;\n+import org.elasticsearch.common.io.PathUtilsForTesting;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.monitor.NodeHealthService;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.threadpool.TestThreadPool;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.junit.Before;\n+\n+import java.io.IOException;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.FileSystem;\n+import java.nio.file.OpenOption;\n+import java.nio.file.Path;\n+import java.nio.file.attribute.FileAttribute;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.elasticsearch.node.Node.NODE_NAME_SETTING;\n+\n+\n+public class FsHealthServiceTests extends ESTestCase {\n+\n+    private DeterministicTaskQueue deterministicTaskQueue;\n+\n+    @Before\n+    public void createObjects() {\n+        Settings settings = Settings.builder().put(NODE_NAME_SETTING.getKey(), \"node\").build();\n+        deterministicTaskQueue = new DeterministicTaskQueue(settings, random());\n+    }\n+\n+    public void testSchedulesHealthCheckAndSlowPathLoggingPeriodically() throws Exception {\n+        final ClusterSettings clusterSettings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+        try (NodeEnvironment env = newNodeEnvironment()) {\n+            FsHealthService fsHealthService = new FsHealthService(Settings.EMPTY, clusterSettings, deterministicTaskQueue.getThreadPool(), env);\n+            fsHealthService.doStart();\n+            assertFalse(deterministicTaskQueue.hasRunnableTasks());\n+            assertTrue(deterministicTaskQueue.hasDeferredTasks());\n+\n+            //schedules the first health check at refresh interval\n+            assertEquals(deterministicTaskQueue.getLatestDeferredExecutionTime(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a8605145cd69f1bab3c7f66121714df7aa6a5c2"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcyNjI5Ng==", "bodyText": "I'd prefer that we also check the behaviour on writes and syncs, effectively to assert that we do detect failures for both of those activities too.", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r426726296", "createdAt": "2020-05-18T15:51:06Z", "author": {"login": "DaveCTurner"}, "path": "server/src/test/java/org/elasticsearch/monitor/fs/FsHealthServiceTests.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.monitor.fs;\n+\n+\n+import org.apache.lucene.mockfile.FilterFileSystemProvider;\n+import org.elasticsearch.cluster.coordination.DeterministicTaskQueue;\n+import org.elasticsearch.common.io.PathUtils;\n+import org.elasticsearch.common.io.PathUtilsForTesting;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.monitor.NodeHealthService;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.threadpool.TestThreadPool;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.junit.Before;\n+\n+import java.io.IOException;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.FileSystem;\n+import java.nio.file.OpenOption;\n+import java.nio.file.Path;\n+import java.nio.file.attribute.FileAttribute;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.elasticsearch.node.Node.NODE_NAME_SETTING;\n+\n+\n+public class FsHealthServiceTests extends ESTestCase {\n+\n+    private DeterministicTaskQueue deterministicTaskQueue;\n+\n+    @Before\n+    public void createObjects() {\n+        Settings settings = Settings.builder().put(NODE_NAME_SETTING.getKey(), \"node\").build();\n+        deterministicTaskQueue = new DeterministicTaskQueue(settings, random());\n+    }\n+\n+    public void testSchedulesHealthCheckAndSlowPathLoggingPeriodically() throws Exception {\n+        final ClusterSettings clusterSettings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+        try (NodeEnvironment env = newNodeEnvironment()) {\n+            FsHealthService fsHealthService = new FsHealthService(Settings.EMPTY, clusterSettings, deterministicTaskQueue.getThreadPool(), env);\n+            fsHealthService.doStart();\n+            assertFalse(deterministicTaskQueue.hasRunnableTasks());\n+            assertTrue(deterministicTaskQueue.hasDeferredTasks());\n+\n+            //schedules the first health check at refresh interval\n+            assertEquals(deterministicTaskQueue.getLatestDeferredExecutionTime(),\n+                FsHealthService.REFRESH_INTERVAL_SETTING.get(Settings.EMPTY).millis());\n+            deterministicTaskQueue.advanceTime();\n+            deterministicTaskQueue.runAllRunnableTasks();\n+\n+            //schedules the next health check at refresh interval\n+            assertEquals(deterministicTaskQueue.getNextDeferredExecutionTime(),\n+                (FsHealthService.REFRESH_INTERVAL_SETTING.get(Settings.EMPTY).millis()) * 2);\n+\n+            //We schedule a slow logging timeout handler per path\n+            assertEquals(deterministicTaskQueue.getDeferredTasks().size(), env.nodeDataPaths().length + 1);\n+\n+            //Verify schedules slow path logging at the timeout\n+            assertEquals(deterministicTaskQueue.getLatestDeferredExecutionTime(),\n+                (FsHealthService.REFRESH_INTERVAL_SETTING.get(Settings.EMPTY).millis() +\n+                    FsHealthService.SLOW_PATH_LOGGING_THRESHOLD_SETTING.get(Settings.EMPTY).millis()));\n+\n+            deterministicTaskQueue.advanceTime();\n+            deterministicTaskQueue.runAllRunnableTasks();\n+\n+            assertFalse(deterministicTaskQueue.hasRunnableTasks());\n+            assertTrue(deterministicTaskQueue.hasDeferredTasks());\n+\n+            fsHealthService.doStop();\n+            // run deferred tasks\n+            while (deterministicTaskQueue.hasDeferredTasks()) {\n+                deterministicTaskQueue.advanceTime();\n+                deterministicTaskQueue.runAllRunnableTasks();\n+            }\n+            // no tasks post service stop\n+            assertFalse(deterministicTaskQueue.hasRunnableTasks());\n+            assertFalse(deterministicTaskQueue.hasDeferredTasks());\n+        }\n+    }\n+\n+    public void testFailsHealthOnIOException() throws IOException {\n+        FileSystem current = PathUtils.getDefaultFileSystem();\n+        FileSystemIOExceptionProvider disruptFileSystemProvider = new FileSystemIOExceptionProvider(current);\n+        PathUtilsForTesting.installMock(disruptFileSystemProvider.getFileSystem(null));\n+        final Settings settings = Settings.EMPTY;\n+        final ClusterSettings clusterSettings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+        TestThreadPool testThreadPool = new TestThreadPool(getClass().getName(), settings);\n+        try (NodeEnvironment env = newNodeEnvironment()) {\n+            FsHealthService fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n+            fsHealthService.new FsHealthMonitor().run();\n+            assertEquals(fsHealthService.getHealth(), NodeHealthService.Status.HEALTHY);\n+\n+            //disrupt file system\n+            disruptFileSystemProvider.injectIOException.set(true);\n+            fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n+            fsHealthService.new FsHealthMonitor().run();\n+            assertEquals(fsHealthService.getHealth(), NodeHealthService.Status.UNHEALTHY);\n+        } finally {\n+            ThreadPool.terminate(testThreadPool, 500, TimeUnit.MILLISECONDS);\n+            disruptFileSystemProvider.injectIOException.set(false);\n+        }\n+    }\n+\n+    public void testFailsHealthOnSinglePathIOException() throws IOException {\n+        FileSystem current = PathUtils.getDefaultFileSystem();\n+        FileSystemIOExceptionProvider disruptFileSystemProvider = new FileSystemIOExceptionProvider(current);\n+        PathUtilsForTesting.installMock(disruptFileSystemProvider.getFileSystem(null));\n+        final Settings settings = Settings.EMPTY;\n+        final ClusterSettings clusterSettings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+        TestThreadPool testThreadPool = new TestThreadPool(getClass().getName(), settings);\n+        try (NodeEnvironment env = newNodeEnvironment()) {\n+            Path[] paths = env.nodeDataPaths();\n+            FsHealthService fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n+            fsHealthService.new FsHealthMonitor().run();\n+            assertEquals(fsHealthService.getHealth(), NodeHealthService.Status.HEALTHY);\n+\n+            //disrupt file system on single path\n+            disruptFileSystemProvider.injectIOException.set(true);\n+            disruptFileSystemProvider.restrictPathPrefix(randomFrom(paths).toString());\n+            fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n+            fsHealthService.new FsHealthMonitor().run();\n+            assertEquals(fsHealthService.getHealth(), NodeHealthService.Status.UNHEALTHY);\n+            assertEquals(disruptFileSystemProvider.getInjectedPathCount(), 1);\n+\n+        } finally {\n+            ThreadPool.terminate(testThreadPool, 500, TimeUnit.MILLISECONDS);\n+            disruptFileSystemProvider.injectIOException.set(false);\n+        }\n+    }\n+\n+    private static class FileSystemIOExceptionProvider extends FilterFileSystemProvider {\n+\n+        AtomicBoolean injectIOException = new AtomicBoolean();\n+        AtomicInteger injectedPaths = new AtomicInteger();\n+\n+        private String pathPrefix = \"/\";\n+\n+        FileSystemIOExceptionProvider(FileSystem inner) {\n+            super(\"disrupt_fs_health://\", inner);\n+        }\n+\n+        public void restrictPathPrefix(String pathPrefix){\n+            this.pathPrefix = pathPrefix;\n+        }\n+\n+        public int getInjectedPathCount(){\n+            return injectedPaths.get();\n+        }\n+\n+        @Override\n+        public FileChannel newFileChannel(Path path, Set<? extends OpenOption> options, FileAttribute<?>... attrs) throws IOException {\n+            if (injectIOException.get()){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a8605145cd69f1bab3c7f66121714df7aa6a5c2"}, "originalPosition": 176}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c9dd1a7934c8f88903882a6405196da04be9e9c8", "author": {"user": {"login": "Bukhtawar", "name": "Bukhtawar Khan"}}, "url": "https://github.com/elastic/elasticsearch/commit/c9dd1a7934c8f88903882a6405196da04be9e9c8", "committedDate": "2020-05-20T12:23:29Z", "message": "Addressing comments on logging and tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c99a68eef519e60740b594897cebdeba41217624", "author": {"user": {"login": "Bukhtawar", "name": "Bukhtawar Khan"}}, "url": "https://github.com/elastic/elasticsearch/commit/c99a68eef519e60740b594897cebdeba41217624", "committedDate": "2020-05-20T14:31:03Z", "message": "Minor edits"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "545eaf5328fedf536c7882cfdc5ff98e4251d5b1", "author": {"user": {"login": "Bukhtawar", "name": "Bukhtawar Khan"}}, "url": "https://github.com/elastic/elasticsearch/commit/545eaf5328fedf536c7882cfdc5ff98e4251d5b1", "committedDate": "2020-05-27T05:57:11Z", "message": "Merge branch 'master' into ro-fs-handling"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "86fa7c9501e46d814428612975e4627ff827f81c", "author": {"user": {"login": "Bukhtawar", "name": "Bukhtawar Khan"}}, "url": "https://github.com/elastic/elasticsearch/commit/86fa7c9501e46d814428612975e4627ff827f81c", "committedDate": "2020-05-27T06:01:29Z", "message": "Updated the exception id"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8102c819c467bb42ff06752e0a785e58842db0ca", "author": {"user": {"login": "Bukhtawar", "name": "Bukhtawar Khan"}}, "url": "https://github.com/elastic/elasticsearch/commit/8102c819c467bb42ff06752e0a785e58842db0ca", "committedDate": "2020-06-04T04:48:26Z", "message": "Merge branch 'master' into ro-fs-handling"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "043db9301654ecc42de863c18571dfe9afc72bef", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/043db9301654ecc42de863c18571dfe9afc72bef", "committedDate": "2020-06-16T08:14:28Z", "message": "Fix merge conflict"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxMjczMzMx", "url": "https://github.com/elastic/elasticsearch/pull/52680#pullrequestreview-431273331", "createdAt": "2020-06-16T08:25:46Z", "commit": {"oid": "043db9301654ecc42de863c18571dfe9afc72bef"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwODoyNTo0N1rOGkQqxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwODo1OToyMlrOGkR_XA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY3NTAxMg==", "bodyText": "This needs some synchronisation since it's accessed on multiple threads.\nI suggest making this field volatile, constructing a new local object on each check and then assigning the local object to this field at the end of the check.\nI also suggest a Set<Path> of unhealthy paths rather than tracking them all -- the healthy ones are never used here. We could even mark this as @Nullable and use null instead of an empty set if we wanted to save on long-lived objects.", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r440675012", "createdAt": "2020-06-16T08:25:47Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.core.internal.io.IOUtils;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.monitor.NodeHealthService;\n+import org.elasticsearch.monitor.StatusInfo;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.function.LongSupplier;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.monitor.StatusInfo.Status.HEALTHY;\n+import static org.elasticsearch.monitor.StatusInfo.Status.UNHEALTHY;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent implements NodeHealthService {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private volatile TimeValue refreshInterval;\n+    private volatile TimeValue slowPathLoggingThreshold;\n+    private final NodeEnvironment nodeEnv;\n+    private final LongSupplier currentTimeMillisSupplier;\n+    private Map<Path, StatusInfo.Status> pathHealthStats;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "043db9301654ecc42de863c18571dfe9afc72bef"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY3NjYzMQ==", "bodyText": "I think the default frequency should be a lot more relaxed; an fsync per node per second is going to cause problems on slower disks. Let's align this with the lag detector:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Setting.timeSetting(\"monitor.fs.health.refresh_interval\", TimeValue.timeValueSeconds(1), TimeValue.timeValueMillis(1),\n          \n          \n            \n                    Setting.timeSetting(\"monitor.fs.health.refresh_interval\", TimeValue.timeValueSeconds(120), TimeValue.timeValueMillis(1),", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r440676631", "createdAt": "2020-06-16T08:28:23Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.core.internal.io.IOUtils;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.monitor.NodeHealthService;\n+import org.elasticsearch.monitor.StatusInfo;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.function.LongSupplier;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.monitor.StatusInfo.Status.HEALTHY;\n+import static org.elasticsearch.monitor.StatusInfo.Status.UNHEALTHY;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent implements NodeHealthService {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private volatile TimeValue refreshInterval;\n+    private volatile TimeValue slowPathLoggingThreshold;\n+    private final NodeEnvironment nodeEnv;\n+    private final LongSupplier currentTimeMillisSupplier;\n+    private Map<Path, StatusInfo.Status> pathHealthStats;\n+    private volatile Scheduler.Cancellable scheduledFuture;\n+\n+    public static final Setting<Boolean> ENABLED_SETTING =\n+        Setting.boolSetting(\"monitor.fs.health.enabled\", true, Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> REFRESH_INTERVAL_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.refresh_interval\", TimeValue.timeValueSeconds(1), TimeValue.timeValueMillis(1),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "043db9301654ecc42de863c18571dfe9afc72bef"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY3OTM0OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private volatile TimeValue refreshInterval;\n          \n          \n            \n                private final TimeValue refreshInterval;", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r440679349", "createdAt": "2020-06-16T08:32:39Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.core.internal.io.IOUtils;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.monitor.NodeHealthService;\n+import org.elasticsearch.monitor.StatusInfo;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.function.LongSupplier;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.monitor.StatusInfo.Status.HEALTHY;\n+import static org.elasticsearch.monitor.StatusInfo.Status.UNHEALTHY;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent implements NodeHealthService {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private volatile TimeValue refreshInterval;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "043db9301654ecc42de863c18571dfe9afc72bef"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY4MDI3OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    static final String TEMP_FILE_NAME = \".es_temp_file\";\n          \n          \n            \n                    private static final String TEMP_FILE_NAME = \".es_temp_file\";", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r440680278", "createdAt": "2020-06-16T08:34:07Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.core.internal.io.IOUtils;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.monitor.NodeHealthService;\n+import org.elasticsearch.monitor.StatusInfo;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.function.LongSupplier;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.monitor.StatusInfo.Status.HEALTHY;\n+import static org.elasticsearch.monitor.StatusInfo.Status.UNHEALTHY;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent implements NodeHealthService {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private volatile TimeValue refreshInterval;\n+    private volatile TimeValue slowPathLoggingThreshold;\n+    private final NodeEnvironment nodeEnv;\n+    private final LongSupplier currentTimeMillisSupplier;\n+    private Map<Path, StatusInfo.Status> pathHealthStats;\n+    private volatile Scheduler.Cancellable scheduledFuture;\n+\n+    public static final Setting<Boolean> ENABLED_SETTING =\n+        Setting.boolSetting(\"monitor.fs.health.enabled\", true, Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> REFRESH_INTERVAL_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.refresh_interval\", TimeValue.timeValueSeconds(1), TimeValue.timeValueMillis(1),\n+            Setting.Property.NodeScope);\n+    public static final Setting<TimeValue> SLOW_PATH_LOGGING_THRESHOLD_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.slow_path_logging_threshold\", TimeValue.timeValueSeconds(5), TimeValue.timeValueMillis(1),\n+            Setting.Property.NodeScope, Setting.Property.Dynamic);\n+\n+\n+    public FsHealthService(Settings settings, ClusterSettings clusterSettings, ThreadPool threadPool, NodeEnvironment nodeEnv) {\n+        this.threadPool = threadPool;\n+        this.enabled = ENABLED_SETTING.get(settings);\n+        this.refreshInterval = REFRESH_INTERVAL_SETTING.get(settings);\n+        this.slowPathLoggingThreshold = SLOW_PATH_LOGGING_THRESHOLD_SETTING.get(settings);\n+        this.currentTimeMillisSupplier = threadPool::relativeTimeInMillis;\n+        this.nodeEnv = nodeEnv;\n+        this.pathHealthStats = new HashMap<>(1);\n+        clusterSettings.addSettingsUpdateConsumer(SLOW_PATH_LOGGING_THRESHOLD_SETTING, this::setSlowPathLoggingThreshold);\n+        clusterSettings.addSettingsUpdateConsumer(ENABLED_SETTING, this::setEnabled);\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        scheduledFuture = threadPool.scheduleWithFixedDelay(new FsHealthMonitor(), refreshInterval,\n+                ThreadPool.Names.GENERIC);\n+    }\n+\n+    @Override\n+    protected void doStop() {\n+        scheduledFuture.cancel();\n+    }\n+\n+    @Override\n+    protected void doClose() throws IOException {\n+\n+    }\n+\n+    public void setEnabled(boolean enabled) { this.enabled = enabled; }\n+\n+    public void setSlowPathLoggingThreshold(TimeValue slowPathLoggingThreshold) {\n+        this.slowPathLoggingThreshold = slowPathLoggingThreshold;\n+    }\n+\n+    @Override\n+    public StatusInfo getHealth() {\n+        StatusInfo statusInfo;\n+        if (enabled == false) {\n+            statusInfo = new StatusInfo(HEALTHY, \"FS health checks are disabled\");\n+        }\n+        else if (pathHealthStats.entrySet().stream().anyMatch(map -> map.getValue() == UNHEALTHY)) {\n+            String info = \"Path(s) \" + pathHealthStats.entrySet()\n+                .stream().filter(v -> v.getValue() == UNHEALTHY)\n+                .map(k -> k.getKey().toString())\n+                .collect(Collectors.joining(\",\")) + \" have failed writability checks\";\n+\n+            statusInfo = new StatusInfo(UNHEALTHY, info);\n+        }\n+        else {\n+            statusInfo = new StatusInfo(HEALTHY, \"All paths have passed writabililty checks\");\n+        }\n+        return statusInfo;\n+    }\n+\n+     class FsHealthMonitor implements Runnable {\n+\n+        static final String TEMP_FILE_NAME = \".es_temp_file\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "043db9301654ecc42de863c18571dfe9afc72bef"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY4Mjg3NQ==", "bodyText": "Is there a shorter time-bound for stabilisation here?", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r440682875", "createdAt": "2020-06-16T08:38:10Z", "author": {"login": "DaveCTurner"}, "path": "server/src/test/java/org/elasticsearch/cluster/coordination/CoordinatorTests.java", "diffHunk": "@@ -158,6 +162,50 @@ public void testDoesNotElectNonMasterNode() {\n         }\n     }\n \n+    public void testUnhealthyNodesGetsRemoved() {\n+        AtomicReference<StatusInfo> healthStatusInfo = new AtomicReference<>(\n+            new StatusInfo(HEALTHY, \"healthy-info\"));\n+        try (Cluster cluster = new Cluster(3)) {\n+            cluster.runRandomly();\n+            cluster.stabilise();\n+\n+            final ClusterNode leader = cluster.getAnyLeader();\n+            logger.info(\"--> adding two new healthy nodes\");\n+            ClusterNode newNode1 = cluster.new ClusterNode(nextNodeIndex.getAndIncrement(), true, leader.nodeSettings,\n+                () -> healthStatusInfo.get());\n+            ClusterNode newNode2 = cluster.new ClusterNode(nextNodeIndex.getAndIncrement(), true, leader.nodeSettings,\n+                () -> healthStatusInfo.get());\n+            cluster.clusterNodes.add(newNode1);\n+            cluster.clusterNodes.add(newNode2);\n+            cluster.stabilise();\n+\n+            {\n+                assertThat(leader.coordinator.getMode(), is(Mode.LEADER));\n+                final VotingConfiguration lastCommittedConfiguration = leader.getLastAppliedClusterState().getLastCommittedConfiguration();\n+                assertThat(lastCommittedConfiguration + \" should be all nodes\", lastCommittedConfiguration.getNodeIds(),\n+                    equalTo(cluster.clusterNodes.stream().map(ClusterNode::getId).collect(Collectors.toSet())));\n+            }\n+\n+            logger.info(\"setting auto-shrink reconfiguration to true\");\n+            leader.submitSetAutoShrinkVotingConfiguration(true);\n+            cluster.stabilise(DEFAULT_CLUSTER_STATE_UPDATE_DELAY);\n+            assertTrue(CLUSTER_AUTO_SHRINK_VOTING_CONFIGURATION.get(leader.getLastAppliedClusterState().metadata().settings()));\n+\n+            logger.info(\"--> changing health of newly added nodes to unhealthy\");\n+            healthStatusInfo.getAndSet(new StatusInfo(UNHEALTHY, \"unhealthy-info\"));\n+\n+            cluster.stabilise();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "043db9301654ecc42de863c18571dfe9afc72bef"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY4MzA3OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    }, () -> new StatusInfo(StatusInfo.Status.HEALTHY, \"unhealthy-info\"));\n          \n          \n            \n                    }, () -> new StatusInfo(StatusInfo.Status.HEALTHY, \"healthy-info\"));", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r440683079", "createdAt": "2020-06-16T08:38:30Z", "author": {"login": "DaveCTurner"}, "path": "server/src/test/java/org/elasticsearch/cluster/coordination/FollowersCheckerTests.java", "diffHunk": "@@ -105,12 +109,11 @@ protected void onSendRequest(long requestId, String action, TransportRequest req\n             TransportService.NOOP_TRANSPORT_INTERCEPTOR, boundTransportAddress -> localNode, null, emptySet());\n         transportService.start();\n         transportService.acceptIncomingRequests();\n-\n         final FollowersChecker followersChecker = new FollowersChecker(settings, transportService, fcr -> {\n             assert false : fcr;\n         }, (node, reason) -> {\n             assert false : node;\n-        });\n+        }, () -> new StatusInfo(StatusInfo.Status.HEALTHY, \"unhealthy-info\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "043db9301654ecc42de863c18571dfe9afc72bef"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY5NjY2OA==", "bodyText": "Could we do this with a fake clock (e.g. a DeterministicTaskQueue) rather than a sleep of a few hundred milliseconds?", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r440696668", "createdAt": "2020-06-16T08:59:22Z", "author": {"login": "DaveCTurner"}, "path": "server/src/test/java/org/elasticsearch/monitor/fs/FsHealthServiceTests.java", "diffHunk": "@@ -0,0 +1,342 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.monitor.fs;\n+\n+\n+import org.apache.logging.log4j.Level;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.lucene.mockfile.FilterFileChannel;\n+import org.apache.lucene.mockfile.FilterFileSystemProvider;\n+import org.elasticsearch.cluster.coordination.DeterministicTaskQueue;\n+import org.elasticsearch.common.io.PathUtils;\n+import org.elasticsearch.common.io.PathUtilsForTesting;\n+import org.elasticsearch.common.logging.Loggers;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.test.MockLogAppender;\n+import org.elasticsearch.test.junit.annotations.TestLogging;\n+import org.elasticsearch.threadpool.TestThreadPool;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.junit.Before;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.FileSystem;\n+import java.nio.file.OpenOption;\n+import java.nio.file.Path;\n+import java.nio.file.attribute.FileAttribute;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.elasticsearch.monitor.StatusInfo.Status.HEALTHY;\n+import static org.elasticsearch.monitor.StatusInfo.Status.UNHEALTHY;\n+import static org.elasticsearch.node.Node.NODE_NAME_SETTING;\n+import static org.hamcrest.Matchers.is;\n+\n+\n+public class FsHealthServiceTests extends ESTestCase {\n+\n+    private DeterministicTaskQueue deterministicTaskQueue;\n+\n+    @Before\n+    public void createObjects() {\n+        Settings settings = Settings.builder().put(NODE_NAME_SETTING.getKey(), \"node\").build();\n+        deterministicTaskQueue = new DeterministicTaskQueue(settings, random());\n+    }\n+\n+    public void testSchedulesHealthCheckAtRefreshIntervals() throws Exception {\n+        long refreshInterval = randomLongBetween(1000, 12000);\n+        final Settings settings = Settings.builder().put(FsHealthService.REFRESH_INTERVAL_SETTING.getKey(), refreshInterval + \"ms\").build();\n+        final ClusterSettings clusterSettings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+        try (NodeEnvironment env = newNodeEnvironment()) {\n+            FsHealthService fsHealthService = new FsHealthService(settings, clusterSettings, deterministicTaskQueue.getThreadPool(), env);\n+            final long startTimeMillis = deterministicTaskQueue.getCurrentTimeMillis();\n+            fsHealthService.doStart();\n+            assertFalse(deterministicTaskQueue.hasRunnableTasks());\n+            assertTrue(deterministicTaskQueue.hasDeferredTasks());\n+            int rescheduledCount = 0;\n+            for (int i = 1; i <= randomIntBetween(5, 10); i++) {\n+                if (deterministicTaskQueue.hasRunnableTasks()) {\n+                    deterministicTaskQueue.runRandomTask();\n+                } else {\n+                    assertThat(deterministicTaskQueue.getLatestDeferredExecutionTime(), is(refreshInterval * (rescheduledCount + 1)));\n+                    deterministicTaskQueue.advanceTime();\n+                    rescheduledCount++;\n+                }\n+                assertThat(deterministicTaskQueue.getCurrentTimeMillis() - startTimeMillis, is(refreshInterval * rescheduledCount));\n+            }\n+\n+            fsHealthService.doStop();\n+            deterministicTaskQueue.runAllTasksInTimeOrder();\n+\n+            assertFalse(deterministicTaskQueue.hasRunnableTasks());\n+            assertFalse(deterministicTaskQueue.hasDeferredTasks());\n+        }\n+    }\n+\n+    public void testFailsHealthOnIOException() throws IOException {\n+        FileSystem fileSystem = PathUtils.getDefaultFileSystem();\n+        FileSystemIOExceptionProvider disruptFileSystemProvider = new FileSystemIOExceptionProvider(fileSystem);\n+        fileSystem = disruptFileSystemProvider.getFileSystem(null);\n+        PathUtilsForTesting.installMock(fileSystem);\n+        final Settings settings = Settings.EMPTY;\n+        final ClusterSettings clusterSettings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+        TestThreadPool testThreadPool = new TestThreadPool(getClass().getName(), settings);\n+        try (NodeEnvironment env = newNodeEnvironment()) {\n+            FsHealthService fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n+            fsHealthService.new FsHealthMonitor().run();\n+            assertEquals(fsHealthService.getHealth().getStatus(), HEALTHY);\n+            assertEquals(fsHealthService.getHealth().getInfo(), \"All paths have passed writabililty checks\");\n+\n+            //disrupt file system\n+            disruptFileSystemProvider.injectIOException.set(true);\n+            fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n+            fsHealthService.new FsHealthMonitor().run();\n+            assertEquals(fsHealthService.getHealth().getStatus(), UNHEALTHY);\n+            for (Path path : env.nodeDataPaths()) {\n+                assertTrue(fsHealthService.getHealth().getInfo().contains(path.toString()));\n+            }\n+            assertEquals(disruptFileSystemProvider.getInjectedPathCount(), env.nodeDataPaths().length);\n+        } finally {\n+            disruptFileSystemProvider.injectIOException.set(false);\n+            PathUtilsForTesting.teardown();\n+            ThreadPool.terminate(testThreadPool, 500, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    @TestLogging(value = \"org.elasticsearch.monitor.fs:WARN\", reason = \"to ensure that we log on hung IO at WARN level\")\n+    public void testLoggingOnHungIO() throws Exception {\n+        long slowLogThreshold = randomLongBetween(100, 200);\n+        final Settings settings = Settings.builder().put(FsHealthService.SLOW_PATH_LOGGING_THRESHOLD_SETTING.getKey(),\n+            slowLogThreshold + \"ms\").build();\n+        FileSystem fileSystem = PathUtils.getDefaultFileSystem();\n+        FileSystemFsyncHungProvider disruptFileSystemProvider = new FileSystemFsyncHungProvider(fileSystem,\n+            randomLongBetween(slowLogThreshold + 1 , 400));\n+        fileSystem = disruptFileSystemProvider.getFileSystem(null);\n+        PathUtilsForTesting.installMock(fileSystem);\n+        final ClusterSettings clusterSettings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+        TestThreadPool testThreadPool = new TestThreadPool(getClass().getName(), settings);\n+\n+        MockLogAppender mockAppender = new MockLogAppender();\n+        mockAppender.start();\n+\n+        Logger logger = LogManager.getLogger(FsHealthService.class);\n+        Loggers.addAppender(logger, mockAppender);\n+        try (NodeEnvironment env = newNodeEnvironment()) {\n+            FsHealthService fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n+            int counter = 0;\n+            for(Path path : env.nodeDataPaths()){\n+                mockAppender.addExpectation(\n+                    new MockLogAppender.SeenEventExpectation(\n+                        \"test\"+ ++counter,\n+                        FsHealthService.class.getCanonicalName(),\n+                        Level.WARN,\n+                        \"checking writability of [\" + path.toString() + \"]\"));\n+            }\n+\n+            //disrupt file system\n+            disruptFileSystemProvider.injectIOException.set(true);\n+            fsHealthService.new FsHealthMonitor().run();\n+            assertEquals(disruptFileSystemProvider.getInjectedPathCount(), env.nodeDataPaths().length);\n+            assertBusy(mockAppender::assertAllExpectationsMatched);\n+        } finally {\n+            Loggers.removeAppender(logger, mockAppender);\n+            mockAppender.stop();\n+            PathUtilsForTesting.teardown();\n+            ThreadPool.terminate(testThreadPool, 500, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    public void testFailsHealthOnSinglePathFsyncFailure() throws IOException {\n+        FileSystem fileSystem = PathUtils.getDefaultFileSystem();\n+        FileSystemFsyncIOExceptionProvider disruptFsyncFileSystemProvider = new FileSystemFsyncIOExceptionProvider(fileSystem);\n+        fileSystem = disruptFsyncFileSystemProvider.getFileSystem(null);\n+        PathUtilsForTesting.installMock(fileSystem);\n+        final Settings settings = Settings.EMPTY;\n+        final ClusterSettings clusterSettings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+        TestThreadPool testThreadPool = new TestThreadPool(getClass().getName(), settings);\n+        try (NodeEnvironment env = newNodeEnvironment()) {\n+            Path[] paths = env.nodeDataPaths();\n+            FsHealthService fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n+            fsHealthService.new FsHealthMonitor().run();\n+            assertEquals(fsHealthService.getHealth().getStatus(), HEALTHY);\n+            assertEquals(fsHealthService.getHealth().getInfo(), \"All paths have passed writabililty checks\");\n+\n+            //disrupt file system fsync on single path\n+            disruptFsyncFileSystemProvider.injectIOException.set(true);\n+            String disruptedPath = randomFrom(paths).toString();\n+            disruptFsyncFileSystemProvider.restrictPathPrefix(disruptedPath);\n+            fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n+            fsHealthService.new FsHealthMonitor().run();\n+            assertEquals(fsHealthService.getHealth().getStatus(), UNHEALTHY);\n+            assertThat(fsHealthService.getHealth().getInfo(), is(\"Path(s) \"+ String.join(\",\", disruptedPath)\n+                + \" have failed writability checks\"));\n+            assertEquals(disruptFsyncFileSystemProvider.getInjectedPathCount(), 1);\n+        } finally {\n+            disruptFsyncFileSystemProvider.injectIOException.set(false);\n+            PathUtilsForTesting.teardown();\n+            ThreadPool.terminate(testThreadPool, 500, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    public void testFailsHealthOnSinglePathWriteFailure() throws IOException {\n+        FileSystem fileSystem = PathUtils.getDefaultFileSystem();\n+        FileSystemIOExceptionProvider disruptWritesFileSystemProvider = new FileSystemIOExceptionProvider(fileSystem);\n+        fileSystem = disruptWritesFileSystemProvider.getFileSystem(null);\n+        PathUtilsForTesting.installMock(fileSystem);\n+        final Settings settings = Settings.EMPTY;\n+        final ClusterSettings clusterSettings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+        TestThreadPool testThreadPool = new TestThreadPool(getClass().getName(), settings);\n+        try (NodeEnvironment env = newNodeEnvironment()) {\n+            Path[] paths = env.nodeDataPaths();\n+            FsHealthService fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n+            fsHealthService.new FsHealthMonitor().run();\n+            assertEquals(fsHealthService.getHealth().getStatus(), HEALTHY);\n+            assertEquals(fsHealthService.getHealth().getInfo(), \"All paths have passed writabililty checks\");\n+\n+            //disrupt file system writes on single path\n+            disruptWritesFileSystemProvider.injectIOException.set(true);\n+            String disruptedPath = randomFrom(paths).toString();\n+            disruptWritesFileSystemProvider.restrictPathPrefix(disruptedPath);\n+            fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n+            fsHealthService.new FsHealthMonitor().run();\n+            assertEquals(fsHealthService.getHealth().getStatus(), UNHEALTHY);\n+            assertThat(fsHealthService.getHealth().getInfo(), is(\"Path(s) \"+ String.join(\",\", disruptedPath)\n+                + \" have failed writability checks\"));\n+            assertEquals(disruptWritesFileSystemProvider.getInjectedPathCount(), 1);\n+        } finally {\n+            disruptWritesFileSystemProvider.injectIOException.set(false);\n+            PathUtilsForTesting.teardown();\n+            ThreadPool.terminate(testThreadPool, 500, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    private static class FileSystemIOExceptionProvider extends FilterFileSystemProvider {\n+\n+        AtomicBoolean injectIOException = new AtomicBoolean();\n+        AtomicInteger injectedPaths = new AtomicInteger();\n+\n+        private String pathPrefix = \"/\";\n+\n+        FileSystemIOExceptionProvider(FileSystem inner) {\n+            super(\"disrupt_fs_health://\", inner);\n+        }\n+\n+        public void restrictPathPrefix(String pathPrefix){\n+            this.pathPrefix = pathPrefix;\n+        }\n+\n+        public int getInjectedPathCount(){\n+            return injectedPaths.get();\n+        }\n+\n+        @Override\n+        public OutputStream newOutputStream(Path path, OpenOption... options) throws IOException {\n+            if (injectIOException.get()){\n+                if (path.toString().startsWith(pathPrefix) && path.toString().endsWith(\".es_temp_file\")) {\n+                    injectedPaths.incrementAndGet();\n+                    throw new IOException(\"fake IOException\");\n+                }\n+            }\n+            return super.newOutputStream(path, options);\n+        }\n+    }\n+\n+    private static class FileSystemFsyncIOExceptionProvider extends FilterFileSystemProvider {\n+\n+        AtomicBoolean injectIOException = new AtomicBoolean();\n+        AtomicInteger injectedPaths = new AtomicInteger();\n+\n+        private String pathPrefix = \"/\";\n+\n+        FileSystemFsyncIOExceptionProvider(FileSystem inner) {\n+            super(\"disrupt_fs_health://\", inner);\n+        }\n+\n+        public void restrictPathPrefix(String pathPrefix){\n+            this.pathPrefix = pathPrefix;\n+        }\n+\n+        public int getInjectedPathCount(){\n+            return injectedPaths.get();\n+        }\n+\n+        @Override\n+        public FileChannel newFileChannel(Path path, Set<? extends OpenOption> options, FileAttribute<?>... attrs) throws IOException {\n+            return new FilterFileChannel(super.newFileChannel(path, options, attrs)) {\n+                @Override\n+                public void force(boolean metaData) throws IOException {\n+                    if (injectIOException.get()) {\n+                        if (path.toString().startsWith(pathPrefix) && path.toString().endsWith(\".es_temp_file\")) {\n+                            injectedPaths.incrementAndGet();\n+                            throw new IOException(\"fake IOException\");\n+                        }\n+                    }\n+                    super.force(metaData);\n+                }\n+            };\n+        }\n+    }\n+\n+    private static class FileSystemFsyncHungProvider extends FilterFileSystemProvider {\n+\n+        AtomicBoolean injectIOException = new AtomicBoolean();\n+        AtomicInteger injectedPaths = new AtomicInteger();\n+\n+        private String pathPrefix = \"/\";\n+        private long delay;\n+\n+        FileSystemFsyncHungProvider(FileSystem inner, long delay) {\n+            super(\"disrupt_fs_health://\", inner);\n+            this.delay = delay;\n+        }\n+\n+        public int getInjectedPathCount(){\n+            return injectedPaths.get();\n+        }\n+\n+        @Override\n+        public FileChannel newFileChannel(Path path, Set<? extends OpenOption> options, FileAttribute<?>... attrs) throws IOException {\n+            return new FilterFileChannel(super.newFileChannel(path, options, attrs)) {\n+                @Override\n+                public void force(boolean metaData) throws IOException {\n+                    if (injectIOException.get()) {\n+                        if (path.toString().startsWith(pathPrefix) && path.toString().endsWith(\".es_temp_file\")) {\n+                            injectedPaths.incrementAndGet();\n+                            try {\n+                                Thread.sleep(delay);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "043db9301654ecc42de863c18571dfe9afc72bef"}, "originalPosition": 331}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bbf55176ba89d6ab097e9ddfb87ebef23ef67d70", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/bbf55176ba89d6ab097e9ddfb87ebef23ef67d70", "committedDate": "2020-06-18T10:53:46Z", "message": "Fix spacing in StatusInfo#toString"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1459937cf7763892b346b23eab4893805f7a7331", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/1459937cf7763892b346b23eab4893805f7a7331", "committedDate": "2020-06-18T10:54:04Z", "message": "Tidy 'skip prevoting' log message"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8eb5e2087b37eac9fb71b03308c4ca8ded70d6dc", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/8eb5e2087b37eac9fb71b03308c4ca8ded70d6dc", "committedDate": "2020-06-18T11:00:21Z", "message": "Tidy response messages in FollowersChecker"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2095d82b3c1cd9eaa21401030845f745f2a46fcf", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/2095d82b3c1cd9eaa21401030845f745f2a46fcf", "committedDate": "2020-06-18T11:02:05Z", "message": "Tidy log message in JoinHelper"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "39a0565941f9cb7eed461e161a39a16bf0695097", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/39a0565941f9cb7eed461e161a39a16bf0695097", "committedDate": "2020-06-18T11:04:03Z", "message": "Tidy message in PreVoteCollector"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "136bc441feebcb5be4d377ebd5480878b6770ae4", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/136bc441feebcb5be4d377ebd5480878b6770ae4", "committedDate": "2020-06-18T11:08:59Z", "message": "Tidy info messages"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1ab13b26dce3bb3bc8fa086f2c0b48ce27889d73", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/1ab13b26dce3bb3bc8fa086f2c0b48ce27889d73", "committedDate": "2020-06-18T11:09:28Z", "message": "Tidy tracing messages"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4143f8f378e7cfec487e88162887495cad0e7e2f", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/4143f8f378e7cfec487e88162887495cad0e7e2f", "committedDate": "2020-06-18T11:10:57Z", "message": "Tidy warn/error messages"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1d9a7abdb2c27a0ba661657a9a8ceba3dc046874", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/1d9a7abdb2c27a0ba661657a9a8ceba3dc046874", "committedDate": "2020-06-18T11:19:47Z", "message": "Fix up tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f2225299287205e5b0050d8c6e551c2642130eab", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/f2225299287205e5b0050d8c6e551c2642130eab", "committedDate": "2020-06-18T11:27:26Z", "message": "Fix too-short delay"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzMTkwMTMw", "url": "https://github.com/elastic/elasticsearch/pull/52680#pullrequestreview-433190130", "createdAt": "2020-06-18T11:29:04Z", "commit": {"oid": "f2225299287205e5b0050d8c6e551c2642130eab"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxMToyOTowNVrOGlrKkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxMTozMTo0MlrOGlrP2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjE1NzcxNQ==", "bodyText": "Can this happen? Looks to me that we already catch and log all exceptions in monitorFSHealth.", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r442157715", "createdAt": "2020-06-18T11:29:05Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.core.internal.io.IOUtils;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.monitor.NodeHealthService;\n+import org.elasticsearch.monitor.StatusInfo;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.function.LongSupplier;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.monitor.StatusInfo.Status.HEALTHY;\n+import static org.elasticsearch.monitor.StatusInfo.Status.UNHEALTHY;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent implements NodeHealthService {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private volatile TimeValue refreshInterval;\n+    private volatile TimeValue slowPathLoggingThreshold;\n+    private final NodeEnvironment nodeEnv;\n+    private final LongSupplier currentTimeMillisSupplier;\n+    private Map<Path, StatusInfo.Status> pathHealthStats;\n+    private volatile Scheduler.Cancellable scheduledFuture;\n+\n+    public static final Setting<Boolean> ENABLED_SETTING =\n+        Setting.boolSetting(\"monitor.fs.health.enabled\", true, Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> REFRESH_INTERVAL_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.refresh_interval\", TimeValue.timeValueSeconds(1), TimeValue.timeValueMillis(1),\n+            Setting.Property.NodeScope);\n+    public static final Setting<TimeValue> SLOW_PATH_LOGGING_THRESHOLD_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.slow_path_logging_threshold\", TimeValue.timeValueSeconds(5), TimeValue.timeValueMillis(1),\n+            Setting.Property.NodeScope, Setting.Property.Dynamic);\n+\n+\n+    public FsHealthService(Settings settings, ClusterSettings clusterSettings, ThreadPool threadPool, NodeEnvironment nodeEnv) {\n+        this.threadPool = threadPool;\n+        this.enabled = ENABLED_SETTING.get(settings);\n+        this.refreshInterval = REFRESH_INTERVAL_SETTING.get(settings);\n+        this.slowPathLoggingThreshold = SLOW_PATH_LOGGING_THRESHOLD_SETTING.get(settings);\n+        this.currentTimeMillisSupplier = threadPool::relativeTimeInMillis;\n+        this.nodeEnv = nodeEnv;\n+        this.pathHealthStats = new HashMap<>(1);\n+        clusterSettings.addSettingsUpdateConsumer(SLOW_PATH_LOGGING_THRESHOLD_SETTING, this::setSlowPathLoggingThreshold);\n+        clusterSettings.addSettingsUpdateConsumer(ENABLED_SETTING, this::setEnabled);\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        scheduledFuture = threadPool.scheduleWithFixedDelay(new FsHealthMonitor(), refreshInterval,\n+                ThreadPool.Names.GENERIC);\n+    }\n+\n+    @Override\n+    protected void doStop() {\n+        scheduledFuture.cancel();\n+    }\n+\n+    @Override\n+    protected void doClose() throws IOException {\n+\n+    }\n+\n+    public void setEnabled(boolean enabled) { this.enabled = enabled; }\n+\n+    public void setSlowPathLoggingThreshold(TimeValue slowPathLoggingThreshold) {\n+        this.slowPathLoggingThreshold = slowPathLoggingThreshold;\n+    }\n+\n+    @Override\n+    public StatusInfo getHealth() {\n+        StatusInfo statusInfo;\n+        if (enabled == false) {\n+            statusInfo = new StatusInfo(HEALTHY, \"health check disabled\");\n+        }\n+        else if (pathHealthStats.entrySet().stream().anyMatch(map -> map.getValue() == UNHEALTHY)) {\n+            String info = \"health check failed on [\" + pathHealthStats.entrySet()\n+                .stream().filter(v -> v.getValue() == UNHEALTHY)\n+                .map(k -> k.getKey().toString())\n+                .collect(Collectors.joining(\",\")) + \"]\";\n+\n+            statusInfo = new StatusInfo(UNHEALTHY, info);\n+        }\n+        else {\n+            statusInfo = new StatusInfo(HEALTHY, \"health check passed\");\n+        }\n+        return statusInfo;\n+    }\n+\n+     class FsHealthMonitor implements Runnable {\n+\n+        static final String TEMP_FILE_NAME = \".es_temp_file\";\n+        private byte[] byteToWrite;\n+\n+        FsHealthMonitor(){\n+            this.byteToWrite = new byte[20];\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                if (enabled) {\n+                    monitorFSHealth();\n+                    logger.debug(\"health check succeeded: {}\", pathHealthStats);\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"health check failed\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2225299287205e5b0050d8c6e551c2642130eab"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjE1ODU5MQ==", "bodyText": "All these usages of assertEquals are backwards: it's assertEquals(expected, actual) but you've put the expected value second.", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r442158591", "createdAt": "2020-06-18T11:30:46Z", "author": {"login": "DaveCTurner"}, "path": "server/src/test/java/org/elasticsearch/monitor/fs/FsHealthServiceTests.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.monitor.fs;\n+\n+\n+import org.apache.logging.log4j.Level;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.lucene.mockfile.FilterFileChannel;\n+import org.apache.lucene.mockfile.FilterFileSystemProvider;\n+import org.elasticsearch.cluster.coordination.DeterministicTaskQueue;\n+import org.elasticsearch.common.io.PathUtils;\n+import org.elasticsearch.common.io.PathUtilsForTesting;\n+import org.elasticsearch.common.logging.Loggers;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.test.MockLogAppender;\n+import org.elasticsearch.test.junit.annotations.TestLogging;\n+import org.elasticsearch.threadpool.TestThreadPool;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.junit.Before;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.FileSystem;\n+import java.nio.file.OpenOption;\n+import java.nio.file.Path;\n+import java.nio.file.attribute.FileAttribute;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.elasticsearch.monitor.StatusInfo.Status.HEALTHY;\n+import static org.elasticsearch.monitor.StatusInfo.Status.UNHEALTHY;\n+import static org.elasticsearch.node.Node.NODE_NAME_SETTING;\n+import static org.hamcrest.Matchers.is;\n+\n+\n+public class FsHealthServiceTests extends ESTestCase {\n+\n+    private DeterministicTaskQueue deterministicTaskQueue;\n+\n+    @Before\n+    public void createObjects() {\n+        Settings settings = Settings.builder().put(NODE_NAME_SETTING.getKey(), \"node\").build();\n+        deterministicTaskQueue = new DeterministicTaskQueue(settings, random());\n+    }\n+\n+    public void testSchedulesHealthCheckAtRefreshIntervals() throws Exception {\n+        long refreshInterval = randomLongBetween(1000, 12000);\n+        final Settings settings = Settings.builder().put(FsHealthService.REFRESH_INTERVAL_SETTING.getKey(), refreshInterval + \"ms\").build();\n+        final ClusterSettings clusterSettings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+        try (NodeEnvironment env = newNodeEnvironment()) {\n+            FsHealthService fsHealthService = new FsHealthService(settings, clusterSettings, deterministicTaskQueue.getThreadPool(), env);\n+            final long startTimeMillis = deterministicTaskQueue.getCurrentTimeMillis();\n+            fsHealthService.doStart();\n+            assertFalse(deterministicTaskQueue.hasRunnableTasks());\n+            assertTrue(deterministicTaskQueue.hasDeferredTasks());\n+            int rescheduledCount = 0;\n+            for (int i = 1; i <= randomIntBetween(5, 10); i++) {\n+                if (deterministicTaskQueue.hasRunnableTasks()) {\n+                    deterministicTaskQueue.runRandomTask();\n+                } else {\n+                    assertThat(deterministicTaskQueue.getLatestDeferredExecutionTime(), is(refreshInterval * (rescheduledCount + 1)));\n+                    deterministicTaskQueue.advanceTime();\n+                    rescheduledCount++;\n+                }\n+                assertThat(deterministicTaskQueue.getCurrentTimeMillis() - startTimeMillis, is(refreshInterval * rescheduledCount));\n+            }\n+\n+            fsHealthService.doStop();\n+            deterministicTaskQueue.runAllTasksInTimeOrder();\n+\n+            assertFalse(deterministicTaskQueue.hasRunnableTasks());\n+            assertFalse(deterministicTaskQueue.hasDeferredTasks());\n+        }\n+    }\n+\n+    public void testFailsHealthOnIOException() throws IOException {\n+        FileSystem fileSystem = PathUtils.getDefaultFileSystem();\n+        FileSystemIOExceptionProvider disruptFileSystemProvider = new FileSystemIOExceptionProvider(fileSystem);\n+        fileSystem = disruptFileSystemProvider.getFileSystem(null);\n+        PathUtilsForTesting.installMock(fileSystem);\n+        final Settings settings = Settings.EMPTY;\n+        final ClusterSettings clusterSettings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+        TestThreadPool testThreadPool = new TestThreadPool(getClass().getName(), settings);\n+        try (NodeEnvironment env = newNodeEnvironment()) {\n+            FsHealthService fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n+            fsHealthService.new FsHealthMonitor().run();\n+            assertEquals(fsHealthService.getHealth().getStatus(), HEALTHY);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2225299287205e5b0050d8c6e551c2642130eab"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjE1OTA2NA==", "bodyText": "NB this needed a loop as a simple Thread.sleep() isn't enough to guarantee that the threadpool's clock has advanced.", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r442159064", "createdAt": "2020-06-18T11:31:42Z", "author": {"login": "DaveCTurner"}, "path": "server/src/test/java/org/elasticsearch/monitor/fs/FsHealthServiceTests.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.monitor.fs;\n+\n+\n+import org.apache.logging.log4j.Level;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.lucene.mockfile.FilterFileChannel;\n+import org.apache.lucene.mockfile.FilterFileSystemProvider;\n+import org.elasticsearch.cluster.coordination.DeterministicTaskQueue;\n+import org.elasticsearch.common.io.PathUtils;\n+import org.elasticsearch.common.io.PathUtilsForTesting;\n+import org.elasticsearch.common.logging.Loggers;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.test.MockLogAppender;\n+import org.elasticsearch.test.junit.annotations.TestLogging;\n+import org.elasticsearch.threadpool.TestThreadPool;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.junit.Before;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.FileSystem;\n+import java.nio.file.OpenOption;\n+import java.nio.file.Path;\n+import java.nio.file.attribute.FileAttribute;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.elasticsearch.monitor.StatusInfo.Status.HEALTHY;\n+import static org.elasticsearch.monitor.StatusInfo.Status.UNHEALTHY;\n+import static org.elasticsearch.node.Node.NODE_NAME_SETTING;\n+import static org.hamcrest.Matchers.is;\n+\n+\n+public class FsHealthServiceTests extends ESTestCase {\n+\n+    private DeterministicTaskQueue deterministicTaskQueue;\n+\n+    @Before\n+    public void createObjects() {\n+        Settings settings = Settings.builder().put(NODE_NAME_SETTING.getKey(), \"node\").build();\n+        deterministicTaskQueue = new DeterministicTaskQueue(settings, random());\n+    }\n+\n+    public void testSchedulesHealthCheckAtRefreshIntervals() throws Exception {\n+        long refreshInterval = randomLongBetween(1000, 12000);\n+        final Settings settings = Settings.builder().put(FsHealthService.REFRESH_INTERVAL_SETTING.getKey(), refreshInterval + \"ms\").build();\n+        final ClusterSettings clusterSettings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+        try (NodeEnvironment env = newNodeEnvironment()) {\n+            FsHealthService fsHealthService = new FsHealthService(settings, clusterSettings, deterministicTaskQueue.getThreadPool(), env);\n+            final long startTimeMillis = deterministicTaskQueue.getCurrentTimeMillis();\n+            fsHealthService.doStart();\n+            assertFalse(deterministicTaskQueue.hasRunnableTasks());\n+            assertTrue(deterministicTaskQueue.hasDeferredTasks());\n+            int rescheduledCount = 0;\n+            for (int i = 1; i <= randomIntBetween(5, 10); i++) {\n+                if (deterministicTaskQueue.hasRunnableTasks()) {\n+                    deterministicTaskQueue.runRandomTask();\n+                } else {\n+                    assertThat(deterministicTaskQueue.getLatestDeferredExecutionTime(), is(refreshInterval * (rescheduledCount + 1)));\n+                    deterministicTaskQueue.advanceTime();\n+                    rescheduledCount++;\n+                }\n+                assertThat(deterministicTaskQueue.getCurrentTimeMillis() - startTimeMillis, is(refreshInterval * rescheduledCount));\n+            }\n+\n+            fsHealthService.doStop();\n+            deterministicTaskQueue.runAllTasksInTimeOrder();\n+\n+            assertFalse(deterministicTaskQueue.hasRunnableTasks());\n+            assertFalse(deterministicTaskQueue.hasDeferredTasks());\n+        }\n+    }\n+\n+    public void testFailsHealthOnIOException() throws IOException {\n+        FileSystem fileSystem = PathUtils.getDefaultFileSystem();\n+        FileSystemIOExceptionProvider disruptFileSystemProvider = new FileSystemIOExceptionProvider(fileSystem);\n+        fileSystem = disruptFileSystemProvider.getFileSystem(null);\n+        PathUtilsForTesting.installMock(fileSystem);\n+        final Settings settings = Settings.EMPTY;\n+        final ClusterSettings clusterSettings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+        TestThreadPool testThreadPool = new TestThreadPool(getClass().getName(), settings);\n+        try (NodeEnvironment env = newNodeEnvironment()) {\n+            FsHealthService fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n+            fsHealthService.new FsHealthMonitor().run();\n+            assertEquals(fsHealthService.getHealth().getStatus(), HEALTHY);\n+            assertEquals(fsHealthService.getHealth().getInfo(), \"health check passed\");\n+\n+            //disrupt file system\n+            disruptFileSystemProvider.injectIOException.set(true);\n+            fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n+            fsHealthService.new FsHealthMonitor().run();\n+            assertEquals(fsHealthService.getHealth().getStatus(), UNHEALTHY);\n+            for (Path path : env.nodeDataPaths()) {\n+                assertTrue(fsHealthService.getHealth().getInfo().contains(path.toString()));\n+            }\n+            assertEquals(disruptFileSystemProvider.getInjectedPathCount(), env.nodeDataPaths().length);\n+        } finally {\n+            disruptFileSystemProvider.injectIOException.set(false);\n+            PathUtilsForTesting.teardown();\n+            ThreadPool.terminate(testThreadPool, 500, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    @TestLogging(value = \"org.elasticsearch.monitor.fs:WARN\", reason = \"to ensure that we log on hung IO at WARN level\")\n+    public void testLoggingOnHungIO() throws Exception {\n+        long slowLogThreshold = randomLongBetween(100, 200);\n+        final Settings settings = Settings.builder().put(FsHealthService.SLOW_PATH_LOGGING_THRESHOLD_SETTING.getKey(),\n+            slowLogThreshold + \"ms\").build();\n+        FileSystem fileSystem = PathUtils.getDefaultFileSystem();\n+        TestThreadPool testThreadPool = new TestThreadPool(getClass().getName(), settings);\n+        FileSystemFsyncHungProvider disruptFileSystemProvider = new FileSystemFsyncHungProvider(fileSystem,\n+            randomLongBetween(slowLogThreshold + 1 , 400), testThreadPool);\n+        fileSystem = disruptFileSystemProvider.getFileSystem(null);\n+        PathUtilsForTesting.installMock(fileSystem);\n+        final ClusterSettings clusterSettings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+\n+        MockLogAppender mockAppender = new MockLogAppender();\n+        mockAppender.start();\n+\n+        Logger logger = LogManager.getLogger(FsHealthService.class);\n+        Loggers.addAppender(logger, mockAppender);\n+        try (NodeEnvironment env = newNodeEnvironment()) {\n+            FsHealthService fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n+            int counter = 0;\n+            for(Path path : env.nodeDataPaths()){\n+                mockAppender.addExpectation(\n+                    new MockLogAppender.SeenEventExpectation(\n+                        \"test\" + ++counter,\n+                        FsHealthService.class.getCanonicalName(),\n+                        Level.WARN,\n+                        \"health check of [\" + path + \"] took [*ms] which is above the warn threshold*\"));\n+            }\n+\n+            //disrupt file system\n+            disruptFileSystemProvider.injectIOException.set(true);\n+            fsHealthService.new FsHealthMonitor().run();\n+            assertEquals(disruptFileSystemProvider.getInjectedPathCount(), env.nodeDataPaths().length);\n+            assertBusy(mockAppender::assertAllExpectationsMatched);\n+        } finally {\n+            Loggers.removeAppender(logger, mockAppender);\n+            mockAppender.stop();\n+            PathUtilsForTesting.teardown();\n+            ThreadPool.terminate(testThreadPool, 500, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    public void testFailsHealthOnSinglePathFsyncFailure() throws IOException {\n+        FileSystem fileSystem = PathUtils.getDefaultFileSystem();\n+        FileSystemFsyncIOExceptionProvider disruptFsyncFileSystemProvider = new FileSystemFsyncIOExceptionProvider(fileSystem);\n+        fileSystem = disruptFsyncFileSystemProvider.getFileSystem(null);\n+        PathUtilsForTesting.installMock(fileSystem);\n+        final Settings settings = Settings.EMPTY;\n+        final ClusterSettings clusterSettings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+        TestThreadPool testThreadPool = new TestThreadPool(getClass().getName(), settings);\n+        try (NodeEnvironment env = newNodeEnvironment()) {\n+            Path[] paths = env.nodeDataPaths();\n+            FsHealthService fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n+            fsHealthService.new FsHealthMonitor().run();\n+            assertEquals(fsHealthService.getHealth().getStatus(), HEALTHY);\n+            assertEquals(fsHealthService.getHealth().getInfo(), \"health check passed\");\n+\n+            //disrupt file system fsync on single path\n+            disruptFsyncFileSystemProvider.injectIOException.set(true);\n+            String disruptedPath = randomFrom(paths).toString();\n+            disruptFsyncFileSystemProvider.restrictPathPrefix(disruptedPath);\n+            fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n+            fsHealthService.new FsHealthMonitor().run();\n+            assertEquals(fsHealthService.getHealth().getStatus(), UNHEALTHY);\n+            assertThat(fsHealthService.getHealth().getInfo(), is(\"health check failed on [\" + disruptedPath + \"]\"));\n+            assertEquals(disruptFsyncFileSystemProvider.getInjectedPathCount(), 1);\n+        } finally {\n+            disruptFsyncFileSystemProvider.injectIOException.set(false);\n+            PathUtilsForTesting.teardown();\n+            ThreadPool.terminate(testThreadPool, 500, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    public void testFailsHealthOnSinglePathWriteFailure() throws IOException {\n+        FileSystem fileSystem = PathUtils.getDefaultFileSystem();\n+        FileSystemIOExceptionProvider disruptWritesFileSystemProvider = new FileSystemIOExceptionProvider(fileSystem);\n+        fileSystem = disruptWritesFileSystemProvider.getFileSystem(null);\n+        PathUtilsForTesting.installMock(fileSystem);\n+        final Settings settings = Settings.EMPTY;\n+        final ClusterSettings clusterSettings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+        TestThreadPool testThreadPool = new TestThreadPool(getClass().getName(), settings);\n+        try (NodeEnvironment env = newNodeEnvironment()) {\n+            Path[] paths = env.nodeDataPaths();\n+            FsHealthService fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n+            fsHealthService.new FsHealthMonitor().run();\n+            assertEquals(fsHealthService.getHealth().getStatus(), HEALTHY);\n+            assertEquals(fsHealthService.getHealth().getInfo(), \"health check passed\");\n+\n+            //disrupt file system writes on single path\n+            disruptWritesFileSystemProvider.injectIOException.set(true);\n+            String disruptedPath = randomFrom(paths).toString();\n+            disruptWritesFileSystemProvider.restrictPathPrefix(disruptedPath);\n+            fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n+            fsHealthService.new FsHealthMonitor().run();\n+            assertEquals(fsHealthService.getHealth().getStatus(), UNHEALTHY);\n+            assertThat(fsHealthService.getHealth().getInfo(), is(\"health check failed on [\" + disruptedPath + \"]\"));\n+            assertEquals(disruptWritesFileSystemProvider.getInjectedPathCount(), 1);\n+        } finally {\n+            disruptWritesFileSystemProvider.injectIOException.set(false);\n+            PathUtilsForTesting.teardown();\n+            ThreadPool.terminate(testThreadPool, 500, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    private static class FileSystemIOExceptionProvider extends FilterFileSystemProvider {\n+\n+        AtomicBoolean injectIOException = new AtomicBoolean();\n+        AtomicInteger injectedPaths = new AtomicInteger();\n+\n+        private String pathPrefix = \"/\";\n+\n+        FileSystemIOExceptionProvider(FileSystem inner) {\n+            super(\"disrupt_fs_health://\", inner);\n+        }\n+\n+        public void restrictPathPrefix(String pathPrefix){\n+            this.pathPrefix = pathPrefix;\n+        }\n+\n+        public int getInjectedPathCount(){\n+            return injectedPaths.get();\n+        }\n+\n+        @Override\n+        public OutputStream newOutputStream(Path path, OpenOption... options) throws IOException {\n+            if (injectIOException.get()){\n+                if (path.toString().startsWith(pathPrefix) && path.toString().endsWith(\".es_temp_file\")) {\n+                    injectedPaths.incrementAndGet();\n+                    throw new IOException(\"fake IOException\");\n+                }\n+            }\n+            return super.newOutputStream(path, options);\n+        }\n+    }\n+\n+    private static class FileSystemFsyncIOExceptionProvider extends FilterFileSystemProvider {\n+\n+        AtomicBoolean injectIOException = new AtomicBoolean();\n+        AtomicInteger injectedPaths = new AtomicInteger();\n+\n+        private String pathPrefix = \"/\";\n+\n+        FileSystemFsyncIOExceptionProvider(FileSystem inner) {\n+            super(\"disrupt_fs_health://\", inner);\n+        }\n+\n+        public void restrictPathPrefix(String pathPrefix){\n+            this.pathPrefix = pathPrefix;\n+        }\n+\n+        public int getInjectedPathCount(){\n+            return injectedPaths.get();\n+        }\n+\n+        @Override\n+        public FileChannel newFileChannel(Path path, Set<? extends OpenOption> options, FileAttribute<?>... attrs) throws IOException {\n+            return new FilterFileChannel(super.newFileChannel(path, options, attrs)) {\n+                @Override\n+                public void force(boolean metaData) throws IOException {\n+                    if (injectIOException.get()) {\n+                        if (path.toString().startsWith(pathPrefix) && path.toString().endsWith(\".es_temp_file\")) {\n+                            injectedPaths.incrementAndGet();\n+                            throw new IOException(\"fake IOException\");\n+                        }\n+                    }\n+                    super.force(metaData);\n+                }\n+            };\n+        }\n+    }\n+\n+    private static class FileSystemFsyncHungProvider extends FilterFileSystemProvider {\n+\n+        AtomicBoolean injectIOException = new AtomicBoolean();\n+        AtomicInteger injectedPaths = new AtomicInteger();\n+\n+        private String pathPrefix = \"/\";\n+        private long delay;\n+        private final ThreadPool threadPool;\n+\n+        FileSystemFsyncHungProvider(FileSystem inner, long delay, ThreadPool threadPool) {\n+            super(\"disrupt_fs_health://\", inner);\n+            this.delay = delay;\n+            this.threadPool = threadPool;\n+        }\n+\n+        public int getInjectedPathCount(){\n+            return injectedPaths.get();\n+        }\n+\n+        @Override\n+        public FileChannel newFileChannel(Path path, Set<? extends OpenOption> options, FileAttribute<?>... attrs) throws IOException {\n+            return new FilterFileChannel(super.newFileChannel(path, options, attrs)) {\n+                @Override\n+                public void force(boolean metaData) throws IOException {\n+                    if (injectIOException.get()) {\n+                        if (path.toString().startsWith(pathPrefix) && path.toString().endsWith(\".es_temp_file\")) {\n+                            injectedPaths.incrementAndGet();\n+                            final long startTimeMillis = threadPool.relativeTimeInMillis();\n+                            do {\n+                                try {\n+                                    Thread.sleep(delay);\n+                                } catch (InterruptedException e) {\n+                                    throw new AssertionError(e);\n+                                }\n+                            } while (threadPool.relativeTimeInMillis() <= startTimeMillis + delay);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2225299287205e5b0050d8c6e551c2642130eab"}, "originalPosition": 337}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "befd8228ac2995653fdb618bf3c17bc57bf283cc", "author": {"user": {"login": "Bukhtawar", "name": "Bukhtawar Khan"}}, "url": "https://github.com/elastic/elasticsearch/commit/befd8228ac2995653fdb618bf3c17bc57bf283cc", "committedDate": "2020-06-18T15:18:49Z", "message": "Minor fixes to Follower and FsHealthService"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "061dd3311bdb1ddeadb07f1d9124ab2a586eb546", "author": {"user": {"login": "Bukhtawar", "name": "Bukhtawar Khan"}}, "url": "https://github.com/elastic/elasticsearch/commit/061dd3311bdb1ddeadb07f1d9124ab2a586eb546", "committedDate": "2020-06-18T15:30:38Z", "message": "Fix assertions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cda2179f9da031607e7ddd3426d0b03a561d47f8", "author": {"user": {"login": "Bukhtawar", "name": "Bukhtawar Khan"}}, "url": "https://github.com/elastic/elasticsearch/commit/cda2179f9da031607e7ddd3426d0b03a561d47f8", "committedDate": "2020-06-18T17:34:28Z", "message": "Leader checks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4d83de02f19a4d35effdefce93b49b024569bf01", "author": {"user": {"login": "Bukhtawar", "name": "Bukhtawar Khan"}}, "url": "https://github.com/elastic/elasticsearch/commit/4d83de02f19a4d35effdefce93b49b024569bf01", "committedDate": "2020-06-19T05:13:05Z", "message": "Leader check tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e41392fc12363ff5383551516490cd3e9238a086", "author": {"user": {"login": "Bukhtawar", "name": "Bukhtawar Khan"}}, "url": "https://github.com/elastic/elasticsearch/commit/e41392fc12363ff5383551516490cd3e9238a086", "committedDate": "2020-06-19T06:49:59Z", "message": "cluster reduce stabilization time after unhealthy node"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "67d49bb5fbf3b3f76910439c6f78fb486a884bc2", "author": {"user": {"login": "Bukhtawar", "name": "Bukhtawar Khan"}}, "url": "https://github.com/elastic/elasticsearch/commit/67d49bb5fbf3b3f76910439c6f78fb486a884bc2", "committedDate": "2020-06-19T06:57:20Z", "message": "Minor fix up"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa3cc697fdabf23e4d1007ea0decc90c51f9beab", "author": {"user": {"login": "Bukhtawar", "name": "Bukhtawar Khan"}}, "url": "https://github.com/elastic/elasticsearch/commit/fa3cc697fdabf23e4d1007ea0decc90c51f9beab", "committedDate": "2020-06-19T11:55:50Z", "message": "ClusterFormationFailureHelper changes and more tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "89035fb50b690c171859d1c9cd2345329b79d752", "author": {"user": {"login": "Bukhtawar", "name": "Bukhtawar Khan"}}, "url": "https://github.com/elastic/elasticsearch/commit/89035fb50b690c171859d1c9cd2345329b79d752", "committedDate": "2020-06-21T08:42:57Z", "message": "Minor changes to LeaderChecker"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "adbe670e530c1be18278c9156da17f5a05261c4c", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/adbe670e530c1be18278c9156da17f5a05261c4c", "committedDate": "2020-06-24T15:30:25Z", "message": "Pass StatusInfo to ClusterFormationState and simplify message"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fdcdf45bad1d1dc71da4487beab8937b4e5938a4", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/fdcdf45bad1d1dc71da4487beab8937b4e5938a4", "committedDate": "2020-06-24T15:37:55Z", "message": "Whitespace"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "deafeca4a0a3197389bb4728a25c7f4dca74dd74", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/deafeca4a0a3197389bb4728a25c7f4dca74dd74", "committedDate": "2020-06-24T15:55:43Z", "message": "Imports"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1120428f20792607767d89cb9da69e0d9fa9fddb", "author": {"user": {"login": "Bukhtawar", "name": "Bukhtawar Khan"}}, "url": "https://github.com/elastic/elasticsearch/commit/1120428f20792607767d89cb9da69e0d9fa9fddb", "committedDate": "2020-06-24T17:40:02Z", "message": "Fixing Random"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "23bc4e5ceae2cac7f9603e35685b4b60f63f9d48", "author": {"user": {"login": "Bukhtawar", "name": "Bukhtawar Khan"}}, "url": "https://github.com/elastic/elasticsearch/commit/23bc4e5ceae2cac7f9603e35685b4b60f63f9d48", "committedDate": "2020-06-24T17:41:10Z", "message": "Merge remote-tracking branch 'upstream/master'"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "06b14b8435569b7032047fc518b2d2aa387b331e", "author": {"user": {"login": "Bukhtawar", "name": "Bukhtawar Khan"}}, "url": "https://github.com/elastic/elasticsearch/commit/06b14b8435569b7032047fc518b2d2aa387b331e", "committedDate": "2020-06-24T17:44:00Z", "message": "Merge branch 'master' into ro-fs-handling"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "56fb9b3e21cae8fa4dce8fbbfbd49dbf440d10b0", "author": {"user": {"login": "Bukhtawar", "name": "Bukhtawar Khan"}}, "url": "https://github.com/elastic/elasticsearch/commit/56fb9b3e21cae8fa4dce8fbbfbd49dbf440d10b0", "committedDate": "2020-06-24T17:55:23Z", "message": "ForbiddenApis for charset"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0d7b72f69e3afaf3409fa1c4fe4bab8bf3448c24", "author": {"user": {"login": "Bukhtawar", "name": "Bukhtawar Khan"}}, "url": "https://github.com/elastic/elasticsearch/commit/0d7b72f69e3afaf3409fa1c4fe4bab8bf3448c24", "committedDate": "2020-06-24T18:21:46Z", "message": "Fix logger"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f390ed875090811dde3eb3da5c66c9009bcf4859", "author": {"user": {"login": "Bukhtawar", "name": "Bukhtawar Khan"}}, "url": "https://github.com/elastic/elasticsearch/commit/f390ed875090811dde3eb3da5c66c9009bcf4859", "committedDate": "2020-06-24T19:21:13Z", "message": "Merge remote-tracking branch 'upstream/master' into ro-fs-handling"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5MDY4MjEw", "url": "https://github.com/elastic/elasticsearch/pull/52680#pullrequestreview-439068210", "createdAt": "2020-06-29T11:59:07Z", "commit": {"oid": "f390ed875090811dde3eb3da5c66c9009bcf4859"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxMTo1OTowN1rOGqNgoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxMTo1OTowN1rOGqNgoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkxNDcyMA==", "bodyText": "This could yield a NullPointerException if unhealthyPaths were set to null since the previous time we read it. Suggest performing a single read of the volatile field into a local variable and then using that instead.", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r446914720", "createdAt": "2020-06-29T11:59:07Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.UUIDs;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.core.internal.io.IOUtils;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.monitor.NodeHealthService;\n+import org.elasticsearch.monitor.StatusInfo;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.function.LongSupplier;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.monitor.StatusInfo.Status.HEALTHY;\n+import static org.elasticsearch.monitor.StatusInfo.Status.UNHEALTHY;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent implements NodeHealthService {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private final TimeValue refreshInterval;\n+    private volatile TimeValue slowPathLoggingThreshold;\n+    private final NodeEnvironment nodeEnv;\n+    private final LongSupplier currentTimeMillisSupplier;\n+    private volatile Scheduler.Cancellable scheduledFuture;\n+\n+    @Nullable\n+    private volatile Set<Path> unhealthyPaths;\n+\n+    public static final Setting<Boolean> ENABLED_SETTING =\n+        Setting.boolSetting(\"monitor.fs.health.enabled\", true, Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> REFRESH_INTERVAL_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.refresh_interval\", TimeValue.timeValueSeconds(120), TimeValue.timeValueMillis(1),\n+            Setting.Property.NodeScope);\n+    public static final Setting<TimeValue> SLOW_PATH_LOGGING_THRESHOLD_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.slow_path_logging_threshold\", TimeValue.timeValueSeconds(5), TimeValue.timeValueMillis(1),\n+            Setting.Property.NodeScope, Setting.Property.Dynamic);\n+\n+\n+    public FsHealthService(Settings settings, ClusterSettings clusterSettings, ThreadPool threadPool, NodeEnvironment nodeEnv) {\n+        this.threadPool = threadPool;\n+        this.enabled = ENABLED_SETTING.get(settings);\n+        this.refreshInterval = REFRESH_INTERVAL_SETTING.get(settings);\n+        this.slowPathLoggingThreshold = SLOW_PATH_LOGGING_THRESHOLD_SETTING.get(settings);\n+        this.currentTimeMillisSupplier = threadPool::relativeTimeInMillis;\n+        this.nodeEnv = nodeEnv;\n+        clusterSettings.addSettingsUpdateConsumer(SLOW_PATH_LOGGING_THRESHOLD_SETTING, this::setSlowPathLoggingThreshold);\n+        clusterSettings.addSettingsUpdateConsumer(ENABLED_SETTING, this::setEnabled);\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        scheduledFuture = threadPool.scheduleWithFixedDelay(new FsHealthMonitor(), refreshInterval,\n+                ThreadPool.Names.GENERIC);\n+    }\n+\n+    @Override\n+    protected void doStop() {\n+        scheduledFuture.cancel();\n+    }\n+\n+    @Override\n+    protected void doClose() {\n+    }\n+\n+    public void setEnabled(boolean enabled) {\n+        this.enabled = enabled;\n+    }\n+\n+    public void setSlowPathLoggingThreshold(TimeValue slowPathLoggingThreshold) {\n+        this.slowPathLoggingThreshold = slowPathLoggingThreshold;\n+    }\n+\n+    @Override\n+    public StatusInfo getHealth() {\n+        StatusInfo statusInfo;\n+        if (enabled == false) {\n+            statusInfo = new StatusInfo(HEALTHY, \"health check disabled\");\n+        } else if (unhealthyPaths == null) {\n+            statusInfo = new StatusInfo(HEALTHY, \"health check passed\");\n+        } else {\n+            String info = \"health check failed on [\" + unhealthyPaths.stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f390ed875090811dde3eb3da5c66c9009bcf4859"}, "originalPosition": 122}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f44cf0d658ebb6e3c9f5e4950dff0bade0dd9f0f", "author": {"user": {"login": "Bukhtawar", "name": "Bukhtawar Khan"}}, "url": "https://github.com/elastic/elasticsearch/commit/f44cf0d658ebb6e3c9f5e4950dff0bade0dd9f0f", "committedDate": "2020-06-29T12:31:08Z", "message": "NPE handling"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "97a4c02a9eafbea0122e1226cf64042eba8c48b2", "author": {"user": {"login": "Bukhtawar", "name": "Bukhtawar Khan"}}, "url": "https://github.com/elastic/elasticsearch/commit/97a4c02a9eafbea0122e1226cf64042eba8c48b2", "committedDate": "2020-06-29T13:20:36Z", "message": "Merge remote-tracking branch 'upstream/master' into ro-fs-handling"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "54d7c98fc4f0ee6fe1a27e64eb5ec1a6e9f7503a", "author": {"user": {"login": "Bukhtawar", "name": "Bukhtawar Khan"}}, "url": "https://github.com/elastic/elasticsearch/commit/54d7c98fc4f0ee6fe1a27e64eb5ec1a6e9f7503a", "committedDate": "2020-07-02T05:31:35Z", "message": "Merge remote-tracking branch 'upstream/master' into ro-fs-handling"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aae514278d14d9c5a56903b5c18df54def23db95", "author": {"user": {"login": "Bukhtawar", "name": "Bukhtawar Khan"}}, "url": "https://github.com/elastic/elasticsearch/commit/aae514278d14d9c5a56903b5c18df54def23db95", "committedDate": "2020-07-03T11:25:52Z", "message": "Merge remote-tracking branch 'upstream/master' into ro-fs-handling"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzNzYxNDA4", "url": "https://github.com/elastic/elasticsearch/pull/52680#pullrequestreview-443761408", "createdAt": "2020-07-07T10:25:47Z", "commit": {"oid": "aae514278d14d9c5a56903b5c18df54def23db95"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2099, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}