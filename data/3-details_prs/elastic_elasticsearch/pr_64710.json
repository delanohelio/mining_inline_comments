{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE2NzUyNTIx", "number": 64710, "title": "Protect replicated data streams against local rollovers", "bodyText": "When a data stream is being auto followed then a rollover in a local cluster can break auto following,\nif the local cluster performs a rollover then it creates a new write index and if then later the remote\ncluster rolls over as well then that new write index can't be replicated, because it has the same name\nas in the write index in the local cluster, which was created earlier.\nIf a data stream is managed by ccr, then the local cluster should not do a rollover for those data streams.\nThe data stream should be rolled over in the remote cluster and that change should replicate to the local\ncluster. Performing a rollover in the local cluster is an operation that the data stream support in ccr should\nperform.\nTo protect against rolling over a replicated data stream, this PR adds a replicate field to DataStream class.\nThe rollover api will fail with an error in case a data stream is being rolled over and the targeted data stream is\na replicated data stream. When the put follow api creates a data stream in the local cluster then the replicate flag\nis set to true. There should be a way to turn a replicated data stream into a regular data stream when for example\nduring disaster recovery. The newly added api in this pr (promote data stream api) is doing that. After a replicated\ndata stream is promoted to a regular data stream then the local data stream can be rolled over, so that the new\nwrite index is no longer a follower index. Also if the put follow api is attempting to update this data stream\n(for example to attempt to resume auto following) then that with fail, because the data stream is no longer a\nreplicated data stream.\nToday with time based indices behind an alias, the is_write_index property isn't replicated from remote cluster\nto the local cluster, so when attempting to rollover the alias in the local cluster the rollover fails, because the\nalias doesn't have a write index. The added replicated field in the DataStream class and added validation\nachieve the same kind of protection, but in a more robust way.\nA followup from #61993.\n(labelling this PR as non-issue, since data stream support for CCR hasn't been released yet)", "createdAt": "2020-11-06T13:45:29Z", "url": "https://github.com/elastic/elasticsearch/pull/64710", "merged": true, "mergeCommit": {"oid": "52afaf20606197756c0820efc7ad04cf62d4b462"}, "closed": true, "closedAt": "2020-12-08T07:34:25Z", "author": {"login": "martijnvg"}, "timelineItems": {"totalCount": 33, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdZ1JnmgH2gAyNTE2NzUyNTIxOmYwZDkwNzYyN2ZjZGIyOGY0ZTI2NTRhZTNiZGUyNTU5YzY4NDAyZTM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdkESe3gH2gAyNTE2NzUyNTIxOmE4MGY3NzcwNmM0ZDg5YzU3YWYyY2QyYzdhNTlhZjE0OGRlODQzNGM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "f0d907627fcdb28f4e2654ae3bde2559c68402e3", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/f0d907627fcdb28f4e2654ae3bde2559c68402e3", "committedDate": "2020-11-06T11:20:49Z", "message": "Added test that fails now, but tests that rolling over a data stream that follows a remote data stream fails."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "10d7ffcb67bde9df9284f81962919f9b82e35372", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/10d7ffcb67bde9df9284f81962919f9b82e35372", "committedDate": "2020-11-06T13:11:43Z", "message": "Added replicate flag to data stream and promote data stream api."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI1MTYyNzY0", "url": "https://github.com/elastic/elasticsearch/pull/64710#pullrequestreview-525162764", "createdAt": "2020-11-06T13:48:16Z", "commit": {"oid": "10d7ffcb67bde9df9284f81962919f9b82e35372"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxMzo0ODoxN1rOHuusww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxMzo0ODoxN1rOHuusww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODc2MTY2Nw==", "bodyText": "Should we embed this in the unfollow api? I'm not sure, because that api is centered around unfollowing a regular index and this operation is different and that would add ambiguity to the unfollow api. However the argument can also be made in reverse, in that this is a related operation.", "url": "https://github.com/elastic/elasticsearch/pull/64710#discussion_r518761667", "createdAt": "2020-11-06T13:48:17Z", "author": {"login": "martijnvg"}, "path": "x-pack/plugin/data-streams/src/main/java/org/elasticsearch/xpack/datastreams/action/PromoteDataStreamTransportAction.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.datastreams.action;\n+\n+import org.elasticsearch.ResourceNotFoundException;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.action.support.master.AcknowledgedTransportMasterNodeAction;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateUpdateTask;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.block.ClusterBlockLevel;\n+import org.elasticsearch.cluster.metadata.DataStream;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.metadata.Metadata;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.core.action.PromoteDataStreamAction;\n+\n+public class PromoteDataStreamTransportAction extends AcknowledgedTransportMasterNodeAction<PromoteDataStreamAction.Request> {\n+\n+    @Inject\n+    public PromoteDataStreamTransportAction(\n+        TransportService transportService,\n+        ClusterService clusterService,\n+        ThreadPool threadPool,\n+        ActionFilters actionFilters,\n+        IndexNameExpressionResolver indexNameExpressionResolver\n+    ) {\n+        super(\n+            PromoteDataStreamAction.NAME,\n+            transportService,\n+            clusterService,\n+            threadPool,\n+            actionFilters,\n+            PromoteDataStreamAction.Request::new,\n+            indexNameExpressionResolver,\n+            ThreadPool.Names.SAME\n+        );\n+    }\n+\n+    @Override\n+    protected void masterOperation(\n+        Task task,\n+        PromoteDataStreamAction.Request request,\n+        ClusterState state,\n+        ActionListener<AcknowledgedResponse> listener\n+    ) throws Exception {\n+        clusterService.submitStateUpdateTask(\n+            \"promote-data-stream [\" + request.getName() + \"]\",\n+            new ClusterStateUpdateTask(Priority.HIGH, request.masterNodeTimeout()) {\n+\n+                @Override\n+                public void onFailure(String source, Exception e) {\n+                    listener.onFailure(e);\n+                }\n+\n+                @Override\n+                public ClusterState execute(ClusterState currentState) {\n+                    return promoteDataStream(currentState, request);\n+                }\n+\n+                @Override\n+                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n+                    listener.onResponse(AcknowledgedResponse.TRUE);\n+                }\n+            }\n+        );\n+    }\n+\n+    static ClusterState promoteDataStream(ClusterState currentState, PromoteDataStreamAction.Request request) {\n+        DataStream dataStream = currentState.getMetadata().dataStreams().get(request.getName());\n+        if (dataStream == null) {\n+            throw new ResourceNotFoundException(\"data stream [\" + request.getName() + \"] does not exist\");\n+        }\n+\n+        DataStream promotedDataStream = dataStream.promoteDataStream();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10d7ffcb67bde9df9284f81962919f9b82e35372"}, "originalPosition": 86}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5514ae8b518154cdf3461c123a4f3bdebab2b9de", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/5514ae8b518154cdf3461c123a4f3bdebab2b9de", "committedDate": "2020-11-09T09:59:11Z", "message": "Merge remote-tracking branch 'es/master' into ccr_data_stream_support_part_2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "461773d173af213c29ac1ff0ff8aacf3f6885295", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/461773d173af213c29ac1ff0ff8aacf3f6885295", "committedDate": "2020-11-09T10:02:31Z", "message": "fix precommit"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ef71529aca1040848f71f0aefe5673749dcb40ec", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/ef71529aca1040848f71f0aefe5673749dcb40ec", "committedDate": "2020-11-09T10:02:59Z", "message": "nit"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "72379300c9cce1f7567f04521bd1bc8e75ef95e4", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/72379300c9cce1f7567f04521bd1bc8e75ef95e4", "committedDate": "2020-11-09T13:25:19Z", "message": "fixed tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e9b6627aad502aa554775e5095ea6b624f2d6e3e", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/e9b6627aad502aa554775e5095ea6b624f2d6e3e", "committedDate": "2020-11-09T16:38:17Z", "message": "fixed tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e031d72b214e2cda485b4dcd2c302734fcb60b86", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/e031d72b214e2cda485b4dcd2c302734fcb60b86", "committedDate": "2020-11-09T18:05:03Z", "message": "fixed npe"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b1c57d14292fc645aaefdc74ff9e17818d6f2d3f", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/b1c57d14292fc645aaefdc74ff9e17818d6f2d3f", "committedDate": "2020-11-10T08:38:46Z", "message": "Merge remote-tracking branch 'es/master' into ccr_data_stream_support_part_2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0c22ce149d4b8f83771c806ddd1d6a4fbfaa670d", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/0c22ce149d4b8f83771c806ddd1d6a4fbfaa670d", "committedDate": "2020-11-10T09:04:12Z", "message": "fixed test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "73877d6b182b53025057bb7f8da74f14d7343444", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/73877d6b182b53025057bb7f8da74f14d7343444", "committedDate": "2020-11-12T10:23:19Z", "message": "Merge remote-tracking branch 'es/master' into ccr_data_stream_support_part_2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5cbaf3d7c8d292a38acc084864c4e5242438b7de", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/5cbaf3d7c8d292a38acc084864c4e5242438b7de", "committedDate": "2020-11-16T10:00:41Z", "message": "Merge remote-tracking branch 'es/master' into ccr_data_stream_support_part_2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c9d410fb1b0ce936e8419450353b4321835dda4d", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/c9d410fb1b0ce936e8419450353b4321835dda4d", "committedDate": "2020-11-16T14:21:54Z", "message": "Merge remote-tracking branch 'es/master' into ccr_data_stream_support_part_2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5efa94385e06dbe070be1dd0b4b8a746093750f1", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/5efa94385e06dbe070be1dd0b4b8a746093750f1", "committedDate": "2020-11-17T13:47:58Z", "message": "added ccr bi-directional test with data streams"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "312a788e3d432e39024383d0ad40c79abec9838c", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/312a788e3d432e39024383d0ad40c79abec9838c", "committedDate": "2020-11-17T13:48:23Z", "message": "Merge remote-tracking branch 'es/master' into ccr_data_stream_support_part_2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "56074c3120a7a4e32f81fd52f942b1d9ea305991", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/56074c3120a7a4e32f81fd52f942b1d9ea305991", "committedDate": "2020-11-19T10:11:32Z", "message": "added docs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "57941acc3bf5ba8326cc9663a9d9139af8eeb90d", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/57941acc3bf5ba8326cc9663a9d9139af8eeb90d", "committedDate": "2020-11-20T12:14:57Z", "message": "Merge remote-tracking branch 'es/master' into ccr_data_stream_support_part_2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1b49909dde0a427072660a9af133115426adce11", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/1b49909dde0a427072660a9af133115426adce11", "committedDate": "2020-11-23T10:26:39Z", "message": "Added a test, which verifies that an alias in follow cluster can't be rolled over."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5700b679d56f4b4a2563eb74702ea491c6b89dca", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/5700b679d56f4b4a2563eb74702ea491c6b89dca", "committedDate": "2020-11-23T10:27:14Z", "message": "Merge remote-tracking branch 'es/master' into ccr_data_stream_support_part_2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5528da438e4a5075e055523307353a68094f0965", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/5528da438e4a5075e055523307353a68094f0965", "committedDate": "2020-11-23T10:33:23Z", "message": "fix checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a21454e2ef70c5437ae2a10d81570a7abfb72592", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/a21454e2ef70c5437ae2a10d81570a7abfb72592", "committedDate": "2020-11-23T10:47:43Z", "message": "added rest spec and renamed rest action"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM3OTk4OTY0", "url": "https://github.com/elastic/elasticsearch/pull/64710#pullrequestreview-537998964", "createdAt": "2020-11-24T21:56:46Z", "commit": {"oid": "a21454e2ef70c5437ae2a10d81570a7abfb72592"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMTo1Njo0NlrOH5XCdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMTo1ODo0NFrOH5XKeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTkwODM0Mg==", "bodyText": "Should we have a separate method that ensures this datastream can be rolled over instead?", "url": "https://github.com/elastic/elasticsearch/pull/64710#discussion_r529908342", "createdAt": "2020-11-24T21:56:46Z", "author": {"login": "dnhatn"}, "path": "server/src/main/java/org/elasticsearch/action/admin/indices/rollover/MetadataRolloverService.java", "diffHunk": "@@ -148,6 +149,7 @@ private RolloverResult rolloverDataStream(ClusterState currentState, IndexAbstra\n         final DataStream ds = dataStream.getDataStream();\n         final IndexMetadata originalWriteIndex = dataStream.getWriteIndex();\n         final String newWriteIndexName = DataStream.getDefaultBackingIndexName(ds.getName(), ds.getGeneration() + 1);\n+        ds.rollover(new Index(newWriteIndexName, \"uuid\")); // just for validation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a21454e2ef70c5437ae2a10d81570a7abfb72592"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTkxMDM5NA==", "bodyText": "Should we name this \"allowRollover\" or \"followed\"? I am okay with \"replicated\" if you prefer.", "url": "https://github.com/elastic/elasticsearch/pull/64710#discussion_r529910394", "createdAt": "2020-11-24T21:58:44Z", "author": {"login": "dnhatn"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/DataStream.java", "diffHunk": "@@ -44,26 +44,29 @@\n \n     public static final String BACKING_INDEX_PREFIX = \".ds-\";\n     public static final Version HIDDEN_VERSION = Version.V_7_11_0;\n+    public static final Version REPLICATED_VERSION = Version.V_8_0_0;\n \n     private final String name;\n     private final TimestampField timeStampField;\n     private final List<Index> indices;\n     private final long generation;\n     private final Map<String, Object> metadata;\n     private final boolean hidden;\n+    private final boolean replicated;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a21454e2ef70c5437ae2a10d81570a7abfb72592"}, "originalPosition": 12}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ef26773e6713eadb03cc781278b4e0ef8b31f763", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/ef26773e6713eadb03cc781278b4e0ef8b31f763", "committedDate": "2020-12-02T09:56:15Z", "message": "Merge remote-tracking branch 'es/master' into ccr_data_stream_support_part_2"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ1ODExNzk1", "url": "https://github.com/elastic/elasticsearch/pull/64710#pullrequestreview-545811795", "createdAt": "2020-12-07T03:42:13Z", "commit": {"oid": "ef26773e6713eadb03cc781278b4e0ef8b31f763"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QwMzo0MjoxNFrOIAUt0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QwMzo0MjoxNFrOIAUt0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzIxMDMyMg==", "bodyText": "@martijnvg Sorry, I think I didn't explain well my concern about supporting bi-directional replication. What I meant was JasonZ's blog. In his setup, we can send the same indexing request (uses the same write alias) to either cluster. In this test, we use different data streams for indexing requests. That means users can't simply reroute all indexing to a single cluster when another is not available.", "url": "https://github.com/elastic/elasticsearch/pull/64710#discussion_r537210322", "createdAt": "2020-12-07T03:42:14Z", "author": {"login": "dnhatn"}, "path": "x-pack/plugin/ccr/qa/multi-cluster/src/test/java/org/elasticsearch/xpack/ccr/AutoFollowIT.java", "diffHunk": "@@ -347,13 +321,369 @@ public void testDataStreams_autoFollowAfterDataStreamCreated() throws Exception\n         }\n     }\n \n+    public void testRolloverDataStreamInFollowClusterForbidden() throws Exception {\n+        if (\"follow\".equals(targetCluster) == false) {\n+            return;\n+        }\n+\n+        final int numDocs = 64;\n+        final String dataStreamName = \"logs-tomcat-prod\";\n+\n+        int initialNumberOfSuccessfulFollowedIndices = getNumberOfSuccessfulFollowedIndices();\n+\n+        // Create auto follow pattern\n+        createAutoFollowPattern(client(), \"test_pattern\", \"logs-*\", \"leader_cluster\");\n+\n+        // Create data stream and ensure that is is auto followed\n+        {\n+            try (RestClient leaderClient = buildLeaderClient()) {\n+                for (int i = 0; i < numDocs; i++) {\n+                    Request indexRequest = new Request(\"POST\", \"/\" + dataStreamName + \"/_doc\");\n+                    indexRequest.addParameter(\"refresh\", \"true\");\n+                    indexRequest.setJsonEntity(\"{\\\"@timestamp\\\": \\\"\" + DATE_FORMAT.format(new Date()) + \"\\\",\\\"message\\\":\\\"abc\\\"}\");\n+                    assertOK(leaderClient.performRequest(indexRequest));\n+                }\n+                verifyDataStream(leaderClient, dataStreamName, backingIndexName(dataStreamName, 1));\n+                verifyDocuments(leaderClient, dataStreamName, numDocs);\n+            }\n+            assertBusy(() -> {\n+                assertThat(getNumberOfSuccessfulFollowedIndices(), equalTo(initialNumberOfSuccessfulFollowedIndices + 1));\n+                verifyDataStream(client(), dataStreamName, backingIndexName(dataStreamName, 1));\n+                ensureYellow(dataStreamName);\n+                verifyDocuments(client(), dataStreamName, numDocs);\n+            });\n+        }\n+\n+        // Rollover in leader cluster and ensure second backing index is replicated:\n+        {\n+            try (RestClient leaderClient = buildLeaderClient()) {\n+                Request rolloverRequest = new Request(\"POST\", \"/\" +  dataStreamName + \"/_rollover\");\n+                assertOK(leaderClient.performRequest(rolloverRequest));\n+                verifyDataStream(leaderClient, dataStreamName, backingIndexName(dataStreamName, 1), backingIndexName(dataStreamName, 2));\n+\n+                Request indexRequest = new Request(\"POST\", \"/\" + dataStreamName + \"/_doc\");\n+                indexRequest.addParameter(\"refresh\", \"true\");\n+                indexRequest.setJsonEntity(\"{\\\"@timestamp\\\": \\\"\" + DATE_FORMAT.format(new Date()) + \"\\\",\\\"message\\\":\\\"abc\\\"}\");\n+                assertOK(leaderClient.performRequest(indexRequest));\n+                verifyDocuments(leaderClient, dataStreamName, numDocs + 1);\n+            }\n+            assertBusy(() -> {\n+                assertThat(getNumberOfSuccessfulFollowedIndices(), equalTo(initialNumberOfSuccessfulFollowedIndices + 2));\n+                verifyDataStream(client(), dataStreamName, backingIndexName(dataStreamName, 1), backingIndexName(dataStreamName, 2));\n+                ensureYellow(dataStreamName);\n+                verifyDocuments(client(), dataStreamName, numDocs + 1);\n+            });\n+        }\n+\n+        // Try rollover in follow cluster\n+        {\n+            Request rolloverRequest1 = new Request(\"POST\", \"/\" +  dataStreamName + \"/_rollover\");\n+            Exception e = expectThrows(ResponseException.class, () -> client().performRequest(rolloverRequest1));\n+            assertThat(e.getMessage(), containsString(\"data stream [\" + dataStreamName + \"] cannot be rolled over, \" +\n+                \"because it is a replicated data stream\"));\n+            verifyDataStream(client(), dataStreamName, backingIndexName(dataStreamName, 1), backingIndexName(dataStreamName, 2));\n+\n+            // Unfollow .ds-logs-tomcat-prod-000001\n+            pauseFollow(backingIndexName(dataStreamName, 1));\n+            closeIndex(backingIndexName(dataStreamName, 1));\n+            unfollow(backingIndexName(dataStreamName, 1));\n+\n+            // Try again\n+            Request rolloverRequest2 = new Request(\"POST\", \"/\" +  dataStreamName + \"/_rollover\");\n+            e = expectThrows(ResponseException.class, () -> client().performRequest(rolloverRequest2));\n+            assertThat(e.getMessage(), containsString(\"data stream [\" + dataStreamName + \"] cannot be rolled over, \" +\n+                \"because it is a replicated data stream\"));\n+            verifyDataStream(client(), dataStreamName, backingIndexName(dataStreamName, 1), backingIndexName(dataStreamName, 2));\n+\n+            // Promote local data stream\n+            Request promoteRequest = new Request(\"POST\", \"/_data_stream/_promote/\" + dataStreamName);\n+            assertOK(client().performRequest(promoteRequest));\n+\n+            // Try again and now the rollover should be successful because local data stream is now :\n+            Request rolloverRequest3 = new Request(\"POST\", \"/\" +  dataStreamName + \"/_rollover\");\n+            assertOK(client().performRequest(rolloverRequest3));\n+            verifyDataStream(client(), dataStreamName, backingIndexName(dataStreamName, 1), backingIndexName(dataStreamName, 2),\n+                backingIndexName(dataStreamName, 3));\n+\n+            // TODO: verify that following a backing index for logs-tomcat-prod data stream in remote cluster fails,\n+            // because local data stream isn't a replicated data stream anymore.\n+\n+            // Unfollow .ds-logs-tomcat-prod-000002,\n+            // which is now possible because this index can now be closed as it is no longer the write index.\n+            pauseFollow(backingIndexName(dataStreamName, 2));\n+            closeIndex(backingIndexName(dataStreamName, 2));\n+            unfollow(backingIndexName(dataStreamName, 2));\n+        }\n+        // Cleanup:\n+        {\n+            deleteAutoFollowPattern(\"test_pattern\");\n+            deleteDataStream(dataStreamName);\n+        }\n+    }\n+\n+    public void testRolloverAliasInFollowClusterForbidden() throws Exception {\n+        if (\"follow\".equals(targetCluster) == false) {\n+            return;\n+        }\n+\n+        final int numDocs = 64;\n+        final String aliasName = \"log-tomcat-prod\";\n+\n+        int initialNumberOfSuccessfulFollowedIndices = getNumberOfSuccessfulFollowedIndices();\n+\n+        // Create auto follow pattern\n+        createAutoFollowPattern(client(), \"test_pattern\", \"log-*\", \"leader_cluster\");\n+\n+        // Create leader index and write alias:\n+        {\n+            try (RestClient leaderClient = buildLeaderClient()) {\n+                Request createFirstIndexRequest = new Request(\"PUT\", \"/\" + aliasName + \"-000001\");\n+                createFirstIndexRequest.setJsonEntity(\"{\\\"aliases\\\": {\\\"\" + aliasName + \"\\\":{\\\"is_write_index\\\":true}}}\");\n+                leaderClient.performRequest(createFirstIndexRequest);\n+\n+                for (int i = 0; i < numDocs; i++) {\n+                    Request indexRequest = new Request(\"POST\", \"/\" + aliasName + \"/_doc\");\n+                    indexRequest.addParameter(\"refresh\", \"true\");\n+                    indexRequest.setJsonEntity(\"{\\\"@timestamp\\\": \\\"\" + DATE_FORMAT.format(new Date()) + \"\\\",\\\"message\\\":\\\"abc\\\"}\");\n+                    assertOK(leaderClient.performRequest(indexRequest));\n+                }\n+                verifyAlias(leaderClient, aliasName, true, aliasName + \"-000001\");\n+                verifyDocuments(leaderClient, aliasName, numDocs);\n+            }\n+            assertBusy(() -> {\n+                assertThat(getNumberOfSuccessfulFollowedIndices(), equalTo(initialNumberOfSuccessfulFollowedIndices + 1));\n+                verifyAlias(client(), aliasName, false, aliasName + \"-000001\");\n+                ensureYellow(aliasName);\n+                verifyDocuments(client(), aliasName, numDocs);\n+            });\n+        }\n+\n+        // Rollover in leader cluster and ensure second backing index is replicated:\n+        {\n+            try (RestClient leaderClient = buildLeaderClient()) {\n+                Request rolloverRequest = new Request(\"POST\", \"/\" +  aliasName + \"/_rollover\");\n+                assertOK(leaderClient.performRequest(rolloverRequest));\n+                verifyAlias(leaderClient, aliasName, true, aliasName + \"-000002\", aliasName + \"-000001\");\n+\n+                Request indexRequest = new Request(\"POST\", \"/\" + aliasName + \"/_doc\");\n+                indexRequest.addParameter(\"refresh\", \"true\");\n+                indexRequest.setJsonEntity(\"{\\\"@timestamp\\\": \\\"\" + DATE_FORMAT.format(new Date()) + \"\\\",\\\"message\\\":\\\"abc\\\"}\");\n+                assertOK(leaderClient.performRequest(indexRequest));\n+                verifyDocuments(leaderClient, aliasName, numDocs + 1);\n+            }\n+            assertBusy(() -> {\n+                assertThat(getNumberOfSuccessfulFollowedIndices(), equalTo(initialNumberOfSuccessfulFollowedIndices + 2));\n+                verifyAlias(client(), aliasName, false, aliasName + \"-000002\", aliasName + \"-000001\");\n+                ensureYellow(aliasName);\n+                verifyDocuments(client(), aliasName, numDocs + 1);\n+            });\n+        }\n+\n+        // Try rollover in follow cluster, this should fail, because is_write_index property of an alias isn't\n+        // replicated to follow cluster.\n+        {\n+            Request rolloverRequest1 = new Request(\"POST\", \"/\" +  aliasName + \"/_rollover\");\n+            Exception e = expectThrows(ResponseException.class, () -> client().performRequest(rolloverRequest1));\n+            assertThat(e.getMessage(), containsString(\"rollover target [\" + aliasName + \"] does not point to a write index\"));\n+            verifyAlias(client(), aliasName, false, aliasName + \"-000002\", aliasName + \"-000001\");\n+        }\n+        // Cleanup:\n+        {\n+            deleteAutoFollowPattern(\"test_pattern\");\n+        }\n+    }\n+\n+    private static void verifyAlias(RestClient client,\n+                                    String aliasName,\n+                                    boolean checkWriteIndex,\n+                                    String... otherIndices) throws IOException {\n+        Request getAliasRequest = new Request(\"GET\", \"/_alias/\" + aliasName);\n+        Map<?, ?> responseBody = toMap(client.performRequest(getAliasRequest));\n+        if (checkWriteIndex) {\n+            assertThat(ObjectPath.eval(otherIndices[0] + \".aliases.\" + aliasName + \".is_write_index\", responseBody), is(true));\n+        }\n+        for (String otherIndex : otherIndices) {\n+            assertThat(ObjectPath.eval(otherIndex + \".aliases.\" + aliasName, responseBody), notNullValue());\n+        }\n+    }\n+\n+    public void testDataStreamsBiDirectionalReplication() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef26773e6713eadb03cc781278b4e0ef8b31f763"}, "originalPosition": 350}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5051eafaa1d01eb80f8d329788124a83ed5709d5", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/5051eafaa1d01eb80f8d329788124a83ed5709d5", "committedDate": "2020-12-07T09:03:35Z", "message": "Merge remote-tracking branch 'es/master' into ccr_data_stream_support_part_2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "676c7a8e04a6af4bdfa3a30fc4bd2214fb3f0dec", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/676c7a8e04a6af4bdfa3a30fc4bd2214fb3f0dec", "committedDate": "2020-12-07T09:56:24Z", "message": "added TODOs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8e21fc79bd213a5a50f0c9d92060f412c6b32069", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/8e21fc79bd213a5a50f0c9d92060f412c6b32069", "committedDate": "2020-12-07T10:08:07Z", "message": "varify"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9c7a0715e3cf348000265bc2d16215d01c3d3a27", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/9c7a0715e3cf348000265bc2d16215d01c3d3a27", "committedDate": "2020-12-07T14:13:33Z", "message": "mark promote ds api as non operator api"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2MjU5NDUy", "url": "https://github.com/elastic/elasticsearch/pull/64710#pullrequestreview-546259452", "createdAt": "2020-12-07T15:28:34Z", "commit": {"oid": "9c7a0715e3cf348000265bc2d16215d01c3d3a27"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxNToyODozNFrOIAsStQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxNTozMDowMFrOIAsXhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzU5NjU5Nw==", "bodyText": "nit: s/replicate/replicated", "url": "https://github.com/elastic/elasticsearch/pull/64710#discussion_r537596597", "createdAt": "2020-12-07T15:28:34Z", "author": {"login": "dnhatn"}, "path": "x-pack/plugin/src/test/resources/rest-api-spec/api/indices.promote_data_stream.json", "diffHunk": "@@ -0,0 +1,27 @@\n+{\n+  \"indices.promote_data_stream\":{\n+    \"documentation\":{\n+      \"url\":\"https://www.elastic.co/guide/en/elasticsearch/reference/master/data-streams.html\",\n+      \"description\":\"Promotes a data stream from a replicate data stream managed by CCR to a regular data stream\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c7a0715e3cf348000265bc2d16215d01c3d3a27"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzU5NzgzMQ==", "bodyText": "We're planning to add alias support to data streams.\n\nThanks for explaning + adding the TODO.", "url": "https://github.com/elastic/elasticsearch/pull/64710#discussion_r537597831", "createdAt": "2020-12-07T15:30:00Z", "author": {"login": "dnhatn"}, "path": "x-pack/plugin/ccr/qa/multi-cluster/src/test/java/org/elasticsearch/xpack/ccr/AutoFollowIT.java", "diffHunk": "@@ -347,13 +321,369 @@ public void testDataStreams_autoFollowAfterDataStreamCreated() throws Exception\n         }\n     }\n \n+    public void testRolloverDataStreamInFollowClusterForbidden() throws Exception {\n+        if (\"follow\".equals(targetCluster) == false) {\n+            return;\n+        }\n+\n+        final int numDocs = 64;\n+        final String dataStreamName = \"logs-tomcat-prod\";\n+\n+        int initialNumberOfSuccessfulFollowedIndices = getNumberOfSuccessfulFollowedIndices();\n+\n+        // Create auto follow pattern\n+        createAutoFollowPattern(client(), \"test_pattern\", \"logs-*\", \"leader_cluster\");\n+\n+        // Create data stream and ensure that is is auto followed\n+        {\n+            try (RestClient leaderClient = buildLeaderClient()) {\n+                for (int i = 0; i < numDocs; i++) {\n+                    Request indexRequest = new Request(\"POST\", \"/\" + dataStreamName + \"/_doc\");\n+                    indexRequest.addParameter(\"refresh\", \"true\");\n+                    indexRequest.setJsonEntity(\"{\\\"@timestamp\\\": \\\"\" + DATE_FORMAT.format(new Date()) + \"\\\",\\\"message\\\":\\\"abc\\\"}\");\n+                    assertOK(leaderClient.performRequest(indexRequest));\n+                }\n+                verifyDataStream(leaderClient, dataStreamName, backingIndexName(dataStreamName, 1));\n+                verifyDocuments(leaderClient, dataStreamName, numDocs);\n+            }\n+            assertBusy(() -> {\n+                assertThat(getNumberOfSuccessfulFollowedIndices(), equalTo(initialNumberOfSuccessfulFollowedIndices + 1));\n+                verifyDataStream(client(), dataStreamName, backingIndexName(dataStreamName, 1));\n+                ensureYellow(dataStreamName);\n+                verifyDocuments(client(), dataStreamName, numDocs);\n+            });\n+        }\n+\n+        // Rollover in leader cluster and ensure second backing index is replicated:\n+        {\n+            try (RestClient leaderClient = buildLeaderClient()) {\n+                Request rolloverRequest = new Request(\"POST\", \"/\" +  dataStreamName + \"/_rollover\");\n+                assertOK(leaderClient.performRequest(rolloverRequest));\n+                verifyDataStream(leaderClient, dataStreamName, backingIndexName(dataStreamName, 1), backingIndexName(dataStreamName, 2));\n+\n+                Request indexRequest = new Request(\"POST\", \"/\" + dataStreamName + \"/_doc\");\n+                indexRequest.addParameter(\"refresh\", \"true\");\n+                indexRequest.setJsonEntity(\"{\\\"@timestamp\\\": \\\"\" + DATE_FORMAT.format(new Date()) + \"\\\",\\\"message\\\":\\\"abc\\\"}\");\n+                assertOK(leaderClient.performRequest(indexRequest));\n+                verifyDocuments(leaderClient, dataStreamName, numDocs + 1);\n+            }\n+            assertBusy(() -> {\n+                assertThat(getNumberOfSuccessfulFollowedIndices(), equalTo(initialNumberOfSuccessfulFollowedIndices + 2));\n+                verifyDataStream(client(), dataStreamName, backingIndexName(dataStreamName, 1), backingIndexName(dataStreamName, 2));\n+                ensureYellow(dataStreamName);\n+                verifyDocuments(client(), dataStreamName, numDocs + 1);\n+            });\n+        }\n+\n+        // Try rollover in follow cluster\n+        {\n+            Request rolloverRequest1 = new Request(\"POST\", \"/\" +  dataStreamName + \"/_rollover\");\n+            Exception e = expectThrows(ResponseException.class, () -> client().performRequest(rolloverRequest1));\n+            assertThat(e.getMessage(), containsString(\"data stream [\" + dataStreamName + \"] cannot be rolled over, \" +\n+                \"because it is a replicated data stream\"));\n+            verifyDataStream(client(), dataStreamName, backingIndexName(dataStreamName, 1), backingIndexName(dataStreamName, 2));\n+\n+            // Unfollow .ds-logs-tomcat-prod-000001\n+            pauseFollow(backingIndexName(dataStreamName, 1));\n+            closeIndex(backingIndexName(dataStreamName, 1));\n+            unfollow(backingIndexName(dataStreamName, 1));\n+\n+            // Try again\n+            Request rolloverRequest2 = new Request(\"POST\", \"/\" +  dataStreamName + \"/_rollover\");\n+            e = expectThrows(ResponseException.class, () -> client().performRequest(rolloverRequest2));\n+            assertThat(e.getMessage(), containsString(\"data stream [\" + dataStreamName + \"] cannot be rolled over, \" +\n+                \"because it is a replicated data stream\"));\n+            verifyDataStream(client(), dataStreamName, backingIndexName(dataStreamName, 1), backingIndexName(dataStreamName, 2));\n+\n+            // Promote local data stream\n+            Request promoteRequest = new Request(\"POST\", \"/_data_stream/_promote/\" + dataStreamName);\n+            assertOK(client().performRequest(promoteRequest));\n+\n+            // Try again and now the rollover should be successful because local data stream is now :\n+            Request rolloverRequest3 = new Request(\"POST\", \"/\" +  dataStreamName + \"/_rollover\");\n+            assertOK(client().performRequest(rolloverRequest3));\n+            verifyDataStream(client(), dataStreamName, backingIndexName(dataStreamName, 1), backingIndexName(dataStreamName, 2),\n+                backingIndexName(dataStreamName, 3));\n+\n+            // TODO: verify that following a backing index for logs-tomcat-prod data stream in remote cluster fails,\n+            // because local data stream isn't a replicated data stream anymore.\n+\n+            // Unfollow .ds-logs-tomcat-prod-000002,\n+            // which is now possible because this index can now be closed as it is no longer the write index.\n+            pauseFollow(backingIndexName(dataStreamName, 2));\n+            closeIndex(backingIndexName(dataStreamName, 2));\n+            unfollow(backingIndexName(dataStreamName, 2));\n+        }\n+        // Cleanup:\n+        {\n+            deleteAutoFollowPattern(\"test_pattern\");\n+            deleteDataStream(dataStreamName);\n+        }\n+    }\n+\n+    public void testRolloverAliasInFollowClusterForbidden() throws Exception {\n+        if (\"follow\".equals(targetCluster) == false) {\n+            return;\n+        }\n+\n+        final int numDocs = 64;\n+        final String aliasName = \"log-tomcat-prod\";\n+\n+        int initialNumberOfSuccessfulFollowedIndices = getNumberOfSuccessfulFollowedIndices();\n+\n+        // Create auto follow pattern\n+        createAutoFollowPattern(client(), \"test_pattern\", \"log-*\", \"leader_cluster\");\n+\n+        // Create leader index and write alias:\n+        {\n+            try (RestClient leaderClient = buildLeaderClient()) {\n+                Request createFirstIndexRequest = new Request(\"PUT\", \"/\" + aliasName + \"-000001\");\n+                createFirstIndexRequest.setJsonEntity(\"{\\\"aliases\\\": {\\\"\" + aliasName + \"\\\":{\\\"is_write_index\\\":true}}}\");\n+                leaderClient.performRequest(createFirstIndexRequest);\n+\n+                for (int i = 0; i < numDocs; i++) {\n+                    Request indexRequest = new Request(\"POST\", \"/\" + aliasName + \"/_doc\");\n+                    indexRequest.addParameter(\"refresh\", \"true\");\n+                    indexRequest.setJsonEntity(\"{\\\"@timestamp\\\": \\\"\" + DATE_FORMAT.format(new Date()) + \"\\\",\\\"message\\\":\\\"abc\\\"}\");\n+                    assertOK(leaderClient.performRequest(indexRequest));\n+                }\n+                verifyAlias(leaderClient, aliasName, true, aliasName + \"-000001\");\n+                verifyDocuments(leaderClient, aliasName, numDocs);\n+            }\n+            assertBusy(() -> {\n+                assertThat(getNumberOfSuccessfulFollowedIndices(), equalTo(initialNumberOfSuccessfulFollowedIndices + 1));\n+                verifyAlias(client(), aliasName, false, aliasName + \"-000001\");\n+                ensureYellow(aliasName);\n+                verifyDocuments(client(), aliasName, numDocs);\n+            });\n+        }\n+\n+        // Rollover in leader cluster and ensure second backing index is replicated:\n+        {\n+            try (RestClient leaderClient = buildLeaderClient()) {\n+                Request rolloverRequest = new Request(\"POST\", \"/\" +  aliasName + \"/_rollover\");\n+                assertOK(leaderClient.performRequest(rolloverRequest));\n+                verifyAlias(leaderClient, aliasName, true, aliasName + \"-000002\", aliasName + \"-000001\");\n+\n+                Request indexRequest = new Request(\"POST\", \"/\" + aliasName + \"/_doc\");\n+                indexRequest.addParameter(\"refresh\", \"true\");\n+                indexRequest.setJsonEntity(\"{\\\"@timestamp\\\": \\\"\" + DATE_FORMAT.format(new Date()) + \"\\\",\\\"message\\\":\\\"abc\\\"}\");\n+                assertOK(leaderClient.performRequest(indexRequest));\n+                verifyDocuments(leaderClient, aliasName, numDocs + 1);\n+            }\n+            assertBusy(() -> {\n+                assertThat(getNumberOfSuccessfulFollowedIndices(), equalTo(initialNumberOfSuccessfulFollowedIndices + 2));\n+                verifyAlias(client(), aliasName, false, aliasName + \"-000002\", aliasName + \"-000001\");\n+                ensureYellow(aliasName);\n+                verifyDocuments(client(), aliasName, numDocs + 1);\n+            });\n+        }\n+\n+        // Try rollover in follow cluster, this should fail, because is_write_index property of an alias isn't\n+        // replicated to follow cluster.\n+        {\n+            Request rolloverRequest1 = new Request(\"POST\", \"/\" +  aliasName + \"/_rollover\");\n+            Exception e = expectThrows(ResponseException.class, () -> client().performRequest(rolloverRequest1));\n+            assertThat(e.getMessage(), containsString(\"rollover target [\" + aliasName + \"] does not point to a write index\"));\n+            verifyAlias(client(), aliasName, false, aliasName + \"-000002\", aliasName + \"-000001\");\n+        }\n+        // Cleanup:\n+        {\n+            deleteAutoFollowPattern(\"test_pattern\");\n+        }\n+    }\n+\n+    private static void verifyAlias(RestClient client,\n+                                    String aliasName,\n+                                    boolean checkWriteIndex,\n+                                    String... otherIndices) throws IOException {\n+        Request getAliasRequest = new Request(\"GET\", \"/_alias/\" + aliasName);\n+        Map<?, ?> responseBody = toMap(client.performRequest(getAliasRequest));\n+        if (checkWriteIndex) {\n+            assertThat(ObjectPath.eval(otherIndices[0] + \".aliases.\" + aliasName + \".is_write_index\", responseBody), is(true));\n+        }\n+        for (String otherIndex : otherIndices) {\n+            assertThat(ObjectPath.eval(otherIndex + \".aliases.\" + aliasName, responseBody), notNullValue());\n+        }\n+    }\n+\n+    public void testDataStreamsBiDirectionalReplication() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzIxMDMyMg=="}, "originalCommit": {"oid": "ef26773e6713eadb03cc781278b4e0ef8b31f763"}, "originalPosition": 350}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2MjYxMzI2", "url": "https://github.com/elastic/elasticsearch/pull/64710#pullrequestreview-546261326", "createdAt": "2020-12-07T15:30:26Z", "commit": {"oid": "9c7a0715e3cf348000265bc2d16215d01c3d3a27"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "23c59b8b57ce9d970c029a9abfdfdfa85b0e25a1", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/23c59b8b57ce9d970c029a9abfdfdfa85b0e25a1", "committedDate": "2020-12-08T06:36:03Z", "message": "Merge remote-tracking branch 'es/master' into ccr_data_stream_support_part_2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a80f77706c4d89c57af2cd2c7a59af148de8434c", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/a80f77706c4d89c57af2cd2c7a59af148de8434c", "committedDate": "2020-12-08T06:38:19Z", "message": "fixed typo"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1225, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}