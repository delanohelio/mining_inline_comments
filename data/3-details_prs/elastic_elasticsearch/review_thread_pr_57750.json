{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI4NTg1MzE1", "number": 57750, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNzozOTowNVrOEDVNfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNzo1MDowNVrOEDVahg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxOTI4NzAwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/Metadata.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNzozOTowNVrOGgSVmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNzozOTowNVrOGgSVmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjUwODA1OA==", "bodyText": "maybe only catch IllegalArgumentException here? Since these are the cases with specific failure logic, otherwise we would mask any other potential problem.", "url": "https://github.com/elastic/elasticsearch/pull/57750#discussion_r436508058", "createdAt": "2020-06-08T07:39:05Z", "author": {"login": "martijnvg"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/Metadata.java", "diffHunk": "@@ -1452,27 +1452,41 @@ public Metadata build() {\n             return indicesLookup;\n         }\n \n-        private void validateDataStreams(SortedMap<String, IndexAbstraction> indicesLookup) {\n-            DataStreamMetadata dsMetadata = (DataStreamMetadata) customs.get(DataStreamMetadata.TYPE);\n+        /**\n+         * Validates there isn't any index with a name that would clash with the future backing indices of the existing data streams.\n+         *\n+         * For eg. if data stream `foo` has backing indices [`foo-000001`, `foo-000002`] and the indices lookup contains indices\n+         * `foo-000001`, `foo-000002` and `foo-000006` this will throw an IllegalStateException (as attempting to rollover the `foo` data\n+         * stream from generation 5 to 6 will not be possible)\n+         *\n+         * @param indicesLookup the indices in the system (this includes the data streams backing indices)\n+         * @param dsMetadata    the data streams in the system\n+         */\n+        static void validateDataStreams(SortedMap<String, IndexAbstraction> indicesLookup, @Nullable DataStreamMetadata dsMetadata) {\n             if (dsMetadata != null) {\n                 for (DataStream ds : dsMetadata.dataStreams().values()) {\n-                    SortedMap<String, IndexAbstraction> potentialConflicts =\n-                        indicesLookup.subMap(ds.getName() + \"-\", ds.getName() + \".\"); // '.' is the char after '-'\n-                    if (potentialConflicts.size() != 0) {\n-                        List<String> indexNames = ds.getIndices().stream().map(Index::getName).collect(Collectors.toList());\n-                        List<String> conflicts = new ArrayList<>();\n-                        for (Map.Entry<String, IndexAbstraction> entry : potentialConflicts.entrySet()) {\n-                            if (entry.getValue().getType() != IndexAbstraction.Type.CONCRETE_INDEX ||\n-                                indexNames.contains(entry.getKey()) == false) {\n-                                conflicts.add(entry.getKey());\n-                            }\n-                        }\n-\n-                        if (conflicts.size() > 0) {\n-                            throw new IllegalStateException(\"data stream [\" + ds.getName() +\n-                                \"] could create backing indices that conflict with \" + conflicts.size() + \" existing index(s) or alias(s)\" +\n-                                \" including '\" + conflicts.get(0) + \"'\");\n-                        }\n+                    Map<String, IndexAbstraction> conflicts =\n+                        indicesLookup.subMap(ds.getName() + \"-\", ds.getName() + \".\") // '.' is the char after '-'\n+                            .entrySet().stream()\n+                            .filter(entry -> {\n+                                if (entry.getValue().getType() != IndexAbstraction.Type.CONCRETE_INDEX) {\n+                                    return true;\n+                                } else {\n+                                    int indexNameCounter;\n+                                    try {\n+                                        indexNameCounter = IndexMetadata.parseIndexNameCounter(entry.getKey());\n+                                    } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "708ed5d79f30ed93395668bff47963a7bc32e468"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxOTI4OTIxOnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/elasticsearch/cluster/metadata/IndexMetadataTests.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNzozOTo1MVrOGgSW-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNzozOTo1MVrOGgSW-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjUwODQwOA==", "bodyText": "maybe also add an assertThat that tests with shrink- prefix?", "url": "https://github.com/elastic/elasticsearch/pull/57750#discussion_r436508408", "createdAt": "2020-06-08T07:39:51Z", "author": {"login": "martijnvg"}, "path": "server/src/test/java/org/elasticsearch/cluster/metadata/IndexMetadataTests.java", "diffHunk": "@@ -331,4 +332,30 @@ public void testNumberOfReplicasIsNonNegative() {\n                 \"Failed to parse value [\" + numberOfReplicas + \"] for setting [index.number_of_replicas] must be >= 0\"));\n     }\n \n+    public void testParseIndexNameReturnsCounter() {\n+        assertThat(parseIndexNameCounter(\"logs-000003\"), is(3));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "708ed5d79f30ed93395668bff47963a7bc32e468"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxOTMyMDM4OnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/elasticsearch/cluster/metadata/MetadataTests.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNzo1MDowNVrOGgSqEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwOToxOToxM1rOGgVpRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjUxMzI5OA==", "bodyText": "Perhaps just add a comment on why no failure is expected and let the exception bubble up?", "url": "https://github.com/elastic/elasticsearch/pull/57750#discussion_r436513298", "createdAt": "2020-06-08T07:50:05Z", "author": {"login": "martijnvg"}, "path": "server/src/test/java/org/elasticsearch/cluster/metadata/MetadataTests.java", "diffHunk": "@@ -1078,6 +1080,148 @@ public void testSerialization() throws IOException {\n         assertTrue(Metadata.isGlobalStateEquals(orig, fromStreamMeta));\n     }\n \n+    public void testValidateDataStreamsNoConflicts() {\n+        Metadata metadata = createIndices(5, 10, \"foo-datastream\").metadata;\n+        try {\n+            validateDataStreams(metadata.getIndicesLookup(), (DataStreamMetadata) metadata.customs().get(DataStreamMetadata.TYPE));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "708ed5d79f30ed93395668bff47963a7bc32e468"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU0NjM5MQ==", "bodyText": "Is the aim of this change a better runtime experience in case the test fails? Or test readability?\nI think the fail message is providing the runtime context, and it will print it in case of failure (which should make debugging this straightforward).", "url": "https://github.com/elastic/elasticsearch/pull/57750#discussion_r436546391", "createdAt": "2020-06-08T08:52:40Z", "author": {"login": "andreidan"}, "path": "server/src/test/java/org/elasticsearch/cluster/metadata/MetadataTests.java", "diffHunk": "@@ -1078,6 +1080,148 @@ public void testSerialization() throws IOException {\n         assertTrue(Metadata.isGlobalStateEquals(orig, fromStreamMeta));\n     }\n \n+    public void testValidateDataStreamsNoConflicts() {\n+        Metadata metadata = createIndices(5, 10, \"foo-datastream\").metadata;\n+        try {\n+            validateDataStreams(metadata.getIndicesLookup(), (DataStreamMetadata) metadata.customs().get(DataStreamMetadata.TYPE));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjUxMzI5OA=="}, "originalCommit": {"oid": "708ed5d79f30ed93395668bff47963a7bc32e468"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU0OTU1OQ==", "bodyText": "Currently when the test fails with any error then there is no stacktrace to the original failure, which I think makes pinpointing the culprit easier?\nThat being said, this is just preference, so feel free to ignore :)", "url": "https://github.com/elastic/elasticsearch/pull/57750#discussion_r436549559", "createdAt": "2020-06-08T08:58:04Z", "author": {"login": "martijnvg"}, "path": "server/src/test/java/org/elasticsearch/cluster/metadata/MetadataTests.java", "diffHunk": "@@ -1078,6 +1080,148 @@ public void testSerialization() throws IOException {\n         assertTrue(Metadata.isGlobalStateEquals(orig, fromStreamMeta));\n     }\n \n+    public void testValidateDataStreamsNoConflicts() {\n+        Metadata metadata = createIndices(5, 10, \"foo-datastream\").metadata;\n+        try {\n+            validateDataStreams(metadata.getIndicesLookup(), (DataStreamMetadata) metadata.customs().get(DataStreamMetadata.TYPE));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjUxMzI5OA=="}, "originalCommit": {"oid": "708ed5d79f30ed93395668bff47963a7bc32e468"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU2MjI0Ng==", "bodyText": "TIL didn't realise it hides the cause of the failure. Made the change, thanks!", "url": "https://github.com/elastic/elasticsearch/pull/57750#discussion_r436562246", "createdAt": "2020-06-08T09:19:13Z", "author": {"login": "andreidan"}, "path": "server/src/test/java/org/elasticsearch/cluster/metadata/MetadataTests.java", "diffHunk": "@@ -1078,6 +1080,148 @@ public void testSerialization() throws IOException {\n         assertTrue(Metadata.isGlobalStateEquals(orig, fromStreamMeta));\n     }\n \n+    public void testValidateDataStreamsNoConflicts() {\n+        Metadata metadata = createIndices(5, 10, \"foo-datastream\").metadata;\n+        try {\n+            validateDataStreams(metadata.getIndicesLookup(), (DataStreamMetadata) metadata.customs().get(DataStreamMetadata.TYPE));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjUxMzI5OA=="}, "originalCommit": {"oid": "708ed5d79f30ed93395668bff47963a7bc32e468"}, "originalPosition": 20}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3585, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}