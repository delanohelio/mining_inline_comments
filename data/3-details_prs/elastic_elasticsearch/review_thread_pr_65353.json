{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI1NjU3NzU4", "number": 65353, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxNjoxMzowMlrOE8SjOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMzowNjowMFrOE8bqew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxNjUzOTQ0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxNjoxMzowMlrOH4U1XA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxNjozNjo0NFrOH4V47g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODgyMzY0NA==", "bodyText": "Why do you need a second zoneid variable? You could use zoneId.", "url": "https://github.com/elastic/elasticsearch/pull/65353#discussion_r528823644", "createdAt": "2020-11-23T16:13:02Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1036,6 +1042,79 @@ private static boolean notEqualsIsRemovableFromConjunction(NotEquals notEquals,\n \n     }\n \n+    /**\n+     * Combine disjunctions on the same field into an In expression.\n+     * This rule looks for both simple equalities:\n+     * 1. a == 1 OR a == 2 becomes a IN (1, 2)\n+     * and combinations of In\n+     * 2. a == 1 OR a IN (2) becomes a IN (1, 2)\n+     * 3. a IN (1) OR a IN (2) becomes a IN (1, 2)\n+     *\n+     * This rule does NOT check for type compatibility as that phase has been\n+     * already be verified in the analyzer.\n+     */\n+    public static class CombineDisjunctionsToIn extends OptimizerExpressionRule {\n+        public CombineDisjunctionsToIn() {\n+            super(TransformDirection.UP);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof Or) {\n+                // look only at equals and In\n+                List<Expression> exps = splitOr(e);\n+\n+                Map<Expression, Set<Expression>> found = new LinkedHashMap<>();\n+                ZoneId zoneId = null;\n+                List<Expression> ors = new ArrayList<>();\n+\n+                for (Expression exp : exps) {\n+                    if (exp instanceof Equals) {\n+                        Equals eq = (Equals) exp;\n+                        // consider only equals against foldables\n+                        if (eq.right().foldable()) {\n+                            found.computeIfAbsent(eq.left(), k -> new LinkedHashSet<>()).add(eq.right());\n+                        } else {\n+                            ors.add(exp);\n+                        }\n+                        if (zoneId == null) {\n+                            zoneId = eq.zoneId();\n+                        }\n+                    }\n+                    else if (exp instanceof In) {\n+                        In in = (In) exp;\n+                        found.computeIfAbsent(in.value(), k -> new LinkedHashSet<>()).addAll(in.list());\n+                        if (zoneId == null) {\n+                            zoneId = in.zoneId();\n+                        }\n+                    } else {\n+                        ors.add(exp);\n+                    }\n+                }\n+\n+                if (found.isEmpty() == false) {\n+                    // combine equals alongside the existing ors\n+                    ZoneId finalZoneId = zoneId;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28d351dbbe6d6429bf093cd31ca8d53ebb64cab7"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODgzNTI2Mw==", "bodyText": "Lambda usage - the variable needs to be final...", "url": "https://github.com/elastic/elasticsearch/pull/65353#discussion_r528835263", "createdAt": "2020-11-23T16:28:54Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1036,6 +1042,79 @@ private static boolean notEqualsIsRemovableFromConjunction(NotEquals notEquals,\n \n     }\n \n+    /**\n+     * Combine disjunctions on the same field into an In expression.\n+     * This rule looks for both simple equalities:\n+     * 1. a == 1 OR a == 2 becomes a IN (1, 2)\n+     * and combinations of In\n+     * 2. a == 1 OR a IN (2) becomes a IN (1, 2)\n+     * 3. a IN (1) OR a IN (2) becomes a IN (1, 2)\n+     *\n+     * This rule does NOT check for type compatibility as that phase has been\n+     * already be verified in the analyzer.\n+     */\n+    public static class CombineDisjunctionsToIn extends OptimizerExpressionRule {\n+        public CombineDisjunctionsToIn() {\n+            super(TransformDirection.UP);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof Or) {\n+                // look only at equals and In\n+                List<Expression> exps = splitOr(e);\n+\n+                Map<Expression, Set<Expression>> found = new LinkedHashMap<>();\n+                ZoneId zoneId = null;\n+                List<Expression> ors = new ArrayList<>();\n+\n+                for (Expression exp : exps) {\n+                    if (exp instanceof Equals) {\n+                        Equals eq = (Equals) exp;\n+                        // consider only equals against foldables\n+                        if (eq.right().foldable()) {\n+                            found.computeIfAbsent(eq.left(), k -> new LinkedHashSet<>()).add(eq.right());\n+                        } else {\n+                            ors.add(exp);\n+                        }\n+                        if (zoneId == null) {\n+                            zoneId = eq.zoneId();\n+                        }\n+                    }\n+                    else if (exp instanceof In) {\n+                        In in = (In) exp;\n+                        found.computeIfAbsent(in.value(), k -> new LinkedHashSet<>()).addAll(in.list());\n+                        if (zoneId == null) {\n+                            zoneId = in.zoneId();\n+                        }\n+                    } else {\n+                        ors.add(exp);\n+                    }\n+                }\n+\n+                if (found.isEmpty() == false) {\n+                    // combine equals alongside the existing ors\n+                    ZoneId finalZoneId = zoneId;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODgyMzY0NA=="}, "originalCommit": {"oid": "28d351dbbe6d6429bf093cd31ca8d53ebb64cab7"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg0MDk0Mg==", "bodyText": "Doesn't hurt to have a final in front of it ;-).", "url": "https://github.com/elastic/elasticsearch/pull/65353#discussion_r528840942", "createdAt": "2020-11-23T16:36:44Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1036,6 +1042,79 @@ private static boolean notEqualsIsRemovableFromConjunction(NotEquals notEquals,\n \n     }\n \n+    /**\n+     * Combine disjunctions on the same field into an In expression.\n+     * This rule looks for both simple equalities:\n+     * 1. a == 1 OR a == 2 becomes a IN (1, 2)\n+     * and combinations of In\n+     * 2. a == 1 OR a IN (2) becomes a IN (1, 2)\n+     * 3. a IN (1) OR a IN (2) becomes a IN (1, 2)\n+     *\n+     * This rule does NOT check for type compatibility as that phase has been\n+     * already be verified in the analyzer.\n+     */\n+    public static class CombineDisjunctionsToIn extends OptimizerExpressionRule {\n+        public CombineDisjunctionsToIn() {\n+            super(TransformDirection.UP);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof Or) {\n+                // look only at equals and In\n+                List<Expression> exps = splitOr(e);\n+\n+                Map<Expression, Set<Expression>> found = new LinkedHashMap<>();\n+                ZoneId zoneId = null;\n+                List<Expression> ors = new ArrayList<>();\n+\n+                for (Expression exp : exps) {\n+                    if (exp instanceof Equals) {\n+                        Equals eq = (Equals) exp;\n+                        // consider only equals against foldables\n+                        if (eq.right().foldable()) {\n+                            found.computeIfAbsent(eq.left(), k -> new LinkedHashSet<>()).add(eq.right());\n+                        } else {\n+                            ors.add(exp);\n+                        }\n+                        if (zoneId == null) {\n+                            zoneId = eq.zoneId();\n+                        }\n+                    }\n+                    else if (exp instanceof In) {\n+                        In in = (In) exp;\n+                        found.computeIfAbsent(in.value(), k -> new LinkedHashSet<>()).addAll(in.list());\n+                        if (zoneId == null) {\n+                            zoneId = in.zoneId();\n+                        }\n+                    } else {\n+                        ors.add(exp);\n+                    }\n+                }\n+\n+                if (found.isEmpty() == false) {\n+                    // combine equals alongside the existing ors\n+                    ZoneId finalZoneId = zoneId;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODgyMzY0NA=="}, "originalCommit": {"oid": "28d351dbbe6d6429bf093cd31ca8d53ebb64cab7"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxNjU0MTQ3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxNjoxMzozN1rOH4U2vQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxNzowOTo0NVrOH4XSFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODgyMzk5Nw==", "bodyText": "nit: any reason to use the proxy finalZoneId? good practice?", "url": "https://github.com/elastic/elasticsearch/pull/65353#discussion_r528823997", "createdAt": "2020-11-23T16:13:37Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1036,6 +1042,79 @@ private static boolean notEqualsIsRemovableFromConjunction(NotEquals notEquals,\n \n     }\n \n+    /**\n+     * Combine disjunctions on the same field into an In expression.\n+     * This rule looks for both simple equalities:\n+     * 1. a == 1 OR a == 2 becomes a IN (1, 2)\n+     * and combinations of In\n+     * 2. a == 1 OR a IN (2) becomes a IN (1, 2)\n+     * 3. a IN (1) OR a IN (2) becomes a IN (1, 2)\n+     *\n+     * This rule does NOT check for type compatibility as that phase has been\n+     * already be verified in the analyzer.\n+     */\n+    public static class CombineDisjunctionsToIn extends OptimizerExpressionRule {\n+        public CombineDisjunctionsToIn() {\n+            super(TransformDirection.UP);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof Or) {\n+                // look only at equals and In\n+                List<Expression> exps = splitOr(e);\n+\n+                Map<Expression, Set<Expression>> found = new LinkedHashMap<>();\n+                ZoneId zoneId = null;\n+                List<Expression> ors = new ArrayList<>();\n+\n+                for (Expression exp : exps) {\n+                    if (exp instanceof Equals) {\n+                        Equals eq = (Equals) exp;\n+                        // consider only equals against foldables\n+                        if (eq.right().foldable()) {\n+                            found.computeIfAbsent(eq.left(), k -> new LinkedHashSet<>()).add(eq.right());\n+                        } else {\n+                            ors.add(exp);\n+                        }\n+                        if (zoneId == null) {\n+                            zoneId = eq.zoneId();\n+                        }\n+                    }\n+                    else if (exp instanceof In) {\n+                        In in = (In) exp;\n+                        found.computeIfAbsent(in.value(), k -> new LinkedHashSet<>()).addAll(in.list());\n+                        if (zoneId == null) {\n+                            zoneId = in.zoneId();\n+                        }\n+                    } else {\n+                        ors.add(exp);\n+                    }\n+                }\n+\n+                if (found.isEmpty() == false) {\n+                    // combine equals alongside the existing ors\n+                    ZoneId finalZoneId = zoneId;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28d351dbbe6d6429bf093cd31ca8d53ebb64cab7"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg2Mzc2NQ==", "bodyText": "See the previous comment", "url": "https://github.com/elastic/elasticsearch/pull/65353#discussion_r528863765", "createdAt": "2020-11-23T17:09:45Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1036,6 +1042,79 @@ private static boolean notEqualsIsRemovableFromConjunction(NotEquals notEquals,\n \n     }\n \n+    /**\n+     * Combine disjunctions on the same field into an In expression.\n+     * This rule looks for both simple equalities:\n+     * 1. a == 1 OR a == 2 becomes a IN (1, 2)\n+     * and combinations of In\n+     * 2. a == 1 OR a IN (2) becomes a IN (1, 2)\n+     * 3. a IN (1) OR a IN (2) becomes a IN (1, 2)\n+     *\n+     * This rule does NOT check for type compatibility as that phase has been\n+     * already be verified in the analyzer.\n+     */\n+    public static class CombineDisjunctionsToIn extends OptimizerExpressionRule {\n+        public CombineDisjunctionsToIn() {\n+            super(TransformDirection.UP);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof Or) {\n+                // look only at equals and In\n+                List<Expression> exps = splitOr(e);\n+\n+                Map<Expression, Set<Expression>> found = new LinkedHashMap<>();\n+                ZoneId zoneId = null;\n+                List<Expression> ors = new ArrayList<>();\n+\n+                for (Expression exp : exps) {\n+                    if (exp instanceof Equals) {\n+                        Equals eq = (Equals) exp;\n+                        // consider only equals against foldables\n+                        if (eq.right().foldable()) {\n+                            found.computeIfAbsent(eq.left(), k -> new LinkedHashSet<>()).add(eq.right());\n+                        } else {\n+                            ors.add(exp);\n+                        }\n+                        if (zoneId == null) {\n+                            zoneId = eq.zoneId();\n+                        }\n+                    }\n+                    else if (exp instanceof In) {\n+                        In in = (In) exp;\n+                        found.computeIfAbsent(in.value(), k -> new LinkedHashSet<>()).addAll(in.list());\n+                        if (zoneId == null) {\n+                            zoneId = in.zoneId();\n+                        }\n+                    } else {\n+                        ors.add(exp);\n+                    }\n+                }\n+\n+                if (found.isEmpty() == false) {\n+                    // combine equals alongside the existing ors\n+                    ZoneId finalZoneId = zoneId;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODgyMzk5Nw=="}, "originalCommit": {"oid": "28d351dbbe6d6429bf093cd31ca8d53ebb64cab7"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxNjU4MTI1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/planner/QueryTranslatorTests.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxNjoyMTo0NVrOH4VOqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxNjoyMTo0NVrOH4VOqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODgzMDEyMA==", "bodyText": "Leftover?", "url": "https://github.com/elastic/elasticsearch/pull/65353#discussion_r528830120", "createdAt": "2020-11-23T16:21:45Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/planner/QueryTranslatorTests.java", "diffHunk": "@@ -106,6 +107,7 @@\n import static org.hamcrest.Matchers.is;\n import static org.hamcrest.Matchers.startsWith;\n \n+@TestLogging(value = \"org.elasticsearch.xpack.sql:TRACE\", reason = \"debug\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28d351dbbe6d6429bf093cd31ca8d53ebb64cab7"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxNjYwODY3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxNjoyNzozOVrOH4Vfcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxNzowOTozMlrOH4XRbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODgzNDQxOQ==", "bodyText": "QQ: I guess the IN could contain non foldable expressions? Wouldn't a similar check be useful for IN's elements?", "url": "https://github.com/elastic/elasticsearch/pull/65353#discussion_r528834419", "createdAt": "2020-11-23T16:27:39Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1036,6 +1042,79 @@ private static boolean notEqualsIsRemovableFromConjunction(NotEquals notEquals,\n \n     }\n \n+    /**\n+     * Combine disjunctions on the same field into an In expression.\n+     * This rule looks for both simple equalities:\n+     * 1. a == 1 OR a == 2 becomes a IN (1, 2)\n+     * and combinations of In\n+     * 2. a == 1 OR a IN (2) becomes a IN (1, 2)\n+     * 3. a IN (1) OR a IN (2) becomes a IN (1, 2)\n+     *\n+     * This rule does NOT check for type compatibility as that phase has been\n+     * already be verified in the analyzer.\n+     */\n+    public static class CombineDisjunctionsToIn extends OptimizerExpressionRule {\n+        public CombineDisjunctionsToIn() {\n+            super(TransformDirection.UP);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof Or) {\n+                // look only at equals and In\n+                List<Expression> exps = splitOr(e);\n+\n+                Map<Expression, Set<Expression>> found = new LinkedHashMap<>();\n+                ZoneId zoneId = null;\n+                List<Expression> ors = new ArrayList<>();\n+\n+                for (Expression exp : exps) {\n+                    if (exp instanceof Equals) {\n+                        Equals eq = (Equals) exp;\n+                        // consider only equals against foldables", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28d351dbbe6d6429bf093cd31ca8d53ebb64cab7"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg2MzU5Nw==", "bodyText": "In requires all values to be foldable and checks this inside its resolveType. Hence why any In produced will only have foldable expressions.", "url": "https://github.com/elastic/elasticsearch/pull/65353#discussion_r528863597", "createdAt": "2020-11-23T17:09:32Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1036,6 +1042,79 @@ private static boolean notEqualsIsRemovableFromConjunction(NotEquals notEquals,\n \n     }\n \n+    /**\n+     * Combine disjunctions on the same field into an In expression.\n+     * This rule looks for both simple equalities:\n+     * 1. a == 1 OR a == 2 becomes a IN (1, 2)\n+     * and combinations of In\n+     * 2. a == 1 OR a IN (2) becomes a IN (1, 2)\n+     * 3. a IN (1) OR a IN (2) becomes a IN (1, 2)\n+     *\n+     * This rule does NOT check for type compatibility as that phase has been\n+     * already be verified in the analyzer.\n+     */\n+    public static class CombineDisjunctionsToIn extends OptimizerExpressionRule {\n+        public CombineDisjunctionsToIn() {\n+            super(TransformDirection.UP);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof Or) {\n+                // look only at equals and In\n+                List<Expression> exps = splitOr(e);\n+\n+                Map<Expression, Set<Expression>> found = new LinkedHashMap<>();\n+                ZoneId zoneId = null;\n+                List<Expression> ors = new ArrayList<>();\n+\n+                for (Expression exp : exps) {\n+                    if (exp instanceof Equals) {\n+                        Equals eq = (Equals) exp;\n+                        // consider only equals against foldables", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODgzNDQxOQ=="}, "originalCommit": {"oid": "28d351dbbe6d6429bf093cd31ca8d53ebb64cab7"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxNjYzMzg5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/planner/QueryTranslatorTests.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxNjozMzoxMVrOH4VvLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxNzowOTo1MFrOH4XSWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODgzODQ0NQ==", "bodyText": "was this left intentionally?", "url": "https://github.com/elastic/elasticsearch/pull/65353#discussion_r528838445", "createdAt": "2020-11-23T16:33:11Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/planner/QueryTranslatorTests.java", "diffHunk": "@@ -106,6 +107,7 @@\n import static org.hamcrest.Matchers.is;\n import static org.hamcrest.Matchers.startsWith;\n \n+@TestLogging(value = \"org.elasticsearch.xpack.sql:TRACE\", reason = \"debug\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28d351dbbe6d6429bf093cd31ca8d53ebb64cab7"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg2MzgzNQ==", "bodyText": "See Andrei's comment", "url": "https://github.com/elastic/elasticsearch/pull/65353#discussion_r528863835", "createdAt": "2020-11-23T17:09:50Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/planner/QueryTranslatorTests.java", "diffHunk": "@@ -106,6 +107,7 @@\n import static org.hamcrest.Matchers.is;\n import static org.hamcrest.Matchers.startsWith;\n \n+@TestLogging(value = \"org.elasticsearch.xpack.sql:TRACE\", reason = \"debug\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODgzODQ0NQ=="}, "originalCommit": {"oid": "28d351dbbe6d6429bf093cd31ca8d53ebb64cab7"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxODAxNTk4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/test/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRulesTests.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMjo1OTo1MVrOH4itpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMjo1OTo1MVrOH4itpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA1MTA0Nw==", "bodyText": "Typo.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    assertEquals(e, e);\n          \n          \n            \n                    assertEquals(or, e);", "url": "https://github.com/elastic/elasticsearch/pull/65353#discussion_r529051047", "createdAt": "2020-11-23T22:59:51Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/ql/src/test/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRulesTests.java", "diffHunk": "@@ -1377,10 +1382,131 @@ public void testExactMatchRLike() throws Exception {\n         RLikePattern pattern = new RLikePattern(\"abc\");\n         FieldAttribute fa = getFieldAttribute();\n         RLike l = new RLike(EMPTY, fa, pattern);\n-        Expression e = new OptimizerRules.ReplaceRegexMatch().rule(l);\n+        Expression e = new ReplaceRegexMatch().rule(l);\n         assertEquals(Equals.class, e.getClass());\n         Equals eq = (Equals) e;\n         assertEquals(fa, eq.left());\n         assertEquals(\"abc\", eq.right().fold());\n     }\n+\n+    //\n+    // CombineDisjunction in Equals\n+    //\n+    public void testTwoEqualsWithOr() throws Exception {\n+        FieldAttribute fa = getFieldAttribute();\n+        Literal one = of(1);\n+        Literal two = of(2);\n+\n+        Or or = new Or(EMPTY, equalsOf(fa, one), equalsOf(fa, two));\n+        Expression e = new CombineDisjunctionsToIn().rule(or);\n+        assertEquals(In.class, e.getClass());\n+        In in = (In) e;\n+        assertEquals(fa, in.value());\n+        assertThat(in.list(), contains(one, two));\n+    }\n+\n+    public void testTwoEqualsWithSameValue() throws Exception {\n+        FieldAttribute fa = getFieldAttribute();\n+        Literal one = of(1);\n+\n+        Or or = new Or(EMPTY, equalsOf(fa, one), equalsOf(fa, one));\n+        Expression e = new CombineDisjunctionsToIn().rule(or);\n+        assertEquals(Equals.class, e.getClass());\n+        Equals eq = (Equals) e;\n+        assertEquals(fa, eq.left());\n+        assertEquals(one, eq.right());\n+    }\n+\n+    public void testOneEqualsOneIn() throws Exception {\n+        FieldAttribute fa = getFieldAttribute();\n+        Literal one = of(1);\n+        Literal two = of(2);\n+\n+        Or or = new Or(EMPTY, equalsOf(fa, one), new In(EMPTY, fa, singletonList(two)));\n+        Expression e = new CombineDisjunctionsToIn().rule(or);\n+        assertEquals(In.class, e.getClass());\n+        In in = (In) e;\n+        assertEquals(fa, in.value());\n+        assertThat(in.list(), contains(one, two));\n+    }\n+\n+    public void testOneEqualsOneInWithSameValue() throws Exception {\n+        FieldAttribute fa = getFieldAttribute();\n+        Literal one = of(1);\n+        Literal two = of(2);\n+\n+        Or or = new Or(EMPTY, equalsOf(fa, one), new In(EMPTY, fa, asList(one, two)));\n+        Expression e = new CombineDisjunctionsToIn().rule(or);\n+        assertEquals(In.class, e.getClass());\n+        In in = (In) e;\n+        assertEquals(fa, in.value());\n+        assertThat(in.list(), contains(one, two));\n+    }\n+\n+    public void testSingleValueInToEquals() throws Exception {\n+        FieldAttribute fa = getFieldAttribute();\n+        Literal one = of(1);\n+\n+        Equals equals = equalsOf(fa, one);\n+        Or or = new Or(EMPTY, equals, new In(EMPTY, fa, singletonList(one)));\n+        Expression e = new CombineDisjunctionsToIn().rule(or);\n+        assertEquals(equals, e);\n+    }\n+\n+    public void testEqualsBehindAnd() throws Exception {\n+        FieldAttribute fa = getFieldAttribute();\n+        Literal one = of(1);\n+        Literal two = of(2);\n+\n+        And and = new And(EMPTY, equalsOf(fa, one), equalsOf(fa, two));\n+        Expression e = new CombineDisjunctionsToIn().rule(and);\n+        assertEquals(and, e);\n+    }\n+\n+    public void testTwoEqualsDifferentFields() throws Exception {\n+        FieldAttribute fieldOne = getFieldAttribute(\"one\");\n+        FieldAttribute fieldTwo = getFieldAttribute(\"two\");\n+        Literal one = of(1);\n+        Literal two = of(2);\n+\n+        Or or = new Or(EMPTY, equalsOf(fieldOne, one), equalsOf(fieldTwo, two));\n+        Expression e = new CombineDisjunctionsToIn().rule(or);\n+        assertEquals(e, e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4ba0f99d6cf89e1986b365abb730c894e571aba"}, "originalPosition": 219}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxODAzMjU5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/test/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRulesTests.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMzowNjowMFrOH4i3-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMzowNjowMFrOH4i3-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA1MzY4OA==", "bodyText": "Super nit-picky. Would just test that there are no changes:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    assertEquals(LessThan.class, or.right().getClass());\n          \n          \n            \n                    LessThan lt = (LessThan) or.right();\n          \n          \n            \n                    assertEquals(fa, lt.left());\n          \n          \n            \n                    assertEquals(two, lt.right());\n          \n          \n            \n                    assertEquals(or.right(), firstOr.right());", "url": "https://github.com/elastic/elasticsearch/pull/65353#discussion_r529053688", "createdAt": "2020-11-23T23:06:00Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/ql/src/test/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRulesTests.java", "diffHunk": "@@ -1377,10 +1382,131 @@ public void testExactMatchRLike() throws Exception {\n         RLikePattern pattern = new RLikePattern(\"abc\");\n         FieldAttribute fa = getFieldAttribute();\n         RLike l = new RLike(EMPTY, fa, pattern);\n-        Expression e = new OptimizerRules.ReplaceRegexMatch().rule(l);\n+        Expression e = new ReplaceRegexMatch().rule(l);\n         assertEquals(Equals.class, e.getClass());\n         Equals eq = (Equals) e;\n         assertEquals(fa, eq.left());\n         assertEquals(\"abc\", eq.right().fold());\n     }\n+\n+    //\n+    // CombineDisjunction in Equals\n+    //\n+    public void testTwoEqualsWithOr() throws Exception {\n+        FieldAttribute fa = getFieldAttribute();\n+        Literal one = of(1);\n+        Literal two = of(2);\n+\n+        Or or = new Or(EMPTY, equalsOf(fa, one), equalsOf(fa, two));\n+        Expression e = new CombineDisjunctionsToIn().rule(or);\n+        assertEquals(In.class, e.getClass());\n+        In in = (In) e;\n+        assertEquals(fa, in.value());\n+        assertThat(in.list(), contains(one, two));\n+    }\n+\n+    public void testTwoEqualsWithSameValue() throws Exception {\n+        FieldAttribute fa = getFieldAttribute();\n+        Literal one = of(1);\n+\n+        Or or = new Or(EMPTY, equalsOf(fa, one), equalsOf(fa, one));\n+        Expression e = new CombineDisjunctionsToIn().rule(or);\n+        assertEquals(Equals.class, e.getClass());\n+        Equals eq = (Equals) e;\n+        assertEquals(fa, eq.left());\n+        assertEquals(one, eq.right());\n+    }\n+\n+    public void testOneEqualsOneIn() throws Exception {\n+        FieldAttribute fa = getFieldAttribute();\n+        Literal one = of(1);\n+        Literal two = of(2);\n+\n+        Or or = new Or(EMPTY, equalsOf(fa, one), new In(EMPTY, fa, singletonList(two)));\n+        Expression e = new CombineDisjunctionsToIn().rule(or);\n+        assertEquals(In.class, e.getClass());\n+        In in = (In) e;\n+        assertEquals(fa, in.value());\n+        assertThat(in.list(), contains(one, two));\n+    }\n+\n+    public void testOneEqualsOneInWithSameValue() throws Exception {\n+        FieldAttribute fa = getFieldAttribute();\n+        Literal one = of(1);\n+        Literal two = of(2);\n+\n+        Or or = new Or(EMPTY, equalsOf(fa, one), new In(EMPTY, fa, asList(one, two)));\n+        Expression e = new CombineDisjunctionsToIn().rule(or);\n+        assertEquals(In.class, e.getClass());\n+        In in = (In) e;\n+        assertEquals(fa, in.value());\n+        assertThat(in.list(), contains(one, two));\n+    }\n+\n+    public void testSingleValueInToEquals() throws Exception {\n+        FieldAttribute fa = getFieldAttribute();\n+        Literal one = of(1);\n+\n+        Equals equals = equalsOf(fa, one);\n+        Or or = new Or(EMPTY, equals, new In(EMPTY, fa, singletonList(one)));\n+        Expression e = new CombineDisjunctionsToIn().rule(or);\n+        assertEquals(equals, e);\n+    }\n+\n+    public void testEqualsBehindAnd() throws Exception {\n+        FieldAttribute fa = getFieldAttribute();\n+        Literal one = of(1);\n+        Literal two = of(2);\n+\n+        And and = new And(EMPTY, equalsOf(fa, one), equalsOf(fa, two));\n+        Expression e = new CombineDisjunctionsToIn().rule(and);\n+        assertEquals(and, e);\n+    }\n+\n+    public void testTwoEqualsDifferentFields() throws Exception {\n+        FieldAttribute fieldOne = getFieldAttribute(\"one\");\n+        FieldAttribute fieldTwo = getFieldAttribute(\"two\");\n+        Literal one = of(1);\n+        Literal two = of(2);\n+\n+        Or or = new Or(EMPTY, equalsOf(fieldOne, one), equalsOf(fieldTwo, two));\n+        Expression e = new CombineDisjunctionsToIn().rule(or);\n+        assertEquals(e, e);\n+    }\n+\n+    public void testMultipleIn() throws Exception {\n+        FieldAttribute fa = getFieldAttribute();\n+        Literal one = of(1);\n+        Literal two = of(2);\n+        Literal three = of(3);\n+\n+        Or firstOr = new Or(EMPTY, new In(EMPTY, fa, singletonList(one)), new In(EMPTY, fa, singletonList(two)));\n+        Or secondOr = new Or(EMPTY, firstOr, new In(EMPTY, fa, singletonList(three)));\n+        Expression e = new CombineDisjunctionsToIn().rule(secondOr);\n+        assertEquals(In.class, e.getClass());\n+        In in = (In) e;\n+        assertEquals(fa, in.value());\n+        assertThat(in.list(), contains(one, two, three));\n+    }\n+\n+    public void testOrWithNonCombinableExpressions() throws Exception {\n+        FieldAttribute fa = getFieldAttribute();\n+        Literal one = of(1);\n+        Literal two = of(2);\n+        Literal three = of(3);\n+\n+        Or firstOr = new Or(EMPTY, new In(EMPTY, fa, singletonList(one)), lessThanOf(fa, two));\n+        Or secondOr = new Or(EMPTY, firstOr, new In(EMPTY, fa, singletonList(three)));\n+        Expression e = new CombineDisjunctionsToIn().rule(secondOr);\n+        assertEquals(Or.class, e.getClass());\n+        Or or = (Or) e;\n+        assertEquals(LessThan.class, or.right().getClass());\n+        LessThan lt = (LessThan) or.right();\n+        assertEquals(fa, lt.left());\n+        assertEquals(two, lt.right());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4ba0f99d6cf89e1986b365abb730c894e571aba"}, "originalPosition": 251}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2003, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}