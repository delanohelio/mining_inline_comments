{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI0NTA0OTMw", "number": 57295, "title": "ILM: add support for rolling over data streams ", "bodyText": "As the datastream information is stored in the ClusterState.Metadata we exposed\nthe Metadata to the AsyncWaitStep#evaluateCondition method in order for\nthe steps to be able to identify when a managed index is part of a DataStream.\nIf a managed index is part of a DataStream the rollover target is the DataStream\nname and the highest generation index is the write index (ie. the rolled index).\nRelates to #53488\nRelates to #53100", "createdAt": "2020-05-28T13:58:36Z", "url": "https://github.com/elastic/elasticsearch/pull/57295", "merged": true, "mergeCommit": {"oid": "6b410dfb78f3676fce1b7401f1628c1ca6fbd45a"}, "closed": true, "closedAt": "2020-06-02T09:25:23Z", "author": {"login": "andreidan"}, "timelineItems": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcluPZkAH2gAyNDI0NTA0OTMwOmE2OTI2NjM4OTlkOTAxMDU2MGFmMWZlODI3YTRlNDkxNWNiZWUwNzI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcnCxR_AFqTQyMTk5MTI0OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "a692663899d9010560af1fe827a4e4915cbee072", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/a692663899d9010560af1fe827a4e4915cbee072", "committedDate": "2020-05-28T13:53:44Z", "message": "Lift getIndexSettingsAsMap in EsRestTestCase"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aae8ce35143445a2e767fe978b765ef00147545d", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/aae8ce35143445a2e767fe978b765ef00147545d", "committedDate": "2020-05-28T13:53:44Z", "message": "Extract rest ILM testing utilities in TimeSeriesRestDriver\n\nRelates to #53488"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ec11c9cb89a6c93bd0225d716ddb19a31f2104c1", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/ec11c9cb89a6c93bd0225d716ddb19a31f2104c1", "committedDate": "2020-05-28T13:53:45Z", "message": "ILM: add support for rolling over data streams\n\nAs the datastream information is stored in the `ClusterState.Metadata` we exposed\nthe `Metadata` to the `AsyncWaitStep#evaluateCondition` method in order for\nthe steps to be able to identify when a managed index is part of a DataStream.\n\nIf a managed index is part of a DataStream the rollover target is the DataStream\nname and the highest generation index is the write index (ie. the rolled index)."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b890e043f0f1a28e5cef016cb347330d338397dd", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/b890e043f0f1a28e5cef016cb347330d338397dd", "committedDate": "2020-05-28T14:28:58Z", "message": "Fix tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6fc0933b46d9fa67602bc8c5e699baf222dcee5c", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/6fc0933b46d9fa67602bc8c5e699baf222dcee5c", "committedDate": "2020-05-28T14:48:53Z", "message": "Fix line length"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwMjQzMjA1", "url": "https://github.com/elastic/elasticsearch/pull/57295#pullrequestreview-420243205", "createdAt": "2020-05-28T15:40:57Z", "commit": {"oid": "6fc0933b46d9fa67602bc8c5e699baf222dcee5c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNTo0MDo1N1rOGb7PcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNTo0MDo1N1rOGb7PcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzNTM0NA==", "bodyText": "Minor: this correctly identifies the data stream's write index under the current implementation of data streams. The IndexAbstraction::getWriteIndex method will always return the correct write index in the event that we change the logic around backing index names, generations, etc., and would slightly simplify the code above.", "url": "https://github.com/elastic/elasticsearch/pull/57295#discussion_r431935344", "createdAt": "2020-05-28T15:40:57Z", "author": {"login": "danhermann"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForActiveShardsStep.java", "diffHunk": "@@ -64,43 +65,48 @@ public Result isConditionMet(Index index, ClusterState clusterState) {\n             return new Result(true, new Info(message));\n         }\n \n-        String rolloverAlias = RolloverAction.LIFECYCLE_ROLLOVER_ALIAS_SETTING.get(originalIndexMeta.getSettings());\n-        if (Strings.isNullOrEmpty(rolloverAlias)) {\n-            throw new IllegalStateException(\"setting [\" + RolloverAction.LIFECYCLE_ROLLOVER_ALIAS\n-                + \"] is not set on index [\" + originalIndexMeta.getIndex().getName() + \"]\");\n-        }\n-\n-        IndexAbstraction indexAbstraction = clusterState.metadata().getIndicesLookup().get(rolloverAlias);\n-        assert indexAbstraction.getType() == IndexAbstraction.Type.ALIAS : rolloverAlias + \" must be an alias but it is not\";\n-\n-        IndexMetadata aliasWriteIndex = indexAbstraction.getWriteIndex();\n+        IndexAbstraction indexAbstraction = clusterState.metadata().getIndicesLookup().get(index.getName());\n         final String rolledIndexName;\n         final String waitForActiveShardsSettingValue;\n-        if (aliasWriteIndex != null) {\n-            rolledIndexName = aliasWriteIndex.getIndex().getName();\n-            waitForActiveShardsSettingValue = aliasWriteIndex.getSettings().get(\"index.write.wait_for_active_shards\");\n+        if (indexAbstraction.getParentDataStream() != null) {\n+            DataStream dataStream = indexAbstraction.getParentDataStream().getDataStream();\n+            rolledIndexName = DataStream.getBackingIndexName(dataStream.getName(), dataStream.getGeneration());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6fc0933b46d9fa67602bc8c5e699baf222dcee5c"}, "originalPosition": 30}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1aeedfd892d18e73b50d92e2ad389561ba501514", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/1aeedfd892d18e73b50d92e2ad389561ba501514", "committedDate": "2020-05-28T16:11:48Z", "message": "Get rolled index using the DataStream `writeIndex`"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwMzE5MDkz", "url": "https://github.com/elastic/elasticsearch/pull/57295#pullrequestreview-420319093", "createdAt": "2020-05-28T17:05:07Z", "commit": {"oid": "1aeedfd892d18e73b50d92e2ad389561ba501514"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNzowNTowOFrOGb-ndw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNzozMzoyNFrOGb_nsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk5MDY0Nw==", "bodyText": "It does seem strange to pass both the Metadata and the IndexMetadata, should we instead pass Metadata and Index so it's easy to look up the index metadata?", "url": "https://github.com/elastic/elasticsearch/pull/57295#discussion_r431990647", "createdAt": "2020-05-28T17:05:08Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/AsyncWaitStep.java", "diffHunk": "@@ -29,7 +30,7 @@ protected Client getClient() {\n         return client;\n     }\n \n-    public abstract void evaluateCondition(IndexMetadata indexMetadata, Listener listener, TimeValue masterTimeout);\n+    public abstract void evaluateCondition(Metadata metadata, IndexMetadata indexMetadata, Listener listener, TimeValue masterTimeout);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1aeedfd892d18e73b50d92e2ad389561ba501514"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk5MTk5NQ==", "bodyText": "Super minor, but can you add an\nassert indexAbstraction != null : \"expected the index \" + indexName + \" to exist in the lookup but it didn't\";\nafter this line? I don't think it's going to happen, but we should check it regardless. Optionally, we could make it a real error also (throw an IllegalStateException)", "url": "https://github.com/elastic/elasticsearch/pull/57295#discussion_r431991995", "createdAt": "2020-05-28T17:07:31Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/RolloverStep.java", "diffHunk": "@@ -39,38 +40,46 @@ public boolean isRetryable() {\n     @Override\n     public void performAction(IndexMetadata indexMetadata, ClusterState currentClusterState,\n                               ClusterStateObserver observer, Listener listener) {\n-        boolean indexingComplete = LifecycleSettings.LIFECYCLE_INDEXING_COMPLETE_SETTING.get(indexMetadata.getSettings());\n-        if (indexingComplete) {\n-            logger.trace(indexMetadata.getIndex() + \" has lifecycle complete set, skipping \" + RolloverStep.NAME);\n-            listener.onResponse(true);\n-            return;\n-        }\n+        IndexAbstraction indexAbstraction = currentClusterState.metadata().getIndicesLookup().get(indexMetadata.getIndex().getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1aeedfd892d18e73b50d92e2ad389561ba501514"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk5NDIxMQ==", "bodyText": "Just to be super paranoid, I think we should handle the case where getDataStream() returns null", "url": "https://github.com/elastic/elasticsearch/pull/57295#discussion_r431994211", "createdAt": "2020-05-28T17:11:22Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/RolloverStep.java", "diffHunk": "@@ -39,38 +40,46 @@ public boolean isRetryable() {\n     @Override\n     public void performAction(IndexMetadata indexMetadata, ClusterState currentClusterState,\n                               ClusterStateObserver observer, Listener listener) {\n-        boolean indexingComplete = LifecycleSettings.LIFECYCLE_INDEXING_COMPLETE_SETTING.get(indexMetadata.getSettings());\n-        if (indexingComplete) {\n-            logger.trace(indexMetadata.getIndex() + \" has lifecycle complete set, skipping \" + RolloverStep.NAME);\n-            listener.onResponse(true);\n-            return;\n-        }\n+        IndexAbstraction indexAbstraction = currentClusterState.metadata().getIndicesLookup().get(indexMetadata.getIndex().getName());\n+        final String rolloverTarget;\n+        if (indexAbstraction.getParentDataStream() != null) {\n+            rolloverTarget = indexAbstraction.getParentDataStream().getDataStream().getName();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1aeedfd892d18e73b50d92e2ad389561ba501514"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk5NTYzMg==", "bodyText": "Should we allow this indexing complete setting regardless of whether the parent data stream exists or not? (in otherwords, moving it before the if (indexAbstraction.getParentDataStream() != null) { check)", "url": "https://github.com/elastic/elasticsearch/pull/57295#discussion_r431995632", "createdAt": "2020-05-28T17:13:55Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/RolloverStep.java", "diffHunk": "@@ -39,38 +40,46 @@ public boolean isRetryable() {\n     @Override\n     public void performAction(IndexMetadata indexMetadata, ClusterState currentClusterState,\n                               ClusterStateObserver observer, Listener listener) {\n-        boolean indexingComplete = LifecycleSettings.LIFECYCLE_INDEXING_COMPLETE_SETTING.get(indexMetadata.getSettings());\n-        if (indexingComplete) {\n-            logger.trace(indexMetadata.getIndex() + \" has lifecycle complete set, skipping \" + RolloverStep.NAME);\n-            listener.onResponse(true);\n-            return;\n-        }\n+        IndexAbstraction indexAbstraction = currentClusterState.metadata().getIndicesLookup().get(indexMetadata.getIndex().getName());\n+        final String rolloverTarget;\n+        if (indexAbstraction.getParentDataStream() != null) {\n+            rolloverTarget = indexAbstraction.getParentDataStream().getDataStream().getName();\n+        } else {\n+            boolean indexingComplete = LifecycleSettings.LIFECYCLE_INDEXING_COMPLETE_SETTING.get(indexMetadata.getSettings());\n+            if (indexingComplete) {\n+                logger.trace(indexMetadata.getIndex() + \" has lifecycle complete set, skipping \" + RolloverStep.NAME);\n+                listener.onResponse(true);\n+                return;\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1aeedfd892d18e73b50d92e2ad389561ba501514"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk5NzU2OQ==", "bodyText": "I think this is a chance we can improve this error message (if you agree), maybe something like:\nsetting [index.lifecycle.rollover_alias] for index [foo-1] is not defined, it must be set to the name of the alias pointing to the group of indices being rolled over\n\nI'm not stuck on the wording, maybe you have a better idea?", "url": "https://github.com/elastic/elasticsearch/pull/57295#discussion_r431997569", "createdAt": "2020-05-28T17:17:28Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/RolloverStep.java", "diffHunk": "@@ -39,38 +40,46 @@ public boolean isRetryable() {\n     @Override\n     public void performAction(IndexMetadata indexMetadata, ClusterState currentClusterState,\n                               ClusterStateObserver observer, Listener listener) {\n-        boolean indexingComplete = LifecycleSettings.LIFECYCLE_INDEXING_COMPLETE_SETTING.get(indexMetadata.getSettings());\n-        if (indexingComplete) {\n-            logger.trace(indexMetadata.getIndex() + \" has lifecycle complete set, skipping \" + RolloverStep.NAME);\n-            listener.onResponse(true);\n-            return;\n-        }\n+        IndexAbstraction indexAbstraction = currentClusterState.metadata().getIndicesLookup().get(indexMetadata.getIndex().getName());\n+        final String rolloverTarget;\n+        if (indexAbstraction.getParentDataStream() != null) {\n+            rolloverTarget = indexAbstraction.getParentDataStream().getDataStream().getName();\n+        } else {\n+            boolean indexingComplete = LifecycleSettings.LIFECYCLE_INDEXING_COMPLETE_SETTING.get(indexMetadata.getSettings());\n+            if (indexingComplete) {\n+                logger.trace(indexMetadata.getIndex() + \" has lifecycle complete set, skipping \" + RolloverStep.NAME);\n+                listener.onResponse(true);\n+                return;\n+            }\n \n-        String rolloverAlias = RolloverAction.LIFECYCLE_ROLLOVER_ALIAS_SETTING.get(indexMetadata.getSettings());\n+            String rolloverAlias = RolloverAction.LIFECYCLE_ROLLOVER_ALIAS_SETTING.get(indexMetadata.getSettings());\n \n-        if (Strings.isNullOrEmpty(rolloverAlias)) {\n-            listener.onFailure(new IllegalArgumentException(String.format(Locale.ROOT,\n-                \"setting [%s] for index [%s] is empty or not defined\", RolloverAction.LIFECYCLE_ROLLOVER_ALIAS,\n-                indexMetadata.getIndex().getName())));\n-            return;\n-        }\n+            if (Strings.isNullOrEmpty(rolloverAlias)) {\n+                listener.onFailure(new IllegalArgumentException(String.format(Locale.ROOT,\n+                    \"setting [%s] for index [%s] is empty or not defined\", RolloverAction.LIFECYCLE_ROLLOVER_ALIAS,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1aeedfd892d18e73b50d92e2ad389561ba501514"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk5ODcwNg==", "bodyText": "I think this can be a static method?", "url": "https://github.com/elastic/elasticsearch/pull/57295#discussion_r431998706", "createdAt": "2020-05-28T17:19:20Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/UpdateRolloverLifecycleDateStep.java", "diffHunk": "@@ -76,6 +72,24 @@ public ClusterState performAction(Index index, ClusterState currentState) {\n             .put(newIndexMetadata)).build();\n     }\n \n+    private String getRolloverTarget(Index index, ClusterState currentState) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1aeedfd892d18e73b50d92e2ad389561ba501514"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjAwMDAyMg==", "bodyText": "Same comment here about null check for the getDataStream(), I also wonder if maybe we should make this a nice static helper like IndexAbstraction.streamNameOrNull(indexAbstraction)?", "url": "https://github.com/elastic/elasticsearch/pull/57295#discussion_r432000022", "createdAt": "2020-05-28T17:21:32Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/UpdateRolloverLifecycleDateStep.java", "diffHunk": "@@ -76,6 +72,24 @@ public ClusterState performAction(Index index, ClusterState currentState) {\n             .put(newIndexMetadata)).build();\n     }\n \n+    private String getRolloverTarget(Index index, ClusterState currentState) {\n+        IndexAbstraction indexAbstraction = currentState.metadata().getIndicesLookup().get(index.getName());\n+        final String rolloverTarget;\n+        if (indexAbstraction.getParentDataStream() != null) {\n+            rolloverTarget = indexAbstraction.getParentDataStream().getDataStream().getName();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1aeedfd892d18e73b50d92e2ad389561ba501514"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjAwMjU0Nw==", "bodyText": "Super minor, but can we use IndexMetadata.SETTING_WAIT_FOR_ACTIVE_SHARDS instead of hardcoding here?", "url": "https://github.com/elastic/elasticsearch/pull/57295#discussion_r432002547", "createdAt": "2020-05-28T17:25:40Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForActiveShardsStep.java", "diffHunk": "@@ -64,43 +67,50 @@ public Result isConditionMet(Index index, ClusterState clusterState) {\n             return new Result(true, new Info(message));\n         }\n \n-        String rolloverAlias = RolloverAction.LIFECYCLE_ROLLOVER_ALIAS_SETTING.get(originalIndexMeta.getSettings());\n-        if (Strings.isNullOrEmpty(rolloverAlias)) {\n-            throw new IllegalStateException(\"setting [\" + RolloverAction.LIFECYCLE_ROLLOVER_ALIAS\n-                + \"] is not set on index [\" + originalIndexMeta.getIndex().getName() + \"]\");\n-        }\n-\n-        IndexAbstraction indexAbstraction = clusterState.metadata().getIndicesLookup().get(rolloverAlias);\n-        assert indexAbstraction.getType() == IndexAbstraction.Type.ALIAS : rolloverAlias + \" must be an alias but it is not\";\n-\n-        IndexMetadata aliasWriteIndex = indexAbstraction.getWriteIndex();\n+        IndexAbstraction indexAbstraction = metadata.getIndicesLookup().get(index.getName());\n         final String rolledIndexName;\n         final String waitForActiveShardsSettingValue;\n-        if (aliasWriteIndex != null) {\n-            rolledIndexName = aliasWriteIndex.getIndex().getName();\n-            waitForActiveShardsSettingValue = aliasWriteIndex.getSettings().get(\"index.write.wait_for_active_shards\");\n-        } else {\n-            List<IndexMetadata> indices = indexAbstraction.getIndices();\n-            int maxIndexCounter = -1;\n-            IndexMetadata rolledIndexMeta = null;\n-            for (IndexMetadata indexMetadata : indices) {\n-                int indexNameCounter = parseIndexNameCounter(indexMetadata.getIndex().getName());\n-                if (maxIndexCounter < indexNameCounter) {\n-                    maxIndexCounter = indexNameCounter;\n-                    rolledIndexMeta = indexMetadata;\n-                }\n-            }\n+        if (indexAbstraction.getParentDataStream() != null) {\n+            DataStream dataStream = indexAbstraction.getParentDataStream().getDataStream();\n+            IndexAbstraction dataStreamAbstraction = metadata.getIndicesLookup().get(dataStream.getName());\n+            assert dataStreamAbstraction != null : dataStream.getName() + \" datastream is not present in the metadata indices lookup\";\n+            IndexMetadata rolledIndexMeta = dataStreamAbstraction.getWriteIndex();\n             if (rolledIndexMeta == null) {\n-                String errorMessage = String.format(Locale.ROOT,\n-                    \"unable to find the index that was rolled over from [%s] as part of lifecycle action [%s]\", index.getName(),\n-                    getKey().getAction());\n-\n-                // Index must have been since deleted\n-                logger.debug(errorMessage);\n-                return new Result(false, new Info(errorMessage));\n+                return getErrorResultOnNullMetadata(index);\n             }\n             rolledIndexName = rolledIndexMeta.getIndex().getName();\n             waitForActiveShardsSettingValue = rolledIndexMeta.getSettings().get(\"index.write.wait_for_active_shards\");\n+        } else {\n+            String rolloverAlias = RolloverAction.LIFECYCLE_ROLLOVER_ALIAS_SETTING.get(originalIndexMeta.getSettings());\n+            if (Strings.isNullOrEmpty(rolloverAlias)) {\n+                throw new IllegalStateException(\"setting [\" + RolloverAction.LIFECYCLE_ROLLOVER_ALIAS\n+                    + \"] is not set on index [\" + originalIndexMeta.getIndex().getName() + \"]\");\n+            }\n+\n+            IndexAbstraction aliasAbstraction = metadata.getIndicesLookup().get(rolloverAlias);\n+            assert aliasAbstraction.getType() == IndexAbstraction.Type.ALIAS : rolloverAlias + \" must be an alias but it is not\";\n+\n+            IndexMetadata aliasWriteIndex = aliasAbstraction.getWriteIndex();\n+            if (aliasWriteIndex != null) {\n+                rolledIndexName = aliasWriteIndex.getIndex().getName();\n+                waitForActiveShardsSettingValue = aliasWriteIndex.getSettings().get(\"index.write.wait_for_active_shards\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1aeedfd892d18e73b50d92e2ad389561ba501514"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjAwMjc1Nw==", "bodyText": "Same here about using IndexMetadata.SETTING_WAIT_FOR_ACTIVE_SHARDS", "url": "https://github.com/elastic/elasticsearch/pull/57295#discussion_r432002757", "createdAt": "2020-05-28T17:26:03Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForActiveShardsStep.java", "diffHunk": "@@ -64,43 +67,50 @@ public Result isConditionMet(Index index, ClusterState clusterState) {\n             return new Result(true, new Info(message));\n         }\n \n-        String rolloverAlias = RolloverAction.LIFECYCLE_ROLLOVER_ALIAS_SETTING.get(originalIndexMeta.getSettings());\n-        if (Strings.isNullOrEmpty(rolloverAlias)) {\n-            throw new IllegalStateException(\"setting [\" + RolloverAction.LIFECYCLE_ROLLOVER_ALIAS\n-                + \"] is not set on index [\" + originalIndexMeta.getIndex().getName() + \"]\");\n-        }\n-\n-        IndexAbstraction indexAbstraction = clusterState.metadata().getIndicesLookup().get(rolloverAlias);\n-        assert indexAbstraction.getType() == IndexAbstraction.Type.ALIAS : rolloverAlias + \" must be an alias but it is not\";\n-\n-        IndexMetadata aliasWriteIndex = indexAbstraction.getWriteIndex();\n+        IndexAbstraction indexAbstraction = metadata.getIndicesLookup().get(index.getName());\n         final String rolledIndexName;\n         final String waitForActiveShardsSettingValue;\n-        if (aliasWriteIndex != null) {\n-            rolledIndexName = aliasWriteIndex.getIndex().getName();\n-            waitForActiveShardsSettingValue = aliasWriteIndex.getSettings().get(\"index.write.wait_for_active_shards\");\n-        } else {\n-            List<IndexMetadata> indices = indexAbstraction.getIndices();\n-            int maxIndexCounter = -1;\n-            IndexMetadata rolledIndexMeta = null;\n-            for (IndexMetadata indexMetadata : indices) {\n-                int indexNameCounter = parseIndexNameCounter(indexMetadata.getIndex().getName());\n-                if (maxIndexCounter < indexNameCounter) {\n-                    maxIndexCounter = indexNameCounter;\n-                    rolledIndexMeta = indexMetadata;\n-                }\n-            }\n+        if (indexAbstraction.getParentDataStream() != null) {\n+            DataStream dataStream = indexAbstraction.getParentDataStream().getDataStream();\n+            IndexAbstraction dataStreamAbstraction = metadata.getIndicesLookup().get(dataStream.getName());\n+            assert dataStreamAbstraction != null : dataStream.getName() + \" datastream is not present in the metadata indices lookup\";\n+            IndexMetadata rolledIndexMeta = dataStreamAbstraction.getWriteIndex();\n             if (rolledIndexMeta == null) {\n-                String errorMessage = String.format(Locale.ROOT,\n-                    \"unable to find the index that was rolled over from [%s] as part of lifecycle action [%s]\", index.getName(),\n-                    getKey().getAction());\n-\n-                // Index must have been since deleted\n-                logger.debug(errorMessage);\n-                return new Result(false, new Info(errorMessage));\n+                return getErrorResultOnNullMetadata(index);\n             }\n             rolledIndexName = rolledIndexMeta.getIndex().getName();\n             waitForActiveShardsSettingValue = rolledIndexMeta.getSettings().get(\"index.write.wait_for_active_shards\");\n+        } else {\n+            String rolloverAlias = RolloverAction.LIFECYCLE_ROLLOVER_ALIAS_SETTING.get(originalIndexMeta.getSettings());\n+            if (Strings.isNullOrEmpty(rolloverAlias)) {\n+                throw new IllegalStateException(\"setting [\" + RolloverAction.LIFECYCLE_ROLLOVER_ALIAS\n+                    + \"] is not set on index [\" + originalIndexMeta.getIndex().getName() + \"]\");\n+            }\n+\n+            IndexAbstraction aliasAbstraction = metadata.getIndicesLookup().get(rolloverAlias);\n+            assert aliasAbstraction.getType() == IndexAbstraction.Type.ALIAS : rolloverAlias + \" must be an alias but it is not\";\n+\n+            IndexMetadata aliasWriteIndex = aliasAbstraction.getWriteIndex();\n+            if (aliasWriteIndex != null) {\n+                rolledIndexName = aliasWriteIndex.getIndex().getName();\n+                waitForActiveShardsSettingValue = aliasWriteIndex.getSettings().get(\"index.write.wait_for_active_shards\");\n+            } else {\n+                List<IndexMetadata> indices = aliasAbstraction.getIndices();\n+                int maxIndexCounter = -1;\n+                IndexMetadata rolledIndexMeta = null;\n+                for (IndexMetadata indexMetadata : indices) {\n+                    int indexNameCounter = parseIndexNameCounter(indexMetadata.getIndex().getName());\n+                    if (maxIndexCounter < indexNameCounter) {\n+                        maxIndexCounter = indexNameCounter;\n+                        rolledIndexMeta = indexMetadata;\n+                    }\n+                }\n+                if (rolledIndexMeta == null) {\n+                    return getErrorResultOnNullMetadata(index);\n+                }\n+                rolledIndexName = rolledIndexMeta.getIndex().getName();\n+                waitForActiveShardsSettingValue = rolledIndexMeta.getSettings().get(\"index.write.wait_for_active_shards\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1aeedfd892d18e73b50d92e2ad389561ba501514"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjAwMzMwOQ==", "bodyText": "This can be static I think", "url": "https://github.com/elastic/elasticsearch/pull/57295#discussion_r432003309", "createdAt": "2020-05-28T17:26:58Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForActiveShardsStep.java", "diffHunk": "@@ -114,6 +124,16 @@ public Result isConditionMet(Index index, ClusterState clusterState) {\n         return new Result(enoughShardsActive, new ActiveShardsInfo(currentActiveShards, activeShardCount.toString(), enoughShardsActive));\n     }\n \n+    private Result getErrorResultOnNullMetadata(Index originalIndex) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1aeedfd892d18e73b50d92e2ad389561ba501514"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjAwNzA5MA==", "bodyText": "Same here about null check or a helper for retrieving the name :)", "url": "https://github.com/elastic/elasticsearch/pull/57295#discussion_r432007090", "createdAt": "2020-05-28T17:33:24Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForRolloverReadyStep.java", "diffHunk": "@@ -48,73 +50,82 @@ public boolean isRetryable() {\n     }\n \n     @Override\n-    public void evaluateCondition(IndexMetadata indexMetadata, Listener listener, TimeValue masterTimeout) {\n-        String rolloverAlias = RolloverAction.LIFECYCLE_ROLLOVER_ALIAS_SETTING.get(indexMetadata.getSettings());\n-\n-        if (Strings.isNullOrEmpty(rolloverAlias)) {\n-            listener.onFailure(new IllegalArgumentException(String.format(Locale.ROOT,\n-                \"setting [%s] for index [%s] is empty or not defined\", RolloverAction.LIFECYCLE_ROLLOVER_ALIAS,\n-                indexMetadata.getIndex().getName())));\n-            return;\n-        }\n+    public void evaluateCondition(Metadata metadata, IndexMetadata indexMetadata, Listener listener, TimeValue masterTimeout) {\n+        IndexAbstraction indexAbstraction = metadata.getIndicesLookup().get(indexMetadata.getIndex().getName());\n+        assert indexAbstraction != null : \"invalid cluster metadata. index [\" + indexMetadata.getIndex().getName() + \"] was not found\";\n+        final String rolloverTarget;\n+        if (indexAbstraction.getParentDataStream() != null) {\n+            rolloverTarget = indexAbstraction.getParentDataStream().getDataStream().getName();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1aeedfd892d18e73b50d92e2ad389561ba501514"}, "originalPosition": 28}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2feb94509f14769531b4cde9b27c376de7babb4b", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/2feb94509f14769531b4cde9b27c376de7babb4b", "committedDate": "2020-05-29T10:14:51Z", "message": "Change AsyncWaitStep#evaluateCondition signature"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "308d1b657ff5cb8c1215fdec0dba58573710239a", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/308d1b657ff5cb8c1215fdec0dba58573710239a", "committedDate": "2020-05-29T10:57:27Z", "message": "Static methods, drop hardcoded strings, cosmetics"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "91a86cde25f38a3b0063c5b140f10c25a54dc815", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/91a86cde25f38a3b0063c5b140f10c25a54dc815", "committedDate": "2020-05-29T11:07:35Z", "message": "Remove unused imports"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9a6240585826cc40532b986ebbbc440f47d7e883", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/9a6240585826cc40532b986ebbbc440f47d7e883", "committedDate": "2020-05-29T11:35:23Z", "message": "Fix test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwOTE5NDQ3", "url": "https://github.com/elastic/elasticsearch/pull/57295#pullrequestreview-420919447", "createdAt": "2020-05-29T12:48:58Z", "commit": {"oid": "9a6240585826cc40532b986ebbbc440f47d7e883"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxOTkxMjQ5", "url": "https://github.com/elastic/elasticsearch/pull/57295#pullrequestreview-421991249", "createdAt": "2020-06-01T16:22:46Z", "commit": {"oid": "9a6240585826cc40532b986ebbbc440f47d7e883"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4125, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}