{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA0MDQ3Nzg0", "number": 55274, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxMToyMDo1MVrODydOYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwOTozNzoxOVrOD9t-KA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0MjM0MjEwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/indices/recovery/RemoteRecoveryTargetHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxMToyMDo1MVrOGGgoTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxMToyMDo1MVrOGGgoTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ3OTI0Nw==", "bodyText": "Should we guard against empty onGoingRetryableActions here before forking off?", "url": "https://github.com/elastic/elasticsearch/pull/55274#discussion_r409479247", "createdAt": "2020-04-16T11:20:51Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/indices/recovery/RemoteRecoveryTargetHandler.java", "diffHunk": "@@ -174,15 +217,67 @@ public void writeFileChunk(StoreFileMetadata fileMetadata, long position, BytesR\n             throttleTimeInNanos = 0;\n         }\n \n-        transportService.sendRequest(targetNode, PeerRecoveryTargetService.Actions.FILE_CHUNK,\n-            new RecoveryFileChunkRequest(recoveryId, shardId, fileMetadata, position, content, lastChunk,\n-                totalTranslogOps,\n+        final long requestSeqNo = requestSeqNoGenerator.getAndIncrement();\n+        final TimeValue initialDelay = TimeValue.timeValueMillis(50);\n+        final TimeValue timeout = fileChunkRequestOptions.timeout();\n+        final Object key = new Object();\n+        final ActionListener<Void> removeListener = ActionListener.runBefore(listener, () -> onGoingRetryableActions.remove(key));\n+        final RetryableAction<Void> fileChunkAction = new RetryableAction<>(logger, threadPool, initialDelay, timeout, removeListener) {\n+\n+            @Override\n+            public void tryAction(ActionListener<Void> listener) {\n                 /* we send estimateTotalOperations with every request since we collect stats on the target and that way we can\n                  * see how many translog ops we accumulate while copying files across the network. A future optimization\n                  * would be in to restart file copy again (new deltas) if we have too many translog ops are piling up.\n                  */\n-                throttleTimeInNanos), fileChunkRequestOptions, new ActionListenerResponseHandler<>(\n-                    ActionListener.map(listener, r -> null), in -> TransportResponse.Empty.INSTANCE, ThreadPool.Names.GENERIC));\n+                final RecoveryFileChunkRequest request = new RecoveryFileChunkRequest(recoveryId, requestSeqNo, shardId, fileMetadata,\n+                    position, content, lastChunk, totalTranslogOps, throttleTimeInNanos);\n+                transportService.sendRequest(targetNode, PeerRecoveryTargetService.Actions.FILE_CHUNK,\n+                    request, fileChunkRequestOptions, new ActionListenerResponseHandler<>(\n+                        ActionListener.map(listener, r -> null), in -> TransportResponse.Empty.INSTANCE, ThreadPool.Names.GENERIC));\n+            }\n+\n+            @Override\n+            public boolean shouldRetry(Exception e) {\n+                return retriesSupported && retryableException(e);\n+            }\n+        };\n+\n+        startRetryableAction(key, fileChunkAction);\n+    }\n+\n+    @Override\n+    public void cancel() {\n+        isCancelled = true;\n+        final RuntimeException exception = new CancellableThreads.ExecutionCancelledException(\"recovery was cancelled\");\n+        // Dispatch to generic as cancellation calls can come on the cluster state applier thread\n+        threadPool.generic().execute(() -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2c568f8d7ef531a651877809608c9ae686964ef"}, "originalPosition": 173}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0MjM1Mzk1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/indices/recovery/RequestTracker.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxMToyNDoxOVrOGGgvkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxMToyNDoxOVrOGGgvkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ4MTEwNA==", "bodyText": "remote -> remove", "url": "https://github.com/elastic/elasticsearch/pull/55274#discussion_r409481104", "createdAt": "2020-04-16T11:24:19Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/indices/recovery/RequestTracker.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.indices.recovery;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.common.util.concurrent.EsExecutors;\n+import org.elasticsearch.common.util.concurrent.ListenableFuture;\n+import org.elasticsearch.index.seqno.LocalCheckpointTracker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static org.elasticsearch.index.seqno.SequenceNumbers.NO_OPS_PERFORMED;\n+\n+public class RequestTracker {\n+\n+    private final Map<Long, ListenableFuture<Void>> ongoingRequests = new HashMap<>();\n+    private final LocalCheckpointTracker checkpointTracker = new LocalCheckpointTracker(NO_OPS_PERFORMED, NO_OPS_PERFORMED);\n+\n+    public synchronized ActionListener<Void> markReceivedAndCreateListener(long requestSeqNo, ActionListener<Void> listener) {\n+        if (checkpointTracker.hasProcessed(requestSeqNo)) {\n+            final ListenableFuture<Void> existingFuture = ongoingRequests.get(requestSeqNo);\n+            if (existingFuture != null) {\n+                existingFuture.addListener(listener, EsExecutors.newDirectExecutorService());\n+            } else {\n+                listener.onResponse(null);\n+            }\n+            return null;\n+        } else {\n+            checkpointTracker.markSeqNoAsProcessed(requestSeqNo);\n+            final ListenableFuture<Void> future = new ListenableFuture<>();\n+            ongoingRequests.put(requestSeqNo, future);\n+            future.addListener(new ActionListener<>() {\n+                @Override\n+                public void onResponse(Void v) {\n+                    synchronized (RequestTracker.this) {\n+                        ongoingRequests.remove(requestSeqNo);\n+                    }\n+                    listener.onResponse(v);\n+                }\n+\n+                @Override\n+                public void onFailure(Exception e) {\n+                    // We do not remote the future to cache the error for retried requests", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2c568f8d7ef531a651877809608c9ae686964ef"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1MzkyMzE5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/indices/recovery/PeerRecoverySourceService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwNjoxMjozMFrOGIEojA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwNjoxMjozMFrOGIEojA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTExNzcwOA==", "bodyText": "I think we really need some JavaDoc that explains the exact mechanics of this transport action.", "url": "https://github.com/elastic/elasticsearch/pull/55274#discussion_r411117708", "createdAt": "2020-04-20T06:12:30Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/indices/recovery/PeerRecoverySourceService.java", "diffHunk": "@@ -75,6 +77,8 @@ public PeerRecoverySourceService(TransportService transportService, IndicesServi\n         this.recoverySettings = recoverySettings;\n         transportService.registerRequestHandler(Actions.START_RECOVERY, ThreadPool.Names.GENERIC, StartRecoveryRequest::new,\n             new StartRecoveryTransportRequestHandler());\n+        transportService.registerRequestHandler(Actions.REESTABLISH_RECOVERY, ThreadPool.Names.GENERIC, ReestablishRecoveryRequest::new,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2c568f8d7ef531a651877809608c9ae686964ef"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NDUzNjM4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/indices/recovery/PeerRecoverySourceService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxOToxNTozNVrOGU_9wg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxOToxNTozNVrOGU_9wg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY3MjcwNg==", "bodyText": "We also need to compare targetAllocationId as we can have two ongoing recoveries for the same shard with the same recoveryId from different targets.", "url": "https://github.com/elastic/elasticsearch/pull/55274#discussion_r424672706", "createdAt": "2020-05-13T19:15:35Z", "author": {"login": "dnhatn"}, "path": "server/src/main/java/org/elasticsearch/indices/recovery/PeerRecoverySourceService.java", "diffHunk": "@@ -218,6 +255,24 @@ synchronized RecoverySourceHandler addNewRecovery(StartRecoveryRequest request,\n                 return handler;\n             }\n \n+            /**\n+             * Adds recovery source handler.\n+             */\n+            synchronized void reestablishRecovery(ReestablishRecoveryRequest request, ActionListener<RecoveryResponse> listener) {\n+                RecoverySourceHandler handler = null;\n+                for (RecoverySourceHandler existingHandler : recoveryHandlers) {\n+                    if (existingHandler.getRequest().recoveryId() == request.recoveryId()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2bebd52869a64c61e6e6f172c58fa65912369fd6"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NDYyMDMwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/indices/recovery/RequestTracker.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxOTo0MDo0OVrOGVAzDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxOTo0MDo0OVrOGVAzDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY4NjM0OA==", "bodyText": "Can we have a test verifying this? Maybe a concurrent test?", "url": "https://github.com/elastic/elasticsearch/pull/55274#discussion_r424686348", "createdAt": "2020-05-13T19:40:49Z", "author": {"login": "dnhatn"}, "path": "server/src/main/java/org/elasticsearch/indices/recovery/RequestTracker.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.indices.recovery;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.common.util.concurrent.EsExecutors;\n+import org.elasticsearch.common.util.concurrent.ListenableFuture;\n+import org.elasticsearch.index.seqno.LocalCheckpointTracker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static org.elasticsearch.index.seqno.SequenceNumbers.NO_OPS_PERFORMED;\n+\n+public class RequestTracker {\n+\n+    private final Map<Long, ListenableFuture<Void>> ongoingRequests = new HashMap<>();\n+    private final LocalCheckpointTracker checkpointTracker = new LocalCheckpointTracker(NO_OPS_PERFORMED, NO_OPS_PERFORMED);\n+\n+    public synchronized ActionListener<Void> markReceivedAndCreateListener(long requestSeqNo, ActionListener<Void> listener) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2bebd52869a64c61e6e6f172c58fa65912369fd6"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MDM0NDU4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/indices/recovery/PeerRecoverySourceService.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwOToxNToyNlrOGXXWow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwODoyNDoxMVrOGZ4_iw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE1MzA1OQ==", "bodyText": "I wonder what will happen if the original recovery request has run to completion before reestablishRecovery has been called. At that point, the RecoverySourceHandler  has been  removed and we'll get a ResourceNotFoundException, even though the recovery completed. The target shard will then completely reset and restart the recovery. Not a biggie (given that the retry should be fast, as it has a retention lease and will do an ops-based recovery), just interesting case to consider.", "url": "https://github.com/elastic/elasticsearch/pull/55274#discussion_r427153059", "createdAt": "2020-05-19T09:15:26Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/indices/recovery/PeerRecoverySourceService.java", "diffHunk": "@@ -218,6 +255,25 @@ synchronized RecoverySourceHandler addNewRecovery(StartRecoveryRequest request,\n                 return handler;\n             }\n \n+            /**\n+             * Adds recovery source handler.\n+             */\n+            synchronized void reestablishRecovery(ReestablishRecoveryRequest request, ActionListener<RecoveryResponse> listener) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a39e4ac1c6dc581402ad87697d484766e4cd94b"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODIzODc5NA==", "bodyText": "I will consider this scenario in a potential follow-up cleanups. This PR is already pretty big, so I want to hold off right now.", "url": "https://github.com/elastic/elasticsearch/pull/55274#discussion_r428238794", "createdAt": "2020-05-20T18:55:02Z", "author": {"login": "tbrooks8"}, "path": "server/src/main/java/org/elasticsearch/indices/recovery/PeerRecoverySourceService.java", "diffHunk": "@@ -218,6 +255,25 @@ synchronized RecoverySourceHandler addNewRecovery(StartRecoveryRequest request,\n                 return handler;\n             }\n \n+            /**\n+             * Adds recovery source handler.\n+             */\n+            synchronized void reestablishRecovery(ReestablishRecoveryRequest request, ActionListener<RecoveryResponse> listener) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE1MzA1OQ=="}, "originalCommit": {"oid": "1a39e4ac1c6dc581402ad87697d484766e4cd94b"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgwMTM1NQ==", "bodyText": "As I said, I'm fine keeping the behavior as is (as it should incrementally restart due to ops-based recovery), just interesting to reason through the behavior.", "url": "https://github.com/elastic/elasticsearch/pull/55274#discussion_r429801355", "createdAt": "2020-05-25T08:24:11Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/indices/recovery/PeerRecoverySourceService.java", "diffHunk": "@@ -218,6 +255,25 @@ synchronized RecoverySourceHandler addNewRecovery(StartRecoveryRequest request,\n                 return handler;\n             }\n \n+            /**\n+             * Adds recovery source handler.\n+             */\n+            synchronized void reestablishRecovery(ReestablishRecoveryRequest request, ActionListener<RecoveryResponse> listener) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE1MzA1OQ=="}, "originalCommit": {"oid": "1a39e4ac1c6dc581402ad87697d484766e4cd94b"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MDM3OTY1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/indices/recovery/PeerRecoveryTargetService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwOToyNDozM1rOGXXstw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxOTo1Nzo1OVrOGYbrww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE1ODcxMQ==", "bodyText": "when is the listener null?", "url": "https://github.com/elastic/elasticsearch/pull/55274#discussion_r427158711", "createdAt": "2020-05-19T09:24:33Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/indices/recovery/PeerRecoveryTargetService.java", "diffHunk": "@@ -513,6 +448,11 @@ public void messageReceived(RecoveryCleanFilesRequest request, TransportChannel\n         public void messageReceived(final RecoveryFileChunkRequest request, TransportChannel channel, Task task) throws Exception {\n             try (RecoveryRef recoveryRef = onGoingRecoveries.getRecoverySafe(request.recoveryId(), request.shardId())) {\n                 final RecoveryTarget recoveryTarget = recoveryRef.target();\n+                final ActionListener<Void> listener = createOrFinishListener(recoveryRef, channel, Actions.FILE_CHUNK, request);\n+                if (listener == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a39e4ac1c6dc581402ad87697d484766e4cd94b"}, "originalPosition": 324}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI3MjU3OQ==", "bodyText": "I added the java doc which explains it.", "url": "https://github.com/elastic/elasticsearch/pull/55274#discussion_r428272579", "createdAt": "2020-05-20T19:57:59Z", "author": {"login": "tbrooks8"}, "path": "server/src/main/java/org/elasticsearch/indices/recovery/PeerRecoveryTargetService.java", "diffHunk": "@@ -513,6 +448,11 @@ public void messageReceived(RecoveryCleanFilesRequest request, TransportChannel\n         public void messageReceived(final RecoveryFileChunkRequest request, TransportChannel channel, Task task) throws Exception {\n             try (RecoveryRef recoveryRef = onGoingRecoveries.getRecoverySafe(request.recoveryId(), request.shardId())) {\n                 final RecoveryTarget recoveryTarget = recoveryRef.target();\n+                final ActionListener<Void> listener = createOrFinishListener(recoveryRef, channel, Actions.FILE_CHUNK, request);\n+                if (listener == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE1ODcxMQ=="}, "originalCommit": {"oid": "1a39e4ac1c6dc581402ad87697d484766e4cd94b"}, "originalPosition": 324}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MDM5MzYyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/indices/recovery/PeerRecoveryTargetService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwOToyODoxMFrOGXX1pA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwOToyODoxMFrOGXX1pA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE2MDk5Ng==", "bodyText": "Can you add a comment here saying that the ResourceNotFoundException covers a failed reestablishRecovery? Given that ResourceNotFoundException is a super class for some exceptions (notably some that we handle earlier here), for example RetentionLeaseNotFoundException, that there's a risk that we might end up indefinitely retrying in case something's wrong with the recovery. I think I would prefer a more specialized exception or targeted approach here.", "url": "https://github.com/elastic/elasticsearch/pull/55274#discussion_r427160996", "createdAt": "2020-05-19T09:28:10Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/indices/recovery/PeerRecoveryTargetService.java", "diffHunk": "@@ -562,7 +530,131 @@ public void onFailure(Exception e) {\n \n         @Override\n         public void doRun() {\n-            doRecovery(recoveryId);\n+            doRecovery(recoveryId, startRecoveryRequest);\n+        }\n+    }\n+\n+    private class RecoveryResponseHandler implements TransportResponseHandler<RecoveryResponse> {\n+\n+        private final long recoveryId;\n+        private final StartRecoveryRequest request;\n+        private final RecoveryState.Timer timer;\n+\n+        private RecoveryResponseHandler(final StartRecoveryRequest request, final RecoveryState.Timer timer) {\n+            this.recoveryId = request.recoveryId();\n+            this.request = request;\n+            this.timer = timer;\n+        }\n+\n+        @Override\n+        public void handleResponse(RecoveryResponse recoveryResponse) {\n+            final TimeValue recoveryTime = new TimeValue(timer.time());\n+            // do this through ongoing recoveries to remove it from the collection\n+            onGoingRecoveries.markRecoveryAsDone(recoveryId);\n+            if (logger.isTraceEnabled()) {\n+                StringBuilder sb = new StringBuilder();\n+                sb.append('[').append(request.shardId().getIndex().getName()).append(']')\n+                    .append('[').append(request.shardId().id()).append(\"] \");\n+                sb.append(\"recovery completed from \").append(request.sourceNode()).append(\", took[\").append(recoveryTime)\n+                    .append(\"]\\n\");\n+                sb.append(\"   phase1: recovered_files [\").append(recoveryResponse.phase1FileNames.size()).append(\"]\")\n+                    .append(\" with total_size of [\").append(new ByteSizeValue(recoveryResponse.phase1TotalSize)).append(\"]\")\n+                    .append(\", took [\").append(timeValueMillis(recoveryResponse.phase1Time)).append(\"], throttling_wait [\")\n+                    .append(timeValueMillis(recoveryResponse.phase1ThrottlingWaitTime)).append(']').append(\"\\n\");\n+                sb.append(\"         : reusing_files   [\").append(recoveryResponse.phase1ExistingFileNames.size())\n+                    .append(\"] with total_size of [\").append(new ByteSizeValue(recoveryResponse.phase1ExistingTotalSize))\n+                    .append(\"]\\n\");\n+                sb.append(\"   phase2: start took [\").append(timeValueMillis(recoveryResponse.startTime)).append(\"]\\n\");\n+                sb.append(\"         : recovered [\").append(recoveryResponse.phase2Operations).append(\"]\")\n+                    .append(\" transaction log operations\")\n+                    .append(\", took [\").append(timeValueMillis(recoveryResponse.phase2Time)).append(\"]\")\n+                    .append(\"\\n\");\n+                logger.trace(\"{}\", sb);\n+            } else {\n+                logger.debug(\"{} recovery done from [{}], took [{}]\", request.shardId(), request.sourceNode(),\n+                    recoveryTime);\n+            }\n+        }\n+\n+        @Override\n+        public void handleException(TransportException e) {\n+            onException(e);\n+        }\n+\n+        private void onException(Exception e) {\n+            if (logger.isTraceEnabled()) {\n+                logger.trace(() -> new ParameterizedMessage(\n+                    \"[{}][{}] Got exception on recovery\", request.shardId().getIndex().getName(),\n+                    request.shardId().id()), e);\n+            }\n+            Throwable cause = ExceptionsHelper.unwrapCause(e);\n+            if (cause instanceof CancellableThreads.ExecutionCancelledException) {\n+                // this can also come from the source wrapped in a RemoteTransportException\n+                onGoingRecoveries.failRecovery(recoveryId, new RecoveryFailedException(request,\n+                    \"source has canceled the recovery\", cause), false);\n+                return;\n+            }\n+            if (cause instanceof RecoveryEngineException) {\n+                // unwrap an exception that was thrown as part of the recovery\n+                cause = cause.getCause();\n+            }\n+            // do it twice, in case we have double transport exception\n+            cause = ExceptionsHelper.unwrapCause(cause);\n+            if (cause instanceof RecoveryEngineException) {\n+                // unwrap an exception that was thrown as part of the recovery\n+                cause = cause.getCause();\n+            }\n+\n+            // here, we would add checks against exception that need to be retried (and not removeAndClean in this case)\n+\n+            if (cause instanceof IllegalIndexShardStateException || cause instanceof IndexNotFoundException ||\n+                cause instanceof ShardNotFoundException) {\n+                // if the target is not ready yet, retry\n+                retryRecovery(\n+                    recoveryId,\n+                    \"remote shard not ready\",\n+                    recoverySettings.retryDelayStateSync(),\n+                    recoverySettings.activityTimeout());\n+                return;\n+            }\n+\n+            if (cause instanceof DelayRecoveryException || cause instanceof ResourceNotFoundException) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a39e4ac1c6dc581402ad87697d484766e4cd94b"}, "originalPosition": 474}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MDQyNjM0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/indices/recovery/RecoveryRequestTracker.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwOTozNjozNFrOGXYKMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwOTozNjozNFrOGXYKMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE2NjI1Nw==", "bodyText": "Can you add @nullable annotation and add some docs for this method?", "url": "https://github.com/elastic/elasticsearch/pull/55274#discussion_r427166257", "createdAt": "2020-05-19T09:36:34Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/indices/recovery/RecoveryRequestTracker.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.indices.recovery;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.common.util.concurrent.EsExecutors;\n+import org.elasticsearch.common.util.concurrent.ListenableFuture;\n+import org.elasticsearch.index.seqno.LocalCheckpointTracker;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static org.elasticsearch.index.seqno.SequenceNumbers.NO_OPS_PERFORMED;\n+\n+public class RecoveryRequestTracker {\n+\n+    private final Map<Long, ListenableFuture<Void>> ongoingRequests = Collections.synchronizedMap(new HashMap<>());\n+    private final LocalCheckpointTracker checkpointTracker = new LocalCheckpointTracker(NO_OPS_PERFORMED, NO_OPS_PERFORMED);\n+\n+    public synchronized ActionListener<Void> markReceivedAndCreateListener(long requestSeqNo, ActionListener<Void> listener) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a39e4ac1c6dc581402ad87697d484766e4cd94b"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MDQyOTIwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/indices/recovery/RecoveryRequestTracker.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwOTozNzoxOVrOGXYL-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwOTozNzoxOVrOGXYL-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE2NjcxNQ==", "bodyText": "combine this with the previous line", "url": "https://github.com/elastic/elasticsearch/pull/55274#discussion_r427166715", "createdAt": "2020-05-19T09:37:19Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/indices/recovery/RecoveryRequestTracker.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.indices.recovery;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.common.util.concurrent.EsExecutors;\n+import org.elasticsearch.common.util.concurrent.ListenableFuture;\n+import org.elasticsearch.index.seqno.LocalCheckpointTracker;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static org.elasticsearch.index.seqno.SequenceNumbers.NO_OPS_PERFORMED;\n+\n+public class RecoveryRequestTracker {\n+\n+    private final Map<Long, ListenableFuture<Void>> ongoingRequests = Collections.synchronizedMap(new HashMap<>());\n+    private final LocalCheckpointTracker checkpointTracker = new LocalCheckpointTracker(NO_OPS_PERFORMED, NO_OPS_PERFORMED);\n+\n+    public synchronized ActionListener<Void> markReceivedAndCreateListener(long requestSeqNo, ActionListener<Void> listener) {\n+        if (checkpointTracker.hasProcessed(requestSeqNo)) {\n+            final ListenableFuture<Void> existingFuture;\n+            existingFuture = ongoingRequests.get(requestSeqNo);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a39e4ac1c6dc581402ad87697d484766e4cd94b"}, "originalPosition": 41}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1076, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}