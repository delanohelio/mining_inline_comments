{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE5NTQ0NjI0", "number": 56915, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNzoyODoxOFrOD9fQog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNjo0MTo0MFrOD94cYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1ODAxODkwOnYy", "diffSide": "RIGHT", "path": "test/framework/src/main/java/org/elasticsearch/index/mapper/FieldMapperTestCase.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNzoyODoxOFrOGXA5KA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxODozMTo1MFrOGXC7eg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc4NTA2NA==", "bodyText": "It seems like we could reuse the existing test classes MockFieldMapper and FakeFieldType here.", "url": "https://github.com/elastic/elasticsearch/pull/56915#discussion_r426785064", "createdAt": "2020-05-18T17:28:18Z", "author": {"login": "jtibshirani"}, "path": "test/framework/src/main/java/org/elasticsearch/index/mapper/FieldMapperTestCase.java", "diffHunk": "@@ -0,0 +1,235 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.analysis.standard.StandardAnalyzer;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.similarities.BM25Similarity;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.analysis.AnalyzerScope;\n+import org.elasticsearch.index.analysis.NamedAnalyzer;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.index.similarity.SimilarityProvider;\n+import org.elasticsearch.test.ESSingleNodeTestCase;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.function.BiConsumer;\n+\n+import static org.hamcrest.Matchers.containsString;\n+\n+public abstract class FieldMapperTestCase<T extends FieldMapper.Builder<?>> extends ESSingleNodeTestCase {\n+\n+    protected final Settings SETTINGS = Settings.builder()\n+        .put(\"index.version.created\", Version.CURRENT)\n+        .build();\n+\n+    private final class Modifier {\n+        final String property;\n+        final boolean updateable;\n+        final BiConsumer<T, T> modifier;\n+\n+        Modifier(String property, boolean updateable, BiConsumer<T, T> modifier) {\n+            this.property = property;\n+            this.updateable = updateable;\n+            this.modifier = modifier;\n+        }\n+\n+        void apply(T first, T second) {\n+            modifier.accept(first, second);\n+        }\n+    }\n+\n+    private Modifier booleanModifier(String name, boolean updateable, BiConsumer<T, Boolean> method) {\n+        return new Modifier(name, updateable, (a, b) -> {\n+            method.accept(a, true);\n+            method.accept(b, false);\n+        });\n+    }\n+\n+    private Object dummyNullValue = \"dummyvalue\";\n+\n+    /** Sets the null value used by the modifier for null value testing. This should be set in an @Before method. */\n+    protected void setDummyNullValue(Object value) {\n+        dummyNullValue = value;\n+    }\n+\n+    protected boolean supportsDocValues() {\n+        return true;\n+    }\n+\n+    protected boolean supportsStore() {\n+        return true;\n+    }\n+\n+    private final List<Modifier> modifiers = new ArrayList<>(Arrays.asList(\n+        new Modifier(\"analyzer\", false, (a, b) -> {\n+            a.indexAnalyzer(new NamedAnalyzer(\"a\", AnalyzerScope.INDEX, new StandardAnalyzer()));\n+            a.indexAnalyzer(new NamedAnalyzer(\"b\", AnalyzerScope.INDEX, new StandardAnalyzer()));\n+        }),\n+        new Modifier(\"boost\", true, (a, b) -> {\n+           a.fieldType().setBoost(1.1f);\n+           b.fieldType().setBoost(1.2f);\n+        }),\n+        new Modifier(\"doc_values\", supportsDocValues() == false, (a, b) -> {\n+            if (supportsDocValues()) {\n+                a.docValues(true);\n+                b.docValues(false);\n+            }\n+        }),\n+        booleanModifier(\"eager_global_ordinals\", true, (a, t) -> a.fieldType().setEagerGlobalOrdinals(t)),\n+        booleanModifier(\"norms\", false, FieldMapper.Builder::omitNorms),\n+        new Modifier(\"null_value\", true, (a, b) -> {\n+            a.fieldType().setNullValue(dummyNullValue);\n+        }),\n+        new Modifier(\"search_analyzer\", true, (a, b) -> {\n+            a.searchAnalyzer(new NamedAnalyzer(\"a\", AnalyzerScope.INDEX, new StandardAnalyzer()));\n+            a.searchAnalyzer(new NamedAnalyzer(\"b\", AnalyzerScope.INDEX, new StandardAnalyzer()));\n+        }),\n+        new Modifier(\"search_quote_analyzer\", true, (a, b) -> {\n+            a.searchQuoteAnalyzer(new NamedAnalyzer(\"a\", AnalyzerScope.INDEX, new StandardAnalyzer()));\n+            a.searchQuoteAnalyzer(new NamedAnalyzer(\"b\", AnalyzerScope.INDEX, new StandardAnalyzer()));\n+        }),\n+        new Modifier(\"similarity\", false, (a, b) -> {\n+            a.similarity(new SimilarityProvider(\"a\", new BM25Similarity()));\n+            b.similarity(new SimilarityProvider(\"b\", new BM25Similarity()));\n+        }),\n+        new Modifier(\"store\", supportsStore() == false, (a, b) -> {\n+            if (supportsStore()) {\n+                a.store(true);\n+                b.store(false);\n+            }\n+        }),\n+        new Modifier(\"term_vector\", false, (a, b) -> {\n+            a.storeTermVectors(true);\n+            b.storeTermVectors(false);\n+        }),\n+        new Modifier(\"term_vector_positions\", false, (a, b) -> {\n+            a.storeTermVectors(true);\n+            b.storeTermVectors(true);\n+            a.storeTermVectorPositions(true);\n+            b.storeTermVectorPositions(false);\n+        }),\n+        new Modifier(\"term_vector_payloads\", false, (a, b) -> {\n+            a.storeTermVectors(true);\n+            b.storeTermVectors(true);\n+            a.storeTermVectorPositions(true);\n+            b.storeTermVectorPositions(true);\n+            a.storeTermVectorPayloads(true);\n+            b.storeTermVectorPayloads(false);\n+        }),\n+        new Modifier(\"term_vector_offsets\", false, (a, b) -> {\n+            a.storeTermVectors(true);\n+            b.storeTermVectors(true);\n+            a.storeTermVectorPositions(true);\n+            b.storeTermVectorPositions(true);\n+            a.storeTermVectorOffsets(true);\n+            b.storeTermVectorOffsets(false);\n+        })\n+    ));\n+\n+    /**\n+     * Add type-specific modifiers for consistency checking.\n+     *\n+     * This should be called in a {@code @Before} method\n+     */\n+    protected void addModifier(String property, boolean updateable, BiConsumer<T, T> method) {\n+        modifiers.add(new Modifier(property, updateable, method));\n+    }\n+\n+    /**\n+     * Add type-specific modifiers for consistency checking.\n+     *\n+     * This should be called in a {@code @Before} method\n+     */\n+    protected void addBooleanModifier(String property, boolean updateable, BiConsumer<T, Boolean> method) {\n+        modifiers.add(new Modifier(property, updateable, (a, b) -> {\n+            method.accept(a, true);\n+            method.accept(b, false);\n+        }));\n+    }\n+\n+    protected abstract T newBuilder();\n+\n+    private static class BogusFieldType extends MappedFieldType {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7da9e8b0bf444a243d988c51ddfc33ffcc1d8d9"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjgxODQyNg==", "bodyText": "++", "url": "https://github.com/elastic/elasticsearch/pull/56915#discussion_r426818426", "createdAt": "2020-05-18T18:31:50Z", "author": {"login": "romseygeek"}, "path": "test/framework/src/main/java/org/elasticsearch/index/mapper/FieldMapperTestCase.java", "diffHunk": "@@ -0,0 +1,235 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.analysis.standard.StandardAnalyzer;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.similarities.BM25Similarity;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.analysis.AnalyzerScope;\n+import org.elasticsearch.index.analysis.NamedAnalyzer;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.index.similarity.SimilarityProvider;\n+import org.elasticsearch.test.ESSingleNodeTestCase;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.function.BiConsumer;\n+\n+import static org.hamcrest.Matchers.containsString;\n+\n+public abstract class FieldMapperTestCase<T extends FieldMapper.Builder<?>> extends ESSingleNodeTestCase {\n+\n+    protected final Settings SETTINGS = Settings.builder()\n+        .put(\"index.version.created\", Version.CURRENT)\n+        .build();\n+\n+    private final class Modifier {\n+        final String property;\n+        final boolean updateable;\n+        final BiConsumer<T, T> modifier;\n+\n+        Modifier(String property, boolean updateable, BiConsumer<T, T> modifier) {\n+            this.property = property;\n+            this.updateable = updateable;\n+            this.modifier = modifier;\n+        }\n+\n+        void apply(T first, T second) {\n+            modifier.accept(first, second);\n+        }\n+    }\n+\n+    private Modifier booleanModifier(String name, boolean updateable, BiConsumer<T, Boolean> method) {\n+        return new Modifier(name, updateable, (a, b) -> {\n+            method.accept(a, true);\n+            method.accept(b, false);\n+        });\n+    }\n+\n+    private Object dummyNullValue = \"dummyvalue\";\n+\n+    /** Sets the null value used by the modifier for null value testing. This should be set in an @Before method. */\n+    protected void setDummyNullValue(Object value) {\n+        dummyNullValue = value;\n+    }\n+\n+    protected boolean supportsDocValues() {\n+        return true;\n+    }\n+\n+    protected boolean supportsStore() {\n+        return true;\n+    }\n+\n+    private final List<Modifier> modifiers = new ArrayList<>(Arrays.asList(\n+        new Modifier(\"analyzer\", false, (a, b) -> {\n+            a.indexAnalyzer(new NamedAnalyzer(\"a\", AnalyzerScope.INDEX, new StandardAnalyzer()));\n+            a.indexAnalyzer(new NamedAnalyzer(\"b\", AnalyzerScope.INDEX, new StandardAnalyzer()));\n+        }),\n+        new Modifier(\"boost\", true, (a, b) -> {\n+           a.fieldType().setBoost(1.1f);\n+           b.fieldType().setBoost(1.2f);\n+        }),\n+        new Modifier(\"doc_values\", supportsDocValues() == false, (a, b) -> {\n+            if (supportsDocValues()) {\n+                a.docValues(true);\n+                b.docValues(false);\n+            }\n+        }),\n+        booleanModifier(\"eager_global_ordinals\", true, (a, t) -> a.fieldType().setEagerGlobalOrdinals(t)),\n+        booleanModifier(\"norms\", false, FieldMapper.Builder::omitNorms),\n+        new Modifier(\"null_value\", true, (a, b) -> {\n+            a.fieldType().setNullValue(dummyNullValue);\n+        }),\n+        new Modifier(\"search_analyzer\", true, (a, b) -> {\n+            a.searchAnalyzer(new NamedAnalyzer(\"a\", AnalyzerScope.INDEX, new StandardAnalyzer()));\n+            a.searchAnalyzer(new NamedAnalyzer(\"b\", AnalyzerScope.INDEX, new StandardAnalyzer()));\n+        }),\n+        new Modifier(\"search_quote_analyzer\", true, (a, b) -> {\n+            a.searchQuoteAnalyzer(new NamedAnalyzer(\"a\", AnalyzerScope.INDEX, new StandardAnalyzer()));\n+            a.searchQuoteAnalyzer(new NamedAnalyzer(\"b\", AnalyzerScope.INDEX, new StandardAnalyzer()));\n+        }),\n+        new Modifier(\"similarity\", false, (a, b) -> {\n+            a.similarity(new SimilarityProvider(\"a\", new BM25Similarity()));\n+            b.similarity(new SimilarityProvider(\"b\", new BM25Similarity()));\n+        }),\n+        new Modifier(\"store\", supportsStore() == false, (a, b) -> {\n+            if (supportsStore()) {\n+                a.store(true);\n+                b.store(false);\n+            }\n+        }),\n+        new Modifier(\"term_vector\", false, (a, b) -> {\n+            a.storeTermVectors(true);\n+            b.storeTermVectors(false);\n+        }),\n+        new Modifier(\"term_vector_positions\", false, (a, b) -> {\n+            a.storeTermVectors(true);\n+            b.storeTermVectors(true);\n+            a.storeTermVectorPositions(true);\n+            b.storeTermVectorPositions(false);\n+        }),\n+        new Modifier(\"term_vector_payloads\", false, (a, b) -> {\n+            a.storeTermVectors(true);\n+            b.storeTermVectors(true);\n+            a.storeTermVectorPositions(true);\n+            b.storeTermVectorPositions(true);\n+            a.storeTermVectorPayloads(true);\n+            b.storeTermVectorPayloads(false);\n+        }),\n+        new Modifier(\"term_vector_offsets\", false, (a, b) -> {\n+            a.storeTermVectors(true);\n+            b.storeTermVectors(true);\n+            a.storeTermVectorPositions(true);\n+            b.storeTermVectorPositions(true);\n+            a.storeTermVectorOffsets(true);\n+            b.storeTermVectorOffsets(false);\n+        })\n+    ));\n+\n+    /**\n+     * Add type-specific modifiers for consistency checking.\n+     *\n+     * This should be called in a {@code @Before} method\n+     */\n+    protected void addModifier(String property, boolean updateable, BiConsumer<T, T> method) {\n+        modifiers.add(new Modifier(property, updateable, method));\n+    }\n+\n+    /**\n+     * Add type-specific modifiers for consistency checking.\n+     *\n+     * This should be called in a {@code @Before} method\n+     */\n+    protected void addBooleanModifier(String property, boolean updateable, BiConsumer<T, Boolean> method) {\n+        modifiers.add(new Modifier(property, updateable, (a, b) -> {\n+            method.accept(a, true);\n+            method.accept(b, false);\n+        }));\n+    }\n+\n+    protected abstract T newBuilder();\n+\n+    private static class BogusFieldType extends MappedFieldType {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc4NTA2NA=="}, "originalCommit": {"oid": "b7da9e8b0bf444a243d988c51ddfc33ffcc1d8d9"}, "originalPosition": 173}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1ODA0MjE3OnYy", "diffSide": "LEFT", "path": "test/framework/src/main/java/org/elasticsearch/index/mapper/FieldTypeTestCase.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNzozNTowOVrOGXBHfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxODozMjoyM1rOGXC8fg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc4ODczNQ==", "bodyText": "It looks like this test was lost in the refactor. Do we have plans to replace it or make it no longer necessary?", "url": "https://github.com/elastic/elasticsearch/pull/56915#discussion_r426788735", "createdAt": "2020-05-18T17:35:09Z", "author": {"login": "jtibshirani"}, "path": "test/framework/src/main/java/org/elasticsearch/index/mapper/FieldTypeTestCase.java", "diffHunk": "@@ -283,92 +95,6 @@ public void testEquals() {\n         assertEquals(ft1, ft2); // symmetric\n         assertEquals(ft2, ft1);\n         assertEquals(ft1.hashCode(), ft2.hashCode());\n-\n-        for (Modifier modifier : modifiers) {\n-            ft1 = createNamedDefaultFieldType();\n-            ft2 = createNamedDefaultFieldType();\n-            modifier.modify(ft2);\n-            assertFieldTypeNotEquals(modifier.property, ft1, ft2);\n-            assertNotEquals(\"hash code for modified property \" + modifier.property, ft1.hashCode(), ft2.hashCode());\n-            // modify the same property and they are equal again\n-            modifier.modify(ft1);\n-            assertFieldTypeEquals(modifier.property, ft1, ft2);\n-            assertEquals(\"hash code for modified property \" + modifier.property, ft1.hashCode(), ft2.hashCode());\n-        }\n-    }\n-\n-    public void testFreeze() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7da9e8b0bf444a243d988c51ddfc33ffcc1d8d9"}, "originalPosition": 237}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjgxODY4Ng==", "bodyText": "The next step will be to decouple FieldType and MappedFieldType entirely, so there won't need to be a freeze() method here at all.", "url": "https://github.com/elastic/elasticsearch/pull/56915#discussion_r426818686", "createdAt": "2020-05-18T18:32:23Z", "author": {"login": "romseygeek"}, "path": "test/framework/src/main/java/org/elasticsearch/index/mapper/FieldTypeTestCase.java", "diffHunk": "@@ -283,92 +95,6 @@ public void testEquals() {\n         assertEquals(ft1, ft2); // symmetric\n         assertEquals(ft2, ft1);\n         assertEquals(ft1.hashCode(), ft2.hashCode());\n-\n-        for (Modifier modifier : modifiers) {\n-            ft1 = createNamedDefaultFieldType();\n-            ft2 = createNamedDefaultFieldType();\n-            modifier.modify(ft2);\n-            assertFieldTypeNotEquals(modifier.property, ft1, ft2);\n-            assertNotEquals(\"hash code for modified property \" + modifier.property, ft1.hashCode(), ft2.hashCode());\n-            // modify the same property and they are equal again\n-            modifier.modify(ft1);\n-            assertFieldTypeEquals(modifier.property, ft1, ft2);\n-            assertEquals(\"hash code for modified property \" + modifier.property, ft1.hashCode(), ft2.hashCode());\n-        }\n-    }\n-\n-    public void testFreeze() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc4ODczNQ=="}, "originalCommit": {"oid": "b7da9e8b0bf444a243d988c51ddfc33ffcc1d8d9"}, "originalPosition": 237}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1ODgzMzE5OnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/elasticsearch/index/mapper/UpdateMappingTests.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMTo1ODo0OVrOGXI2yQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMTozNDo1MlrOGXcL0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkxNTUyOQ==", "bodyText": "To me the error message \"mapper [foo] cannot be changed from type [long] to [double]\" is a lot clearer, we could prefer that original wording.\nOn a related note, it looks like MappedFieldType#checkTypeName is now unused and can be removed.", "url": "https://github.com/elastic/elasticsearch/pull/56915#discussion_r426915529", "createdAt": "2020-05-18T21:58:49Z", "author": {"login": "jtibshirani"}, "path": "server/src/test/java/org/elasticsearch/index/mapper/UpdateMappingTests.java", "diffHunk": "@@ -101,19 +101,13 @@ public void testConflictSameType() throws Exception {\n                 .startObject(\"properties\").startObject(\"foo\").field(\"type\", \"double\").endObject()\n                 .endObject().endObject().endObject();\n \n-        try {\n-            mapperService.merge(\"type\", new CompressedXContent(Strings.toString(update)), MapperService.MergeReason.MAPPING_UPDATE);\n-            fail();\n-        } catch (IllegalArgumentException e) {\n-            assertThat(e.getMessage(), containsString(\"mapper [foo] cannot be changed from type [long] to [double]\"));\n-        }\n+        IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () ->\n+            mapperService.merge(\"type\", new CompressedXContent(Strings.toString(update)), MapperService.MergeReason.MAPPING_UPDATE));\n+        assertThat(e.getMessage(), containsString(\"mapper [foo] of different type, current_type [long], merged_type [double]\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b59cedc67df4610186583e930ccfbdefc9efc3c8"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzIzMjIwOA==", "bodyText": "++", "url": "https://github.com/elastic/elasticsearch/pull/56915#discussion_r427232208", "createdAt": "2020-05-19T11:34:52Z", "author": {"login": "romseygeek"}, "path": "server/src/test/java/org/elasticsearch/index/mapper/UpdateMappingTests.java", "diffHunk": "@@ -101,19 +101,13 @@ public void testConflictSameType() throws Exception {\n                 .startObject(\"properties\").startObject(\"foo\").field(\"type\", \"double\").endObject()\n                 .endObject().endObject().endObject();\n \n-        try {\n-            mapperService.merge(\"type\", new CompressedXContent(Strings.toString(update)), MapperService.MergeReason.MAPPING_UPDATE);\n-            fail();\n-        } catch (IllegalArgumentException e) {\n-            assertThat(e.getMessage(), containsString(\"mapper [foo] cannot be changed from type [long] to [double]\"));\n-        }\n+        IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () ->\n+            mapperService.merge(\"type\", new CompressedXContent(Strings.toString(update)), MapperService.MergeReason.MAPPING_UPDATE));\n+        assertThat(e.getMessage(), containsString(\"mapper [foo] of different type, current_type [long], merged_type [double]\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkxNTUyOQ=="}, "originalCommit": {"oid": "b59cedc67df4610186583e930ccfbdefc9efc3c8"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1ODg1MTE1OnYy", "diffSide": "LEFT", "path": "test/framework/src/main/java/org/elasticsearch/index/mapper/FieldTypeTestCase.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMjowNjoxN1rOGXJBow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMTozNjowOFrOGXcO5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkxODMwNw==", "bodyText": "I just noticed we've lost test coverage for the equals method, which is used in FieldTypeLookup. This is too bad, I wonder if we could we keep these modifiers around or switch to using EqualsHashCodeTestUtils#checkEqualsAndHashCode.", "url": "https://github.com/elastic/elasticsearch/pull/56915#discussion_r426918307", "createdAt": "2020-05-18T22:06:17Z", "author": {"login": "jtibshirani"}, "path": "test/framework/src/main/java/org/elasticsearch/index/mapper/FieldTypeTestCase.java", "diffHunk": "@@ -283,92 +95,6 @@ public void testEquals() {\n         assertEquals(ft1, ft2); // symmetric\n         assertEquals(ft2, ft1);\n         assertEquals(ft1.hashCode(), ft2.hashCode());\n-\n-        for (Modifier modifier : modifiers) {\n-            ft1 = createNamedDefaultFieldType();\n-            ft2 = createNamedDefaultFieldType();\n-            modifier.modify(ft2);\n-            assertFieldTypeNotEquals(modifier.property, ft1, ft2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b59cedc67df4610186583e930ccfbdefc9efc3c8"}, "originalPosition": 228}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzIzMjk5Nw==", "bodyText": "With luck we'll be able to simplify a lot of the MapperService lookup stuff once things have been rearranged, but for now I agree we still need these tests.  I've modified FieldTypeTestCase to allow testing of subtypes with modifiers, using EqualsHashCodeTestUtils.", "url": "https://github.com/elastic/elasticsearch/pull/56915#discussion_r427232997", "createdAt": "2020-05-19T11:36:08Z", "author": {"login": "romseygeek"}, "path": "test/framework/src/main/java/org/elasticsearch/index/mapper/FieldTypeTestCase.java", "diffHunk": "@@ -283,92 +95,6 @@ public void testEquals() {\n         assertEquals(ft1, ft2); // symmetric\n         assertEquals(ft2, ft1);\n         assertEquals(ft1.hashCode(), ft2.hashCode());\n-\n-        for (Modifier modifier : modifiers) {\n-            ft1 = createNamedDefaultFieldType();\n-            ft2 = createNamedDefaultFieldType();\n-            modifier.modify(ft2);\n-            assertFieldTypeNotEquals(modifier.property, ft1, ft2);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkxODMwNw=="}, "originalCommit": {"oid": "b59cedc67df4610186583e930ccfbdefc9efc3c8"}, "originalPosition": 228}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1ODkyMzk3OnYy", "diffSide": "RIGHT", "path": "test/framework/src/main/java/org/elasticsearch/index/mapper/FieldMapperTestCase.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMjozNzoxMlrOGXJstw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMTozNTowMVrOGXcMHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkyOTMzNQ==", "bodyText": "I think this could just be FIeldMapper toMerge = new MockFieldMapper(\"bogus\") ?", "url": "https://github.com/elastic/elasticsearch/pull/56915#discussion_r426929335", "createdAt": "2020-05-18T22:37:12Z", "author": {"login": "jtibshirani"}, "path": "test/framework/src/main/java/org/elasticsearch/index/mapper/FieldMapperTestCase.java", "diffHunk": "@@ -203,8 +179,8 @@ public void testMergeConflicts() {\n         }\n         {\n             FieldMapper mapper = (FieldMapper) newBuilder().build(context);\n-            FieldMapper toMerge = new FieldMapper(\"bogus\", new BogusFieldType(), new BogusFieldType(),\n-                SETTINGS, FieldMapper.MultiFields.empty(), FieldMapper.CopyTo.empty()) {\n+            FieldMapper toMerge = new FieldMapper(\"bogus\", new MockFieldMapper.FakeFieldType(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b59cedc67df4610186583e930ccfbdefc9efc3c8"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzIzMjI4Nw==", "bodyText": "It could, thanks!", "url": "https://github.com/elastic/elasticsearch/pull/56915#discussion_r427232287", "createdAt": "2020-05-19T11:35:01Z", "author": {"login": "romseygeek"}, "path": "test/framework/src/main/java/org/elasticsearch/index/mapper/FieldMapperTestCase.java", "diffHunk": "@@ -203,8 +179,8 @@ public void testMergeConflicts() {\n         }\n         {\n             FieldMapper mapper = (FieldMapper) newBuilder().build(context);\n-            FieldMapper toMerge = new FieldMapper(\"bogus\", new BogusFieldType(), new BogusFieldType(),\n-                SETTINGS, FieldMapper.MultiFields.empty(), FieldMapper.CopyTo.empty()) {\n+            FieldMapper toMerge = new FieldMapper(\"bogus\", new MockFieldMapper.FakeFieldType(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkyOTMzNQ=="}, "originalCommit": {"oid": "b59cedc67df4610186583e930ccfbdefc9efc3c8"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MjEwODQyOnYy", "diffSide": "LEFT", "path": "x-pack/plugin/spatial/src/test/java/org/elasticsearch/xpack/spatial/index/mapper/GeoShapeWithDocValuesFieldTypeTests.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNjozMjozMVrOGXo00Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNzoyNToyN1rOGXq36w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQzOTMxMw==", "bodyText": "Should this test have been deleted?", "url": "https://github.com/elastic/elasticsearch/pull/56915#discussion_r427439313", "createdAt": "2020-05-19T16:32:31Z", "author": {"login": "jtibshirani"}, "path": "x-pack/plugin/spatial/src/test/java/org/elasticsearch/xpack/spatial/index/mapper/GeoShapeWithDocValuesFieldTypeTests.java", "diffHunk": "@@ -1,30 +0,0 @@\n-/*\n- * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n- * or more contributor license agreements. Licensed under the Elastic License;\n- * you may not use this file except in compliance with the Elastic License.\n- */\n-\n-package org.elasticsearch.xpack.spatial.index.mapper;\n-\n-import org.elasticsearch.common.geo.builders.ShapeBuilder;\n-import org.elasticsearch.index.mapper.FieldTypeTestCase;\n-import org.elasticsearch.index.mapper.MappedFieldType;\n-import org.junit.Before;\n-\n-public class GeoShapeWithDocValuesFieldTypeTests extends FieldTypeTestCase {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee7c14a7d8ab018dcd96743d380e89d5154585ec"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3Mjg3NQ==", "bodyText": "It should not!  Have restored it.", "url": "https://github.com/elastic/elasticsearch/pull/56915#discussion_r427472875", "createdAt": "2020-05-19T17:25:27Z", "author": {"login": "romseygeek"}, "path": "x-pack/plugin/spatial/src/test/java/org/elasticsearch/xpack/spatial/index/mapper/GeoShapeWithDocValuesFieldTypeTests.java", "diffHunk": "@@ -1,30 +0,0 @@\n-/*\n- * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n- * or more contributor license agreements. Licensed under the Elastic License;\n- * you may not use this file except in compliance with the Elastic License.\n- */\n-\n-package org.elasticsearch.xpack.spatial.index.mapper;\n-\n-import org.elasticsearch.common.geo.builders.ShapeBuilder;\n-import org.elasticsearch.index.mapper.FieldTypeTestCase;\n-import org.elasticsearch.index.mapper.MappedFieldType;\n-import org.junit.Before;\n-\n-public class GeoShapeWithDocValuesFieldTypeTests extends FieldTypeTestCase {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQzOTMxMw=="}, "originalCommit": {"oid": "ee7c14a7d8ab018dcd96743d380e89d5154585ec"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MjExNjY1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNjozNDoxMFrOGXo5uA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNjozNDoxMFrOGXo5uA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0MDU2OA==", "bodyText": "Great that this is abstract, I like how it encourages implementors to think through what can be updated vs. not.", "url": "https://github.com/elastic/elasticsearch/pull/56915#discussion_r427440568", "createdAt": "2020-05-19T16:34:10Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java", "diffHunk": "@@ -334,32 +334,88 @@ protected FieldMapper clone() {\n     }\n \n     @Override\n-    public FieldMapper merge(Mapper mergeWith) {\n+    public final FieldMapper merge(Mapper mergeWith) {\n         FieldMapper merged = clone();\n-        merged.doMerge(mergeWith);\n+        List<String> conflicts = new ArrayList<>();\n+        if (mergeWith instanceof FieldMapper == false) {\n+            throw new IllegalArgumentException(\"mapper [\" + fieldType.name() + \"] cannot be changed from type [\"\n+            + contentType() + \"] to [\" + mergeWith.getClass().getSimpleName() + \"]\");\n+        }\n+        merged.mergeSharedOptions((FieldMapper)mergeWith, conflicts);\n+        if (conflicts.isEmpty() == false) {\n+            throw new IllegalArgumentException(\"Mapper for [\" + name() +\n+                \"] conflicts with existing mapping:\\n\" + conflicts.toString());\n+        }\n         return merged;\n     }\n \n-    /**\n-     * Merge changes coming from {@code mergeWith} in place.\n-     */\n-    protected void doMerge(Mapper mergeWith) {\n-        if (!this.getClass().equals(mergeWith.getClass())) {\n-            String mergedType = mergeWith.getClass().getSimpleName();\n-            if (mergeWith instanceof FieldMapper) {\n-                mergedType = ((FieldMapper) mergeWith).contentType();\n+    private void mergeSharedOptions(FieldMapper mergeWith, List<String> conflicts) {\n+\n+        if (Objects.equals(this.contentType(), mergeWith.contentType()) == false) {\n+            throw new IllegalArgumentException(\"mapper [\" + fieldType().name() + \"] cannot be changed from type [\" + contentType()\n+                + \"] to [\" + mergeWith.contentType() + \"]\");\n+        }\n+\n+        MappedFieldType other = mergeWith.fieldType;\n+\n+        boolean indexed =  fieldType.indexOptions() != IndexOptions.NONE;\n+        boolean mergeWithIndexed = other.indexOptions() != IndexOptions.NONE;\n+        // TODO: should be validating if index options go \"up\" (but \"down\" is ok)\n+        if (indexed != mergeWithIndexed) {\n+            conflicts.add(\"mapper [\" + name() + \"] has different [index] values\");\n+        }\n+        if (fieldType.stored() != other.stored()) {\n+            conflicts.add(\"mapper [\" + name() + \"] has different [store] values\");\n+        }\n+        if (fieldType.hasDocValues() != other.hasDocValues()) {\n+            conflicts.add(\"mapper [\" + name() + \"] has different [doc_values] values\");\n+        }\n+        if (fieldType.omitNorms() && !other.omitNorms()) {\n+            conflicts.add(\"mapper [\" + name() + \"] has different [norms] values, cannot change from disable to enabled\");\n+        }\n+        if (fieldType.storeTermVectors() != other.storeTermVectors()) {\n+            conflicts.add(\"mapper [\" + name() + \"] has different [store_term_vector] values\");\n+        }\n+        if (fieldType.storeTermVectorOffsets() != other.storeTermVectorOffsets()) {\n+            conflicts.add(\"mapper [\" + name() + \"] has different [store_term_vector_offsets] values\");\n+        }\n+        if (fieldType.storeTermVectorPositions() != other.storeTermVectorPositions()) {\n+            conflicts.add(\"mapper [\" + name() + \"] has different [store_term_vector_positions] values\");\n+        }\n+        if (fieldType.storeTermVectorPayloads() != other.storeTermVectorPayloads()) {\n+            conflicts.add(\"mapper [\" + name() + \"] has different [store_term_vector_payloads] values\");\n+        }\n+\n+        // null and \"default\"-named index analyzers both mean the default is used\n+        if (fieldType.indexAnalyzer() == null || \"default\".equals(fieldType.indexAnalyzer().name())) {\n+            if (other.indexAnalyzer() != null && \"default\".equals(other.indexAnalyzer().name()) == false) {\n+                conflicts.add(\"mapper [\" + name() + \"] has different [analyzer]\");\n             }\n-            throw new IllegalArgumentException(\"mapper [\" + fieldType().name() + \"] of different type, current_type [\" + contentType()\n-                + \"], merged_type [\" + mergedType + \"]\");\n+        } else if (other.indexAnalyzer() == null || \"default\".equals(other.indexAnalyzer().name())) {\n+            conflicts.add(\"mapper [\" + name() + \"] has different [analyzer]\");\n+        } else if (fieldType.indexAnalyzer().name().equals(other.indexAnalyzer().name()) == false) {\n+            conflicts.add(\"mapper [\" + name() + \"] has different [analyzer]\");\n+        }\n+\n+        if (Objects.equals(fieldType.similarity(), other.similarity()) == false) {\n+            conflicts.add(\"mapper [\" + name() + \"] has different [similarity]\");\n         }\n-        FieldMapper fieldMergeWith = (FieldMapper) mergeWith;\n-        multiFields = multiFields.merge(fieldMergeWith.multiFields);\n \n-        // apply changeable values\n-        this.fieldType = fieldMergeWith.fieldType;\n-        this.copyTo = fieldMergeWith.copyTo;\n+        mergeOptions(mergeWith, conflicts);\n+\n+        if (conflicts.isEmpty()) {\n+            multiFields = multiFields.merge(mergeWith.multiFields);\n+            // apply changeable values\n+            this.fieldType = mergeWith.fieldType;\n+            this.copyTo = mergeWith.copyTo;\n+        }\n     }\n \n+    /**\n+     * Merge type-specific options and check for incompatible settings in mappings to be merged\n+     */\n+    protected abstract void mergeOptions(FieldMapper other, List<String> conflicts);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee7c14a7d8ab018dcd96743d380e89d5154585ec"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MjEzNTIzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNjozOTowN1rOGXpFvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNzoyNTo0M1rOGXq4oA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0MzY0Nw==", "bodyText": "Small comment, calling mergeOptions directly from here could be nice:\nFieldMapper fieldMapper = (FieldMapper) mergeWith;\nmerged.mergeSharedOptions(fieldMapper, conflicts);\nmerged.mergeOptions(fieldMapper, conflicts);", "url": "https://github.com/elastic/elasticsearch/pull/56915#discussion_r427443647", "createdAt": "2020-05-19T16:39:07Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java", "diffHunk": "@@ -334,32 +334,88 @@ protected FieldMapper clone() {\n     }\n \n     @Override\n-    public FieldMapper merge(Mapper mergeWith) {\n+    public final FieldMapper merge(Mapper mergeWith) {\n         FieldMapper merged = clone();\n-        merged.doMerge(mergeWith);\n+        List<String> conflicts = new ArrayList<>();\n+        if (mergeWith instanceof FieldMapper == false) {\n+            throw new IllegalArgumentException(\"mapper [\" + fieldType.name() + \"] cannot be changed from type [\"\n+            + contentType() + \"] to [\" + mergeWith.getClass().getSimpleName() + \"]\");\n+        }\n+        merged.mergeSharedOptions((FieldMapper)mergeWith, conflicts);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee7c14a7d8ab018dcd96743d380e89d5154585ec"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3MzA1Ng==", "bodyText": "++, I've rearranged things here.", "url": "https://github.com/elastic/elasticsearch/pull/56915#discussion_r427473056", "createdAt": "2020-05-19T17:25:43Z", "author": {"login": "romseygeek"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java", "diffHunk": "@@ -334,32 +334,88 @@ protected FieldMapper clone() {\n     }\n \n     @Override\n-    public FieldMapper merge(Mapper mergeWith) {\n+    public final FieldMapper merge(Mapper mergeWith) {\n         FieldMapper merged = clone();\n-        merged.doMerge(mergeWith);\n+        List<String> conflicts = new ArrayList<>();\n+        if (mergeWith instanceof FieldMapper == false) {\n+            throw new IllegalArgumentException(\"mapper [\" + fieldType.name() + \"] cannot be changed from type [\"\n+            + contentType() + \"] to [\" + mergeWith.getClass().getSimpleName() + \"]\");\n+        }\n+        merged.mergeSharedOptions((FieldMapper)mergeWith, conflicts);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0MzY0Nw=="}, "originalCommit": {"oid": "ee7c14a7d8ab018dcd96743d380e89d5154585ec"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MjEzOTk3OnYy", "diffSide": "LEFT", "path": "modules/mapper-extras/src/test/java/org/elasticsearch/index/mapper/ScaledFloatFieldTypeTests.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNjo0MDoyMVrOGXpI3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNzoyMzoxMlrOGXqyfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0NDQ0Ng==", "bodyText": "I think we dropped this modifier accidentally.", "url": "https://github.com/elastic/elasticsearch/pull/56915#discussion_r427444446", "createdAt": "2020-05-19T16:40:21Z", "author": {"login": "jtibshirani"}, "path": "modules/mapper-extras/src/test/java/org/elasticsearch/index/mapper/ScaledFloatFieldTypeTests.java", "diffHunk": "@@ -51,22 +50,6 @@ protected MappedFieldType createDefaultFieldType() {\n         return ft;\n     }\n \n-    @Before\n-    public void setupProperties() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee7c14a7d8ab018dcd96743d380e89d5154585ec"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3MTQ4Ng==", "bodyText": "scaling_factor can't be updated, so we'd never be in a position when FieldTypeLookup would be comparing and old and new types with different scaling factors.", "url": "https://github.com/elastic/elasticsearch/pull/56915#discussion_r427471486", "createdAt": "2020-05-19T17:23:12Z", "author": {"login": "romseygeek"}, "path": "modules/mapper-extras/src/test/java/org/elasticsearch/index/mapper/ScaledFloatFieldTypeTests.java", "diffHunk": "@@ -51,22 +50,6 @@ protected MappedFieldType createDefaultFieldType() {\n         return ft;\n     }\n \n-    @Before\n-    public void setupProperties() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0NDQ0Ng=="}, "originalCommit": {"oid": "ee7c14a7d8ab018dcd96743d380e89d5154585ec"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MjE0NDk3OnYy", "diffSide": "LEFT", "path": "server/src/test/java/org/elasticsearch/index/mapper/CompletionFieldTypeTests.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNjo0MTo0MFrOGXpMLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNzoyNDo1M1rOGXq2bA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0NTI5Mw==", "bodyText": "Should this have been deleted?", "url": "https://github.com/elastic/elasticsearch/pull/56915#discussion_r427445293", "createdAt": "2020-05-19T16:41:40Z", "author": {"login": "jtibshirani"}, "path": "server/src/test/java/org/elasticsearch/index/mapper/CompletionFieldTypeTests.java", "diffHunk": "@@ -1,59 +0,0 @@\n-/*\n- * Licensed to Elasticsearch under one or more contributor\n- * license agreements. See the NOTICE file distributed with\n- * this work for additional information regarding copyright\n- * ownership. Elasticsearch licenses this file to you under\n- * the Apache License, Version 2.0 (the \"License\"); you may\n- * not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.elasticsearch.index.mapper;\n-\n-import org.elasticsearch.search.suggest.completion.context.ContextBuilder;\n-import org.elasticsearch.search.suggest.completion.context.ContextMappings;\n-import org.junit.Before;\n-\n-import java.util.Arrays;\n-\n-public class CompletionFieldTypeTests extends FieldTypeTestCase {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee7c14a7d8ab018dcd96743d380e89d5154585ec"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3MjQ5Mg==", "bodyText": "Again, none of these values can be updated in a merge, so we don't need an equality check.", "url": "https://github.com/elastic/elasticsearch/pull/56915#discussion_r427472492", "createdAt": "2020-05-19T17:24:53Z", "author": {"login": "romseygeek"}, "path": "server/src/test/java/org/elasticsearch/index/mapper/CompletionFieldTypeTests.java", "diffHunk": "@@ -1,59 +0,0 @@\n-/*\n- * Licensed to Elasticsearch under one or more contributor\n- * license agreements. See the NOTICE file distributed with\n- * this work for additional information regarding copyright\n- * ownership. Elasticsearch licenses this file to you under\n- * the Apache License, Version 2.0 (the \"License\"); you may\n- * not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.elasticsearch.index.mapper;\n-\n-import org.elasticsearch.search.suggest.completion.context.ContextBuilder;\n-import org.elasticsearch.search.suggest.completion.context.ContextMappings;\n-import org.junit.Before;\n-\n-import java.util.Arrays;\n-\n-public class CompletionFieldTypeTests extends FieldTypeTestCase {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0NTI5Mw=="}, "originalCommit": {"oid": "ee7c14a7d8ab018dcd96743d380e89d5154585ec"}, "originalPosition": 27}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 347, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}