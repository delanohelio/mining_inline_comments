{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMxNzU5Nzg3", "number": 57875, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMzo0Nzo1N1rOED40EQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMzo1MTowM1rOED48Ww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNTEyMDE3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/utils/persistence/SearchAfterDocumentsIterator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMzo0Nzo1N1rOGhKyfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMzo0Nzo1N1rOGhKyfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQzMjk1OQ==", "bodyText": "We only need total hits for the first query. Would be good to have this be false once we have the total hits recorded.", "url": "https://github.com/elastic/elasticsearch/pull/57875#discussion_r437432959", "createdAt": "2020-06-09T13:47:57Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/utils/persistence/SearchAfterDocumentsIterator.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ml.utils.persistence;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.client.OriginSettingClient;\n+import org.elasticsearch.index.query.QueryBuilder;\n+import org.elasticsearch.search.SearchHit;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.elasticsearch.search.sort.FieldSortBuilder;\n+import org.elasticsearch.xpack.ml.utils.MlIndicesUtils;\n+\n+import java.util.ArrayDeque;\n+import java.util.Deque;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+\n+/**\n+ * An iterator useful to fetch a large number of documents of type T\n+ * and iterate through them in batches of 10,000.\n+ *\n+ * In terms of functionality this is very similar to {@link BatchedDocumentsIterator}\n+ * the difference being that this uses search after rather than scroll.\n+ *\n+ * Search after has the advantage that the scroll context does not have to be kept\n+ * alive so if processing each batch takes a long time search after should be\n+ * preferred to scroll.\n+ */\n+public abstract class SearchAfterDocumentsIterator<T> implements BatchedIterator<T> {\n+\n+    private static final int BATCH_SIZE = 10_000;\n+\n+    private final OriginSettingClient client;\n+    private final String index;\n+    private volatile long count;\n+    private volatile long totalHits;\n+\n+    protected SearchAfterDocumentsIterator(OriginSettingClient client, String index) {\n+        this.client = Objects.requireNonNull(client);\n+        this.index = Objects.requireNonNull(index);\n+        this.totalHits = -1;\n+        this.count = 0;\n+    }\n+\n+    /**\n+     * Returns {@code true} if the iteration has more elements or\n+     * no searches have been been run and it is unknown if there is a next.\n+     *\n+     * @return {@code true} if the iteration has more elements or the first\n+     * search has not been run\n+     */\n+    @Override\n+    public boolean hasNext() {\n+        return count != totalHits;\n+    }\n+\n+    /**\n+     * The first time next() is called, the search will be performed and the first\n+     * batch will be returned. Any subsequent call will return the following batches.\n+     * <p>\n+     * Note that in some implementations it is possible that when there are no\n+     * results at all, the first time this method is called an empty {@code Deque} is returned.\n+     *\n+     * @return a {@code Deque} with the next batch of documents\n+     * @throws NoSuchElementException if the iteration has no more elements\n+     */\n+    @Override\n+    public Deque<T> next() {\n+        if (!hasNext()) {\n+            throw new NoSuchElementException();\n+        }\n+\n+        SearchResponse searchResponse;\n+        if (totalHits == -1) {\n+            searchResponse = initSearch();\n+        } else {\n+            searchResponse = doSearch(searchAfterFields());\n+        }\n+        return mapHits(searchResponse);\n+    }\n+\n+    private SearchResponse initSearch() {\n+        SearchResponse searchResponse = doSearch(null);\n+        totalHits = searchResponse.getHits().getTotalHits().value;\n+        return searchResponse;\n+    }\n+\n+    private SearchResponse doSearch(Object [] searchAfterValues) {\n+        SearchRequest searchRequest = new SearchRequest(index);\n+        searchRequest.indicesOptions(MlIndicesUtils.addIgnoreUnavailable(SearchRequest.DEFAULT_INDICES_OPTIONS));\n+        SearchSourceBuilder sourceBuilder = (new SearchSourceBuilder()\n+            .size(BATCH_SIZE)\n+            .query(getQuery())\n+            .fetchSource(shouldFetchSource())\n+            .trackTotalHits(true)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83313a84ef11c2d9becc25848d5ed669d090605c"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNTE0MTM5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/utils/persistence/SearchAfterDocumentsIterator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMzo1MTowM1rOGhK_ZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxOToyOToxN1rOGhZGaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQzNjI2MQ==", "bodyText": "Does search after protect us from new docs being added?\nIt seems to me that there is a possibility of count > totalHits if new documents are added + the index is refreshed.\nIt might be good to have this as count <= totalHits as adjust the initial values + initialization of values accordingly.", "url": "https://github.com/elastic/elasticsearch/pull/57875#discussion_r437436261", "createdAt": "2020-06-09T13:51:03Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/utils/persistence/SearchAfterDocumentsIterator.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ml.utils.persistence;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.client.OriginSettingClient;\n+import org.elasticsearch.index.query.QueryBuilder;\n+import org.elasticsearch.search.SearchHit;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.elasticsearch.search.sort.FieldSortBuilder;\n+import org.elasticsearch.xpack.ml.utils.MlIndicesUtils;\n+\n+import java.util.ArrayDeque;\n+import java.util.Deque;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+\n+/**\n+ * An iterator useful to fetch a large number of documents of type T\n+ * and iterate through them in batches of 10,000.\n+ *\n+ * In terms of functionality this is very similar to {@link BatchedDocumentsIterator}\n+ * the difference being that this uses search after rather than scroll.\n+ *\n+ * Search after has the advantage that the scroll context does not have to be kept\n+ * alive so if processing each batch takes a long time search after should be\n+ * preferred to scroll.\n+ */\n+public abstract class SearchAfterDocumentsIterator<T> implements BatchedIterator<T> {\n+\n+    private static final int BATCH_SIZE = 10_000;\n+\n+    private final OriginSettingClient client;\n+    private final String index;\n+    private volatile long count;\n+    private volatile long totalHits;\n+\n+    protected SearchAfterDocumentsIterator(OriginSettingClient client, String index) {\n+        this.client = Objects.requireNonNull(client);\n+        this.index = Objects.requireNonNull(index);\n+        this.totalHits = -1;\n+        this.count = 0;\n+    }\n+\n+    /**\n+     * Returns {@code true} if the iteration has more elements or\n+     * no searches have been been run and it is unknown if there is a next.\n+     *\n+     * @return {@code true} if the iteration has more elements or the first\n+     * search has not been run\n+     */\n+    @Override\n+    public boolean hasNext() {\n+        return count != totalHits;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83313a84ef11c2d9becc25848d5ed669d090605c"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY2NzQzMw==", "bodyText": "That is a very good point and with deletes count may never ==  totalHits.\nI changed the logic so that hasNext will return false only if the last search returned less than the requested number for hits e.g. I asked for 10 results but only got 8 back so there are no more search results and that is the end of the iteration.", "url": "https://github.com/elastic/elasticsearch/pull/57875#discussion_r437667433", "createdAt": "2020-06-09T19:29:17Z", "author": {"login": "davidkyle"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/utils/persistence/SearchAfterDocumentsIterator.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ml.utils.persistence;\n+\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.client.OriginSettingClient;\n+import org.elasticsearch.index.query.QueryBuilder;\n+import org.elasticsearch.search.SearchHit;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.elasticsearch.search.sort.FieldSortBuilder;\n+import org.elasticsearch.xpack.ml.utils.MlIndicesUtils;\n+\n+import java.util.ArrayDeque;\n+import java.util.Deque;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+\n+/**\n+ * An iterator useful to fetch a large number of documents of type T\n+ * and iterate through them in batches of 10,000.\n+ *\n+ * In terms of functionality this is very similar to {@link BatchedDocumentsIterator}\n+ * the difference being that this uses search after rather than scroll.\n+ *\n+ * Search after has the advantage that the scroll context does not have to be kept\n+ * alive so if processing each batch takes a long time search after should be\n+ * preferred to scroll.\n+ */\n+public abstract class SearchAfterDocumentsIterator<T> implements BatchedIterator<T> {\n+\n+    private static final int BATCH_SIZE = 10_000;\n+\n+    private final OriginSettingClient client;\n+    private final String index;\n+    private volatile long count;\n+    private volatile long totalHits;\n+\n+    protected SearchAfterDocumentsIterator(OriginSettingClient client, String index) {\n+        this.client = Objects.requireNonNull(client);\n+        this.index = Objects.requireNonNull(index);\n+        this.totalHits = -1;\n+        this.count = 0;\n+    }\n+\n+    /**\n+     * Returns {@code true} if the iteration has more elements or\n+     * no searches have been been run and it is unknown if there is a next.\n+     *\n+     * @return {@code true} if the iteration has more elements or the first\n+     * search has not been run\n+     */\n+    @Override\n+    public boolean hasNext() {\n+        return count != totalHits;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQzNjI2MQ=="}, "originalCommit": {"oid": "83313a84ef11c2d9becc25848d5ed669d090605c"}, "originalPosition": 59}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1733, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}