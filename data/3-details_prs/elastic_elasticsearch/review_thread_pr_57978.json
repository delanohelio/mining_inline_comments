{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMyOTgyNTgy", "number": 57978, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMTo0MDoyNFrOEEpZ-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMTo1MDo1NFrOEEplrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMzA4MTU1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/job/process/autodetect/state/CategorizerStats.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMTo0MDoyNFrOGiZhYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMTo0MDoyNFrOGiZhYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcyMjkxNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        &&Objects.equals(this.partitionFieldName, that.partitionFieldName)\n          \n          \n            \n                        && Objects.equals(this.partitionFieldName, that.partitionFieldName)\n          \n      \n    \n    \n  \n\n\"obsessive formatting disorder\" :D", "url": "https://github.com/elastic/elasticsearch/pull/57978#discussion_r438722914", "createdAt": "2020-06-11T11:40:24Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/job/process/autodetect/state/CategorizerStats.java", "diffHunk": "@@ -0,0 +1,359 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.ml.job.process.autodetect.state;\n+\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ObjectParser.ValueType;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.xpack.core.common.time.TimeUtils;\n+import org.elasticsearch.xpack.core.ml.job.config.Job;\n+import org.elasticsearch.xpack.core.ml.job.results.ReservedFieldNames;\n+import org.elasticsearch.xpack.core.ml.job.results.Result;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.Objects;\n+\n+public class CategorizerStats implements ToXContentObject, Writeable {\n+\n+    /**\n+     * Result type\n+     */\n+    public static final String RESULT_TYPE_VALUE = \"categorizer_stats\";\n+    public static final ParseField RESULT_TYPE_FIELD = new ParseField(RESULT_TYPE_VALUE);\n+\n+    /**\n+     * Field Names\n+     */\n+    public static final ParseField PARTITION_FIELD_NAME = new ParseField(\"partition_field_name\");\n+    public static final ParseField PARTITION_FIELD_VALUE = new ParseField(\"partition_field_value\");\n+    public static final ParseField CATEGORIZED_DOC_COUNT_FIELD = new ParseField(\"categorized_doc_count\");\n+    public static final ParseField TOTAL_CATEGORY_COUNT_FIELD = new ParseField(\"total_category_count\");\n+    public static final ParseField FREQUENT_CATEGORY_COUNT_FIELD = new ParseField(\"frequent_category_count\");\n+    public static final ParseField RARE_CATEGORY_COUNT_FIELD = new ParseField(\"rare_category_count\");\n+    public static final ParseField DEAD_CATEGORY_COUNT_FIELD = new ParseField(\"dead_category_count\");\n+    public static final ParseField FAILED_CATEGORY_COUNT_FIELD = new ParseField(\"failed_category_count\");\n+    public static final ParseField CATEGORIZATION_STATUS_FIELD = new ParseField(\"categorization_status\");\n+    public static final ParseField LOG_TIME_FIELD = new ParseField(\"log_time\");\n+    public static final ParseField TIMESTAMP_FIELD = new ParseField(\"timestamp\");\n+\n+    public static final ConstructingObjectParser<Builder, Void> STRICT_PARSER = createParser(false);\n+    public static final ConstructingObjectParser<Builder, Void> LENIENT_PARSER = createParser(true);\n+\n+    private static ConstructingObjectParser<Builder, Void> createParser(boolean ignoreUnknownFields) {\n+        ConstructingObjectParser<Builder, Void> parser = new ConstructingObjectParser<>(RESULT_TYPE_FIELD.getPreferredName(),\n+            ignoreUnknownFields, a -> new Builder((String) a[0]));\n+\n+        parser.declareString(ConstructingObjectParser.constructorArg(), Job.ID);\n+        parser.declareString((modelSizeStat, s) -> {}, Result.RESULT_TYPE);\n+        parser.declareString(Builder::setPartitionFieldName, PARTITION_FIELD_NAME);\n+        parser.declareString(Builder::setPartitionFieldValue, PARTITION_FIELD_VALUE);\n+        parser.declareLong(Builder::setCategorizedDocCount, CATEGORIZED_DOC_COUNT_FIELD);\n+        parser.declareLong(Builder::setTotalCategoryCount, TOTAL_CATEGORY_COUNT_FIELD);\n+        parser.declareLong(Builder::setFrequentCategoryCount, FREQUENT_CATEGORY_COUNT_FIELD);\n+        parser.declareLong(Builder::setRareCategoryCount, RARE_CATEGORY_COUNT_FIELD);\n+        parser.declareLong(Builder::setDeadCategoryCount, DEAD_CATEGORY_COUNT_FIELD);\n+        parser.declareLong(Builder::setFailedCategoryCount, FAILED_CATEGORY_COUNT_FIELD);\n+        parser.declareField(Builder::setCategorizationStatus,\n+            p -> CategorizationStatus.fromString(p.text()), CATEGORIZATION_STATUS_FIELD, ValueType.STRING);\n+        parser.declareField(Builder::setLogTime,\n+            p -> TimeUtils.parseTimeFieldToInstant(p, LOG_TIME_FIELD.getPreferredName()), LOG_TIME_FIELD, ValueType.VALUE);\n+        parser.declareField(Builder::setTimestamp,\n+            p -> TimeUtils.parseTimeFieldToInstant(p, TIMESTAMP_FIELD.getPreferredName()), TIMESTAMP_FIELD, ValueType.VALUE);\n+\n+        return parser;\n+    }\n+\n+    private final String jobId;\n+    private final String partitionFieldName;\n+    private final String partitionFieldValue;\n+    private final long categorizedDocCount;\n+    private final long totalCategoryCount;\n+    private final long frequentCategoryCount;\n+    private final long rareCategoryCount;\n+    private final long deadCategoryCount;\n+    private final long failedCategoryCount;\n+    private final CategorizationStatus categorizationStatus;\n+    private final Instant timestamp;\n+    private final Instant logTime;\n+\n+    private CategorizerStats(String jobId, @Nullable String partitionFieldName, @Nullable String partitionFieldValue,\n+                             long categorizedDocCount, long totalCategoryCount, long frequentCategoryCount, long rareCategoryCount,\n+                             long deadCategoryCount, long failedCategoryCount, CategorizationStatus categorizationStatus, Instant timestamp,\n+                             Instant logTime) {\n+        this.jobId = Objects.requireNonNull(jobId);\n+        this.partitionFieldName = partitionFieldName;\n+        this.partitionFieldValue = partitionFieldValue;\n+        this.categorizedDocCount = categorizedDocCount;\n+        this.totalCategoryCount = totalCategoryCount;\n+        this.frequentCategoryCount = frequentCategoryCount;\n+        this.rareCategoryCount = rareCategoryCount;\n+        this.deadCategoryCount = deadCategoryCount;\n+        this.failedCategoryCount = failedCategoryCount;\n+        this.categorizationStatus = Objects.requireNonNull(categorizationStatus);\n+        this.timestamp = Instant.ofEpochMilli(timestamp.toEpochMilli());\n+        this.logTime = Instant.ofEpochMilli(logTime.toEpochMilli());\n+    }\n+\n+    public CategorizerStats(StreamInput in) throws IOException {\n+        jobId = in.readString();\n+        partitionFieldName = in.readOptionalString();\n+        partitionFieldValue = in.readOptionalString();\n+        categorizedDocCount = in.readVLong();\n+        totalCategoryCount = in.readVLong();\n+        frequentCategoryCount = in.readVLong();\n+        rareCategoryCount = in.readVLong();\n+        deadCategoryCount = in.readVLong();\n+        failedCategoryCount = in.readVLong();\n+        categorizationStatus = CategorizationStatus.readFromStream(in);\n+        logTime = in.readInstant();\n+        timestamp = in.readInstant();\n+    }\n+\n+    public String getId() {\n+        return documentIdPrefix(jobId) + logTime.toEpochMilli();\n+    }\n+\n+    public static String documentIdPrefix(String jobId) {\n+        return jobId + \"_categorizer_stats_\";\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        out.writeString(jobId);\n+        out.writeOptionalString(partitionFieldName);\n+        out.writeOptionalString(partitionFieldValue);\n+        out.writeVLong(categorizedDocCount);\n+        out.writeVLong(totalCategoryCount);\n+        out.writeVLong(frequentCategoryCount);\n+        out.writeVLong(rareCategoryCount);\n+        out.writeVLong(deadCategoryCount);\n+        out.writeVLong(failedCategoryCount);\n+        categorizationStatus.writeTo(out);\n+        out.writeInstant(logTime);\n+        out.writeInstant(timestamp);\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject();\n+        builder.field(Job.ID.getPreferredName(), jobId);\n+        builder.field(Result.RESULT_TYPE.getPreferredName(), RESULT_TYPE_VALUE);\n+        if (partitionFieldName != null) {\n+            builder.field(PARTITION_FIELD_NAME.getPreferredName(), partitionFieldName);\n+            builder.field(PARTITION_FIELD_VALUE.getPreferredName(), partitionFieldValue);\n+            if (ReservedFieldNames.isValidFieldName(partitionFieldName)) {\n+                builder.field(partitionFieldName, partitionFieldValue);\n+            }\n+        }\n+        builder.field(CATEGORIZED_DOC_COUNT_FIELD.getPreferredName(), categorizedDocCount);\n+        builder.field(TOTAL_CATEGORY_COUNT_FIELD.getPreferredName(), totalCategoryCount);\n+        builder.field(FREQUENT_CATEGORY_COUNT_FIELD.getPreferredName(), frequentCategoryCount);\n+        builder.field(RARE_CATEGORY_COUNT_FIELD.getPreferredName(), rareCategoryCount);\n+        builder.field(DEAD_CATEGORY_COUNT_FIELD.getPreferredName(), deadCategoryCount);\n+        builder.field(FAILED_CATEGORY_COUNT_FIELD.getPreferredName(), failedCategoryCount);\n+        builder.field(CATEGORIZATION_STATUS_FIELD.getPreferredName(), categorizationStatus);\n+        builder.timeField(LOG_TIME_FIELD.getPreferredName(), LOG_TIME_FIELD.getPreferredName() + \"_string\", logTime.toEpochMilli());\n+        builder.timeField(TIMESTAMP_FIELD.getPreferredName(), TIMESTAMP_FIELD.getPreferredName() + \"_string\", timestamp.toEpochMilli());\n+        builder.endObject();\n+        return builder;\n+    }\n+\n+    public String getJobId() {\n+        return jobId;\n+    }\n+\n+    public String getPartitionFieldName() {\n+        return partitionFieldName;\n+    }\n+\n+    public String getPartitionFieldValue() {\n+        return partitionFieldValue;\n+    }\n+\n+    public long getCategorizedDocCount() {\n+        return categorizedDocCount;\n+    }\n+\n+    public long getTotalCategoryCount() {\n+        return totalCategoryCount;\n+    }\n+\n+    public long getFrequentCategoryCount() {\n+        return frequentCategoryCount;\n+    }\n+\n+    public long getRareCategoryCount() {\n+        return rareCategoryCount;\n+    }\n+\n+    public long getDeadCategoryCount() {\n+        return deadCategoryCount;\n+    }\n+\n+    public long getFailedCategoryCount() {\n+        return deadCategoryCount;\n+    }\n+\n+    public CategorizationStatus getCategorizationStatus() {\n+        return categorizationStatus;\n+    }\n+\n+    /**\n+     * The model timestamp when these stats were created.\n+     * @return The model time\n+     */\n+    public Instant getTimestamp() {\n+        return timestamp;\n+    }\n+\n+    /**\n+     * The wall clock time at the point when this instance was created.\n+     * @return The wall clock time\n+     */\n+    public Instant getLogTime() {\n+        return logTime;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(jobId, partitionFieldName, partitionFieldValue, categorizedDocCount, totalCategoryCount,\n+            frequentCategoryCount, rareCategoryCount, deadCategoryCount, failedCategoryCount, categorizationStatus, timestamp, logTime);\n+    }\n+\n+    /**\n+     * Compare all the fields.\n+     */\n+    @Override\n+    public boolean equals(Object other) {\n+        if (this == other) {\n+            return true;\n+        }\n+\n+        if (other instanceof CategorizerStats == false) {\n+            return false;\n+        }\n+\n+        CategorizerStats that = (CategorizerStats) other;\n+\n+        return Objects.equals(this.jobId, that.jobId)\n+            &&Objects.equals(this.partitionFieldName, that.partitionFieldName)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f216eb1f9140d1649dfc7c001238918389eb5f2"}, "originalPosition": 250}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMzA4NzQwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/job/process/autodetect/state/CategorizerStats.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMTo0MjozM1rOGiZlOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMjoxMDoyOVrOGiaYSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcyMzg5OQ==", "bodyText": "We don't check that all of these are > 0. This is probably OK since we are getting this data from C++ and there is an implicit trust.", "url": "https://github.com/elastic/elasticsearch/pull/57978#discussion_r438723899", "createdAt": "2020-06-11T11:42:33Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/job/process/autodetect/state/CategorizerStats.java", "diffHunk": "@@ -0,0 +1,359 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.ml.job.process.autodetect.state;\n+\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ObjectParser.ValueType;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.xpack.core.common.time.TimeUtils;\n+import org.elasticsearch.xpack.core.ml.job.config.Job;\n+import org.elasticsearch.xpack.core.ml.job.results.ReservedFieldNames;\n+import org.elasticsearch.xpack.core.ml.job.results.Result;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.Objects;\n+\n+public class CategorizerStats implements ToXContentObject, Writeable {\n+\n+    /**\n+     * Result type\n+     */\n+    public static final String RESULT_TYPE_VALUE = \"categorizer_stats\";\n+    public static final ParseField RESULT_TYPE_FIELD = new ParseField(RESULT_TYPE_VALUE);\n+\n+    /**\n+     * Field Names\n+     */\n+    public static final ParseField PARTITION_FIELD_NAME = new ParseField(\"partition_field_name\");\n+    public static final ParseField PARTITION_FIELD_VALUE = new ParseField(\"partition_field_value\");\n+    public static final ParseField CATEGORIZED_DOC_COUNT_FIELD = new ParseField(\"categorized_doc_count\");\n+    public static final ParseField TOTAL_CATEGORY_COUNT_FIELD = new ParseField(\"total_category_count\");\n+    public static final ParseField FREQUENT_CATEGORY_COUNT_FIELD = new ParseField(\"frequent_category_count\");\n+    public static final ParseField RARE_CATEGORY_COUNT_FIELD = new ParseField(\"rare_category_count\");\n+    public static final ParseField DEAD_CATEGORY_COUNT_FIELD = new ParseField(\"dead_category_count\");\n+    public static final ParseField FAILED_CATEGORY_COUNT_FIELD = new ParseField(\"failed_category_count\");\n+    public static final ParseField CATEGORIZATION_STATUS_FIELD = new ParseField(\"categorization_status\");\n+    public static final ParseField LOG_TIME_FIELD = new ParseField(\"log_time\");\n+    public static final ParseField TIMESTAMP_FIELD = new ParseField(\"timestamp\");\n+\n+    public static final ConstructingObjectParser<Builder, Void> STRICT_PARSER = createParser(false);\n+    public static final ConstructingObjectParser<Builder, Void> LENIENT_PARSER = createParser(true);\n+\n+    private static ConstructingObjectParser<Builder, Void> createParser(boolean ignoreUnknownFields) {\n+        ConstructingObjectParser<Builder, Void> parser = new ConstructingObjectParser<>(RESULT_TYPE_FIELD.getPreferredName(),\n+            ignoreUnknownFields, a -> new Builder((String) a[0]));\n+\n+        parser.declareString(ConstructingObjectParser.constructorArg(), Job.ID);\n+        parser.declareString((modelSizeStat, s) -> {}, Result.RESULT_TYPE);\n+        parser.declareString(Builder::setPartitionFieldName, PARTITION_FIELD_NAME);\n+        parser.declareString(Builder::setPartitionFieldValue, PARTITION_FIELD_VALUE);\n+        parser.declareLong(Builder::setCategorizedDocCount, CATEGORIZED_DOC_COUNT_FIELD);\n+        parser.declareLong(Builder::setTotalCategoryCount, TOTAL_CATEGORY_COUNT_FIELD);\n+        parser.declareLong(Builder::setFrequentCategoryCount, FREQUENT_CATEGORY_COUNT_FIELD);\n+        parser.declareLong(Builder::setRareCategoryCount, RARE_CATEGORY_COUNT_FIELD);\n+        parser.declareLong(Builder::setDeadCategoryCount, DEAD_CATEGORY_COUNT_FIELD);\n+        parser.declareLong(Builder::setFailedCategoryCount, FAILED_CATEGORY_COUNT_FIELD);\n+        parser.declareField(Builder::setCategorizationStatus,\n+            p -> CategorizationStatus.fromString(p.text()), CATEGORIZATION_STATUS_FIELD, ValueType.STRING);\n+        parser.declareField(Builder::setLogTime,\n+            p -> TimeUtils.parseTimeFieldToInstant(p, LOG_TIME_FIELD.getPreferredName()), LOG_TIME_FIELD, ValueType.VALUE);\n+        parser.declareField(Builder::setTimestamp,\n+            p -> TimeUtils.parseTimeFieldToInstant(p, TIMESTAMP_FIELD.getPreferredName()), TIMESTAMP_FIELD, ValueType.VALUE);\n+\n+        return parser;\n+    }\n+\n+    private final String jobId;\n+    private final String partitionFieldName;\n+    private final String partitionFieldValue;\n+    private final long categorizedDocCount;\n+    private final long totalCategoryCount;\n+    private final long frequentCategoryCount;\n+    private final long rareCategoryCount;\n+    private final long deadCategoryCount;\n+    private final long failedCategoryCount;\n+    private final CategorizationStatus categorizationStatus;\n+    private final Instant timestamp;\n+    private final Instant logTime;\n+\n+    private CategorizerStats(String jobId, @Nullable String partitionFieldName, @Nullable String partitionFieldValue,\n+                             long categorizedDocCount, long totalCategoryCount, long frequentCategoryCount, long rareCategoryCount,\n+                             long deadCategoryCount, long failedCategoryCount, CategorizationStatus categorizationStatus, Instant timestamp,\n+                             Instant logTime) {\n+        this.jobId = Objects.requireNonNull(jobId);\n+        this.partitionFieldName = partitionFieldName;\n+        this.partitionFieldValue = partitionFieldValue;\n+        this.categorizedDocCount = categorizedDocCount;\n+        this.totalCategoryCount = totalCategoryCount;\n+        this.frequentCategoryCount = frequentCategoryCount;\n+        this.rareCategoryCount = rareCategoryCount;\n+        this.deadCategoryCount = deadCategoryCount;\n+        this.failedCategoryCount = failedCategoryCount;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f216eb1f9140d1649dfc7c001238918389eb5f2"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODczNjk3MQ==", "bodyText": "Yes, good point.  This is dodgy when we're using VLong serialization.  It means someone can DoS us by updating a document to contain a negative number.\nThis same problem applies to most of our other results classes too, so I think it's best to deal with it in a separate PR.\nLike you say, the C++ won't send negative values for unsigned counters, so it's not a likely problem.", "url": "https://github.com/elastic/elasticsearch/pull/57978#discussion_r438736971", "createdAt": "2020-06-11T12:10:29Z", "author": {"login": "droberts195"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/job/process/autodetect/state/CategorizerStats.java", "diffHunk": "@@ -0,0 +1,359 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.ml.job.process.autodetect.state;\n+\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ObjectParser.ValueType;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.xpack.core.common.time.TimeUtils;\n+import org.elasticsearch.xpack.core.ml.job.config.Job;\n+import org.elasticsearch.xpack.core.ml.job.results.ReservedFieldNames;\n+import org.elasticsearch.xpack.core.ml.job.results.Result;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.Objects;\n+\n+public class CategorizerStats implements ToXContentObject, Writeable {\n+\n+    /**\n+     * Result type\n+     */\n+    public static final String RESULT_TYPE_VALUE = \"categorizer_stats\";\n+    public static final ParseField RESULT_TYPE_FIELD = new ParseField(RESULT_TYPE_VALUE);\n+\n+    /**\n+     * Field Names\n+     */\n+    public static final ParseField PARTITION_FIELD_NAME = new ParseField(\"partition_field_name\");\n+    public static final ParseField PARTITION_FIELD_VALUE = new ParseField(\"partition_field_value\");\n+    public static final ParseField CATEGORIZED_DOC_COUNT_FIELD = new ParseField(\"categorized_doc_count\");\n+    public static final ParseField TOTAL_CATEGORY_COUNT_FIELD = new ParseField(\"total_category_count\");\n+    public static final ParseField FREQUENT_CATEGORY_COUNT_FIELD = new ParseField(\"frequent_category_count\");\n+    public static final ParseField RARE_CATEGORY_COUNT_FIELD = new ParseField(\"rare_category_count\");\n+    public static final ParseField DEAD_CATEGORY_COUNT_FIELD = new ParseField(\"dead_category_count\");\n+    public static final ParseField FAILED_CATEGORY_COUNT_FIELD = new ParseField(\"failed_category_count\");\n+    public static final ParseField CATEGORIZATION_STATUS_FIELD = new ParseField(\"categorization_status\");\n+    public static final ParseField LOG_TIME_FIELD = new ParseField(\"log_time\");\n+    public static final ParseField TIMESTAMP_FIELD = new ParseField(\"timestamp\");\n+\n+    public static final ConstructingObjectParser<Builder, Void> STRICT_PARSER = createParser(false);\n+    public static final ConstructingObjectParser<Builder, Void> LENIENT_PARSER = createParser(true);\n+\n+    private static ConstructingObjectParser<Builder, Void> createParser(boolean ignoreUnknownFields) {\n+        ConstructingObjectParser<Builder, Void> parser = new ConstructingObjectParser<>(RESULT_TYPE_FIELD.getPreferredName(),\n+            ignoreUnknownFields, a -> new Builder((String) a[0]));\n+\n+        parser.declareString(ConstructingObjectParser.constructorArg(), Job.ID);\n+        parser.declareString((modelSizeStat, s) -> {}, Result.RESULT_TYPE);\n+        parser.declareString(Builder::setPartitionFieldName, PARTITION_FIELD_NAME);\n+        parser.declareString(Builder::setPartitionFieldValue, PARTITION_FIELD_VALUE);\n+        parser.declareLong(Builder::setCategorizedDocCount, CATEGORIZED_DOC_COUNT_FIELD);\n+        parser.declareLong(Builder::setTotalCategoryCount, TOTAL_CATEGORY_COUNT_FIELD);\n+        parser.declareLong(Builder::setFrequentCategoryCount, FREQUENT_CATEGORY_COUNT_FIELD);\n+        parser.declareLong(Builder::setRareCategoryCount, RARE_CATEGORY_COUNT_FIELD);\n+        parser.declareLong(Builder::setDeadCategoryCount, DEAD_CATEGORY_COUNT_FIELD);\n+        parser.declareLong(Builder::setFailedCategoryCount, FAILED_CATEGORY_COUNT_FIELD);\n+        parser.declareField(Builder::setCategorizationStatus,\n+            p -> CategorizationStatus.fromString(p.text()), CATEGORIZATION_STATUS_FIELD, ValueType.STRING);\n+        parser.declareField(Builder::setLogTime,\n+            p -> TimeUtils.parseTimeFieldToInstant(p, LOG_TIME_FIELD.getPreferredName()), LOG_TIME_FIELD, ValueType.VALUE);\n+        parser.declareField(Builder::setTimestamp,\n+            p -> TimeUtils.parseTimeFieldToInstant(p, TIMESTAMP_FIELD.getPreferredName()), TIMESTAMP_FIELD, ValueType.VALUE);\n+\n+        return parser;\n+    }\n+\n+    private final String jobId;\n+    private final String partitionFieldName;\n+    private final String partitionFieldValue;\n+    private final long categorizedDocCount;\n+    private final long totalCategoryCount;\n+    private final long frequentCategoryCount;\n+    private final long rareCategoryCount;\n+    private final long deadCategoryCount;\n+    private final long failedCategoryCount;\n+    private final CategorizationStatus categorizationStatus;\n+    private final Instant timestamp;\n+    private final Instant logTime;\n+\n+    private CategorizerStats(String jobId, @Nullable String partitionFieldName, @Nullable String partitionFieldValue,\n+                             long categorizedDocCount, long totalCategoryCount, long frequentCategoryCount, long rareCategoryCount,\n+                             long deadCategoryCount, long failedCategoryCount, CategorizationStatus categorizationStatus, Instant timestamp,\n+                             Instant logTime) {\n+        this.jobId = Objects.requireNonNull(jobId);\n+        this.partitionFieldName = partitionFieldName;\n+        this.partitionFieldValue = partitionFieldValue;\n+        this.categorizedDocCount = categorizedDocCount;\n+        this.totalCategoryCount = totalCategoryCount;\n+        this.frequentCategoryCount = frequentCategoryCount;\n+        this.rareCategoryCount = rareCategoryCount;\n+        this.deadCategoryCount = deadCategoryCount;\n+        this.failedCategoryCount = failedCategoryCount;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcyMzg5OQ=="}, "originalCommit": {"oid": "6f216eb1f9140d1649dfc7c001238918389eb5f2"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMzEwMzE2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/job/results/AutodetectResult.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMTo0Nzo1NVrOGiZu_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMTo0Nzo1NVrOGiZu_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcyNjM5OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (in.getVersion().onOrAfter(Version.V_8_0_0) && in.readBoolean()) {\n          \n          \n            \n                        this.categorizerStats = new CategorizerStats(in);\n          \n          \n            \n                    if (in.getVersion().onOrAfter(Version.V_8_0_0)) {\n          \n          \n            \n                        this.categorizerStats = in.readOptionalWriteable(CategorizerStats::new);", "url": "https://github.com/elastic/elasticsearch/pull/57978#discussion_r438726398", "createdAt": "2020-06-11T11:47:55Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/job/results/AutodetectResult.java", "diffHunk": "@@ -136,12 +143,16 @@ public AutodetectResult(StreamInput in) throws IOException {\n         } else {\n             this.categoryDefinition = null;\n         }\n+        if (in.getVersion().onOrAfter(Version.V_8_0_0) && in.readBoolean()) {\n+            this.categorizerStats = new CategorizerStats(in);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f216eb1f9140d1649dfc7c001238918389eb5f2"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMzExMTUwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/job/results/AutodetectResult.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMTo1MDo1NFrOGiZ0TA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMTo1MDo1NFrOGiZ0TA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcyNzc1Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        writeNullable(categorizerStats, out);\n          \n          \n            \n                        out.writeOptionalWriteable(categorizerStats);\n          \n      \n    \n    \n  \n\nI wonder if this writeNullable method could just be removed? The down side is that there is no StreamOutput#writeOptionalList. Maybe there should be?", "url": "https://github.com/elastic/elasticsearch/pull/57978#discussion_r438727756", "createdAt": "2020-06-11T11:50:54Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/job/results/AutodetectResult.java", "diffHunk": "@@ -165,6 +176,9 @@ public void writeTo(StreamOutput out) throws IOException {\n         writeNullable(modelPlot, out);\n         writeNullable(annotation, out);\n         writeNullable(categoryDefinition, out);\n+        if (out.getVersion().onOrAfter(Version.V_8_0_0)) {\n+            writeNullable(categorizerStats, out);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f216eb1f9140d1649dfc7c001238918389eb5f2"}, "originalPosition": 83}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1707, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}