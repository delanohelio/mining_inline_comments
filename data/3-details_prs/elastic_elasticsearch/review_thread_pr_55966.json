{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEwOTEwMDMy", "number": 55966, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQwODowODo0N1rOD37_PQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQwNDowNzowMVrOD4SCXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5OTgxMTE3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/SpatialPlugin.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQwODowODo0N1rOGOeZNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNDo0MTozNVrOGOsgPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzgzMTIyMw==", "bodyText": "Should be SPATIAL_GEO_GRID?", "url": "https://github.com/elastic/elasticsearch/pull/55966#discussion_r417831223", "createdAt": "2020-04-30T08:08:47Z", "author": {"login": "iverase"}, "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/SpatialPlugin.java", "diffHunk": "@@ -110,13 +122,49 @@ public void registerGeoShapeCentroidAggregator(ValuesSourceRegistry.Builder buil\n             });\n     }\n \n-    public static void registerValueCountAggregator(ValuesSourceRegistry.Builder builder) {\n+    public void registerGeoShapeGridAggregators(ValuesSourceRegistry.Builder builder) {\n+        builder.register(GeoHashGridAggregationBuilder.NAME, GeoShapeValuesSourceType.instance(),\n+            (GeoGridAggregatorSupplier) (name, factories, valuesSource, precision, geoBoundingBox, requiredSize, shardSize,\n+                                         aggregationContext, parent, metadata) -> {\n+                if (getLicenseState().isAllowed(XPackLicenseState.Feature.SPATIAL_GEO_CENTROID)) {\n+                    final GeoGridTiler tiler;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2d9ed0c68d2e943c1ad6ff7984c4d48c2571b3f"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA2MjM5OQ==", "bodyText": "yes! good catch. I was also missing unit tests for this in SpatialPluginTests. added and fixed!", "url": "https://github.com/elastic/elasticsearch/pull/55966#discussion_r418062399", "createdAt": "2020-04-30T14:41:35Z", "author": {"login": "talevy"}, "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/SpatialPlugin.java", "diffHunk": "@@ -110,13 +122,49 @@ public void registerGeoShapeCentroidAggregator(ValuesSourceRegistry.Builder buil\n             });\n     }\n \n-    public static void registerValueCountAggregator(ValuesSourceRegistry.Builder builder) {\n+    public void registerGeoShapeGridAggregators(ValuesSourceRegistry.Builder builder) {\n+        builder.register(GeoHashGridAggregationBuilder.NAME, GeoShapeValuesSourceType.instance(),\n+            (GeoGridAggregatorSupplier) (name, factories, valuesSource, precision, geoBoundingBox, requiredSize, shardSize,\n+                                         aggregationContext, parent, metadata) -> {\n+                if (getLicenseState().isAllowed(XPackLicenseState.Feature.SPATIAL_GEO_CENTROID)) {\n+                    final GeoGridTiler tiler;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzgzMTIyMw=="}, "originalCommit": {"oid": "b2d9ed0c68d2e943c1ad6ff7984c4d48c2571b3f"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMTI3Nzg1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/SpatialPlugin.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNDo0ODoyOVrOGOs04g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNTowOToxNVrOGOtwOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA2NzY4Mg==", "bodyText": "Why other registers are static except this one? needs to be public?", "url": "https://github.com/elastic/elasticsearch/pull/55966#discussion_r418067682", "createdAt": "2020-04-30T14:48:29Z", "author": {"login": "iverase"}, "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/SpatialPlugin.java", "diffHunk": "@@ -110,13 +122,49 @@ public void registerGeoShapeCentroidAggregator(ValuesSourceRegistry.Builder buil\n             });\n     }\n \n-    public static void registerValueCountAggregator(ValuesSourceRegistry.Builder builder) {\n+    public void registerGeoShapeGridAggregators(ValuesSourceRegistry.Builder builder) {\n+        builder.register(GeoHashGridAggregationBuilder.NAME, GeoShapeValuesSourceType.instance(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59c8bcf27d9d750d397bbc120f5f4db326bfc940"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA3MTcyNg==", "bodyText": "I made them all private. good catch.\nThe ones with license checks cannot be static because they need to call getLicenseState()", "url": "https://github.com/elastic/elasticsearch/pull/55966#discussion_r418071726", "createdAt": "2020-04-30T14:54:05Z", "author": {"login": "talevy"}, "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/SpatialPlugin.java", "diffHunk": "@@ -110,13 +122,49 @@ public void registerGeoShapeCentroidAggregator(ValuesSourceRegistry.Builder buil\n             });\n     }\n \n-    public static void registerValueCountAggregator(ValuesSourceRegistry.Builder builder) {\n+    public void registerGeoShapeGridAggregators(ValuesSourceRegistry.Builder builder) {\n+        builder.register(GeoHashGridAggregationBuilder.NAME, GeoShapeValuesSourceType.instance(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA2NzY4Mg=="}, "originalCommit": {"oid": "59c8bcf27d9d750d397bbc120f5f4db326bfc940"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA4Mjg3Mg==", "bodyText": "Thanks for the explanation.", "url": "https://github.com/elastic/elasticsearch/pull/55966#discussion_r418082872", "createdAt": "2020-04-30T15:09:15Z", "author": {"login": "iverase"}, "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/SpatialPlugin.java", "diffHunk": "@@ -110,13 +122,49 @@ public void registerGeoShapeCentroidAggregator(ValuesSourceRegistry.Builder buil\n             });\n     }\n \n-    public static void registerValueCountAggregator(ValuesSourceRegistry.Builder builder) {\n+    public void registerGeoShapeGridAggregators(ValuesSourceRegistry.Builder builder) {\n+        builder.register(GeoHashGridAggregationBuilder.NAME, GeoShapeValuesSourceType.instance(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA2NzY4Mg=="}, "originalCommit": {"oid": "59c8bcf27d9d750d397bbc120f5f4db326bfc940"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMzQyMzY3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/SpatialPlugin.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQwNDowNzowMVrOGPBleA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNTo0MDo1M1rOGQGKHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQwNzgwMA==", "bodyText": "I think I figured out the circuit-breaking logic!\nthis is my least favorite part. a hack to give GeoShapeCellIdSource access to AggregatorBase's circuit-breaker logic, which must be created before the aggregator is created.", "url": "https://github.com/elastic/elasticsearch/pull/55966#discussion_r418407800", "createdAt": "2020-05-01T04:07:01Z", "author": {"login": "talevy"}, "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/SpatialPlugin.java", "diffHunk": "@@ -110,13 +122,53 @@ public void registerGeoShapeCentroidAggregator(ValuesSourceRegistry.Builder buil\n             });\n     }\n \n-    public static void registerValueCountAggregator(ValuesSourceRegistry.Builder builder) {\n+    private void registerGeoShapeGridAggregators(ValuesSourceRegistry.Builder builder) {\n+        builder.register(GeoHashGridAggregationBuilder.NAME, GeoShapeValuesSourceType.instance(),\n+            (GeoGridAggregatorSupplier) (name, factories, valuesSource, precision, geoBoundingBox, requiredSize, shardSize,\n+                                         aggregationContext, parent, metadata) -> {\n+                if (getLicenseState().isAllowed(XPackLicenseState.Feature.SPATIAL_GEO_GRID)) {\n+                    final GeoGridTiler tiler;\n+                    if (geoBoundingBox.isUnbounded()) {\n+                        tiler = new GeoHashGridTiler();\n+                    } else {\n+                        tiler = new BoundedGeoHashGridTiler(geoBoundingBox);\n+                    }\n+                    GeoShapeCellIdSource cellIdSource = new GeoShapeCellIdSource((GeoShapeValuesSource) valuesSource, precision, tiler);\n+                    GeoShapeHashGridAggregator agg = new GeoShapeHashGridAggregator(name, factories, cellIdSource, requiredSize, shardSize,\n+                        aggregationContext, parent, metadata);\n+                    cellIdSource.setCircuitBreakerConsumer(agg::addRequestBytes);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0feb6026abf9ea78cdadc2c1ed1d5d3d32845b0"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTUxNDU0NQ==", "bodyText": "I cannot think in another way to achieve this at the moment. Do you see any issue down the line with this approach. Maybe add a TODO so we do not forget we should find a better solution?\nI wonder if in the long term we need a family of value source that knows about the circuit breaker.", "url": "https://github.com/elastic/elasticsearch/pull/55966#discussion_r419514545", "createdAt": "2020-05-04T15:17:27Z", "author": {"login": "iverase"}, "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/SpatialPlugin.java", "diffHunk": "@@ -110,13 +122,53 @@ public void registerGeoShapeCentroidAggregator(ValuesSourceRegistry.Builder buil\n             });\n     }\n \n-    public static void registerValueCountAggregator(ValuesSourceRegistry.Builder builder) {\n+    private void registerGeoShapeGridAggregators(ValuesSourceRegistry.Builder builder) {\n+        builder.register(GeoHashGridAggregationBuilder.NAME, GeoShapeValuesSourceType.instance(),\n+            (GeoGridAggregatorSupplier) (name, factories, valuesSource, precision, geoBoundingBox, requiredSize, shardSize,\n+                                         aggregationContext, parent, metadata) -> {\n+                if (getLicenseState().isAllowed(XPackLicenseState.Feature.SPATIAL_GEO_GRID)) {\n+                    final GeoGridTiler tiler;\n+                    if (geoBoundingBox.isUnbounded()) {\n+                        tiler = new GeoHashGridTiler();\n+                    } else {\n+                        tiler = new BoundedGeoHashGridTiler(geoBoundingBox);\n+                    }\n+                    GeoShapeCellIdSource cellIdSource = new GeoShapeCellIdSource((GeoShapeValuesSource) valuesSource, precision, tiler);\n+                    GeoShapeHashGridAggregator agg = new GeoShapeHashGridAggregator(name, factories, cellIdSource, requiredSize, shardSize,\n+                        aggregationContext, parent, metadata);\n+                    cellIdSource.setCircuitBreakerConsumer(agg::addRequestBytes);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQwNzgwMA=="}, "originalCommit": {"oid": "d0feb6026abf9ea78cdadc2c1ed1d5d3d32845b0"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTUzMTI5NQ==", "bodyText": "Do you see any issue down the line with this approach\n\nI do not see a way around this in the short-term. I think it would require more changes to more inherited methods to properly pass along this information from the aggregator to the circuit-breaker via the ValuesSource.\n\nI wonder if in the long term we need a family of value source that knows about the circuit breaker.\n\nthis was the approach taken in #50720. I realize the problem there is that the Aggregator has its own utility method for keeping track of bytes and then subtracting from the circuit-breaker upon closing. I had some bugs with separating the concerns and so I updated it to leverage the Aggregator's wrapper around circuit-breaking logic.\nI will add a comment in the code for sure", "url": "https://github.com/elastic/elasticsearch/pull/55966#discussion_r419531295", "createdAt": "2020-05-04T15:40:53Z", "author": {"login": "talevy"}, "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/SpatialPlugin.java", "diffHunk": "@@ -110,13 +122,53 @@ public void registerGeoShapeCentroidAggregator(ValuesSourceRegistry.Builder buil\n             });\n     }\n \n-    public static void registerValueCountAggregator(ValuesSourceRegistry.Builder builder) {\n+    private void registerGeoShapeGridAggregators(ValuesSourceRegistry.Builder builder) {\n+        builder.register(GeoHashGridAggregationBuilder.NAME, GeoShapeValuesSourceType.instance(),\n+            (GeoGridAggregatorSupplier) (name, factories, valuesSource, precision, geoBoundingBox, requiredSize, shardSize,\n+                                         aggregationContext, parent, metadata) -> {\n+                if (getLicenseState().isAllowed(XPackLicenseState.Feature.SPATIAL_GEO_GRID)) {\n+                    final GeoGridTiler tiler;\n+                    if (geoBoundingBox.isUnbounded()) {\n+                        tiler = new GeoHashGridTiler();\n+                    } else {\n+                        tiler = new BoundedGeoHashGridTiler(geoBoundingBox);\n+                    }\n+                    GeoShapeCellIdSource cellIdSource = new GeoShapeCellIdSource((GeoShapeValuesSource) valuesSource, precision, tiler);\n+                    GeoShapeHashGridAggregator agg = new GeoShapeHashGridAggregator(name, factories, cellIdSource, requiredSize, shardSize,\n+                        aggregationContext, parent, metadata);\n+                    cellIdSource.setCircuitBreakerConsumer(agg::addRequestBytes);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQwNzgwMA=="}, "originalCommit": {"oid": "d0feb6026abf9ea78cdadc2c1ed1d5d3d32845b0"}, "originalPosition": 79}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2548, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}