{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY5OTMxODQz", "number": 61309, "title": "Correct how field retrieval handles multifields and copy_to.", "bodyText": "Before when a value was copied to a field through a parent field or copy_to,\nwe parsed it using the FieldMapper from the source field. Instead we should\nparse it using the target FieldMapper. This ensures that we apply the\nappropriate mapping type and options to the copied value.\nTo implement the fix cleanly, this PR refactors the value parsing strategy. Now\ninstead of looking up values directly, field mappers produce a helper object\nValueFetcher. The value fetchers are responsible for almost all aspects of\nfetching, including looking up the right paths in the _source.\nThe PR is fairly big but each commit can be reviewed individually.\nFixes #61033.", "createdAt": "2020-08-19T05:34:54Z", "url": "https://github.com/elastic/elasticsearch/pull/61309", "merged": true, "mergeCommit": {"oid": "5457b34343838f11081c8c34234d79fcb6d1cecd"}, "closed": true, "closedAt": "2020-08-19T23:50:27Z", "author": {"login": "jtibshirani"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdAU-WDAFqTQ3MDEzOTgyNQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdAjNJEAH2gAyNDY5OTMxODQzOmYzNTM1NjdjMTk1YzZiMTgxYmJkNTAwM2U1MzU5YWQzZTVkNDY2NDk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcwMTM5ODI1", "url": "https://github.com/elastic/elasticsearch/pull/61309#pullrequestreview-470139825", "createdAt": "2020-08-19T05:43:25Z", "commit": {"oid": "a2b316435b89ba2cb07f74a13da2eff323db8a2e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwNTo0MzoyNlrOHC0ymg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwNTo0MzoyNlrOHC0ymg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjcyNDEyMg==", "bodyText": "This is an unfortunate workaround. I think we should consider moving value fetching support from FieldMapper to MappedFieldType in a follow-up. That would clean this up, because when looking up a field's MappedFieldType we will already resolve aliases to their targets (and can avoid doing it manually here).", "url": "https://github.com/elastic/elasticsearch/pull/61309#discussion_r472724122", "createdAt": "2020-08-19T05:43:26Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/search/fetch/subphase/FieldValueRetriever.java", "diffHunk": "@@ -38,34 +40,40 @@\n  * Then given a specific document, it can retrieve the corresponding fields from the document's source.\n  */\n public class FieldValueRetriever {\n-    private final MappingLookup fieldMappers;\n     private final List<FieldContext> fieldContexts;\n \n     public static FieldValueRetriever create(MapperService mapperService,\n                                              Collection<FieldAndFormat> fieldAndFormats) {\n         MappingLookup fieldMappers = mapperService.documentMapper().mappers();\n-        List<FieldContext> fields = new ArrayList<>();\n+        List<FieldContext> fieldContexts = new ArrayList<>();\n \n         for (FieldAndFormat fieldAndFormat : fieldAndFormats) {\n             String fieldPattern = fieldAndFormat.field;\n             String format = fieldAndFormat.format;\n \n             Collection<String> concreteFields = mapperService.simpleMatchToFullName(fieldPattern);\n             for (String field : concreteFields) {\n-                if (fieldMappers.getMapper(field) != null && mapperService.isMetadataField(field) == false) {\n-                    Set<String> sourcePath = mapperService.sourcePath(field);\n-                    fields.add(new FieldContext(field, sourcePath, format));\n+                Mapper mapper = fieldMappers.getMapper(field);\n+                if (mapper == null || mapperService.isMetadataField(field)) {\n+                    continue;\n+                }\n+\n+                if (mapper instanceof FieldAliasMapper) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2b316435b89ba2cb07f74a13da2eff323db8a2e"}, "originalPosition": 43}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a2b316435b89ba2cb07f74a13da2eff323db8a2e", "author": {"user": {"login": "jtibshirani", "name": "Julie Tibshirani"}}, "url": "https://github.com/elastic/elasticsearch/commit/a2b316435b89ba2cb07f74a13da2eff323db8a2e", "committedDate": "2020-08-19T05:12:36Z", "message": "Remove FieldMapper#nullValue()."}, "afterCommit": {"oid": "b8a70be2fc3e3ad610fbe3f1f5ff28632f2307f2", "author": {"user": {"login": "jtibshirani", "name": "Julie Tibshirani"}}, "url": "https://github.com/elastic/elasticsearch/commit/b8a70be2fc3e3ad610fbe3f1f5ff28632f2307f2", "committedDate": "2020-08-19T16:57:08Z", "message": "Remove FieldMapper#nullValue()."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "81b9db24ce2054b9409913b591c1455055819ff4", "author": {"user": {"login": "jtibshirani", "name": "Julie Tibshirani"}}, "url": "https://github.com/elastic/elasticsearch/commit/81b9db24ce2054b9409913b591c1455055819ff4", "committedDate": "2020-08-19T17:04:43Z", "message": "Fix multifield and copy_to cases in FieldValueRetrieverTests.\n\nBefore these cases asserted the wrong result. Now they capture the right\nbehavior, but currently fail."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b8a70be2fc3e3ad610fbe3f1f5ff28632f2307f2", "author": {"user": {"login": "jtibshirani", "name": "Julie Tibshirani"}}, "url": "https://github.com/elastic/elasticsearch/commit/b8a70be2fc3e3ad610fbe3f1f5ff28632f2307f2", "committedDate": "2020-08-19T16:57:08Z", "message": "Remove FieldMapper#nullValue()."}, "afterCommit": {"oid": "aa87bde384da4352d9c063d17beeec7cc12b37ad", "author": {"user": {"login": "jtibshirani", "name": "Julie Tibshirani"}}, "url": "https://github.com/elastic/elasticsearch/commit/aa87bde384da4352d9c063d17beeec7cc12b37ad", "committedDate": "2020-08-19T17:34:32Z", "message": "Remove FieldMapper#nullValue()."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fc34f4a2dc5feedfe299936d634ebc416c0bf8db", "author": {"user": {"login": "jtibshirani", "name": "Julie Tibshirani"}}, "url": "https://github.com/elastic/elasticsearch/commit/fc34f4a2dc5feedfe299936d634ebc416c0bf8db", "committedDate": "2020-08-19T19:01:21Z", "message": "Refactor FieldMapper#lookupValues to return a ValueFetcher object.\n\nThis will help to implement the fix in a clean way."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9717621f427524d0b42df1246835ed9e9efe9435", "author": {"user": {"login": "jtibshirani", "name": "Julie Tibshirani"}}, "url": "https://github.com/elastic/elasticsearch/commit/9717621f427524d0b42df1246835ed9e9efe9435", "committedDate": "2020-08-19T19:01:23Z", "message": "Correctly handle values from multifields and copy_to.\n\nBefore when a value was copied to a field through a parent field or copy_to, we\nparsed it using the FieldMapper from the source field. Instead we should parse\nit using the target FieldMapper.\n\nThis fix works but is a bit messy. The next commit will clean up the approach."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aacd3907020ef8d26eeeee9a071c014c35ba689f", "author": {"user": {"login": "jtibshirani", "name": "Julie Tibshirani"}}, "url": "https://github.com/elastic/elasticsearch/commit/aacd3907020ef8d26eeeee9a071c014c35ba689f", "committedDate": "2020-08-19T19:01:26Z", "message": "Move source path lookup to SourceValueFetcher.\n\nNow SourceValueFetcher owns all aspects of looking up values from _source,\ninstead of requiring some information to be passed in externally."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "aa87bde384da4352d9c063d17beeec7cc12b37ad", "author": {"user": {"login": "jtibshirani", "name": "Julie Tibshirani"}}, "url": "https://github.com/elastic/elasticsearch/commit/aa87bde384da4352d9c063d17beeec7cc12b37ad", "committedDate": "2020-08-19T17:34:32Z", "message": "Remove FieldMapper#nullValue()."}, "afterCommit": {"oid": "49c2c759bf22223058c4676729933cdad9b94b14", "author": {"user": {"login": "jtibshirani", "name": "Julie Tibshirani"}}, "url": "https://github.com/elastic/elasticsearch/commit/49c2c759bf22223058c4676729933cdad9b94b14", "committedDate": "2020-08-19T19:01:28Z", "message": "Remove FieldMapper#nullValue()."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa66569505c10d90f8a794c84f708c874730a3fa", "author": {"user": {"login": "jtibshirani", "name": "Julie Tibshirani"}}, "url": "https://github.com/elastic/elasticsearch/commit/fa66569505c10d90f8a794c84f708c874730a3fa", "committedDate": "2020-08-19T19:06:16Z", "message": "Remove FieldMapper#nullValue().\n\nThis is no longer needed after the refactor to use ValueFetcher."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "49c2c759bf22223058c4676729933cdad9b94b14", "author": {"user": {"login": "jtibshirani", "name": "Julie Tibshirani"}}, "url": "https://github.com/elastic/elasticsearch/commit/49c2c759bf22223058c4676729933cdad9b94b14", "committedDate": "2020-08-19T19:01:28Z", "message": "Remove FieldMapper#nullValue()."}, "afterCommit": {"oid": "fa66569505c10d90f8a794c84f708c874730a3fa", "author": {"user": {"login": "jtibshirani", "name": "Julie Tibshirani"}}, "url": "https://github.com/elastic/elasticsearch/commit/fa66569505c10d90f8a794c84f708c874730a3fa", "committedDate": "2020-08-19T19:06:16Z", "message": "Remove FieldMapper#nullValue().\n\nThis is no longer needed after the refactor to use ValueFetcher."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcwNzc0ODk5", "url": "https://github.com/elastic/elasticsearch/pull/61309#pullrequestreview-470774899", "createdAt": "2020-08-19T19:33:37Z", "commit": {"oid": "fa66569505c10d90f8a794c84f708c874730a3fa"}, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxOTozMzozOFrOHDWMaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxOTo0MjoxM1rOHDWdDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzI3MTQwMA==", "bodyText": "I think it'd be cleaner if this were handled by a differently named subclass. I know we have the boolean in the mapper, but it just feels funny to pass a boolean swapping out the guts of the implementation.", "url": "https://github.com/elastic/elasticsearch/pull/61309#discussion_r473271400", "createdAt": "2020-08-19T19:33:38Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/SourceValueFetcher.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.search.lookup.SourceLookup;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.Set;\n+\n+/**\n+ * An implementation of {@link ValueFetcher} that knows how to extract values\n+ * from the document source. Most standard field mappers will use this class\n+ * to implement value fetching.\n+ */\n+public abstract class SourceValueFetcher implements ValueFetcher {\n+    private final Set<String> sourcePaths;\n+    private final @Nullable Object nullValue;\n+    private final boolean parsesArrayValue;\n+\n+    public SourceValueFetcher(String fieldName, MapperService mapperService, boolean parsesArrayValue) {\n+        this(fieldName, mapperService, parsesArrayValue, null);\n+    }\n+\n+    /**\n+     * @param fieldName The name of the field.\n+     * @param parsesArrayValue Whether the fetcher handles array values during document parsing.\n+     * @param nullValue A optional substitute value if the _source value is 'null'.\n+     */\n+    public SourceValueFetcher(String fieldName, MapperService mapperService, boolean parsesArrayValue, Object nullValue) {\n+        this.sourcePaths = mapperService.sourcePath(fieldName);\n+        this.nullValue = nullValue;\n+        this.parsesArrayValue = parsesArrayValue;\n+    }\n+\n+    @Override\n+    public List<Object> fetchValues(SourceLookup lookup) {\n+        List<Object> values = new ArrayList<>();\n+        for (String path : sourcePaths) {\n+            Object sourceValue = lookup.extractValue(path, nullValue);\n+            if (sourceValue == null) {\n+                return List.of();\n+            }\n+\n+            if (parsesArrayValue) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa66569505c10d90f8a794c84f708c874730a3fa"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzI3MTc4MQ==", "bodyText": "I don't really think this is cleaner than passing the CheckedFunction but if you like it better that is cool with me.", "url": "https://github.com/elastic/elasticsearch/pull/61309#discussion_r473271781", "createdAt": "2020-08-19T19:34:21Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/SourceValueFetcher.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.search.lookup.SourceLookup;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.Set;\n+\n+/**\n+ * An implementation of {@link ValueFetcher} that knows how to extract values\n+ * from the document source. Most standard field mappers will use this class\n+ * to implement value fetching.\n+ */\n+public abstract class SourceValueFetcher implements ValueFetcher {\n+    private final Set<String> sourcePaths;\n+    private final @Nullable Object nullValue;\n+    private final boolean parsesArrayValue;\n+\n+    public SourceValueFetcher(String fieldName, MapperService mapperService, boolean parsesArrayValue) {\n+        this(fieldName, mapperService, parsesArrayValue, null);\n+    }\n+\n+    /**\n+     * @param fieldName The name of the field.\n+     * @param parsesArrayValue Whether the fetcher handles array values during document parsing.\n+     * @param nullValue A optional substitute value if the _source value is 'null'.\n+     */\n+    public SourceValueFetcher(String fieldName, MapperService mapperService, boolean parsesArrayValue, Object nullValue) {\n+        this.sourcePaths = mapperService.sourcePath(fieldName);\n+        this.nullValue = nullValue;\n+        this.parsesArrayValue = parsesArrayValue;\n+    }\n+\n+    @Override\n+    public List<Object> fetchValues(SourceLookup lookup) {\n+        List<Object> values = new ArrayList<>();\n+        for (String path : sourcePaths) {\n+            Object sourceValue = lookup.extractValue(path, nullValue);\n+            if (sourceValue == null) {\n+                return List.of();\n+            }\n+\n+            if (parsesArrayValue) {\n+                values.addAll((List<?>) parseSourceValue(sourceValue));\n+            } else {\n+                // We allow source values to contain multiple levels of arrays, such as `\"field\": [[1, 2]]`.\n+                // So we need to unwrap these arrays before passing them on to be parsed.\n+                Queue<Object> queue = new ArrayDeque<>();\n+                queue.add(sourceValue);\n+                while (queue.isEmpty() == false) {\n+                    Object value = queue.poll();\n+                    if (value instanceof List) {\n+                        queue.addAll((List<?>) value);\n+                    } else {\n+                        Object parsedValue = parseSourceValue(value);\n+                        if (parsedValue != null) {\n+                            values.add(parsedValue);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        return values;\n+    }\n+\n+    /**\n+     * Given a value that has been extracted from a document's source, parse it into a standard\n+     * format. This parsing logic should closely mirror the value parsing in\n+     * {@link FieldMapper#parseCreateField} or {@link FieldMapper#parse}.\n+     */\n+    protected abstract Object parseSourceValue(Object value);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa66569505c10d90f8a794c84f708c874730a3fa"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzI3MjE0NQ==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/elastic/elasticsearch/pull/61309#discussion_r473272145", "createdAt": "2020-08-19T19:35:05Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/search/fetch/subphase/FieldValueRetriever.java", "diffHunk": "@@ -38,34 +40,40 @@\n  * Then given a specific document, it can retrieve the corresponding fields from the document's source.\n  */\n public class FieldValueRetriever {\n-    private final MappingLookup fieldMappers;\n     private final List<FieldContext> fieldContexts;\n \n     public static FieldValueRetriever create(MapperService mapperService,\n                                              Collection<FieldAndFormat> fieldAndFormats) {\n         MappingLookup fieldMappers = mapperService.documentMapper().mappers();\n-        List<FieldContext> fields = new ArrayList<>();\n+        List<FieldContext> fieldContexts = new ArrayList<>();\n \n         for (FieldAndFormat fieldAndFormat : fieldAndFormats) {\n             String fieldPattern = fieldAndFormat.field;\n             String format = fieldAndFormat.format;\n \n             Collection<String> concreteFields = mapperService.simpleMatchToFullName(fieldPattern);\n             for (String field : concreteFields) {\n-                if (fieldMappers.getMapper(field) != null && mapperService.isMetadataField(field) == false) {\n-                    Set<String> sourcePath = mapperService.sourcePath(field);\n-                    fields.add(new FieldContext(field, sourcePath, format));\n+                Mapper mapper = fieldMappers.getMapper(field);\n+                if (mapper == null || mapperService.isMetadataField(field)) {\n+                    continue;\n+                }\n+\n+                if (mapper instanceof FieldAliasMapper) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjcyNDEyMg=="}, "originalCommit": {"oid": "a2b316435b89ba2cb07f74a13da2eff323db8a2e"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzI3NTY2Mw==", "bodyText": "fieldType.value == null ? lookup -> List.of() : lookup -> List.of(fieldType.value)? It isn't really important, but it'd make me feel good.", "url": "https://github.com/elastic/elasticsearch/pull/61309#discussion_r473275663", "createdAt": "2020-08-19T19:42:13Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/mapper-constant-keyword/src/main/java/org/elasticsearch/xpack/constantkeyword/mapper/ConstantKeywordFieldMapper.java", "diffHunk": "@@ -264,21 +265,16 @@ protected void parseCreateField(ParseContext context) throws IOException {\n     }\n \n     @Override\n-    public List<String> lookupValues(SourceLookup lookup, String format) {\n+    public ValueFetcher valueFetcher(MapperService mapperService, String format) {\n         if (format != null) {\n             throw new IllegalArgumentException(\"Field [\" + name() + \"] of type [\" + typeName() + \"] doesn't support formats.\");\n         }\n \n-        return fieldType().value == null\n+        return lookup -> fieldType().value == null", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa66569505c10d90f8a794c84f708c874730a3fa"}, "originalPosition": 25}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f353567c195c6b181bbd5003e5359ad3e5d46649", "author": {"user": {"login": "jtibshirani", "name": "Julie Tibshirani"}}, "url": "https://github.com/elastic/elasticsearch/commit/f353567c195c6b181bbd5003e5359ad3e5d46649", "committedDate": "2020-08-19T22:18:16Z", "message": "Only check constant value once in ConstantKeywordFieldMapper#valueFetcher."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4760, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}