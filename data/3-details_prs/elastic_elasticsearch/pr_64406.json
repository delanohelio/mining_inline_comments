{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEyOTQzMDUy", "number": 64406, "title": "Introduce per REST endpoint media types", "bodyText": "Per REST endpoint media types declaration allows to make parsing/validation more strict.\nIf a media type was declared only in one endpoint (for instance CSV in SQL endpoint) it should not be allowed to parse that media type when using other endpoints.\nHowever, the Compatible API need to be able to understand all media types supported by Elasticsearch in order to parse a compatible-with=version parameter.\nThis implies that endpoints need to declare which media type they support and how to parse them (if introducing new media types - like SQL).\nHow to parse:\nMediaType interface still serves as an abstraction on top of XContentType and TextFormat. It also has a declaration of mappings String-MediaType with parameters. Parameters declares the names of parameters and regex to validate its values.\nThis instructs how to perform the parsing. For instance - XContentType.JSON has the mapping of application/vnd.elasticsearch+json -> JSON and allows parameters compatible-with=\\d and charset=utf-8\nMediaTypeParser was simplified into ParsedMediaType class with static factory method for parsing.\nHow to declare:\nRestHandler interface is extended with a validAcceptMediaTypes which returns a MediaTypeRegistry - a class that encapsulates mappings of string (type/subtype) to MediaType, allowed parameters and formatPathParameter values.\nWe only need to allow of declaration of valid media types for Accept header. Content-Type valid media types are fixed to XContentType instances - json, yaml, smile, cbor.\nrelates #51816", "createdAt": "2020-10-30T11:50:10Z", "url": "https://github.com/elastic/elasticsearch/pull/64406", "merged": true, "mergeCommit": {"oid": "c219e176e9ee01073a2b9a15d8119ef6e184bdd2"}, "closed": true, "closedAt": "2020-11-05T08:47:14Z", "author": {"login": "pgomulka"}, "timelineItems": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdXjWiJgH2gAyNTEyOTQzMDUyOmU0NjhmZGYzNTBjNTRiY2ZkNjNlZTlhMWYyMjEyMzI0NzhjMTExYmM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdZdudUAH2gAyNTEyOTQzMDUyOmI5MDhiZmViZDE0YzcxNTdhZWI3NTkyZjE3YzQ5MDdkOGU5YzZhN2Y=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "e468fdf350c54bcfd63ee9a1f221232478c111bc", "author": {"user": {"login": "pgomulka", "name": "Przemyslaw Gomulka"}}, "url": "https://github.com/elastic/elasticsearch/commit/e468fdf350c54bcfd63ee9a1f221232478c111bc", "committedDate": "2020-10-30T09:28:47Z", "message": "Introduce per endpoint media types"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5cfa11e9db3416a4f7920806977f1333b1c837fa", "author": {"user": {"login": "pgomulka", "name": "Przemyslaw Gomulka"}}, "url": "https://github.com/elastic/elasticsearch/commit/5cfa11e9db3416a4f7920806977f1333b1c837fa", "committedDate": "2020-10-30T09:45:06Z", "message": "Merge branch 'master' into compat/parsed_media_type"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "66224e74f5ede806080c282914870ebac7a8c508", "author": {"user": {"login": "pgomulka", "name": "Przemyslaw Gomulka"}}, "url": "https://github.com/elastic/elasticsearch/commit/66224e74f5ede806080c282914870ebac7a8c508", "committedDate": "2020-10-30T10:14:20Z", "message": "allow smile and cbor to parse charset param. See ClientYamlTestExecutionContext:L122"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "29b27e805f8e31f7b2e21cd54ae9a2342d9398aa", "author": {"user": {"login": "pgomulka", "name": "Przemyslaw Gomulka"}}, "url": "https://github.com/elastic/elasticsearch/commit/29b27e805f8e31f7b2e21cd54ae9a2342d9398aa", "committedDate": "2020-10-30T12:37:26Z", "message": "javadocs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "46903625a056c3f615d0c593370e3c442b1a99b5", "author": {"user": {"login": "pgomulka", "name": "Przemyslaw Gomulka"}}, "url": "https://github.com/elastic/elasticsearch/commit/46903625a056c3f615d0c593370e3c442b1a99b5", "committedDate": "2020-10-30T12:42:38Z", "message": "fix javadoc"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxOTAxODk2", "url": "https://github.com/elastic/elasticsearch/pull/64406#pullrequestreview-521901896", "createdAt": "2020-11-02T18:43:22Z", "commit": {"oid": "46903625a056c3f615d0c593370e3c442b1a99b5"}, "state": "COMMENTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxODo0MzoyMlrOHsRQZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMDoxNjoyOFrOHsUJqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE4MjExNg==", "bodyText": "I think the description here is a bit off/out of date ? (specifically the last 2 sentences)", "url": "https://github.com/elastic/elasticsearch/pull/64406#discussion_r516182116", "createdAt": "2020-11-02T18:43:22Z", "author": {"login": "jakelandis"}, "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeRegistry.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.xcontent;\n+\n+import org.elasticsearch.common.collect.Tuple;\n+\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * A registry of mappings between String typeWithSubtype to a MediaType instances. For instance application/json to XContentType.JSON\n+ * Defines parameters that are allowed for media types and a regex to validate them.\n+ * Specifies format path parameter values that are used to specify requested response Content-Type.\n+ */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46903625a056c3f615d0c593370e3c442b1a99b5"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE4NzM4Mw==", "bodyText": "I would prefer to avoid using Tuple in interfaces. Rather a container object (which is essentially a tuple) to hold the two pieces of state. It helps with more readable code and future additions that may require more then two items. i.e. Set<MediaTypeHeader>\n(which I think would also help with naming this method to httpHeaders() ...technically these are valid headers, not mappings, they are valid ones are used to find the mappings. )", "url": "https://github.com/elastic/elasticsearch/pull/64406#discussion_r516187383", "createdAt": "2020-11-02T18:53:10Z", "author": {"login": "jakelandis"}, "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaType.java", "diffHunk": "@@ -19,34 +19,31 @@\n \n package org.elasticsearch.common.xcontent;\n \n+import org.elasticsearch.common.collect.Tuple;\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n /**\n  * Abstracts a <a href=\"http://en.wikipedia.org/wiki/Internet_media_type\">Media Type</a> and a format parameter.\n  * Media types are used as values on Content-Type and Accept headers\n  * format is an URL parameter, specifies response media type.\n  */\n public interface MediaType {\n-    /**\n-     * Returns a type part of a MediaType\n-     * i.e. application for application/json\n-     */\n-    String type();\n+    String COMPATIBLE_WITH_PARAMETER_NAME = \"compatible-with\";\n+    String VERSION_PATTERN = \"\\\\d+\";\n \n-    /**\n-     * Returns a subtype part of a MediaType.\n-     * i.e. json for application/json\n-     */\n-    String subtype();\n \n     /**\n      * Returns a corresponding format for a MediaType. i.e. json for application/json media type\n      * Can differ from the MediaType's subtype i.e plain/text has a subtype of text but format is txt\n      */\n-    String format();\n+    String formatPathParameter();\n \n     /**\n-     * returns a string representation of a media type.\n+     * returns a set of Tuples where a key is a sting - MediaType's type with subtype i.e application/json\n+     * and a value is a map of parameters to be validated.\n+     * Map's key is a parameter name, value is a parameter regex which is used for validation\n      */\n-    default String typeWithSubtype(){\n-        return type() + \"/\" + subtype();\n-    }\n+    Set<Tuple<String, Map<String,String>>> mediaTypeMappings();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46903625a056c3f615d0c593370e3c442b1a99b5"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE4OTUwOQ==", "bodyText": "Also, can the Pattern be part of return e.g. ``Set<...Map<String, String>>> -> Set<...Map<String, Pattern>>>` ?\nI remember this discussion before, but can't remember the original reason why it is string well enough or if this is still the case.", "url": "https://github.com/elastic/elasticsearch/pull/64406#discussion_r516189509", "createdAt": "2020-11-02T18:57:13Z", "author": {"login": "jakelandis"}, "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaType.java", "diffHunk": "@@ -19,34 +19,31 @@\n \n package org.elasticsearch.common.xcontent;\n \n+import org.elasticsearch.common.collect.Tuple;\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n /**\n  * Abstracts a <a href=\"http://en.wikipedia.org/wiki/Internet_media_type\">Media Type</a> and a format parameter.\n  * Media types are used as values on Content-Type and Accept headers\n  * format is an URL parameter, specifies response media type.\n  */\n public interface MediaType {\n-    /**\n-     * Returns a type part of a MediaType\n-     * i.e. application for application/json\n-     */\n-    String type();\n+    String COMPATIBLE_WITH_PARAMETER_NAME = \"compatible-with\";\n+    String VERSION_PATTERN = \"\\\\d+\";\n \n-    /**\n-     * Returns a subtype part of a MediaType.\n-     * i.e. json for application/json\n-     */\n-    String subtype();\n \n     /**\n      * Returns a corresponding format for a MediaType. i.e. json for application/json media type\n      * Can differ from the MediaType's subtype i.e plain/text has a subtype of text but format is txt\n      */\n-    String format();\n+    String formatPathParameter();\n \n     /**\n-     * returns a string representation of a media type.\n+     * returns a set of Tuples where a key is a sting - MediaType's type with subtype i.e application/json\n+     * and a value is a map of parameters to be validated.\n+     * Map's key is a parameter name, value is a parameter regex which is used for validation\n      */\n-    default String typeWithSubtype(){\n-        return type() + \"/\" + subtype();\n-    }\n+    Set<Tuple<String, Map<String,String>>> mediaTypeMappings();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE4NzM4Mw=="}, "originalCommit": {"oid": "46903625a056c3f615d0c593370e3c442b1a99b5"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjIwNjExMQ==", "bodyText": "I would suggest to change this to queryParameter (drop the format, but leave as an example in the javadoc). If this is named queryParamter and the other method is httpHeaders I think that it makes it clear implementing this class is a way to describe a MediaType.\n(also can you update the java doc...no need to mention subtype anymore, but a and example of ?format=json would be useful.", "url": "https://github.com/elastic/elasticsearch/pull/64406#discussion_r516206111", "createdAt": "2020-11-02T19:30:09Z", "author": {"login": "jakelandis"}, "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaType.java", "diffHunk": "@@ -19,34 +19,31 @@\n \n package org.elasticsearch.common.xcontent;\n \n+import org.elasticsearch.common.collect.Tuple;\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n /**\n  * Abstracts a <a href=\"http://en.wikipedia.org/wiki/Internet_media_type\">Media Type</a> and a format parameter.\n  * Media types are used as values on Content-Type and Accept headers\n  * format is an URL parameter, specifies response media type.\n  */\n public interface MediaType {\n-    /**\n-     * Returns a type part of a MediaType\n-     * i.e. application for application/json\n-     */\n-    String type();\n+    String COMPATIBLE_WITH_PARAMETER_NAME = \"compatible-with\";\n+    String VERSION_PATTERN = \"\\\\d+\";\n \n-    /**\n-     * Returns a subtype part of a MediaType.\n-     * i.e. json for application/json\n-     */\n-    String subtype();\n \n     /**\n      * Returns a corresponding format for a MediaType. i.e. json for application/json media type\n      * Can differ from the MediaType's subtype i.e plain/text has a subtype of text but format is txt\n      */\n-    String format();\n+    String formatPathParameter();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46903625a056c3f615d0c593370e3c442b1a99b5"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjIwNzIwMg==", "bodyText": "I think we should also have a VENDER_PREFIX\t= \"application/vnd.elasticsearch+\" here", "url": "https://github.com/elastic/elasticsearch/pull/64406#discussion_r516207202", "createdAt": "2020-11-02T19:32:17Z", "author": {"login": "jakelandis"}, "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaType.java", "diffHunk": "@@ -19,34 +19,31 @@\n \n package org.elasticsearch.common.xcontent;\n \n+import org.elasticsearch.common.collect.Tuple;\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n /**\n  * Abstracts a <a href=\"http://en.wikipedia.org/wiki/Internet_media_type\">Media Type</a> and a format parameter.\n  * Media types are used as values on Content-Type and Accept headers\n  * format is an URL parameter, specifies response media type.\n  */\n public interface MediaType {\n-    /**\n-     * Returns a type part of a MediaType\n-     * i.e. application for application/json\n-     */\n-    String type();\n+    String COMPATIBLE_WITH_PARAMETER_NAME = \"compatible-with\";\n+    String VERSION_PATTERN = \"\\\\d+\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46903625a056c3f615d0c593370e3c442b1a99b5"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjIxMjI0OA==", "bodyText": "can you log an issue for more stricter parsing and add a TODO that references that to remove this ? Also, probably good to mention that this class can currently return null for unknown mediaTypes, but once issue_number is implemented that won't be possible, so don't rely on null return values.", "url": "https://github.com/elastic/elasticsearch/pull/64406#discussion_r516212248", "createdAt": "2020-11-02T19:42:14Z", "author": {"login": "jakelandis"}, "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/ParsedMediaType.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.xcontent;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * A raw result of parsing media types from Accept or Content-Type headers.\n+ * It follow parsing and validates as per  rules defined in https://tools.ietf.org/html/rfc7231#section-3.1.1.1\n+ * Can be resolved to <code>MediaType</code>\n+ * @see MediaType\n+ * @see MediaTypeRegistry\n+ */\n+public class ParsedMediaType {\n+    //sun.net.www.protocol.http.HttpURLConnection sets a default Accept header if it was not provided on a request\n+    public static final String DEFAULT_ACCEPT_STRING = \"text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46903625a056c3f615d0c593370e3c442b1a99b5"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjIxMjc2MQ==", "bodyText": "can you add or null if no media type could be found", "url": "https://github.com/elastic/elasticsearch/pull/64406#discussion_r516212761", "createdAt": "2020-11-02T19:43:16Z", "author": {"login": "jakelandis"}, "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/ParsedMediaType.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.xcontent;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * A raw result of parsing media types from Accept or Content-Type headers.\n+ * It follow parsing and validates as per  rules defined in https://tools.ietf.org/html/rfc7231#section-3.1.1.1\n+ * Can be resolved to <code>MediaType</code>\n+ * @see MediaType\n+ * @see MediaTypeRegistry\n+ */\n+public class ParsedMediaType {\n+    //sun.net.www.protocol.http.HttpURLConnection sets a default Accept header if it was not provided on a request\n+    public static final String DEFAULT_ACCEPT_STRING = \"text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2\";\n+\n+    private final String type;\n+    private final String subType;\n+    private final Map<String, String> parameters;\n+    // tchar pattern as defined by RFC7230 section 3.2.6\n+    private static final Pattern TCHAR_PATTERN = Pattern.compile(\"[a-zA-z0-9!#$%&'*+\\\\-.\\\\^_`|~]+\");\n+\n+    private ParsedMediaType(String type, String subType, Map<String, String> parameters) {\n+        this.type = type;\n+        this.subType = subType;\n+        this.parameters = Collections.unmodifiableMap(parameters);\n+    }\n+\n+    /**\n+     * The parsed mime type without the associated parameters. Will always return lowercase.\n+     */\n+    public String mimeTypeWithoutParams() {\n+        return type + \"/\" + subType;\n+    }\n+\n+    public Map<String, String> getParameters() {\n+        return parameters;\n+    }\n+\n+    /**\n+     * Parses a header value into it's parts.\n+     *\n+     * @return a {@link ParsedMediaType} if the header could be parsed. TODO: don't return null\n+     * @throws IllegalArgumentException if the header is malformed\n+     */\n+    public static ParsedMediaType parseMediaType(String headerValue) {\n+        if (DEFAULT_ACCEPT_STRING.equals(headerValue) || \"*/*\".equals(headerValue)) {\n+            return null;\n+        }\n+        if (headerValue != null) {\n+            final String[] elements = headerValue.toLowerCase(Locale.ROOT).split(\"[\\\\s\\\\t]*;\");\n+\n+            final String[] splitMediaType = elements[0].split(\"/\");\n+            if ((splitMediaType.length == 2 && TCHAR_PATTERN.matcher(splitMediaType[0].trim()).matches()\n+                && TCHAR_PATTERN.matcher(splitMediaType[1].trim()).matches()) == false) {\n+                throw new IllegalArgumentException(\"invalid media type [\" + headerValue + \"]\");\n+            }\n+            if (elements.length == 1) {\n+                return new ParsedMediaType(splitMediaType[0].trim(), splitMediaType[1].trim(), Collections.emptyMap());\n+            } else {\n+                Map<String, String> parameters = new HashMap<>();\n+                for (int i = 1; i < elements.length; i++) {\n+                    String paramsAsString = elements[i].trim();\n+                    if (paramsAsString.isEmpty()) {\n+                        continue;\n+                    }\n+                    String[] keyValueParam = elements[i].trim().split(\"=\");\n+                    if (keyValueParam.length == 2) {\n+                        String parameterName = keyValueParam[0].toLowerCase(Locale.ROOT).trim();\n+                        String parameterValue = keyValueParam[1].toLowerCase(Locale.ROOT).trim();\n+                        parameters.put(parameterName, parameterValue);\n+                    } else {\n+                        throw new IllegalArgumentException(\"invalid parameters for header [\" + headerValue + \"]\");\n+                    }\n+                }\n+                return new ParsedMediaType(splitMediaType[0].trim().toLowerCase(Locale.ROOT),\n+                    splitMediaType[1].trim().toLowerCase(Locale.ROOT), parameters);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Resolves this instance to a MediaType instance defined in given MediaTypeRegistry.\n+     * Performs validation against parameters.\n+     * @param mediaTypeRegistry a registry where a mapping between a raw media type to an instance MediaType is defined\n+     * @return a MediaType instance", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46903625a056c3f615d0c593370e3c442b1a99b5"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjIxNTkyMg==", "bodyText": "is this intended be commented out ?", "url": "https://github.com/elastic/elasticsearch/pull/64406#discussion_r516215922", "createdAt": "2020-11-02T19:49:06Z", "author": {"login": "jakelandis"}, "path": "libs/x-content/src/test/java/org/elasticsearch/common/xcontent/ParsedMediaTypeTests.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.xcontent;\n+\n+import org.elasticsearch.test.ESTestCase;\n+\n+import java.util.Collections;\n+import java.util.Map;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.nullValue;\n+\n+public class ParsedMediaTypeTests extends ESTestCase {\n+\n+    MediaTypeRegistry<XContentType> mediaTypeRegistry = new MediaTypeRegistry<XContentType>()\n+        .register(XContentType.values());\n+\n+    public void testJsonWithParameters() throws Exception {\n+        String mediaType = \"application/vnd.elasticsearch+json\";\n+        assertThat(ParsedMediaType.parseMediaType(mediaType).getParameters(),\n+            equalTo(Collections.emptyMap()));\n+        assertThat(ParsedMediaType.parseMediaType(mediaType + \";\").getParameters(),\n+            equalTo(Collections.emptyMap()));\n+        assertThat(ParsedMediaType.parseMediaType(mediaType + \"; charset=UTF-8\").getParameters(),\n+            equalTo(Map.of(\"charset\", \"utf-8\")));\n+        assertThat(ParsedMediaType.parseMediaType(mediaType + \"; compatible-with=123;charset=UTF-8\").getParameters(),\n+            equalTo(Map.of(\"charset\", \"utf-8\", \"compatible-with\", \"123\")));\n+    }\n+\n+    public void testWhiteSpaceInTypeSubtype() {\n+        String mediaType = \" application/vnd.elasticsearch+json \";\n+        assertThat(ParsedMediaType.parseMediaType(mediaType).toMediaType(mediaTypeRegistry),\n+            equalTo(XContentType.JSON));\n+\n+        assertThat(ParsedMediaType.parseMediaType(mediaType + \"; compatible-with=123; charset=UTF-8\").getParameters(),\n+            equalTo(Map.of(\"charset\", \"utf-8\", \"compatible-with\", \"123\")));\n+        assertThat(ParsedMediaType.parseMediaType(mediaType + \"; compatible-with=123;\\n charset=UTF-8\").getParameters(),\n+            equalTo(Map.of(\"charset\", \"utf-8\", \"compatible-with\", \"123\")));\n+\n+\n+    }\n+\n+    public void testInvalidParameters() {\n+        String mediaType = \"application/vnd.elasticsearch+json\";\n+        expectThrows(IllegalArgumentException.class, () -> ParsedMediaType.parseMediaType(mediaType + \"; keyvalueNoEqualsSign\")\n+            .toMediaType(mediaTypeRegistry));\n+        // allowing spaces between =\n+        // expectThrows(IllegalArgumentException.class, () -> ParsedMediaType.parseMediaType(mediaType + \"; key = value\")\n+        //            .toMediaType(mediaTypeRegistry));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46903625a056c3f615d0c593370e3c442b1a99b5"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjIxNzk4NA==", "bodyText": "For 7.x we will want to issue a deprecation warning for scenario... an known media type but with unknown parameters will result in ?? (json i think)", "url": "https://github.com/elastic/elasticsearch/pull/64406#discussion_r516217984", "createdAt": "2020-11-02T19:53:09Z", "author": {"login": "jakelandis"}, "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/ParsedMediaType.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.xcontent;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * A raw result of parsing media types from Accept or Content-Type headers.\n+ * It follow parsing and validates as per  rules defined in https://tools.ietf.org/html/rfc7231#section-3.1.1.1\n+ * Can be resolved to <code>MediaType</code>\n+ * @see MediaType\n+ * @see MediaTypeRegistry\n+ */\n+public class ParsedMediaType {\n+    //sun.net.www.protocol.http.HttpURLConnection sets a default Accept header if it was not provided on a request\n+    public static final String DEFAULT_ACCEPT_STRING = \"text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2\";\n+\n+    private final String type;\n+    private final String subType;\n+    private final Map<String, String> parameters;\n+    // tchar pattern as defined by RFC7230 section 3.2.6\n+    private static final Pattern TCHAR_PATTERN = Pattern.compile(\"[a-zA-z0-9!#$%&'*+\\\\-.\\\\^_`|~]+\");\n+\n+    private ParsedMediaType(String type, String subType, Map<String, String> parameters) {\n+        this.type = type;\n+        this.subType = subType;\n+        this.parameters = Collections.unmodifiableMap(parameters);\n+    }\n+\n+    /**\n+     * The parsed mime type without the associated parameters. Will always return lowercase.\n+     */\n+    public String mimeTypeWithoutParams() {\n+        return type + \"/\" + subType;\n+    }\n+\n+    public Map<String, String> getParameters() {\n+        return parameters;\n+    }\n+\n+    /**\n+     * Parses a header value into it's parts.\n+     *\n+     * @return a {@link ParsedMediaType} if the header could be parsed. TODO: don't return null\n+     * @throws IllegalArgumentException if the header is malformed\n+     */\n+    public static ParsedMediaType parseMediaType(String headerValue) {\n+        if (DEFAULT_ACCEPT_STRING.equals(headerValue) || \"*/*\".equals(headerValue)) {\n+            return null;\n+        }\n+        if (headerValue != null) {\n+            final String[] elements = headerValue.toLowerCase(Locale.ROOT).split(\"[\\\\s\\\\t]*;\");\n+\n+            final String[] splitMediaType = elements[0].split(\"/\");\n+            if ((splitMediaType.length == 2 && TCHAR_PATTERN.matcher(splitMediaType[0].trim()).matches()\n+                && TCHAR_PATTERN.matcher(splitMediaType[1].trim()).matches()) == false) {\n+                throw new IllegalArgumentException(\"invalid media type [\" + headerValue + \"]\");\n+            }\n+            if (elements.length == 1) {\n+                return new ParsedMediaType(splitMediaType[0].trim(), splitMediaType[1].trim(), Collections.emptyMap());\n+            } else {\n+                Map<String, String> parameters = new HashMap<>();\n+                for (int i = 1; i < elements.length; i++) {\n+                    String paramsAsString = elements[i].trim();\n+                    if (paramsAsString.isEmpty()) {\n+                        continue;\n+                    }\n+                    String[] keyValueParam = elements[i].trim().split(\"=\");\n+                    if (keyValueParam.length == 2) {\n+                        String parameterName = keyValueParam[0].toLowerCase(Locale.ROOT).trim();\n+                        String parameterValue = keyValueParam[1].toLowerCase(Locale.ROOT).trim();\n+                        parameters.put(parameterName, parameterValue);\n+                    } else {\n+                        throw new IllegalArgumentException(\"invalid parameters for header [\" + headerValue + \"]\");\n+                    }\n+                }\n+                return new ParsedMediaType(splitMediaType[0].trim().toLowerCase(Locale.ROOT),\n+                    splitMediaType[1].trim().toLowerCase(Locale.ROOT), parameters);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Resolves this instance to a MediaType instance defined in given MediaTypeRegistry.\n+     * Performs validation against parameters.\n+     * @param mediaTypeRegistry a registry where a mapping between a raw media type to an instance MediaType is defined\n+     * @return a MediaType instance\n+     */\n+    public  <T extends MediaType> T toMediaType(MediaTypeRegistry<T> mediaTypeRegistry) {\n+        T type = mediaTypeRegistry.typeWithSubtypeToMediaType(mimeTypeWithoutParams());\n+        if (type != null) {\n+\n+            Map<String, Pattern> registeredParams = mediaTypeRegistry.parametersFor(mimeTypeWithoutParams());\n+            for (Map.Entry<String, String> givenParamEntry : parameters.entrySet()) {\n+                if (isValidParameter(givenParamEntry.getKey(), givenParamEntry.getValue(), registeredParams) == false) {\n+                    return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46903625a056c3f615d0c593370e3c442b1a99b5"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjIyMTk1Mw==", "bodyText": "It's not clear from here if the \"charset\" is 'required', or if it is present only allows for these values. I think using a first class object (not a Tuple) would help with readability here.", "url": "https://github.com/elastic/elasticsearch/pull/64406#discussion_r516221953", "createdAt": "2020-11-02T20:00:46Z", "author": {"login": "jakelandis"}, "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java", "diffHunk": "@@ -47,14 +49,26 @@ public String mediaType() {\n         }\n \n         @Override\n-        public String subtype() {\n+        public String formatPathParameter() {\n             return \"json\";\n         }\n \n         @Override\n         public XContent xContent() {\n             return JsonXContent.jsonXContent;\n         }\n+\n+        @Override\n+        public Set<Tuple<String, Map<String, String>>> mediaTypeMappings() {\n+            return Set.of(\n+                Tuple.tuple(\"application/json\", Map.of(\"charset\", \"UTF-8\")),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46903625a056c3f615d0c593370e3c442b1a99b5"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjIyNDc0NA==", "bodyText": "Since this can now be either Accept or Content-Type we probably want to change this to MediaTypeHeaderException", "url": "https://github.com/elastic/elasticsearch/pull/64406#discussion_r516224744", "createdAt": "2020-11-02T20:06:26Z", "author": {"login": "jakelandis"}, "path": "server/src/main/java/org/elasticsearch/rest/RestRequest.java", "diffHunk": "@@ -86,15 +88,15 @@ protected RestRequest(NamedXContentRegistry xContentRegistry, Map<String, String\n \n     private RestRequest(NamedXContentRegistry xContentRegistry, Map<String, String> params, String path,\n                         Map<String, List<String>> headers, HttpRequest httpRequest, HttpChannel httpChannel, long requestId) {\n-        final XContentType xContentType;\n-        try {\n-            xContentType = parseContentType(headers.get(\"Content-Type\"));\n-        } catch (final IllegalArgumentException e) {\n+        try{\n+            this.parsedAccept = parseHeaderWithMediaType(httpRequest.getHeaders(), \"Accept\");\n+            this.parsedContentType = parseHeaderWithMediaType(httpRequest.getHeaders(), \"Content-Type\");\n+            if (parsedContentType != null) {\n+                this.xContentType.set(parsedContentType.toMediaType(XContentType.MEDIA_TYPE_REGISTRY));\n+            }\n+        }catch (IllegalArgumentException e){\n             throw new ContentTypeHeaderException(e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46903625a056c3f615d0c593370e3c442b1a99b5"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjIyNTc1OQ==", "bodyText": "might to include the header name in the exception for troubleshooting.", "url": "https://github.com/elastic/elasticsearch/pull/64406#discussion_r516225759", "createdAt": "2020-11-02T20:08:25Z", "author": {"login": "jakelandis"}, "path": "server/src/main/java/org/elasticsearch/rest/RestRequest.java", "diffHunk": "@@ -104,6 +106,22 @@ private RestRequest(NamedXContentRegistry xContentRegistry, Map<String, String>\n         this.requestId = requestId;\n     }\n \n+    private static @Nullable ParsedMediaType parseHeaderWithMediaType(Map<String, List<String>> headers, String headerName) {\n+        //TOOD: shouldn't this be case insensitive ?\n+        List<String> header = headers.get(headerName);\n+        if (header == null || header.isEmpty()) {\n+            return null;\n+        } else if (header.size() > 1) {\n+            throw new IllegalArgumentException(\"only one value for the  header should be provided\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46903625a056c3f615d0c593370e3c442b1a99b5"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjIyNjk1Mw==", "bodyText": "should we resolve this TODO with this PR ?", "url": "https://github.com/elastic/elasticsearch/pull/64406#discussion_r516226953", "createdAt": "2020-11-02T20:10:58Z", "author": {"login": "jakelandis"}, "path": "server/src/main/java/org/elasticsearch/rest/RestRequest.java", "diffHunk": "@@ -104,6 +106,22 @@ private RestRequest(NamedXContentRegistry xContentRegistry, Map<String, String>\n         this.requestId = requestId;\n     }\n \n+    private static @Nullable ParsedMediaType parseHeaderWithMediaType(Map<String, List<String>> headers, String headerName) {\n+        //TOOD: shouldn't this be case insensitive ?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46903625a056c3f615d0c593370e3c442b1a99b5"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjIyOTU0Nw==", "bodyText": "whoops .. missing line break.", "url": "https://github.com/elastic/elasticsearch/pull/64406#discussion_r516229547", "createdAt": "2020-11-02T20:16:28Z", "author": {"login": "jakelandis"}, "path": "test/framework/src/main/java/org/elasticsearch/test/rest/yaml/ClientYamlTestResponse.java", "diffHunk": "@@ -53,8 +53,8 @@ public ClientYamlTestResponse(Response response) throws IOException {\n         this.response = response;\n         if (response.getEntity() != null) {\n             String contentType = response.getHeader(\"Content-Type\");\n-            this.bodyContentType = XContentType.fromMediaType(contentType);\n-            try {\n+            //Do not know about sql media types. relies on null\n+            this.bodyContentType = getContentTypeIgnoreExceptions(contentType);            try {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46903625a056c3f615d0c593370e3c442b1a99b5"}, "originalPosition": 7}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2bda74f773d6b682deaa0c256a3568cbc0c1956c", "author": {"user": {"login": "pgomulka", "name": "Przemyslaw Gomulka"}}, "url": "https://github.com/elastic/elasticsearch/commit/2bda74f773d6b682deaa0c256a3568cbc0c1956c", "committedDate": "2020-11-03T12:15:42Z", "message": "code review follow up"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7779083b4e5ed3301bd75bfc340bff51bae2042c", "author": {"user": {"login": "pgomulka", "name": "Przemyslaw Gomulka"}}, "url": "https://github.com/elastic/elasticsearch/commit/7779083b4e5ed3301bd75bfc340bff51bae2042c", "committedDate": "2020-11-03T12:52:14Z", "message": "minor tweaks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dd26408343b5633d4981d15207c5a714a8a44e7e", "author": {"user": {"login": "pgomulka", "name": "Przemyslaw Gomulka"}}, "url": "https://github.com/elastic/elasticsearch/commit/dd26408343b5633d4981d15207c5a714a8a44e7e", "committedDate": "2020-11-03T12:52:41Z", "message": "Merge branch 'master' into compat/introduce_per_endpoint_media_types"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "94b4a0a85ece16e597818e815d958675e5879125", "author": {"user": {"login": "pgomulka", "name": "Przemyslaw Gomulka"}}, "url": "https://github.com/elastic/elasticsearch/commit/94b4a0a85ece16e597818e815d958675e5879125", "committedDate": "2020-11-03T13:41:27Z", "message": "fix test after exception msg rename"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "43855911ed3ec0ad1d245cc398e7d67f59acb975", "author": {"user": {"login": "pgomulka", "name": "Przemyslaw Gomulka"}}, "url": "https://github.com/elastic/elasticsearch/commit/43855911ed3ec0ad1d245cc398e7d67f59acb975", "committedDate": "2020-11-03T15:30:35Z", "message": "rename to header value"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyODM4NzU3", "url": "https://github.com/elastic/elasticsearch/pull/64406#pullrequestreview-522838757", "createdAt": "2020-11-03T20:08:51Z", "commit": {"oid": "43855911ed3ec0ad1d245cc398e7d67f59acb975"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QyMDowODo1MVrOHs-vpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QyMDozNDo1N1rOHs_hGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkyNzM5Ng==", "bodyText": "how about something like this:\n\nMultiple header represenations may map to a single {@link MediaType} for example, \"application/json\" and \"application/vnd.elasticsearch+json\" both represent a JSON MediaType. A MediaType can have only one query parameter representation. For example \"json\" (case insensitive) maps back to a JSON media type. \n\nAdditionally, a http header may optionally have parameters. For example \"application/json; charset=utf-8\". This class also allows to define a regular expression for valid values of charset.", "url": "https://github.com/elastic/elasticsearch/pull/64406#discussion_r516927396", "createdAt": "2020-11-03T20:08:51Z", "author": {"login": "jakelandis"}, "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeRegistry.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.xcontent;\n+\n+import org.elasticsearch.common.collect.Tuple;\n+\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * A registry of mappings between String typeWithSubtype to a MediaType instances. For instance application/json to XContentType.JSON\n+ * Defines parameters that are allowed for media types and a regex to validate them.\n+ * Specifies format path parameter values that are used to specify requested response Content-Type.\n+ */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE4MjExNg=="}, "originalCommit": {"oid": "46903625a056c3f615d0c593370e3c442b1a99b5"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkyODQ4OQ==", "bodyText": "should */* be a JSON type ? (with this lenient parsing null defaults to that..but I think it should be explicit that */* is JSON)", "url": "https://github.com/elastic/elasticsearch/pull/64406#discussion_r516928489", "createdAt": "2020-11-03T20:11:09Z", "author": {"login": "jakelandis"}, "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/ParsedMediaType.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.xcontent;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * A raw result of parsing media types from Accept or Content-Type headers.\n+ * It follow parsing and validates as per  rules defined in https://tools.ietf.org/html/rfc7231#section-3.1.1.1\n+ * Can be resolved to <code>MediaType</code>\n+ * @see MediaType\n+ * @see MediaTypeRegistry\n+ */\n+public class ParsedMediaType {\n+    // TODO this should be removed once strict parsing is implemented https://github.com/elastic/elasticsearch/issues/63080\n+    // sun.net.www.protocol.http.HttpURLConnection sets a default Accept header if it was not provided on a request.\n+    // For this value Parsing returns null.\n+    public static final String DEFAULT_ACCEPT_STRING = \"text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2\";\n+\n+    private final String type;\n+    private final String subType;\n+    private final Map<String, String> parameters;\n+    // tchar pattern as defined by RFC7230 section 3.2.6\n+    private static final Pattern TCHAR_PATTERN = Pattern.compile(\"[a-zA-z0-9!#$%&'*+\\\\-.\\\\^_`|~]+\");\n+\n+    private ParsedMediaType(String type, String subType, Map<String, String> parameters) {\n+        this.type = type;\n+        this.subType = subType;\n+        this.parameters = Collections.unmodifiableMap(parameters);\n+    }\n+\n+    /**\n+     * The parsed mime type without the associated parameters. Will always return lowercase.\n+     */\n+    public String mediaTypeWithoutParameters() {\n+        return type + \"/\" + subType;\n+    }\n+\n+    public Map<String, String> getParameters() {\n+        return parameters;\n+    }\n+\n+    /**\n+     * Parses a header value into it's parts.\n+     * Note: parsing can return null, but it will throw exceptions once https://github.com/elastic/elasticsearch/issues/63080 is done\n+     * Do not rely on nulls\n+     *\n+     * @return a {@link ParsedMediaType} if the header could be parsed.\n+     * @throws IllegalArgumentException if the header is malformed\n+     */\n+    public static ParsedMediaType parseMediaType(String headerValue) {\n+        if (DEFAULT_ACCEPT_STRING.equals(headerValue) || \"*/*\".equals(headerValue)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43855911ed3ec0ad1d245cc398e7d67f59acb975"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkzNTkwMA==", "bodyText": "The only mention I saw in the spec was \" No whitespace is allowed between the header field-name and colon. \"\nThe field value is not covered by this mandate:\nheader-field   = field-name \":\" OWS field-value OWS\n\nThis does not explicitly state that the field-value can not have whitespace. For example, \"application/<space>json\" isn't forbidden by the HTTP spec (spaces are allowed in the field-value). The correctness of spaces in mimetypes or parameters would be defined by https://tools.ietf.org/html/rfc6838 (media type spec). While it is pretty clear that \"application/<space>json\" != \"application/json\", I think we should still allow it since that is a nightmare to troubleshoot. Also the spec is not clear on if ;<space>param<space>=<space>value is acceptable. I think it actually is.\nI would suggest to remove the \"RFC disallows this\".", "url": "https://github.com/elastic/elasticsearch/pull/64406#discussion_r516935900", "createdAt": "2020-11-03T20:26:23Z", "author": {"login": "jakelandis"}, "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/ParsedMediaType.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.xcontent;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * A raw result of parsing media types from Accept or Content-Type headers.\n+ * It follow parsing and validates as per  rules defined in https://tools.ietf.org/html/rfc7231#section-3.1.1.1\n+ * Can be resolved to <code>MediaType</code>\n+ * @see MediaType\n+ * @see MediaTypeRegistry\n+ */\n+public class ParsedMediaType {\n+    // TODO this should be removed once strict parsing is implemented https://github.com/elastic/elasticsearch/issues/63080\n+    // sun.net.www.protocol.http.HttpURLConnection sets a default Accept header if it was not provided on a request.\n+    // For this value Parsing returns null.\n+    public static final String DEFAULT_ACCEPT_STRING = \"text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2\";\n+\n+    private final String type;\n+    private final String subType;\n+    private final Map<String, String> parameters;\n+    // tchar pattern as defined by RFC7230 section 3.2.6\n+    private static final Pattern TCHAR_PATTERN = Pattern.compile(\"[a-zA-z0-9!#$%&'*+\\\\-.\\\\^_`|~]+\");\n+\n+    private ParsedMediaType(String type, String subType, Map<String, String> parameters) {\n+        this.type = type;\n+        this.subType = subType;\n+        this.parameters = Collections.unmodifiableMap(parameters);\n+    }\n+\n+    /**\n+     * The parsed mime type without the associated parameters. Will always return lowercase.\n+     */\n+    public String mediaTypeWithoutParameters() {\n+        return type + \"/\" + subType;\n+    }\n+\n+    public Map<String, String> getParameters() {\n+        return parameters;\n+    }\n+\n+    /**\n+     * Parses a header value into it's parts.\n+     * Note: parsing can return null, but it will throw exceptions once https://github.com/elastic/elasticsearch/issues/63080 is done\n+     * Do not rely on nulls\n+     *\n+     * @return a {@link ParsedMediaType} if the header could be parsed.\n+     * @throws IllegalArgumentException if the header is malformed\n+     */\n+    public static ParsedMediaType parseMediaType(String headerValue) {\n+        if (DEFAULT_ACCEPT_STRING.equals(headerValue) || \"*/*\".equals(headerValue)) {\n+            return null;\n+        }\n+        if (headerValue != null) {\n+            final String[] elements = headerValue.toLowerCase(Locale.ROOT).split(\"[\\\\s\\\\t]*;\");\n+\n+            final String[] splitMediaType = elements[0].split(\"/\");\n+            if ((splitMediaType.length == 2 && TCHAR_PATTERN.matcher(splitMediaType[0].trim()).matches()\n+                && TCHAR_PATTERN.matcher(splitMediaType[1].trim()).matches()) == false) {\n+                throw new IllegalArgumentException(\"invalid media type [\" + headerValue + \"]\");\n+            }\n+            if (elements.length == 1) {\n+                return new ParsedMediaType(splitMediaType[0].trim(), splitMediaType[1].trim(), Collections.emptyMap());\n+            } else {\n+                Map<String, String> parameters = new HashMap<>();\n+                for (int i = 1; i < elements.length; i++) {\n+                    String paramsAsString = elements[i].trim();\n+                    if (paramsAsString.isEmpty()) {\n+                        continue;\n+                    }\n+                    // intentionally allowing to have spaces around `=` (RFC disallows this)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43855911ed3ec0ad1d245cc398e7d67f59acb975"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkzOTM5Nw==", "bodyText": "The concern here is that someone requests application/yaml;charset=Windows-1252, they will now get back application/json (since it is the null/default), right ?\nI think this should log deprecation warning about an unsupported charset and still return the type.", "url": "https://github.com/elastic/elasticsearch/pull/64406#discussion_r516939397", "createdAt": "2020-11-03T20:33:37Z", "author": {"login": "jakelandis"}, "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/ParsedMediaType.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.xcontent;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * A raw result of parsing media types from Accept or Content-Type headers.\n+ * It follow parsing and validates as per  rules defined in https://tools.ietf.org/html/rfc7231#section-3.1.1.1\n+ * Can be resolved to <code>MediaType</code>\n+ * @see MediaType\n+ * @see MediaTypeRegistry\n+ */\n+public class ParsedMediaType {\n+    //sun.net.www.protocol.http.HttpURLConnection sets a default Accept header if it was not provided on a request\n+    public static final String DEFAULT_ACCEPT_STRING = \"text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2\";\n+\n+    private final String type;\n+    private final String subType;\n+    private final Map<String, String> parameters;\n+    // tchar pattern as defined by RFC7230 section 3.2.6\n+    private static final Pattern TCHAR_PATTERN = Pattern.compile(\"[a-zA-z0-9!#$%&'*+\\\\-.\\\\^_`|~]+\");\n+\n+    private ParsedMediaType(String type, String subType, Map<String, String> parameters) {\n+        this.type = type;\n+        this.subType = subType;\n+        this.parameters = Collections.unmodifiableMap(parameters);\n+    }\n+\n+    /**\n+     * The parsed mime type without the associated parameters. Will always return lowercase.\n+     */\n+    public String mimeTypeWithoutParams() {\n+        return type + \"/\" + subType;\n+    }\n+\n+    public Map<String, String> getParameters() {\n+        return parameters;\n+    }\n+\n+    /**\n+     * Parses a header value into it's parts.\n+     *\n+     * @return a {@link ParsedMediaType} if the header could be parsed. TODO: don't return null\n+     * @throws IllegalArgumentException if the header is malformed\n+     */\n+    public static ParsedMediaType parseMediaType(String headerValue) {\n+        if (DEFAULT_ACCEPT_STRING.equals(headerValue) || \"*/*\".equals(headerValue)) {\n+            return null;\n+        }\n+        if (headerValue != null) {\n+            final String[] elements = headerValue.toLowerCase(Locale.ROOT).split(\"[\\\\s\\\\t]*;\");\n+\n+            final String[] splitMediaType = elements[0].split(\"/\");\n+            if ((splitMediaType.length == 2 && TCHAR_PATTERN.matcher(splitMediaType[0].trim()).matches()\n+                && TCHAR_PATTERN.matcher(splitMediaType[1].trim()).matches()) == false) {\n+                throw new IllegalArgumentException(\"invalid media type [\" + headerValue + \"]\");\n+            }\n+            if (elements.length == 1) {\n+                return new ParsedMediaType(splitMediaType[0].trim(), splitMediaType[1].trim(), Collections.emptyMap());\n+            } else {\n+                Map<String, String> parameters = new HashMap<>();\n+                for (int i = 1; i < elements.length; i++) {\n+                    String paramsAsString = elements[i].trim();\n+                    if (paramsAsString.isEmpty()) {\n+                        continue;\n+                    }\n+                    String[] keyValueParam = elements[i].trim().split(\"=\");\n+                    if (keyValueParam.length == 2) {\n+                        String parameterName = keyValueParam[0].toLowerCase(Locale.ROOT).trim();\n+                        String parameterValue = keyValueParam[1].toLowerCase(Locale.ROOT).trim();\n+                        parameters.put(parameterName, parameterValue);\n+                    } else {\n+                        throw new IllegalArgumentException(\"invalid parameters for header [\" + headerValue + \"]\");\n+                    }\n+                }\n+                return new ParsedMediaType(splitMediaType[0].trim().toLowerCase(Locale.ROOT),\n+                    splitMediaType[1].trim().toLowerCase(Locale.ROOT), parameters);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Resolves this instance to a MediaType instance defined in given MediaTypeRegistry.\n+     * Performs validation against parameters.\n+     * @param mediaTypeRegistry a registry where a mapping between a raw media type to an instance MediaType is defined\n+     * @return a MediaType instance\n+     */\n+    public  <T extends MediaType> T toMediaType(MediaTypeRegistry<T> mediaTypeRegistry) {\n+        T type = mediaTypeRegistry.typeWithSubtypeToMediaType(mimeTypeWithoutParams());\n+        if (type != null) {\n+\n+            Map<String, Pattern> registeredParams = mediaTypeRegistry.parametersFor(mimeTypeWithoutParams());\n+            for (Map.Entry<String, String> givenParamEntry : parameters.entrySet()) {\n+                if (isValidParameter(givenParamEntry.getKey(), givenParamEntry.getValue(), registeredParams) == false) {\n+                    return null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjIxNzk4NA=="}, "originalCommit": {"oid": "46903625a056c3f615d0c593370e3c442b1a99b5"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk0MDA1Ng==", "bodyText": "can we also emit a deprecation warning ?", "url": "https://github.com/elastic/elasticsearch/pull/64406#discussion_r516940056", "createdAt": "2020-11-03T20:34:57Z", "author": {"login": "jakelandis"}, "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/ParsedMediaType.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.xcontent;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * A raw result of parsing media types from Accept or Content-Type headers.\n+ * It follow parsing and validates as per  rules defined in https://tools.ietf.org/html/rfc7231#section-3.1.1.1\n+ * Can be resolved to <code>MediaType</code>\n+ * @see MediaType\n+ * @see MediaTypeRegistry\n+ */\n+public class ParsedMediaType {\n+    // TODO this should be removed once strict parsing is implemented https://github.com/elastic/elasticsearch/issues/63080\n+    // sun.net.www.protocol.http.HttpURLConnection sets a default Accept header if it was not provided on a request.\n+    // For this value Parsing returns null.\n+    public static final String DEFAULT_ACCEPT_STRING = \"text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2\";\n+\n+    private final String type;\n+    private final String subType;\n+    private final Map<String, String> parameters;\n+    // tchar pattern as defined by RFC7230 section 3.2.6\n+    private static final Pattern TCHAR_PATTERN = Pattern.compile(\"[a-zA-z0-9!#$%&'*+\\\\-.\\\\^_`|~]+\");\n+\n+    private ParsedMediaType(String type, String subType, Map<String, String> parameters) {\n+        this.type = type;\n+        this.subType = subType;\n+        this.parameters = Collections.unmodifiableMap(parameters);\n+    }\n+\n+    /**\n+     * The parsed mime type without the associated parameters. Will always return lowercase.\n+     */\n+    public String mediaTypeWithoutParameters() {\n+        return type + \"/\" + subType;\n+    }\n+\n+    public Map<String, String> getParameters() {\n+        return parameters;\n+    }\n+\n+    /**\n+     * Parses a header value into it's parts.\n+     * Note: parsing can return null, but it will throw exceptions once https://github.com/elastic/elasticsearch/issues/63080 is done\n+     * Do not rely on nulls\n+     *\n+     * @return a {@link ParsedMediaType} if the header could be parsed.\n+     * @throws IllegalArgumentException if the header is malformed\n+     */\n+    public static ParsedMediaType parseMediaType(String headerValue) {\n+        if (DEFAULT_ACCEPT_STRING.equals(headerValue) || \"*/*\".equals(headerValue)) {\n+            return null;\n+        }\n+        if (headerValue != null) {\n+            final String[] elements = headerValue.toLowerCase(Locale.ROOT).split(\"[\\\\s\\\\t]*;\");\n+\n+            final String[] splitMediaType = elements[0].split(\"/\");\n+            if ((splitMediaType.length == 2 && TCHAR_PATTERN.matcher(splitMediaType[0].trim()).matches()\n+                && TCHAR_PATTERN.matcher(splitMediaType[1].trim()).matches()) == false) {\n+                throw new IllegalArgumentException(\"invalid media type [\" + headerValue + \"]\");\n+            }\n+            if (elements.length == 1) {\n+                return new ParsedMediaType(splitMediaType[0].trim(), splitMediaType[1].trim(), Collections.emptyMap());\n+            } else {\n+                Map<String, String> parameters = new HashMap<>();\n+                for (int i = 1; i < elements.length; i++) {\n+                    String paramsAsString = elements[i].trim();\n+                    if (paramsAsString.isEmpty()) {\n+                        continue;\n+                    }\n+                    // intentionally allowing to have spaces around `=` (RFC disallows this)\n+                    String[] keyValueParam = elements[i].trim().split(\"=\");\n+                    if (keyValueParam.length == 2) {\n+                        String parameterName = keyValueParam[0].toLowerCase(Locale.ROOT).trim();\n+                        String parameterValue = keyValueParam[1].toLowerCase(Locale.ROOT).trim();\n+                        parameters.put(parameterName, parameterValue);\n+                    } else {\n+                        throw new IllegalArgumentException(\"invalid parameters for header [\" + headerValue + \"]\");\n+                    }\n+                }\n+                return new ParsedMediaType(splitMediaType[0].trim().toLowerCase(Locale.ROOT),\n+                    splitMediaType[1].trim().toLowerCase(Locale.ROOT), parameters);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Resolves this instance to a MediaType instance defined in given MediaTypeRegistry.\n+     * Performs validation against parameters.\n+     * @param mediaTypeRegistry a registry where a mapping between a raw media type to an instance MediaType is defined\n+     * @return a MediaType instance or null if no media type could be found or if a known parameter do not passes validation\n+     */\n+    public  <T extends MediaType> T toMediaType(MediaTypeRegistry<T> mediaTypeRegistry) {\n+        T type = mediaTypeRegistry.typeWithSubtypeToMediaType(mediaTypeWithoutParameters());\n+        if (type != null) {\n+\n+            Map<String, Pattern> registeredParams = mediaTypeRegistry.parametersFor(mediaTypeWithoutParameters());\n+            for (Map.Entry<String, String> givenParamEntry : parameters.entrySet()) {\n+                if (isValidParameter(givenParamEntry.getKey(), givenParamEntry.getValue(), registeredParams) == false) {\n+                    return null;\n+                }\n+            }\n+            return type;\n+        }\n+        return null;\n+    }\n+\n+    private boolean isValidParameter(String paramName, String value, Map<String, Pattern> registeredParams) {\n+        if(registeredParams.containsKey(paramName)){\n+            Pattern regex = registeredParams.get(paramName);\n+            return regex.matcher(value).matches();\n+        }\n+        //TODO undefined parameters are allowed until https://github.com/elastic/elasticsearch/issues/63080", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43855911ed3ec0ad1d245cc398e7d67f59acb975"}, "originalPosition": 136}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dc61731ba05c6d2338ff46cf3f3bf665b334c525", "author": {"user": {"login": "pgomulka", "name": "Przemyslaw Gomulka"}}, "url": "https://github.com/elastic/elasticsearch/commit/dc61731ba05c6d2338ff46cf3f3bf665b334c525", "committedDate": "2020-11-04T09:24:25Z", "message": "remove charset validation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNTQ0OTky", "url": "https://github.com/elastic/elasticsearch/pull/64406#pullrequestreview-523544992", "createdAt": "2020-11-04T16:45:27Z", "commit": {"oid": "dc61731ba05c6d2338ff46cf3f3bf665b334c525"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNzMyNjc5", "url": "https://github.com/elastic/elasticsearch/pull/64406#pullrequestreview-523732679", "createdAt": "2020-11-04T21:02:43Z", "commit": {"oid": "dc61731ba05c6d2338ff46cf3f3bf665b334c525"}, "state": "APPROVED", "comments": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMTowMjo0NFrOHtpmUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQyMjoxNzo0N1rOHtrseg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYyOTUyMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if(format == null) {\n          \n          \n            \n                    if (format == null) {", "url": "https://github.com/elastic/elasticsearch/pull/64406#discussion_r517629521", "createdAt": "2020-11-04T21:02:44Z", "author": {"login": "jaymode"}, "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeRegistry.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.xcontent;\n+\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * A registry for quick media type lookup.\n+ * It allows to find media type by a header value - typeWithSubtype aka mediaType without parameters.\n+ * I.e. application/json will return XContentType.JSON\n+ * Also allows to find media type by a path parameter <code>format</code>.\n+ * I.e. txt used in path _sql?format=txt will return TextFormat.PLAIN_TEXT\n+ *\n+ * Multiple header representations may map to a single {@link MediaType} for example, \"application/json\"\n+ * and \"application/vnd.elasticsearch+json\" both represent a JSON MediaType.\n+ * A MediaType can have only one query parameter representation.\n+ * For example \"json\" (case insensitive) maps back to a JSON media type.\n+ *\n+ * Additionally, a http header may optionally have parameters. For example \"application/json; charset=utf-8\".\n+ * This class also allows to define a regular expression for valid values of charset.\n+ */\n+public class MediaTypeRegistry<T extends MediaType> {\n+\n+    private Map<String, T> queryParamToMediaType = new HashMap<>();\n+    private Map<String, T> typeWithSubtypeToMediaType = new HashMap<>();\n+    private Map<String, Map<String, Pattern>> parametersMap = new HashMap<>();\n+\n+    public T queryParamToMediaType(String format) {\n+        if(format == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc61731ba05c6d2338ff46cf3f3bf665b334c525"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYyOTcyOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            queryParamToMediaType.put(mediaType.queryParameter(),mediaType);\n          \n          \n            \n                            queryParamToMediaType.put(mediaType.queryParameter(), mediaType);", "url": "https://github.com/elastic/elasticsearch/pull/64406#discussion_r517629728", "createdAt": "2020-11-04T21:03:10Z", "author": {"login": "jaymode"}, "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeRegistry.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.xcontent;\n+\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * A registry for quick media type lookup.\n+ * It allows to find media type by a header value - typeWithSubtype aka mediaType without parameters.\n+ * I.e. application/json will return XContentType.JSON\n+ * Also allows to find media type by a path parameter <code>format</code>.\n+ * I.e. txt used in path _sql?format=txt will return TextFormat.PLAIN_TEXT\n+ *\n+ * Multiple header representations may map to a single {@link MediaType} for example, \"application/json\"\n+ * and \"application/vnd.elasticsearch+json\" both represent a JSON MediaType.\n+ * A MediaType can have only one query parameter representation.\n+ * For example \"json\" (case insensitive) maps back to a JSON media type.\n+ *\n+ * Additionally, a http header may optionally have parameters. For example \"application/json; charset=utf-8\".\n+ * This class also allows to define a regular expression for valid values of charset.\n+ */\n+public class MediaTypeRegistry<T extends MediaType> {\n+\n+    private Map<String, T> queryParamToMediaType = new HashMap<>();\n+    private Map<String, T> typeWithSubtypeToMediaType = new HashMap<>();\n+    private Map<String, Map<String, Pattern>> parametersMap = new HashMap<>();\n+\n+    public T queryParamToMediaType(String format) {\n+        if(format == null) {\n+            return null;\n+        }\n+        return queryParamToMediaType.get(format.toLowerCase(Locale.ROOT));\n+    }\n+\n+    public T typeWithSubtypeToMediaType(String typeWithSubtype) {\n+        return typeWithSubtypeToMediaType.get(typeWithSubtype.toLowerCase(Locale.ROOT));\n+    }\n+\n+    public Map<String, Pattern> parametersFor(String typeWithSubtype) {\n+        return parametersMap.get(typeWithSubtype);\n+    }\n+\n+    public MediaTypeRegistry<T> register(T[] mediaTypes ) {\n+        for (T mediaType : mediaTypes) {\n+            Set<MediaType.HeaderValue> tuples = mediaType.headerValues();\n+            for (MediaType.HeaderValue headerValue : tuples) {\n+                queryParamToMediaType.put(mediaType.queryParameter(),mediaType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc61731ba05c6d2338ff46cf3f3bf665b334c525"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYyOTg2Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Map<String,Pattern> convertPatterns(Map<String,String> paramNameAndValueRegex){\n          \n          \n            \n                private Map<String,Pattern> convertPatterns(Map<String, String> paramNameAndValueRegex) {", "url": "https://github.com/elastic/elasticsearch/pull/64406#discussion_r517629862", "createdAt": "2020-11-04T21:03:28Z", "author": {"login": "jaymode"}, "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeRegistry.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.xcontent;\n+\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * A registry for quick media type lookup.\n+ * It allows to find media type by a header value - typeWithSubtype aka mediaType without parameters.\n+ * I.e. application/json will return XContentType.JSON\n+ * Also allows to find media type by a path parameter <code>format</code>.\n+ * I.e. txt used in path _sql?format=txt will return TextFormat.PLAIN_TEXT\n+ *\n+ * Multiple header representations may map to a single {@link MediaType} for example, \"application/json\"\n+ * and \"application/vnd.elasticsearch+json\" both represent a JSON MediaType.\n+ * A MediaType can have only one query parameter representation.\n+ * For example \"json\" (case insensitive) maps back to a JSON media type.\n+ *\n+ * Additionally, a http header may optionally have parameters. For example \"application/json; charset=utf-8\".\n+ * This class also allows to define a regular expression for valid values of charset.\n+ */\n+public class MediaTypeRegistry<T extends MediaType> {\n+\n+    private Map<String, T> queryParamToMediaType = new HashMap<>();\n+    private Map<String, T> typeWithSubtypeToMediaType = new HashMap<>();\n+    private Map<String, Map<String, Pattern>> parametersMap = new HashMap<>();\n+\n+    public T queryParamToMediaType(String format) {\n+        if(format == null) {\n+            return null;\n+        }\n+        return queryParamToMediaType.get(format.toLowerCase(Locale.ROOT));\n+    }\n+\n+    public T typeWithSubtypeToMediaType(String typeWithSubtype) {\n+        return typeWithSubtypeToMediaType.get(typeWithSubtype.toLowerCase(Locale.ROOT));\n+    }\n+\n+    public Map<String, Pattern> parametersFor(String typeWithSubtype) {\n+        return parametersMap.get(typeWithSubtype);\n+    }\n+\n+    public MediaTypeRegistry<T> register(T[] mediaTypes ) {\n+        for (T mediaType : mediaTypes) {\n+            Set<MediaType.HeaderValue> tuples = mediaType.headerValues();\n+            for (MediaType.HeaderValue headerValue : tuples) {\n+                queryParamToMediaType.put(mediaType.queryParameter(),mediaType);\n+                typeWithSubtypeToMediaType.put(headerValue.v1(), mediaType);\n+                parametersMap.put(headerValue.v1(), convertPatterns(headerValue.v2()));\n+            }\n+        }\n+        return this;\n+    }\n+\n+    private Map<String,Pattern> convertPatterns(Map<String,String> paramNameAndValueRegex){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc61731ba05c6d2338ff46cf3f3bf665b334c525"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYzMDg1NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if(registeredParams.containsKey(paramName)){\n          \n          \n            \n                    if (registeredParams.containsKey(paramName)) {", "url": "https://github.com/elastic/elasticsearch/pull/64406#discussion_r517630854", "createdAt": "2020-11-04T21:05:23Z", "author": {"login": "jaymode"}, "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/ParsedMediaType.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.xcontent;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * A raw result of parsing media types from Accept or Content-Type headers.\n+ * It follow parsing and validates as per  rules defined in https://tools.ietf.org/html/rfc7231#section-3.1.1.1\n+ * Can be resolved to <code>MediaType</code>\n+ * @see MediaType\n+ * @see MediaTypeRegistry\n+ */\n+public class ParsedMediaType {\n+    // TODO this should be removed once strict parsing is implemented https://github.com/elastic/elasticsearch/issues/63080\n+    // sun.net.www.protocol.http.HttpURLConnection sets a default Accept header if it was not provided on a request.\n+    // For this value Parsing returns null.\n+    public static final String DEFAULT_ACCEPT_STRING = \"text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2\";\n+\n+    private final String type;\n+    private final String subType;\n+    private final Map<String, String> parameters;\n+    // tchar pattern as defined by RFC7230 section 3.2.6\n+    private static final Pattern TCHAR_PATTERN = Pattern.compile(\"[a-zA-z0-9!#$%&'*+\\\\-.\\\\^_`|~]+\");\n+\n+    private ParsedMediaType(String type, String subType, Map<String, String> parameters) {\n+        this.type = type;\n+        this.subType = subType;\n+        this.parameters = Collections.unmodifiableMap(parameters);\n+    }\n+\n+    /**\n+     * The parsed mime type without the associated parameters. Will always return lowercase.\n+     */\n+    public String mediaTypeWithoutParameters() {\n+        return type + \"/\" + subType;\n+    }\n+\n+    public Map<String, String> getParameters() {\n+        return parameters;\n+    }\n+\n+    /**\n+     * Parses a header value into it's parts.\n+     * Note: parsing can return null, but it will throw exceptions once https://github.com/elastic/elasticsearch/issues/63080 is done\n+     * Do not rely on nulls\n+     *\n+     * @return a {@link ParsedMediaType} if the header could be parsed.\n+     * @throws IllegalArgumentException if the header is malformed\n+     */\n+    public static ParsedMediaType parseMediaType(String headerValue) {\n+        if (DEFAULT_ACCEPT_STRING.equals(headerValue) || \"*/*\".equals(headerValue)) {\n+            return null;\n+        }\n+        if (headerValue != null) {\n+            final String[] elements = headerValue.toLowerCase(Locale.ROOT).split(\"[\\\\s\\\\t]*;\");\n+\n+            final String[] splitMediaType = elements[0].split(\"/\");\n+            if ((splitMediaType.length == 2 && TCHAR_PATTERN.matcher(splitMediaType[0].trim()).matches()\n+                && TCHAR_PATTERN.matcher(splitMediaType[1].trim()).matches()) == false) {\n+                throw new IllegalArgumentException(\"invalid media type [\" + headerValue + \"]\");\n+            }\n+            if (elements.length == 1) {\n+                return new ParsedMediaType(splitMediaType[0].trim(), splitMediaType[1].trim(), Collections.emptyMap());\n+            } else {\n+                Map<String, String> parameters = new HashMap<>();\n+                for (int i = 1; i < elements.length; i++) {\n+                    String paramsAsString = elements[i].trim();\n+                    if (paramsAsString.isEmpty()) {\n+                        continue;\n+                    }\n+                    // intentionally allowing to have spaces around `=`\n+                    // https://tools.ietf.org/html/rfc7231#section-3.1.1.1 disallows this\n+                    String[] keyValueParam = elements[i].trim().split(\"=\");\n+                    if (keyValueParam.length == 2) {\n+                        String parameterName = keyValueParam[0].toLowerCase(Locale.ROOT).trim();\n+                        String parameterValue = keyValueParam[1].toLowerCase(Locale.ROOT).trim();\n+                        parameters.put(parameterName, parameterValue);\n+                    } else {\n+                        throw new IllegalArgumentException(\"invalid parameters for header [\" + headerValue + \"]\");\n+                    }\n+                }\n+                return new ParsedMediaType(splitMediaType[0].trim().toLowerCase(Locale.ROOT),\n+                    splitMediaType[1].trim().toLowerCase(Locale.ROOT), parameters);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Resolves this instance to a MediaType instance defined in given MediaTypeRegistry.\n+     * Performs validation against parameters.\n+     * @param mediaTypeRegistry a registry where a mapping between a raw media type to an instance MediaType is defined\n+     * @return a MediaType instance or null if no media type could be found or if a known parameter do not passes validation\n+     */\n+    public  <T extends MediaType> T toMediaType(MediaTypeRegistry<T> mediaTypeRegistry) {\n+        T type = mediaTypeRegistry.typeWithSubtypeToMediaType(mediaTypeWithoutParameters());\n+        if (type != null) {\n+\n+            Map<String, Pattern> registeredParams = mediaTypeRegistry.parametersFor(mediaTypeWithoutParameters());\n+            for (Map.Entry<String, String> givenParamEntry : parameters.entrySet()) {\n+                if (isValidParameter(givenParamEntry.getKey(), givenParamEntry.getValue(), registeredParams) == false) {\n+                    return null;\n+                }\n+            }\n+            return type;\n+        }\n+        return null;\n+    }\n+\n+    private boolean isValidParameter(String paramName, String value, Map<String, Pattern> registeredParams) {\n+        if(registeredParams.containsKey(paramName)){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc61731ba05c6d2338ff46cf3f3bf665b334c525"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYzMTIyNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                default MediaTypeRegistry<? extends MediaType> validAcceptMediaTypes(){\n          \n          \n            \n                default MediaTypeRegistry<? extends MediaType> validAcceptMediaTypes() {", "url": "https://github.com/elastic/elasticsearch/pull/64406#discussion_r517631225", "createdAt": "2020-11-04T21:06:07Z", "author": {"login": "jaymode"}, "path": "server/src/main/java/org/elasticsearch/rest/RestHandler.java", "diffHunk": "@@ -99,6 +102,10 @@ default boolean allowSystemIndexAccessByDefault() {\n         return false;\n     }\n \n+    default MediaTypeRegistry<? extends MediaType> validAcceptMediaTypes(){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc61731ba05c6d2338ff46cf3f3bf665b334c525"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYzMTMzOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    }catch (IllegalArgumentException e){\n          \n          \n            \n                    } catch (IllegalArgumentException e) {", "url": "https://github.com/elastic/elasticsearch/pull/64406#discussion_r517631339", "createdAt": "2020-11-04T21:06:22Z", "author": {"login": "jaymode"}, "path": "server/src/main/java/org/elasticsearch/rest/RestRequest.java", "diffHunk": "@@ -86,14 +88,14 @@ protected RestRequest(NamedXContentRegistry xContentRegistry, Map<String, String\n \n     private RestRequest(NamedXContentRegistry xContentRegistry, Map<String, String> params, String path,\n                         Map<String, List<String>> headers, HttpRequest httpRequest, HttpChannel httpChannel, long requestId) {\n-        final XContentType xContentType;\n-        try {\n-            xContentType = parseContentType(headers.get(\"Content-Type\"));\n-        } catch (final IllegalArgumentException e) {\n-            throw new ContentTypeHeaderException(e);\n-        }\n-        if (xContentType != null) {\n-            this.xContentType.set(xContentType);\n+        try{\n+            this.parsedAccept = parseHeaderWithMediaType(httpRequest.getHeaders(), \"Accept\");\n+            this.parsedContentType = parseHeaderWithMediaType(httpRequest.getHeaders(), \"Content-Type\");\n+            if (parsedContentType != null) {\n+                this.xContentType.set(parsedContentType.toMediaType(XContentType.MEDIA_TYPE_REGISTRY));\n+            }\n+        }catch (IllegalArgumentException e){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc61731ba05c6d2338ff46cf3f3bf665b334c525"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYzMTQ5OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if(request.getParsedAccept() != null){\n          \n          \n            \n                    if (request.getParsedAccept() != null) {", "url": "https://github.com/elastic/elasticsearch/pull/64406#discussion_r517631499", "createdAt": "2020-11-04T21:06:45Z", "author": {"login": "jaymode"}, "path": "server/src/main/java/org/elasticsearch/rest/action/cat/RestTable.java", "diffHunk": "@@ -51,18 +51,21 @@\n \n     public static RestResponse buildResponse(Table table, RestChannel channel) throws Exception {\n         RestRequest request = channel.request();\n-        XContentType xContentType = getXContentType(request);\n+        XContentType xContentType = getResponseContentType(request);\n         if (xContentType != null) {\n             return buildXContentBuilder(table, channel);\n         }\n         return buildTextPlainResponse(table, channel);\n     }\n \n-    private static XContentType getXContentType(RestRequest request) {\n+    private static XContentType getResponseContentType(RestRequest request) {\n         if (request.hasParam(\"format\")) {\n             return XContentType.fromFormat(request.param(\"format\"));\n         }\n-        return XContentType.fromMediaType(request.header(\"Accept\"));\n+        if(request.getParsedAccept() != null){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc61731ba05c6d2338ff46cf3f3bf665b334c525"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYzMTYyOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public MediaTypeRegistry<? extends MediaType> validAcceptMediaTypes(){\n          \n          \n            \n                public MediaTypeRegistry<? extends MediaType> validAcceptMediaTypes() {", "url": "https://github.com/elastic/elasticsearch/pull/64406#discussion_r517631628", "createdAt": "2020-11-04T21:07:00Z", "author": {"login": "jaymode"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/plugin/RestSqlQueryAction.java", "diffHunk": "@@ -44,6 +45,10 @@\n             new Route(POST, Protocol.SQL_QUERY_REST_ENDPOINT));\n     }\n \n+    public MediaTypeRegistry<? extends MediaType> validAcceptMediaTypes(){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc61731ba05c6d2338ff46cf3f3bf665b334c525"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYzMTgwNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    }catch (IllegalArgumentException e){\n          \n          \n            \n                    } catch (IllegalArgumentException e) {", "url": "https://github.com/elastic/elasticsearch/pull/64406#discussion_r517631805", "createdAt": "2020-11-04T21:07:25Z", "author": {"login": "jaymode"}, "path": "x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/common/http/HttpResponse.java", "diffHunk": "@@ -105,7 +105,12 @@ public XContentType xContentType() {\n         if (values == null || values.length == 0) {\n             return null;\n         }\n-        return XContentType.fromMediaType(values[0]);\n+        try {\n+            return XContentType.fromMediaType(values[0]);\n+        }catch (IllegalArgumentException e){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc61731ba05c6d2338ff46cf3f3bf665b334c525"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYzMjA5Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            new HeaderValue(VENDOR_APPLICATION_PREFIX +\"json\",\n          \n          \n            \n                            new HeaderValue(VENDOR_APPLICATION_PREFIX + \"json\",", "url": "https://github.com/elastic/elasticsearch/pull/64406#discussion_r517632096", "createdAt": "2020-11-04T21:08:04Z", "author": {"login": "jaymode"}, "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java", "diffHunk": "@@ -47,14 +47,26 @@ public String mediaType() {\n         }\n \n         @Override\n-        public String subtype() {\n+        public String queryParameter() {\n             return \"json\";\n         }\n \n         @Override\n         public XContent xContent() {\n             return JsonXContent.jsonXContent;\n         }\n+\n+        @Override\n+        public Set<HeaderValue> headerValues() {\n+            return Set.of(\n+                new HeaderValue(\"application/json\"),\n+                new HeaderValue(\"application/x-ndjson\"),\n+                new HeaderValue(\"application/*\"),\n+                new HeaderValue(VENDOR_APPLICATION_PREFIX +\"json\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc61731ba05c6d2338ff46cf3f3bf665b334c525"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYzMjE4NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            new HeaderValue(VENDOR_APPLICATION_PREFIX +\"x-ndjson\",\n          \n          \n            \n                            new HeaderValue(VENDOR_APPLICATION_PREFIX + \"x-ndjson\",", "url": "https://github.com/elastic/elasticsearch/pull/64406#discussion_r517632185", "createdAt": "2020-11-04T21:08:15Z", "author": {"login": "jaymode"}, "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java", "diffHunk": "@@ -47,14 +47,26 @@ public String mediaType() {\n         }\n \n         @Override\n-        public String subtype() {\n+        public String queryParameter() {\n             return \"json\";\n         }\n \n         @Override\n         public XContent xContent() {\n             return JsonXContent.jsonXContent;\n         }\n+\n+        @Override\n+        public Set<HeaderValue> headerValues() {\n+            return Set.of(\n+                new HeaderValue(\"application/json\"),\n+                new HeaderValue(\"application/x-ndjson\"),\n+                new HeaderValue(\"application/*\"),\n+                new HeaderValue(VENDOR_APPLICATION_PREFIX +\"json\",\n+                    Map.of(COMPATIBLE_WITH_PARAMETER_NAME, VERSION_PATTERN)),\n+                new HeaderValue(VENDOR_APPLICATION_PREFIX +\"x-ndjson\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc61731ba05c6d2338ff46cf3f3bf665b334c525"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYzMjcyMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            new HeaderValue(VENDOR_APPLICATION_PREFIX +\"smile\",\n          \n          \n            \n                            new HeaderValue(VENDOR_APPLICATION_PREFIX + \"smile\",", "url": "https://github.com/elastic/elasticsearch/pull/64406#discussion_r517632721", "createdAt": "2020-11-04T21:09:31Z", "author": {"login": "jaymode"}, "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java", "diffHunk": "@@ -66,14 +78,22 @@ public String mediaTypeWithoutParameters() {\n         }\n \n         @Override\n-        public String subtype() {\n+        public String queryParameter() {\n             return \"smile\";\n         }\n \n         @Override\n         public XContent xContent() {\n             return SmileXContent.smileXContent;\n         }\n+\n+        @Override\n+        public Set<HeaderValue> headerValues() {\n+            return Set.of(\n+                new HeaderValue(\"application/smile\"),\n+                new HeaderValue(VENDOR_APPLICATION_PREFIX +\"smile\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc61731ba05c6d2338ff46cf3f3bf665b334c525"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYzMjgxMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            new HeaderValue(VENDOR_APPLICATION_PREFIX +\"yaml\",\n          \n          \n            \n                            new HeaderValue(VENDOR_APPLICATION_PREFIX + \"yaml\",", "url": "https://github.com/elastic/elasticsearch/pull/64406#discussion_r517632812", "createdAt": "2020-11-04T21:09:41Z", "author": {"login": "jaymode"}, "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java", "diffHunk": "@@ -85,14 +105,22 @@ public String mediaTypeWithoutParameters() {\n         }\n \n         @Override\n-        public String subtype() {\n+        public String queryParameter() {\n             return \"yaml\";\n         }\n \n         @Override\n         public XContent xContent() {\n             return YamlXContent.yamlXContent;\n         }\n+\n+        @Override\n+        public Set<HeaderValue> headerValues() {\n+            return Set.of(\n+                new HeaderValue(\"application/yaml\"),\n+                new HeaderValue(VENDOR_APPLICATION_PREFIX +\"yaml\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc61731ba05c6d2338ff46cf3f3bf665b334c525"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYzMjg5Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            new HeaderValue(VENDOR_APPLICATION_PREFIX +\"cbor\",\n          \n          \n            \n                            new HeaderValue(VENDOR_APPLICATION_PREFIX + \"cbor\",", "url": "https://github.com/elastic/elasticsearch/pull/64406#discussion_r517632897", "createdAt": "2020-11-04T21:09:53Z", "author": {"login": "jaymode"}, "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java", "diffHunk": "@@ -104,45 +132,36 @@ public String mediaTypeWithoutParameters() {\n         }\n \n         @Override\n-        public String subtype() {\n+        public String queryParameter() {\n             return \"cbor\";\n         }\n \n         @Override\n         public XContent xContent() {\n             return CborXContent.cborXContent;\n         }\n+\n+        @Override\n+        public Set<HeaderValue> headerValues() {\n+            return Set.of(\n+                new HeaderValue(\"application/cbor\"),\n+                new HeaderValue(VENDOR_APPLICATION_PREFIX +\"cbor\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc61731ba05c6d2338ff46cf3f3bf665b334c525"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYzMzEyNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new IllegalArgumentException(\"Incorrect header [\"+headerName+\"]. \" +\n          \n          \n            \n                        throw new IllegalArgumentException(\"Incorrect header [\" + headerName + \"]. \" +", "url": "https://github.com/elastic/elasticsearch/pull/64406#discussion_r517633126", "createdAt": "2020-11-04T21:10:21Z", "author": {"login": "jaymode"}, "path": "server/src/main/java/org/elasticsearch/rest/RestRequest.java", "diffHunk": "@@ -104,6 +106,23 @@ private RestRequest(NamedXContentRegistry xContentRegistry, Map<String, String>\n         this.requestId = requestId;\n     }\n \n+    private static @Nullable ParsedMediaType parseHeaderWithMediaType(Map<String, List<String>> headers, String headerName) {\n+        //TODO: make all usages of headers case-insensitive\n+        List<String> header = headers.get(headerName);\n+        if (header == null || header.isEmpty()) {\n+            return null;\n+        } else if (header.size() > 1) {\n+            throw new IllegalArgumentException(\"Incorrect header [\"+headerName+\"]. \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc61731ba05c6d2338ff46cf3f3bf665b334c525"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzY1NzQ5NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    try{\n          \n          \n            \n                    try {", "url": "https://github.com/elastic/elasticsearch/pull/64406#discussion_r517657495", "createdAt": "2020-11-04T22:03:18Z", "author": {"login": "jaymode"}, "path": "server/src/main/java/org/elasticsearch/rest/RestRequest.java", "diffHunk": "@@ -86,14 +88,14 @@ protected RestRequest(NamedXContentRegistry xContentRegistry, Map<String, String\n \n     private RestRequest(NamedXContentRegistry xContentRegistry, Map<String, String> params, String path,\n                         Map<String, List<String>> headers, HttpRequest httpRequest, HttpChannel httpChannel, long requestId) {\n-        final XContentType xContentType;\n-        try {\n-            xContentType = parseContentType(headers.get(\"Content-Type\"));\n-        } catch (final IllegalArgumentException e) {\n-            throw new ContentTypeHeaderException(e);\n-        }\n-        if (xContentType != null) {\n-            this.xContentType.set(xContentType);\n+        try{", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc61731ba05c6d2338ff46cf3f3bf665b334c525"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzY1OTI1OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if(request.getParsedAccept() != null) {\n          \n          \n            \n                    if (request.getParsedAccept() != null) {", "url": "https://github.com/elastic/elasticsearch/pull/64406#discussion_r517659258", "createdAt": "2020-11-04T22:07:14Z", "author": {"login": "jaymode"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/plugin/SqlMediaTypeParser.java", "diffHunk": "@@ -42,25 +34,19 @@\n      * isn't then we use the {@code Content-Type} header which is required.\n      */\n     public MediaType getMediaType(RestRequest request, SqlQueryRequest sqlRequest) {\n-\n         if (Mode.isDedicatedClient(sqlRequest.requestInfo().mode())\n             && (sqlRequest.binaryCommunication() == null || sqlRequest.binaryCommunication())) {\n             // enforce CBOR response for drivers and CLI (unless instructed differently through the config param)\n             return XContentType.CBOR;\n         } else if (request.hasParam(URL_PARAM_FORMAT)) {\n-            return validateColumnarRequest(sqlRequest.columnar(), parser.fromFormat(request.param(URL_PARAM_FORMAT)));\n-        }\n-        if (request.getHeaders().containsKey(\"Accept\")) {\n-            String accept = request.header(\"Accept\");\n-            // */* means \"I don't care\" which we should treat like not specifying the header\n-            if (\"*/*\".equals(accept) == false) {\n-                return validateColumnarRequest(sqlRequest.columnar(), parser.fromMediaType(accept));\n-            }\n+            return validateColumnarRequest(sqlRequest.columnar(),\n+                MEDIA_TYPE_REGISTRY.queryParamToMediaType(request.param(URL_PARAM_FORMAT)));\n         }\n \n-        String contentType = request.header(\"Content-Type\");\n-        assert contentType != null : \"The Content-Type header is required\";\n-        return validateColumnarRequest(sqlRequest.columnar(), parser.fromMediaType(contentType));\n+        if(request.getParsedAccept() != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc61731ba05c6d2338ff46cf3f3bf665b334c525"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzY2Mjk2Ng==", "bodyText": "this is a not well documented fact, but by default Netty uses a case insensitive hashing strategy for retrieval of headers. Checkout the DefaultHttpHeaders class if you're interested. Due to our use of Netty for HTTP parsing we also get this benefit in the nio transport. Also, see the Netty4HttpRequest/NioHttpRequest.HttpHeadersMap class.", "url": "https://github.com/elastic/elasticsearch/pull/64406#discussion_r517662966", "createdAt": "2020-11-04T22:15:47Z", "author": {"login": "jaymode"}, "path": "server/src/main/java/org/elasticsearch/rest/RestRequest.java", "diffHunk": "@@ -104,6 +106,23 @@ private RestRequest(NamedXContentRegistry xContentRegistry, Map<String, String>\n         this.requestId = requestId;\n     }\n \n+    private static @Nullable ParsedMediaType parseHeaderWithMediaType(Map<String, List<String>> headers, String headerName) {\n+        //TODO: make all usages of headers case-insensitive", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc61731ba05c6d2338ff46cf3f3bf665b334c525"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzY2Mzg2Ng==", "bodyText": "I'd love if we can move the comment from the usage to a method level documentation that expands on why we use null; I get it now but at some point it won't be obvious anymore", "url": "https://github.com/elastic/elasticsearch/pull/64406#discussion_r517663866", "createdAt": "2020-11-04T22:17:47Z", "author": {"login": "jaymode"}, "path": "test/framework/src/main/java/org/elasticsearch/test/rest/yaml/ClientYamlTestResponse.java", "diffHunk": "@@ -71,6 +72,14 @@ public ClientYamlTestResponse(Response response) throws IOException {\n         }\n     }\n \n+    private XContentType getContentTypeIgnoreExceptions(String contentType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc61731ba05c6d2338ff46cf3f3bf665b334c525"}, "originalPosition": 14}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4a3138dd46c7826e902f0375e2a61d5aef036c70", "author": {"user": {"login": "pgomulka", "name": "Przemyslaw Gomulka"}}, "url": "https://github.com/elastic/elasticsearch/commit/4a3138dd46c7826e902f0375e2a61d5aef036c70", "committedDate": "2020-11-05T07:33:33Z", "message": "Apply suggestions from code review\n\nCo-authored-by: Jay Modi <jaymode@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0b565e566cfb0555b25d02e082105bb482e7e6fd", "author": {"user": {"login": "pgomulka", "name": "Przemyslaw Gomulka"}}, "url": "https://github.com/elastic/elasticsearch/commit/0b565e566cfb0555b25d02e082105bb482e7e6fd", "committedDate": "2020-11-05T08:02:03Z", "message": "javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b35ad2ce54f0577edd332d8ebedb4fa817475e71", "author": {"user": {"login": "pgomulka", "name": "Przemyslaw Gomulka"}}, "url": "https://github.com/elastic/elasticsearch/commit/b35ad2ce54f0577edd332d8ebedb4fa817475e71", "committedDate": "2020-11-05T08:02:35Z", "message": "Merge branch 'master' into compat/introduce_per_endpoint_media_types"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b908bfebd14c7157aeb7592f17c4907d8e9c6a7f", "author": {"user": {"login": "pgomulka", "name": "Przemyslaw Gomulka"}}, "url": "https://github.com/elastic/elasticsearch/commit/b908bfebd14c7157aeb7592f17c4907d8e9c6a7f", "committedDate": "2020-11-05T08:03:20Z", "message": "Merge branch 'compat/introduce_per_endpoint_media_types' of github.com:pgomulka/elasticsearch into compat/introduce_per_endpoint_media_types"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 864, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}