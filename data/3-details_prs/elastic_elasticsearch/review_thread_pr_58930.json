{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQzNTcxNzYy", "number": 58930, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxODoxNToyN1rOELTwVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNDowNjoyNVrOEM6SMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMjkzNDYzOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/analytics/src/main/java/org/elasticsearch/xpack/analytics/aggregations/bucket/histogram/HistoBackedHistogramAggregator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxODoxNToyN1rOGs2A4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxMzo0MzoxN1rOGuorlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY3NTQ4OA==", "bodyText": "Is this the correct place to disallow sub-aggregations?", "url": "https://github.com/elastic/elasticsearch/pull/58930#discussion_r449675488", "createdAt": "2020-07-03T18:15:27Z", "author": {"login": "csoulios"}, "path": "x-pack/plugin/analytics/src/main/java/org/elasticsearch/xpack/analytics/aggregations/bucket/histogram/HistoBackedHistogramAggregator.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.analytics.aggregations.bucket.histogram;\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.elasticsearch.index.fielddata.HistogramValue;\n+import org.elasticsearch.index.fielddata.HistogramValues;\n+import org.elasticsearch.search.aggregations.Aggregator;\n+import org.elasticsearch.search.aggregations.AggregatorFactories;\n+import org.elasticsearch.search.aggregations.BucketOrder;\n+import org.elasticsearch.search.aggregations.LeafBucketCollector;\n+import org.elasticsearch.search.aggregations.LeafBucketCollectorBase;\n+import org.elasticsearch.search.aggregations.bucket.histogram.AbstractHistogramAggregator;\n+import org.elasticsearch.search.aggregations.support.ValuesSourceConfig;\n+import org.elasticsearch.search.internal.SearchContext;\n+import org.elasticsearch.xpack.analytics.aggregations.support.HistogramValuesSource;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+public class HistoBackedHistogramAggregator extends AbstractHistogramAggregator {\n+\n+    private final HistogramValuesSource.Histogram valuesSource;\n+\n+    public HistoBackedHistogramAggregator(\n+        String name,\n+        AggregatorFactories factories,\n+        double interval,\n+        double offset,\n+        BucketOrder order,\n+        boolean keyed,\n+        long minDocCount,\n+        double minBound,\n+        double maxBound,\n+        ValuesSourceConfig valuesSourceConfig,\n+        SearchContext context,\n+        Aggregator parent,\n+        boolean collectsFromSingleBucket,\n+        Map<String, Object> metadata) throws IOException {\n+        super(name, factories, interval, offset, order, keyed, minDocCount, minBound, maxBound,\n+            valuesSourceConfig.format(), context, parent, collectsFromSingleBucket, metadata);\n+\n+        // TODO: Stop using null here\n+        this.valuesSource = valuesSourceConfig.hasValues() ? (HistogramValuesSource.Histogram) valuesSourceConfig.getValuesSource() : null;\n+\n+        // Sub aggregations are not allowed when running histogram agg over histograms\n+        if (subAggregators().length > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51ba48d44f3b49aeaf5e070b5d842effb35e52c1"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTU1NDE5OA==", "bodyText": "Yeah, I think this is probably the best location since we don't have access to the factory from the plugin", "url": "https://github.com/elastic/elasticsearch/pull/58930#discussion_r451554198", "createdAt": "2020-07-08T13:43:17Z", "author": {"login": "polyfractal"}, "path": "x-pack/plugin/analytics/src/main/java/org/elasticsearch/xpack/analytics/aggregations/bucket/histogram/HistoBackedHistogramAggregator.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.analytics.aggregations.bucket.histogram;\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.elasticsearch.index.fielddata.HistogramValue;\n+import org.elasticsearch.index.fielddata.HistogramValues;\n+import org.elasticsearch.search.aggregations.Aggregator;\n+import org.elasticsearch.search.aggregations.AggregatorFactories;\n+import org.elasticsearch.search.aggregations.BucketOrder;\n+import org.elasticsearch.search.aggregations.LeafBucketCollector;\n+import org.elasticsearch.search.aggregations.LeafBucketCollectorBase;\n+import org.elasticsearch.search.aggregations.bucket.histogram.AbstractHistogramAggregator;\n+import org.elasticsearch.search.aggregations.support.ValuesSourceConfig;\n+import org.elasticsearch.search.internal.SearchContext;\n+import org.elasticsearch.xpack.analytics.aggregations.support.HistogramValuesSource;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+public class HistoBackedHistogramAggregator extends AbstractHistogramAggregator {\n+\n+    private final HistogramValuesSource.Histogram valuesSource;\n+\n+    public HistoBackedHistogramAggregator(\n+        String name,\n+        AggregatorFactories factories,\n+        double interval,\n+        double offset,\n+        BucketOrder order,\n+        boolean keyed,\n+        long minDocCount,\n+        double minBound,\n+        double maxBound,\n+        ValuesSourceConfig valuesSourceConfig,\n+        SearchContext context,\n+        Aggregator parent,\n+        boolean collectsFromSingleBucket,\n+        Map<String, Object> metadata) throws IOException {\n+        super(name, factories, interval, offset, order, keyed, minDocCount, minBound, maxBound,\n+            valuesSourceConfig.format(), context, parent, collectsFromSingleBucket, metadata);\n+\n+        // TODO: Stop using null here\n+        this.valuesSource = valuesSourceConfig.hasValues() ? (HistogramValuesSource.Histogram) valuesSourceConfig.getValuesSource() : null;\n+\n+        // Sub aggregations are not allowed when running histogram agg over histograms\n+        if (subAggregators().length > 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY3NTQ4OA=="}, "originalCommit": {"oid": "51ba48d44f3b49aeaf5e070b5d842effb35e52c1"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwNzk4OTc5OnYy", "diffSide": "RIGHT", "path": "docs/reference/aggregations/bucket/histogram-aggregation.asciidoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxODowNTowM1rOGth0ig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxODowNTowM1rOGth0ig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM5MzIyNg==", "bodyText": "Perhaps we need to improve wording here. This is a subtle concept and we must be as clear as possible on the message", "url": "https://github.com/elastic/elasticsearch/pull/58930#discussion_r450393226", "createdAt": "2020-07-06T18:05:03Z", "author": {"login": "csoulios"}, "path": "docs/reference/aggregations/bucket/histogram-aggregation.asciidoc", "diffHunk": "@@ -286,3 +286,92 @@ POST /sales/_search?size=0\n // TEST[setup:sales]\n \n <1> Documents without a value in the `quantity` field will fall into the same bucket as documents that have the value `0`.\n+\n+[[search-aggregations-bucket-histogram-aggregation-histogram-fields]]\n+==== Histogram fields\n+\n+Running a histogram aggregation over histogram fields computes the total number of counts for each interval.\n+\n+For example, for the following index that stores pre-aggregated histograms with latency metrics (in milliseconds) for different networks:\n+\n+[source,console]\n+--------------------------------------------------\n+PUT metrics_index/_doc/1\n+{\n+  \"network.name\" : \"net-1\",\n+  \"latency_histo\" : {\n+      \"values\" : [1, 3, 8, 12, 15],\n+      \"counts\" : [3, 7, 23, 12, 6]\n+   }\n+}\n+\n+PUT metrics_index/_doc/2\n+{\n+  \"network.name\" : \"net-2\",\n+  \"latency_histo\" : {\n+      \"values\" : [1, 6, 8, 12, 14],\n+      \"counts\" : [8, 17, 8, 7, 6]\n+   }\n+}\n+\n+POST /metrics_index/_search?size=0\n+{\n+    \"aggs\" : {\n+        \"latency_buckets\" : {\n+            \"histogram\" : {\n+                \"field\" : \"latency_histo\",\n+                \"interval\" : 5\n+            }\n+        }\n+    }\n+}\n+--------------------------------------------------\n+\n+\n+The `histogram` aggregation will sum the counts of each interval computed based on the `values` and\n+return the following output:\n+\n+[source,console-result]\n+--------------------------------------------------\n+{\n+    ...\n+    \"aggregations\": {\n+        \"prices\" : {\n+            \"buckets\": [\n+                {\n+                    \"key\": 0.0,\n+                    \"doc_count\": 18\n+                },\n+                {\n+                    \"key\": 5.0,\n+                    \"doc_count\": 48\n+                },\n+                {\n+                    \"key\": 10.0,\n+                    \"doc_count\": 25\n+                },\n+                {\n+                    \"key\": 15.0,\n+                    \"doc_count\": 6\n+                }\n+            ]\n+        }\n+    }\n+}\n+--------------------------------------------------\n+// TESTRESPONSE[skip:test not setup]\n+\n+[IMPORTANT]\n+========\n+Histogram aggregation is a bucket aggregation, which partitions documents into buckets rather than calculating metrics over fields like\n+metrics aggregations do. Each bucket represents a collection of documents which sub-aggregations can run on.\n+On the other hand, a histogram field is a pre-aggregated field representing multiple values inside a single field:\n+buckets of numerical data and a count of items/documents for each bucket. This mismatch between the histogram aggregations expected input\n+(expecting raw documents) and the histogram field (that provides summary information) limits the outcome of the aggregation\n+to only the doc counts for each bucket.\n+\n+\n+**Consequently, when executing a histogram aggregation over a histogram field, no sub-aggregations are supported.**\n+========", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc3163ca6ba4ed510247d5ecf9c0987cb45b6bee"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxOTcxODI1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/analytics/src/main/java/org/elasticsearch/xpack/analytics/aggregations/bucket/histogram/HistoBackedHistogramAggregator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNDowMjo1NlrOGvSoRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNDowMjo1NlrOGvSoRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjI0MTQ3Nw==", "bodyText": "I think rather than iterating count times, we can lookup the bucketOrd once, call collectExistingBucket() / collectBucket() as appropriate, and then finally call incrementBucketDocCount() with count-1.  That way we don't have to keep re-adding to the same ord just to increment the count, and should be a bit faster I think.", "url": "https://github.com/elastic/elasticsearch/pull/58930#discussion_r452241477", "createdAt": "2020-07-09T14:02:56Z", "author": {"login": "polyfractal"}, "path": "x-pack/plugin/analytics/src/main/java/org/elasticsearch/xpack/analytics/aggregations/bucket/histogram/HistoBackedHistogramAggregator.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.analytics.aggregations.bucket.histogram;\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.elasticsearch.index.fielddata.HistogramValue;\n+import org.elasticsearch.index.fielddata.HistogramValues;\n+import org.elasticsearch.search.aggregations.Aggregator;\n+import org.elasticsearch.search.aggregations.AggregatorFactories;\n+import org.elasticsearch.search.aggregations.BucketOrder;\n+import org.elasticsearch.search.aggregations.CardinalityUpperBound;\n+import org.elasticsearch.search.aggregations.LeafBucketCollector;\n+import org.elasticsearch.search.aggregations.LeafBucketCollectorBase;\n+import org.elasticsearch.search.aggregations.bucket.histogram.AbstractHistogramAggregator;\n+import org.elasticsearch.search.aggregations.support.ValuesSourceConfig;\n+import org.elasticsearch.search.internal.SearchContext;\n+import org.elasticsearch.xpack.analytics.aggregations.support.HistogramValuesSource;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+public class HistoBackedHistogramAggregator extends AbstractHistogramAggregator {\n+\n+    private final HistogramValuesSource.Histogram valuesSource;\n+\n+    public HistoBackedHistogramAggregator(\n+        String name,\n+        AggregatorFactories factories,\n+        double interval,\n+        double offset,\n+        BucketOrder order,\n+        boolean keyed,\n+        long minDocCount,\n+        double minBound,\n+        double maxBound,\n+        ValuesSourceConfig valuesSourceConfig,\n+        SearchContext context,\n+        Aggregator parent,\n+        CardinalityUpperBound cardinalityUpperBound,\n+        Map<String, Object> metadata) throws IOException {\n+        super(name, factories, interval, offset, order, keyed, minDocCount, minBound, maxBound,\n+            valuesSourceConfig.format(), context, parent, cardinalityUpperBound, metadata);\n+\n+        // TODO: Stop using null here\n+        this.valuesSource = valuesSourceConfig.hasValues() ? (HistogramValuesSource.Histogram) valuesSourceConfig.getValuesSource() : null;\n+\n+        // Sub aggregations are not allowed when running histogram agg over histograms\n+        if (subAggregators().length > 0) {\n+            throw new IllegalArgumentException(\"Histogram aggregation on histogram fields does not support sub-aggregations\");\n+        }\n+    }\n+\n+    @Override\n+    public LeafBucketCollector getLeafCollector(LeafReaderContext ctx,\n+            final LeafBucketCollector sub) throws IOException {\n+        if (valuesSource == null) {\n+            return LeafBucketCollector.NO_OP_COLLECTOR;\n+        }\n+\n+        final HistogramValues values = valuesSource.getHistogramValues(ctx);\n+        return new LeafBucketCollectorBase(sub, values) {\n+            @Override\n+            public void collect(int doc, long owningBucketOrd) throws IOException {\n+                if (values.advanceExact(doc)) {\n+                    final HistogramValue sketch = values.histogram();\n+\n+                    double previousKey = Double.NEGATIVE_INFINITY;\n+                    while (sketch.next()) {\n+                        final double value = sketch.value();\n+                        final int count = sketch.count();\n+\n+                        double key = Math.floor((value - offset) / interval);\n+                        assert key >= previousKey;\n+                        for (int i = 0; i < count; ++i) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bce6a8f2305dcf2ad25160013c8c98ea1e711be2"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxOTczMjk2OnYy", "diffSide": "RIGHT", "path": "docs/reference/aggregations/bucket/histogram-aggregation.asciidoc", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNDowNjoyNVrOGvSxmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNDowNjoyNVrOGvSxmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjI0Mzg2Nw==", "bodyText": "I thought about it some more and can't think of a better/clearer way to express this concept... so \ud83d\udc4d and maybe we can tweak it later if we think of a better way.  I think it's clear what the limitations are so I'm not too concerned.", "url": "https://github.com/elastic/elasticsearch/pull/58930#discussion_r452243867", "createdAt": "2020-07-09T14:06:25Z", "author": {"login": "polyfractal"}, "path": "docs/reference/aggregations/bucket/histogram-aggregation.asciidoc", "diffHunk": "@@ -286,3 +286,93 @@ POST /sales/_search?size=0\n // TEST[setup:sales]\n \n <1> Documents without a value in the `quantity` field will fall into the same bucket as documents that have the value `0`.\n+\n+[[search-aggregations-bucket-histogram-aggregation-histogram-fields]]\n+==== Histogram fields\n+\n+Running a histogram aggregation over histogram fields computes the total number of counts for each interval.\n+\n+For example, executing a histogram aggregation against the following index that stores pre-aggregated histograms\n+with latency metrics (in milliseconds) for different networks:\n+\n+[source,console]\n+--------------------------------------------------\n+PUT metrics_index/_doc/1\n+{\n+  \"network.name\" : \"net-1\",\n+  \"latency_histo\" : {\n+      \"values\" : [1, 3, 8, 12, 15],\n+      \"counts\" : [3, 7, 23, 12, 6]\n+   }\n+}\n+\n+PUT metrics_index/_doc/2\n+{\n+  \"network.name\" : \"net-2\",\n+  \"latency_histo\" : {\n+      \"values\" : [1, 6, 8, 12, 14],\n+      \"counts\" : [8, 17, 8, 7, 6]\n+   }\n+}\n+\n+POST /metrics_index/_search?size=0\n+{\n+    \"aggs\" : {\n+        \"latency_buckets\" : {\n+            \"histogram\" : {\n+                \"field\" : \"latency_histo\",\n+                \"interval\" : 5\n+            }\n+        }\n+    }\n+}\n+--------------------------------------------------\n+\n+\n+The `histogram` aggregation will sum the counts of each interval computed based on the `values` and\n+return the following output:\n+\n+[source,console-result]\n+--------------------------------------------------\n+{\n+    ...\n+    \"aggregations\": {\n+        \"prices\" : {\n+            \"buckets\": [\n+                {\n+                    \"key\": 0.0,\n+                    \"doc_count\": 18\n+                },\n+                {\n+                    \"key\": 5.0,\n+                    \"doc_count\": 48\n+                },\n+                {\n+                    \"key\": 10.0,\n+                    \"doc_count\": 25\n+                },\n+                {\n+                    \"key\": 15.0,\n+                    \"doc_count\": 6\n+                }\n+            ]\n+        }\n+    }\n+}\n+--------------------------------------------------\n+// TESTRESPONSE[skip:test not setup]\n+\n+[IMPORTANT]\n+========\n+Histogram aggregation is a bucket aggregation, which partitions documents into buckets rather than calculating metrics over fields like", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bce6a8f2305dcf2ad25160013c8c98ea1e711be2"}, "originalPosition": 82}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2139, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}