{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQyNzk3Njg2", "number": 58859, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxNzowMDo1NlrOEKl1Dw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQyMTo0MDowNlrOEKq4Vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NTQxMDA3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/execution/assembler/Matcher.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxNzowMDo1NlrOGruLzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxNzowMDo1NlrOGruLzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ5ODYzNg==", "bodyText": "This used to be inside SequenceRuntime but now it has been extracted and takes care only of matching.", "url": "https://github.com/elastic/elasticsearch/pull/58859#discussion_r448498636", "createdAt": "2020-07-01T17:00:56Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/execution/assembler/Matcher.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.eql.execution.assembler;\n+\n+import org.elasticsearch.common.collect.Tuple;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.search.SearchHit;\n+import org.elasticsearch.xpack.eql.execution.search.Limit;\n+import org.elasticsearch.xpack.eql.execution.search.Ordinal;\n+import org.elasticsearch.xpack.eql.execution.sequence.Sequence;\n+import org.elasticsearch.xpack.eql.execution.sequence.SequenceStateMachine;\n+import org.elasticsearch.xpack.eql.session.Payload;\n+\n+import java.util.List;\n+\n+/**\n+ * Executable tracking sequences at runtime.\n+ */\n+class Matcher {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eedae623945a611f15beb62fd6aea2d90bef96a"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NTQxNzU1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/execution/assembler/TumblingWindow.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxNzowMzoxMVrOGruQlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxNzowMzoxMVrOGruQlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ5OTg2MA==", "bodyText": "This is the querying/pagination part from SequenceRuntime; in this version it introduces two new things:\n\nrange queries to the current window (instead of being open ended which made it hard to reason on whether a sequence should be matched or data be discarded)\npagination/advancement. If there's no more data in the current query, keep looking in the other queries (as long as they have something to match against).", "url": "https://github.com/elastic/elasticsearch/pull/58859#discussion_r448499860", "createdAt": "2020-07-01T17:03:11Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/execution/assembler/TumblingWindow.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.execution.assembler;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.common.collect.Tuple;\n+import org.elasticsearch.search.SearchHit;\n+import org.elasticsearch.xpack.eql.execution.search.Ordinal;\n+import org.elasticsearch.xpack.eql.execution.search.QueryClient;\n+import org.elasticsearch.xpack.eql.execution.sequence.SequenceKey;\n+import org.elasticsearch.xpack.eql.session.Payload;\n+import org.elasticsearch.xpack.eql.util.ReversedIterator;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import static org.elasticsearch.action.ActionListener.wrap;\n+\n+/**\n+ * Time-based window encapsulating query creation and advancement.\n+ * Since queries can return different number of results, to avoid creating incorrect sequences,\n+ * all searches are 'boxed' to a base query.\n+ * The base query is initially the first query - when no results are found, the next query gets promoted.\n+ * \n+ * This allows the window to find any follow-up results even if they are found outside the initial window\n+ * of a base query.\n+ */\n+public class TumblingWindow implements Executable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eedae623945a611f15beb62fd6aea2d90bef96a"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NjIzNTc4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/execution/assembler/ExecutionManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQyMTozOToyM1rOGr2NsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQyMTozOToyM1rOGr2NsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYzMDE5Mg==", "bodyText": "This one doesn't seem to actually be used.", "url": "https://github.com/elastic/elasticsearch/pull/58859#discussion_r448630192", "createdAt": "2020-07-01T21:39:23Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/execution/assembler/ExecutionManager.java", "diffHunk": "@@ -48,27 +47,52 @@ public Executable assemble(List<List<Attribute>> listOfKeys,\n                                Limit limit) {\n         FieldExtractorRegistry extractorRegistry = new FieldExtractorRegistry();\n         \n-        List<Criterion> criteria = new ArrayList<>(plans.size() - 1);\n-        \n         boolean descending = direction == OrderDirection.DESC;\n+\n+        // fields\n+        HitExtractor tsExtractor = timestampExtractor(hitExtractor(timestamp, extractorRegistry));\n+        HitExtractor tbExtractor = Expressions.isPresent(tiebreaker) ? hitExtractor(tiebreaker, extractorRegistry) : null;\n+        // NB: since there's no aliasing inside EQL, the attribute name is the same as the underlying field name\n+        String timestampName = Expressions.name(timestamp);\n+        String tiebreakerName = Expressions.isPresent(tiebreaker) ? Expressions.name(tiebreaker) : null;\n+\n+        Criterion<QueryRequest> base = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8445184607f80c61911b75de709dc0c5ff5c6b0"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NjIzNzY2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/execution/assembler/ExecutionManager.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQyMTo0MDowNlrOGr2O0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMzo1MDowOFrOGsNxmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYzMDQ4MA==", "bodyText": "i > 0", "url": "https://github.com/elastic/elasticsearch/pull/58859#discussion_r448630480", "createdAt": "2020-07-01T21:40:06Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/execution/assembler/ExecutionManager.java", "diffHunk": "@@ -48,27 +47,52 @@ public Executable assemble(List<List<Attribute>> listOfKeys,\n                                Limit limit) {\n         FieldExtractorRegistry extractorRegistry = new FieldExtractorRegistry();\n         \n-        List<Criterion> criteria = new ArrayList<>(plans.size() - 1);\n-        \n         boolean descending = direction == OrderDirection.DESC;\n+\n+        // fields\n+        HitExtractor tsExtractor = timestampExtractor(hitExtractor(timestamp, extractorRegistry));\n+        HitExtractor tbExtractor = Expressions.isPresent(tiebreaker) ? hitExtractor(tiebreaker, extractorRegistry) : null;\n+        // NB: since there's no aliasing inside EQL, the attribute name is the same as the underlying field name\n+        String timestampName = Expressions.name(timestamp);\n+        String tiebreakerName = Expressions.isPresent(tiebreaker) ? Expressions.name(tiebreaker) : null;\n+\n+        Criterion<QueryRequest> base = null;\n+        // secondary criteria\n+        List<Criterion<BoxedQueryRequest>> criteria = new ArrayList<>(plans.size() - 1);\n         \n         // build a criterion for each query\n-        for (int i = 0; i < plans.size() - 1; i++) {\n+        for (int i = 0; i < plans.size(); i++) {\n             List<Attribute> keys = listOfKeys.get(i);\n-            // fields\n-            HitExtractor tsExtractor = timestampExtractor(hitExtractor(timestamp, extractorRegistry));\n-            HitExtractor tbExtractor = Expressions.isPresent(tiebreaker) ? hitExtractor(tiebreaker, extractorRegistry) : null;\n             List<HitExtractor> keyExtractors = hitExtractors(keys, extractorRegistry);\n \n             PhysicalPlan query = plans.get(i);\n             // search query\n-            // TODO: this could be generalized into an exec only query\n-            Check.isTrue(query instanceof EsQueryExec, \"Expected a query but got [{}]\", query.getClass());\n-            QueryRequest request = ((EsQueryExec) query).queryRequest(session);\n-            // base query remains descending, the rest need to flip\n-            criteria.add(new Criterion(request.searchSource(), keyExtractors, tsExtractor, tbExtractor, i > 0 && descending));\n+            if (query instanceof EsQueryExec) {\n+                QueryRequest original = ((EsQueryExec) query).queryRequest(session);\n+                \n+                BoxedQueryRequest boxedRequest = new BoxedQueryRequest(original, timestampName, tiebreakerName);\n+                Criterion<BoxedQueryRequest> criterion =\n+                        new Criterion<>(i, boxedRequest, keyExtractors, tsExtractor, tbExtractor, i> 0 && descending);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8445184607f80c61911b75de709dc0c5ff5c6b0"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODgxNjk3Mg==", "bodyText": "descending can be false so i > 0 && descending != i > 0", "url": "https://github.com/elastic/elasticsearch/pull/58859#discussion_r448816972", "createdAt": "2020-07-02T07:56:37Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/execution/assembler/ExecutionManager.java", "diffHunk": "@@ -48,27 +47,52 @@ public Executable assemble(List<List<Attribute>> listOfKeys,\n                                Limit limit) {\n         FieldExtractorRegistry extractorRegistry = new FieldExtractorRegistry();\n         \n-        List<Criterion> criteria = new ArrayList<>(plans.size() - 1);\n-        \n         boolean descending = direction == OrderDirection.DESC;\n+\n+        // fields\n+        HitExtractor tsExtractor = timestampExtractor(hitExtractor(timestamp, extractorRegistry));\n+        HitExtractor tbExtractor = Expressions.isPresent(tiebreaker) ? hitExtractor(tiebreaker, extractorRegistry) : null;\n+        // NB: since there's no aliasing inside EQL, the attribute name is the same as the underlying field name\n+        String timestampName = Expressions.name(timestamp);\n+        String tiebreakerName = Expressions.isPresent(tiebreaker) ? Expressions.name(tiebreaker) : null;\n+\n+        Criterion<QueryRequest> base = null;\n+        // secondary criteria\n+        List<Criterion<BoxedQueryRequest>> criteria = new ArrayList<>(plans.size() - 1);\n         \n         // build a criterion for each query\n-        for (int i = 0; i < plans.size() - 1; i++) {\n+        for (int i = 0; i < plans.size(); i++) {\n             List<Attribute> keys = listOfKeys.get(i);\n-            // fields\n-            HitExtractor tsExtractor = timestampExtractor(hitExtractor(timestamp, extractorRegistry));\n-            HitExtractor tbExtractor = Expressions.isPresent(tiebreaker) ? hitExtractor(tiebreaker, extractorRegistry) : null;\n             List<HitExtractor> keyExtractors = hitExtractors(keys, extractorRegistry);\n \n             PhysicalPlan query = plans.get(i);\n             // search query\n-            // TODO: this could be generalized into an exec only query\n-            Check.isTrue(query instanceof EsQueryExec, \"Expected a query but got [{}]\", query.getClass());\n-            QueryRequest request = ((EsQueryExec) query).queryRequest(session);\n-            // base query remains descending, the rest need to flip\n-            criteria.add(new Criterion(request.searchSource(), keyExtractors, tsExtractor, tbExtractor, i > 0 && descending));\n+            if (query instanceof EsQueryExec) {\n+                QueryRequest original = ((EsQueryExec) query).queryRequest(session);\n+                \n+                BoxedQueryRequest boxedRequest = new BoxedQueryRequest(original, timestampName, tiebreakerName);\n+                Criterion<BoxedQueryRequest> criterion =\n+                        new Criterion<>(i, boxedRequest, keyExtractors, tsExtractor, tbExtractor, i> 0 && descending);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYzMDQ4MA=="}, "originalCommit": {"oid": "d8445184607f80c61911b75de709dc0c5ff5c6b0"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAxNjIxNw==", "bodyText": "I think it was about the formatting (missing space)", "url": "https://github.com/elastic/elasticsearch/pull/58859#discussion_r449016217", "createdAt": "2020-07-02T13:50:08Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/execution/assembler/ExecutionManager.java", "diffHunk": "@@ -48,27 +47,52 @@ public Executable assemble(List<List<Attribute>> listOfKeys,\n                                Limit limit) {\n         FieldExtractorRegistry extractorRegistry = new FieldExtractorRegistry();\n         \n-        List<Criterion> criteria = new ArrayList<>(plans.size() - 1);\n-        \n         boolean descending = direction == OrderDirection.DESC;\n+\n+        // fields\n+        HitExtractor tsExtractor = timestampExtractor(hitExtractor(timestamp, extractorRegistry));\n+        HitExtractor tbExtractor = Expressions.isPresent(tiebreaker) ? hitExtractor(tiebreaker, extractorRegistry) : null;\n+        // NB: since there's no aliasing inside EQL, the attribute name is the same as the underlying field name\n+        String timestampName = Expressions.name(timestamp);\n+        String tiebreakerName = Expressions.isPresent(tiebreaker) ? Expressions.name(tiebreaker) : null;\n+\n+        Criterion<QueryRequest> base = null;\n+        // secondary criteria\n+        List<Criterion<BoxedQueryRequest>> criteria = new ArrayList<>(plans.size() - 1);\n         \n         // build a criterion for each query\n-        for (int i = 0; i < plans.size() - 1; i++) {\n+        for (int i = 0; i < plans.size(); i++) {\n             List<Attribute> keys = listOfKeys.get(i);\n-            // fields\n-            HitExtractor tsExtractor = timestampExtractor(hitExtractor(timestamp, extractorRegistry));\n-            HitExtractor tbExtractor = Expressions.isPresent(tiebreaker) ? hitExtractor(tiebreaker, extractorRegistry) : null;\n             List<HitExtractor> keyExtractors = hitExtractors(keys, extractorRegistry);\n \n             PhysicalPlan query = plans.get(i);\n             // search query\n-            // TODO: this could be generalized into an exec only query\n-            Check.isTrue(query instanceof EsQueryExec, \"Expected a query but got [{}]\", query.getClass());\n-            QueryRequest request = ((EsQueryExec) query).queryRequest(session);\n-            // base query remains descending, the rest need to flip\n-            criteria.add(new Criterion(request.searchSource(), keyExtractors, tsExtractor, tbExtractor, i > 0 && descending));\n+            if (query instanceof EsQueryExec) {\n+                QueryRequest original = ((EsQueryExec) query).queryRequest(session);\n+                \n+                BoxedQueryRequest boxedRequest = new BoxedQueryRequest(original, timestampName, tiebreakerName);\n+                Criterion<BoxedQueryRequest> criterion =\n+                        new Criterion<>(i, boxedRequest, keyExtractors, tsExtractor, tbExtractor, i> 0 && descending);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYzMDQ4MA=="}, "originalCommit": {"oid": "d8445184607f80c61911b75de709dc0c5ff5c6b0"}, "originalPosition": 48}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2202, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}