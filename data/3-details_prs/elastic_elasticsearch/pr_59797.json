{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDUxMjM1MzI0", "number": 59797, "title": "Make the Painless Semantic Phase External", "bodyText": "This change switches the semantic phase for processing the user tree to the external visitor pattern. Given the length the semantic phase is, each user tree node ends up with a static default semantic analysis method. This helps keep the external phase visitor from being over 2k lines of code. It's still separate in design, and each of the default methods could be moved somewhere else in the future if necessary.", "createdAt": "2020-07-17T16:11:07Z", "url": "https://github.com/elastic/elasticsearch/pull/59797", "merged": true, "mergeCommit": {"oid": "1a3efc43292a23cb697108f294de3dfbe7ed8a0e"}, "closed": true, "closedAt": "2020-07-27T17:47:59Z", "author": {"login": "jdconrad"}, "timelineItems": {"totalCount": 194, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABceBnTtgH2gAyNDUxMjM1MzI0OjRjODAyMjRjYmI3YzIwZTUwODM3ODYyZWFmYzBmOGJjNDFmODRjZmY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc5EtquAH2gAyNDUxMjM1MzI0OmYxNzcyYzZhZmRmM2Q4YjNkOThlYjM5N2YzNzM5ZjI3MGVhMWQxYTE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "4c80224cbb7c20e50837862eafc0f8bc41f84cff", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/4c80224cbb7c20e50837862eafc0f8bc41f84cff", "committedDate": "2020-05-04T15:56:39Z", "message": "Merge branch 'master' into nodes4"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5cdb321bc0432297d5579d1029f165b5ef35d6d0", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/5cdb321bc0432297d5579d1029f165b5ef35d6d0", "committedDate": "2020-05-04T21:52:47Z", "message": "Merge branch 'master' into nodes4"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f3298b3c94c730f91247bb0f9a58a7123423f24b", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/f3298b3c94c730f91247bb0f9a58a7123423f24b", "committedDate": "2020-05-04T22:12:50Z", "message": "Merge branch 'nodes4' into nodes5"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c5153953dc331280025c2bfc5b8c145c140b5d0a", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/c5153953dc331280025c2bfc5b8c145c140b5d0a", "committedDate": "2020-05-04T22:14:50Z", "message": "remove unnecessary read/write checks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c74a5c91176b02104639b491960ea9436c9fef0f", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/c74a5c91176b02104639b491960ea9436c9fef0f", "committedDate": "2020-05-04T23:42:15Z", "message": "Merge branch 'nodes5' into nodes6"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "26f1d5cc262b982ea697077af5c13c40702c0c37", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/26f1d5cc262b982ea697077af5c13c40702c0c37", "committedDate": "2020-05-04T23:50:38Z", "message": "Merge branch 'nodes6' into semantic0"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cf023817db9f7b1e8d313a65dfb940f9fbd0e541", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/cf023817db9f7b1e8d313a65dfb940f9fbd0e541", "committedDate": "2020-05-05T16:35:17Z", "message": "Merge branch 'master' into nodes5"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4a70d3fb81f22666dbb013aa8ed07604f999d2fe", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/4a70d3fb81f22666dbb013aa8ed07604f999d2fe", "committedDate": "2020-05-05T16:35:23Z", "message": "Merge branch 'nodes5' into nodes6"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3201a274cba9ecb9a3752162ad5e2b5a72b360e6", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/3201a274cba9ecb9a3752162ad5e2b5a72b360e6", "committedDate": "2020-05-05T16:35:31Z", "message": "Merge branch 'nodes6' into semantic0"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "729c1dbe82bd49f9058761d57a548f6a622bd14e", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/729c1dbe82bd49f9058761d57a548f6a622bd14e", "committedDate": "2020-05-06T16:53:29Z", "message": "Merge branch 'master' into nodes5"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c50c2ce955a2742df50d7522510f51e8855f42ed", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/c50c2ce955a2742df50d7522510f51e8855f42ed", "committedDate": "2020-05-06T16:53:47Z", "message": "Merge branch 'nodes5' into nodes6"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4c25b66fba923701651e21ceaeac08834e90b5d5", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/4c25b66fba923701651e21ceaeac08834e90b5d5", "committedDate": "2020-05-06T16:54:07Z", "message": "Merge branch 'nodes6' into semantic0"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "680a8b32d49ee9d9e8c349b6b98bf440ca0c0d07", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/680a8b32d49ee9d9e8c349b6b98bf440ca0c0d07", "committedDate": "2020-05-06T17:31:55Z", "message": "remove unnecessary test code from Walker"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "394cf2fa4386f5443a9c1a2e75434dd03063117a", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/394cf2fa4386f5443a9c1a2e75434dd03063117a", "committedDate": "2020-05-06T17:59:43Z", "message": "fix imports"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6b429c66512befbd1fadb82285679b19378a8e84", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/6b429c66512befbd1fadb82285679b19378a8e84", "committedDate": "2020-05-06T22:12:46Z", "message": "remove more dead code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a9753af0cbc6f6b52295afc4e5ba5e17e4c9799a", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/a9753af0cbc6f6b52295afc4e5ba5e17e4c9799a", "committedDate": "2020-05-07T15:37:21Z", "message": "Merge branch 'master' into nodes5"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "77bb1df417baf81f2673d54fd28e89581152d4c8", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/77bb1df417baf81f2673d54fd28e89581152d4c8", "committedDate": "2020-05-07T15:37:27Z", "message": "Merge branch 'nodes5' into nodes6"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9106ae5756e688351f69a96ba2b53f0c71d88b09", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/9106ae5756e688351f69a96ba2b53f0c71d88b09", "committedDate": "2020-05-07T15:37:37Z", "message": "Merge branch 'nodes6' into semantic0"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9791782411ec75c7236a92a642cee803847f8bb5", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/9791782411ec75c7236a92a642cee803847f8bb5", "committedDate": "2020-05-11T17:33:14Z", "message": "Merge branch 'master' into nodes5"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a2bbf6bec4530d4bd680a45c602647ab3514ca55", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/a2bbf6bec4530d4bd680a45c602647ab3514ca55", "committedDate": "2020-05-11T17:33:31Z", "message": "Merge branch 'nodes5' into nodes6"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "86fe756fc1f4760b336e42ffa922e9de1d9c61fe", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/86fe756fc1f4760b336e42ffa922e9de1d9c61fe", "committedDate": "2020-05-11T17:33:47Z", "message": "Merge branch 'nodes6' into semantic0"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9c67ee16ac9d5d8cb20be5ff5680e4c4472f4311", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/9c67ee16ac9d5d8cb20be5ff5680e4c4472f4311", "committedDate": "2020-05-13T18:48:20Z", "message": "fixed lexer spacing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "941d762d2da55dce4add0a69cb58791c11c54650", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/941d762d2da55dce4add0a69cb58791c11c54650", "committedDate": "2020-05-13T20:09:01Z", "message": "Merge branch 'master' into nodes5"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a378ad56d918b1d1bd40354d08423193008f7313", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/a378ad56d918b1d1bd40354d08423193008f7313", "committedDate": "2020-05-13T20:09:06Z", "message": "Merge branch 'nodes5' into nodes6"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1c2c1851fdd5d48b3a06b304f703364041c01e9a", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/1c2c1851fdd5d48b3a06b304f703364041c01e9a", "committedDate": "2020-05-13T20:09:13Z", "message": "Merge branch 'nodes6' into semantic0"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "515427155b4920403075669d0b54532cc6c350ab", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/515427155b4920403075669d0b54532cc6c350ab", "committedDate": "2020-05-14T17:30:59Z", "message": "Merge branch 'master' into semantic0"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5405019217619fbfe3ab2328b0212b7086bdb97b", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/5405019217619fbfe3ab2328b0212b7086bdb97b", "committedDate": "2020-05-14T17:31:10Z", "message": "Merge branch 'semantic0' into semantic1"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ce4a9cf8504564ea84a9e05382f4cf1373e56556", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/ce4a9cf8504564ea84a9e05382f4cf1373e56556", "committedDate": "2020-06-08T14:48:54Z", "message": "Merge branch 'master' into semantic0"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f4dd1787ce97df3635d27094aca2e248d61d4afb", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/f4dd1787ce97df3635d27094aca2e248d61d4afb", "committedDate": "2020-06-08T14:49:13Z", "message": "Merge branch 'semantic0' into semantic1"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b8a7eae2b54ad2dce22bb06e903d896577bf9ee0", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/b8a7eae2b54ad2dce22bb06e903d896577bf9ee0", "committedDate": "2020-06-10T15:29:53Z", "message": "Merge branch 'master' into semantic1"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c0eb8a5308a23ee600d4d7fea096eca93a19524a", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/c0eb8a5308a23ee600d4d7fea096eca93a19524a", "committedDate": "2020-06-12T15:40:07Z", "message": "Merge branch 'master' into semantic1"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9b7e36686702931c842bf3cbaf88b7c2d6466d2d", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/9b7e36686702931c842bf3cbaf88b7c2d6466d2d", "committedDate": "2020-06-12T16:27:37Z", "message": "Merge branch 'semantic1' into semantic2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e0acb3e74a79f35e6e9ecccdba0989ad7de8cda7", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/e0acb3e74a79f35e6e9ecccdba0989ad7de8cda7", "committedDate": "2020-06-12T16:27:53Z", "message": "Merge branch 'semantic2' into semantic3"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ae755a811e1cd3609f7b427b012e371cef807fe3", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/ae755a811e1cd3609f7b427b012e371cef807fe3", "committedDate": "2020-06-15T17:07:52Z", "message": "Merge branch 'master' into semantic1"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "15ad272f43e83cb67ec804a22ae2efd5b739f742", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/15ad272f43e83cb67ec804a22ae2efd5b739f742", "committedDate": "2020-06-15T17:08:13Z", "message": "Merge branch 'semantic1' into semantic2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5207d228095d48c32cc47ccba3049d36d10dba55", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/5207d228095d48c32cc47ccba3049d36d10dba55", "committedDate": "2020-06-15T17:45:01Z", "message": "Merge branch 'semantic2' into semantic3"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b090e91b12cf4e12b0da876079fe43a3a6d60f66", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/b090e91b12cf4e12b0da876079fe43a3a6d60f66", "committedDate": "2020-06-18T15:06:38Z", "message": "Merge branch 'master' into semantic1"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b35a06fd97652d82d9f1a1d66bdf2186f8a81a41", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/b35a06fd97652d82d9f1a1d66bdf2186f8a81a41", "committedDate": "2020-06-18T15:06:47Z", "message": "Merge branch 'semantic1' into semantic2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ea0a33ce0d5f247bad06a653be9f22c5caa81591", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/ea0a33ce0d5f247bad06a653be9f22c5caa81591", "committedDate": "2020-06-18T15:06:57Z", "message": "Merge branch 'semantic2' into semantic3"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "89f84a945c99621dd22339aec07814a6b4a6b066", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/89f84a945c99621dd22339aec07814a6b4a6b066", "committedDate": "2020-06-18T15:10:56Z", "message": "fix indentation in license header"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "acce2f7e07e97173b5e7ddcb6404389fbcdde5e2", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/acce2f7e07e97173b5e7ddcb6404389fbcdde5e2", "committedDate": "2020-06-18T16:55:03Z", "message": "Merge branch 'master' into semantic3"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1fe0a3ca2939495888a10395b6d7abde239b8a25", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/1fe0a3ca2939495888a10395b6d7abde239b8a25", "committedDate": "2020-06-18T16:58:02Z", "message": "Merge branch 'semantic3' into semantic4"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "439c6648feb2067036db2b041c8ed405c12a7bce", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/439c6648feb2067036db2b041c8ed405c12a7bce", "committedDate": "2020-06-24T15:43:01Z", "message": "Merge branch 'master' into semantic3"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "486f779e525cbc646f85e0c99380262466c12574", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/486f779e525cbc646f85e0c99380262466c12574", "committedDate": "2020-06-24T15:43:19Z", "message": "Merge branch 'semantic3' into semantic4"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6f8c2d58c882d0b8f9296fe60302dc41df25f4c4", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/6f8c2d58c882d0b8f9296fe60302dc41df25f4c4", "committedDate": "2020-06-24T16:11:45Z", "message": "remove extraneous code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3de00846a6baaac92bc663d54f23684957d26ce2", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/3de00846a6baaac92bc663d54f23684957d26ce2", "committedDate": "2020-06-30T17:59:25Z", "message": "Merge branch 'master' into semantic3"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "591e8fbf28df972180a52b957f3c756cc25c99c1", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/591e8fbf28df972180a52b957f3c756cc25c99c1", "committedDate": "2020-06-30T17:59:35Z", "message": "Merge branch 'semantic3' into semantic4"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d11dbcd7a3d1ba91752962d3ac133cba2e050c8e", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/d11dbcd7a3d1ba91752962d3ac133cba2e050c8e", "committedDate": "2020-06-30T18:03:01Z", "message": "rename left/right to true/false for user conditional node"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d9e6809729672d2b0ad359344feba73d4250bd16", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/d9e6809729672d2b0ad359344feba73d4250bd16", "committedDate": "2020-06-30T19:18:39Z", "message": "Merge branch 'master' into semantic4"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ec8ddacd6059f1565a5da6b61898821a7c2f52b4", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/ec8ddacd6059f1565a5da6b61898821a7c2f52b4", "committedDate": "2020-06-30T19:29:39Z", "message": "Merge branch 'semantic4' into semantic5"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d843df9dba3fc04d180ee747ea36b1bb03bdcdfa", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/d843df9dba3fc04d180ee747ea36b1bb03bdcdfa", "committedDate": "2020-07-01T14:55:21Z", "message": "Merge branch 'master' into semantic4"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e45645ed4ee348ea9119183c906eb3833f47ad73", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/e45645ed4ee348ea9119183c906eb3833f47ad73", "committedDate": "2020-07-01T17:42:56Z", "message": "Merge branch 'master' into semantic4"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "db96091b0d652056a25ee2681215f31bdf9655e0", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/db96091b0d652056a25ee2681215f31bdf9655e0", "committedDate": "2020-07-01T20:32:43Z", "message": "add visitor patterns for user and ir trees"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4c1902df61876b686f6a2c1899c78ee311a5e1a1", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/4c1902df61876b686f6a2c1899c78ee311a5e1a1", "committedDate": "2020-07-01T20:45:02Z", "message": "Merge branch 'master' into semantic05"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4b8742a0776b5a819fc369dc9d7889885e00c6a0", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/4b8742a0776b5a819fc369dc9d7889885e00c6a0", "committedDate": "2020-07-02T21:15:19Z", "message": "add base visitor classes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f2d5006edbc63374240e15a57c647fd1fb05808e", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/f2d5006edbc63374240e15a57c647fd1fb05808e", "committedDate": "2020-07-07T16:16:38Z", "message": "Merge branch 'master' into semantic05"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cf0809cf2bfd7dab9182427897d3d1af77fe27cc", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/cf0809cf2bfd7dab9182427897d3d1af77fe27cc", "committedDate": "2020-07-07T16:46:25Z", "message": "Merge branch 'semantic05' into semantic5"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8f4f548fc806abeb4e3b54c5d498198b0ce4b6f3", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/8f4f548fc806abeb4e3b54c5d498198b0ce4b6f3", "committedDate": "2020-07-07T16:53:27Z", "message": "fix intellij default"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4db342843635c2138faad1b89ab80c66be59c512", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/4db342843635c2138faad1b89ab80c66be59c512", "committedDate": "2020-07-07T16:58:41Z", "message": "remove extraneous newline"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "739a9f8580c26b616bbb0d15d939fcd1fca32493", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/739a9f8580c26b616bbb0d15d939fcd1fca32493", "committedDate": "2020-07-14T15:55:30Z", "message": "Merge branch 'master' into semantic5"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "523bf849fd51a846b2abbdbfe12637407582e3b1", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/523bf849fd51a846b2abbdbfe12637407582e3b1", "committedDate": "2020-07-14T16:13:38Z", "message": "response to pr comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cf1612a0e4471f742efd198a90c7f0248ab1a130", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/cf1612a0e4471f742efd198a90c7f0248ab1a130", "committedDate": "2020-07-14T16:29:49Z", "message": "Merge branch 'master' into semantic5"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8591d38eb78bb33df2c11fec64b5259912ca1d9c", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/8591d38eb78bb33df2c11fec64b5259912ca1d9c", "committedDate": "2020-07-14T17:02:19Z", "message": "Merge branch 'master' into semantic5"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "75244e2d01b925e4c9471a4fdcb703487dd03261", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/75244e2d01b925e4c9471a4fdcb703487dd03261", "committedDate": "2020-07-14T19:04:34Z", "message": "Merge branch 'master' into semantic5"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "124353999810d028814421a55bd971c1a9f5f6c6", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/124353999810d028814421a55bd971c1a9f5f6c6", "committedDate": "2020-07-15T15:31:26Z", "message": "Merge branch 'master' into semantic5"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "af98c81ac67701a350431d1d0c1e0059d756a33a", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/af98c81ac67701a350431d1d0c1e0059d756a33a", "committedDate": "2020-07-15T16:15:59Z", "message": "Merge branch 'semantic5' into semantic6"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "80fee0c306985fa649a66ccf7ea5fd99d0810e5a", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/80fee0c306985fa649a66ccf7ea5fd99d0810e5a", "committedDate": "2020-07-16T15:47:19Z", "message": "Merge branch 'master' into semantic6"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "29cd653736514e77a52384391fee28e612ad3b24", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/29cd653736514e77a52384391fee28e612ad3b24", "committedDate": "2020-07-16T16:03:32Z", "message": "response to pr comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "06fde8117fce065bb37701b8963dc58c3eaadb4a", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/06fde8117fce065bb37701b8963dc58c3eaadb4a", "committedDate": "2020-07-16T16:43:47Z", "message": "Merge branch 'master' into semantic6"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "60484d7919c9afee2f890fe9646c23ca72662187", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/60484d7919c9afee2f890fe9646c23ca72662187", "committedDate": "2020-07-16T19:46:04Z", "message": "Merge branch 'semantic6' into semantic7"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "056d1d8f215b9ffb5c3c8be4108d1fb0ae8eae7f", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/056d1d8f215b9ffb5c3c8be4108d1fb0ae8eae7f", "committedDate": "2020-07-17T15:27:30Z", "message": "Merge branch 'master' into semantic7"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUyNjQ5NzI4", "url": "https://github.com/elastic/elasticsearch/pull/59797#pullrequestreview-452649728", "createdAt": "2020-07-21T16:52:37Z", "commit": {"oid": "056d1d8f215b9ffb5c3c8be4108d1fb0ae8eae7f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNjo1MjozN1rOG1BFwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNjo1MjozN1rOG1BFwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI0NTU2OA==", "bodyText": "Where did this go?", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r458245568", "createdAt": "2020-07-21T16:52:37Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/SemanticHeaderPhase.java", "diffHunk": "@@ -1,88 +0,0 @@\n-/*", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "056d1d8f215b9ffb5c3c8be4108d1fb0ae8eae7f"}, "originalPosition": 1}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUyNjUyMzQy", "url": "https://github.com/elastic/elasticsearch/pull/59797#pullrequestreview-452652342", "createdAt": "2020-07-21T16:55:38Z", "commit": {"oid": "056d1d8f215b9ffb5c3c8be4108d1fb0ae8eae7f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNjo1NTozOFrOG1BNTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNjo1NTozOFrOG1BNTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI0NzUwMw==", "bodyText": "Why the rearrangement?", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r458247503", "createdAt": "2020-07-21T16:55:38Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/ANode.java", "diffHunk": "@@ -57,16 +57,16 @@ public Location getLocation() {\n     }\n \n     /**\n-     * Callback to visit a user tree node.\n+     * Create an error with location information pointing to this node.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "056d1d8f215b9ffb5c3c8be4108d1fb0ae8eae7f"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUyNjU3NDk3", "url": "https://github.com/elastic/elasticsearch/pull/59797#pullrequestreview-452657497", "createdAt": "2020-07-21T17:01:27Z", "commit": {"oid": "056d1d8f215b9ffb5c3c8be4108d1fb0ae8eae7f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNzowMToyOFrOG1BbkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNzowMToyOFrOG1BbkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI1MTE1Mw==", "bodyText": "Pick a better way to wrap args.", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r458251153", "createdAt": "2020-07-21T17:01:28Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EBinary.java", "diffHunk": "@@ -72,108 +73,113 @@ public Operation getOperation() {\n         return userTreeVisitor.visitBinary(this, input);\n     }\n \n-    @Override\n-    void analyze(SemanticScope semanticScope) {\n-        if (semanticScope.getCondition(this, Write.class)) {\n-            throw createError(new IllegalArgumentException(\n+    public static void visitDefaultSemanticAnalysis(\n+            DefaultSemanticAnalysisPhase visitor, EBinary userBinaryNode, SemanticScope semanticScope) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "056d1d8f215b9ffb5c3c8be4108d1fb0ae8eae7f"}, "originalPosition": 17}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUyNjYzNTUw", "url": "https://github.com/elastic/elasticsearch/pull/59797#pullrequestreview-452663550", "createdAt": "2020-07-21T17:09:25Z", "commit": {"oid": "056d1d8f215b9ffb5c3c8be4108d1fb0ae8eae7f"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9742de607bef6fcfe372d6a85d7070ef8f3ba629", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/9742de607bef6fcfe372d6a85d7070ef8f3ba629", "committedDate": "2020-07-21T17:39:39Z", "message": "Merge branch 'master' into semantic7"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c1847360d791e3f6c22a35fffb9e209cb790384d", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/c1847360d791e3f6c22a35fffb9e209cb790384d", "committedDate": "2020-07-22T22:37:48Z", "message": "Merge branch 'master' into semantic7"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7a727d2bc0ad6d8b769848d7e37e5e1847da7d77", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/7a727d2bc0ad6d8b769848d7e37e5e1847da7d77", "committedDate": "2020-07-22T23:52:38Z", "message": "make semantic phase external"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0MjQ0Njky", "url": "https://github.com/elastic/elasticsearch/pull/59797#pullrequestreview-454244692", "createdAt": "2020-07-23T15:21:12Z", "commit": {"oid": "7a727d2bc0ad6d8b769848d7e37e5e1847da7d77"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNToyMToxMlrOG2PlQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNToyMToxMlrOG2PlQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUzMTU4Ng==", "bodyText": "Are the changes to this file due to intellij?  What happens if you regen?", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r459531586", "createdAt": "2020-07-23T15:21:12Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/PainlessLexer.java", "diffHunk": "@@ -1,13 +1,17 @@\n // ANTLR GENERATED CODE: DO NOT EDIT\n package org.elasticsearch.painless.antlr;\n-import org.antlr.v4.runtime.Lexer;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a727d2bc0ad6d8b769848d7e37e5e1847da7d77"}, "originalPosition": 3}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0MjQ1NDQ3", "url": "https://github.com/elastic/elasticsearch/pull/59797#pullrequestreview-454245447", "createdAt": "2020-07-23T15:21:58Z", "commit": {"oid": "7a727d2bc0ad6d8b769848d7e37e5e1847da7d77"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNToyMTo1OFrOG2Pngg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNToyMTo1OFrOG2Pngg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUzMjE2Mg==", "bodyText": "Similar question about generated vs intellij", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r459532162", "createdAt": "2020-07-23T15:21:58Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/PainlessParser.java", "diffHunk": "@@ -1,13 +1,25 @@\n // ANTLR GENERATED CODE: DO NOT EDIT\n package org.elasticsearch.painless.antlr;\n-import org.antlr.v4.runtime.atn.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a727d2bc0ad6d8b769848d7e37e5e1847da7d77"}, "originalPosition": 3}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0MjYyNTQ1", "url": "https://github.com/elastic/elasticsearch/pull/59797#pullrequestreview-454262545", "createdAt": "2020-07-23T15:40:22Z", "commit": {"oid": "7a727d2bc0ad6d8b769848d7e37e5e1847da7d77"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNTo0MDoyM1rOG2QZtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNTo0MDoyM1rOG2QZtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU0NTAxNQ==", "bodyText": "Provide a one sentence explanation for each public method.", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r459545015", "createdAt": "2020-07-23T15:40:23Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultSemanticAnalysisPhase.java", "diffHunk": "@@ -0,0 +1,2728 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.phase;\n+\n+import org.elasticsearch.painless.AnalyzerCaster;\n+import org.elasticsearch.painless.FunctionRef;\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.Operation;\n+import org.elasticsearch.painless.lookup.PainlessCast;\n+import org.elasticsearch.painless.lookup.PainlessClassBinding;\n+import org.elasticsearch.painless.lookup.PainlessConstructor;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessInstanceBinding;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.node.AExpression;\n+import org.elasticsearch.painless.node.ANode;\n+import org.elasticsearch.painless.node.AStatement;\n+import org.elasticsearch.painless.node.EAssignment;\n+import org.elasticsearch.painless.node.EBinary;\n+import org.elasticsearch.painless.node.EBooleanComp;\n+import org.elasticsearch.painless.node.EBooleanConstant;\n+import org.elasticsearch.painless.node.EBrace;\n+import org.elasticsearch.painless.node.ECall;\n+import org.elasticsearch.painless.node.ECallLocal;\n+import org.elasticsearch.painless.node.EComp;\n+import org.elasticsearch.painless.node.EConditional;\n+import org.elasticsearch.painless.node.EDecimal;\n+import org.elasticsearch.painless.node.EDot;\n+import org.elasticsearch.painless.node.EElvis;\n+import org.elasticsearch.painless.node.EExplicit;\n+import org.elasticsearch.painless.node.EFunctionRef;\n+import org.elasticsearch.painless.node.EInstanceof;\n+import org.elasticsearch.painless.node.ELambda;\n+import org.elasticsearch.painless.node.EListInit;\n+import org.elasticsearch.painless.node.EMapInit;\n+import org.elasticsearch.painless.node.ENewArray;\n+import org.elasticsearch.painless.node.ENewArrayFunctionRef;\n+import org.elasticsearch.painless.node.ENewObj;\n+import org.elasticsearch.painless.node.ENull;\n+import org.elasticsearch.painless.node.ENumeric;\n+import org.elasticsearch.painless.node.ERegex;\n+import org.elasticsearch.painless.node.EString;\n+import org.elasticsearch.painless.node.ESymbol;\n+import org.elasticsearch.painless.node.EUnary;\n+import org.elasticsearch.painless.node.SBlock;\n+import org.elasticsearch.painless.node.SBreak;\n+import org.elasticsearch.painless.node.SCatch;\n+import org.elasticsearch.painless.node.SClass;\n+import org.elasticsearch.painless.node.SContinue;\n+import org.elasticsearch.painless.node.SDeclBlock;\n+import org.elasticsearch.painless.node.SDeclaration;\n+import org.elasticsearch.painless.node.SDo;\n+import org.elasticsearch.painless.node.SEach;\n+import org.elasticsearch.painless.node.SExpression;\n+import org.elasticsearch.painless.node.SFor;\n+import org.elasticsearch.painless.node.SFunction;\n+import org.elasticsearch.painless.node.SIf;\n+import org.elasticsearch.painless.node.SIfElse;\n+import org.elasticsearch.painless.node.SReturn;\n+import org.elasticsearch.painless.node.SThrow;\n+import org.elasticsearch.painless.node.STry;\n+import org.elasticsearch.painless.node.SWhile;\n+import org.elasticsearch.painless.spi.annotation.NonDeterministicAnnotation;\n+import org.elasticsearch.painless.symbol.Decorations;\n+import org.elasticsearch.painless.symbol.Decorations.AllEscape;\n+import org.elasticsearch.painless.symbol.Decorations.AnyBreak;\n+import org.elasticsearch.painless.symbol.Decorations.AnyContinue;\n+import org.elasticsearch.painless.symbol.Decorations.BeginLoop;\n+import org.elasticsearch.painless.symbol.Decorations.BinaryType;\n+import org.elasticsearch.painless.symbol.Decorations.CapturesDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.ComparisonType;\n+import org.elasticsearch.painless.symbol.Decorations.CompoundType;\n+import org.elasticsearch.painless.symbol.Decorations.Concatenate;\n+import org.elasticsearch.painless.symbol.Decorations.ContinuousLoop;\n+import org.elasticsearch.painless.symbol.Decorations.DefOptimized;\n+import org.elasticsearch.painless.symbol.Decorations.DowncastPainlessCast;\n+import org.elasticsearch.painless.symbol.Decorations.EncodingDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.Explicit;\n+import org.elasticsearch.painless.symbol.Decorations.ExpressionPainlessCast;\n+import org.elasticsearch.painless.symbol.Decorations.GetterPainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.InLoop;\n+import org.elasticsearch.painless.symbol.Decorations.InstanceType;\n+import org.elasticsearch.painless.symbol.Decorations.Internal;\n+import org.elasticsearch.painless.symbol.Decorations.IterablePainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.LastLoop;\n+import org.elasticsearch.painless.symbol.Decorations.LastSource;\n+import org.elasticsearch.painless.symbol.Decorations.ListShortcut;\n+import org.elasticsearch.painless.symbol.Decorations.LoopEscape;\n+import org.elasticsearch.painless.symbol.Decorations.MapShortcut;\n+import org.elasticsearch.painless.symbol.Decorations.MethodEscape;\n+import org.elasticsearch.painless.symbol.Decorations.MethodNameDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.Negate;\n+import org.elasticsearch.painless.symbol.Decorations.ParameterNames;\n+import org.elasticsearch.painless.symbol.Decorations.PartialCanonicalTypeName;\n+import org.elasticsearch.painless.symbol.Decorations.Read;\n+import org.elasticsearch.painless.symbol.Decorations.ReferenceDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.ReturnType;\n+import org.elasticsearch.painless.symbol.Decorations.SemanticVariable;\n+import org.elasticsearch.painless.symbol.Decorations.SetterPainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.ShiftType;\n+import org.elasticsearch.painless.symbol.Decorations.Shortcut;\n+import org.elasticsearch.painless.symbol.Decorations.StandardConstant;\n+import org.elasticsearch.painless.symbol.Decorations.StandardLocalFunction;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessClassBinding;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessConstructor;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessField;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessInstanceBinding;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.StaticType;\n+import org.elasticsearch.painless.symbol.Decorations.TargetType;\n+import org.elasticsearch.painless.symbol.Decorations.TypeParameters;\n+import org.elasticsearch.painless.symbol.Decorations.UnaryType;\n+import org.elasticsearch.painless.symbol.Decorations.UpcastPainlessCast;\n+import org.elasticsearch.painless.symbol.Decorations.ValueType;\n+import org.elasticsearch.painless.symbol.Decorations.Write;\n+import org.elasticsearch.painless.symbol.FunctionTable;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptScope;\n+import org.elasticsearch.painless.symbol.SemanticScope;\n+import org.elasticsearch.painless.symbol.SemanticScope.FunctionScope;\n+import org.elasticsearch.painless.symbol.SemanticScope.LambdaScope;\n+import org.elasticsearch.painless.symbol.SemanticScope.Variable;\n+\n+import java.lang.reflect.Modifier;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+import java.util.regex.PatternSyntaxException;\n+\n+import static org.elasticsearch.painless.lookup.PainlessLookupUtility.typeToCanonicalTypeName;\n+import static org.elasticsearch.painless.symbol.SemanticScope.newFunctionScope;\n+\n+public class DefaultSemanticAnalysisPhase extends UserTreeBaseVisitor<SemanticScope> {\n+\n+    public void decorateWithCast(AExpression userExpressionNode, SemanticScope semanticScope) {\n+        Location location = userExpressionNode.getLocation();\n+        Class<?> valueType = semanticScope.getDecoration(userExpressionNode, ValueType.class).getValueType();\n+        Class<?> targetType = semanticScope.getDecoration(userExpressionNode, TargetType.class).getTargetType();\n+        boolean isExplicitCast = semanticScope.getCondition(userExpressionNode, Explicit.class);\n+        boolean isInternalCast = semanticScope.getCondition(userExpressionNode, Internal.class);\n+\n+        PainlessCast painlessCast = AnalyzerCaster.getLegalCast(location, valueType, targetType, isExplicitCast, isInternalCast);\n+\n+        if (painlessCast != null) {\n+            semanticScope.putDecoration(userExpressionNode, new ExpressionPainlessCast(painlessCast));\n+        }\n+    }\n+\n+    public void visit(ANode userNode, SemanticScope semanticScope) {\n+        if (userNode != null) {\n+            userNode.visit(this, semanticScope);\n+        }\n+    }\n+\n+    public void checkedVisit(AExpression userExpressionNode, SemanticScope semanticScope) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a727d2bc0ad6d8b769848d7e37e5e1847da7d77"}, "originalPosition": 178}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0MjkyODU0", "url": "https://github.com/elastic/elasticsearch/pull/59797#pullrequestreview-454292854", "createdAt": "2020-07-23T16:15:52Z", "commit": {"oid": "7a727d2bc0ad6d8b769848d7e37e5e1847da7d77"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNjoxNTo1MlrOG2R1eA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNjoxNTo1MlrOG2R1eA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU2ODUwNA==", "bodyText": "I like the new use of Negate condition in DefaultSemanticAnalysisPhase.", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r459568504", "createdAt": "2020-07-23T16:15:52Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EDecimal.java", "diffHunk": "@@ -55,48 +50,4 @@ public String getDecimal() {\n     public <Scope> void visitChildren(UserTreeVisitor<Scope> userTreeVisitor, Scope scope) {\n         // terminal node; no children\n     }\n-\n-    @Override\n-    void analyze(SemanticScope semanticScope) {\n-        analyze(semanticScope, false);\n-    }\n-\n-    void analyze(SemanticScope semanticScope, boolean negate) {\n-        if (semanticScope.getCondition(this, Write.class)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a727d2bc0ad6d8b769848d7e37e5e1847da7d77"}, "originalPosition": 23}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0Mjk2ODkx", "url": "https://github.com/elastic/elasticsearch/pull/59797#pullrequestreview-454296891", "createdAt": "2020-07-23T16:20:50Z", "commit": {"oid": "7a727d2bc0ad6d8b769848d7e37e5e1847da7d77"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNjoyMDo1MFrOG2SBkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNjoyMDo1MFrOG2SBkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU3MTYwMg==", "bodyText": "Consider moving this definition closer to it's use.", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r459571602", "createdAt": "2020-07-23T16:20:50Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultSemanticAnalysisPhase.java", "diffHunk": "@@ -0,0 +1,2728 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.phase;\n+\n+import org.elasticsearch.painless.AnalyzerCaster;\n+import org.elasticsearch.painless.FunctionRef;\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.Operation;\n+import org.elasticsearch.painless.lookup.PainlessCast;\n+import org.elasticsearch.painless.lookup.PainlessClassBinding;\n+import org.elasticsearch.painless.lookup.PainlessConstructor;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessInstanceBinding;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.node.AExpression;\n+import org.elasticsearch.painless.node.ANode;\n+import org.elasticsearch.painless.node.AStatement;\n+import org.elasticsearch.painless.node.EAssignment;\n+import org.elasticsearch.painless.node.EBinary;\n+import org.elasticsearch.painless.node.EBooleanComp;\n+import org.elasticsearch.painless.node.EBooleanConstant;\n+import org.elasticsearch.painless.node.EBrace;\n+import org.elasticsearch.painless.node.ECall;\n+import org.elasticsearch.painless.node.ECallLocal;\n+import org.elasticsearch.painless.node.EComp;\n+import org.elasticsearch.painless.node.EConditional;\n+import org.elasticsearch.painless.node.EDecimal;\n+import org.elasticsearch.painless.node.EDot;\n+import org.elasticsearch.painless.node.EElvis;\n+import org.elasticsearch.painless.node.EExplicit;\n+import org.elasticsearch.painless.node.EFunctionRef;\n+import org.elasticsearch.painless.node.EInstanceof;\n+import org.elasticsearch.painless.node.ELambda;\n+import org.elasticsearch.painless.node.EListInit;\n+import org.elasticsearch.painless.node.EMapInit;\n+import org.elasticsearch.painless.node.ENewArray;\n+import org.elasticsearch.painless.node.ENewArrayFunctionRef;\n+import org.elasticsearch.painless.node.ENewObj;\n+import org.elasticsearch.painless.node.ENull;\n+import org.elasticsearch.painless.node.ENumeric;\n+import org.elasticsearch.painless.node.ERegex;\n+import org.elasticsearch.painless.node.EString;\n+import org.elasticsearch.painless.node.ESymbol;\n+import org.elasticsearch.painless.node.EUnary;\n+import org.elasticsearch.painless.node.SBlock;\n+import org.elasticsearch.painless.node.SBreak;\n+import org.elasticsearch.painless.node.SCatch;\n+import org.elasticsearch.painless.node.SClass;\n+import org.elasticsearch.painless.node.SContinue;\n+import org.elasticsearch.painless.node.SDeclBlock;\n+import org.elasticsearch.painless.node.SDeclaration;\n+import org.elasticsearch.painless.node.SDo;\n+import org.elasticsearch.painless.node.SEach;\n+import org.elasticsearch.painless.node.SExpression;\n+import org.elasticsearch.painless.node.SFor;\n+import org.elasticsearch.painless.node.SFunction;\n+import org.elasticsearch.painless.node.SIf;\n+import org.elasticsearch.painless.node.SIfElse;\n+import org.elasticsearch.painless.node.SReturn;\n+import org.elasticsearch.painless.node.SThrow;\n+import org.elasticsearch.painless.node.STry;\n+import org.elasticsearch.painless.node.SWhile;\n+import org.elasticsearch.painless.spi.annotation.NonDeterministicAnnotation;\n+import org.elasticsearch.painless.symbol.Decorations;\n+import org.elasticsearch.painless.symbol.Decorations.AllEscape;\n+import org.elasticsearch.painless.symbol.Decorations.AnyBreak;\n+import org.elasticsearch.painless.symbol.Decorations.AnyContinue;\n+import org.elasticsearch.painless.symbol.Decorations.BeginLoop;\n+import org.elasticsearch.painless.symbol.Decorations.BinaryType;\n+import org.elasticsearch.painless.symbol.Decorations.CapturesDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.ComparisonType;\n+import org.elasticsearch.painless.symbol.Decorations.CompoundType;\n+import org.elasticsearch.painless.symbol.Decorations.Concatenate;\n+import org.elasticsearch.painless.symbol.Decorations.ContinuousLoop;\n+import org.elasticsearch.painless.symbol.Decorations.DefOptimized;\n+import org.elasticsearch.painless.symbol.Decorations.DowncastPainlessCast;\n+import org.elasticsearch.painless.symbol.Decorations.EncodingDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.Explicit;\n+import org.elasticsearch.painless.symbol.Decorations.ExpressionPainlessCast;\n+import org.elasticsearch.painless.symbol.Decorations.GetterPainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.InLoop;\n+import org.elasticsearch.painless.symbol.Decorations.InstanceType;\n+import org.elasticsearch.painless.symbol.Decorations.Internal;\n+import org.elasticsearch.painless.symbol.Decorations.IterablePainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.LastLoop;\n+import org.elasticsearch.painless.symbol.Decorations.LastSource;\n+import org.elasticsearch.painless.symbol.Decorations.ListShortcut;\n+import org.elasticsearch.painless.symbol.Decorations.LoopEscape;\n+import org.elasticsearch.painless.symbol.Decorations.MapShortcut;\n+import org.elasticsearch.painless.symbol.Decorations.MethodEscape;\n+import org.elasticsearch.painless.symbol.Decorations.MethodNameDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.Negate;\n+import org.elasticsearch.painless.symbol.Decorations.ParameterNames;\n+import org.elasticsearch.painless.symbol.Decorations.PartialCanonicalTypeName;\n+import org.elasticsearch.painless.symbol.Decorations.Read;\n+import org.elasticsearch.painless.symbol.Decorations.ReferenceDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.ReturnType;\n+import org.elasticsearch.painless.symbol.Decorations.SemanticVariable;\n+import org.elasticsearch.painless.symbol.Decorations.SetterPainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.ShiftType;\n+import org.elasticsearch.painless.symbol.Decorations.Shortcut;\n+import org.elasticsearch.painless.symbol.Decorations.StandardConstant;\n+import org.elasticsearch.painless.symbol.Decorations.StandardLocalFunction;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessClassBinding;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessConstructor;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessField;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessInstanceBinding;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.StaticType;\n+import org.elasticsearch.painless.symbol.Decorations.TargetType;\n+import org.elasticsearch.painless.symbol.Decorations.TypeParameters;\n+import org.elasticsearch.painless.symbol.Decorations.UnaryType;\n+import org.elasticsearch.painless.symbol.Decorations.UpcastPainlessCast;\n+import org.elasticsearch.painless.symbol.Decorations.ValueType;\n+import org.elasticsearch.painless.symbol.Decorations.Write;\n+import org.elasticsearch.painless.symbol.FunctionTable;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptScope;\n+import org.elasticsearch.painless.symbol.SemanticScope;\n+import org.elasticsearch.painless.symbol.SemanticScope.FunctionScope;\n+import org.elasticsearch.painless.symbol.SemanticScope.LambdaScope;\n+import org.elasticsearch.painless.symbol.SemanticScope.Variable;\n+\n+import java.lang.reflect.Modifier;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+import java.util.regex.PatternSyntaxException;\n+\n+import static org.elasticsearch.painless.lookup.PainlessLookupUtility.typeToCanonicalTypeName;\n+import static org.elasticsearch.painless.symbol.SemanticScope.newFunctionScope;\n+\n+public class DefaultSemanticAnalysisPhase extends UserTreeBaseVisitor<SemanticScope> {\n+\n+    public void decorateWithCast(AExpression userExpressionNode, SemanticScope semanticScope) {\n+        Location location = userExpressionNode.getLocation();\n+        Class<?> valueType = semanticScope.getDecoration(userExpressionNode, ValueType.class).getValueType();\n+        Class<?> targetType = semanticScope.getDecoration(userExpressionNode, TargetType.class).getTargetType();\n+        boolean isExplicitCast = semanticScope.getCondition(userExpressionNode, Explicit.class);\n+        boolean isInternalCast = semanticScope.getCondition(userExpressionNode, Internal.class);\n+\n+        PainlessCast painlessCast = AnalyzerCaster.getLegalCast(location, valueType, targetType, isExplicitCast, isInternalCast);\n+\n+        if (painlessCast != null) {\n+            semanticScope.putDecoration(userExpressionNode, new ExpressionPainlessCast(painlessCast));\n+        }\n+    }\n+\n+    public void visit(ANode userNode, SemanticScope semanticScope) {\n+        if (userNode != null) {\n+            userNode.visit(this, semanticScope);\n+        }\n+    }\n+\n+    public void checkedVisit(AExpression userExpressionNode, SemanticScope semanticScope) {\n+        if (userExpressionNode != null) {\n+            userExpressionNode.visit(this, semanticScope);\n+\n+            if (semanticScope.hasDecoration(userExpressionNode, PartialCanonicalTypeName.class)) {\n+                throw userExpressionNode.createError(new IllegalArgumentException(\"cannot resolve symbol [\" +\n+                        semanticScope.getDecoration(userExpressionNode, PartialCanonicalTypeName.class).getPartialCanonicalTypeName() +\n+                        \"]\"));\n+            }\n+\n+            if (semanticScope.hasDecoration(userExpressionNode, StaticType.class)) {\n+                throw userExpressionNode.createError(new IllegalArgumentException(\"value required: instead found unexpected type \" +\n+                        \"[\" + semanticScope.getDecoration(userExpressionNode, StaticType.class).getStaticCanonicalTypeName() + \"]\"));\n+            }\n+\n+            if (semanticScope.hasDecoration(userExpressionNode, ValueType.class) == false) {\n+                throw userExpressionNode.createError(new IllegalStateException(\"value required: instead found no value\"));\n+            }\n+        }\n+    }\n+\n+    public void visitClass(SClass userClassNode, ScriptScope scriptScope) {\n+        for (SFunction userFunctionNode : userClassNode.getFunctionNodes()) {\n+            visitFunction(userFunctionNode, scriptScope);\n+        }\n+    }\n+\n+    public void visitFunction(SFunction userFunctionNode, ScriptScope scriptScope) {\n+        String functionName = userFunctionNode.getFunctionName();\n+        LocalFunction localFunction =\n+                scriptScope.getFunctionTable().getFunction(functionName, userFunctionNode.getCanonicalTypeNameParameters().size());\n+        Class<?> returnType = localFunction.getReturnType();\n+        List<Class<?>> typeParameters = localFunction.getTypeParameters();\n+        FunctionScope functionScope = newFunctionScope(scriptScope, localFunction.getReturnType());\n+\n+        for (int index = 0; index < localFunction.getTypeParameters().size(); ++index) {\n+            Class<?> typeParameter = localFunction.getTypeParameters().get(index);\n+            String parameterName = userFunctionNode.getParameterNames().get(index);\n+            functionScope.defineVariable(userFunctionNode.getLocation(), typeParameter, parameterName, false);\n+        }\n+\n+        SBlock userBlockNode = userFunctionNode.getBlockNode();\n+\n+        if (userBlockNode.getStatementNodes().isEmpty()) {\n+            throw userFunctionNode.createError(new IllegalArgumentException(\"invalid function definition: \" +\n+                    \"found no statements for function \" +\n+                    \"[\" + functionName + \"] with [\" + typeParameters.size() + \"] parameters\"));\n+        }\n+\n+        functionScope.setCondition(userBlockNode, LastSource.class);\n+        visit(userBlockNode, functionScope.newLocalScope());\n+        boolean methodEscape = functionScope.getCondition(userBlockNode, MethodEscape.class);\n+        boolean isAutoReturnEnabled = userFunctionNode.isAutoReturnEnabled();\n+\n+        if (methodEscape == false && isAutoReturnEnabled == false && returnType != void.class) {\n+            throw userFunctionNode.createError(new IllegalArgumentException(\"invalid function definition: \" +\n+                    \"not all paths provide a return value for function \" +\n+                    \"[\" + functionName + \"] with [\" + typeParameters.size() + \"] parameters\"));\n+        }\n+\n+        if (methodEscape) {\n+            functionScope.setCondition(userFunctionNode, MethodEscape.class);\n+        }\n+\n+        // TODO: do not specialize for execute\n+        // TODO: https://github.com/elastic/elasticsearch/issues/51841\n+        if (\"execute\".equals(functionName)) {\n+            scriptScope.setUsedVariables(functionScope.getUsedVariables());\n+        }\n+        // TODO: end\n+    }\n+\n+    @Override\n+    public void visitBlock(SBlock userBlockNode, SemanticScope semanticScope) {\n+        List<AStatement> userStatementNodes = userBlockNode.getStatementNodes();\n+\n+        if (userStatementNodes.isEmpty()) {\n+            throw userBlockNode.createError(new IllegalArgumentException(\"invalid block: found no statements\"));\n+        }\n+\n+        AStatement lastUserStatement = userStatementNodes.get(userStatementNodes.size() - 1);\n+\n+        boolean lastSource = semanticScope.getCondition(userBlockNode, LastSource.class);\n+        boolean beginLoop = semanticScope.getCondition(userBlockNode, BeginLoop.class);\n+        boolean inLoop = semanticScope.getCondition(userBlockNode, InLoop.class);\n+        boolean lastLoop = semanticScope.getCondition(userBlockNode, LastLoop.class);\n+\n+        boolean allEscape;\n+        boolean anyContinue = false;\n+        boolean anyBreak = false;\n+\n+        for (AStatement userStatementNode : userStatementNodes) {\n+            if (inLoop) {\n+                semanticScope.setCondition(userStatementNode, InLoop.class);\n+            }\n+\n+            if (userStatementNode == lastUserStatement) {\n+                if (beginLoop || lastLoop) {\n+                    semanticScope.setCondition(userStatementNode, LastLoop.class);\n+                }\n+\n+                if (lastSource) {\n+                    semanticScope.setCondition(userStatementNode, LastSource.class);\n+                }\n+            }\n+\n+            visit(userStatementNode, semanticScope);\n+            allEscape = semanticScope.getCondition(userStatementNode, AllEscape.class);\n+\n+            if (userStatementNode == lastUserStatement) {\n+                semanticScope.replicateCondition(userStatementNode, userBlockNode, MethodEscape.class);\n+                semanticScope.replicateCondition(userStatementNode, userBlockNode, LoopEscape.class);\n+\n+                if (allEscape) {\n+                    semanticScope.setCondition(userStatementNode, AllEscape.class);\n+                }\n+            } else {\n+                if (allEscape) {\n+                    throw userBlockNode.createError(new IllegalArgumentException(\"invalid block: unreachable statement\"));\n+                }\n+            }\n+\n+            anyContinue |= semanticScope.getCondition(userStatementNode, AnyContinue.class);\n+            anyBreak |= semanticScope.getCondition(userStatementNode, AnyBreak.class);\n+        }\n+\n+        if (anyContinue) {\n+            semanticScope.setCondition(userBlockNode, AnyContinue.class);\n+        }\n+\n+        if (anyBreak) {\n+            semanticScope.setCondition(userBlockNode, AnyBreak.class);\n+        }\n+    }\n+\n+    @Override\n+    public void visitIf(SIf userIfNode, SemanticScope semanticScope) {\n+        AExpression userConditionNode = userIfNode.getConditionNode();\n+        semanticScope.setCondition(userConditionNode, Read.class);\n+        semanticScope.putDecoration(userConditionNode, new TargetType(boolean.class));\n+        checkedVisit(userConditionNode, semanticScope);\n+        decorateWithCast(userConditionNode, semanticScope);\n+\n+        SBlock userIfBlockNode = userIfNode.getIfBlockNode();\n+\n+        if (userConditionNode instanceof EBooleanConstant || userIfBlockNode == null) {\n+            throw userIfNode.createError(new IllegalArgumentException(\"extraneous if block\"));\n+        }\n+\n+        semanticScope.replicateCondition(userIfNode, userIfBlockNode, LastSource.class);\n+        semanticScope.replicateCondition(userIfNode, userIfBlockNode, InLoop.class);\n+        semanticScope.replicateCondition(userIfNode, userIfBlockNode, LastLoop.class);\n+        visit(userIfBlockNode, semanticScope.newLocalScope());\n+        semanticScope.replicateCondition(userIfBlockNode, userIfNode, AnyContinue.class);\n+        semanticScope.replicateCondition(userIfBlockNode, userIfNode, AnyBreak.class);\n+    }\n+\n+    @Override\n+    public void visitIfElse(SIfElse userIfElseNode, SemanticScope semanticScope) {\n+        AExpression userConditionNode = userIfElseNode.getConditionNode();\n+        semanticScope.setCondition(userConditionNode, Read.class);\n+        semanticScope.putDecoration(userConditionNode, new TargetType(boolean.class));\n+        checkedVisit(userConditionNode, semanticScope);\n+        decorateWithCast(userConditionNode, semanticScope);\n+\n+        SBlock userIfBlockNode = userIfElseNode.getIfBlockNode();\n+\n+        if (userConditionNode instanceof EBooleanConstant || userIfBlockNode == null) {\n+            throw userIfElseNode.createError(new IllegalArgumentException(\"extraneous if block\"));\n+        }\n+\n+        semanticScope.replicateCondition(userIfElseNode, userIfBlockNode, LastSource.class);\n+        semanticScope.replicateCondition(userIfElseNode, userIfBlockNode, InLoop.class);\n+        semanticScope.replicateCondition(userIfElseNode, userIfBlockNode, LastLoop.class);\n+        visit(userIfBlockNode, semanticScope.newLocalScope());\n+\n+        SBlock userElseBlockNode = userIfElseNode.getElseBlockNode();\n+\n+        if (userElseBlockNode == null) {\n+            throw userIfElseNode.createError(new IllegalArgumentException(\"extraneous else block.\"));\n+        }\n+\n+        semanticScope.replicateCondition(userIfElseNode, userElseBlockNode, LastSource.class);\n+        semanticScope.replicateCondition(userIfElseNode, userElseBlockNode, InLoop.class);\n+        semanticScope.replicateCondition(userIfElseNode, userElseBlockNode, LastLoop.class);\n+        visit(userElseBlockNode, semanticScope.newLocalScope());\n+\n+        if (semanticScope.getCondition(userIfBlockNode, MethodEscape.class) &&\n+                semanticScope.getCondition(userElseBlockNode, MethodEscape.class)) {\n+            semanticScope.setCondition(userIfElseNode, MethodEscape.class);\n+        }\n+\n+        if (semanticScope.getCondition(userIfBlockNode, LoopEscape.class) &&\n+                semanticScope.getCondition(userElseBlockNode, LoopEscape.class)) {\n+            semanticScope.setCondition(userIfElseNode, LoopEscape.class);\n+        }\n+\n+        if (semanticScope.getCondition(userIfBlockNode, AllEscape.class) &&\n+                semanticScope.getCondition(userElseBlockNode, AllEscape.class)) {\n+            semanticScope.setCondition(userIfElseNode, AllEscape.class);\n+        }\n+\n+        if (semanticScope.getCondition(userIfBlockNode, AnyContinue.class) ||\n+                semanticScope.getCondition(userElseBlockNode, AnyContinue.class)) {\n+            semanticScope.setCondition(userIfElseNode, AnyContinue.class);\n+        }\n+\n+        if (semanticScope.getCondition(userIfBlockNode, AnyBreak.class) ||\n+                semanticScope.getCondition(userElseBlockNode, AnyBreak.class)) {\n+            semanticScope.setCondition(userIfElseNode, AnyBreak.class);\n+        }\n+    }\n+\n+    @Override\n+    public void visitWhile(SWhile userWhileNode, SemanticScope semanticScope) {\n+        semanticScope = semanticScope.newLocalScope();\n+\n+        AExpression userConditionNode = userWhileNode.getConditionNode();\n+        semanticScope.setCondition(userConditionNode, Read.class);\n+        semanticScope.putDecoration(userConditionNode, new TargetType(boolean.class));\n+        checkedVisit(userConditionNode, semanticScope);\n+        decorateWithCast(userConditionNode, semanticScope);\n+\n+        SBlock userBlockNode = userWhileNode.getBlockNode();\n+        boolean continuous = false;\n+\n+        if (userConditionNode instanceof EBooleanConstant) {\n+            continuous = ((EBooleanConstant)userConditionNode).getBool();\n+\n+            if (continuous == false) {\n+                throw userWhileNode.createError(new IllegalArgumentException(\"extraneous while loop\"));\n+            } else {\n+                semanticScope.setCondition(userWhileNode, ContinuousLoop.class);\n+            }\n+\n+            if (userBlockNode == null) {\n+                throw userWhileNode.createError(new IllegalArgumentException(\"no paths escape from while loop\"));\n+            }\n+        }\n+\n+        if (userBlockNode != null) {\n+            semanticScope.setCondition(userBlockNode, BeginLoop.class);\n+            semanticScope.setCondition(userBlockNode, InLoop.class);\n+            visit(userBlockNode, semanticScope);\n+\n+            if (semanticScope.getCondition(userBlockNode, LoopEscape.class) &&\n+                    semanticScope.getCondition(userBlockNode, AnyContinue.class) == false) {\n+                throw userWhileNode.createError(new IllegalArgumentException(\"extraneous while loop\"));\n+            }\n+\n+            if (continuous && semanticScope.getCondition(userBlockNode, AnyBreak.class) == false) {\n+                semanticScope.setCondition(userWhileNode, MethodEscape.class);\n+                semanticScope.setCondition(userWhileNode, AllEscape.class);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitDo(SDo userDoNode, SemanticScope semanticScope) {\n+        semanticScope = semanticScope.newLocalScope();\n+\n+        SBlock userBlockNode = userDoNode.getBlockNode();\n+\n+        if (userBlockNode == null) {\n+            throw userDoNode.createError(new IllegalArgumentException(\"extraneous do-while loop\"));\n+        }\n+\n+        semanticScope.setCondition(userBlockNode, BeginLoop.class);\n+        semanticScope.setCondition(userBlockNode, InLoop.class);\n+        visit(userBlockNode, semanticScope);\n+\n+        if (semanticScope.getCondition(userBlockNode, LoopEscape.class) &&\n+                semanticScope.getCondition(userBlockNode, AnyContinue.class) == false) {\n+            throw userDoNode.createError(new IllegalArgumentException(\"extraneous do-while loop\"));\n+        }\n+\n+        AExpression userConditionNode = userDoNode.getConditionNode();\n+\n+        semanticScope.setCondition(userConditionNode, Read.class);\n+        semanticScope.putDecoration(userConditionNode, new TargetType(boolean.class));\n+        checkedVisit(userConditionNode, semanticScope);\n+        decorateWithCast(userConditionNode, semanticScope);\n+\n+        boolean continuous;\n+\n+        if (userConditionNode instanceof EBooleanConstant) {\n+            continuous = ((EBooleanConstant)userConditionNode).getBool();\n+\n+            if (continuous == false) {\n+                throw userDoNode.createError(new IllegalArgumentException(\"extraneous do-while loop\"));\n+            } else {\n+                semanticScope.setCondition(userDoNode, ContinuousLoop.class);\n+            }\n+\n+            if (semanticScope.getCondition(userBlockNode, AnyBreak.class) == false) {\n+                semanticScope.setCondition(userDoNode, MethodEscape.class);\n+                semanticScope.setCondition(userDoNode, AllEscape.class);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitFor(SFor userForNode, SemanticScope semanticScope) {\n+        semanticScope = semanticScope.newLocalScope();\n+\n+        ANode userInitializerNode = userForNode.getInitializerNode();\n+\n+        if (userInitializerNode != null) {\n+            if (userInitializerNode instanceof SDeclBlock) {\n+                visit(userInitializerNode, semanticScope);\n+            } else if (userInitializerNode instanceof AExpression) {\n+                checkedVisit((AExpression)userInitializerNode, semanticScope);\n+            } else {\n+                throw userForNode.createError(new IllegalStateException(\"illegal tree structure\"));\n+            }\n+        }\n+\n+        AExpression userConditionNode = userForNode.getConditionNode();\n+        SBlock userBlockNode = userForNode.getBlockNode();\n+        boolean continuous = false;\n+\n+        if (userConditionNode != null) {\n+            semanticScope.setCondition(userConditionNode, Read.class);\n+            semanticScope.putDecoration(userConditionNode, new TargetType(boolean.class));\n+            checkedVisit(userConditionNode, semanticScope);\n+            decorateWithCast(userConditionNode, semanticScope);\n+\n+            if (userConditionNode instanceof EBooleanConstant) {\n+                continuous = ((EBooleanConstant)userConditionNode).getBool();\n+\n+                if (continuous == false) {\n+                    throw userForNode.createError(new IllegalArgumentException(\"extraneous for loop\"));\n+                }\n+\n+                if (userBlockNode == null) {\n+                    throw userForNode.createError(new IllegalArgumentException(\"no paths escape from for loop\"));\n+                }\n+            }\n+        } else {\n+            continuous = true;\n+        }\n+\n+        AExpression userAfterthoughtNode = userForNode.getAfterthoughtNode();\n+\n+        if (userAfterthoughtNode != null) {\n+            checkedVisit(userAfterthoughtNode, semanticScope);\n+        }\n+\n+        if (userBlockNode != null) {\n+            semanticScope.setCondition(userBlockNode, BeginLoop.class);\n+            semanticScope.setCondition(userBlockNode, InLoop.class);\n+            visit(userBlockNode, semanticScope);\n+\n+            if (semanticScope.getCondition(userBlockNode, LoopEscape.class) &&\n+                    semanticScope.getCondition(userBlockNode, AnyContinue.class) == false) {\n+                throw userForNode.createError(new IllegalArgumentException(\"extraneous for loop\"));\n+            }\n+\n+            if (continuous && semanticScope.getCondition(userBlockNode, AnyBreak.class) == false) {\n+                semanticScope.setCondition(userForNode, MethodEscape.class);\n+                semanticScope.setCondition(userForNode, AllEscape.class);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitEach(SEach userEachNode, SemanticScope semanticScope) {\n+        AExpression userIterableNode = userEachNode.getIterableNode();\n+        semanticScope.setCondition(userIterableNode, Read.class);\n+        checkedVisit(userIterableNode, semanticScope);\n+\n+        String canonicalTypeName = userEachNode.getCanonicalTypeName();\n+        Class<?> type = semanticScope.getScriptScope().getPainlessLookup().canonicalTypeNameToType(canonicalTypeName);\n+\n+        if (type == null) {\n+            throw userEachNode.createError(new IllegalArgumentException(\n+                    \"invalid foreach loop: type [\" + canonicalTypeName + \"] not found\"));\n+        }\n+\n+        semanticScope = semanticScope.newLocalScope();\n+\n+        Location location = userEachNode.getLocation();\n+        String symbol = userEachNode.getSymbol();\n+        Variable variable = semanticScope.defineVariable(location, type, symbol, true);\n+        semanticScope.putDecoration(userEachNode, new SemanticVariable(variable));\n+\n+        SBlock userBlockNode = userEachNode.getBlockNode();\n+\n+        if (userBlockNode == null) {\n+            throw userEachNode.createError(new IllegalArgumentException(\"extraneous foreach loop\"));\n+        }\n+\n+        semanticScope.setCondition(userBlockNode, BeginLoop.class);\n+        semanticScope.setCondition(userBlockNode, InLoop.class);\n+        visit(userBlockNode, semanticScope);\n+\n+        if (semanticScope.getCondition(userBlockNode, LoopEscape.class) &&\n+                semanticScope.getCondition(userBlockNode, AnyContinue.class) == false) {\n+            throw userEachNode.createError(new IllegalArgumentException(\"extraneous foreach loop\"));\n+        }\n+\n+        Class<?> iterableValueType = semanticScope.getDecoration(userIterableNode, ValueType.class).getValueType();\n+\n+        if (iterableValueType.isArray()) {\n+            PainlessCast painlessCast =\n+                    AnalyzerCaster.getLegalCast(location, iterableValueType.getComponentType(), variable.getType(), true, true);\n+\n+            if (painlessCast != null) {\n+                semanticScope.putDecoration(userEachNode, new ExpressionPainlessCast(painlessCast));\n+            }\n+        } else if (iterableValueType == def.class || Iterable.class.isAssignableFrom(iterableValueType)) {\n+            if (iterableValueType != def.class) {\n+                PainlessMethod method = semanticScope.getScriptScope().getPainlessLookup().\n+                        lookupPainlessMethod(iterableValueType, false, \"iterator\", 0);\n+\n+                if (method == null) {\n+                    throw userEachNode.createError(new IllegalArgumentException(\"invalid foreach loop: \" +\n+                            \"method [\" + typeToCanonicalTypeName(iterableValueType) + \", iterator/0] not found\"));\n+                }\n+\n+                semanticScope.putDecoration(userEachNode, new IterablePainlessMethod(method));\n+            }\n+\n+            PainlessCast painlessCast = AnalyzerCaster.getLegalCast(location, def.class, type, true, true);\n+\n+            if (painlessCast != null) {\n+                semanticScope.putDecoration(userEachNode, new ExpressionPainlessCast(painlessCast));\n+            }\n+        } else {\n+            throw userEachNode.createError(new IllegalArgumentException(\"invalid foreach loop: \" +\n+                    \"cannot iterate over type [\" + PainlessLookupUtility.typeToCanonicalTypeName(iterableValueType) + \"].\"));\n+        }\n+    }\n+\n+    @Override\n+    public void visitDeclBlock(SDeclBlock userDeclBlockNode, SemanticScope semanticScope) {\n+        for (SDeclaration userDeclarationNode : userDeclBlockNode.getDeclarationNodes()) {\n+            visit(userDeclarationNode, semanticScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitDeclaration(SDeclaration userDeclarationNode, SemanticScope semanticScope) {\n+        ScriptScope scriptScope = semanticScope.getScriptScope();\n+        String symbol = userDeclarationNode.getSymbol();\n+\n+        if (scriptScope.getPainlessLookup().isValidCanonicalClassName(symbol)) {\n+            throw userDeclarationNode.createError(new IllegalArgumentException(\n+                    \"invalid declaration: type [\" + symbol + \"] cannot be a name\"));\n+        }\n+\n+        String canonicalTypeName = userDeclarationNode.getCanonicalTypeName();\n+        Class<?> type = scriptScope.getPainlessLookup().canonicalTypeNameToType(canonicalTypeName);\n+\n+        if (type == null) {\n+            throw userDeclarationNode.createError(new IllegalArgumentException(\n+                    \"invalid declaration: cannot resolve type [\" + canonicalTypeName + \"]\"));\n+        }\n+\n+        AExpression userValueNode = userDeclarationNode.getValueNode();\n+\n+        if (userValueNode != null) {\n+            semanticScope.setCondition(userValueNode, Read.class);\n+            semanticScope.putDecoration(userValueNode, new TargetType(type));\n+            checkedVisit(userValueNode, semanticScope);\n+            decorateWithCast(userValueNode, semanticScope);\n+        }\n+\n+        Location location = userDeclarationNode.getLocation();\n+        Variable variable = semanticScope.defineVariable(location, type, symbol, false);\n+        semanticScope.putDecoration(userDeclarationNode, new SemanticVariable(variable));\n+    }\n+\n+    @Override\n+    public void visitReturn(SReturn userReturnNode, SemanticScope semanticScope) {\n+        AExpression userValueNode = userReturnNode.getValueNode();\n+\n+        if (userValueNode == null) {\n+            if (semanticScope.getReturnType() != void.class) {\n+                throw userReturnNode.createError(new ClassCastException(\"cannot cast from \" +\n+                        \"[\" + semanticScope.getReturnCanonicalTypeName() + \"] to \" +\n+                        \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(void.class) + \"]\"));\n+            }\n+        } else {\n+            semanticScope.setCondition(userValueNode, Read.class);\n+            semanticScope.putDecoration(userValueNode, new TargetType(semanticScope.getReturnType()));\n+            semanticScope.setCondition(userValueNode, Internal.class);\n+            checkedVisit(userValueNode, semanticScope);\n+            decorateWithCast(userValueNode, semanticScope);\n+        }\n+\n+        semanticScope.setCondition(userReturnNode, MethodEscape.class);\n+        semanticScope.setCondition(userReturnNode, LoopEscape.class);\n+        semanticScope.setCondition(userReturnNode, AllEscape.class);\n+    }\n+\n+    @Override\n+    public void visitExpression(SExpression userExpressionNode, SemanticScope semanticScope) {\n+        Class<?> rtnType = semanticScope.getReturnType();\n+        boolean isVoid = rtnType == void.class;\n+        boolean lastSource = semanticScope.getCondition(userExpressionNode, LastSource.class);\n+        AExpression userStatementNode = userExpressionNode.getStatementNode();\n+\n+        if (lastSource && isVoid == false) {\n+            semanticScope.setCondition(userStatementNode, Read.class);\n+        }\n+\n+        checkedVisit(userStatementNode, semanticScope);\n+        Class<?> expressionValueType = semanticScope.getDecoration(userStatementNode, ValueType.class).getValueType();\n+        boolean rtn = lastSource && isVoid == false && expressionValueType != void.class;\n+\n+        if (rtn) {\n+            semanticScope.putDecoration(userStatementNode, new TargetType(rtnType));\n+            semanticScope.setCondition(userStatementNode, Internal.class);\n+            decorateWithCast(userStatementNode, semanticScope);\n+\n+            semanticScope.setCondition(userExpressionNode, MethodEscape.class);\n+            semanticScope.setCondition(userExpressionNode, LoopEscape.class);\n+            semanticScope.setCondition(userExpressionNode, AllEscape.class);\n+        }\n+    }\n+\n+    @Override\n+    public void visitTry(STry userTryNode, SemanticScope semanticScope) {\n+        SBlock userBlockNode = userTryNode.getBlockNode();\n+\n+        if (userBlockNode == null) {\n+            throw userTryNode.createError(new IllegalArgumentException(\"extraneous try statement\"));\n+        }\n+\n+        semanticScope.replicateCondition(userTryNode, userBlockNode, LastSource.class);\n+        semanticScope.replicateCondition(userTryNode, userBlockNode, InLoop.class);\n+        semanticScope.replicateCondition(userTryNode, userBlockNode, LastLoop.class);\n+        visit(userBlockNode, semanticScope.newLocalScope());\n+\n+        boolean methodEscape = semanticScope.getCondition(userBlockNode, MethodEscape.class);\n+        boolean loopEscape = semanticScope.getCondition(userBlockNode, LoopEscape.class);\n+        boolean allEscape = semanticScope.getCondition(userBlockNode, AllEscape.class);\n+        boolean anyContinue = semanticScope.getCondition(userBlockNode, AnyContinue.class);\n+        boolean anyBreak = semanticScope.getCondition(userBlockNode, AnyBreak.class);\n+\n+        for (SCatch userCatchNode : userTryNode.getCatchNodes()) {\n+            semanticScope.replicateCondition(userTryNode, userCatchNode, LastSource.class);\n+            semanticScope.replicateCondition(userTryNode, userCatchNode, InLoop.class);\n+            semanticScope.replicateCondition(userTryNode, userCatchNode, LastLoop.class);\n+            visit(userCatchNode, semanticScope.newLocalScope());\n+\n+            methodEscape &= semanticScope.getCondition(userCatchNode, MethodEscape.class);\n+            loopEscape &= semanticScope.getCondition(userCatchNode, LoopEscape.class);\n+            allEscape &= semanticScope.getCondition(userCatchNode, AllEscape.class);\n+            anyContinue |= semanticScope.getCondition(userCatchNode, AnyContinue.class);\n+            anyBreak |= semanticScope.getCondition(userCatchNode, AnyBreak.class);\n+        }\n+\n+        if (methodEscape) {\n+            semanticScope.setCondition(userTryNode, MethodEscape.class);\n+        }\n+\n+        if (loopEscape) {\n+            semanticScope.setCondition(userTryNode, LoopEscape.class);\n+        }\n+\n+        if (allEscape) {\n+            semanticScope.setCondition(userTryNode, AllEscape.class);\n+        }\n+\n+        if (anyContinue) {\n+            semanticScope.setCondition(userTryNode, AnyContinue.class);\n+        }\n+\n+        if (anyBreak) {\n+            semanticScope.setCondition(userTryNode, AnyBreak.class);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCatch(SCatch userCatchNode, SemanticScope semanticScope) {\n+        ScriptScope scriptScope = semanticScope.getScriptScope();\n+        String symbol = userCatchNode.getSymbol();\n+\n+        if (scriptScope.getPainlessLookup().isValidCanonicalClassName(symbol)) {\n+            throw userCatchNode.createError(new IllegalArgumentException(\n+                    \"invalid catch declaration: type [\" + symbol + \"] cannot be a name\"));\n+        }\n+\n+        String canonicalTypeName = userCatchNode.getCanonicalTypeName();\n+        Class<?> type = scriptScope.getPainlessLookup().canonicalTypeNameToType(canonicalTypeName);\n+\n+        if (type == null) {\n+            throw userCatchNode.createError(new IllegalArgumentException(\n+                    \"invalid catch declaration: cannot resolve type [\" + canonicalTypeName + \"]\"));\n+        }\n+\n+        Location location = userCatchNode.getLocation();\n+        Variable variable = semanticScope.defineVariable(location, type, symbol, false);\n+        semanticScope.putDecoration(userCatchNode, new SemanticVariable(variable));\n+        Class<?> baseException = userCatchNode.getBaseException();\n+\n+        if (userCatchNode.getBaseException().isAssignableFrom(type) == false) {\n+            throw userCatchNode.createError(new ClassCastException(\n+                    \"cannot cast from [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] \" +\n+                            \"to [\" + PainlessLookupUtility.typeToCanonicalTypeName(baseException) + \"]\"));\n+        }\n+\n+        SBlock userBlockNode = userCatchNode.getBlockNode();\n+\n+        if (userBlockNode != null) {\n+            semanticScope.replicateCondition(userCatchNode, userBlockNode, LastSource.class);\n+            semanticScope.replicateCondition(userCatchNode, userBlockNode, InLoop.class);\n+            semanticScope.replicateCondition(userCatchNode, userBlockNode, LastLoop.class);\n+            visit(userBlockNode, semanticScope);\n+\n+            semanticScope.replicateCondition(userBlockNode, userCatchNode, MethodEscape.class);\n+            semanticScope.replicateCondition(userBlockNode, userCatchNode, LoopEscape.class);\n+            semanticScope.replicateCondition(userBlockNode, userCatchNode, AllEscape.class);\n+            semanticScope.replicateCondition(userBlockNode, userCatchNode, AnyContinue.class);\n+            semanticScope.replicateCondition(userBlockNode, userCatchNode, AnyBreak.class);\n+        }\n+    }\n+\n+    @Override\n+    public void visitThrow(SThrow userThrowNode, SemanticScope semanticScope) {\n+        AExpression userExpressionNode = userThrowNode.getExpressionNode();\n+\n+        semanticScope.setCondition(userExpressionNode, Read.class);\n+        semanticScope.putDecoration(userExpressionNode, new TargetType(Exception.class));\n+        checkedVisit(userExpressionNode, semanticScope);\n+        decorateWithCast(userExpressionNode, semanticScope);\n+\n+        semanticScope.setCondition(userThrowNode, MethodEscape.class);\n+        semanticScope.setCondition(userThrowNode, LoopEscape.class);\n+        semanticScope.setCondition(userThrowNode, AllEscape.class);\n+    }\n+\n+    @Override\n+    public void visitContinue(SContinue userContinueNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userContinueNode, InLoop.class) == false) {\n+            throw userContinueNode.createError(new IllegalArgumentException(\"invalid continue statement: not inside loop\"));\n+        }\n+\n+        if (semanticScope.getCondition(userContinueNode, LastLoop.class)) {\n+            throw userContinueNode.createError(new IllegalArgumentException(\"extraneous continue statement\"));\n+        }\n+\n+        semanticScope.setCondition(userContinueNode, AllEscape.class);\n+        semanticScope.setCondition(userContinueNode, AnyContinue.class);\n+    }\n+\n+    @Override\n+    public void visitBreak(SBreak userBreakNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userBreakNode, InLoop.class) == false) {\n+            throw userBreakNode.createError(new IllegalArgumentException(\"invalid break statement: not inside loop\"));\n+        }\n+\n+        semanticScope.setCondition(userBreakNode, AllEscape.class);\n+        semanticScope.setCondition(userBreakNode, LoopEscape.class);\n+        semanticScope.setCondition(userBreakNode, AnyBreak.class);\n+    }\n+\n+    @Override\n+    public void visitAssignment(EAssignment userAssignmentNode, SemanticScope semanticScope) {\n+        AExpression userLeftNode = userAssignmentNode.getLeftNode();\n+        semanticScope.replicateCondition(userAssignmentNode, userLeftNode, Read.class);\n+        semanticScope.setCondition(userLeftNode, Write.class);\n+        checkedVisit(userLeftNode, semanticScope);\n+        Class<?> leftValueType = semanticScope.getDecoration(userLeftNode, Decorations.ValueType.class).getValueType();\n+\n+        AExpression userRightNode = userAssignmentNode.getRightNode();\n+        semanticScope.setCondition(userRightNode, Read.class);\n+\n+        Operation operation = userAssignmentNode.getOperation();\n+\n+        if (operation != null) {\n+            checkedVisit(userRightNode, semanticScope);\n+            Class<?> rightValueType = semanticScope.getDecoration(userRightNode, ValueType.class).getValueType();\n+\n+            Class<?> compoundType;\n+            Class<?> shiftType = null;\n+            boolean isShift = false;\n+\n+            if (operation == Operation.MUL) {\n+                compoundType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, true);\n+            } else if (operation == Operation.DIV) {\n+                compoundType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, true);\n+            } else if (operation == Operation.REM) {\n+                compoundType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, true);\n+            } else if (operation == Operation.ADD) {\n+                compoundType = AnalyzerCaster.promoteAdd(leftValueType, rightValueType);\n+            } else if (operation == Operation.SUB) {\n+                compoundType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, true);\n+            } else if (operation == Operation.LSH) {\n+                compoundType = AnalyzerCaster.promoteNumeric(leftValueType, false);\n+                shiftType = AnalyzerCaster.promoteNumeric(rightValueType, false);\n+                isShift = true;\n+            } else if (operation == Operation.RSH) {\n+                compoundType = AnalyzerCaster.promoteNumeric(leftValueType, false);\n+                shiftType = AnalyzerCaster.promoteNumeric(rightValueType, false);\n+                isShift = true;\n+            } else if (operation == Operation.USH) {\n+                compoundType = AnalyzerCaster.promoteNumeric(leftValueType, false);\n+                shiftType = AnalyzerCaster.promoteNumeric(rightValueType, false);\n+                isShift = true;\n+            } else if (operation == Operation.BWAND) {\n+                compoundType = AnalyzerCaster.promoteXor(leftValueType, rightValueType);\n+            } else if (operation == Operation.XOR) {\n+                compoundType = AnalyzerCaster.promoteXor(leftValueType, rightValueType);\n+            } else if (operation == Operation.BWOR) {\n+                compoundType = AnalyzerCaster.promoteXor(leftValueType, rightValueType);\n+            } else {\n+                throw userAssignmentNode.createError(new IllegalStateException(\"illegal tree structure\"));\n+            }\n+\n+            if (compoundType == null || (isShift && shiftType == null)) {\n+                throw userAssignmentNode.createError(new ClassCastException(\"invalid compound assignment: \" +\n+                        \"cannot apply [\" + operation.symbol + \"=] to types [\" + leftValueType + \"] and [\" + rightValueType + \"]\"));\n+            }\n+\n+            boolean cat = operation == Operation.ADD && compoundType == String.class;\n+\n+            if (cat && userRightNode instanceof EBinary &&\n+                    ((EBinary)userRightNode).getOperation() == Operation.ADD && rightValueType == String.class) {\n+                semanticScope.setCondition(userRightNode, Concatenate.class);\n+            }\n+\n+            if (isShift) {\n+                if (compoundType == def.class) {\n+                    // shifts are promoted independently, but for the def type, we need object.\n+                    semanticScope.putDecoration(userRightNode, new TargetType(def.class));\n+                } else if (shiftType == long.class) {\n+                    semanticScope.putDecoration(userRightNode, new TargetType(int.class));\n+                    semanticScope.setCondition(userRightNode, Explicit.class);\n+                } else {\n+                    semanticScope.putDecoration(userRightNode, new TargetType(shiftType));\n+                }\n+            } else {\n+                semanticScope.putDecoration(userRightNode, new TargetType(compoundType));\n+            }\n+\n+            decorateWithCast(userRightNode, semanticScope);\n+\n+            Location location = userAssignmentNode.getLocation();\n+            PainlessCast upcast = AnalyzerCaster.getLegalCast(location, leftValueType, compoundType, false, false);\n+            PainlessCast downcast = AnalyzerCaster.getLegalCast(location, compoundType, leftValueType, true, false);\n+\n+            semanticScope.putDecoration(userAssignmentNode, new CompoundType(compoundType));\n+\n+            if (cat) {\n+                semanticScope.setCondition(userAssignmentNode, Concatenate.class);\n+            }\n+\n+            if (upcast != null) {\n+                semanticScope.putDecoration(userAssignmentNode, new UpcastPainlessCast(upcast));\n+            }\n+\n+            if (downcast != null) {\n+                semanticScope.putDecoration(userAssignmentNode, new DowncastPainlessCast(downcast));\n+            }\n+            // if the lhs node is a def optimized node we update the actual type to remove the need for a cast\n+        } else if (semanticScope.getCondition(userLeftNode, DefOptimized.class)) {\n+            checkedVisit(userRightNode, semanticScope);\n+            Class<?> rightValueType = semanticScope.getDecoration(userRightNode, ValueType.class).getValueType();\n+\n+            if (rightValueType == void.class) {\n+                throw userAssignmentNode.createError(new IllegalArgumentException(\n+                        \"invalid assignment: cannot assign type [\" + PainlessLookupUtility.typeToCanonicalTypeName(void.class) + \"]\"));\n+            }\n+\n+            semanticScope.putDecoration(userLeftNode, new ValueType(rightValueType));\n+            leftValueType = rightValueType;\n+            // Otherwise, we must adapt the rhs type to the lhs type with a cast.\n+        } else {\n+            semanticScope.putDecoration(userRightNode, new TargetType(leftValueType));\n+            checkedVisit(userRightNode, semanticScope);\n+            decorateWithCast(userRightNode, semanticScope);\n+        }\n+\n+        semanticScope.putDecoration(userAssignmentNode,\n+                new ValueType(semanticScope.getCondition(userAssignmentNode, Read.class) ? leftValueType : void.class));\n+    }\n+\n+    @Override\n+    public void visitUnary(EUnary userUnaryNode, SemanticScope semanticScope) {\n+        Operation operation = userUnaryNode.getOperation();\n+\n+        if (semanticScope.getCondition(userUnaryNode, Write.class)) {\n+            throw userUnaryNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userUnaryNode, Read.class) == false) {\n+            throw userUnaryNode.createError(new IllegalArgumentException(\n+                    \"not a statement: result not used from \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        AExpression userChildNode = userUnaryNode.getChildNode();\n+        Class<?> valueType;\n+        Class<?> unaryType = null;\n+\n+        if (operation == Operation.SUB && (userChildNode instanceof ENumeric || userChildNode instanceof EDecimal)) {\n+            semanticScope.setCondition(userChildNode, Read.class);\n+            semanticScope.copyDecoration(userUnaryNode, userChildNode, TargetType.class);\n+            semanticScope.replicateCondition(userUnaryNode, userChildNode, Explicit.class);\n+            semanticScope.replicateCondition(userUnaryNode, userChildNode, Internal.class);\n+            semanticScope.setCondition(userChildNode, Negate.class);\n+            checkedVisit(userChildNode, semanticScope);\n+\n+            if (semanticScope.hasDecoration(userUnaryNode, TargetType.class)) {\n+                decorateWithCast(userChildNode, semanticScope);\n+            }\n+\n+            valueType = semanticScope.getDecoration(userChildNode, ValueType.class).getValueType();\n+        } else {\n+            if (operation == Operation.NOT) {\n+                semanticScope.setCondition(userChildNode, Read.class);\n+                semanticScope.putDecoration(userChildNode, new TargetType(boolean.class));\n+                checkedVisit(userChildNode, semanticScope);\n+                decorateWithCast(userChildNode, semanticScope);\n+\n+                valueType = boolean.class;\n+            } else if (operation == Operation.BWNOT || operation == Operation.ADD || operation == Operation.SUB) {\n+                semanticScope.setCondition(userChildNode, Read.class);\n+                checkedVisit(userChildNode, semanticScope);\n+                Class<?> childValueType = semanticScope.getDecoration(userChildNode, ValueType.class).getValueType();\n+\n+                unaryType = AnalyzerCaster.promoteNumeric(childValueType, operation != Operation.BWNOT);\n+\n+                if (unaryType == null) {\n+                    throw userUnaryNode.createError(new ClassCastException(\"cannot apply the \" + operation.name + \" operator \" +\n+                            \"[\" + operation.symbol + \"] to the type \" +\n+                            \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(childValueType) + \"]\"));\n+                }\n+\n+                semanticScope.putDecoration(userChildNode, new TargetType(unaryType));\n+                decorateWithCast(userChildNode, semanticScope);\n+\n+                TargetType targetType = semanticScope.getDecoration(userUnaryNode, TargetType.class);\n+\n+                if (unaryType == def.class && targetType != null) {\n+                    valueType = targetType.getTargetType();\n+                } else {\n+                    valueType = unaryType;\n+                }\n+            } else {\n+                throw userUnaryNode.createError(new IllegalStateException(\"unexpected unary operation [\" + operation.name + \"]\"));\n+            }\n+        }\n+\n+        semanticScope.putDecoration(userUnaryNode, new ValueType(valueType));\n+\n+        if (unaryType != null) {\n+            semanticScope.putDecoration(userUnaryNode, new UnaryType(unaryType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitBinary(EBinary userBinaryNode, SemanticScope semanticScope) {\n+        Operation operation = userBinaryNode.getOperation();\n+\n+        if (semanticScope.getCondition(userBinaryNode, Write.class)) {\n+            throw userBinaryNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userBinaryNode, Read.class) == false) {\n+            throw userBinaryNode.createError(new IllegalArgumentException(\n+                    \"not a statement: result not used from \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        AExpression userLeftNode = userBinaryNode.getLeftNode();\n+        semanticScope.setCondition(userLeftNode, Read.class);\n+        checkedVisit(userLeftNode, semanticScope);\n+        Class<?> leftValueType = semanticScope.getDecoration(userLeftNode, ValueType.class).getValueType();\n+\n+        AExpression userRightNode = userBinaryNode.getRightNode();\n+        semanticScope.setCondition(userRightNode, Read.class);\n+        checkedVisit(userRightNode, semanticScope);\n+        Class<?> rightValueType = semanticScope.getDecoration(userRightNode, ValueType.class).getValueType();\n+\n+        Class<?> valueType;\n+        Class<?> binaryType;\n+        Class<?> shiftType = null;\n+\n+        if (operation == Operation.FIND || operation == Operation.MATCH) {\n+            semanticScope.putDecoration(userLeftNode, new TargetType(String.class));\n+            semanticScope.putDecoration(userRightNode, new TargetType(Pattern.class));\n+            decorateWithCast(userLeftNode, semanticScope);\n+            decorateWithCast(userRightNode, semanticScope);\n+            binaryType = boolean.class;\n+            valueType = boolean.class;\n+        } else {\n+            if (operation == Operation.MUL || operation == Operation.DIV || operation == Operation.REM) {\n+                binaryType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, true);\n+            } else if (operation == Operation.ADD) {\n+                binaryType = AnalyzerCaster.promoteAdd(leftValueType, rightValueType);\n+            } else if (operation == Operation.SUB) {\n+                binaryType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, true);\n+            } else if (operation == Operation.LSH || operation == Operation.RSH || operation == Operation.USH) {\n+                binaryType = AnalyzerCaster.promoteNumeric(leftValueType, false);\n+                shiftType = AnalyzerCaster.promoteNumeric(rightValueType, false);\n+\n+                if (shiftType == null) {\n+                    binaryType = null;\n+                }\n+            } else if (operation == Operation.BWOR || operation == Operation.BWAND) {\n+                binaryType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, false);\n+            } else if (operation == Operation.XOR) {\n+                binaryType = AnalyzerCaster.promoteXor(leftValueType, rightValueType);\n+            } else {\n+                throw userBinaryNode.createError(new IllegalStateException(\"unexpected binary operation [\" + operation.name + \"]\"));\n+            }\n+\n+            if (binaryType == null) {\n+                throw userBinaryNode.createError(new ClassCastException(\"cannot apply the \" + operation.name + \" operator \" +\n+                        \"[\" + operation.symbol + \"] to the types \" +\n+                        \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(leftValueType) + \"] and \" +\n+                        \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(rightValueType) + \"]\"));\n+            }\n+\n+            valueType = binaryType;\n+\n+            if (operation == Operation.ADD && binaryType == String.class) {\n+                if (userLeftNode instanceof EBinary &&\n+                        ((EBinary)userLeftNode).getOperation() == Operation.ADD && leftValueType == String.class) {\n+                    semanticScope.setCondition(userLeftNode, Concatenate.class);\n+                }\n+\n+                if (userRightNode instanceof EBinary &&\n+                        ((EBinary)userRightNode).getOperation() == Operation.ADD && rightValueType == String.class) {\n+                    semanticScope.setCondition(userRightNode, Concatenate.class);\n+                }\n+            } else if (binaryType == def.class || shiftType == def.class) {\n+                TargetType targetType = semanticScope.getDecoration(userBinaryNode, TargetType.class);\n+\n+                if (targetType != null) {\n+                    valueType = targetType.getTargetType();\n+                }\n+            } else {\n+                semanticScope.putDecoration(userLeftNode, new TargetType(binaryType));\n+\n+                if (operation == Operation.LSH || operation == Operation.RSH || operation == Operation.USH) {\n+                    if (shiftType == long.class) {\n+                        semanticScope.putDecoration(userRightNode, new TargetType(int.class));\n+                        semanticScope.setCondition(userRightNode, Explicit.class);\n+                    } else {\n+                        semanticScope.putDecoration(userRightNode, new TargetType(shiftType));\n+                    }\n+                } else {\n+                    semanticScope.putDecoration(userRightNode, new TargetType(binaryType));\n+                }\n+\n+                decorateWithCast(userLeftNode, semanticScope);\n+                decorateWithCast(userRightNode, semanticScope);\n+            }\n+        }\n+\n+        semanticScope.putDecoration(userBinaryNode, new ValueType(valueType));\n+        semanticScope.putDecoration(userBinaryNode, new BinaryType(binaryType));\n+\n+        if (shiftType != null) {\n+            semanticScope.putDecoration(userBinaryNode, new ShiftType(shiftType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitBooleanComp(EBooleanComp userBooleanCompNode, SemanticScope semanticScope) {\n+        Operation operation = userBooleanCompNode.getOperation();\n+\n+        if (semanticScope.getCondition(userBooleanCompNode, Write.class)) {\n+            throw userBooleanCompNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userBooleanCompNode, Read.class) == false) {\n+            throw userBooleanCompNode.createError(new IllegalArgumentException(\n+                    \"not a statement: result not used from \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        AExpression userLeftNode = userBooleanCompNode.getLeftNode();\n+        semanticScope.setCondition(userLeftNode, Read.class);\n+        semanticScope.putDecoration(userLeftNode, new TargetType(boolean.class));\n+        checkedVisit(userLeftNode, semanticScope);\n+        decorateWithCast(userLeftNode, semanticScope);\n+\n+        AExpression userRightNode = userBooleanCompNode.getRightNode();\n+        semanticScope.setCondition(userRightNode, Read.class);\n+        semanticScope.putDecoration(userRightNode, new TargetType(boolean.class));\n+        checkedVisit(userRightNode, semanticScope);\n+        decorateWithCast(userRightNode, semanticScope);\n+\n+        semanticScope.putDecoration(userBooleanCompNode, new ValueType(boolean.class));\n+    }\n+\n+    @Override\n+    public void visitComp(EComp userCompNode, SemanticScope semanticScope) {\n+        Operation operation = userCompNode.getOperation();\n+\n+        if (semanticScope.getCondition(userCompNode, Write.class)) {\n+            throw userCompNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userCompNode, Read.class) == false) {\n+            throw userCompNode.createError(new IllegalArgumentException(\n+                    \"not a statement: result not used from \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        AExpression userLeftNode = userCompNode.getLeftNode();\n+        semanticScope.setCondition(userLeftNode, Read.class);\n+        checkedVisit(userLeftNode, semanticScope);\n+        Class<?> leftValueType = semanticScope.getDecoration(userLeftNode, ValueType.class).getValueType();\n+\n+        AExpression userRightNode = userCompNode.getRightNode();\n+        semanticScope.setCondition(userRightNode, Read.class);\n+        checkedVisit(userRightNode, semanticScope);\n+        Class<?> rightValueType = semanticScope.getDecoration(userRightNode, ValueType.class).getValueType();\n+\n+        Class<?> promotedType;\n+\n+        if (operation == Operation.EQ || operation == Operation.EQR || operation == Operation.NE || operation == Operation.NER) {\n+            promotedType = AnalyzerCaster.promoteEquality(leftValueType, rightValueType);\n+        } else if (operation == Operation.GT || operation == Operation.GTE || operation == Operation.LT || operation == Operation.LTE) {\n+            promotedType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, true);\n+        } else {\n+            throw userCompNode.createError(new IllegalStateException(\"unexpected binary operation [\" + operation.name + \"]\"));\n+        }\n+\n+        if (promotedType == null) {\n+            throw userCompNode.createError(new ClassCastException(\"cannot apply the \" + operation.name + \" operator \" +\n+                    \"[\" + operation.symbol + \"] to the types \" +\n+                    \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(leftValueType) + \"] and \" +\n+                    \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(rightValueType) + \"]\"));\n+        }\n+\n+        if ((operation == Operation.EQ || operation == Operation.EQR || operation == Operation.NE || operation == Operation.NER)\n+                && userLeftNode instanceof ENull && userRightNode instanceof ENull) {\n+            throw userCompNode.createError(new IllegalArgumentException(\"extraneous comparison of [null] constants\"));\n+        }\n+\n+        if (operation == Operation.EQR || operation == Operation.NER || promotedType != def.class) {\n+            semanticScope.putDecoration(userLeftNode, new TargetType(promotedType));\n+            semanticScope.putDecoration(userRightNode, new TargetType(promotedType));\n+            decorateWithCast(userLeftNode, semanticScope);\n+            decorateWithCast(userRightNode, semanticScope);\n+        }\n+\n+        semanticScope.putDecoration(userCompNode, new ValueType(boolean.class));\n+        semanticScope.putDecoration(userCompNode, new ComparisonType(promotedType));\n+    }\n+\n+    @Override\n+    public void visitExplicit(EExplicit userExplicitNode, SemanticScope semanticScope) {\n+        String canonicalTypeName = userExplicitNode.getCanonicalTypeName();\n+\n+        if (semanticScope.getCondition(userExplicitNode, Write.class)) {\n+            throw userExplicitNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to an explicit cast with target type [\" + canonicalTypeName + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userExplicitNode, Read.class) == false) {\n+            throw userExplicitNode.createError(new IllegalArgumentException(\n+                    \"not a statement: result not used from explicit cast with target type [\" + canonicalTypeName + \"]\"));\n+        }\n+\n+        Class<?> valueType = semanticScope.getScriptScope().getPainlessLookup().canonicalTypeNameToType(canonicalTypeName);\n+\n+        if (valueType == null) {\n+            throw userExplicitNode.createError(new IllegalArgumentException(\"cannot resolve type [\" + canonicalTypeName + \"]\"));\n+        }\n+\n+        AExpression userChildNode = userExplicitNode.getChildNode();\n+        semanticScope.setCondition(userChildNode, Read.class);\n+        semanticScope.putDecoration(userChildNode, new TargetType(valueType));\n+        semanticScope.setCondition(userChildNode, Explicit.class);\n+        checkedVisit(userChildNode, semanticScope);\n+        decorateWithCast(userChildNode, semanticScope);\n+\n+        semanticScope.putDecoration(userExplicitNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitInstanceof(EInstanceof userInstanceofNode, SemanticScope semanticScope) {\n+        String canonicalTypeName = userInstanceofNode.getCanonicalTypeName();\n+\n+        if (semanticScope.getCondition(userInstanceofNode, Write.class)) {\n+            throw userInstanceofNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to instanceof with target type [\" + canonicalTypeName + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userInstanceofNode, Read.class) == false) {\n+            throw userInstanceofNode.createError(new IllegalArgumentException(\n+                    \"not a statement: result not used from instanceof with target type [\" + canonicalTypeName + \"]\"));\n+        }\n+\n+        Class<?> instanceType = semanticScope.getScriptScope().getPainlessLookup().canonicalTypeNameToType(canonicalTypeName);\n+\n+        if (instanceType == null) {\n+            throw userInstanceofNode.createError(new IllegalArgumentException(\"Not a type [\" + canonicalTypeName + \"].\"));\n+        }\n+\n+        AExpression userExpressionNode = userInstanceofNode.getExpressionNode();\n+        semanticScope.setCondition(userExpressionNode, Read.class);\n+        checkedVisit(userExpressionNode, semanticScope);\n+\n+        semanticScope.putDecoration(userInstanceofNode, new ValueType(boolean.class));\n+        semanticScope.putDecoration(userInstanceofNode, new InstanceType(instanceType));\n+    }\n+\n+    @Override\n+    public void visitConditional(EConditional userConditionalNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userConditionalNode, Write.class)) {\n+            throw userConditionalNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to conditional operation [?:]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userConditionalNode, Read.class) == false) {\n+            throw userConditionalNode.createError(new IllegalArgumentException(\n+                    \"not a statement: result not used from conditional operation [?:]\"));\n+        }\n+\n+        AExpression userConditionNode = userConditionalNode.getConditionNode();\n+        semanticScope.setCondition(userConditionNode, Read.class);\n+        semanticScope.putDecoration(userConditionNode, new TargetType(boolean.class));\n+        checkedVisit(userConditionNode, semanticScope);\n+        decorateWithCast(userConditionNode, semanticScope);\n+\n+        AExpression userTrueNode = userConditionalNode.getTrueNode();\n+        semanticScope.setCondition(userTrueNode, Read.class);\n+        semanticScope.copyDecoration(userConditionalNode, userTrueNode, TargetType.class);\n+        semanticScope.replicateCondition(userConditionalNode, userTrueNode, Explicit.class);\n+        semanticScope.replicateCondition(userConditionalNode, userTrueNode, Internal.class);\n+        checkedVisit(userTrueNode, semanticScope);\n+        Class<?> leftValueType = semanticScope.getDecoration(userTrueNode, ValueType.class).getValueType();\n+\n+        AExpression userFalseNode = userConditionalNode.getFalseNode();\n+        semanticScope.setCondition(userFalseNode, Read.class);\n+        semanticScope.copyDecoration(userConditionalNode, userFalseNode, TargetType.class);\n+        semanticScope.replicateCondition(userConditionalNode, userFalseNode, Explicit.class);\n+        semanticScope.replicateCondition(userConditionalNode, userFalseNode, Internal.class);\n+        checkedVisit(userFalseNode, semanticScope);\n+        Class<?> rightValueType = semanticScope.getDecoration(userFalseNode, ValueType.class).getValueType();\n+\n+        TargetType targetType = semanticScope.getDecoration(userConditionalNode, TargetType.class);\n+        Class<?> valueType;\n+\n+        if (targetType == null) {\n+            Class<?> promote = AnalyzerCaster.promoteConditional(leftValueType, rightValueType);\n+\n+            if (promote == null) {\n+                throw userConditionalNode.createError(new ClassCastException(\"cannot apply the conditional operator [?:] to the types \" +\n+                        \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(leftValueType) + \"] and \" +\n+                        \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(rightValueType) + \"]\"));\n+            }\n+\n+            semanticScope.putDecoration(userTrueNode, new TargetType(promote));\n+            semanticScope.putDecoration(userFalseNode, new TargetType(promote));\n+            valueType = promote;\n+        } else {\n+            valueType = targetType.getTargetType();\n+        }\n+\n+        decorateWithCast(userTrueNode, semanticScope);\n+        decorateWithCast(userFalseNode, semanticScope);\n+\n+        semanticScope.putDecoration(userConditionalNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitElvis(EElvis userElvisNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userElvisNode, Write.class)) {\n+            throw userElvisNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to elvis operation [?:]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userElvisNode, Read.class) == false) {\n+            throw userElvisNode.createError(new IllegalArgumentException(\"not a statement: result not used from elvis operation [?:]\"));\n+        }\n+\n+        TargetType targetType = semanticScope.getDecoration(userElvisNode, TargetType.class);\n+\n+        if (targetType != null && targetType.getTargetType().isPrimitive()) {\n+            throw userElvisNode.createError(new IllegalArgumentException(\"Elvis operator cannot return primitives\"));\n+        }\n+\n+        AExpression userLeftNode = userElvisNode.getLeftNode();\n+        semanticScope.setCondition(userLeftNode, Read.class);\n+        semanticScope.copyDecoration(userElvisNode, userLeftNode, TargetType.class);\n+        semanticScope.replicateCondition(userElvisNode, userLeftNode, Explicit.class);\n+        semanticScope.replicateCondition(userElvisNode, userLeftNode, Internal.class);\n+        checkedVisit(userLeftNode, semanticScope);\n+        Class<?> leftValueType = semanticScope.getDecoration(userLeftNode, ValueType.class).getValueType();\n+\n+        AExpression userRightNode = userElvisNode.getRightNode();\n+        semanticScope.setCondition(userRightNode, Read.class);\n+        semanticScope.copyDecoration(userElvisNode, userRightNode, TargetType.class);\n+        semanticScope.replicateCondition(userElvisNode, userRightNode, Explicit.class);\n+        semanticScope.replicateCondition(userElvisNode, userRightNode, Internal.class);\n+        checkedVisit(userRightNode, semanticScope);\n+        Class<?> rightValueType = semanticScope.getDecoration(userRightNode, ValueType.class).getValueType();\n+\n+        if (userLeftNode instanceof ENull) {\n+            throw userElvisNode.createError(new IllegalArgumentException(\"Extraneous elvis operator. LHS is null.\"));\n+        }\n+        if (    userLeftNode instanceof EBooleanConstant ||\n+                userLeftNode instanceof ENumeric         ||\n+                userLeftNode instanceof EDecimal         ||\n+                userLeftNode instanceof EString\n+        ) {\n+            throw userElvisNode.createError(new IllegalArgumentException(\"Extraneous elvis operator. LHS is a constant.\"));\n+        }\n+        if (leftValueType.isPrimitive()) {\n+            throw userElvisNode.createError(new IllegalArgumentException(\"Extraneous elvis operator. LHS is a primitive.\"));\n+        }\n+        if (userRightNode instanceof ENull) {\n+            throw userElvisNode.createError(new IllegalArgumentException(\"Extraneous elvis operator. RHS is null.\"));\n+        }\n+\n+        Class<?> valueType;\n+\n+        if (targetType == null) {\n+            Class<?> promote = AnalyzerCaster.promoteConditional(leftValueType, rightValueType);\n+\n+            semanticScope.putDecoration(userLeftNode, new TargetType(promote));\n+            semanticScope.putDecoration(userRightNode, new TargetType(promote));\n+            valueType = promote;\n+        } else {\n+            valueType = targetType.getTargetType();\n+        }\n+\n+        decorateWithCast(userLeftNode, semanticScope);\n+        decorateWithCast(userRightNode, semanticScope);\n+\n+        semanticScope.putDecoration(userElvisNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitListInit(EListInit userListInitNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userListInitNode, Write.class)) {\n+            throw userListInitNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to list initializer\"));\n+        }\n+\n+        if (semanticScope.getCondition(userListInitNode, Read.class) == false) {\n+            throw userListInitNode.createError(new IllegalArgumentException(\"not a statement: result not used from list initializer\"));\n+        }\n+\n+        Class<?> valueType = ArrayList.class;\n+\n+        PainlessConstructor constructor = semanticScope.getScriptScope().getPainlessLookup().lookupPainlessConstructor(valueType, 0);\n+\n+        if (constructor == null) {\n+            throw userListInitNode.createError(new IllegalArgumentException(\n+                    \"constructor [\" + typeToCanonicalTypeName(valueType) + \", <init>/0] not found\"));\n+        }\n+\n+        semanticScope.putDecoration(userListInitNode, new StandardPainlessConstructor(constructor));\n+\n+        PainlessMethod method = semanticScope.getScriptScope().getPainlessLookup().lookupPainlessMethod(valueType, false, \"add\", 1);\n+\n+        if (method == null) {\n+            throw userListInitNode.createError(new IllegalArgumentException(\n+                    \"method [\" + typeToCanonicalTypeName(valueType) + \", add/1] not found\"));\n+        }\n+\n+        semanticScope.putDecoration(userListInitNode, new StandardPainlessMethod(method));\n+\n+        for (AExpression userValueNode : userListInitNode.getValueNodes()) {\n+            semanticScope.setCondition(userValueNode, Read.class);\n+            semanticScope.putDecoration(userValueNode, new TargetType(def.class));\n+            semanticScope.setCondition(userValueNode, Internal.class);\n+            checkedVisit(userValueNode, semanticScope);\n+            decorateWithCast(userValueNode, semanticScope);\n+        }\n+\n+        semanticScope.putDecoration(userListInitNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitMapInit(EMapInit userMapInitNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userMapInitNode, Write.class)) {\n+            throw userMapInitNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to map initializer\"));\n+        }\n+\n+        if (semanticScope.getCondition(userMapInitNode, Read.class) == false) {\n+            throw userMapInitNode.createError(new IllegalArgumentException(\"not a statement: result not used from map initializer\"));\n+        }\n+\n+        Class<?> valueType = HashMap.class;\n+\n+        PainlessConstructor constructor = semanticScope.getScriptScope().getPainlessLookup().lookupPainlessConstructor(valueType, 0);\n+\n+        if (constructor == null) {\n+            throw userMapInitNode.createError(new IllegalArgumentException(\n+                    \"constructor [\" + typeToCanonicalTypeName(valueType) + \", <init>/0] not found\"));\n+        }\n+\n+        semanticScope.putDecoration(userMapInitNode, new StandardPainlessConstructor(constructor));\n+\n+        PainlessMethod method = semanticScope.getScriptScope().getPainlessLookup().lookupPainlessMethod(valueType, false, \"put\", 2);\n+\n+        if (method == null) {\n+            throw userMapInitNode.createError(new IllegalArgumentException(\n+                    \"method [\" + typeToCanonicalTypeName(valueType) + \", put/2] not found\"));\n+        }\n+\n+        semanticScope.putDecoration(userMapInitNode, new StandardPainlessMethod(method));\n+\n+        List<AExpression> userKeyNodes = userMapInitNode.getKeyNodes();\n+        List<AExpression> userValueNodes = userMapInitNode.getValueNodes();\n+\n+        if (userKeyNodes.size() != userValueNodes.size()) {\n+            throw userMapInitNode.createError(new IllegalStateException(\"Illegal tree structure.\"));\n+        }\n+\n+        for (int i = 0; i < userKeyNodes.size(); ++i) {\n+            AExpression userKeyNode = userKeyNodes.get(i);\n+            semanticScope.setCondition(userKeyNode, Read.class);\n+            semanticScope.putDecoration(userKeyNode, new TargetType(def.class));\n+            semanticScope.setCondition(userKeyNode, Internal.class);\n+            checkedVisit(userKeyNode, semanticScope);\n+            decorateWithCast(userKeyNode, semanticScope);\n+\n+            AExpression userValueNode = userValueNodes.get(i);\n+            semanticScope.setCondition(userValueNode, Read.class);\n+            semanticScope.putDecoration(userValueNode, new TargetType(def.class));\n+            semanticScope.setCondition(userValueNode, Internal.class);\n+            checkedVisit(userValueNode, semanticScope);\n+            decorateWithCast(userValueNode, semanticScope);\n+        }\n+\n+        semanticScope.putDecoration(userMapInitNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitNewArray(ENewArray userNewArrayNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userNewArrayNode, Write.class)) {\n+            throw userNewArrayNode.createError(new IllegalArgumentException(\"invalid assignment: cannot assign a value to new array\"));\n+        }\n+\n+        if (semanticScope.getCondition(userNewArrayNode, Read.class) == false) {\n+            throw userNewArrayNode.createError(new IllegalArgumentException(\"not a statement: result not used from new array\"));\n+        }\n+\n+        String canonicalTypeName = userNewArrayNode.getCanonicalTypeName();\n+        Class<?> valueType = semanticScope.getScriptScope().getPainlessLookup().canonicalTypeNameToType(canonicalTypeName);\n+\n+        if (valueType == null) {\n+            throw userNewArrayNode.createError(new IllegalArgumentException(\"Not a type [\" + canonicalTypeName + \"].\"));\n+        }\n+\n+        for (AExpression userValueNode : userNewArrayNode.getValueNodes()) {\n+            semanticScope.setCondition(userValueNode, Read.class);\n+            semanticScope.putDecoration(userValueNode,\n+                    new TargetType(userNewArrayNode.isInitializer() ? valueType.getComponentType() : int.class));\n+            semanticScope.setCondition(userValueNode, Internal.class);\n+            checkedVisit(userValueNode, semanticScope);\n+            decorateWithCast(userValueNode, semanticScope);\n+        }\n+\n+        semanticScope.putDecoration(userNewArrayNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitNewObj(ENewObj userNewObjNode, SemanticScope semanticScope) {\n+        String canonicalTypeName =  userNewObjNode.getCanonicalTypeName();\n+        List<AExpression> userArgumentNodes = userNewObjNode.getArgumentNodes();\n+        int userArgumentsSize = userArgumentNodes.size();\n+\n+        if (semanticScope.getCondition(userNewObjNode, Write.class)) {\n+            throw userNewObjNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment cannot assign a value to new object with constructor \" +\n+                            \"[\" + canonicalTypeName + \"/\" + userArgumentsSize + \"]\"));\n+        }\n+\n+        ScriptScope scriptScope = semanticScope.getScriptScope();\n+        Class<?> valueType = scriptScope.getPainlessLookup().canonicalTypeNameToType(canonicalTypeName);\n+\n+        if (valueType == null) {\n+            throw userNewObjNode.createError(new IllegalArgumentException(\"Not a type [\" + canonicalTypeName + \"].\"));\n+        }\n+\n+        PainlessConstructor constructor = scriptScope.getPainlessLookup().lookupPainlessConstructor(valueType, userArgumentsSize);\n+\n+        if (constructor == null) {\n+            throw userNewObjNode.createError(new IllegalArgumentException(\n+                    \"constructor [\" + typeToCanonicalTypeName(valueType) + \", <init>/\" + userArgumentsSize + \"] not found\"));\n+        }\n+\n+        scriptScope.putDecoration(userNewObjNode, new StandardPainlessConstructor(constructor));\n+        scriptScope.markNonDeterministic(constructor.annotations.containsKey(NonDeterministicAnnotation.class));\n+\n+        Class<?>[] types = new Class<?>[constructor.typeParameters.size()];\n+        constructor.typeParameters.toArray(types);\n+\n+        if (constructor.typeParameters.size() != userArgumentsSize) {\n+            throw userNewObjNode.createError(new IllegalArgumentException(\n+                    \"When calling constructor on type [\" + PainlessLookupUtility.typeToCanonicalTypeName(valueType) + \"] \" +\n+                            \"expected [\" + constructor.typeParameters.size() + \"] arguments, but found [\" + userArgumentsSize + \"].\"));\n+        }\n+\n+        for (int i = 0; i < userArgumentsSize; ++i) {\n+            AExpression userArgumentNode = userArgumentNodes.get(i);\n+\n+            semanticScope.setCondition(userArgumentNode, Read.class);\n+            semanticScope.putDecoration(userArgumentNode, new TargetType(types[i]));\n+            semanticScope.setCondition(userArgumentNode, Internal.class);\n+            checkedVisit(userArgumentNode, semanticScope);\n+            decorateWithCast(userArgumentNode, semanticScope);\n+        }\n+\n+        semanticScope.putDecoration(userNewObjNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitCallLocal(ECallLocal userCallLocalNode, SemanticScope semanticScope) {\n+        String methodName = userCallLocalNode.getMethodName();\n+        List<AExpression> userArgumentNodes = userCallLocalNode.getArgumentNodes();\n+        int userArgumentsSize = userArgumentNodes.size();\n+\n+        if (semanticScope.getCondition(userCallLocalNode, Write.class)) {\n+            throw userCallLocalNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to function call [\" + methodName + \"/\" + userArgumentsSize + \"]\"));\n+        }\n+\n+        ScriptScope scriptScope = semanticScope.getScriptScope();\n+\n+        FunctionTable.LocalFunction localFunction = null;\n+        PainlessMethod importedMethod = null;\n+        PainlessClassBinding classBinding = null;\n+        int classBindingOffset = 0;\n+        PainlessInstanceBinding instanceBinding = null;\n+\n+        Class<?> valueType;\n+\n+        localFunction = scriptScope.getFunctionTable().getFunction(methodName, userArgumentsSize);\n+\n+        // user cannot call internal functions, reset to null if an internal function is found\n+        if (localFunction != null && localFunction.isInternal()) {\n+            localFunction = null;\n+        }\n+\n+        if (localFunction == null) {\n+            importedMethod = scriptScope.getPainlessLookup().lookupImportedPainlessMethod(methodName, userArgumentsSize);\n+\n+            if (importedMethod == null) {\n+                classBinding = scriptScope.getPainlessLookup().lookupPainlessClassBinding(methodName, userArgumentsSize);\n+\n+                // check to see if this class binding requires an implicit this reference\n+                if (classBinding != null && classBinding.typeParameters.isEmpty() == false &&\n+                        classBinding.typeParameters.get(0) == scriptScope.getScriptClassInfo().getBaseClass()) {\n+                    classBinding = null;\n+                }\n+\n+                if (classBinding == null) {\n+                    // This extra check looks for a possible match where the class binding requires an implicit this\n+                    // reference.  This is a temporary solution to allow the class binding access to data from the\n+                    // base script class without need for a user to add additional arguments.  A long term solution\n+                    // will likely involve adding a class instance binding where any instance can have a class binding\n+                    // as part of its API.  However, the situation at run-time is difficult and will modifications that\n+                    // are a substantial change if even possible to do.\n+                    classBinding = scriptScope.getPainlessLookup().lookupPainlessClassBinding(methodName, userArgumentsSize + 1);\n+\n+                    if (classBinding != null) {\n+                        if (classBinding.typeParameters.isEmpty() == false &&\n+                                classBinding.typeParameters.get(0) == scriptScope.getScriptClassInfo().getBaseClass()) {\n+                            classBindingOffset = 1;\n+                        } else {\n+                            classBinding = null;\n+                        }\n+                    }\n+\n+                    if (classBinding == null) {\n+                        instanceBinding = scriptScope.getPainlessLookup().lookupPainlessInstanceBinding(methodName, userArgumentsSize);\n+\n+                        if (instanceBinding == null) {\n+                            throw userCallLocalNode.createError(new IllegalArgumentException(\n+                                    \"Unknown call [\" + methodName + \"] with [\" + userArgumentNodes + \"] arguments.\"));\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        List<Class<?>> typeParameters;\n+\n+        if (localFunction != null) {\n+            semanticScope.putDecoration(userCallLocalNode, new StandardLocalFunction(localFunction));\n+\n+            typeParameters = new ArrayList<>(localFunction.getTypeParameters());\n+            valueType = localFunction.getReturnType();\n+        } else if (importedMethod != null) {\n+            semanticScope.putDecoration(userCallLocalNode, new StandardPainlessMethod(importedMethod));\n+\n+            scriptScope.markNonDeterministic(importedMethod.annotations.containsKey(NonDeterministicAnnotation.class));\n+            typeParameters = new ArrayList<>(importedMethod.typeParameters);\n+            valueType = importedMethod.returnType;\n+        } else if (classBinding != null) {\n+            semanticScope.putDecoration(userCallLocalNode, new StandardPainlessClassBinding(classBinding));\n+            semanticScope.putDecoration(userCallLocalNode, new StandardConstant(classBindingOffset));\n+\n+            scriptScope.markNonDeterministic(classBinding.annotations.containsKey(NonDeterministicAnnotation.class));\n+            typeParameters = new ArrayList<>(classBinding.typeParameters);\n+            valueType = classBinding.returnType;\n+        } else if (instanceBinding != null) {\n+            semanticScope.putDecoration(userCallLocalNode, new StandardPainlessInstanceBinding(instanceBinding));\n+\n+            typeParameters = new ArrayList<>(instanceBinding.typeParameters);\n+            valueType = instanceBinding.returnType;\n+        } else {\n+            throw new IllegalStateException(\"Illegal tree structure.\");\n+        }\n+        // if the class binding is using an implicit this reference then the arguments counted must\n+        // be incremented by 1 as the this reference will not be part of the arguments passed into\n+        // the class binding call\n+        for (int argument = 0; argument < userArgumentsSize; ++argument) {\n+            AExpression userArgumentNode = userArgumentNodes.get(argument);\n+\n+            semanticScope.setCondition(userArgumentNode, Read.class);\n+            semanticScope.putDecoration(userArgumentNode, new TargetType(typeParameters.get(argument + classBindingOffset)));\n+            semanticScope.setCondition(userArgumentNode, Internal.class);\n+            checkedVisit(userArgumentNode, semanticScope);\n+            decorateWithCast(userArgumentNode, semanticScope);\n+        }\n+\n+        semanticScope.putDecoration(userCallLocalNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitBooleanConstant(EBooleanConstant userBooleanConstantNode, SemanticScope semanticScope) {\n+        boolean bool = userBooleanConstantNode.getBool();\n+\n+        if (semanticScope.getCondition(userBooleanConstantNode, Write.class)) {\n+            throw userBooleanConstantNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to boolean constant [\" + bool + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userBooleanConstantNode, Read.class) == false) {\n+            throw userBooleanConstantNode.createError(\n+                    new IllegalArgumentException(\"not a statement: boolean constant [\" + bool + \"] not used\"));\n+        }\n+\n+        semanticScope.putDecoration(userBooleanConstantNode, new ValueType(boolean.class));\n+        semanticScope.putDecoration(userBooleanConstantNode, new StandardConstant(bool));\n+    }\n+\n+    @Override\n+    public void visitNumeric(ENumeric userNumericNode, SemanticScope semanticScope) {\n+        String numeric = userNumericNode.getNumeric();\n+\n+        if (semanticScope.getCondition(userNumericNode, Negate.class)) {\n+            numeric = \"-\" + numeric;\n+        }\n+\n+        if (semanticScope.getCondition(userNumericNode, Write.class)) {\n+            throw userNumericNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to numeric constant [\" + numeric + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userNumericNode, Read.class) == false) {\n+            throw userNumericNode.createError(new IllegalArgumentException(\n+                    \"not a statement: numeric constant [\" + numeric + \"] not used\"));\n+        }\n+\n+        int radix = userNumericNode.getRadix();\n+        Class<?> valueType;\n+        Object constant;\n+\n+        if (numeric.endsWith(\"d\") || numeric.endsWith(\"D\")) {\n+            if (radix != 10) {\n+                throw userNumericNode.createError(new IllegalStateException(\"Illegal tree structure.\"));\n+            }\n+\n+            try {\n+                constant = Double.parseDouble(numeric.substring(0, numeric.length() - 1));\n+                valueType = double.class;\n+            } catch (NumberFormatException exception) {\n+                throw userNumericNode.createError(new IllegalArgumentException(\"Invalid double constant [\" + numeric + \"].\"));\n+            }\n+        } else if (numeric.endsWith(\"f\") || numeric.endsWith(\"F\")) {\n+            if (radix != 10) {\n+                throw userNumericNode.createError(new IllegalStateException(\"Illegal tree structure.\"));\n+            }\n+\n+            try {\n+                constant = Float.parseFloat(numeric.substring(0, numeric.length() - 1));\n+                valueType = float.class;\n+            } catch (NumberFormatException exception) {\n+                throw userNumericNode.createError(new IllegalArgumentException(\"Invalid float constant [\" + numeric + \"].\"));\n+            }\n+        } else if (numeric.endsWith(\"l\") || numeric.endsWith(\"L\")) {\n+            try {\n+                constant = Long.parseLong(numeric.substring(0, numeric.length() - 1), radix);\n+                valueType = long.class;\n+            } catch (NumberFormatException exception) {\n+                throw userNumericNode.createError(new IllegalArgumentException(\"Invalid long constant [\" + numeric + \"].\"));\n+            }\n+        } else {\n+            try {\n+                TargetType targetType = semanticScope.getDecoration(userNumericNode, TargetType.class);\n+                Class<?> sort = targetType == null ? int.class : targetType.getTargetType();\n+                int integer = Integer.parseInt(numeric, radix);\n+\n+                if (sort == byte.class && integer >= Byte.MIN_VALUE && integer <= Byte.MAX_VALUE) {\n+                    constant = (byte)integer;\n+                    valueType = byte.class;\n+                } else if (sort == char.class && integer >= Character.MIN_VALUE && integer <= Character.MAX_VALUE) {\n+                    constant = (char)integer;\n+                    valueType = char.class;\n+                } else if (sort == short.class && integer >= Short.MIN_VALUE && integer <= Short.MAX_VALUE) {\n+                    constant = (short)integer;\n+                    valueType = short.class;\n+                } else {\n+                    constant = integer;\n+                    valueType = int.class;\n+                }\n+            } catch (NumberFormatException exception) {\n+                try {\n+                    // Check if we can parse as a long. If so then hint that the user might prefer that.\n+                    Long.parseLong(numeric, radix);\n+                    throw userNumericNode.createError(new IllegalArgumentException(\n+                            \"Invalid int constant [\" + numeric + \"]. If you want a long constant then change it to [\" + numeric + \"L].\"));\n+                } catch (NumberFormatException longNoGood) {\n+                    // Ignored\n+                }\n+                throw userNumericNode.createError(new IllegalArgumentException(\"Invalid int constant [\" + numeric + \"].\"));\n+            }\n+        }\n+\n+        semanticScope.putDecoration(userNumericNode, new ValueType(valueType));\n+        semanticScope.putDecoration(userNumericNode, new StandardConstant(constant));\n+    }\n+\n+    @Override\n+    public void visitDecimal(EDecimal userDecimalNode, SemanticScope semanticScope) {\n+        String decimal = userDecimalNode.getDecimal();\n+\n+        if (semanticScope.getCondition(userDecimalNode, Negate.class)) {\n+            decimal = \"-\" + decimal;\n+        }\n+\n+        if (semanticScope.getCondition(userDecimalNode, Write.class)) {\n+            throw userDecimalNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to decimal constant [\" + decimal + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userDecimalNode, Read.class) == false) {\n+            throw userDecimalNode.createError(new IllegalArgumentException(\"not a statement: decimal constant [\" + decimal + \"] not used\"));\n+        }\n+\n+        Class<?> valueType;\n+        Object constant;\n+\n+        if (decimal.endsWith(\"f\") || decimal.endsWith(\"F\")) {\n+            try {\n+                constant = Float.parseFloat(decimal.substring(0, decimal.length() - 1));\n+                valueType = float.class;\n+            } catch (NumberFormatException exception) {\n+                throw userDecimalNode.createError(new IllegalArgumentException(\"Invalid float constant [\" + decimal + \"].\"));\n+            }\n+        } else {\n+            String toParse = decimal;\n+            if (toParse.endsWith(\"d\") || decimal.endsWith(\"D\")) {\n+                toParse = toParse.substring(0, decimal.length() - 1);\n+            }\n+            try {\n+                constant = Double.parseDouble(toParse);\n+                valueType = double.class;\n+            } catch (NumberFormatException exception) {\n+                throw userDecimalNode.createError(new IllegalArgumentException(\"Invalid double constant [\" + decimal + \"].\"));\n+            }\n+        }\n+\n+        semanticScope.putDecoration(userDecimalNode, new ValueType(valueType));\n+        semanticScope.putDecoration(userDecimalNode, new StandardConstant(constant));\n+    }\n+\n+    @Override\n+    public void visitString(EString userStringNode, SemanticScope semanticScope) {\n+        String string = userStringNode.getString();\n+\n+        if (semanticScope.getCondition(userStringNode, Write.class)) {\n+            throw userStringNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to string constant [\" + string + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userStringNode, Read.class) == false) {\n+            throw userStringNode.createError(new IllegalArgumentException(\"not a statement: string constant [\" + string + \"] not used\"));\n+        }\n+\n+        semanticScope.putDecoration(userStringNode, new ValueType(String.class));\n+        semanticScope.putDecoration(userStringNode, new StandardConstant(string));\n+    }\n+\n+    @Override\n+    public void visitNull(ENull userNullNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userNullNode, Write.class)) {\n+            throw userNullNode.createError(new IllegalArgumentException(\"invalid assignment: cannot assign a value to null constant\"));\n+        }\n+\n+        if (semanticScope.getCondition(userNullNode, Read.class) == false) {\n+            throw userNullNode.createError(new IllegalArgumentException(\"not a statement: null constant not used\"));\n+        }\n+\n+        TargetType targetType = semanticScope.getDecoration(userNullNode, TargetType.class);\n+        Class<?> valueType;\n+\n+        if (targetType != null) {\n+            if (targetType.getTargetType().isPrimitive()) {\n+                throw userNullNode.createError(new IllegalArgumentException(\n+                        \"Cannot cast null to a primitive type [\" + targetType.getTargetCanonicalTypeName() + \"].\"));\n+            }\n+\n+            valueType = targetType.getTargetType();\n+        } else {\n+            valueType = Object.class;\n+        }\n+\n+        semanticScope.putDecoration(userNullNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitRegex(ERegex userRegexNode, SemanticScope semanticScope) {\n+        String pattern = userRegexNode.getPattern();\n+        String flags = userRegexNode.getFlags();\n+\n+        if (semanticScope.getCondition(userRegexNode, Write.class)) {\n+            throw userRegexNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to regex constant [\" + pattern + \"] with flags [\" + flags + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userRegexNode, Read.class) == false) {\n+            throw userRegexNode.createError(new IllegalArgumentException(\n+                    \"not a statement: regex constant [\" + pattern + \"] with flags [\" + flags + \"] not used\"));\n+        }\n+\n+        if (semanticScope.getScriptScope().getCompilerSettings().areRegexesEnabled() == false) {\n+            throw userRegexNode.createError(new IllegalStateException(\"Regexes are disabled. Set [script.painless.regex.enabled] to [true] \"\n+                    + \"in elasticsearch.yaml to allow them. Be careful though, regexes break out of Painless's protection against deep \"\n+                    + \"recursion and long loops.\"));\n+        }\n+\n+        Location location = userRegexNode.getLocation();\n+\n+        int constant = 0;\n+\n+        for (int i = 0; i < flags.length(); ++i) {\n+            char flag = flags.charAt(i);\n+\n+            switch (flag) {\n+                case 'c':\n+                    constant |= Pattern.CANON_EQ;\n+                    break;\n+                case 'i':\n+                    constant |= Pattern.CASE_INSENSITIVE;\n+                    break;\n+                case 'l':\n+                    constant |= Pattern.LITERAL;\n+                    break;\n+                case 'm':\n+                    constant |= Pattern.MULTILINE;\n+                    break;\n+                case 's':\n+                    constant |= Pattern.DOTALL;\n+                    break;\n+                case 'U':\n+                    constant |= Pattern.UNICODE_CHARACTER_CLASS;\n+                    break;\n+                case 'u':\n+                    constant |= Pattern.UNICODE_CASE;\n+                    break;\n+                case 'x':\n+                    constant |= Pattern.COMMENTS;\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"invalid regular expression: unknown flag [\" + flag + \"]\");\n+            }\n+        }\n+\n+        try {\n+            Pattern.compile(pattern, constant);\n+        } catch (PatternSyntaxException pse) {\n+            throw new Location(location.getSourceName(), location.getOffset() + 1 + pse.getIndex()).createError(\n+                    new IllegalArgumentException(\"invalid regular expression: \" +\n+                            \"could not compile regex constant [\" + pattern + \"] with flags [\" + flags + \"]\", pse));\n+        }\n+\n+        semanticScope.putDecoration(userRegexNode, new ValueType(Pattern.class));\n+        semanticScope.putDecoration(userRegexNode, new StandardConstant(constant));\n+    }\n+\n+    @Override\n+    public void visitLambda(ELambda userLambdaNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userLambdaNode, Write.class)) {\n+            throw userLambdaNode.createError(new IllegalArgumentException(\"invalid assignment: cannot assign a value to a lambda\"));\n+        }\n+\n+        if (semanticScope.getCondition(userLambdaNode, Read.class) == false) {\n+            throw userLambdaNode.createError(new IllegalArgumentException(\"not a statement: lambda not used\"));\n+        }\n+\n+        ScriptScope scriptScope = semanticScope.getScriptScope();\n+        TargetType targetType = semanticScope.getDecoration(userLambdaNode, TargetType.class);\n+        List<String> canonicalTypeNameParameters = userLambdaNode.getCanonicalTypeNameParameters();\n+\n+        Class<?> returnType;\n+        List<Class<?>> typeParameters;\n+        PainlessMethod interfaceMethod;\n+\n+        // inspect the target first, set interface method if we know it.\n+        if (targetType == null) {\n+            // we don't know anything: treat as def\n+            returnType = def.class;\n+            // don't infer any types, replace any null types with def\n+            typeParameters = new ArrayList<>(canonicalTypeNameParameters.size());\n+            for (String type : canonicalTypeNameParameters) {\n+                if (type == null) {\n+                    typeParameters.add(def.class);\n+                } else {\n+                    Class<?> typeParameter = scriptScope.getPainlessLookup().canonicalTypeNameToType(type);\n+\n+                    if (typeParameter == null) {\n+                        throw userLambdaNode.createError(new IllegalArgumentException(\"cannot resolve type [\" + type + \"]\"));\n+                    }\n+\n+                    typeParameters.add(typeParameter);\n+                }\n+            }\n+        } else {\n+            // we know the method statically, infer return type and any unknown/def types\n+            interfaceMethod = scriptScope.getPainlessLookup().lookupFunctionalInterfacePainlessMethod(targetType.getTargetType());\n+            if (interfaceMethod == null) {\n+                throw userLambdaNode.createError(new IllegalArgumentException(\"Cannot pass lambda to \" +\n+                        \"[\" + targetType.getTargetCanonicalTypeName() + \"], not a functional interface\"));\n+            }\n+            // check arity before we manipulate parameters\n+            if (interfaceMethod.typeParameters.size() != canonicalTypeNameParameters.size())\n+                throw new IllegalArgumentException(\"Incorrect number of parameters for [\" + interfaceMethod.javaMethod.getName() +\n+                        \"] in [\" + targetType.getTargetCanonicalTypeName() + \"]\");\n+            // for method invocation, its allowed to ignore the return value\n+            if (interfaceMethod.returnType == void.class) {\n+                returnType = def.class;\n+            } else {\n+                returnType = interfaceMethod.returnType;\n+            }\n+            // replace any null types with the actual type\n+            typeParameters = new ArrayList<>(canonicalTypeNameParameters.size());\n+            for (int i = 0; i < canonicalTypeNameParameters.size(); i++) {\n+                String paramType = canonicalTypeNameParameters.get(i);\n+                if (paramType == null) {\n+                    typeParameters.add(interfaceMethod.typeParameters.get(i));\n+                } else {\n+                    Class<?> typeParameter = scriptScope.getPainlessLookup().canonicalTypeNameToType(paramType);\n+\n+                    if (typeParameter == null) {\n+                        throw userLambdaNode.createError(new IllegalArgumentException(\"cannot resolve type [\" + paramType + \"]\"));\n+                    }\n+\n+                    typeParameters.add(typeParameter);\n+                }\n+            }\n+        }\n+\n+        Location location = userLambdaNode.getLocation();\n+        List<String> parameterNames = userLambdaNode.getParameterNames();\n+        LambdaScope lambdaScope = semanticScope.newLambdaScope(returnType);\n+\n+        for (int index = 0; index < typeParameters.size(); ++index) {\n+            Class<?> type = typeParameters.get(index);\n+            String parameterName = parameterNames.get(index);\n+            lambdaScope.defineVariable(location, type, parameterName, true);\n+        }\n+\n+        SBlock userBlockNode = userLambdaNode.getBlockNode();\n+\n+        if (userBlockNode.getStatementNodes().isEmpty()) {\n+            throw userLambdaNode.createError(new IllegalArgumentException(\"cannot generate empty lambda\"));\n+        }\n+\n+        semanticScope.setCondition(userBlockNode, LastSource.class);\n+        visit(userBlockNode, lambdaScope);\n+\n+        if (semanticScope.getCondition(userBlockNode, MethodEscape.class) == false) {\n+            throw userLambdaNode.createError(new IllegalArgumentException(\"not all paths return a value for lambda\"));\n+        }\n+\n+        // prepend capture list to lambda's arguments\n+        List<Variable> capturedVariables = new ArrayList<>(lambdaScope.getCaptures());\n+        List<Class<?>> typeParametersWithCaptures = new ArrayList<>(capturedVariables.size() + typeParameters.size());\n+        List<String> parameterNamesWithCaptures = new ArrayList<>(capturedVariables.size() + parameterNames.size());\n+\n+        for (Variable capturedVariable : capturedVariables) {\n+            typeParametersWithCaptures.add(capturedVariable.getType());\n+            parameterNamesWithCaptures.add(capturedVariable.getName());\n+        }\n+\n+        typeParametersWithCaptures.addAll(typeParameters);\n+        parameterNamesWithCaptures.addAll(parameterNames);\n+\n+        // desugar lambda body into a synthetic method\n+        String name = scriptScope.getNextSyntheticName(\"lambda\");\n+        scriptScope.getFunctionTable().addFunction(name, returnType, typeParametersWithCaptures, true, true);\n+\n+        Class<?> valueType;\n+        // setup method reference to synthetic method\n+        if (targetType == null) {\n+            String defReferenceEncoding = \"Sthis.\" + name + \",\" + capturedVariables.size();\n+            valueType = String.class;\n+            semanticScope.putDecoration(userLambdaNode, new EncodingDecoration(defReferenceEncoding));\n+        } else {\n+            FunctionRef ref = FunctionRef.create(scriptScope.getPainlessLookup(), scriptScope.getFunctionTable(),\n+                    location, targetType.getTargetType(), \"this\", name, capturedVariables.size());\n+            valueType = targetType.getTargetType();\n+            semanticScope.putDecoration(userLambdaNode, new ReferenceDecoration(ref));\n+        }\n+\n+        semanticScope.putDecoration(userLambdaNode, new ValueType(valueType));\n+        semanticScope.putDecoration(userLambdaNode, new MethodNameDecoration(name));\n+        semanticScope.putDecoration(userLambdaNode, new ReturnType(returnType));\n+        semanticScope.putDecoration(userLambdaNode, new TypeParameters(typeParametersWithCaptures));\n+        semanticScope.putDecoration(userLambdaNode, new ParameterNames(parameterNamesWithCaptures));\n+        semanticScope.putDecoration(userLambdaNode, new CapturesDecoration(capturedVariables));\n+    }\n+\n+    @Override\n+    public void visitFunctionRef(EFunctionRef userFunctionRefNode, SemanticScope semanticScope) {\n+        ScriptScope scriptScope = semanticScope.getScriptScope();\n+\n+        Location location = userFunctionRefNode.getLocation();\n+        String symbol = userFunctionRefNode.getSymbol();\n+        String methodName = userFunctionRefNode.getMethodName();\n+        boolean read = semanticScope.getCondition(userFunctionRefNode, Read.class);\n+\n+        Class<?> type = scriptScope.getPainlessLookup().canonicalTypeNameToType(symbol);\n+        TargetType targetType = semanticScope.getDecoration(userFunctionRefNode, TargetType.class);\n+        Class<?> valueType;\n+\n+        if (symbol.equals(\"this\") || type != null)  {\n+            if (semanticScope.getCondition(userFunctionRefNode, Write.class)) {\n+                throw userFunctionRefNode.createError(new IllegalArgumentException(\n+                        \"invalid assignment: cannot assign a value to function reference [\" + symbol + \":\" + methodName + \"]\"));\n+            }\n+\n+            if (read == false) {\n+                throw userFunctionRefNode.createError(new IllegalArgumentException(\n+                        \"not a statement: function reference [\" + symbol + \":\" + methodName + \"] not used\"));\n+            }\n+\n+            if (targetType == null) {\n+                valueType = String.class;\n+                String defReferenceEncoding = \"S\" + symbol + \".\" + methodName + \",0\";\n+                semanticScope.putDecoration(userFunctionRefNode, new EncodingDecoration(defReferenceEncoding));\n+            } else {\n+                FunctionRef ref = FunctionRef.create(scriptScope.getPainlessLookup(), scriptScope.getFunctionTable(),\n+                        location, targetType.getTargetType(), symbol, methodName, 0);\n+                valueType = targetType.getTargetType();\n+                semanticScope.putDecoration(userFunctionRefNode, new ReferenceDecoration(ref));\n+            }\n+        } else {\n+            if (semanticScope.getCondition(userFunctionRefNode, Write.class)) {\n+                throw userFunctionRefNode.createError(new IllegalArgumentException(\n+                        \"invalid assignment: cannot assign a value to capturing function reference [\" + symbol + \":\"  + methodName + \"]\"));\n+            }\n+\n+            if (read == false) {\n+                throw userFunctionRefNode.createError(new IllegalArgumentException(\n+                        \"not a statement: capturing function reference [\" + symbol + \":\"  + methodName + \"] not used\"));\n+            }\n+\n+            SemanticScope.Variable captured = semanticScope.getVariable(location, symbol);\n+            semanticScope.putDecoration(userFunctionRefNode, new CapturesDecoration(Collections.singletonList(captured)));\n+            if (targetType == null) {\n+                String defReferenceEncoding;\n+                if (captured.getType() == def.class) {\n+                    // dynamic implementation\n+                    defReferenceEncoding = \"D\" + symbol + \".\" + methodName + \",1\";\n+                } else {\n+                    // typed implementation\n+                    defReferenceEncoding = \"S\" + captured.getCanonicalTypeName() + \".\" + methodName + \",1\";\n+                }\n+                valueType = String.class;\n+                semanticScope.putDecoration(userFunctionRefNode, new EncodingDecoration(defReferenceEncoding));\n+            } else {\n+                valueType = targetType.getTargetType();\n+                // static case\n+                if (captured.getType() != def.class) {\n+                    FunctionRef ref = FunctionRef.create(scriptScope.getPainlessLookup(), scriptScope.getFunctionTable(), location,\n+                            targetType.getTargetType(), captured.getCanonicalTypeName(), methodName, 1);\n+                    semanticScope.putDecoration(userFunctionRefNode, new ReferenceDecoration(ref));\n+                }\n+            }\n+        }\n+\n+        semanticScope.putDecoration(userFunctionRefNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitNewArrayFunctionRef(ENewArrayFunctionRef userNewArrayFunctionRefNode, SemanticScope semanticScope) {\n+        String canonicalTypeName = userNewArrayFunctionRefNode.getCanonicalTypeName();\n+\n+        if (semanticScope.getCondition(userNewArrayFunctionRefNode, Write.class)) {\n+            throw userNewArrayFunctionRefNode.createError(new IllegalArgumentException(\n+                    \"cannot assign a value to new array function reference with target type [ + \" + canonicalTypeName  + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userNewArrayFunctionRefNode, Read.class) == false) {\n+            throw userNewArrayFunctionRefNode.createError(new IllegalArgumentException(\n+                    \"not a statement: new array function reference with target type [\" + canonicalTypeName + \"] not used\"));\n+        }\n+\n+        ScriptScope scriptScope = semanticScope.getScriptScope();\n+        TargetType targetType = semanticScope.getDecoration(userNewArrayFunctionRefNode, TargetType.class);\n+\n+        Class<?> valueType;\n+        Class<?> clazz = scriptScope.getPainlessLookup().canonicalTypeNameToType(canonicalTypeName);\n+        semanticScope.putDecoration(userNewArrayFunctionRefNode, new ReturnType(clazz));\n+\n+        if (clazz == null) {\n+            throw userNewArrayFunctionRefNode.createError(new IllegalArgumentException(\"Not a type [\" + canonicalTypeName + \"].\"));\n+        }\n+\n+        String name = scriptScope.getNextSyntheticName(\"newarray\");\n+        scriptScope.getFunctionTable().addFunction(name, clazz, Collections.singletonList(int.class), true, true);\n+        semanticScope.putDecoration(userNewArrayFunctionRefNode, new MethodNameDecoration(name));\n+\n+        if (targetType == null) {\n+            String defReferenceEncoding = \"Sthis.\" + name + \",0\";\n+            valueType = String.class;\n+            scriptScope.putDecoration(userNewArrayFunctionRefNode, new EncodingDecoration(defReferenceEncoding));\n+        } else {\n+            FunctionRef ref = FunctionRef.create(scriptScope.getPainlessLookup(), scriptScope.getFunctionTable(),\n+                    userNewArrayFunctionRefNode.getLocation(), targetType.getTargetType(), \"this\", name, 0);\n+            valueType = targetType.getTargetType();\n+            semanticScope.putDecoration(userNewArrayFunctionRefNode, new ReferenceDecoration(ref));\n+        }\n+\n+        semanticScope.putDecoration(userNewArrayFunctionRefNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitSymbol(ESymbol userSymbolNode, SemanticScope semanticScope) {\n+        boolean read = semanticScope.getCondition(userSymbolNode, Read.class);\n+        boolean write = semanticScope.getCondition(userSymbolNode, Write.class);\n+        String symbol = userSymbolNode.getSymbol();\n+        Class<?> staticType = semanticScope.getScriptScope().getPainlessLookup().canonicalTypeNameToType(symbol);\n+\n+        if (staticType != null)  {\n+            if (write) {\n+                throw userSymbolNode.createError(new IllegalArgumentException(\"invalid assignment: \" +\n+                        \"cannot write a value to a static type [\" + PainlessLookupUtility.typeToCanonicalTypeName(staticType) + \"]\"));\n+            }\n+\n+            if (read == false) {\n+                throw userSymbolNode.createError(new IllegalArgumentException(\"not a statement: \" +\n+                        \"static type [\" + PainlessLookupUtility.typeToCanonicalTypeName(staticType) + \"] not used\"));\n+            }\n+\n+            semanticScope.putDecoration(userSymbolNode, new StaticType(staticType));\n+        } else if (semanticScope.isVariableDefined(symbol)) {\n+            if (read == false && write == false) {\n+                throw userSymbolNode.createError(new IllegalArgumentException(\"not a statement: variable [\" + symbol + \"] not used\"));\n+            }\n+\n+            Location location = userSymbolNode.getLocation();\n+            Variable variable = semanticScope.getVariable(location, symbol);\n+\n+            if (write && variable.isFinal()) {\n+                throw userSymbolNode.createError(new IllegalArgumentException(\"Variable [\" + variable.getName() + \"] is read-only.\"));\n+            }\n+\n+            Class<?> valueType = variable.getType();\n+            semanticScope.putDecoration(userSymbolNode, new ValueType(valueType));\n+        } else {\n+            semanticScope.putDecoration(userSymbolNode, new PartialCanonicalTypeName(symbol));\n+        }\n+    }\n+\n+    @Override\n+    public void visitDot(EDot userDotNode, SemanticScope semanticScope) {\n+        boolean read = semanticScope.getCondition(userDotNode, Read.class);\n+        boolean write = semanticScope.getCondition(userDotNode, Write.class);\n+\n+        if (read == false && write == false) {\n+            throw userDotNode.createError(new IllegalArgumentException(\"not a statement: result of dot operator [.] not used\"));\n+        }\n+\n+        ScriptScope scriptScope = semanticScope.getScriptScope();\n+        String index = userDotNode.getIndex();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a727d2bc0ad6d8b769848d7e37e5e1847da7d77"}, "originalPosition": 2264}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0MzIzODYz", "url": "https://github.com/elastic/elasticsearch/pull/59797#pullrequestreview-454323863", "createdAt": "2020-07-23T16:56:06Z", "commit": {"oid": "7a727d2bc0ad6d8b769848d7e37e5e1847da7d77"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNjo1NjowNlrOG2TUcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNjo1NjowNlrOG2TUcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU5MjgxOA==", "bodyText": "de-indent this line.", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r459592818", "createdAt": "2020-07-23T16:56:06Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultSemanticAnalysisPhase.java", "diffHunk": "@@ -0,0 +1,2728 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.phase;\n+\n+import org.elasticsearch.painless.AnalyzerCaster;\n+import org.elasticsearch.painless.FunctionRef;\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.Operation;\n+import org.elasticsearch.painless.lookup.PainlessCast;\n+import org.elasticsearch.painless.lookup.PainlessClassBinding;\n+import org.elasticsearch.painless.lookup.PainlessConstructor;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessInstanceBinding;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.node.AExpression;\n+import org.elasticsearch.painless.node.ANode;\n+import org.elasticsearch.painless.node.AStatement;\n+import org.elasticsearch.painless.node.EAssignment;\n+import org.elasticsearch.painless.node.EBinary;\n+import org.elasticsearch.painless.node.EBooleanComp;\n+import org.elasticsearch.painless.node.EBooleanConstant;\n+import org.elasticsearch.painless.node.EBrace;\n+import org.elasticsearch.painless.node.ECall;\n+import org.elasticsearch.painless.node.ECallLocal;\n+import org.elasticsearch.painless.node.EComp;\n+import org.elasticsearch.painless.node.EConditional;\n+import org.elasticsearch.painless.node.EDecimal;\n+import org.elasticsearch.painless.node.EDot;\n+import org.elasticsearch.painless.node.EElvis;\n+import org.elasticsearch.painless.node.EExplicit;\n+import org.elasticsearch.painless.node.EFunctionRef;\n+import org.elasticsearch.painless.node.EInstanceof;\n+import org.elasticsearch.painless.node.ELambda;\n+import org.elasticsearch.painless.node.EListInit;\n+import org.elasticsearch.painless.node.EMapInit;\n+import org.elasticsearch.painless.node.ENewArray;\n+import org.elasticsearch.painless.node.ENewArrayFunctionRef;\n+import org.elasticsearch.painless.node.ENewObj;\n+import org.elasticsearch.painless.node.ENull;\n+import org.elasticsearch.painless.node.ENumeric;\n+import org.elasticsearch.painless.node.ERegex;\n+import org.elasticsearch.painless.node.EString;\n+import org.elasticsearch.painless.node.ESymbol;\n+import org.elasticsearch.painless.node.EUnary;\n+import org.elasticsearch.painless.node.SBlock;\n+import org.elasticsearch.painless.node.SBreak;\n+import org.elasticsearch.painless.node.SCatch;\n+import org.elasticsearch.painless.node.SClass;\n+import org.elasticsearch.painless.node.SContinue;\n+import org.elasticsearch.painless.node.SDeclBlock;\n+import org.elasticsearch.painless.node.SDeclaration;\n+import org.elasticsearch.painless.node.SDo;\n+import org.elasticsearch.painless.node.SEach;\n+import org.elasticsearch.painless.node.SExpression;\n+import org.elasticsearch.painless.node.SFor;\n+import org.elasticsearch.painless.node.SFunction;\n+import org.elasticsearch.painless.node.SIf;\n+import org.elasticsearch.painless.node.SIfElse;\n+import org.elasticsearch.painless.node.SReturn;\n+import org.elasticsearch.painless.node.SThrow;\n+import org.elasticsearch.painless.node.STry;\n+import org.elasticsearch.painless.node.SWhile;\n+import org.elasticsearch.painless.spi.annotation.NonDeterministicAnnotation;\n+import org.elasticsearch.painless.symbol.Decorations;\n+import org.elasticsearch.painless.symbol.Decorations.AllEscape;\n+import org.elasticsearch.painless.symbol.Decorations.AnyBreak;\n+import org.elasticsearch.painless.symbol.Decorations.AnyContinue;\n+import org.elasticsearch.painless.symbol.Decorations.BeginLoop;\n+import org.elasticsearch.painless.symbol.Decorations.BinaryType;\n+import org.elasticsearch.painless.symbol.Decorations.CapturesDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.ComparisonType;\n+import org.elasticsearch.painless.symbol.Decorations.CompoundType;\n+import org.elasticsearch.painless.symbol.Decorations.Concatenate;\n+import org.elasticsearch.painless.symbol.Decorations.ContinuousLoop;\n+import org.elasticsearch.painless.symbol.Decorations.DefOptimized;\n+import org.elasticsearch.painless.symbol.Decorations.DowncastPainlessCast;\n+import org.elasticsearch.painless.symbol.Decorations.EncodingDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.Explicit;\n+import org.elasticsearch.painless.symbol.Decorations.ExpressionPainlessCast;\n+import org.elasticsearch.painless.symbol.Decorations.GetterPainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.InLoop;\n+import org.elasticsearch.painless.symbol.Decorations.InstanceType;\n+import org.elasticsearch.painless.symbol.Decorations.Internal;\n+import org.elasticsearch.painless.symbol.Decorations.IterablePainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.LastLoop;\n+import org.elasticsearch.painless.symbol.Decorations.LastSource;\n+import org.elasticsearch.painless.symbol.Decorations.ListShortcut;\n+import org.elasticsearch.painless.symbol.Decorations.LoopEscape;\n+import org.elasticsearch.painless.symbol.Decorations.MapShortcut;\n+import org.elasticsearch.painless.symbol.Decorations.MethodEscape;\n+import org.elasticsearch.painless.symbol.Decorations.MethodNameDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.Negate;\n+import org.elasticsearch.painless.symbol.Decorations.ParameterNames;\n+import org.elasticsearch.painless.symbol.Decorations.PartialCanonicalTypeName;\n+import org.elasticsearch.painless.symbol.Decorations.Read;\n+import org.elasticsearch.painless.symbol.Decorations.ReferenceDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.ReturnType;\n+import org.elasticsearch.painless.symbol.Decorations.SemanticVariable;\n+import org.elasticsearch.painless.symbol.Decorations.SetterPainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.ShiftType;\n+import org.elasticsearch.painless.symbol.Decorations.Shortcut;\n+import org.elasticsearch.painless.symbol.Decorations.StandardConstant;\n+import org.elasticsearch.painless.symbol.Decorations.StandardLocalFunction;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessClassBinding;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessConstructor;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessField;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessInstanceBinding;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.StaticType;\n+import org.elasticsearch.painless.symbol.Decorations.TargetType;\n+import org.elasticsearch.painless.symbol.Decorations.TypeParameters;\n+import org.elasticsearch.painless.symbol.Decorations.UnaryType;\n+import org.elasticsearch.painless.symbol.Decorations.UpcastPainlessCast;\n+import org.elasticsearch.painless.symbol.Decorations.ValueType;\n+import org.elasticsearch.painless.symbol.Decorations.Write;\n+import org.elasticsearch.painless.symbol.FunctionTable;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptScope;\n+import org.elasticsearch.painless.symbol.SemanticScope;\n+import org.elasticsearch.painless.symbol.SemanticScope.FunctionScope;\n+import org.elasticsearch.painless.symbol.SemanticScope.LambdaScope;\n+import org.elasticsearch.painless.symbol.SemanticScope.Variable;\n+\n+import java.lang.reflect.Modifier;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+import java.util.regex.PatternSyntaxException;\n+\n+import static org.elasticsearch.painless.lookup.PainlessLookupUtility.typeToCanonicalTypeName;\n+import static org.elasticsearch.painless.symbol.SemanticScope.newFunctionScope;\n+\n+public class DefaultSemanticAnalysisPhase extends UserTreeBaseVisitor<SemanticScope> {\n+\n+    public void decorateWithCast(AExpression userExpressionNode, SemanticScope semanticScope) {\n+        Location location = userExpressionNode.getLocation();\n+        Class<?> valueType = semanticScope.getDecoration(userExpressionNode, ValueType.class).getValueType();\n+        Class<?> targetType = semanticScope.getDecoration(userExpressionNode, TargetType.class).getTargetType();\n+        boolean isExplicitCast = semanticScope.getCondition(userExpressionNode, Explicit.class);\n+        boolean isInternalCast = semanticScope.getCondition(userExpressionNode, Internal.class);\n+\n+        PainlessCast painlessCast = AnalyzerCaster.getLegalCast(location, valueType, targetType, isExplicitCast, isInternalCast);\n+\n+        if (painlessCast != null) {\n+            semanticScope.putDecoration(userExpressionNode, new ExpressionPainlessCast(painlessCast));\n+        }\n+    }\n+\n+    public void visit(ANode userNode, SemanticScope semanticScope) {\n+        if (userNode != null) {\n+            userNode.visit(this, semanticScope);\n+        }\n+    }\n+\n+    public void checkedVisit(AExpression userExpressionNode, SemanticScope semanticScope) {\n+        if (userExpressionNode != null) {\n+            userExpressionNode.visit(this, semanticScope);\n+\n+            if (semanticScope.hasDecoration(userExpressionNode, PartialCanonicalTypeName.class)) {\n+                throw userExpressionNode.createError(new IllegalArgumentException(\"cannot resolve symbol [\" +\n+                        semanticScope.getDecoration(userExpressionNode, PartialCanonicalTypeName.class).getPartialCanonicalTypeName() +\n+                        \"]\"));\n+            }\n+\n+            if (semanticScope.hasDecoration(userExpressionNode, StaticType.class)) {\n+                throw userExpressionNode.createError(new IllegalArgumentException(\"value required: instead found unexpected type \" +\n+                        \"[\" + semanticScope.getDecoration(userExpressionNode, StaticType.class).getStaticCanonicalTypeName() + \"]\"));\n+            }\n+\n+            if (semanticScope.hasDecoration(userExpressionNode, ValueType.class) == false) {\n+                throw userExpressionNode.createError(new IllegalStateException(\"value required: instead found no value\"));\n+            }\n+        }\n+    }\n+\n+    public void visitClass(SClass userClassNode, ScriptScope scriptScope) {\n+        for (SFunction userFunctionNode : userClassNode.getFunctionNodes()) {\n+            visitFunction(userFunctionNode, scriptScope);\n+        }\n+    }\n+\n+    public void visitFunction(SFunction userFunctionNode, ScriptScope scriptScope) {\n+        String functionName = userFunctionNode.getFunctionName();\n+        LocalFunction localFunction =\n+                scriptScope.getFunctionTable().getFunction(functionName, userFunctionNode.getCanonicalTypeNameParameters().size());\n+        Class<?> returnType = localFunction.getReturnType();\n+        List<Class<?>> typeParameters = localFunction.getTypeParameters();\n+        FunctionScope functionScope = newFunctionScope(scriptScope, localFunction.getReturnType());\n+\n+        for (int index = 0; index < localFunction.getTypeParameters().size(); ++index) {\n+            Class<?> typeParameter = localFunction.getTypeParameters().get(index);\n+            String parameterName = userFunctionNode.getParameterNames().get(index);\n+            functionScope.defineVariable(userFunctionNode.getLocation(), typeParameter, parameterName, false);\n+        }\n+\n+        SBlock userBlockNode = userFunctionNode.getBlockNode();\n+\n+        if (userBlockNode.getStatementNodes().isEmpty()) {\n+            throw userFunctionNode.createError(new IllegalArgumentException(\"invalid function definition: \" +\n+                    \"found no statements for function \" +\n+                    \"[\" + functionName + \"] with [\" + typeParameters.size() + \"] parameters\"));\n+        }\n+\n+        functionScope.setCondition(userBlockNode, LastSource.class);\n+        visit(userBlockNode, functionScope.newLocalScope());\n+        boolean methodEscape = functionScope.getCondition(userBlockNode, MethodEscape.class);\n+        boolean isAutoReturnEnabled = userFunctionNode.isAutoReturnEnabled();\n+\n+        if (methodEscape == false && isAutoReturnEnabled == false && returnType != void.class) {\n+            throw userFunctionNode.createError(new IllegalArgumentException(\"invalid function definition: \" +\n+                    \"not all paths provide a return value for function \" +\n+                    \"[\" + functionName + \"] with [\" + typeParameters.size() + \"] parameters\"));\n+        }\n+\n+        if (methodEscape) {\n+            functionScope.setCondition(userFunctionNode, MethodEscape.class);\n+        }\n+\n+        // TODO: do not specialize for execute\n+        // TODO: https://github.com/elastic/elasticsearch/issues/51841\n+        if (\"execute\".equals(functionName)) {\n+            scriptScope.setUsedVariables(functionScope.getUsedVariables());\n+        }\n+        // TODO: end\n+    }\n+\n+    @Override\n+    public void visitBlock(SBlock userBlockNode, SemanticScope semanticScope) {\n+        List<AStatement> userStatementNodes = userBlockNode.getStatementNodes();\n+\n+        if (userStatementNodes.isEmpty()) {\n+            throw userBlockNode.createError(new IllegalArgumentException(\"invalid block: found no statements\"));\n+        }\n+\n+        AStatement lastUserStatement = userStatementNodes.get(userStatementNodes.size() - 1);\n+\n+        boolean lastSource = semanticScope.getCondition(userBlockNode, LastSource.class);\n+        boolean beginLoop = semanticScope.getCondition(userBlockNode, BeginLoop.class);\n+        boolean inLoop = semanticScope.getCondition(userBlockNode, InLoop.class);\n+        boolean lastLoop = semanticScope.getCondition(userBlockNode, LastLoop.class);\n+\n+        boolean allEscape;\n+        boolean anyContinue = false;\n+        boolean anyBreak = false;\n+\n+        for (AStatement userStatementNode : userStatementNodes) {\n+            if (inLoop) {\n+                semanticScope.setCondition(userStatementNode, InLoop.class);\n+            }\n+\n+            if (userStatementNode == lastUserStatement) {\n+                if (beginLoop || lastLoop) {\n+                    semanticScope.setCondition(userStatementNode, LastLoop.class);\n+                }\n+\n+                if (lastSource) {\n+                    semanticScope.setCondition(userStatementNode, LastSource.class);\n+                }\n+            }\n+\n+            visit(userStatementNode, semanticScope);\n+            allEscape = semanticScope.getCondition(userStatementNode, AllEscape.class);\n+\n+            if (userStatementNode == lastUserStatement) {\n+                semanticScope.replicateCondition(userStatementNode, userBlockNode, MethodEscape.class);\n+                semanticScope.replicateCondition(userStatementNode, userBlockNode, LoopEscape.class);\n+\n+                if (allEscape) {\n+                    semanticScope.setCondition(userStatementNode, AllEscape.class);\n+                }\n+            } else {\n+                if (allEscape) {\n+                    throw userBlockNode.createError(new IllegalArgumentException(\"invalid block: unreachable statement\"));\n+                }\n+            }\n+\n+            anyContinue |= semanticScope.getCondition(userStatementNode, AnyContinue.class);\n+            anyBreak |= semanticScope.getCondition(userStatementNode, AnyBreak.class);\n+        }\n+\n+        if (anyContinue) {\n+            semanticScope.setCondition(userBlockNode, AnyContinue.class);\n+        }\n+\n+        if (anyBreak) {\n+            semanticScope.setCondition(userBlockNode, AnyBreak.class);\n+        }\n+    }\n+\n+    @Override\n+    public void visitIf(SIf userIfNode, SemanticScope semanticScope) {\n+        AExpression userConditionNode = userIfNode.getConditionNode();\n+        semanticScope.setCondition(userConditionNode, Read.class);\n+        semanticScope.putDecoration(userConditionNode, new TargetType(boolean.class));\n+        checkedVisit(userConditionNode, semanticScope);\n+        decorateWithCast(userConditionNode, semanticScope);\n+\n+        SBlock userIfBlockNode = userIfNode.getIfBlockNode();\n+\n+        if (userConditionNode instanceof EBooleanConstant || userIfBlockNode == null) {\n+            throw userIfNode.createError(new IllegalArgumentException(\"extraneous if block\"));\n+        }\n+\n+        semanticScope.replicateCondition(userIfNode, userIfBlockNode, LastSource.class);\n+        semanticScope.replicateCondition(userIfNode, userIfBlockNode, InLoop.class);\n+        semanticScope.replicateCondition(userIfNode, userIfBlockNode, LastLoop.class);\n+        visit(userIfBlockNode, semanticScope.newLocalScope());\n+        semanticScope.replicateCondition(userIfBlockNode, userIfNode, AnyContinue.class);\n+        semanticScope.replicateCondition(userIfBlockNode, userIfNode, AnyBreak.class);\n+    }\n+\n+    @Override\n+    public void visitIfElse(SIfElse userIfElseNode, SemanticScope semanticScope) {\n+        AExpression userConditionNode = userIfElseNode.getConditionNode();\n+        semanticScope.setCondition(userConditionNode, Read.class);\n+        semanticScope.putDecoration(userConditionNode, new TargetType(boolean.class));\n+        checkedVisit(userConditionNode, semanticScope);\n+        decorateWithCast(userConditionNode, semanticScope);\n+\n+        SBlock userIfBlockNode = userIfElseNode.getIfBlockNode();\n+\n+        if (userConditionNode instanceof EBooleanConstant || userIfBlockNode == null) {\n+            throw userIfElseNode.createError(new IllegalArgumentException(\"extraneous if block\"));\n+        }\n+\n+        semanticScope.replicateCondition(userIfElseNode, userIfBlockNode, LastSource.class);\n+        semanticScope.replicateCondition(userIfElseNode, userIfBlockNode, InLoop.class);\n+        semanticScope.replicateCondition(userIfElseNode, userIfBlockNode, LastLoop.class);\n+        visit(userIfBlockNode, semanticScope.newLocalScope());\n+\n+        SBlock userElseBlockNode = userIfElseNode.getElseBlockNode();\n+\n+        if (userElseBlockNode == null) {\n+            throw userIfElseNode.createError(new IllegalArgumentException(\"extraneous else block.\"));\n+        }\n+\n+        semanticScope.replicateCondition(userIfElseNode, userElseBlockNode, LastSource.class);\n+        semanticScope.replicateCondition(userIfElseNode, userElseBlockNode, InLoop.class);\n+        semanticScope.replicateCondition(userIfElseNode, userElseBlockNode, LastLoop.class);\n+        visit(userElseBlockNode, semanticScope.newLocalScope());\n+\n+        if (semanticScope.getCondition(userIfBlockNode, MethodEscape.class) &&\n+                semanticScope.getCondition(userElseBlockNode, MethodEscape.class)) {\n+            semanticScope.setCondition(userIfElseNode, MethodEscape.class);\n+        }\n+\n+        if (semanticScope.getCondition(userIfBlockNode, LoopEscape.class) &&\n+                semanticScope.getCondition(userElseBlockNode, LoopEscape.class)) {\n+            semanticScope.setCondition(userIfElseNode, LoopEscape.class);\n+        }\n+\n+        if (semanticScope.getCondition(userIfBlockNode, AllEscape.class) &&\n+                semanticScope.getCondition(userElseBlockNode, AllEscape.class)) {\n+            semanticScope.setCondition(userIfElseNode, AllEscape.class);\n+        }\n+\n+        if (semanticScope.getCondition(userIfBlockNode, AnyContinue.class) ||\n+                semanticScope.getCondition(userElseBlockNode, AnyContinue.class)) {\n+            semanticScope.setCondition(userIfElseNode, AnyContinue.class);\n+        }\n+\n+        if (semanticScope.getCondition(userIfBlockNode, AnyBreak.class) ||\n+                semanticScope.getCondition(userElseBlockNode, AnyBreak.class)) {\n+            semanticScope.setCondition(userIfElseNode, AnyBreak.class);\n+        }\n+    }\n+\n+    @Override\n+    public void visitWhile(SWhile userWhileNode, SemanticScope semanticScope) {\n+        semanticScope = semanticScope.newLocalScope();\n+\n+        AExpression userConditionNode = userWhileNode.getConditionNode();\n+        semanticScope.setCondition(userConditionNode, Read.class);\n+        semanticScope.putDecoration(userConditionNode, new TargetType(boolean.class));\n+        checkedVisit(userConditionNode, semanticScope);\n+        decorateWithCast(userConditionNode, semanticScope);\n+\n+        SBlock userBlockNode = userWhileNode.getBlockNode();\n+        boolean continuous = false;\n+\n+        if (userConditionNode instanceof EBooleanConstant) {\n+            continuous = ((EBooleanConstant)userConditionNode).getBool();\n+\n+            if (continuous == false) {\n+                throw userWhileNode.createError(new IllegalArgumentException(\"extraneous while loop\"));\n+            } else {\n+                semanticScope.setCondition(userWhileNode, ContinuousLoop.class);\n+            }\n+\n+            if (userBlockNode == null) {\n+                throw userWhileNode.createError(new IllegalArgumentException(\"no paths escape from while loop\"));\n+            }\n+        }\n+\n+        if (userBlockNode != null) {\n+            semanticScope.setCondition(userBlockNode, BeginLoop.class);\n+            semanticScope.setCondition(userBlockNode, InLoop.class);\n+            visit(userBlockNode, semanticScope);\n+\n+            if (semanticScope.getCondition(userBlockNode, LoopEscape.class) &&\n+                    semanticScope.getCondition(userBlockNode, AnyContinue.class) == false) {\n+                throw userWhileNode.createError(new IllegalArgumentException(\"extraneous while loop\"));\n+            }\n+\n+            if (continuous && semanticScope.getCondition(userBlockNode, AnyBreak.class) == false) {\n+                semanticScope.setCondition(userWhileNode, MethodEscape.class);\n+                semanticScope.setCondition(userWhileNode, AllEscape.class);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitDo(SDo userDoNode, SemanticScope semanticScope) {\n+        semanticScope = semanticScope.newLocalScope();\n+\n+        SBlock userBlockNode = userDoNode.getBlockNode();\n+\n+        if (userBlockNode == null) {\n+            throw userDoNode.createError(new IllegalArgumentException(\"extraneous do-while loop\"));\n+        }\n+\n+        semanticScope.setCondition(userBlockNode, BeginLoop.class);\n+        semanticScope.setCondition(userBlockNode, InLoop.class);\n+        visit(userBlockNode, semanticScope);\n+\n+        if (semanticScope.getCondition(userBlockNode, LoopEscape.class) &&\n+                semanticScope.getCondition(userBlockNode, AnyContinue.class) == false) {\n+            throw userDoNode.createError(new IllegalArgumentException(\"extraneous do-while loop\"));\n+        }\n+\n+        AExpression userConditionNode = userDoNode.getConditionNode();\n+\n+        semanticScope.setCondition(userConditionNode, Read.class);\n+        semanticScope.putDecoration(userConditionNode, new TargetType(boolean.class));\n+        checkedVisit(userConditionNode, semanticScope);\n+        decorateWithCast(userConditionNode, semanticScope);\n+\n+        boolean continuous;\n+\n+        if (userConditionNode instanceof EBooleanConstant) {\n+            continuous = ((EBooleanConstant)userConditionNode).getBool();\n+\n+            if (continuous == false) {\n+                throw userDoNode.createError(new IllegalArgumentException(\"extraneous do-while loop\"));\n+            } else {\n+                semanticScope.setCondition(userDoNode, ContinuousLoop.class);\n+            }\n+\n+            if (semanticScope.getCondition(userBlockNode, AnyBreak.class) == false) {\n+                semanticScope.setCondition(userDoNode, MethodEscape.class);\n+                semanticScope.setCondition(userDoNode, AllEscape.class);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitFor(SFor userForNode, SemanticScope semanticScope) {\n+        semanticScope = semanticScope.newLocalScope();\n+\n+        ANode userInitializerNode = userForNode.getInitializerNode();\n+\n+        if (userInitializerNode != null) {\n+            if (userInitializerNode instanceof SDeclBlock) {\n+                visit(userInitializerNode, semanticScope);\n+            } else if (userInitializerNode instanceof AExpression) {\n+                checkedVisit((AExpression)userInitializerNode, semanticScope);\n+            } else {\n+                throw userForNode.createError(new IllegalStateException(\"illegal tree structure\"));\n+            }\n+        }\n+\n+        AExpression userConditionNode = userForNode.getConditionNode();\n+        SBlock userBlockNode = userForNode.getBlockNode();\n+        boolean continuous = false;\n+\n+        if (userConditionNode != null) {\n+            semanticScope.setCondition(userConditionNode, Read.class);\n+            semanticScope.putDecoration(userConditionNode, new TargetType(boolean.class));\n+            checkedVisit(userConditionNode, semanticScope);\n+            decorateWithCast(userConditionNode, semanticScope);\n+\n+            if (userConditionNode instanceof EBooleanConstant) {\n+                continuous = ((EBooleanConstant)userConditionNode).getBool();\n+\n+                if (continuous == false) {\n+                    throw userForNode.createError(new IllegalArgumentException(\"extraneous for loop\"));\n+                }\n+\n+                if (userBlockNode == null) {\n+                    throw userForNode.createError(new IllegalArgumentException(\"no paths escape from for loop\"));\n+                }\n+            }\n+        } else {\n+            continuous = true;\n+        }\n+\n+        AExpression userAfterthoughtNode = userForNode.getAfterthoughtNode();\n+\n+        if (userAfterthoughtNode != null) {\n+            checkedVisit(userAfterthoughtNode, semanticScope);\n+        }\n+\n+        if (userBlockNode != null) {\n+            semanticScope.setCondition(userBlockNode, BeginLoop.class);\n+            semanticScope.setCondition(userBlockNode, InLoop.class);\n+            visit(userBlockNode, semanticScope);\n+\n+            if (semanticScope.getCondition(userBlockNode, LoopEscape.class) &&\n+                    semanticScope.getCondition(userBlockNode, AnyContinue.class) == false) {\n+                throw userForNode.createError(new IllegalArgumentException(\"extraneous for loop\"));\n+            }\n+\n+            if (continuous && semanticScope.getCondition(userBlockNode, AnyBreak.class) == false) {\n+                semanticScope.setCondition(userForNode, MethodEscape.class);\n+                semanticScope.setCondition(userForNode, AllEscape.class);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitEach(SEach userEachNode, SemanticScope semanticScope) {\n+        AExpression userIterableNode = userEachNode.getIterableNode();\n+        semanticScope.setCondition(userIterableNode, Read.class);\n+        checkedVisit(userIterableNode, semanticScope);\n+\n+        String canonicalTypeName = userEachNode.getCanonicalTypeName();\n+        Class<?> type = semanticScope.getScriptScope().getPainlessLookup().canonicalTypeNameToType(canonicalTypeName);\n+\n+        if (type == null) {\n+            throw userEachNode.createError(new IllegalArgumentException(\n+                    \"invalid foreach loop: type [\" + canonicalTypeName + \"] not found\"));\n+        }\n+\n+        semanticScope = semanticScope.newLocalScope();\n+\n+        Location location = userEachNode.getLocation();\n+        String symbol = userEachNode.getSymbol();\n+        Variable variable = semanticScope.defineVariable(location, type, symbol, true);\n+        semanticScope.putDecoration(userEachNode, new SemanticVariable(variable));\n+\n+        SBlock userBlockNode = userEachNode.getBlockNode();\n+\n+        if (userBlockNode == null) {\n+            throw userEachNode.createError(new IllegalArgumentException(\"extraneous foreach loop\"));\n+        }\n+\n+        semanticScope.setCondition(userBlockNode, BeginLoop.class);\n+        semanticScope.setCondition(userBlockNode, InLoop.class);\n+        visit(userBlockNode, semanticScope);\n+\n+        if (semanticScope.getCondition(userBlockNode, LoopEscape.class) &&\n+                semanticScope.getCondition(userBlockNode, AnyContinue.class) == false) {\n+            throw userEachNode.createError(new IllegalArgumentException(\"extraneous foreach loop\"));\n+        }\n+\n+        Class<?> iterableValueType = semanticScope.getDecoration(userIterableNode, ValueType.class).getValueType();\n+\n+        if (iterableValueType.isArray()) {\n+            PainlessCast painlessCast =\n+                    AnalyzerCaster.getLegalCast(location, iterableValueType.getComponentType(), variable.getType(), true, true);\n+\n+            if (painlessCast != null) {\n+                semanticScope.putDecoration(userEachNode, new ExpressionPainlessCast(painlessCast));\n+            }\n+        } else if (iterableValueType == def.class || Iterable.class.isAssignableFrom(iterableValueType)) {\n+            if (iterableValueType != def.class) {\n+                PainlessMethod method = semanticScope.getScriptScope().getPainlessLookup().\n+                        lookupPainlessMethod(iterableValueType, false, \"iterator\", 0);\n+\n+                if (method == null) {\n+                    throw userEachNode.createError(new IllegalArgumentException(\"invalid foreach loop: \" +\n+                            \"method [\" + typeToCanonicalTypeName(iterableValueType) + \", iterator/0] not found\"));\n+                }\n+\n+                semanticScope.putDecoration(userEachNode, new IterablePainlessMethod(method));\n+            }\n+\n+            PainlessCast painlessCast = AnalyzerCaster.getLegalCast(location, def.class, type, true, true);\n+\n+            if (painlessCast != null) {\n+                semanticScope.putDecoration(userEachNode, new ExpressionPainlessCast(painlessCast));\n+            }\n+        } else {\n+            throw userEachNode.createError(new IllegalArgumentException(\"invalid foreach loop: \" +\n+                    \"cannot iterate over type [\" + PainlessLookupUtility.typeToCanonicalTypeName(iterableValueType) + \"].\"));\n+        }\n+    }\n+\n+    @Override\n+    public void visitDeclBlock(SDeclBlock userDeclBlockNode, SemanticScope semanticScope) {\n+        for (SDeclaration userDeclarationNode : userDeclBlockNode.getDeclarationNodes()) {\n+            visit(userDeclarationNode, semanticScope);\n+        }\n+    }\n+\n+    @Override\n+    public void visitDeclaration(SDeclaration userDeclarationNode, SemanticScope semanticScope) {\n+        ScriptScope scriptScope = semanticScope.getScriptScope();\n+        String symbol = userDeclarationNode.getSymbol();\n+\n+        if (scriptScope.getPainlessLookup().isValidCanonicalClassName(symbol)) {\n+            throw userDeclarationNode.createError(new IllegalArgumentException(\n+                    \"invalid declaration: type [\" + symbol + \"] cannot be a name\"));\n+        }\n+\n+        String canonicalTypeName = userDeclarationNode.getCanonicalTypeName();\n+        Class<?> type = scriptScope.getPainlessLookup().canonicalTypeNameToType(canonicalTypeName);\n+\n+        if (type == null) {\n+            throw userDeclarationNode.createError(new IllegalArgumentException(\n+                    \"invalid declaration: cannot resolve type [\" + canonicalTypeName + \"]\"));\n+        }\n+\n+        AExpression userValueNode = userDeclarationNode.getValueNode();\n+\n+        if (userValueNode != null) {\n+            semanticScope.setCondition(userValueNode, Read.class);\n+            semanticScope.putDecoration(userValueNode, new TargetType(type));\n+            checkedVisit(userValueNode, semanticScope);\n+            decorateWithCast(userValueNode, semanticScope);\n+        }\n+\n+        Location location = userDeclarationNode.getLocation();\n+        Variable variable = semanticScope.defineVariable(location, type, symbol, false);\n+        semanticScope.putDecoration(userDeclarationNode, new SemanticVariable(variable));\n+    }\n+\n+    @Override\n+    public void visitReturn(SReturn userReturnNode, SemanticScope semanticScope) {\n+        AExpression userValueNode = userReturnNode.getValueNode();\n+\n+        if (userValueNode == null) {\n+            if (semanticScope.getReturnType() != void.class) {\n+                throw userReturnNode.createError(new ClassCastException(\"cannot cast from \" +\n+                        \"[\" + semanticScope.getReturnCanonicalTypeName() + \"] to \" +\n+                        \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(void.class) + \"]\"));\n+            }\n+        } else {\n+            semanticScope.setCondition(userValueNode, Read.class);\n+            semanticScope.putDecoration(userValueNode, new TargetType(semanticScope.getReturnType()));\n+            semanticScope.setCondition(userValueNode, Internal.class);\n+            checkedVisit(userValueNode, semanticScope);\n+            decorateWithCast(userValueNode, semanticScope);\n+        }\n+\n+        semanticScope.setCondition(userReturnNode, MethodEscape.class);\n+        semanticScope.setCondition(userReturnNode, LoopEscape.class);\n+        semanticScope.setCondition(userReturnNode, AllEscape.class);\n+    }\n+\n+    @Override\n+    public void visitExpression(SExpression userExpressionNode, SemanticScope semanticScope) {\n+        Class<?> rtnType = semanticScope.getReturnType();\n+        boolean isVoid = rtnType == void.class;\n+        boolean lastSource = semanticScope.getCondition(userExpressionNode, LastSource.class);\n+        AExpression userStatementNode = userExpressionNode.getStatementNode();\n+\n+        if (lastSource && isVoid == false) {\n+            semanticScope.setCondition(userStatementNode, Read.class);\n+        }\n+\n+        checkedVisit(userStatementNode, semanticScope);\n+        Class<?> expressionValueType = semanticScope.getDecoration(userStatementNode, ValueType.class).getValueType();\n+        boolean rtn = lastSource && isVoid == false && expressionValueType != void.class;\n+\n+        if (rtn) {\n+            semanticScope.putDecoration(userStatementNode, new TargetType(rtnType));\n+            semanticScope.setCondition(userStatementNode, Internal.class);\n+            decorateWithCast(userStatementNode, semanticScope);\n+\n+            semanticScope.setCondition(userExpressionNode, MethodEscape.class);\n+            semanticScope.setCondition(userExpressionNode, LoopEscape.class);\n+            semanticScope.setCondition(userExpressionNode, AllEscape.class);\n+        }\n+    }\n+\n+    @Override\n+    public void visitTry(STry userTryNode, SemanticScope semanticScope) {\n+        SBlock userBlockNode = userTryNode.getBlockNode();\n+\n+        if (userBlockNode == null) {\n+            throw userTryNode.createError(new IllegalArgumentException(\"extraneous try statement\"));\n+        }\n+\n+        semanticScope.replicateCondition(userTryNode, userBlockNode, LastSource.class);\n+        semanticScope.replicateCondition(userTryNode, userBlockNode, InLoop.class);\n+        semanticScope.replicateCondition(userTryNode, userBlockNode, LastLoop.class);\n+        visit(userBlockNode, semanticScope.newLocalScope());\n+\n+        boolean methodEscape = semanticScope.getCondition(userBlockNode, MethodEscape.class);\n+        boolean loopEscape = semanticScope.getCondition(userBlockNode, LoopEscape.class);\n+        boolean allEscape = semanticScope.getCondition(userBlockNode, AllEscape.class);\n+        boolean anyContinue = semanticScope.getCondition(userBlockNode, AnyContinue.class);\n+        boolean anyBreak = semanticScope.getCondition(userBlockNode, AnyBreak.class);\n+\n+        for (SCatch userCatchNode : userTryNode.getCatchNodes()) {\n+            semanticScope.replicateCondition(userTryNode, userCatchNode, LastSource.class);\n+            semanticScope.replicateCondition(userTryNode, userCatchNode, InLoop.class);\n+            semanticScope.replicateCondition(userTryNode, userCatchNode, LastLoop.class);\n+            visit(userCatchNode, semanticScope.newLocalScope());\n+\n+            methodEscape &= semanticScope.getCondition(userCatchNode, MethodEscape.class);\n+            loopEscape &= semanticScope.getCondition(userCatchNode, LoopEscape.class);\n+            allEscape &= semanticScope.getCondition(userCatchNode, AllEscape.class);\n+            anyContinue |= semanticScope.getCondition(userCatchNode, AnyContinue.class);\n+            anyBreak |= semanticScope.getCondition(userCatchNode, AnyBreak.class);\n+        }\n+\n+        if (methodEscape) {\n+            semanticScope.setCondition(userTryNode, MethodEscape.class);\n+        }\n+\n+        if (loopEscape) {\n+            semanticScope.setCondition(userTryNode, LoopEscape.class);\n+        }\n+\n+        if (allEscape) {\n+            semanticScope.setCondition(userTryNode, AllEscape.class);\n+        }\n+\n+        if (anyContinue) {\n+            semanticScope.setCondition(userTryNode, AnyContinue.class);\n+        }\n+\n+        if (anyBreak) {\n+            semanticScope.setCondition(userTryNode, AnyBreak.class);\n+        }\n+    }\n+\n+    @Override\n+    public void visitCatch(SCatch userCatchNode, SemanticScope semanticScope) {\n+        ScriptScope scriptScope = semanticScope.getScriptScope();\n+        String symbol = userCatchNode.getSymbol();\n+\n+        if (scriptScope.getPainlessLookup().isValidCanonicalClassName(symbol)) {\n+            throw userCatchNode.createError(new IllegalArgumentException(\n+                    \"invalid catch declaration: type [\" + symbol + \"] cannot be a name\"));\n+        }\n+\n+        String canonicalTypeName = userCatchNode.getCanonicalTypeName();\n+        Class<?> type = scriptScope.getPainlessLookup().canonicalTypeNameToType(canonicalTypeName);\n+\n+        if (type == null) {\n+            throw userCatchNode.createError(new IllegalArgumentException(\n+                    \"invalid catch declaration: cannot resolve type [\" + canonicalTypeName + \"]\"));\n+        }\n+\n+        Location location = userCatchNode.getLocation();\n+        Variable variable = semanticScope.defineVariable(location, type, symbol, false);\n+        semanticScope.putDecoration(userCatchNode, new SemanticVariable(variable));\n+        Class<?> baseException = userCatchNode.getBaseException();\n+\n+        if (userCatchNode.getBaseException().isAssignableFrom(type) == false) {\n+            throw userCatchNode.createError(new ClassCastException(\n+                    \"cannot cast from [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] \" +\n+                            \"to [\" + PainlessLookupUtility.typeToCanonicalTypeName(baseException) + \"]\"));\n+        }\n+\n+        SBlock userBlockNode = userCatchNode.getBlockNode();\n+\n+        if (userBlockNode != null) {\n+            semanticScope.replicateCondition(userCatchNode, userBlockNode, LastSource.class);\n+            semanticScope.replicateCondition(userCatchNode, userBlockNode, InLoop.class);\n+            semanticScope.replicateCondition(userCatchNode, userBlockNode, LastLoop.class);\n+            visit(userBlockNode, semanticScope);\n+\n+            semanticScope.replicateCondition(userBlockNode, userCatchNode, MethodEscape.class);\n+            semanticScope.replicateCondition(userBlockNode, userCatchNode, LoopEscape.class);\n+            semanticScope.replicateCondition(userBlockNode, userCatchNode, AllEscape.class);\n+            semanticScope.replicateCondition(userBlockNode, userCatchNode, AnyContinue.class);\n+            semanticScope.replicateCondition(userBlockNode, userCatchNode, AnyBreak.class);\n+        }\n+    }\n+\n+    @Override\n+    public void visitThrow(SThrow userThrowNode, SemanticScope semanticScope) {\n+        AExpression userExpressionNode = userThrowNode.getExpressionNode();\n+\n+        semanticScope.setCondition(userExpressionNode, Read.class);\n+        semanticScope.putDecoration(userExpressionNode, new TargetType(Exception.class));\n+        checkedVisit(userExpressionNode, semanticScope);\n+        decorateWithCast(userExpressionNode, semanticScope);\n+\n+        semanticScope.setCondition(userThrowNode, MethodEscape.class);\n+        semanticScope.setCondition(userThrowNode, LoopEscape.class);\n+        semanticScope.setCondition(userThrowNode, AllEscape.class);\n+    }\n+\n+    @Override\n+    public void visitContinue(SContinue userContinueNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userContinueNode, InLoop.class) == false) {\n+            throw userContinueNode.createError(new IllegalArgumentException(\"invalid continue statement: not inside loop\"));\n+        }\n+\n+        if (semanticScope.getCondition(userContinueNode, LastLoop.class)) {\n+            throw userContinueNode.createError(new IllegalArgumentException(\"extraneous continue statement\"));\n+        }\n+\n+        semanticScope.setCondition(userContinueNode, AllEscape.class);\n+        semanticScope.setCondition(userContinueNode, AnyContinue.class);\n+    }\n+\n+    @Override\n+    public void visitBreak(SBreak userBreakNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userBreakNode, InLoop.class) == false) {\n+            throw userBreakNode.createError(new IllegalArgumentException(\"invalid break statement: not inside loop\"));\n+        }\n+\n+        semanticScope.setCondition(userBreakNode, AllEscape.class);\n+        semanticScope.setCondition(userBreakNode, LoopEscape.class);\n+        semanticScope.setCondition(userBreakNode, AnyBreak.class);\n+    }\n+\n+    @Override\n+    public void visitAssignment(EAssignment userAssignmentNode, SemanticScope semanticScope) {\n+        AExpression userLeftNode = userAssignmentNode.getLeftNode();\n+        semanticScope.replicateCondition(userAssignmentNode, userLeftNode, Read.class);\n+        semanticScope.setCondition(userLeftNode, Write.class);\n+        checkedVisit(userLeftNode, semanticScope);\n+        Class<?> leftValueType = semanticScope.getDecoration(userLeftNode, Decorations.ValueType.class).getValueType();\n+\n+        AExpression userRightNode = userAssignmentNode.getRightNode();\n+        semanticScope.setCondition(userRightNode, Read.class);\n+\n+        Operation operation = userAssignmentNode.getOperation();\n+\n+        if (operation != null) {\n+            checkedVisit(userRightNode, semanticScope);\n+            Class<?> rightValueType = semanticScope.getDecoration(userRightNode, ValueType.class).getValueType();\n+\n+            Class<?> compoundType;\n+            Class<?> shiftType = null;\n+            boolean isShift = false;\n+\n+            if (operation == Operation.MUL) {\n+                compoundType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, true);\n+            } else if (operation == Operation.DIV) {\n+                compoundType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, true);\n+            } else if (operation == Operation.REM) {\n+                compoundType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, true);\n+            } else if (operation == Operation.ADD) {\n+                compoundType = AnalyzerCaster.promoteAdd(leftValueType, rightValueType);\n+            } else if (operation == Operation.SUB) {\n+                compoundType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, true);\n+            } else if (operation == Operation.LSH) {\n+                compoundType = AnalyzerCaster.promoteNumeric(leftValueType, false);\n+                shiftType = AnalyzerCaster.promoteNumeric(rightValueType, false);\n+                isShift = true;\n+            } else if (operation == Operation.RSH) {\n+                compoundType = AnalyzerCaster.promoteNumeric(leftValueType, false);\n+                shiftType = AnalyzerCaster.promoteNumeric(rightValueType, false);\n+                isShift = true;\n+            } else if (operation == Operation.USH) {\n+                compoundType = AnalyzerCaster.promoteNumeric(leftValueType, false);\n+                shiftType = AnalyzerCaster.promoteNumeric(rightValueType, false);\n+                isShift = true;\n+            } else if (operation == Operation.BWAND) {\n+                compoundType = AnalyzerCaster.promoteXor(leftValueType, rightValueType);\n+            } else if (operation == Operation.XOR) {\n+                compoundType = AnalyzerCaster.promoteXor(leftValueType, rightValueType);\n+            } else if (operation == Operation.BWOR) {\n+                compoundType = AnalyzerCaster.promoteXor(leftValueType, rightValueType);\n+            } else {\n+                throw userAssignmentNode.createError(new IllegalStateException(\"illegal tree structure\"));\n+            }\n+\n+            if (compoundType == null || (isShift && shiftType == null)) {\n+                throw userAssignmentNode.createError(new ClassCastException(\"invalid compound assignment: \" +\n+                        \"cannot apply [\" + operation.symbol + \"=] to types [\" + leftValueType + \"] and [\" + rightValueType + \"]\"));\n+            }\n+\n+            boolean cat = operation == Operation.ADD && compoundType == String.class;\n+\n+            if (cat && userRightNode instanceof EBinary &&\n+                    ((EBinary)userRightNode).getOperation() == Operation.ADD && rightValueType == String.class) {\n+                semanticScope.setCondition(userRightNode, Concatenate.class);\n+            }\n+\n+            if (isShift) {\n+                if (compoundType == def.class) {\n+                    // shifts are promoted independently, but for the def type, we need object.\n+                    semanticScope.putDecoration(userRightNode, new TargetType(def.class));\n+                } else if (shiftType == long.class) {\n+                    semanticScope.putDecoration(userRightNode, new TargetType(int.class));\n+                    semanticScope.setCondition(userRightNode, Explicit.class);\n+                } else {\n+                    semanticScope.putDecoration(userRightNode, new TargetType(shiftType));\n+                }\n+            } else {\n+                semanticScope.putDecoration(userRightNode, new TargetType(compoundType));\n+            }\n+\n+            decorateWithCast(userRightNode, semanticScope);\n+\n+            Location location = userAssignmentNode.getLocation();\n+            PainlessCast upcast = AnalyzerCaster.getLegalCast(location, leftValueType, compoundType, false, false);\n+            PainlessCast downcast = AnalyzerCaster.getLegalCast(location, compoundType, leftValueType, true, false);\n+\n+            semanticScope.putDecoration(userAssignmentNode, new CompoundType(compoundType));\n+\n+            if (cat) {\n+                semanticScope.setCondition(userAssignmentNode, Concatenate.class);\n+            }\n+\n+            if (upcast != null) {\n+                semanticScope.putDecoration(userAssignmentNode, new UpcastPainlessCast(upcast));\n+            }\n+\n+            if (downcast != null) {\n+                semanticScope.putDecoration(userAssignmentNode, new DowncastPainlessCast(downcast));\n+            }\n+            // if the lhs node is a def optimized node we update the actual type to remove the need for a cast\n+        } else if (semanticScope.getCondition(userLeftNode, DefOptimized.class)) {\n+            checkedVisit(userRightNode, semanticScope);\n+            Class<?> rightValueType = semanticScope.getDecoration(userRightNode, ValueType.class).getValueType();\n+\n+            if (rightValueType == void.class) {\n+                throw userAssignmentNode.createError(new IllegalArgumentException(\n+                        \"invalid assignment: cannot assign type [\" + PainlessLookupUtility.typeToCanonicalTypeName(void.class) + \"]\"));\n+            }\n+\n+            semanticScope.putDecoration(userLeftNode, new ValueType(rightValueType));\n+            leftValueType = rightValueType;\n+            // Otherwise, we must adapt the rhs type to the lhs type with a cast.\n+        } else {\n+            semanticScope.putDecoration(userRightNode, new TargetType(leftValueType));\n+            checkedVisit(userRightNode, semanticScope);\n+            decorateWithCast(userRightNode, semanticScope);\n+        }\n+\n+        semanticScope.putDecoration(userAssignmentNode,\n+                new ValueType(semanticScope.getCondition(userAssignmentNode, Read.class) ? leftValueType : void.class));\n+    }\n+\n+    @Override\n+    public void visitUnary(EUnary userUnaryNode, SemanticScope semanticScope) {\n+        Operation operation = userUnaryNode.getOperation();\n+\n+        if (semanticScope.getCondition(userUnaryNode, Write.class)) {\n+            throw userUnaryNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userUnaryNode, Read.class) == false) {\n+            throw userUnaryNode.createError(new IllegalArgumentException(\n+                    \"not a statement: result not used from \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        AExpression userChildNode = userUnaryNode.getChildNode();\n+        Class<?> valueType;\n+        Class<?> unaryType = null;\n+\n+        if (operation == Operation.SUB && (userChildNode instanceof ENumeric || userChildNode instanceof EDecimal)) {\n+            semanticScope.setCondition(userChildNode, Read.class);\n+            semanticScope.copyDecoration(userUnaryNode, userChildNode, TargetType.class);\n+            semanticScope.replicateCondition(userUnaryNode, userChildNode, Explicit.class);\n+            semanticScope.replicateCondition(userUnaryNode, userChildNode, Internal.class);\n+            semanticScope.setCondition(userChildNode, Negate.class);\n+            checkedVisit(userChildNode, semanticScope);\n+\n+            if (semanticScope.hasDecoration(userUnaryNode, TargetType.class)) {\n+                decorateWithCast(userChildNode, semanticScope);\n+            }\n+\n+            valueType = semanticScope.getDecoration(userChildNode, ValueType.class).getValueType();\n+        } else {\n+            if (operation == Operation.NOT) {\n+                semanticScope.setCondition(userChildNode, Read.class);\n+                semanticScope.putDecoration(userChildNode, new TargetType(boolean.class));\n+                checkedVisit(userChildNode, semanticScope);\n+                decorateWithCast(userChildNode, semanticScope);\n+\n+                valueType = boolean.class;\n+            } else if (operation == Operation.BWNOT || operation == Operation.ADD || operation == Operation.SUB) {\n+                semanticScope.setCondition(userChildNode, Read.class);\n+                checkedVisit(userChildNode, semanticScope);\n+                Class<?> childValueType = semanticScope.getDecoration(userChildNode, ValueType.class).getValueType();\n+\n+                unaryType = AnalyzerCaster.promoteNumeric(childValueType, operation != Operation.BWNOT);\n+\n+                if (unaryType == null) {\n+                    throw userUnaryNode.createError(new ClassCastException(\"cannot apply the \" + operation.name + \" operator \" +\n+                            \"[\" + operation.symbol + \"] to the type \" +\n+                            \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(childValueType) + \"]\"));\n+                }\n+\n+                semanticScope.putDecoration(userChildNode, new TargetType(unaryType));\n+                decorateWithCast(userChildNode, semanticScope);\n+\n+                TargetType targetType = semanticScope.getDecoration(userUnaryNode, TargetType.class);\n+\n+                if (unaryType == def.class && targetType != null) {\n+                    valueType = targetType.getTargetType();\n+                } else {\n+                    valueType = unaryType;\n+                }\n+            } else {\n+                throw userUnaryNode.createError(new IllegalStateException(\"unexpected unary operation [\" + operation.name + \"]\"));\n+            }\n+        }\n+\n+        semanticScope.putDecoration(userUnaryNode, new ValueType(valueType));\n+\n+        if (unaryType != null) {\n+            semanticScope.putDecoration(userUnaryNode, new UnaryType(unaryType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitBinary(EBinary userBinaryNode, SemanticScope semanticScope) {\n+        Operation operation = userBinaryNode.getOperation();\n+\n+        if (semanticScope.getCondition(userBinaryNode, Write.class)) {\n+            throw userBinaryNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userBinaryNode, Read.class) == false) {\n+            throw userBinaryNode.createError(new IllegalArgumentException(\n+                    \"not a statement: result not used from \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        AExpression userLeftNode = userBinaryNode.getLeftNode();\n+        semanticScope.setCondition(userLeftNode, Read.class);\n+        checkedVisit(userLeftNode, semanticScope);\n+        Class<?> leftValueType = semanticScope.getDecoration(userLeftNode, ValueType.class).getValueType();\n+\n+        AExpression userRightNode = userBinaryNode.getRightNode();\n+        semanticScope.setCondition(userRightNode, Read.class);\n+        checkedVisit(userRightNode, semanticScope);\n+        Class<?> rightValueType = semanticScope.getDecoration(userRightNode, ValueType.class).getValueType();\n+\n+        Class<?> valueType;\n+        Class<?> binaryType;\n+        Class<?> shiftType = null;\n+\n+        if (operation == Operation.FIND || operation == Operation.MATCH) {\n+            semanticScope.putDecoration(userLeftNode, new TargetType(String.class));\n+            semanticScope.putDecoration(userRightNode, new TargetType(Pattern.class));\n+            decorateWithCast(userLeftNode, semanticScope);\n+            decorateWithCast(userRightNode, semanticScope);\n+            binaryType = boolean.class;\n+            valueType = boolean.class;\n+        } else {\n+            if (operation == Operation.MUL || operation == Operation.DIV || operation == Operation.REM) {\n+                binaryType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, true);\n+            } else if (operation == Operation.ADD) {\n+                binaryType = AnalyzerCaster.promoteAdd(leftValueType, rightValueType);\n+            } else if (operation == Operation.SUB) {\n+                binaryType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, true);\n+            } else if (operation == Operation.LSH || operation == Operation.RSH || operation == Operation.USH) {\n+                binaryType = AnalyzerCaster.promoteNumeric(leftValueType, false);\n+                shiftType = AnalyzerCaster.promoteNumeric(rightValueType, false);\n+\n+                if (shiftType == null) {\n+                    binaryType = null;\n+                }\n+            } else if (operation == Operation.BWOR || operation == Operation.BWAND) {\n+                binaryType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, false);\n+            } else if (operation == Operation.XOR) {\n+                binaryType = AnalyzerCaster.promoteXor(leftValueType, rightValueType);\n+            } else {\n+                throw userBinaryNode.createError(new IllegalStateException(\"unexpected binary operation [\" + operation.name + \"]\"));\n+            }\n+\n+            if (binaryType == null) {\n+                throw userBinaryNode.createError(new ClassCastException(\"cannot apply the \" + operation.name + \" operator \" +\n+                        \"[\" + operation.symbol + \"] to the types \" +\n+                        \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(leftValueType) + \"] and \" +\n+                        \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(rightValueType) + \"]\"));\n+            }\n+\n+            valueType = binaryType;\n+\n+            if (operation == Operation.ADD && binaryType == String.class) {\n+                if (userLeftNode instanceof EBinary &&\n+                        ((EBinary)userLeftNode).getOperation() == Operation.ADD && leftValueType == String.class) {\n+                    semanticScope.setCondition(userLeftNode, Concatenate.class);\n+                }\n+\n+                if (userRightNode instanceof EBinary &&\n+                        ((EBinary)userRightNode).getOperation() == Operation.ADD && rightValueType == String.class) {\n+                    semanticScope.setCondition(userRightNode, Concatenate.class);\n+                }\n+            } else if (binaryType == def.class || shiftType == def.class) {\n+                TargetType targetType = semanticScope.getDecoration(userBinaryNode, TargetType.class);\n+\n+                if (targetType != null) {\n+                    valueType = targetType.getTargetType();\n+                }\n+            } else {\n+                semanticScope.putDecoration(userLeftNode, new TargetType(binaryType));\n+\n+                if (operation == Operation.LSH || operation == Operation.RSH || operation == Operation.USH) {\n+                    if (shiftType == long.class) {\n+                        semanticScope.putDecoration(userRightNode, new TargetType(int.class));\n+                        semanticScope.setCondition(userRightNode, Explicit.class);\n+                    } else {\n+                        semanticScope.putDecoration(userRightNode, new TargetType(shiftType));\n+                    }\n+                } else {\n+                    semanticScope.putDecoration(userRightNode, new TargetType(binaryType));\n+                }\n+\n+                decorateWithCast(userLeftNode, semanticScope);\n+                decorateWithCast(userRightNode, semanticScope);\n+            }\n+        }\n+\n+        semanticScope.putDecoration(userBinaryNode, new ValueType(valueType));\n+        semanticScope.putDecoration(userBinaryNode, new BinaryType(binaryType));\n+\n+        if (shiftType != null) {\n+            semanticScope.putDecoration(userBinaryNode, new ShiftType(shiftType));\n+        }\n+    }\n+\n+    @Override\n+    public void visitBooleanComp(EBooleanComp userBooleanCompNode, SemanticScope semanticScope) {\n+        Operation operation = userBooleanCompNode.getOperation();\n+\n+        if (semanticScope.getCondition(userBooleanCompNode, Write.class)) {\n+            throw userBooleanCompNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userBooleanCompNode, Read.class) == false) {\n+            throw userBooleanCompNode.createError(new IllegalArgumentException(\n+                    \"not a statement: result not used from \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        AExpression userLeftNode = userBooleanCompNode.getLeftNode();\n+        semanticScope.setCondition(userLeftNode, Read.class);\n+        semanticScope.putDecoration(userLeftNode, new TargetType(boolean.class));\n+        checkedVisit(userLeftNode, semanticScope);\n+        decorateWithCast(userLeftNode, semanticScope);\n+\n+        AExpression userRightNode = userBooleanCompNode.getRightNode();\n+        semanticScope.setCondition(userRightNode, Read.class);\n+        semanticScope.putDecoration(userRightNode, new TargetType(boolean.class));\n+        checkedVisit(userRightNode, semanticScope);\n+        decorateWithCast(userRightNode, semanticScope);\n+\n+        semanticScope.putDecoration(userBooleanCompNode, new ValueType(boolean.class));\n+    }\n+\n+    @Override\n+    public void visitComp(EComp userCompNode, SemanticScope semanticScope) {\n+        Operation operation = userCompNode.getOperation();\n+\n+        if (semanticScope.getCondition(userCompNode, Write.class)) {\n+            throw userCompNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userCompNode, Read.class) == false) {\n+            throw userCompNode.createError(new IllegalArgumentException(\n+                    \"not a statement: result not used from \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n+        }\n+\n+        AExpression userLeftNode = userCompNode.getLeftNode();\n+        semanticScope.setCondition(userLeftNode, Read.class);\n+        checkedVisit(userLeftNode, semanticScope);\n+        Class<?> leftValueType = semanticScope.getDecoration(userLeftNode, ValueType.class).getValueType();\n+\n+        AExpression userRightNode = userCompNode.getRightNode();\n+        semanticScope.setCondition(userRightNode, Read.class);\n+        checkedVisit(userRightNode, semanticScope);\n+        Class<?> rightValueType = semanticScope.getDecoration(userRightNode, ValueType.class).getValueType();\n+\n+        Class<?> promotedType;\n+\n+        if (operation == Operation.EQ || operation == Operation.EQR || operation == Operation.NE || operation == Operation.NER) {\n+            promotedType = AnalyzerCaster.promoteEquality(leftValueType, rightValueType);\n+        } else if (operation == Operation.GT || operation == Operation.GTE || operation == Operation.LT || operation == Operation.LTE) {\n+            promotedType = AnalyzerCaster.promoteNumeric(leftValueType, rightValueType, true);\n+        } else {\n+            throw userCompNode.createError(new IllegalStateException(\"unexpected binary operation [\" + operation.name + \"]\"));\n+        }\n+\n+        if (promotedType == null) {\n+            throw userCompNode.createError(new ClassCastException(\"cannot apply the \" + operation.name + \" operator \" +\n+                    \"[\" + operation.symbol + \"] to the types \" +\n+                    \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(leftValueType) + \"] and \" +\n+                    \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(rightValueType) + \"]\"));\n+        }\n+\n+        if ((operation == Operation.EQ || operation == Operation.EQR || operation == Operation.NE || operation == Operation.NER)\n+                && userLeftNode instanceof ENull && userRightNode instanceof ENull) {\n+            throw userCompNode.createError(new IllegalArgumentException(\"extraneous comparison of [null] constants\"));\n+        }\n+\n+        if (operation == Operation.EQR || operation == Operation.NER || promotedType != def.class) {\n+            semanticScope.putDecoration(userLeftNode, new TargetType(promotedType));\n+            semanticScope.putDecoration(userRightNode, new TargetType(promotedType));\n+            decorateWithCast(userLeftNode, semanticScope);\n+            decorateWithCast(userRightNode, semanticScope);\n+        }\n+\n+        semanticScope.putDecoration(userCompNode, new ValueType(boolean.class));\n+        semanticScope.putDecoration(userCompNode, new ComparisonType(promotedType));\n+    }\n+\n+    @Override\n+    public void visitExplicit(EExplicit userExplicitNode, SemanticScope semanticScope) {\n+        String canonicalTypeName = userExplicitNode.getCanonicalTypeName();\n+\n+        if (semanticScope.getCondition(userExplicitNode, Write.class)) {\n+            throw userExplicitNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to an explicit cast with target type [\" + canonicalTypeName + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userExplicitNode, Read.class) == false) {\n+            throw userExplicitNode.createError(new IllegalArgumentException(\n+                    \"not a statement: result not used from explicit cast with target type [\" + canonicalTypeName + \"]\"));\n+        }\n+\n+        Class<?> valueType = semanticScope.getScriptScope().getPainlessLookup().canonicalTypeNameToType(canonicalTypeName);\n+\n+        if (valueType == null) {\n+            throw userExplicitNode.createError(new IllegalArgumentException(\"cannot resolve type [\" + canonicalTypeName + \"]\"));\n+        }\n+\n+        AExpression userChildNode = userExplicitNode.getChildNode();\n+        semanticScope.setCondition(userChildNode, Read.class);\n+        semanticScope.putDecoration(userChildNode, new TargetType(valueType));\n+        semanticScope.setCondition(userChildNode, Explicit.class);\n+        checkedVisit(userChildNode, semanticScope);\n+        decorateWithCast(userChildNode, semanticScope);\n+\n+        semanticScope.putDecoration(userExplicitNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitInstanceof(EInstanceof userInstanceofNode, SemanticScope semanticScope) {\n+        String canonicalTypeName = userInstanceofNode.getCanonicalTypeName();\n+\n+        if (semanticScope.getCondition(userInstanceofNode, Write.class)) {\n+            throw userInstanceofNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to instanceof with target type [\" + canonicalTypeName + \"]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userInstanceofNode, Read.class) == false) {\n+            throw userInstanceofNode.createError(new IllegalArgumentException(\n+                    \"not a statement: result not used from instanceof with target type [\" + canonicalTypeName + \"]\"));\n+        }\n+\n+        Class<?> instanceType = semanticScope.getScriptScope().getPainlessLookup().canonicalTypeNameToType(canonicalTypeName);\n+\n+        if (instanceType == null) {\n+            throw userInstanceofNode.createError(new IllegalArgumentException(\"Not a type [\" + canonicalTypeName + \"].\"));\n+        }\n+\n+        AExpression userExpressionNode = userInstanceofNode.getExpressionNode();\n+        semanticScope.setCondition(userExpressionNode, Read.class);\n+        checkedVisit(userExpressionNode, semanticScope);\n+\n+        semanticScope.putDecoration(userInstanceofNode, new ValueType(boolean.class));\n+        semanticScope.putDecoration(userInstanceofNode, new InstanceType(instanceType));\n+    }\n+\n+    @Override\n+    public void visitConditional(EConditional userConditionalNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userConditionalNode, Write.class)) {\n+            throw userConditionalNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to conditional operation [?:]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userConditionalNode, Read.class) == false) {\n+            throw userConditionalNode.createError(new IllegalArgumentException(\n+                    \"not a statement: result not used from conditional operation [?:]\"));\n+        }\n+\n+        AExpression userConditionNode = userConditionalNode.getConditionNode();\n+        semanticScope.setCondition(userConditionNode, Read.class);\n+        semanticScope.putDecoration(userConditionNode, new TargetType(boolean.class));\n+        checkedVisit(userConditionNode, semanticScope);\n+        decorateWithCast(userConditionNode, semanticScope);\n+\n+        AExpression userTrueNode = userConditionalNode.getTrueNode();\n+        semanticScope.setCondition(userTrueNode, Read.class);\n+        semanticScope.copyDecoration(userConditionalNode, userTrueNode, TargetType.class);\n+        semanticScope.replicateCondition(userConditionalNode, userTrueNode, Explicit.class);\n+        semanticScope.replicateCondition(userConditionalNode, userTrueNode, Internal.class);\n+        checkedVisit(userTrueNode, semanticScope);\n+        Class<?> leftValueType = semanticScope.getDecoration(userTrueNode, ValueType.class).getValueType();\n+\n+        AExpression userFalseNode = userConditionalNode.getFalseNode();\n+        semanticScope.setCondition(userFalseNode, Read.class);\n+        semanticScope.copyDecoration(userConditionalNode, userFalseNode, TargetType.class);\n+        semanticScope.replicateCondition(userConditionalNode, userFalseNode, Explicit.class);\n+        semanticScope.replicateCondition(userConditionalNode, userFalseNode, Internal.class);\n+        checkedVisit(userFalseNode, semanticScope);\n+        Class<?> rightValueType = semanticScope.getDecoration(userFalseNode, ValueType.class).getValueType();\n+\n+        TargetType targetType = semanticScope.getDecoration(userConditionalNode, TargetType.class);\n+        Class<?> valueType;\n+\n+        if (targetType == null) {\n+            Class<?> promote = AnalyzerCaster.promoteConditional(leftValueType, rightValueType);\n+\n+            if (promote == null) {\n+                throw userConditionalNode.createError(new ClassCastException(\"cannot apply the conditional operator [?:] to the types \" +\n+                        \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(leftValueType) + \"] and \" +\n+                        \"[\" + PainlessLookupUtility.typeToCanonicalTypeName(rightValueType) + \"]\"));\n+            }\n+\n+            semanticScope.putDecoration(userTrueNode, new TargetType(promote));\n+            semanticScope.putDecoration(userFalseNode, new TargetType(promote));\n+            valueType = promote;\n+        } else {\n+            valueType = targetType.getTargetType();\n+        }\n+\n+        decorateWithCast(userTrueNode, semanticScope);\n+        decorateWithCast(userFalseNode, semanticScope);\n+\n+        semanticScope.putDecoration(userConditionalNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitElvis(EElvis userElvisNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userElvisNode, Write.class)) {\n+            throw userElvisNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to elvis operation [?:]\"));\n+        }\n+\n+        if (semanticScope.getCondition(userElvisNode, Read.class) == false) {\n+            throw userElvisNode.createError(new IllegalArgumentException(\"not a statement: result not used from elvis operation [?:]\"));\n+        }\n+\n+        TargetType targetType = semanticScope.getDecoration(userElvisNode, TargetType.class);\n+\n+        if (targetType != null && targetType.getTargetType().isPrimitive()) {\n+            throw userElvisNode.createError(new IllegalArgumentException(\"Elvis operator cannot return primitives\"));\n+        }\n+\n+        AExpression userLeftNode = userElvisNode.getLeftNode();\n+        semanticScope.setCondition(userLeftNode, Read.class);\n+        semanticScope.copyDecoration(userElvisNode, userLeftNode, TargetType.class);\n+        semanticScope.replicateCondition(userElvisNode, userLeftNode, Explicit.class);\n+        semanticScope.replicateCondition(userElvisNode, userLeftNode, Internal.class);\n+        checkedVisit(userLeftNode, semanticScope);\n+        Class<?> leftValueType = semanticScope.getDecoration(userLeftNode, ValueType.class).getValueType();\n+\n+        AExpression userRightNode = userElvisNode.getRightNode();\n+        semanticScope.setCondition(userRightNode, Read.class);\n+        semanticScope.copyDecoration(userElvisNode, userRightNode, TargetType.class);\n+        semanticScope.replicateCondition(userElvisNode, userRightNode, Explicit.class);\n+        semanticScope.replicateCondition(userElvisNode, userRightNode, Internal.class);\n+        checkedVisit(userRightNode, semanticScope);\n+        Class<?> rightValueType = semanticScope.getDecoration(userRightNode, ValueType.class).getValueType();\n+\n+        if (userLeftNode instanceof ENull) {\n+            throw userElvisNode.createError(new IllegalArgumentException(\"Extraneous elvis operator. LHS is null.\"));\n+        }\n+        if (    userLeftNode instanceof EBooleanConstant ||\n+                userLeftNode instanceof ENumeric         ||\n+                userLeftNode instanceof EDecimal         ||\n+                userLeftNode instanceof EString\n+        ) {\n+            throw userElvisNode.createError(new IllegalArgumentException(\"Extraneous elvis operator. LHS is a constant.\"));\n+        }\n+        if (leftValueType.isPrimitive()) {\n+            throw userElvisNode.createError(new IllegalArgumentException(\"Extraneous elvis operator. LHS is a primitive.\"));\n+        }\n+        if (userRightNode instanceof ENull) {\n+            throw userElvisNode.createError(new IllegalArgumentException(\"Extraneous elvis operator. RHS is null.\"));\n+        }\n+\n+        Class<?> valueType;\n+\n+        if (targetType == null) {\n+            Class<?> promote = AnalyzerCaster.promoteConditional(leftValueType, rightValueType);\n+\n+            semanticScope.putDecoration(userLeftNode, new TargetType(promote));\n+            semanticScope.putDecoration(userRightNode, new TargetType(promote));\n+            valueType = promote;\n+        } else {\n+            valueType = targetType.getTargetType();\n+        }\n+\n+        decorateWithCast(userLeftNode, semanticScope);\n+        decorateWithCast(userRightNode, semanticScope);\n+\n+        semanticScope.putDecoration(userElvisNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitListInit(EListInit userListInitNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userListInitNode, Write.class)) {\n+            throw userListInitNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to list initializer\"));\n+        }\n+\n+        if (semanticScope.getCondition(userListInitNode, Read.class) == false) {\n+            throw userListInitNode.createError(new IllegalArgumentException(\"not a statement: result not used from list initializer\"));\n+        }\n+\n+        Class<?> valueType = ArrayList.class;\n+\n+        PainlessConstructor constructor = semanticScope.getScriptScope().getPainlessLookup().lookupPainlessConstructor(valueType, 0);\n+\n+        if (constructor == null) {\n+            throw userListInitNode.createError(new IllegalArgumentException(\n+                    \"constructor [\" + typeToCanonicalTypeName(valueType) + \", <init>/0] not found\"));\n+        }\n+\n+        semanticScope.putDecoration(userListInitNode, new StandardPainlessConstructor(constructor));\n+\n+        PainlessMethod method = semanticScope.getScriptScope().getPainlessLookup().lookupPainlessMethod(valueType, false, \"add\", 1);\n+\n+        if (method == null) {\n+            throw userListInitNode.createError(new IllegalArgumentException(\n+                    \"method [\" + typeToCanonicalTypeName(valueType) + \", add/1] not found\"));\n+        }\n+\n+        semanticScope.putDecoration(userListInitNode, new StandardPainlessMethod(method));\n+\n+        for (AExpression userValueNode : userListInitNode.getValueNodes()) {\n+            semanticScope.setCondition(userValueNode, Read.class);\n+            semanticScope.putDecoration(userValueNode, new TargetType(def.class));\n+            semanticScope.setCondition(userValueNode, Internal.class);\n+            checkedVisit(userValueNode, semanticScope);\n+            decorateWithCast(userValueNode, semanticScope);\n+        }\n+\n+        semanticScope.putDecoration(userListInitNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitMapInit(EMapInit userMapInitNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userMapInitNode, Write.class)) {\n+            throw userMapInitNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment: cannot assign a value to map initializer\"));\n+        }\n+\n+        if (semanticScope.getCondition(userMapInitNode, Read.class) == false) {\n+            throw userMapInitNode.createError(new IllegalArgumentException(\"not a statement: result not used from map initializer\"));\n+        }\n+\n+        Class<?> valueType = HashMap.class;\n+\n+        PainlessConstructor constructor = semanticScope.getScriptScope().getPainlessLookup().lookupPainlessConstructor(valueType, 0);\n+\n+        if (constructor == null) {\n+            throw userMapInitNode.createError(new IllegalArgumentException(\n+                    \"constructor [\" + typeToCanonicalTypeName(valueType) + \", <init>/0] not found\"));\n+        }\n+\n+        semanticScope.putDecoration(userMapInitNode, new StandardPainlessConstructor(constructor));\n+\n+        PainlessMethod method = semanticScope.getScriptScope().getPainlessLookup().lookupPainlessMethod(valueType, false, \"put\", 2);\n+\n+        if (method == null) {\n+            throw userMapInitNode.createError(new IllegalArgumentException(\n+                    \"method [\" + typeToCanonicalTypeName(valueType) + \", put/2] not found\"));\n+        }\n+\n+        semanticScope.putDecoration(userMapInitNode, new StandardPainlessMethod(method));\n+\n+        List<AExpression> userKeyNodes = userMapInitNode.getKeyNodes();\n+        List<AExpression> userValueNodes = userMapInitNode.getValueNodes();\n+\n+        if (userKeyNodes.size() != userValueNodes.size()) {\n+            throw userMapInitNode.createError(new IllegalStateException(\"Illegal tree structure.\"));\n+        }\n+\n+        for (int i = 0; i < userKeyNodes.size(); ++i) {\n+            AExpression userKeyNode = userKeyNodes.get(i);\n+            semanticScope.setCondition(userKeyNode, Read.class);\n+            semanticScope.putDecoration(userKeyNode, new TargetType(def.class));\n+            semanticScope.setCondition(userKeyNode, Internal.class);\n+            checkedVisit(userKeyNode, semanticScope);\n+            decorateWithCast(userKeyNode, semanticScope);\n+\n+            AExpression userValueNode = userValueNodes.get(i);\n+            semanticScope.setCondition(userValueNode, Read.class);\n+            semanticScope.putDecoration(userValueNode, new TargetType(def.class));\n+            semanticScope.setCondition(userValueNode, Internal.class);\n+            checkedVisit(userValueNode, semanticScope);\n+            decorateWithCast(userValueNode, semanticScope);\n+        }\n+\n+        semanticScope.putDecoration(userMapInitNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitNewArray(ENewArray userNewArrayNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(userNewArrayNode, Write.class)) {\n+            throw userNewArrayNode.createError(new IllegalArgumentException(\"invalid assignment: cannot assign a value to new array\"));\n+        }\n+\n+        if (semanticScope.getCondition(userNewArrayNode, Read.class) == false) {\n+            throw userNewArrayNode.createError(new IllegalArgumentException(\"not a statement: result not used from new array\"));\n+        }\n+\n+        String canonicalTypeName = userNewArrayNode.getCanonicalTypeName();\n+        Class<?> valueType = semanticScope.getScriptScope().getPainlessLookup().canonicalTypeNameToType(canonicalTypeName);\n+\n+        if (valueType == null) {\n+            throw userNewArrayNode.createError(new IllegalArgumentException(\"Not a type [\" + canonicalTypeName + \"].\"));\n+        }\n+\n+        for (AExpression userValueNode : userNewArrayNode.getValueNodes()) {\n+            semanticScope.setCondition(userValueNode, Read.class);\n+            semanticScope.putDecoration(userValueNode,\n+                    new TargetType(userNewArrayNode.isInitializer() ? valueType.getComponentType() : int.class));\n+            semanticScope.setCondition(userValueNode, Internal.class);\n+            checkedVisit(userValueNode, semanticScope);\n+            decorateWithCast(userValueNode, semanticScope);\n+        }\n+\n+        semanticScope.putDecoration(userNewArrayNode, new ValueType(valueType));\n+    }\n+\n+    @Override\n+    public void visitNewObj(ENewObj userNewObjNode, SemanticScope semanticScope) {\n+        String canonicalTypeName =  userNewObjNode.getCanonicalTypeName();\n+        List<AExpression> userArgumentNodes = userNewObjNode.getArgumentNodes();\n+        int userArgumentsSize = userArgumentNodes.size();\n+\n+        if (semanticScope.getCondition(userNewObjNode, Write.class)) {\n+            throw userNewObjNode.createError(new IllegalArgumentException(\n+                    \"invalid assignment cannot assign a value to new object with constructor \" +\n+                            \"[\" + canonicalTypeName + \"/\" + userArgumentsSize + \"]\"));\n+        }\n+\n+        ScriptScope scriptScope = semanticScope.getScriptScope();\n+        Class<?> valueType = scriptScope.getPainlessLookup().canonicalTypeNameToType(canonicalTypeName);\n+\n+        if (valueType == null) {\n+            throw userNewObjNode.createError(new IllegalArgumentException(\"Not a type [\" + canonicalTypeName + \"].\"));\n+        }\n+\n+        PainlessConstructor constructor = scriptScope.getPainlessLookup().lookupPainlessConstructor(valueType, userArgumentsSize);\n+\n+        if (constructor == null) {\n+            throw userNewObjNode.createError(new IllegalArgumentException(\n+                    \"constructor [\" + typeToCanonicalTypeName(valueType) + \", <init>/\" + userArgumentsSize + \"] not found\"));\n+        }\n+\n+        scriptScope.putDecoration(userNewObjNode, new StandardPainlessConstructor(constructor));\n+        scriptScope.markNonDeterministic(constructor.annotations.containsKey(NonDeterministicAnnotation.class));\n+\n+        Class<?>[] types = new Class<?>[constructor.typeParameters.size()];\n+        constructor.typeParameters.toArray(types);\n+\n+        if (constructor.typeParameters.size() != userArgumentsSize) {\n+            throw userNewObjNode.createError(new IllegalArgumentException(\n+                    \"When calling constructor on type [\" + PainlessLookupUtility.typeToCanonicalTypeName(valueType) + \"] \" +\n+                            \"expected [\" + constructor.typeParameters.size() + \"] arguments, but found [\" + userArgumentsSize + \"].\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a727d2bc0ad6d8b769848d7e37e5e1847da7d77"}, "originalPosition": 1575}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0MzI3NTYx", "url": "https://github.com/elastic/elasticsearch/pull/59797#pullrequestreview-454327561", "createdAt": "2020-07-23T17:00:44Z", "commit": {"oid": "7a727d2bc0ad6d8b769848d7e37e5e1847da7d77"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzowMDo0NFrOG2Tfmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzowMDo0NFrOG2Tfmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU5NTY3NA==", "bodyText": "Why is this different in DefaultSemanticAnalysisPhase?  Is it just the changes to use decorations?", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r459595674", "createdAt": "2020-07-23T17:00:44Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EUnary.java", "diffHunk": "@@ -68,90 +57,4 @@ public Operation getOperation() {\n     public <Scope> void visitChildren(UserTreeVisitor<Scope> userTreeVisitor, Scope scope) {\n         childNode.visit(userTreeVisitor, scope);\n     }\n-\n-    @Override\n-    void analyze(SemanticScope semanticScope) {\n-        if (semanticScope.getCondition(this, Write.class)) {\n-            throw createError(new IllegalArgumentException(\n-                    \"invalid assignment: cannot assign a value to \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n-        }\n-\n-        if (semanticScope.getCondition(this, Read.class) == false) {\n-            throw createError(new IllegalArgumentException(\n-                    \"not a statement: result not used from \" + operation.name + \" operation \" + \"[\" + operation.symbol + \"]\"));\n-        }\n-\n-        Class<?> valueType;\n-        Class<?> promote = null;\n-\n-        if ((operation == Operation.SUB || operation == Operation.ADD) &&\n-                (childNode instanceof ENumeric || childNode instanceof EDecimal)) {\n-            semanticScope.setCondition(childNode, Read.class);\n-            semanticScope.copyDecoration(this, childNode, TargetType.class);\n-            semanticScope.replicateCondition(this, childNode, Explicit.class);\n-            semanticScope.replicateCondition(this, childNode, Internal.class);\n-\n-            if (childNode instanceof ENumeric) {\n-                ENumeric numeric = (ENumeric)childNode;\n-\n-                if (operation == Operation.SUB) {\n-                    numeric.analyze(semanticScope, numeric.getNumeric().charAt(0) != '-');\n-                } else {\n-                    childNode.analyze(semanticScope);\n-                }\n-            } else if (childNode instanceof EDecimal) {\n-                EDecimal decimal = (EDecimal)childNode;\n-\n-                if (operation == Operation.SUB) {\n-                    decimal.analyze(semanticScope, decimal.getDecimal().charAt(0) != '-');\n-                } else {\n-                    childNode.analyze(semanticScope);\n-                }\n-            } else {\n-                throw createError(new IllegalArgumentException(\"illegal tree structure\"));\n-            }\n-\n-            valueType = semanticScope.getDecoration(childNode, ValueType.class).getValueType();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a727d2bc0ad6d8b769848d7e37e5e1847da7d77"}, "originalPosition": 68}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0MzMxNTUy", "url": "https://github.com/elastic/elasticsearch/pull/59797#pullrequestreview-454331552", "createdAt": "2020-07-23T17:05:58Z", "commit": {"oid": "7a727d2bc0ad6d8b769848d7e37e5e1847da7d77"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzowNTo1OFrOG2TrcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzowNTo1OFrOG2TrcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU5ODcwNQ==", "bodyText": "Where did this cast move to in DefaultSemanticAnalysisPhase?", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r459598705", "createdAt": "2020-07-23T17:05:58Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SExpression.java", "diffHunk": "@@ -57,35 +48,6 @@ public AExpression getExpressionNode() {\n \n     @Override\n     public <Scope> void visitChildren(UserTreeVisitor<Scope> userTreeVisitor, Scope scope) {\n-        expressionNode.visit(userTreeVisitor, scope);\n-    }\n-\n-    @Override\n-    void analyze(SemanticScope semanticScope) {\n-        Class<?> rtnType = semanticScope.getReturnType();\n-        boolean isVoid = rtnType == void.class;\n-        boolean lastSource = semanticScope.getCondition(this, LastSource.class);\n-\n-        if (lastSource && !isVoid) {\n-            semanticScope.setCondition(expressionNode, Read.class);\n-        }\n-\n-        AExpression.analyze(expressionNode, semanticScope);\n-        Class<?> expressionValueType = semanticScope.getDecoration(expressionNode, ValueType.class).getValueType();\n-\n-        boolean rtn = lastSource && isVoid == false && expressionValueType != void.class;\n-        semanticScope.putDecoration(expressionNode, new TargetType(rtn ? rtnType : expressionValueType));\n-\n-        if (rtn) {\n-            semanticScope.setCondition(expressionNode, Internal.class);\n-        }\n-\n-        expressionNode.cast(semanticScope);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a727d2bc0ad6d8b769848d7e37e5e1847da7d77"}, "originalPosition": 65}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0MzMzMTY5", "url": "https://github.com/elastic/elasticsearch/pull/59797#pullrequestreview-454333169", "createdAt": "2020-07-23T17:08:06Z", "commit": {"oid": "7a727d2bc0ad6d8b769848d7e37e5e1847da7d77"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzowODowNlrOG2TwKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzowODowNlrOG2TwKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU5OTkxNQ==", "bodyText": "Line these conditions up.", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r459599915", "createdAt": "2020-07-23T17:08:06Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/phase/DefaultSemanticAnalysisPhase.java", "diffHunk": "@@ -0,0 +1,2728 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.phase;\n+\n+import org.elasticsearch.painless.AnalyzerCaster;\n+import org.elasticsearch.painless.FunctionRef;\n+import org.elasticsearch.painless.Location;\n+import org.elasticsearch.painless.Operation;\n+import org.elasticsearch.painless.lookup.PainlessCast;\n+import org.elasticsearch.painless.lookup.PainlessClassBinding;\n+import org.elasticsearch.painless.lookup.PainlessConstructor;\n+import org.elasticsearch.painless.lookup.PainlessField;\n+import org.elasticsearch.painless.lookup.PainlessInstanceBinding;\n+import org.elasticsearch.painless.lookup.PainlessLookupUtility;\n+import org.elasticsearch.painless.lookup.PainlessMethod;\n+import org.elasticsearch.painless.lookup.def;\n+import org.elasticsearch.painless.node.AExpression;\n+import org.elasticsearch.painless.node.ANode;\n+import org.elasticsearch.painless.node.AStatement;\n+import org.elasticsearch.painless.node.EAssignment;\n+import org.elasticsearch.painless.node.EBinary;\n+import org.elasticsearch.painless.node.EBooleanComp;\n+import org.elasticsearch.painless.node.EBooleanConstant;\n+import org.elasticsearch.painless.node.EBrace;\n+import org.elasticsearch.painless.node.ECall;\n+import org.elasticsearch.painless.node.ECallLocal;\n+import org.elasticsearch.painless.node.EComp;\n+import org.elasticsearch.painless.node.EConditional;\n+import org.elasticsearch.painless.node.EDecimal;\n+import org.elasticsearch.painless.node.EDot;\n+import org.elasticsearch.painless.node.EElvis;\n+import org.elasticsearch.painless.node.EExplicit;\n+import org.elasticsearch.painless.node.EFunctionRef;\n+import org.elasticsearch.painless.node.EInstanceof;\n+import org.elasticsearch.painless.node.ELambda;\n+import org.elasticsearch.painless.node.EListInit;\n+import org.elasticsearch.painless.node.EMapInit;\n+import org.elasticsearch.painless.node.ENewArray;\n+import org.elasticsearch.painless.node.ENewArrayFunctionRef;\n+import org.elasticsearch.painless.node.ENewObj;\n+import org.elasticsearch.painless.node.ENull;\n+import org.elasticsearch.painless.node.ENumeric;\n+import org.elasticsearch.painless.node.ERegex;\n+import org.elasticsearch.painless.node.EString;\n+import org.elasticsearch.painless.node.ESymbol;\n+import org.elasticsearch.painless.node.EUnary;\n+import org.elasticsearch.painless.node.SBlock;\n+import org.elasticsearch.painless.node.SBreak;\n+import org.elasticsearch.painless.node.SCatch;\n+import org.elasticsearch.painless.node.SClass;\n+import org.elasticsearch.painless.node.SContinue;\n+import org.elasticsearch.painless.node.SDeclBlock;\n+import org.elasticsearch.painless.node.SDeclaration;\n+import org.elasticsearch.painless.node.SDo;\n+import org.elasticsearch.painless.node.SEach;\n+import org.elasticsearch.painless.node.SExpression;\n+import org.elasticsearch.painless.node.SFor;\n+import org.elasticsearch.painless.node.SFunction;\n+import org.elasticsearch.painless.node.SIf;\n+import org.elasticsearch.painless.node.SIfElse;\n+import org.elasticsearch.painless.node.SReturn;\n+import org.elasticsearch.painless.node.SThrow;\n+import org.elasticsearch.painless.node.STry;\n+import org.elasticsearch.painless.node.SWhile;\n+import org.elasticsearch.painless.spi.annotation.NonDeterministicAnnotation;\n+import org.elasticsearch.painless.symbol.Decorations;\n+import org.elasticsearch.painless.symbol.Decorations.AllEscape;\n+import org.elasticsearch.painless.symbol.Decorations.AnyBreak;\n+import org.elasticsearch.painless.symbol.Decorations.AnyContinue;\n+import org.elasticsearch.painless.symbol.Decorations.BeginLoop;\n+import org.elasticsearch.painless.symbol.Decorations.BinaryType;\n+import org.elasticsearch.painless.symbol.Decorations.CapturesDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.ComparisonType;\n+import org.elasticsearch.painless.symbol.Decorations.CompoundType;\n+import org.elasticsearch.painless.symbol.Decorations.Concatenate;\n+import org.elasticsearch.painless.symbol.Decorations.ContinuousLoop;\n+import org.elasticsearch.painless.symbol.Decorations.DefOptimized;\n+import org.elasticsearch.painless.symbol.Decorations.DowncastPainlessCast;\n+import org.elasticsearch.painless.symbol.Decorations.EncodingDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.Explicit;\n+import org.elasticsearch.painless.symbol.Decorations.ExpressionPainlessCast;\n+import org.elasticsearch.painless.symbol.Decorations.GetterPainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.InLoop;\n+import org.elasticsearch.painless.symbol.Decorations.InstanceType;\n+import org.elasticsearch.painless.symbol.Decorations.Internal;\n+import org.elasticsearch.painless.symbol.Decorations.IterablePainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.LastLoop;\n+import org.elasticsearch.painless.symbol.Decorations.LastSource;\n+import org.elasticsearch.painless.symbol.Decorations.ListShortcut;\n+import org.elasticsearch.painless.symbol.Decorations.LoopEscape;\n+import org.elasticsearch.painless.symbol.Decorations.MapShortcut;\n+import org.elasticsearch.painless.symbol.Decorations.MethodEscape;\n+import org.elasticsearch.painless.symbol.Decorations.MethodNameDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.Negate;\n+import org.elasticsearch.painless.symbol.Decorations.ParameterNames;\n+import org.elasticsearch.painless.symbol.Decorations.PartialCanonicalTypeName;\n+import org.elasticsearch.painless.symbol.Decorations.Read;\n+import org.elasticsearch.painless.symbol.Decorations.ReferenceDecoration;\n+import org.elasticsearch.painless.symbol.Decorations.ReturnType;\n+import org.elasticsearch.painless.symbol.Decorations.SemanticVariable;\n+import org.elasticsearch.painless.symbol.Decorations.SetterPainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.ShiftType;\n+import org.elasticsearch.painless.symbol.Decorations.Shortcut;\n+import org.elasticsearch.painless.symbol.Decorations.StandardConstant;\n+import org.elasticsearch.painless.symbol.Decorations.StandardLocalFunction;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessClassBinding;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessConstructor;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessField;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessInstanceBinding;\n+import org.elasticsearch.painless.symbol.Decorations.StandardPainlessMethod;\n+import org.elasticsearch.painless.symbol.Decorations.StaticType;\n+import org.elasticsearch.painless.symbol.Decorations.TargetType;\n+import org.elasticsearch.painless.symbol.Decorations.TypeParameters;\n+import org.elasticsearch.painless.symbol.Decorations.UnaryType;\n+import org.elasticsearch.painless.symbol.Decorations.UpcastPainlessCast;\n+import org.elasticsearch.painless.symbol.Decorations.ValueType;\n+import org.elasticsearch.painless.symbol.Decorations.Write;\n+import org.elasticsearch.painless.symbol.FunctionTable;\n+import org.elasticsearch.painless.symbol.FunctionTable.LocalFunction;\n+import org.elasticsearch.painless.symbol.ScriptScope;\n+import org.elasticsearch.painless.symbol.SemanticScope;\n+import org.elasticsearch.painless.symbol.SemanticScope.FunctionScope;\n+import org.elasticsearch.painless.symbol.SemanticScope.LambdaScope;\n+import org.elasticsearch.painless.symbol.SemanticScope.Variable;\n+\n+import java.lang.reflect.Modifier;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+import java.util.regex.PatternSyntaxException;\n+\n+import static org.elasticsearch.painless.lookup.PainlessLookupUtility.typeToCanonicalTypeName;\n+import static org.elasticsearch.painless.symbol.SemanticScope.newFunctionScope;\n+\n+public class DefaultSemanticAnalysisPhase extends UserTreeBaseVisitor<SemanticScope> {\n+\n+    public void decorateWithCast(AExpression userExpressionNode, SemanticScope semanticScope) {\n+        Location location = userExpressionNode.getLocation();\n+        Class<?> valueType = semanticScope.getDecoration(userExpressionNode, ValueType.class).getValueType();\n+        Class<?> targetType = semanticScope.getDecoration(userExpressionNode, TargetType.class).getTargetType();\n+        boolean isExplicitCast = semanticScope.getCondition(userExpressionNode, Explicit.class);\n+        boolean isInternalCast = semanticScope.getCondition(userExpressionNode, Internal.class);\n+\n+        PainlessCast painlessCast = AnalyzerCaster.getLegalCast(location, valueType, targetType, isExplicitCast, isInternalCast);\n+\n+        if (painlessCast != null) {\n+            semanticScope.putDecoration(userExpressionNode, new ExpressionPainlessCast(painlessCast));\n+        }\n+    }\n+\n+    public void visit(ANode userNode, SemanticScope semanticScope) {\n+        if (userNode != null) {\n+            userNode.visit(this, semanticScope);\n+        }\n+    }\n+\n+    public void checkedVisit(AExpression userExpressionNode, SemanticScope semanticScope) {\n+        if (userExpressionNode != null) {\n+            userExpressionNode.visit(this, semanticScope);\n+\n+            if (semanticScope.hasDecoration(userExpressionNode, PartialCanonicalTypeName.class)) {\n+                throw userExpressionNode.createError(new IllegalArgumentException(\"cannot resolve symbol [\" +\n+                        semanticScope.getDecoration(userExpressionNode, PartialCanonicalTypeName.class).getPartialCanonicalTypeName() +\n+                        \"]\"));\n+            }\n+\n+            if (semanticScope.hasDecoration(userExpressionNode, StaticType.class)) {\n+                throw userExpressionNode.createError(new IllegalArgumentException(\"value required: instead found unexpected type \" +\n+                        \"[\" + semanticScope.getDecoration(userExpressionNode, StaticType.class).getStaticCanonicalTypeName() + \"]\"));\n+            }\n+\n+            if (semanticScope.hasDecoration(userExpressionNode, ValueType.class) == false) {\n+                throw userExpressionNode.createError(new IllegalStateException(\"value required: instead found no value\"));\n+            }\n+        }\n+    }\n+\n+    public void visitClass(SClass userClassNode, ScriptScope scriptScope) {\n+        for (SFunction userFunctionNode : userClassNode.getFunctionNodes()) {\n+            visitFunction(userFunctionNode, scriptScope);\n+        }\n+    }\n+\n+    public void visitFunction(SFunction userFunctionNode, ScriptScope scriptScope) {\n+        String functionName = userFunctionNode.getFunctionName();\n+        LocalFunction localFunction =\n+                scriptScope.getFunctionTable().getFunction(functionName, userFunctionNode.getCanonicalTypeNameParameters().size());\n+        Class<?> returnType = localFunction.getReturnType();\n+        List<Class<?>> typeParameters = localFunction.getTypeParameters();\n+        FunctionScope functionScope = newFunctionScope(scriptScope, localFunction.getReturnType());\n+\n+        for (int index = 0; index < localFunction.getTypeParameters().size(); ++index) {\n+            Class<?> typeParameter = localFunction.getTypeParameters().get(index);\n+            String parameterName = userFunctionNode.getParameterNames().get(index);\n+            functionScope.defineVariable(userFunctionNode.getLocation(), typeParameter, parameterName, false);\n+        }\n+\n+        SBlock userBlockNode = userFunctionNode.getBlockNode();\n+\n+        if (userBlockNode.getStatementNodes().isEmpty()) {\n+            throw userFunctionNode.createError(new IllegalArgumentException(\"invalid function definition: \" +\n+                    \"found no statements for function \" +\n+                    \"[\" + functionName + \"] with [\" + typeParameters.size() + \"] parameters\"));\n+        }\n+\n+        functionScope.setCondition(userBlockNode, LastSource.class);\n+        visit(userBlockNode, functionScope.newLocalScope());\n+        boolean methodEscape = functionScope.getCondition(userBlockNode, MethodEscape.class);\n+        boolean isAutoReturnEnabled = userFunctionNode.isAutoReturnEnabled();\n+\n+        if (methodEscape == false && isAutoReturnEnabled == false && returnType != void.class) {\n+            throw userFunctionNode.createError(new IllegalArgumentException(\"invalid function definition: \" +\n+                    \"not all paths provide a return value for function \" +\n+                    \"[\" + functionName + \"] with [\" + typeParameters.size() + \"] parameters\"));\n+        }\n+\n+        if (methodEscape) {\n+            functionScope.setCondition(userFunctionNode, MethodEscape.class);\n+        }\n+\n+        // TODO: do not specialize for execute\n+        // TODO: https://github.com/elastic/elasticsearch/issues/51841\n+        if (\"execute\".equals(functionName)) {\n+            scriptScope.setUsedVariables(functionScope.getUsedVariables());\n+        }\n+        // TODO: end\n+    }\n+\n+    @Override\n+    public void visitBlock(SBlock userBlockNode, SemanticScope semanticScope) {\n+        List<AStatement> userStatementNodes = userBlockNode.getStatementNodes();\n+\n+        if (userStatementNodes.isEmpty()) {\n+            throw userBlockNode.createError(new IllegalArgumentException(\"invalid block: found no statements\"));\n+        }\n+\n+        AStatement lastUserStatement = userStatementNodes.get(userStatementNodes.size() - 1);\n+\n+        boolean lastSource = semanticScope.getCondition(userBlockNode, LastSource.class);\n+        boolean beginLoop = semanticScope.getCondition(userBlockNode, BeginLoop.class);\n+        boolean inLoop = semanticScope.getCondition(userBlockNode, InLoop.class);\n+        boolean lastLoop = semanticScope.getCondition(userBlockNode, LastLoop.class);\n+\n+        boolean allEscape;\n+        boolean anyContinue = false;\n+        boolean anyBreak = false;\n+\n+        for (AStatement userStatementNode : userStatementNodes) {\n+            if (inLoop) {\n+                semanticScope.setCondition(userStatementNode, InLoop.class);\n+            }\n+\n+            if (userStatementNode == lastUserStatement) {\n+                if (beginLoop || lastLoop) {\n+                    semanticScope.setCondition(userStatementNode, LastLoop.class);\n+                }\n+\n+                if (lastSource) {\n+                    semanticScope.setCondition(userStatementNode, LastSource.class);\n+                }\n+            }\n+\n+            visit(userStatementNode, semanticScope);\n+            allEscape = semanticScope.getCondition(userStatementNode, AllEscape.class);\n+\n+            if (userStatementNode == lastUserStatement) {\n+                semanticScope.replicateCondition(userStatementNode, userBlockNode, MethodEscape.class);\n+                semanticScope.replicateCondition(userStatementNode, userBlockNode, LoopEscape.class);\n+\n+                if (allEscape) {\n+                    semanticScope.setCondition(userStatementNode, AllEscape.class);\n+                }\n+            } else {\n+                if (allEscape) {\n+                    throw userBlockNode.createError(new IllegalArgumentException(\"invalid block: unreachable statement\"));\n+                }\n+            }\n+\n+            anyContinue |= semanticScope.getCondition(userStatementNode, AnyContinue.class);\n+            anyBreak |= semanticScope.getCondition(userStatementNode, AnyBreak.class);\n+        }\n+\n+        if (anyContinue) {\n+            semanticScope.setCondition(userBlockNode, AnyContinue.class);\n+        }\n+\n+        if (anyBreak) {\n+            semanticScope.setCondition(userBlockNode, AnyBreak.class);\n+        }\n+    }\n+\n+    @Override\n+    public void visitIf(SIf userIfNode, SemanticScope semanticScope) {\n+        AExpression userConditionNode = userIfNode.getConditionNode();\n+        semanticScope.setCondition(userConditionNode, Read.class);\n+        semanticScope.putDecoration(userConditionNode, new TargetType(boolean.class));\n+        checkedVisit(userConditionNode, semanticScope);\n+        decorateWithCast(userConditionNode, semanticScope);\n+\n+        SBlock userIfBlockNode = userIfNode.getIfBlockNode();\n+\n+        if (userConditionNode instanceof EBooleanConstant || userIfBlockNode == null) {\n+            throw userIfNode.createError(new IllegalArgumentException(\"extraneous if block\"));\n+        }\n+\n+        semanticScope.replicateCondition(userIfNode, userIfBlockNode, LastSource.class);\n+        semanticScope.replicateCondition(userIfNode, userIfBlockNode, InLoop.class);\n+        semanticScope.replicateCondition(userIfNode, userIfBlockNode, LastLoop.class);\n+        visit(userIfBlockNode, semanticScope.newLocalScope());\n+        semanticScope.replicateCondition(userIfBlockNode, userIfNode, AnyContinue.class);\n+        semanticScope.replicateCondition(userIfBlockNode, userIfNode, AnyBreak.class);\n+    }\n+\n+    @Override\n+    public void visitIfElse(SIfElse userIfElseNode, SemanticScope semanticScope) {\n+        AExpression userConditionNode = userIfElseNode.getConditionNode();\n+        semanticScope.setCondition(userConditionNode, Read.class);\n+        semanticScope.putDecoration(userConditionNode, new TargetType(boolean.class));\n+        checkedVisit(userConditionNode, semanticScope);\n+        decorateWithCast(userConditionNode, semanticScope);\n+\n+        SBlock userIfBlockNode = userIfElseNode.getIfBlockNode();\n+\n+        if (userConditionNode instanceof EBooleanConstant || userIfBlockNode == null) {\n+            throw userIfElseNode.createError(new IllegalArgumentException(\"extraneous if block\"));\n+        }\n+\n+        semanticScope.replicateCondition(userIfElseNode, userIfBlockNode, LastSource.class);\n+        semanticScope.replicateCondition(userIfElseNode, userIfBlockNode, InLoop.class);\n+        semanticScope.replicateCondition(userIfElseNode, userIfBlockNode, LastLoop.class);\n+        visit(userIfBlockNode, semanticScope.newLocalScope());\n+\n+        SBlock userElseBlockNode = userIfElseNode.getElseBlockNode();\n+\n+        if (userElseBlockNode == null) {\n+            throw userIfElseNode.createError(new IllegalArgumentException(\"extraneous else block.\"));\n+        }\n+\n+        semanticScope.replicateCondition(userIfElseNode, userElseBlockNode, LastSource.class);\n+        semanticScope.replicateCondition(userIfElseNode, userElseBlockNode, InLoop.class);\n+        semanticScope.replicateCondition(userIfElseNode, userElseBlockNode, LastLoop.class);\n+        visit(userElseBlockNode, semanticScope.newLocalScope());\n+\n+        if (semanticScope.getCondition(userIfBlockNode, MethodEscape.class) &&\n+                semanticScope.getCondition(userElseBlockNode, MethodEscape.class)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a727d2bc0ad6d8b769848d7e37e5e1847da7d77"}, "originalPosition": 366}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0MzM1NjA3", "url": "https://github.com/elastic/elasticsearch/pull/59797#pullrequestreview-454335607", "createdAt": "2020-07-23T17:11:20Z", "commit": {"oid": "7a727d2bc0ad6d8b769848d7e37e5e1847da7d77"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzoxMToyMFrOG2T3kg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzoxMToyMFrOG2T3kg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYwMTgxMA==", "bodyText": "Why'd this message change?", "url": "https://github.com/elastic/elasticsearch/pull/59797#discussion_r459601810", "createdAt": "2020-07-23T17:11:20Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/yamlRestTest/resources/rest-api-spec/test/painless/20_scriptfield.yml", "diffHunk": "@@ -151,6 +151,6 @@ setup:\n     - match: { error.type: \"search_phase_execution_exception\" }\n     - match: { error.reason: \"all shards failed\" }\n     - match: { error.failed_shards.0.reason.caused_by.type: \"illegal_argument_exception\" }\n-    - match: { error.failed_shards.0.reason.caused_by.reason: \"While loop has no escape.\" }\n+    - match: { error.failed_shards.0.reason.caused_by.reason: \"no paths escape from while loop\" }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a727d2bc0ad6d8b769848d7e37e5e1847da7d77"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b53b318e950ac59d92fb80bccf2cf895bc026e94", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/b53b318e950ac59d92fb80bccf2cf895bc026e94", "committedDate": "2020-07-23T17:50:57Z", "message": "response to pr comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c79b2494389347f46202c48176b635b8dbfbb3f7", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/c79b2494389347f46202c48176b635b8dbfbb3f7", "committedDate": "2020-07-23T17:54:51Z", "message": "regen antlr to unedited"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "89abb7eca8ecc760f8bc900440be3f3ac3a5a58c", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/89abb7eca8ecc760f8bc900440be3f3ac3a5a58c", "committedDate": "2020-07-23T18:02:00Z", "message": "realign if/else statements"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0Mzc0NTIz", "url": "https://github.com/elastic/elasticsearch/pull/59797#pullrequestreview-454374523", "createdAt": "2020-07-23T18:04:16Z", "commit": {"oid": "c79b2494389347f46202c48176b635b8dbfbb3f7"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "57f5699ed257b3df9e44a03ba37809abee76fb32", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/57f5699ed257b3df9e44a03ba37809abee76fb32", "committedDate": "2020-07-27T15:18:24Z", "message": "Merge branch 'master' into semantic7"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f1772c6afdf3d8b3d98eb397f3739f270ea1d1a1", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/f1772c6afdf3d8b3d98eb397f3739f270ea1d1a1", "committedDate": "2020-07-27T16:49:16Z", "message": "added basic comments to each public method for\nDefaultSemanticAnalysisPhase"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eac1d61e41717df51b42edf65cbd1570a2a46663", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/eac1d61e41717df51b42edf65cbd1570a2a46663", "committedDate": "2020-03-27T23:55:26Z", "message": "remove statement, use read instead"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "082e94b4a590591196625bad85750d2fcbc4f551", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/082e94b4a590591196625bad85750d2fcbc4f551", "committedDate": "2020-03-30T16:27:34Z", "message": "add tests for not a statement"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d6ca6a35cfeb2f5b8689b7258bb19eda858c03bf", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/d6ca6a35cfeb2f5b8689b7258bb19eda858c03bf", "committedDate": "2020-03-30T16:51:01Z", "message": "Merge branch 'master' into nodes0"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4459ee9a8029edd7c995865bd3202830def8097c", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/4459ee9a8029edd7c995865bd3202830def8097c", "committedDate": "2020-03-30T19:02:43Z", "message": "move isDefOptimized to output instead of as mutable state on the nodes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1eb0a513f54a2abc3a4d90877d43297a246e7dac", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/1eb0a513f54a2abc3a4d90877d43297a246e7dac", "committedDate": "2020-03-30T19:05:32Z", "message": "Merge branch 'master' into nodes0"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "372ec631791fceda73c22bb1dfbba176aeba7c1f", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/372ec631791fceda73c22bb1dfbba176aeba7c1f", "committedDate": "2020-03-30T19:05:58Z", "message": "Merge branch 'nodes0' into nodes1"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "99c54f190497586547ab073b41a0c5d39d89b5fd", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/99c54f190497586547ab073b41a0c5d39d89b5fd", "committedDate": "2020-03-30T20:18:46Z", "message": "remove AStoreable and give individual nodes responsibility to check\nwrite"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2eceff4ba180840b185ae834b963c9b7ae1f58bc", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/2eceff4ba180840b185ae834b963c9b7ae1f58bc", "committedDate": "2020-03-30T22:18:14Z", "message": "clean up write messages and add tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "78961f80bef311dfa557dd0288dec8a7a1564be6", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/78961f80bef311dfa557dd0288dec8a7a1564be6", "committedDate": "2020-03-30T22:57:27Z", "message": "elimate extraneous new array function reference ir node"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7a3a3870e6443c2cfa2cdf9a3e0920977daaaf82", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/7a3a3870e6443c2cfa2cdf9a3e0920977daaaf82", "committedDate": "2020-03-31T20:07:52Z", "message": "switch ir function ref nodes to different types"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "791eca3b0d29f37c9d84fd196fb03618d33b8606", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/791eca3b0d29f37c9d84fd196fb03618d33b8606", "committedDate": "2020-03-31T20:45:25Z", "message": "remove ILambda in favor of ir tree calculating def method call recipe"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e77796275a7bf20572efb4dd1610e26ad0adefe1", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/e77796275a7bf20572efb4dd1610e26ad0adefe1", "committedDate": "2020-03-31T22:52:45Z", "message": "remove sub nodes from user tree"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0eba55c612cfbc1b967b0cd1e2e99fa01b53ec6e", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/0eba55c612cfbc1b967b0cd1e2e99fa01b53ec6e", "committedDate": "2020-04-01T22:20:46Z", "message": "remove PainlessCast from output as it's completely local"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8d0ac605207b4fd8fb38942de0e7831dd2dfce9e", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/8d0ac605207b4fd8fb38942de0e7831dd2dfce9e", "committedDate": "2020-04-02T23:59:28Z", "message": "partially removed type from lexer"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "38c15bc41853f468504d1e6517aa78f8d528e4a6", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/38c15bc41853f468504d1e6517aa78f8d528e4a6", "committedDate": "2020-04-03T23:19:27Z", "message": "removed ambiguity in parsing related to casting versus binary"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3bfed8d6631a604e3da06aa734be4a50ee7c078b", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/3bfed8d6631a604e3da06aa734be4a50ee7c078b", "committedDate": "2020-04-04T00:42:02Z", "message": "handle negation in the user tree instead of relying on the walker"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f8235dfa22a5e02193bc45b12f35b18eb08df896", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/f8235dfa22a5e02193bc45b12f35b18eb08df896", "committedDate": "2020-04-06T20:57:57Z", "message": "lexer hack completely removed"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "94b6c80f963c042dae95604d3c6b469fff10d9ac", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/94b6c80f963c042dae95604d3c6b469fff10d9ac", "committedDate": "2020-04-08T17:03:44Z", "message": "Merge branch 'master' into nodes0"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e7af841e35bcd8d4f845f54ffb082d3d201a51b4", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/e7af841e35bcd8d4f845f54ffb082d3d201a51b4", "committedDate": "2020-04-08T17:03:54Z", "message": "Merge branch 'nodes0' into nodes1"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "97549c8d5b65a1c97a361a9fb8fa30bdab0ea6db", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/97549c8d5b65a1c97a361a9fb8fa30bdab0ea6db", "committedDate": "2020-04-08T17:24:14Z", "message": "Merge branch 'nodes1' into nodes2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "68cd9273b01b4d9a5b27546c3a61862dd7c424b4", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/68cd9273b01b4d9a5b27546c3a61862dd7c424b4", "committedDate": "2020-04-08T17:26:09Z", "message": "Merge branch 'nodes2' into nodes3"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "112048c228d27db7920c45d54c504965bf273be5", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/112048c228d27db7920c45d54c504965bf273be5", "committedDate": "2020-04-08T17:29:05Z", "message": "Merge branch 'nodes3' into nodes4"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5669498608729c5633e15b53142b0126e9d2e2c7", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/5669498608729c5633e15b53142b0126e9d2e2c7", "committedDate": "2020-04-08T17:30:40Z", "message": "Merge branch 'nodes4' into nodes5"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "56b43370baaac38d98593a92fe96fb063c5b0585", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/56b43370baaac38d98593a92fe96fb063c5b0585", "committedDate": "2020-04-08T19:23:30Z", "message": "add javadocs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1f6bf2f30cb90de1e386f96326ea146435e73921", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/1f6bf2f30cb90de1e386f96326ea146435e73921", "committedDate": "2020-04-08T22:16:30Z", "message": "add guards for invalid static values"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "50fc23b95ff6254430cbe5b1fe3382ebed451752", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/50fc23b95ff6254430cbe5b1fe3382ebed451752", "committedDate": "2020-04-09T20:56:43Z", "message": "add partial types tests and not a symbol tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1b61f58c3a9fbbd924eaa7647d96b9541d4e9919", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/1b61f58c3a9fbbd924eaa7647d96b9541d4e9919", "committedDate": "2020-04-09T21:50:23Z", "message": "add tests for valid static types"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "07b1efe9f647668e41a4121ab987968d1ba7b425", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/07b1efe9f647668e41a4121ab987968d1ba7b425", "committedDate": "2020-04-09T23:33:29Z", "message": "add precedence node to handle final lexer hack removal path"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "251ff50fcac2ded70f1026560cf7cb67d1e86c28", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/251ff50fcac2ded70f1026560cf7cb67d1e86c28", "committedDate": "2020-04-10T15:30:43Z", "message": "Merge branch 'master' into nodes1"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "198fa475e180a169ca1911734d49096dbaf4a1f3", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/198fa475e180a169ca1911734d49096dbaf4a1f3", "committedDate": "2020-04-10T15:36:40Z", "message": "Merge branch 'nodes1' into nodes2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dd82b5f86711cb8d99c686d9fa21ddb035e84880", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/dd82b5f86711cb8d99c686d9fa21ddb035e84880", "committedDate": "2020-04-10T15:40:21Z", "message": "Merge branch 'nodes2' into nodes3"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "87cafb387bc0f8096d3b7929b1d5186c481fdb39", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/87cafb387bc0f8096d3b7929b1d5186c481fdb39", "committedDate": "2020-04-10T15:42:14Z", "message": "Merge branch 'nodes3' into nodes4"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c466828680319beea3cc0087cfbf0ba73e5010eb", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/c466828680319beea3cc0087cfbf0ba73e5010eb", "committedDate": "2020-04-10T15:44:06Z", "message": "Merge branch 'nodes4' into nodes5"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e60482addcf51170606e74a6c0870481b705f14e", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/e60482addcf51170606e74a6c0870481b705f14e", "committedDate": "2020-04-10T18:35:21Z", "message": "move prefix into nodes its actually used in"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8c902dad68b1317b13097a4818d45f9fc1bed7a5", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/8c902dad68b1317b13097a4818d45f9fc1bed7a5", "committedDate": "2020-04-14T20:28:16Z", "message": "Use block instead of list of statements for Lambda"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a79f9b33ca1b8333d0e0b471c8c337674ca6f3f4", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/a79f9b33ca1b8333d0e0b471c8c337674ca6f3f4", "committedDate": "2020-04-14T23:12:20Z", "message": "Merge branch 'master' into nodes1"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4c93293c2ada3933550f1b64fa303a8785b7b328", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/4c93293c2ada3933550f1b64fa303a8785b7b328", "committedDate": "2020-04-14T23:12:46Z", "message": "Merge branch 'nodes1' into nodes2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "14079081e7c0e4fb365a4a48abef0aa16f0a9692", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/14079081e7c0e4fb365a4a48abef0aa16f0a9692", "committedDate": "2020-04-15T20:18:06Z", "message": "add primitive types to remove binary recognition of cast"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7a349b32470df4fa11b472acae915c8a5a63b5a2", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/7a349b32470df4fa11b472acae915c8a5a63b5a2", "committedDate": "2020-04-15T20:39:54Z", "message": "remove unnecessary nodes from EDot"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "68679c8c4249bc8af9b28b449b5695fa8816b0cf", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/68679c8c4249bc8af9b28b449b5695fa8816b0cf", "committedDate": "2020-04-15T20:58:15Z", "message": "remove precedence"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bb55509d9540c641e5f50e184bd4790153fbedea", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/bb55509d9540c641e5f50e184bd4790153fbedea", "committedDate": "2020-04-16T22:03:44Z", "message": "remove node creation in EUnary"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1de2751d9913ab8ebca868c727b759cbbb1c7b2a", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/1de2751d9913ab8ebca868c727b759cbbb1c7b2a", "committedDate": "2020-04-16T22:31:34Z", "message": "remove remaining node instantiations within the semantic pass"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e991a4ea8ad596fcb7eddece58a977cb8e353d7c", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/e991a4ea8ad596fcb7eddece58a977cb8e353d7c", "committedDate": "2020-04-16T23:58:30Z", "message": "partial first pass of cleaning up members of user tree nodes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "99b541f1f495fdfd0a0973e76395a00e17eb0091", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/99b541f1f495fdfd0a0973e76395a00e17eb0091", "committedDate": "2020-04-17T19:48:27Z", "message": "clean up more nodes members"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "82476866eaff495a3b21e88f5807db838704ca97", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/82476866eaff495a3b21e88f5807db838704ca97", "committedDate": "2020-04-17T20:49:16Z", "message": "setup user nodes for external pass by making members private w/ getters"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "85e1f8a498f19d824cb68ab5debfc3ba60177e8c", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/85e1f8a498f19d824cb68ab5debfc3ba60177e8c", "committedDate": "2020-04-17T21:36:56Z", "message": "name changes Scope to SemanticScope, ScriptRoot to ScriptScope"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2e37afe020fb8fc695b4f409dfe3e436db93c9a3", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/2e37afe020fb8fc695b4f409dfe3e436db93c9a3", "committedDate": "2020-04-17T21:40:21Z", "message": "fix typo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d320ced583d94e5418ded9e5b71597c37c88d6dd", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/d320ced583d94e5418ded9e5b71597c37c88d6dd", "committedDate": "2020-04-17T22:14:57Z", "message": "move ScriptScope into SemanticScope"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b59eeea1b6c89921ca748f86ecafc76ba4bd627f", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/b59eeea1b6c89921ca748f86ecafc76ba4bd627f", "committedDate": "2020-04-17T22:19:29Z", "message": "remove EConstant"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c3f8c8c8cacccaa5defd6c8480b7e62b8a20b21a", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/c3f8c8c8cacccaa5defd6c8480b7e62b8a20b21a", "committedDate": "2020-04-17T23:03:16Z", "message": "remove DType nodes and remove SDeclaration from SCatch"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b4c096235d00f02c4d6fa2aad72cf05db45ced23", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/b4c096235d00f02c4d6fa2aad72cf05db45ced23", "committedDate": "2020-04-18T00:38:57Z", "message": "add decorators for semantic pass"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9ccfaeb99d980d7ab6c14b6927134f8077197f60", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/9ccfaeb99d980d7ab6c14b6927134f8077197f60", "committedDate": "2020-04-18T16:15:00Z", "message": "partially add decoration for output.actual"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0095dbcc4cd53ba80364ea0ca345aea81fd34bfe", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/0095dbcc4cd53ba80364ea0ca345aea81fd34bfe", "committedDate": "2020-04-18T17:42:39Z", "message": "finish converting output.actual to decorator value"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "71e457d8dd55ca485bc6d247ac9133d8112133df", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/71e457d8dd55ca485bc6d247ac9133d8112133df", "committedDate": "2020-04-18T19:03:33Z", "message": "fix value type decorations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e2a9866b8eede31d25c086351ac282d926d39c14", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/e2a9866b8eede31d25c086351ac282d926d39c14", "committedDate": "2020-04-18T19:34:32Z", "message": "rename scopetable to writescope"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d30f595bcdb4d29569ab4cc918630e07459ba9b9", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/d30f595bcdb4d29569ab4cc918630e07459ba9b9", "committedDate": "2020-04-18T19:48:51Z", "message": "add copy to decorator"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ec0411cc1891cbe54e8cc56d8f60c3e79068ef20", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/ec0411cc1891cbe54e8cc56d8f60c3e79068ef20", "committedDate": "2020-04-19T03:15:56Z", "message": "replace expression input with decoration"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "36d32f3bbb8e8c32c6d89b8101535f6071502d54", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/36d32f3bbb8e8c32c6d89b8101535f6071502d54", "committedDate": "2020-04-19T17:07:56Z", "message": "change expression output static type to be a decoration"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7244c21ff11ae59e5f611d71ad9c6c2ea2d86ced", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/7244c21ff11ae59e5f611d71ad9c6c2ea2d86ced", "committedDate": "2020-04-19T17:36:23Z", "message": "remove expression output except node"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2ea3183844713a178d0003adf53a467432c3aa2e", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/2ea3183844713a178d0003adf53a467432c3aa2e", "committedDate": "2020-04-19T17:58:19Z", "message": "replace user statement input with decorations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f974d8ff77ac9db1e735358fd9d786013ca62fcd", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/f974d8ff77ac9db1e735358fd9d786013ca62fcd", "committedDate": "2020-04-19T18:27:53Z", "message": "remove statement count from statement output"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fc463f80eb88ad4a85f8c500446ce1fd41376c40", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/fc463f80eb88ad4a85f8c500446ce1fd41376c40", "committedDate": "2020-04-19T19:52:42Z", "message": "switched statement output to decorations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2c68562a1e9e126f6579654024ff9b89821162a9", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/2c68562a1e9e126f6579654024ff9b89821162a9", "committedDate": "2020-04-19T20:54:34Z", "message": "start to convert ir tree building to an external phase"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "57baf7282a3126fd1b2324283c72ed4b4fd36a38", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/57baf7282a3126fd1b2324283c72ed4b4fd36a38", "committedDate": "2020-04-20T00:09:55Z", "message": "move all statement nodes to build ir tree"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3fc720dcc165911dafd1d73ce92883b9ad1407ed", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/3fc720dcc165911dafd1d73ce92883b9ad1407ed", "committedDate": "2020-04-21T03:45:19Z", "message": "completed transition of expression nodes to move ir building to separate\nphase"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "99cf8bc1d8b291fd75ab9b4c92fea594c07da602", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/99cf8bc1d8b291fd75ab9b4c92fea594c07da602", "committedDate": "2020-04-21T05:39:21Z", "message": "fixed tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c8076bfa4366e371aaba802a038db3c56ce43074", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/c8076bfa4366e371aaba802a038db3c56ce43074", "committedDate": "2020-04-21T14:51:10Z", "message": "Merge branch 'master' into nodes2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a4d34169a4724a4111cb30c9671e79798b64f3ef", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/a4d34169a4724a4111cb30c9671e79798b64f3ef", "committedDate": "2020-04-21T16:38:42Z", "message": "response to pr comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dafeaeb13af618684c04f0f5d38d509d4af92533", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/dafeaeb13af618684c04f0f5d38d509d4af92533", "committedDate": "2020-04-21T17:31:42Z", "message": "Merge branch 'master' into nodes2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ee2e19f11c6d3781eb420fc9c94d8bb1342d76a4", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/ee2e19f11c6d3781eb420fc9c94d8bb1342d76a4", "committedDate": "2020-04-21T17:32:33Z", "message": "Merge branch 'nodes2' into nodes3"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9f2cdd1d6db22e474db4a1664b28942f32b6e8d6", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/9f2cdd1d6db22e474db4a1664b28942f32b6e8d6", "committedDate": "2020-04-21T17:38:07Z", "message": "Merge branch 'nodes3' into nodes4"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3250d9eeb0a9c1532353d79fb3daceb74f941686", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/3250d9eeb0a9c1532353d79fb3daceb74f941686", "committedDate": "2020-04-21T17:44:40Z", "message": "Merge branch 'nodes4' into nodes5"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d965f14ba797d115a5e499178807bbc288e7136b", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/d965f14ba797d115a5e499178807bbc288e7136b", "committedDate": "2020-04-21T17:47:09Z", "message": "Merge branch 'nodes5' into nodes6"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "229f99c28164fe814514b26a412c191eae39de4c", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/229f99c28164fe814514b26a412c191eae39de4c", "committedDate": "2020-04-21T17:51:01Z", "message": "Merge branch 'nodes6' into semantic0"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b7216acce6e99edad979591605ac5efc2edb776b", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/b7216acce6e99edad979591605ac5efc2edb776b", "committedDate": "2020-04-21T17:52:46Z", "message": "Merge branch 'semantic0' into semantic1"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "888c90bff8bbedb73e769dea43c2db4c7312f387", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/888c90bff8bbedb73e769dea43c2db4c7312f387", "committedDate": "2020-04-21T17:57:54Z", "message": "Merge branch 'semantic1' into semantic2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8499779928eaabb98d618d9a31091f888d2ca38b", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/8499779928eaabb98d618d9a31091f888d2ca38b", "committedDate": "2020-04-21T18:00:16Z", "message": "Merge branch 'semantic2' into semantic3"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9dc9855f1053d088f1ba1687269e10fc87bea38c", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/9dc9855f1053d088f1ba1687269e10fc87bea38c", "committedDate": "2020-04-21T18:01:52Z", "message": "Merge branch 'semantic3' into semantic4"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "831d34262872b5a68c6ddb19343c4b8cf47e3201", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/831d34262872b5a68c6ddb19343c4b8cf47e3201", "committedDate": "2020-04-21T18:03:56Z", "message": "Merge branch 'semantic4' into semantic5"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac53464dbd37bd30c1ab1e97e2c704f3bafd9258", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/ac53464dbd37bd30c1ab1e97e2c704f3bafd9258", "committedDate": "2020-04-21T22:39:09Z", "message": "moved header generation to external phase"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6e12b999cd590edb968130cd5a8757e774a89e88", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/6e12b999cd590edb968130cd5a8757e774a89e88", "committedDate": "2020-04-22T21:13:15Z", "message": "move statement nodes to external pass format"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b2eaaba7d50a628620a659fe93959986270179fe", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/b2eaaba7d50a628620a659fe93959986270179fe", "committedDate": "2020-04-23T22:04:31Z", "message": "update user expression nodes to visitor pattern"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ecd7d428a5b5f127eca82d68b7f429492f278b8f", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/ecd7d428a5b5f127eca82d68b7f429492f278b8f", "committedDate": "2020-04-23T22:59:21Z", "message": "fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2d07ee67e79b3922b206c7132b260eb221aa6f98", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/2d07ee67e79b3922b206c7132b260eb221aa6f98", "committedDate": "2020-04-23T23:42:13Z", "message": "more fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a1ff4a0a9d2141722bffeb4d8b6fef3fc5e7addb", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/a1ff4a0a9d2141722bffeb4d8b6fef3fc5e7addb", "committedDate": "2020-04-24T14:26:04Z", "message": "Merge branch 'master' into nodes3"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1531a1e5ae9574fe54a26a63651c26c64391d733", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/1531a1e5ae9574fe54a26a63651c26c64391d733", "committedDate": "2020-04-24T14:34:07Z", "message": "Merge branch 'nodes3' into nodes4"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b16f828448b6416194d7bbbe4bb7f77808b9b62f", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/b16f828448b6416194d7bbbe4bb7f77808b9b62f", "committedDate": "2020-04-24T14:34:42Z", "message": "Merge branch 'nodes4' into nodes5"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cd139e2bf3de1f018a0659466066d7f2744a3f33", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/cd139e2bf3de1f018a0659466066d7f2744a3f33", "committedDate": "2020-04-24T14:34:59Z", "message": "Merge branch 'nodes5' into nodes6"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ca1febb58a3fb9b59d904a85ba27cef7b4ffb58a", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/ca1febb58a3fb9b59d904a85ba27cef7b4ffb58a", "committedDate": "2020-04-24T14:35:15Z", "message": "Merge branch 'nodes6' into semantic0"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7fd5ec24b8e903d2738a13c6c45856354aaa2364", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/7fd5ec24b8e903d2738a13c6c45856354aaa2364", "committedDate": "2020-04-24T14:35:25Z", "message": "Merge branch 'semantic0' into semantic1"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "69d9579a9de2797b04b0910fe18a36668777d778", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/69d9579a9de2797b04b0910fe18a36668777d778", "committedDate": "2020-04-24T14:35:35Z", "message": "Merge branch 'semantic1' into semantic2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2a0635de911f98cd66f0f1ddb15bc25beda5b34a", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/2a0635de911f98cd66f0f1ddb15bc25beda5b34a", "committedDate": "2020-04-24T14:35:53Z", "message": "Merge branch 'semantic2' into semantic3"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "edd3db7c4b6ee005dd814e3a5af8884962e2334b", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/edd3db7c4b6ee005dd814e3a5af8884962e2334b", "committedDate": "2020-04-24T14:36:04Z", "message": "Merge branch 'semantic3' into semantic4"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7428df991ac48815834122d254b9caa14988411b", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/7428df991ac48815834122d254b9caa14988411b", "committedDate": "2020-04-24T14:36:15Z", "message": "Merge branch 'semantic4' into semantic5"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a840eb2cafec3be2e6b00a3f96b8ef4dfd705784", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/a840eb2cafec3be2e6b00a3f96b8ef4dfd705784", "committedDate": "2020-04-24T14:36:35Z", "message": "Merge branch 'semantic5' into semantic6"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "147bd2a0a19dc0d346b34ddd3481437b868ee7ee", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/147bd2a0a19dc0d346b34ddd3481437b868ee7ee", "committedDate": "2020-04-24T14:36:54Z", "message": "Merge branch 'semantic6' into semantic7"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "64796ba9432bd5240d7bd1a9190503622d0af0ba", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/64796ba9432bd5240d7bd1a9190503622d0af0ba", "committedDate": "2020-04-29T20:36:52Z", "message": "Merge branch 'master' into nodes3"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "35a029e05a0b237f0de461efc33cb94992739614", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/35a029e05a0b237f0de461efc33cb94992739614", "committedDate": "2020-04-29T20:57:49Z", "message": "response to pr comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "948d6ecef2a5b02f15c90a96b35cbbaec9971720", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/948d6ecef2a5b02f15c90a96b35cbbaec9971720", "committedDate": "2020-04-29T21:49:47Z", "message": "Merge branch 'master' into nodes3"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5542b0f9fd649660bc36198b7d45161a8954794e", "author": {"user": {"login": "jdconrad", "name": "Jack Conradson"}}, "url": "https://github.com/elastic/elasticsearch/commit/5542b0f9fd649660bc36198b7d45161a8954794e", "committedDate": "2020-04-29T21:49:54Z", "message": "Merge branch 'nodes3' into nodes4"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4191, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}