{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY4NjY5NTU3", "number": 51632, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxMToxNjozMlrODb4SIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxMTo0MjoxNlrODb4tcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwNTYwMjg5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxMToxNjozMlrOFjnfmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQxMzowMTozMFrOFkKrag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg5MTU0Nw==", "bodyText": "1.0f", "url": "https://github.com/elastic/elasticsearch/pull/51632#discussion_r372891547", "createdAt": "2020-01-30T11:16:32Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java", "diffHunk": "@@ -408,12 +395,9 @@ private MoveDecision decideRebalance(final ShardRouting shard) {\n                     // more even, it doesn't make sense to execute the heavyweight operation of relocating a shard unless\n                     // the gains make it worth it, as defined by the threshold\n                     boolean deltaAboveThreshold = lessThan(currentDelta, threshold) == false;\n-                    // simulate the weight of the node if we were to relocate the shard to it\n-                    float weightWithShardAdded = weight.weightShardAdded(this, node, idxName);\n                     // calculate the delta of the weights of the two nodes if we were to add the shard to the\n                     // node in question and move it away from the node that currently holds it.\n-                    float proposedDelta = weightWithShardAdded - weight.weightShardRemoved(this, currentNode, idxName);\n-                    boolean betterWeightWithShardAdded = proposedDelta < currentDelta;\n+                    boolean betterWeightWithShardAdded = nodeWeight + 1 < currentWeight;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ffbbac3e8d0f9b568e54876ced522bc2933f6c4"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ2ODAxMA==", "bodyText": "\ud83d\udc4d 482be93", "url": "https://github.com/elastic/elasticsearch/pull/51632#discussion_r373468010", "createdAt": "2020-01-31T13:01:30Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java", "diffHunk": "@@ -408,12 +395,9 @@ private MoveDecision decideRebalance(final ShardRouting shard) {\n                     // more even, it doesn't make sense to execute the heavyweight operation of relocating a shard unless\n                     // the gains make it worth it, as defined by the threshold\n                     boolean deltaAboveThreshold = lessThan(currentDelta, threshold) == false;\n-                    // simulate the weight of the node if we were to relocate the shard to it\n-                    float weightWithShardAdded = weight.weightShardAdded(this, node, idxName);\n                     // calculate the delta of the weights of the two nodes if we were to add the shard to the\n                     // node in question and move it away from the node that currently holds it.\n-                    float proposedDelta = weightWithShardAdded - weight.weightShardRemoved(this, currentNode, idxName);\n-                    boolean betterWeightWithShardAdded = proposedDelta < currentDelta;\n+                    boolean betterWeightWithShardAdded = nodeWeight + 1 < currentWeight;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg5MTU0Nw=="}, "originalCommit": {"oid": "5ffbbac3e8d0f9b568e54876ced522bc2933f6c4"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwNTYwNjU3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxMToxNzo1OVrOFjnhuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQxMzowNjo1M1rOFkKzOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg5MjA4OA==", "bodyText": "perhaps just\nif (rebalanceDecision.type() == Type.NO) {\n  continue;\n}\n\nand the same for the allocationDecision below", "url": "https://github.com/elastic/elasticsearch/pull/51632#discussion_r372892088", "createdAt": "2020-01-30T11:17:59Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java", "diffHunk": "@@ -1000,30 +995,32 @@ private boolean tryRelocateShard(ModelNode minNode, ModelNode maxNode, String id\n                 }\n                 ShardRouting candidate = null;\n                 final AllocationDeciders deciders = allocation.deciders();\n+                final List<ShardRouting> shardRoutings = new ArrayList<>(index.numShards());\n                 for (ShardRouting shard : index) {\n                     if (shard.started()) {\n                         // skip initializing, unassigned and relocating shards we can't relocate them anyway\n-                        Decision allocationDecision = deciders.canAllocate(shard, minNode.getRoutingNode(), allocation);\n-                        Decision rebalanceDecision = deciders.canRebalance(shard, allocation);\n-                        if (((allocationDecision.type() == Type.YES) || (allocationDecision.type() == Type.THROTTLE))\n-                                && ((rebalanceDecision.type() == Type.YES) || (rebalanceDecision.type() == Type.THROTTLE))) {\n-                            if (maxNode.containsShard(shard)) {\n-                                // simulate moving shard from maxNode to minNode\n-                                final float delta = weight.weightShardAdded(\n-                                    this, minNode, idx) - weight.weightShardRemoved(this, maxNode, idx);\n-                                if (delta < minCost ||\n-                                        (candidate != null && Float.compare(delta, minCost) == 0 && candidate.id() > shard.id())) {\n-                                    /* this last line is a tie-breaker to make the shard allocation alg deterministic\n-                                     * otherwise we rely on the iteration order of the index.getAllShards() which is a set.*/\n-                                    minCost = delta;\n-                                    candidate = shard;\n-                                    decision = new Decision.Multi().add(allocationDecision).add(rebalanceDecision);\n-                                }\n-                            }\n+                        if (maxNode.containsShard(shard)) {\n+                            shardRoutings.add(shard);\n                         }\n                     }\n                 }\n \n+                // look for a relocation candidate, in descending order of shard id so that the decision is deterministic\n+                shardRoutings.sort(BY_DESCENDING_SHARD_ID);\n+                for (ShardRouting shard : shardRoutings) {\n+                    final Decision rebalanceDecision = deciders.canRebalance(shard, allocation);\n+                    if ((rebalanceDecision.type() != Type.YES) && (rebalanceDecision.type() != Type.THROTTLE)) {\n+                        continue;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ffbbac3e8d0f9b568e54876ced522bc2933f6c4"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ3MDAxMA==", "bodyText": "\ud83d\udc4d b4f90c2", "url": "https://github.com/elastic/elasticsearch/pull/51632#discussion_r373470010", "createdAt": "2020-01-31T13:06:53Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java", "diffHunk": "@@ -1000,30 +995,32 @@ private boolean tryRelocateShard(ModelNode minNode, ModelNode maxNode, String id\n                 }\n                 ShardRouting candidate = null;\n                 final AllocationDeciders deciders = allocation.deciders();\n+                final List<ShardRouting> shardRoutings = new ArrayList<>(index.numShards());\n                 for (ShardRouting shard : index) {\n                     if (shard.started()) {\n                         // skip initializing, unassigned and relocating shards we can't relocate them anyway\n-                        Decision allocationDecision = deciders.canAllocate(shard, minNode.getRoutingNode(), allocation);\n-                        Decision rebalanceDecision = deciders.canRebalance(shard, allocation);\n-                        if (((allocationDecision.type() == Type.YES) || (allocationDecision.type() == Type.THROTTLE))\n-                                && ((rebalanceDecision.type() == Type.YES) || (rebalanceDecision.type() == Type.THROTTLE))) {\n-                            if (maxNode.containsShard(shard)) {\n-                                // simulate moving shard from maxNode to minNode\n-                                final float delta = weight.weightShardAdded(\n-                                    this, minNode, idx) - weight.weightShardRemoved(this, maxNode, idx);\n-                                if (delta < minCost ||\n-                                        (candidate != null && Float.compare(delta, minCost) == 0 && candidate.id() > shard.id())) {\n-                                    /* this last line is a tie-breaker to make the shard allocation alg deterministic\n-                                     * otherwise we rely on the iteration order of the index.getAllShards() which is a set.*/\n-                                    minCost = delta;\n-                                    candidate = shard;\n-                                    decision = new Decision.Multi().add(allocationDecision).add(rebalanceDecision);\n-                                }\n-                            }\n+                        if (maxNode.containsShard(shard)) {\n+                            shardRoutings.add(shard);\n                         }\n                     }\n                 }\n \n+                // look for a relocation candidate, in descending order of shard id so that the decision is deterministic\n+                shardRoutings.sort(BY_DESCENDING_SHARD_ID);\n+                for (ShardRouting shard : shardRoutings) {\n+                    final Decision rebalanceDecision = deciders.canRebalance(shard, allocation);\n+                    if ((rebalanceDecision.type() != Type.YES) && (rebalanceDecision.type() != Type.THROTTLE)) {\n+                        continue;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg5MjA4OA=="}, "originalCommit": {"oid": "5ffbbac3e8d0f9b568e54876ced522bc2933f6c4"}, "originalPosition": 179}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwNTYxMjM2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxMToyMDoxMlrOFjnlLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQxMzowNzowN1rOFkKzbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg5Mjk3Mg==", "bodyText": "Should we move this up as well, so that we can avoid the if (candidate != null) { check (as it's only assigned once now)?", "url": "https://github.com/elastic/elasticsearch/pull/51632#discussion_r372892972", "createdAt": "2020-01-30T11:20:12Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java", "diffHunk": "@@ -1000,30 +995,32 @@ private boolean tryRelocateShard(ModelNode minNode, ModelNode maxNode, String id\n                 }\n                 ShardRouting candidate = null;\n                 final AllocationDeciders deciders = allocation.deciders();\n+                final List<ShardRouting> shardRoutings = new ArrayList<>(index.numShards());\n                 for (ShardRouting shard : index) {\n                     if (shard.started()) {\n                         // skip initializing, unassigned and relocating shards we can't relocate them anyway\n-                        Decision allocationDecision = deciders.canAllocate(shard, minNode.getRoutingNode(), allocation);\n-                        Decision rebalanceDecision = deciders.canRebalance(shard, allocation);\n-                        if (((allocationDecision.type() == Type.YES) || (allocationDecision.type() == Type.THROTTLE))\n-                                && ((rebalanceDecision.type() == Type.YES) || (rebalanceDecision.type() == Type.THROTTLE))) {\n-                            if (maxNode.containsShard(shard)) {\n-                                // simulate moving shard from maxNode to minNode\n-                                final float delta = weight.weightShardAdded(\n-                                    this, minNode, idx) - weight.weightShardRemoved(this, maxNode, idx);\n-                                if (delta < minCost ||\n-                                        (candidate != null && Float.compare(delta, minCost) == 0 && candidate.id() > shard.id())) {\n-                                    /* this last line is a tie-breaker to make the shard allocation alg deterministic\n-                                     * otherwise we rely on the iteration order of the index.getAllShards() which is a set.*/\n-                                    minCost = delta;\n-                                    candidate = shard;\n-                                    decision = new Decision.Multi().add(allocationDecision).add(rebalanceDecision);\n-                                }\n-                            }\n+                        if (maxNode.containsShard(shard)) {\n+                            shardRoutings.add(shard);\n                         }\n                     }\n                 }\n \n+                // look for a relocation candidate, in descending order of shard id so that the decision is deterministic\n+                shardRoutings.sort(BY_DESCENDING_SHARD_ID);\n+                for (ShardRouting shard : shardRoutings) {\n+                    final Decision rebalanceDecision = deciders.canRebalance(shard, allocation);\n+                    if ((rebalanceDecision.type() != Type.YES) && (rebalanceDecision.type() != Type.THROTTLE)) {\n+                        continue;\n+                    }\n+                    final Decision allocationDecision = deciders.canAllocate(shard, minNode.getRoutingNode(), allocation);\n+                    if ((allocationDecision.type() != Type.YES) && (allocationDecision.type() != Type.THROTTLE)) {\n+                        continue;\n+                    }\n+                    candidate = shard;\n+                    decision = new Decision.Multi().add(allocationDecision).add(rebalanceDecision);\n+                    break;\n+                }\n+\n                 if (candidate != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ffbbac3e8d0f9b568e54876ced522bc2933f6c4"}, "originalPosition": 190}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ3MDA2Mw==", "bodyText": "Yes, thanks, that's nicer still. ad503a5.", "url": "https://github.com/elastic/elasticsearch/pull/51632#discussion_r373470063", "createdAt": "2020-01-31T13:07:07Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java", "diffHunk": "@@ -1000,30 +995,32 @@ private boolean tryRelocateShard(ModelNode minNode, ModelNode maxNode, String id\n                 }\n                 ShardRouting candidate = null;\n                 final AllocationDeciders deciders = allocation.deciders();\n+                final List<ShardRouting> shardRoutings = new ArrayList<>(index.numShards());\n                 for (ShardRouting shard : index) {\n                     if (shard.started()) {\n                         // skip initializing, unassigned and relocating shards we can't relocate them anyway\n-                        Decision allocationDecision = deciders.canAllocate(shard, minNode.getRoutingNode(), allocation);\n-                        Decision rebalanceDecision = deciders.canRebalance(shard, allocation);\n-                        if (((allocationDecision.type() == Type.YES) || (allocationDecision.type() == Type.THROTTLE))\n-                                && ((rebalanceDecision.type() == Type.YES) || (rebalanceDecision.type() == Type.THROTTLE))) {\n-                            if (maxNode.containsShard(shard)) {\n-                                // simulate moving shard from maxNode to minNode\n-                                final float delta = weight.weightShardAdded(\n-                                    this, minNode, idx) - weight.weightShardRemoved(this, maxNode, idx);\n-                                if (delta < minCost ||\n-                                        (candidate != null && Float.compare(delta, minCost) == 0 && candidate.id() > shard.id())) {\n-                                    /* this last line is a tie-breaker to make the shard allocation alg deterministic\n-                                     * otherwise we rely on the iteration order of the index.getAllShards() which is a set.*/\n-                                    minCost = delta;\n-                                    candidate = shard;\n-                                    decision = new Decision.Multi().add(allocationDecision).add(rebalanceDecision);\n-                                }\n-                            }\n+                        if (maxNode.containsShard(shard)) {\n+                            shardRoutings.add(shard);\n                         }\n                     }\n                 }\n \n+                // look for a relocation candidate, in descending order of shard id so that the decision is deterministic\n+                shardRoutings.sort(BY_DESCENDING_SHARD_ID);\n+                for (ShardRouting shard : shardRoutings) {\n+                    final Decision rebalanceDecision = deciders.canRebalance(shard, allocation);\n+                    if ((rebalanceDecision.type() != Type.YES) && (rebalanceDecision.type() != Type.THROTTLE)) {\n+                        continue;\n+                    }\n+                    final Decision allocationDecision = deciders.canAllocate(shard, minNode.getRoutingNode(), allocation);\n+                    if ((allocationDecision.type() != Type.YES) && (allocationDecision.type() != Type.THROTTLE)) {\n+                        continue;\n+                    }\n+                    candidate = shard;\n+                    decision = new Decision.Multi().add(allocationDecision).add(rebalanceDecision);\n+                    break;\n+                }\n+\n                 if (candidate != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg5Mjk3Mg=="}, "originalCommit": {"oid": "5ffbbac3e8d0f9b568e54876ced522bc2933f6c4"}, "originalPosition": 190}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwNTY3MjgwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxMTo0MjoxNlrOFjoIxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQxMzowNjozNFrOFkKyxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjkwMjA4NQ==", "bodyText": "I think this could now translate into a nice stream one liner?\nindex.stream().filter(ShardRouting::started).filter(maxNode::containsShard).sorted(Comparator.comparing(ShardRouting::id).reversed())\n\nthen either collect or do the final filtering and findFirst?", "url": "https://github.com/elastic/elasticsearch/pull/51632#discussion_r372902085", "createdAt": "2020-01-30T11:42:16Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java", "diffHunk": "@@ -993,24 +993,27 @@ private boolean tryRelocateShard(ModelNode minNode, ModelNode maxNode, String id\n                 }\n                 ShardRouting candidate = null;\n                 final AllocationDeciders deciders = allocation.deciders();\n+                final List<ShardRouting> shardRoutings = new ArrayList<>(index.numShards());\n                 for (ShardRouting shard : index) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bacce1cb706d203cc971ad8bbe746cb432c50db8"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ2OTg5Mw==", "bodyText": "We can't use findFirst since we also need to capture the decision from the first matching shard; however nor do we need to collect into a list: 8971daa.\n(Of course .sorted() has to allocate an array anyway, but I think that Collectors#toList always copies its input even if it's already an array, so at least there's that)", "url": "https://github.com/elastic/elasticsearch/pull/51632#discussion_r373469893", "createdAt": "2020-01-31T13:06:34Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java", "diffHunk": "@@ -993,24 +993,27 @@ private boolean tryRelocateShard(ModelNode minNode, ModelNode maxNode, String id\n                 }\n                 ShardRouting candidate = null;\n                 final AllocationDeciders deciders = allocation.deciders();\n+                final List<ShardRouting> shardRoutings = new ArrayList<>(index.numShards());\n                 for (ShardRouting shard : index) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjkwMjA4NQ=="}, "originalCommit": {"oid": "bacce1cb706d203cc971ad8bbe746cb432c50db8"}, "originalPosition": 5}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 109, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}