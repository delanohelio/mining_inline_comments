{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcyNjI4MDI0", "number": 61495, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQyMTo1OTozNVrOEbwa_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQyMTo1OTozNVrOEbwa_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3NTQwMzUxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/common/compress/DeflateCompressor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQyMTo1OTozNVrOHF3v_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQyMTo1OTozNVrOHF3v_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTkxODMzNQ==", "bodyText": "Need this flag still and move the super.close into the flag check also due to a Java8 bug: https://bugs.openjdk.java.net/browse/JDK-8054565 that otherwise forces another .finish on the underlying stream after the deflater has already been reset (thus adding another 5 bytes to it and breaking things).", "url": "https://github.com/elastic/elasticsearch/pull/61495#discussion_r475918335", "createdAt": "2020-08-24T21:59:35Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/common/compress/DeflateCompressor.java", "diffHunk": "@@ -88,56 +156,80 @@ public StreamInput streamInput(StreamInput in) throws IOException {\n             throw new IllegalArgumentException(\"Input stream is not compressed with DEFLATE!\");\n         }\n \n-        final boolean nowrap = true;\n-        final Inflater inflater = new Inflater(nowrap);\n-        InputStream decompressedIn = new InflaterInputStream(in, inflater, BUFFER_SIZE);\n-        decompressedIn = new BufferedInputStream(decompressedIn, BUFFER_SIZE);\n-        return new InputStreamStreamInput(decompressedIn) {\n-            final AtomicBoolean closed = new AtomicBoolean(false);\n-\n+        final Releasable releasable;\n+        final Inflater inflater;\n+        if (threadLocal) {\n+            final ReleasableReference<Inflater> current = inflaterForStreamRef.get();\n+            if (current.inUse) {\n+                // Nested de-compression streams should not happen but we still handle them safely by using a fresh Inflater\n+                inflater = new Inflater(true);\n+                releasable = inflater::end;\n+            } else {\n+                inflater = current.get();\n+                releasable = current;\n+            }\n+        } else {\n+            inflater = new Inflater(true);\n+            releasable = inflater::end;\n+        }\n+        return new BufferedInputStream(new InflaterInputStream(in, inflater, BUFFER_SIZE) {\n+            @Override\n             public void close() throws IOException {\n                 try {\n                     super.close();\n                 } finally {\n-                    if (closed.compareAndSet(false, true)) {\n-                        // important to release native memory\n-                        inflater.end();\n-                    }\n+                    // We are ensured to only call this once since we wrap this stream in a BufferedInputStream that will only close\n+                    // its delegate once\n+                    releasable.close();\n                 }\n             }\n-        };\n+        }, BUFFER_SIZE);\n     }\n \n     @Override\n-    public StreamOutput streamOutput(OutputStream out) throws IOException {\n+    public StreamOutput threadLocalStreamOutput(OutputStream out) throws IOException {\n         out.write(HEADER);\n-        final boolean nowrap = true;\n-        final Deflater deflater = new Deflater(LEVEL, nowrap);\n+        final ReleasableReference<Deflater> current = deflaterForStreamRef.get();\n+        final Releasable releasable;\n+        final Deflater deflater;\n+        if (current.inUse) {\n+            // Nested compression streams should not happen but we still handle them safely by using a fresh Deflater\n+            deflater = new Deflater(LEVEL, true);\n+            releasable = deflater::end;\n+        } else {\n+            deflater = current.get();\n+            releasable = current;\n+        }\n         final boolean syncFlush = true;\n         DeflaterOutputStream deflaterOutputStream = new DeflaterOutputStream(out, deflater, BUFFER_SIZE, syncFlush);\n         OutputStream compressedOut = new BufferedOutputStream(deflaterOutputStream, BUFFER_SIZE);\n         return new OutputStreamStreamOutput(compressedOut) {\n-            final AtomicBoolean closed = new AtomicBoolean(false);\n+\n+            // Due to https://bugs.openjdk.java.net/browse/JDK-8054565 we can't rely on the buffered output stream to only close once\n+            // in code that has to support Java 8 so we manually manage a close flag for this stream.\n+            private boolean closed = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e34eaccd4480c127d169d33477145be540160407"}, "originalPosition": 171}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 812, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}