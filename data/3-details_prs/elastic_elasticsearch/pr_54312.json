{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk0NDc2Mjkw", "number": 54312, "title": "Broadcast cancellation to only nodes have outstanding child tasks", "bodyText": "Today when canceling a task we broadcast ban/unban requests to all nodes in the cluster. This strategy does not scale well for hierarchical cancellation. With this change, we will track outstanding child requests and broadcast cancellation to only nodes having outstanding child tasks. This change also strengthens the coordination during cancellation. A parent task will no longer be able to send child requests via transport service once it gets cancelled, which streamlines cancellation on the parent task by not requiring to manually check whether the task is cancelled during the execution.\nRelates #50990\nSupersedes #51157\nCo-authored-by: Igor Motov igor@motovs.org\nCo-authored-by: Yannick Welsch yannick@welsch.lu", "createdAt": "2020-03-26T23:40:37Z", "url": "https://github.com/elastic/elasticsearch/pull/54312", "merged": true, "mergeCommit": {"oid": "ee3d40320aabf6c64003b7669739e04b86e25a56"}, "closed": true, "closedAt": "2020-04-01T15:22:14Z", "author": {"login": "dnhatn"}, "timelineItems": {"totalCount": 29, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcRk1wzAH2gAyMzk0NDc2MjkwOmNkMTllZWYwZmJkYzFlY2E5YjgyOGMxNjc4ZGU1ZGQ0Y2M2MThhM2Y=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcTXk5vAH2gAyMzk0NDc2MjkwOjJjOGMxY2RiOTQxYzIzODlmYWU1YWFkNDQ2MmQwYmE4YzdkMmZkNzI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "cd19eef0fbdc1eca9b828c1678de5dd4cc618a3f", "author": {"user": {"login": "dnhatn", "name": "Nhat Nguyen"}}, "url": "https://github.com/elastic/elasticsearch/commit/cd19eef0fbdc1eca9b828c1678de5dd4cc618a3f", "committedDate": "2020-03-26T23:38:06Z", "message": "Propagate cancellation to nodes have outstanding child tasks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "23ddc8aa0b0845e54666e8941791589b69c2b08e", "author": {"user": {"login": "dnhatn", "name": "Nhat Nguyen"}}, "url": "https://github.com/elastic/elasticsearch/commit/23ddc8aa0b0845e54666e8941791589b69c2b08e", "committedDate": "2020-03-27T16:23:23Z", "message": "register child node when execute task locally"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2136f26af6e9ae409e8baf182b9ff1afcfdc3369", "author": {"user": {"login": "dnhatn", "name": "Nhat Nguyen"}}, "url": "https://github.com/elastic/elasticsearch/commit/2136f26af6e9ae409e8baf182b9ff1afcfdc3369", "committedDate": "2020-03-27T16:41:48Z", "message": "Merge branch 'master' into track-child-tasks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dba2dbdc0a567cd12cd460c3a25e5472abdab898", "author": {"user": {"login": "dnhatn", "name": "Nhat Nguyen"}}, "url": "https://github.com/elastic/elasticsearch/commit/dba2dbdc0a567cd12cd460c3a25e5472abdab898", "committedDate": "2020-03-27T17:40:09Z", "message": "only return when childTasks have completed"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a2286d1d0f86da3108c5ce27ccbc72fb9ad8043f", "author": {"user": {"login": "dnhatn", "name": "Nhat Nguyen"}}, "url": "https://github.com/elastic/elasticsearch/commit/a2286d1d0f86da3108c5ce27ccbc72fb9ad8043f", "committedDate": "2020-03-27T17:40:59Z", "message": "remove unneed synchronized"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b14efd3131591ae9522e39eacd3a294f5ee679fe", "author": {"user": {"login": "dnhatn", "name": "Nhat Nguyen"}}, "url": "https://github.com/elastic/elasticsearch/commit/b14efd3131591ae9522e39eacd3a294f5ee679fe", "committedDate": "2020-03-27T18:32:35Z", "message": "javadocs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f5753dc2a4d879ff14b77c6f3a034b648cd2081f", "author": {"user": {"login": "dnhatn", "name": "Nhat Nguyen"}}, "url": "https://github.com/elastic/elasticsearch/commit/f5753dc2a4d879ff14b77c6f3a034b648cd2081f", "committedDate": "2020-03-27T18:55:24Z", "message": "Merge branch 'master' into track-child-tasks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0f51b4548ef55190e34a26a4309122cdc95df32d", "author": {"user": {"login": "dnhatn", "name": "Nhat Nguyen"}}, "url": "https://github.com/elastic/elasticsearch/commit/0f51b4548ef55190e34a26a4309122cdc95df32d", "committedDate": "2020-03-27T19:47:56Z", "message": "remove assertion"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzNTYwNjYz", "url": "https://github.com/elastic/elasticsearch/pull/54312#pullrequestreview-383560663", "createdAt": "2020-03-30T06:29:28Z", "commit": {"oid": "0f51b4548ef55190e34a26a4309122cdc95df32d"}, "state": "COMMENTED", "comments": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwNjoyOToyOFrOF9bOXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwNzoxODowMVrOF9cdZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1MzUwMQ==", "bodyText": "should we check before the unblock that cancelFuture.isDone == false?", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399953501", "createdAt": "2020-03-30T06:29:28Z", "author": {"login": "ywelsch"}, "path": "modules/reindex/src/test/java/org/elasticsearch/index/reindex/CancelTests.java", "diffHunk": "@@ -159,7 +162,9 @@ private void testCancel(String action, AbstractBulkByScrollRequestBuilder<?, ?>\n \n         logger.debug(\"unblocking the blocked update\");\n         ALLOWED_OPERATIONS.release(builder.request().getSlices());\n-\n+        ListTasksResponse cancelTasksResponse = cancelFuture.get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f51b4548ef55190e34a26a4309122cdc95df32d"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1NDQwMw==", "bodyText": "Given the test change here, I wonder if there should be an option for task cancellation to say whether it should wait for its children to be cancelled / completed before returning. As soon as the parent is cancelled, we know that eventually the children will be cancelled (not yet guaranteed by the current implementation, but something we eventually want with the keepalive).", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399954403", "createdAt": "2020-03-30T06:31:59Z", "author": {"login": "ywelsch"}, "path": "modules/reindex/src/test/java/org/elasticsearch/index/reindex/CancelTests.java", "diffHunk": "@@ -131,16 +132,18 @@ private void testCancel(String action, AbstractBulkByScrollRequestBuilder<?, ?>\n \n         // Cancel the request while the action is blocked by the indexing operation listeners.\n         // This will prevent further requests from being sent.\n-        ListTasksResponse cancelTasksResponse = client().admin().cluster().prepareCancelTasks().setTaskId(mainTask.getTaskId()).get();\n-        cancelTasksResponse.rethrowFailures(\"Cancel\");\n-        assertThat(cancelTasksResponse.getTasks(), hasSize(1));\n+        ActionFuture<CancelTasksResponse> cancelFuture = client().admin().cluster().prepareCancelTasks()\n+            .setTaskId(mainTask.getTaskId()).execute();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f51b4548ef55190e34a26a4309122cdc95df32d"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1NjM0Mw==", "bodyText": "In theory, we could coordinate the banning / unbanning on a per-node basis, i.e., as soon as the parent is cancelled, and all requests from a child node have completed, we can send an unban to that node. I don't think that this optimization is needed (as it might make the code unnecessarily more complex), just thought I should mention it.", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399956343", "createdAt": "2020-03-30T06:37:15Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java", "diffHunk": "@@ -104,48 +103,35 @@ protected void processTasks(CancelTasksRequest request, Consumer<CancellableTask\n \n     @Override\n     protected synchronized void taskOperation(CancelTasksRequest request, CancellableTask cancellableTask,\n-            ActionListener<TaskInfo> listener) {\n+                                              ActionListener<TaskInfo> listener) {\n         String nodeId = clusterService.localNode().getId();\n         final boolean canceled;\n         if (cancellableTask.shouldCancelChildrenOnCancellation()) {\n-            DiscoveryNodes childNodes = clusterService.state().nodes();\n-            final BanLock banLock = new BanLock(childNodes.getSize(), () -> removeBanOnNodes(cancellableTask, childNodes));\n-            canceled = taskManager.cancel(cancellableTask, request.getReason(), banLock::onTaskFinished);\n-            if (canceled) {\n-                // /In case the task has some child tasks, we need to wait for until ban is set on all nodes\n-                logger.trace(\"cancelling task {} on child nodes\", cancellableTask.getId());\n-                AtomicInteger responses = new AtomicInteger(childNodes.getSize());\n-                List<Exception> failures = new ArrayList<>();\n-                setBanOnNodes(request.getReason(), cancellableTask, childNodes, new ActionListener<Void>() {\n-                    @Override\n-                    public void onResponse(Void aVoid) {\n-                        processResponse();\n-                    }\n-\n-                    @Override\n-                    public void onFailure(Exception e) {\n-                        synchronized (failures) {\n-                            failures.add(e);\n-                        }\n-                        processResponse();\n-                    }\n-\n-                    private void processResponse() {\n-                        banLock.onBanSet();\n-                        if (responses.decrementAndGet() == 0) {\n-                            if (failures.isEmpty() == false) {\n-                                IllegalStateException exception = new IllegalStateException(\"failed to cancel children of the task [\" +\n-                                    cancellableTask.getId() + \"]\");\n-                                failures.forEach(exception::addSuppressed);\n-                                listener.onFailure(exception);\n-                            } else {\n-                                listener.onResponse(cancellableTask.taskInfo(nodeId, false));\n-                            }\n-                        }\n+            final StepListener<Void> completeListener = new StepListener<>();\n+            // Only return when all these 3 actions completed: (1) bans are placed on nodes with outstanding child tasks,\n+            // (2) child tasks are completed or failed, (3) the parent task itself was cancelled.\n+            final GroupedActionListener<Void> groupedListener =\n+                new GroupedActionListener<>(ActionListener.map(completeListener, r -> null), 3);\n+            final Collection<DiscoveryNode> childNodes =\n+                taskManager.startBanOnChildrenNodes(cancellableTask.getId(), () -> groupedListener.onResponse(null));\n+            completeListener.whenComplete(r -> {\n+                    removeBanOnNodes(cancellableTask, childNodes);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f51b4548ef55190e34a26a4309122cdc95df32d"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1NzM3Ng==", "bodyText": "let's also log the childNodes here", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399957376", "createdAt": "2020-03-30T06:39:51Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java", "diffHunk": "@@ -158,74 +144,42 @@ private void processResponse() {\n         }\n     }\n \n-    private void setBanOnNodes(String reason, CancellableTask task, DiscoveryNodes nodes, ActionListener<Void> listener) {\n-        sendSetBanRequest(nodes,\n-            BanParentTaskRequest.createSetBanParentTaskRequest(new TaskId(clusterService.localNode().getId(), task.getId()), reason),\n-            listener);\n-    }\n-\n-    private void removeBanOnNodes(CancellableTask task, DiscoveryNodes nodes) {\n-        sendRemoveBanRequest(nodes,\n-            BanParentTaskRequest.createRemoveBanParentTaskRequest(new TaskId(clusterService.localNode().getId(), task.getId())));\n-    }\n-\n-    private void sendSetBanRequest(DiscoveryNodes nodes, BanParentTaskRequest request, ActionListener<Void> listener) {\n-        for (ObjectObjectCursor<String, DiscoveryNode> node : nodes.getNodes()) {\n-            logger.trace(\"Sending ban for tasks with the parent [{}] to the node [{}], ban [{}]\", request.parentTaskId, node.key,\n-                request.ban);\n-            transportService.sendRequest(node.value, BAN_PARENT_ACTION_NAME, request,\n+    private void setBanOnNodes(String reason, CancellableTask task, Collection<DiscoveryNode> childNodes, ActionListener<Void> listener) {\n+        if (childNodes.isEmpty()) {\n+            listener.onResponse(null);\n+            return;\n+        }\n+        logger.trace(\"cancelling task {} on child nodes\", task.getId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f51b4548ef55190e34a26a4309122cdc95df32d"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1OTEyMw==", "bodyText": "if (canceled == false) we're not calling groupedListener?", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399959123", "createdAt": "2020-03-30T06:44:28Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java", "diffHunk": "@@ -104,48 +103,35 @@ protected void processTasks(CancelTasksRequest request, Consumer<CancellableTask\n \n     @Override\n     protected synchronized void taskOperation(CancelTasksRequest request, CancellableTask cancellableTask,\n-            ActionListener<TaskInfo> listener) {\n+                                              ActionListener<TaskInfo> listener) {\n         String nodeId = clusterService.localNode().getId();\n         final boolean canceled;\n         if (cancellableTask.shouldCancelChildrenOnCancellation()) {\n-            DiscoveryNodes childNodes = clusterService.state().nodes();\n-            final BanLock banLock = new BanLock(childNodes.getSize(), () -> removeBanOnNodes(cancellableTask, childNodes));\n-            canceled = taskManager.cancel(cancellableTask, request.getReason(), banLock::onTaskFinished);\n-            if (canceled) {\n-                // /In case the task has some child tasks, we need to wait for until ban is set on all nodes\n-                logger.trace(\"cancelling task {} on child nodes\", cancellableTask.getId());\n-                AtomicInteger responses = new AtomicInteger(childNodes.getSize());\n-                List<Exception> failures = new ArrayList<>();\n-                setBanOnNodes(request.getReason(), cancellableTask, childNodes, new ActionListener<Void>() {\n-                    @Override\n-                    public void onResponse(Void aVoid) {\n-                        processResponse();\n-                    }\n-\n-                    @Override\n-                    public void onFailure(Exception e) {\n-                        synchronized (failures) {\n-                            failures.add(e);\n-                        }\n-                        processResponse();\n-                    }\n-\n-                    private void processResponse() {\n-                        banLock.onBanSet();\n-                        if (responses.decrementAndGet() == 0) {\n-                            if (failures.isEmpty() == false) {\n-                                IllegalStateException exception = new IllegalStateException(\"failed to cancel children of the task [\" +\n-                                    cancellableTask.getId() + \"]\");\n-                                failures.forEach(exception::addSuppressed);\n-                                listener.onFailure(exception);\n-                            } else {\n-                                listener.onResponse(cancellableTask.taskInfo(nodeId, false));\n-                            }\n-                        }\n+            final StepListener<Void> completeListener = new StepListener<>();\n+            // Only return when all these 3 actions completed: (1) bans are placed on nodes with outstanding child tasks,\n+            // (2) child tasks are completed or failed, (3) the parent task itself was cancelled.\n+            final GroupedActionListener<Void> groupedListener =\n+                new GroupedActionListener<>(ActionListener.map(completeListener, r -> null), 3);\n+            final Collection<DiscoveryNode> childNodes =\n+                taskManager.startBanOnChildrenNodes(cancellableTask.getId(), () -> groupedListener.onResponse(null));\n+            completeListener.whenComplete(r -> {\n+                    removeBanOnNodes(cancellableTask, childNodes);\n+                    listener.onResponse(cancellableTask.taskInfo(nodeId, false));\n+                },\n+                e -> {\n+                    try {\n+                        removeBanOnNodes(cancellableTask, childNodes);\n+                    } catch (Exception inner) {\n+                        e.addSuppressed(inner);\n                     }\n+                    listener.onFailure(e);\n                 });\n+            canceled = taskManager.cancel(cancellableTask, request.getReason(), () -> groupedListener.onResponse(null));\n+            if (canceled) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f51b4548ef55190e34a26a4309122cdc95df32d"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1OTQyMA==", "bodyText": "log at trace level", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399959420", "createdAt": "2020-03-30T06:45:17Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java", "diffHunk": "@@ -158,74 +144,42 @@ private void processResponse() {\n         }\n     }\n \n-    private void setBanOnNodes(String reason, CancellableTask task, DiscoveryNodes nodes, ActionListener<Void> listener) {\n-        sendSetBanRequest(nodes,\n-            BanParentTaskRequest.createSetBanParentTaskRequest(new TaskId(clusterService.localNode().getId(), task.getId()), reason),\n-            listener);\n-    }\n-\n-    private void removeBanOnNodes(CancellableTask task, DiscoveryNodes nodes) {\n-        sendRemoveBanRequest(nodes,\n-            BanParentTaskRequest.createRemoveBanParentTaskRequest(new TaskId(clusterService.localNode().getId(), task.getId())));\n-    }\n-\n-    private void sendSetBanRequest(DiscoveryNodes nodes, BanParentTaskRequest request, ActionListener<Void> listener) {\n-        for (ObjectObjectCursor<String, DiscoveryNode> node : nodes.getNodes()) {\n-            logger.trace(\"Sending ban for tasks with the parent [{}] to the node [{}], ban [{}]\", request.parentTaskId, node.key,\n-                request.ban);\n-            transportService.sendRequest(node.value, BAN_PARENT_ACTION_NAME, request,\n+    private void setBanOnNodes(String reason, CancellableTask task, Collection<DiscoveryNode> childNodes, ActionListener<Void> listener) {\n+        if (childNodes.isEmpty()) {\n+            listener.onResponse(null);\n+            return;\n+        }\n+        logger.trace(\"cancelling task {} on child nodes\", task.getId());\n+        GroupedActionListener<Void> groupedListener =\n+            new GroupedActionListener<>(ActionListener.map(listener, r -> null), childNodes.size());\n+        final BanParentTaskRequest banRequest = BanParentTaskRequest.createSetBanParentTaskRequest(\n+            new TaskId(clusterService.localNode().getId(), task.getId()), reason);\n+        for (DiscoveryNode node : childNodes) {\n+            transportService.sendRequest(node, BAN_PARENT_ACTION_NAME, banRequest,\n                 new EmptyTransportResponseHandler(ThreadPool.Names.SAME) {\n                     @Override\n                     public void handleResponse(TransportResponse.Empty response) {\n-                        listener.onResponse(null);\n+                        groupedListener.onResponse(null);\n                     }\n \n                     @Override\n                     public void handleException(TransportException exp) {\n-                        logger.warn(\"Cannot send ban for tasks with the parent [{}] to the node [{}]\", request.parentTaskId, node.key);\n-                        listener.onFailure(exp);\n+                        logger.warn(\"Cannot send ban for tasks with the parent [{}] to the node [{}]\", banRequest.parentTaskId, node);\n+                        groupedListener.onFailure(exp);\n                     }\n                 });\n         }\n     }\n \n-    private void sendRemoveBanRequest(DiscoveryNodes nodes, BanParentTaskRequest request) {\n-        for (ObjectObjectCursor<String, DiscoveryNode> node : nodes.getNodes()) {\n-            logger.debug(\"Sending remove ban for tasks with the parent [{}] to the node [{}]\", request.parentTaskId, node.key);\n-            transportService.sendRequest(node.value, BAN_PARENT_ACTION_NAME, request, EmptyTransportResponseHandler\n-                .INSTANCE_SAME);\n+    private void removeBanOnNodes(CancellableTask task, Collection<DiscoveryNode> childNodes) {\n+        final BanParentTaskRequest request =\n+            BanParentTaskRequest.createRemoveBanParentTaskRequest(new TaskId(clusterService.localNode().getId(), task.getId()));\n+        for (DiscoveryNode node : childNodes) {\n+            logger.debug(\"Sending remove ban for tasks with the parent [{}] to the node [{}]\", request.parentTaskId, node);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f51b4548ef55190e34a26a4309122cdc95df32d"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2MTgyOQ==", "bodyText": "I wonder if we should leave this optimization in (and add a comment as well). This avoids computing the hash of the task id in order to look it up in the map.", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399961829", "createdAt": "2020-03-30T06:51:37Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/tasks/TaskManager.java", "diffHunk": "@@ -163,7 +178,7 @@ private void registerCancellableTask(Task task) {\n         CancellableTaskHolder oldHolder = cancellableTasks.put(task.getId(), holder);\n         assert oldHolder == null;\n         // Check if this task was banned before we start it\n-        if (task.getParentTaskId().isSet() && banedParents.isEmpty() == false) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f51b4548ef55190e34a26a4309122cdc95df32d"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2MzM2OA==", "bodyText": "when do we expect this to happen?", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399963368", "createdAt": "2020-03-30T06:55:15Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/tasks/TaskManager.java", "diffHunk": "@@ -369,6 +397,33 @@ public void removeBan(TaskId parentTaskId) {\n         banedParents.remove(parentTaskId);\n     }\n \n+    // for testing\n+    public boolean childTasksCancelledOrBanned(TaskId parentTaskId) {\n+        if (banedParents.containsKey(parentTaskId)) {\n+            return true;\n+        }\n+        return cancellableTasks.values().stream().noneMatch(task -> task.hasParent(parentTaskId));\n+    }\n+\n+    /**\n+     * Start rejecting new child requests as the parent task was cancelled.\n+     *\n+     * @param taskId            the parent task id\n+     * @param onEmptyChildNodes called when all child nodes are unregistered (i.e, all child tasks are completed or failed)\n+     * @return the set of current nodes that have outstanding child tasks\n+     */\n+    public Collection<DiscoveryNode> startBanOnChildrenNodes(long taskId, Runnable onEmptyChildNodes) {\n+        final CancellableTaskHolder holder = cancellableTasks.get(taskId);\n+        if (holder != null) {\n+            return holder.startBan(onEmptyChildNodes);\n+        } else {\n+            logger.warn(\"Trying to cancel task without registered cancellable task \" + taskId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f51b4548ef55190e34a26a4309122cdc95df32d"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2MzUwMA==", "bodyText": "I'm not sure I understand this comment. Can you elaborate on this?", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399963500", "createdAt": "2020-03-30T06:55:35Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/tasks/TaskManager.java", "diffHunk": "@@ -369,6 +397,33 @@ public void removeBan(TaskId parentTaskId) {\n         banedParents.remove(parentTaskId);\n     }\n \n+    // for testing\n+    public boolean childTasksCancelledOrBanned(TaskId parentTaskId) {\n+        if (banedParents.containsKey(parentTaskId)) {\n+            return true;\n+        }\n+        return cancellableTasks.values().stream().noneMatch(task -> task.hasParent(parentTaskId));\n+    }\n+\n+    /**\n+     * Start rejecting new child requests as the parent task was cancelled.\n+     *\n+     * @param taskId            the parent task id\n+     * @param onEmptyChildNodes called when all child nodes are unregistered (i.e, all child tasks are completed or failed)\n+     * @return the set of current nodes that have outstanding child tasks\n+     */\n+    public Collection<DiscoveryNode> startBanOnChildrenNodes(long taskId, Runnable onEmptyChildNodes) {\n+        final CancellableTaskHolder holder = cancellableTasks.get(taskId);\n+        if (holder != null) {\n+            return holder.startBan(onEmptyChildNodes);\n+        } else {\n+            logger.warn(\"Trying to cancel task without registered cancellable task \" + taskId);\n+            // We still need to set ban on local node for persistent tasks", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f51b4548ef55190e34a26a4309122cdc95df32d"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2Mzk0NQ==", "bodyText": "perhaps call this onChildTasksCompleted?", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399963945", "createdAt": "2020-03-30T06:56:38Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/tasks/TaskManager.java", "diffHunk": "@@ -369,6 +397,33 @@ public void removeBan(TaskId parentTaskId) {\n         banedParents.remove(parentTaskId);\n     }\n \n+    // for testing\n+    public boolean childTasksCancelledOrBanned(TaskId parentTaskId) {\n+        if (banedParents.containsKey(parentTaskId)) {\n+            return true;\n+        }\n+        return cancellableTasks.values().stream().noneMatch(task -> task.hasParent(parentTaskId));\n+    }\n+\n+    /**\n+     * Start rejecting new child requests as the parent task was cancelled.\n+     *\n+     * @param taskId            the parent task id\n+     * @param onEmptyChildNodes called when all child nodes are unregistered (i.e, all child tasks are completed or failed)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f51b4548ef55190e34a26a4309122cdc95df32d"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2NDk3MA==", "bodyText": "any child tasks", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399964970", "createdAt": "2020-03-30T06:58:59Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/tasks/TaskManager.java", "diffHunk": "@@ -495,6 +552,56 @@ public boolean hasParent(TaskId parentTaskId) {\n         public CancellableTask getTask() {\n             return task;\n         }\n+\n+        synchronized void registerChildNode(DiscoveryNode node) {\n+            if (banChildren) {\n+                throw new TaskCancelledException(\"The parent task was cancelled, shouldn't start any children tasks\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f51b4548ef55190e34a26a4309122cdc95df32d"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2NTY5Mg==", "bodyText": "perhaps runnable = {}, which avoids the null check later down", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399965692", "createdAt": "2020-03-30T07:00:43Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/tasks/TaskManager.java", "diffHunk": "@@ -495,6 +552,56 @@ public boolean hasParent(TaskId parentTaskId) {\n         public CancellableTask getTask() {\n             return task;\n         }\n+\n+        synchronized void registerChildNode(DiscoveryNode node) {\n+            if (banChildren) {\n+                throw new TaskCancelledException(\"The parent task was cancelled, shouldn't start any children tasks\");\n+            }\n+            if (childTasksPerNode == null) {\n+                childTasksPerNode = new ObjectIntHashMap<>();\n+            }\n+            childTasksPerNode.addTo(node, 1);\n+        }\n+\n+        void unregisterChildNode(DiscoveryNode node) {\n+            final Runnable runnable;\n+            synchronized (this) {\n+                if (childTasksPerNode.addTo(node, -1) == 0) {\n+                    childTasksPerNode.remove(node);\n+                }\n+                if (childTasksPerNode.isEmpty()) {\n+                    runnable = onEmptyChildNodes;\n+                } else {\n+                    runnable = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f51b4548ef55190e34a26a4309122cdc95df32d"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2NjI5OA==", "bodyText": "why does this deserve a warning?\nWhen do we expect this to happen?", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399966298", "createdAt": "2020-03-30T07:02:04Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/tasks/TaskManager.java", "diffHunk": "@@ -495,6 +552,56 @@ public boolean hasParent(TaskId parentTaskId) {\n         public CancellableTask getTask() {\n             return task;\n         }\n+\n+        synchronized void registerChildNode(DiscoveryNode node) {\n+            if (banChildren) {\n+                throw new TaskCancelledException(\"The parent task was cancelled, shouldn't start any children tasks\");\n+            }\n+            if (childTasksPerNode == null) {\n+                childTasksPerNode = new ObjectIntHashMap<>();\n+            }\n+            childTasksPerNode.addTo(node, 1);\n+        }\n+\n+        void unregisterChildNode(DiscoveryNode node) {\n+            final Runnable runnable;\n+            synchronized (this) {\n+                if (childTasksPerNode.addTo(node, -1) == 0) {\n+                    childTasksPerNode.remove(node);\n+                }\n+                if (childTasksPerNode.isEmpty()) {\n+                    runnable = onEmptyChildNodes;\n+                } else {\n+                    runnable = null;\n+                }\n+            }\n+            if (runnable != null) {\n+                runnable.run();\n+            }\n+        }\n+\n+        Set<DiscoveryNode> startBan(Runnable onEmptyChildNodes) {\n+            final Set<DiscoveryNode> pendingChildNodes;\n+            synchronized (this) {\n+                if (banChildren) {\n+                    logger.warn(\"Trying to start ban twice for task \" + task.getId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f51b4548ef55190e34a26a4309122cdc95df32d"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2NjY3OQ==", "bodyText": "Why use empty set here and not the actual set? Will this not lead to incorrectness?", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399966679", "createdAt": "2020-03-30T07:03:00Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/tasks/TaskManager.java", "diffHunk": "@@ -495,6 +552,56 @@ public boolean hasParent(TaskId parentTaskId) {\n         public CancellableTask getTask() {\n             return task;\n         }\n+\n+        synchronized void registerChildNode(DiscoveryNode node) {\n+            if (banChildren) {\n+                throw new TaskCancelledException(\"The parent task was cancelled, shouldn't start any children tasks\");\n+            }\n+            if (childTasksPerNode == null) {\n+                childTasksPerNode = new ObjectIntHashMap<>();\n+            }\n+            childTasksPerNode.addTo(node, 1);\n+        }\n+\n+        void unregisterChildNode(DiscoveryNode node) {\n+            final Runnable runnable;\n+            synchronized (this) {\n+                if (childTasksPerNode.addTo(node, -1) == 0) {\n+                    childTasksPerNode.remove(node);\n+                }\n+                if (childTasksPerNode.isEmpty()) {\n+                    runnable = onEmptyChildNodes;\n+                } else {\n+                    runnable = null;\n+                }\n+            }\n+            if (runnable != null) {\n+                runnable.run();\n+            }\n+        }\n+\n+        Set<DiscoveryNode> startBan(Runnable onEmptyChildNodes) {\n+            final Set<DiscoveryNode> pendingChildNodes;\n+            synchronized (this) {\n+                if (banChildren) {\n+                    logger.warn(\"Trying to start ban twice for task \" + task.getId());\n+                    pendingChildNodes = Collections.emptySet();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f51b4548ef55190e34a26a4309122cdc95df32d"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk3MTI5Mw==", "bodyText": "I think that we need to actually capture the connection (not the DiscoveryNode object). The reason for this is cross-cluster connections. In the task cancellation action, we assume that the DiscoveryNode is sufficient to resolve the target of the cancellation. This only works for nodes in the same cluster, however.\nI don't think that we need to solve this all in this PR, but we need to capture the issue properly, and add an item to the planning.", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399971293", "createdAt": "2020-03-30T07:12:55Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/transport/TransportService.java", "diffHunk": "@@ -560,6 +561,33 @@ public void removeConnectionListener(TransportConnectionListener listener) {\n                                                                 final TransportRequestOptions options,\n                                                                 TransportResponseHandler<T> handler) {\n         try {\n+            if (request.getParentTask().isSet()) {\n+                final Releasable unregisterChildNode = taskManager.registerChildNode(request.getParentTask().getId(), connection.getNode());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f51b4548ef55190e34a26a4309122cdc95df32d"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk3MTcxMg==", "bodyText": "should we call this in a finally block?", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399971712", "createdAt": "2020-03-30T07:13:43Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/transport/TransportService.java", "diffHunk": "@@ -560,6 +561,33 @@ public void removeConnectionListener(TransportConnectionListener listener) {\n                                                                 final TransportRequestOptions options,\n                                                                 TransportResponseHandler<T> handler) {\n         try {\n+            if (request.getParentTask().isSet()) {\n+                final Releasable unregisterChildNode = taskManager.registerChildNode(request.getParentTask().getId(), connection.getNode());\n+                final TransportResponseHandler<T> delegate = handler;\n+                handler = new TransportResponseHandler<>() {\n+                    @Override\n+                    public void handleResponse(T response) {\n+                        unregisterChildNode.close();\n+                        delegate.handleResponse(response);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f51b4548ef55190e34a26a4309122cdc95df32d"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk3MTc4NQ==", "bodyText": "should we call this in a finally block?", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399971785", "createdAt": "2020-03-30T07:13:53Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/transport/TransportService.java", "diffHunk": "@@ -560,6 +561,33 @@ public void removeConnectionListener(TransportConnectionListener listener) {\n                                                                 final TransportRequestOptions options,\n                                                                 TransportResponseHandler<T> handler) {\n         try {\n+            if (request.getParentTask().isSet()) {\n+                final Releasable unregisterChildNode = taskManager.registerChildNode(request.getParentTask().getId(), connection.getNode());\n+                final TransportResponseHandler<T> delegate = handler;\n+                handler = new TransportResponseHandler<>() {\n+                    @Override\n+                    public void handleResponse(T response) {\n+                        unregisterChildNode.close();\n+                        delegate.handleResponse(response);\n+                    }\n+\n+                    @Override\n+                    public void handleException(TransportException exp) {\n+                        unregisterChildNode.close();\n+                        delegate.handleException(exp);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f51b4548ef55190e34a26a4309122cdc95df32d"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk3MjY5OQ==", "bodyText": "assert that cancelFuture.isDone == false before disabling blocks?", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399972699", "createdAt": "2020-03-30T07:15:45Z", "author": {"login": "ywelsch"}, "path": "server/src/test/java/org/elasticsearch/search/SearchCancellationIT.java", "diffHunk": "@@ -151,8 +151,9 @@ public void testCancellationDuringQueryPhase() throws Exception {\n             .execute();\n \n         awaitForBlock(plugins);\n-        cancelSearch(SearchAction.NAME);\n+        ActionFuture<CancelTasksResponse> cancelFuture = cancelSearch(SearchAction.NAME);\n         disableBlocks(plugins);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f51b4548ef55190e34a26a4309122cdc95df32d"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk3MzczNQ==", "bodyText": "testBanOnly...", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399973735", "createdAt": "2020-03-30T07:18:01Z", "author": {"login": "ywelsch"}, "path": "server/src/test/java/org/elasticsearch/action/admin/cluster/node/tasks/CancellableTasksIT.java", "diffHunk": "@@ -0,0 +1,381 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.action.admin.cluster.node.tasks;\n+\n+import org.elasticsearch.action.ActionFuture;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.ActionRequest;\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.action.ActionRunnable;\n+import org.elasticsearch.action.ActionType;\n+import org.elasticsearch.action.LatchedActionListener;\n+import org.elasticsearch.action.admin.cluster.node.tasks.cancel.CancelTasksResponse;\n+import org.elasticsearch.action.admin.cluster.node.tasks.list.ListTasksResponse;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.GroupedActionListener;\n+import org.elasticsearch.action.support.HandledTransportAction;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.util.concurrent.AbstractRunnable;\n+import org.elasticsearch.common.util.concurrent.ConcurrentCollections;\n+import org.elasticsearch.plugins.ActionPlugin;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.tasks.CancellableTask;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.tasks.TaskCancelledException;\n+import org.elasticsearch.tasks.TaskId;\n+import org.elasticsearch.tasks.TaskManager;\n+import org.elasticsearch.test.ESIntegTestCase;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportException;\n+import org.elasticsearch.transport.TransportResponse;\n+import org.elasticsearch.transport.TransportResponseHandler;\n+import org.elasticsearch.transport.TransportService;\n+import org.junit.Before;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.instanceOf;\n+\n+public class CancellableTasksIT extends ESIntegTestCase {\n+    static final Map<ChildRequest, CountDownLatch> arrivedLatches = ConcurrentCollections.newConcurrentMap();\n+    static final Map<ChildRequest, CountDownLatch> beforeExecuteLatches = ConcurrentCollections.newConcurrentMap();\n+    static final Map<ChildRequest, CountDownLatch> completedLatches = ConcurrentCollections.newConcurrentMap();\n+\n+    @Before\n+    public void resetTestStates() {\n+        arrivedLatches.clear();\n+        beforeExecuteLatches.clear();\n+        completedLatches.clear();\n+    }\n+\n+    public void testBandOnlyNodesWithOutstandingChildTasks() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f51b4548ef55190e34a26a4309122cdc95df32d"}, "originalPosition": 85}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "de680fc95020558a8889ca59bc89dcd2ea6537cb", "author": {"user": {"login": "dnhatn", "name": "Nhat Nguyen"}}, "url": "https://github.com/elastic/elasticsearch/commit/de680fc95020558a8889ca59bc89dcd2ea6537cb", "committedDate": "2020-03-30T12:52:25Z", "message": "fix tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "03ce7a816e1b89712ebd4057d3550646c315af2e", "author": {"user": {"login": "dnhatn", "name": "Nhat Nguyen"}}, "url": "https://github.com/elastic/elasticsearch/commit/03ce7a816e1b89712ebd4057d3550646c315af2e", "committedDate": "2020-03-30T13:00:14Z", "message": "fix logging"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "297b78726aeb4c7cae96db54e98903174745fd0b", "author": {"user": {"login": "dnhatn", "name": "Nhat Nguyen"}}, "url": "https://github.com/elastic/elasticsearch/commit/297b78726aeb4c7cae96db54e98903174745fd0b", "committedDate": "2020-03-30T14:12:49Z", "message": "restore optimization"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "226a5414320e8e4f725a1762e2226af6731a906a", "author": {"user": {"login": "dnhatn", "name": "Nhat Nguyen"}}, "url": "https://github.com/elastic/elasticsearch/commit/226a5414320e8e4f725a1762e2226af6731a906a", "committedDate": "2020-03-30T14:48:48Z", "message": "ban children"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a5af596d79d4c663cb711f60f0f1011ad22b32d0", "author": {"user": {"login": "dnhatn", "name": "Nhat Nguyen"}}, "url": "https://github.com/elastic/elasticsearch/commit/a5af596d79d4c663cb711f60f0f1011ad22b32d0", "committedDate": "2020-03-30T18:31:12Z", "message": "add wait_for_completion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ff31a93604b5fe267e04a1b3bda5f06223df755d", "author": {"user": {"login": "dnhatn", "name": "Nhat Nguyen"}}, "url": "https://github.com/elastic/elasticsearch/commit/ff31a93604b5fe267e04a1b3bda5f06223df755d", "committedDate": "2020-03-30T18:36:21Z", "message": "Merge branch 'master' into track-child-tasks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4f337decce08edd355621c9982559df34bc42ce6", "author": {"user": {"login": "dnhatn", "name": "Nhat Nguyen"}}, "url": "https://github.com/elastic/elasticsearch/commit/4f337decce08edd355621c9982559df34bc42ce6", "committedDate": "2020-03-30T18:49:13Z", "message": "Add TODO"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "627e6a498a25618ffd8e7d0bc534f2d4ff4cf8db", "author": {"user": {"login": "dnhatn", "name": "Nhat Nguyen"}}, "url": "https://github.com/elastic/elasticsearch/commit/627e6a498a25618ffd8e7d0bc534f2d4ff4cf8db", "committedDate": "2020-03-30T18:55:44Z", "message": "format"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4abd0f54c7d799ce19b9ff9161fa664e1a176f8b", "author": {"user": {"login": "dnhatn", "name": "Nhat Nguyen"}}, "url": "https://github.com/elastic/elasticsearch/commit/4abd0f54c7d799ce19b9ff9161fa664e1a176f8b", "committedDate": "2020-03-30T21:33:15Z", "message": "wait_for_completion -> wait_for_child_tasks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e6a8b7c79b07cb841b041f2acae26df113e6c068", "author": {"user": {"login": "dnhatn", "name": "Nhat Nguyen"}}, "url": "https://github.com/elastic/elasticsearch/commit/e6a8b7c79b07cb841b041f2acae26df113e6c068", "committedDate": "2020-03-30T21:35:34Z", "message": "comment"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0NDg4NDk5", "url": "https://github.com/elastic/elasticsearch/pull/54312#pullrequestreview-384488499", "createdAt": "2020-03-31T08:00:13Z", "commit": {"oid": "e6a8b7c79b07cb841b041f2acae26df113e6c068"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQwODowMDoxM1rOF-JuEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQwOTozMjoyMFrOF-NK-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDcxNTI4MA==", "bodyText": "I wonder if this message is misleading. The task could have been cancelled, but it could also have completed successfully before this request came in.", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r400715280", "createdAt": "2020-03-31T08:00:13Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java", "diffHunk": "@@ -103,127 +102,75 @@ protected void processTasks(CancelTasksRequest request, Consumer<CancellableTask\n     }\n \n     @Override\n-    protected synchronized void taskOperation(CancelTasksRequest request, CancellableTask cancellableTask,\n-            ActionListener<TaskInfo> listener) {\n+    protected void taskOperation(CancelTasksRequest request, CancellableTask cancellableTask, ActionListener<TaskInfo> listener) {\n         String nodeId = clusterService.localNode().getId();\n-        final boolean canceled;\n         if (cancellableTask.shouldCancelChildrenOnCancellation()) {\n-            DiscoveryNodes childNodes = clusterService.state().nodes();\n-            final BanLock banLock = new BanLock(childNodes.getSize(), () -> removeBanOnNodes(cancellableTask, childNodes));\n-            canceled = taskManager.cancel(cancellableTask, request.getReason(), banLock::onTaskFinished);\n-            if (canceled) {\n-                // /In case the task has some child tasks, we need to wait for until ban is set on all nodes\n-                logger.trace(\"cancelling task {} on child nodes\", cancellableTask.getId());\n-                AtomicInteger responses = new AtomicInteger(childNodes.getSize());\n-                List<Exception> failures = new ArrayList<>();\n-                setBanOnNodes(request.getReason(), cancellableTask, childNodes, new ActionListener<Void>() {\n-                    @Override\n-                    public void onResponse(Void aVoid) {\n-                        processResponse();\n-                    }\n-\n-                    @Override\n-                    public void onFailure(Exception e) {\n-                        synchronized (failures) {\n-                            failures.add(e);\n-                        }\n-                        processResponse();\n-                    }\n-\n-                    private void processResponse() {\n-                        banLock.onBanSet();\n-                        if (responses.decrementAndGet() == 0) {\n-                            if (failures.isEmpty() == false) {\n-                                IllegalStateException exception = new IllegalStateException(\"failed to cancel children of the task [\" +\n-                                    cancellableTask.getId() + \"]\");\n-                                failures.forEach(exception::addSuppressed);\n-                                listener.onFailure(exception);\n-                            } else {\n-                                listener.onResponse(cancellableTask.taskInfo(nodeId, false));\n-                            }\n-                        }\n-                    }\n-                });\n+            StepListener<Void> completedListener = new StepListener<>();\n+            GroupedActionListener<Void> groupedListener = new GroupedActionListener<>(ActionListener.map(completedListener, r -> null), 3);\n+            Collection<DiscoveryNode> childrenNodes =\n+                taskManager.startBanOnChildrenNodes(cancellableTask.getId(), () -> groupedListener.onResponse(null));\n+            boolean cancelled = taskManager.cancel(cancellableTask, request.getReason(), () -> groupedListener.onResponse(null));\n+            if (cancelled == false) {\n+                throw new IllegalStateException(\"task with id \" + cancellableTask.getId() + \" is already cancelled\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6a8b7c79b07cb841b041f2acae26df113e6c068"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDcxNjU0Mw==", "bodyText": "Another issue I have with this is that this does not play nicely with wait_for_completion. Assume someone else has cancelled the task, and you now want to wait for completion. This gives you a hard exception instead of waiting for all child tasks to complete.", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r400716543", "createdAt": "2020-03-31T08:02:20Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java", "diffHunk": "@@ -103,127 +102,75 @@ protected void processTasks(CancelTasksRequest request, Consumer<CancellableTask\n     }\n \n     @Override\n-    protected synchronized void taskOperation(CancelTasksRequest request, CancellableTask cancellableTask,\n-            ActionListener<TaskInfo> listener) {\n+    protected void taskOperation(CancelTasksRequest request, CancellableTask cancellableTask, ActionListener<TaskInfo> listener) {\n         String nodeId = clusterService.localNode().getId();\n-        final boolean canceled;\n         if (cancellableTask.shouldCancelChildrenOnCancellation()) {\n-            DiscoveryNodes childNodes = clusterService.state().nodes();\n-            final BanLock banLock = new BanLock(childNodes.getSize(), () -> removeBanOnNodes(cancellableTask, childNodes));\n-            canceled = taskManager.cancel(cancellableTask, request.getReason(), banLock::onTaskFinished);\n-            if (canceled) {\n-                // /In case the task has some child tasks, we need to wait for until ban is set on all nodes\n-                logger.trace(\"cancelling task {} on child nodes\", cancellableTask.getId());\n-                AtomicInteger responses = new AtomicInteger(childNodes.getSize());\n-                List<Exception> failures = new ArrayList<>();\n-                setBanOnNodes(request.getReason(), cancellableTask, childNodes, new ActionListener<Void>() {\n-                    @Override\n-                    public void onResponse(Void aVoid) {\n-                        processResponse();\n-                    }\n-\n-                    @Override\n-                    public void onFailure(Exception e) {\n-                        synchronized (failures) {\n-                            failures.add(e);\n-                        }\n-                        processResponse();\n-                    }\n-\n-                    private void processResponse() {\n-                        banLock.onBanSet();\n-                        if (responses.decrementAndGet() == 0) {\n-                            if (failures.isEmpty() == false) {\n-                                IllegalStateException exception = new IllegalStateException(\"failed to cancel children of the task [\" +\n-                                    cancellableTask.getId() + \"]\");\n-                                failures.forEach(exception::addSuppressed);\n-                                listener.onFailure(exception);\n-                            } else {\n-                                listener.onResponse(cancellableTask.taskInfo(nodeId, false));\n-                            }\n-                        }\n-                    }\n-                });\n+            StepListener<Void> completedListener = new StepListener<>();\n+            GroupedActionListener<Void> groupedListener = new GroupedActionListener<>(ActionListener.map(completedListener, r -> null), 3);\n+            Collection<DiscoveryNode> childrenNodes =\n+                taskManager.startBanOnChildrenNodes(cancellableTask.getId(), () -> groupedListener.onResponse(null));\n+            boolean cancelled = taskManager.cancel(cancellableTask, request.getReason(), () -> groupedListener.onResponse(null));\n+            if (cancelled == false) {\n+                throw new IllegalStateException(\"task with id \" + cancellableTask.getId() + \" is already cancelled\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDcxNTI4MA=="}, "originalCommit": {"oid": "e6a8b7c79b07cb841b041f2acae26df113e6c068"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDcxNjk2MA==", "bodyText": "basis", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r400716960", "createdAt": "2020-03-31T08:03:02Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java", "diffHunk": "@@ -103,127 +102,75 @@ protected void processTasks(CancelTasksRequest request, Consumer<CancellableTask\n     }\n \n     @Override\n-    protected synchronized void taskOperation(CancelTasksRequest request, CancellableTask cancellableTask,\n-            ActionListener<TaskInfo> listener) {\n+    protected void taskOperation(CancelTasksRequest request, CancellableTask cancellableTask, ActionListener<TaskInfo> listener) {\n         String nodeId = clusterService.localNode().getId();\n-        final boolean canceled;\n         if (cancellableTask.shouldCancelChildrenOnCancellation()) {\n-            DiscoveryNodes childNodes = clusterService.state().nodes();\n-            final BanLock banLock = new BanLock(childNodes.getSize(), () -> removeBanOnNodes(cancellableTask, childNodes));\n-            canceled = taskManager.cancel(cancellableTask, request.getReason(), banLock::onTaskFinished);\n-            if (canceled) {\n-                // /In case the task has some child tasks, we need to wait for until ban is set on all nodes\n-                logger.trace(\"cancelling task {} on child nodes\", cancellableTask.getId());\n-                AtomicInteger responses = new AtomicInteger(childNodes.getSize());\n-                List<Exception> failures = new ArrayList<>();\n-                setBanOnNodes(request.getReason(), cancellableTask, childNodes, new ActionListener<Void>() {\n-                    @Override\n-                    public void onResponse(Void aVoid) {\n-                        processResponse();\n-                    }\n-\n-                    @Override\n-                    public void onFailure(Exception e) {\n-                        synchronized (failures) {\n-                            failures.add(e);\n-                        }\n-                        processResponse();\n-                    }\n-\n-                    private void processResponse() {\n-                        banLock.onBanSet();\n-                        if (responses.decrementAndGet() == 0) {\n-                            if (failures.isEmpty() == false) {\n-                                IllegalStateException exception = new IllegalStateException(\"failed to cancel children of the task [\" +\n-                                    cancellableTask.getId() + \"]\");\n-                                failures.forEach(exception::addSuppressed);\n-                                listener.onFailure(exception);\n-                            } else {\n-                                listener.onResponse(cancellableTask.taskInfo(nodeId, false));\n-                            }\n-                        }\n-                    }\n-                });\n+            StepListener<Void> completedListener = new StepListener<>();\n+            GroupedActionListener<Void> groupedListener = new GroupedActionListener<>(ActionListener.map(completedListener, r -> null), 3);\n+            Collection<DiscoveryNode> childrenNodes =\n+                taskManager.startBanOnChildrenNodes(cancellableTask.getId(), () -> groupedListener.onResponse(null));\n+            boolean cancelled = taskManager.cancel(cancellableTask, request.getReason(), () -> groupedListener.onResponse(null));\n+            if (cancelled == false) {\n+                throw new IllegalStateException(\"task with id \" + cancellableTask.getId() + \" is already cancelled\");\n             }\n-        }  else {\n-            canceled = taskManager.cancel(cancellableTask, request.getReason(),\n+            StepListener<Void> banOnNodesListener = new StepListener<>();\n+            setBanOnNodes(request.getReason(), cancellableTask, childrenNodes, banOnNodesListener);\n+            banOnNodesListener.whenComplete(groupedListener::onResponse, groupedListener::onFailure);\n+            // We remove bans after all child tasks are completed although in theory we can do it on a per-node basic.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6a8b7c79b07cb841b041f2acae26df113e6c068"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc3MTgzNQ==", "bodyText": "I prefer the wait_for_completion, as this is also about completing the cancellation of the parent task. Also, I think that the default should be false (also needs to be documented).", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r400771835", "createdAt": "2020-03-31T09:32:20Z", "author": {"login": "ywelsch"}, "path": "rest-api-spec/src/main/resources/rest-api-spec/api/tasks.cancel.json", "diffHunk": "@@ -39,6 +39,10 @@\n       \"parent_task_id\":{\n         \"type\":\"string\",\n         \"description\":\"Cancel tasks with specified parent task id (node_id:task_number). Set to -1 to cancel all.\"\n+      },\n+      \"wait_for_child_tasks\": {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6a8b7c79b07cb841b041f2acae26df113e6c068"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0NjY4MTcx", "url": "https://github.com/elastic/elasticsearch/pull/54312#pullrequestreview-384668171", "createdAt": "2020-03-31T12:10:12Z", "commit": {"oid": "e6a8b7c79b07cb841b041f2acae26df113e6c068"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxMjoxMDoxMlrOF-Snmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxMjoxNjoxNVrOF-S1EA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg2MTA4Mw==", "bodyText": "shouldn't we get the default value from the cancelTasksRequest so we don't duplicate it?", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r400861083", "createdAt": "2020-03-31T12:10:12Z", "author": {"login": "javanna"}, "path": "server/src/main/java/org/elasticsearch/rest/action/admin/cluster/RestCancelTasksAction.java", "diffHunk": "@@ -66,6 +66,7 @@ public RestChannelConsumer prepareRequest(final RestRequest request, final NodeC\n         cancelTasksRequest.setNodes(nodesIds);\n         cancelTasksRequest.setActions(actions);\n         cancelTasksRequest.setParentTaskId(parentTaskId);\n+        cancelTasksRequest.setWaitForChildTasks(request.paramAsBoolean(\"wait_for_child_tasks\", true));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6a8b7c79b07cb841b041f2acae26df113e6c068"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg2NDUyOA==", "bodyText": "I am curious about this: the child tasks are already cancelled or banned before the delete async search call returns?", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r400864528", "createdAt": "2020-03-31T12:16:15Z", "author": {"login": "javanna"}, "path": "x-pack/plugin/async-search/src/test/java/org/elasticsearch/xpack/search/AsyncSearchActionTests.java", "diffHunk": "@@ -190,8 +193,11 @@ public void testDeleteCancelRunningTask() throws Exception {\n         SearchResponseIterator it =\n             assertBlockingIterator(indexName, new SearchSourceBuilder(), randomBoolean() ? 1 : 0, 2);\n         initial = it.next();\n-        deleteAsyncSearch(initial.getId());\n+        ActionFuture<AcknowledgedResponse> cancelFuture =\n+            client().execute(DeleteAsyncSearchAction.INSTANCE, new DeleteAsyncSearchAction.Request(initial.getId()));\n+        ensureChildTasksCancelledOrBanned(AsyncSearchId.decode(initial.getId()).getTaskId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6a8b7c79b07cb841b041f2acae26df113e6c068"}, "originalPosition": 25}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9a55fe41951f6bf0704ac5fe3690aa1206f832c5", "author": {"user": {"login": "dnhatn", "name": "Nhat Nguyen"}}, "url": "https://github.com/elastic/elasticsearch/commit/9a55fe41951f6bf0704ac5fe3690aa1206f832c5", "committedDate": "2020-03-31T18:26:03Z", "message": "Allow cancel multiple times"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a01325e069ff433165a0bdbc0da2854da8db729e", "author": {"user": {"login": "dnhatn", "name": "Nhat Nguyen"}}, "url": "https://github.com/elastic/elasticsearch/commit/a01325e069ff433165a0bdbc0da2854da8db729e", "committedDate": "2020-03-31T18:26:03Z", "message": "wording"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8cff3b0a4998ef4f5de015c484c2f4389a807ce3", "author": {"user": {"login": "dnhatn", "name": "Nhat Nguyen"}}, "url": "https://github.com/elastic/elasticsearch/commit/8cff3b0a4998ef4f5de015c484c2f4389a807ce3", "committedDate": "2020-03-31T19:44:28Z", "message": "wait_for_completion to false"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b07d962385bea4ab2acc0afa887e2952baf3e44d", "author": {"user": {"login": "dnhatn", "name": "Nhat Nguyen"}}, "url": "https://github.com/elastic/elasticsearch/commit/b07d962385bea4ab2acc0afa887e2952baf3e44d", "committedDate": "2020-03-31T19:44:41Z", "message": "Merge branch 'master' into track-child-tasks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "76f8fd128407aee9e3d7d99eaf7e89c55646bb8d", "author": {"user": {"login": "dnhatn", "name": "Nhat Nguyen"}}, "url": "https://github.com/elastic/elasticsearch/commit/76f8fd128407aee9e3d7d99eaf7e89c55646bb8d", "committedDate": "2020-03-31T20:17:36Z", "message": "allow mock"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4572f23d998f8a2c4da28b2afe4132cfae1d64ec", "author": {"user": {"login": "dnhatn", "name": "Nhat Nguyen"}}, "url": "https://github.com/elastic/elasticsearch/commit/4572f23d998f8a2c4da28b2afe4132cfae1d64ec", "committedDate": "2020-03-31T22:02:01Z", "message": "fix docs"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg1Mzk1NTA3", "url": "https://github.com/elastic/elasticsearch/pull/54312#pullrequestreview-385395507", "createdAt": "2020-04-01T09:05:11Z", "commit": {"oid": "4572f23d998f8a2c4da28b2afe4132cfae1d64ec"}, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQwOTowNToxMVrOF-3ZCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQwOTozMTowMVrOF-4XrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ2MzU2Mg==", "bodyText": "Use this in TasksRequestConvertersTests?", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r401463562", "createdAt": "2020-04-01T09:05:11Z", "author": {"login": "ywelsch"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/tasks/CancelTasksRequest.java", "diffHunk": "@@ -138,13 +150,21 @@ public Builder withNodesFiltered(List<String> nodes){\n             return this;\n         }\n \n+        public Builder withWaitForCompletion(boolean waitForCompletion) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4572f23d998f8a2c4da28b2afe4132cfae1d64ec"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ2NTMzNQ==", "bodyText": "call this getWaitForCompletion", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r401465335", "createdAt": "2020-04-01T09:08:11Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/CancelTasksRequest.java", "diffHunk": "@@ -68,4 +77,16 @@ public CancelTasksRequest setReason(String reason) {\n     public String getReason() {\n         return reason;\n     }\n+\n+    /**\n+     * If {@code true}, the request blocks until the cancellation of the task and its child tasks is completed.\n+     * Otherwise, the request can return soon after the cancellation is started. Defaults to {@code false}.\n+     */\n+    public void setWaitForCompletion(boolean waitForCompletion) {\n+        this.waitForCompletion = waitForCompletion;\n+    }\n+\n+    public boolean waitForChildTasks() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4572f23d998f8a2c4da28b2afe4132cfae1d64ec"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ2NTQ2OA==", "bodyText": "instead of introducing this constant, just use cancelTasksRequest.getWaitForCompletion() here", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r401465468", "createdAt": "2020-04-01T09:08:26Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/rest/action/admin/cluster/RestCancelTasksAction.java", "diffHunk": "@@ -66,6 +66,8 @@ public RestChannelConsumer prepareRequest(final RestRequest request, final NodeC\n         cancelTasksRequest.setNodes(nodesIds);\n         cancelTasksRequest.setActions(actions);\n         cancelTasksRequest.setParentTaskId(parentTaskId);\n+        cancelTasksRequest.setWaitForCompletion(\n+            request.paramAsBoolean(\"wait_for_child_tasks\", CancelTasksRequest.DEFAULT_WAIT_FOR_COMPLETION));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4572f23d998f8a2c4da28b2afe4132cfae1d64ec"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ3OTU5Ng==", "bodyText": "As well as in TasksClientDocumentationIT to document it there as well?", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r401479596", "createdAt": "2020-04-01T09:31:01Z", "author": {"login": "ywelsch"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/tasks/CancelTasksRequest.java", "diffHunk": "@@ -138,13 +150,21 @@ public Builder withNodesFiltered(List<String> nodes){\n             return this;\n         }\n \n+        public Builder withWaitForCompletion(boolean waitForCompletion) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ2MzU2Mg=="}, "originalCommit": {"oid": "4572f23d998f8a2c4da28b2afe4132cfae1d64ec"}, "originalPosition": 59}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2c8c1cdb941c2389fae5aad4462d0ba8c7d2fd72", "author": {"user": {"login": "dnhatn", "name": "Nhat Nguyen"}}, "url": "https://github.com/elastic/elasticsearch/commit/2c8c1cdb941c2389fae5aad4462d0ba8c7d2fd72", "committedDate": "2020-04-01T13:18:46Z", "message": "nits"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1439, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}