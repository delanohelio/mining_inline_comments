{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU1NzE4Mjg1", "number": 60121, "title": "Make MlDailyMaintenanceService delete jobs that are in deleting state anyway", "bodyText": "This PR makes MlDailyMaintenanceService delete ML jobs (anomaly detectors) that are in deleting state but do not have corresponding deletion task. This effectively recreates unfinished deletion tasks allowing jobs to disappear.\nAdditionally, the PR:\n\nMakes DataDescription.Builder methods chainable\nSets description on analytics jobs deletion tasks to make them easily distinguishable in tasks list\nRemoves unneeded JobDeletionTask.java\nAdds a test that verifies that two comma-separated job ids are not supported by the DeleteJobAction\n\nRelates #42840", "createdAt": "2020-07-23T13:44:44Z", "url": "https://github.com/elastic/elasticsearch/pull/60121", "merged": true, "mergeCommit": {"oid": "b487990941e50533c1a8198a129bfee10ece0422"}, "closed": true, "closedAt": "2020-07-30T07:08:28Z", "author": {"login": "przemekwitek"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc4_AS7gBqjM1ODkxMzI3NTM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc5r-xlgFqTQ1NzU4NDk0NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a99b9260d6209725f6e002f277aa66f5b07dfe0d", "author": {"user": {"login": "przemekwitek", "name": "Przemys\u0142aw Witek"}}, "url": "https://github.com/elastic/elasticsearch/commit/a99b9260d6209725f6e002f277aa66f5b07dfe0d", "committedDate": "2020-07-23T13:43:27Z", "message": "Make MlDailyMaintenanceService delete jobs that are in deleting state anyway"}, "afterCommit": {"oid": "d341cd7fd639e6a0a9f8d740752131d1648bcf91", "author": {"user": {"login": "przemekwitek", "name": "Przemys\u0142aw Witek"}}, "url": "https://github.com/elastic/elasticsearch/commit/d341cd7fd639e6a0a9f8d740752131d1648bcf91", "committedDate": "2020-07-27T10:05:21Z", "message": "Make MlDailyMaintenanceService delete jobs that are in deleting state anyway"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1Njg5Mjc1", "url": "https://github.com/elastic/elasticsearch/pull/60121#pullrequestreview-455689275", "createdAt": "2020-07-27T11:15:36Z", "commit": {"oid": "d341cd7fd639e6a0a9f8d740752131d1648bcf91"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxMToxNTozNlrOG3eHaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxMToxNTozNlrOG3eHaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgxODI4MA==", "bodyText": "why was this changed to just 10 seconds into the future?", "url": "https://github.com/elastic/elasticsearch/pull/60121#discussion_r460818280", "createdAt": "2020-07-27T11:15:36Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/MlDailyMaintenanceService.java", "diffHunk": "@@ -88,11 +102,7 @@ private static TimeValue delayToNextTime(ClusterName clusterName) {\n         int minutesOffset = random.ints(0, MAX_TIME_OFFSET_MINUTES).findFirst().getAsInt();\n \n         ZonedDateTime now = ZonedDateTime.now(Clock.systemDefaultZone());\n-        ZonedDateTime next = now.plusDays(1)\n-            .toLocalDate()\n-            .atStartOfDay(now.getZone())\n-            .plusMinutes(30)\n-            .plusMinutes(minutesOffset);\n+        ZonedDateTime next = now.plusSeconds(10);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d341cd7fd639e6a0a9f8d740752131d1648bcf91"}, "originalPosition": 50}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1NzA2MzM0", "url": "https://github.com/elastic/elasticsearch/pull/60121#pullrequestreview-455706334", "createdAt": "2020-07-27T11:44:54Z", "commit": {"oid": "8018e0bb5823ba1ec95b785142f1c6f450efac88"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxMTo0NDo1NVrOG3e9-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxMTo0NDo1NVrOG3e9-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgzMjI1MA==", "bodyText": "This type of action should be rare, so an info log here would be good. This way we know when ALL longer running maintenance tasks are complete since now we have two that run concurrently.\nsince you are using an AcknowledgedResponse, a predicate on acknowledged would work.", "url": "https://github.com/elastic/elasticsearch/pull/60121#discussion_r460832250", "createdAt": "2020-07-27T11:44:55Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/MlDailyMaintenanceService.java", "diffHunk": "@@ -136,32 +150,107 @@ private void triggerTasks() {\n                 return;\n             }\n             LOGGER.info(\"triggering scheduled [ML] maintenance tasks\");\n-            executeAsyncWithOrigin(client,\n-                ML_ORIGIN,\n-                DeleteExpiredDataAction.INSTANCE,\n-                new DeleteExpiredDataAction.Request(deleteExpiredDataRequestsPerSecond, TimeValue.timeValueHours(8)),\n+            triggerDeleteExpiredDataTask();\n+            triggerDeleteJobsInStateDeletingWithoutDeletionTask(\n                 ActionListener.wrap(\n-                    response -> {\n-                        if (response.isDeleted()) {\n-                            LOGGER.info(\"Successfully completed [ML] maintenance tasks\");\n-                        } else {\n-                            LOGGER.info(\"Halting [ML] maintenance tasks before completion as elapsed time is too great\");\n-                        }\n-                    },\n-                    e -> LOGGER.error(\"An error occurred during maintenance tasks execution\", e)));\n-            auditUnassignedMlTasks(clusterService.state());\n+                    response -> {},", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8018e0bb5823ba1ec95b785142f1c6f450efac88"}, "originalPosition": 61}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1NzEyNDU1", "url": "https://github.com/elastic/elasticsearch/pull/60121#pullrequestreview-455712455", "createdAt": "2020-07-27T11:55:09Z", "commit": {"oid": "8018e0bb5823ba1ec95b785142f1c6f450efac88"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxMTo1NTowOVrOG3fRGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxMjowMToyOVrOG3fc0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgzNzE0NQ==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/elastic/elasticsearch/pull/60121#discussion_r460837145", "createdAt": "2020-07-27T11:55:09Z", "author": {"login": "davidkyle"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/action/DeleteDataFrameAnalyticsAction.java", "diffHunk": "@@ -77,6 +78,11 @@ public ActionRequestValidationException validate() {\n             return null;\n         }\n \n+        @Override\n+        public String getDescription() {\n+            return DELETION_TASK_DESCRIPTION_PREFIX + id;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8018e0bb5823ba1ec95b785142f1c6f450efac88"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDg0MDE0Nw==", "bodyText": "I'm not sure this will fail the test as the response does not come on the main test thread it will cause the assertion failure on a different thread. I could be wrong can you check please.\nCompare with https://github.com/elastic/elasticsearch/blob/master/x-pack/plugin/ml/src/test/java/org/elasticsearch/xpack/ml/MlSingleNodeTestCase.java#L121", "url": "https://github.com/elastic/elasticsearch/pull/60121#discussion_r460840147", "createdAt": "2020-07-27T12:01:29Z", "author": {"login": "davidkyle"}, "path": "x-pack/plugin/ml/qa/native-multi-node-tests/src/test/java/org/elasticsearch/xpack/ml/integration/MlDailyMaintenanceServiceIT.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.ml.integration;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.cluster.ClusterName;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.common.util.concurrent.EsExecutors;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.xpack.core.ml.job.config.AnalysisConfig;\n+import org.elasticsearch.xpack.core.ml.job.config.DataDescription;\n+import org.elasticsearch.xpack.core.ml.job.config.Detector;\n+import org.elasticsearch.xpack.core.ml.job.config.Job;\n+import org.elasticsearch.xpack.ml.MlAssignmentNotifier;\n+import org.elasticsearch.xpack.ml.MlDailyMaintenanceService;\n+import org.elasticsearch.xpack.ml.job.persistence.JobConfigProvider;\n+import org.junit.Before;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.Consumer;\n+\n+import static java.util.stream.Collectors.toSet;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+public class MlDailyMaintenanceServiceIT extends MlNativeAutodetectIntegTestCase {\n+\n+    private JobConfigProvider jobConfigProvider;\n+    private ThreadPool threadPool;\n+\n+    @Before\n+    public void setUpMocks() {\n+        jobConfigProvider = new JobConfigProvider(client(), xContentRegistry());\n+        threadPool = mock(ThreadPool.class);\n+        ExecutorService directExecutorService = EsExecutors.newDirectExecutorService();\n+        when(threadPool.generic()).thenReturn(directExecutorService);\n+    }\n+\n+    public void testTriggerDeleteJobsInStateDeletingWithoutDeletionTask() throws InterruptedException {\n+        MlDailyMaintenanceService maintenanceService =\n+            new MlDailyMaintenanceService(\n+                settings(Version.CURRENT).build(),\n+                ClusterName.DEFAULT,\n+                threadPool,\n+                client(),\n+                mock(ClusterService.class),\n+                mock(MlAssignmentNotifier.class));\n+\n+        putJob(\"maintenance-test-1\");\n+        putJob(\"maintenance-test-2\");\n+        putJob(\"maintenance-test-3\");\n+        assertThat(getJobIds(), containsInAnyOrder(\"maintenance-test-1\", \"maintenance-test-2\", \"maintenance-test-3\"));\n+\n+        blockingCall(maintenanceService::triggerDeleteJobsInStateDeletingWithoutDeletionTask);\n+        assertThat(getJobIds(), containsInAnyOrder(\"maintenance-test-1\", \"maintenance-test-2\", \"maintenance-test-3\"));\n+\n+        this.<Boolean>blockingCall(listener -> jobConfigProvider.markJobAsDeleting(\"maintenance-test-2\", listener));\n+        this.<Boolean>blockingCall(listener -> jobConfigProvider.markJobAsDeleting(\"maintenance-test-3\", listener));\n+        assertThat(getJobIds(), containsInAnyOrder(\"maintenance-test-1\", \"maintenance-test-2\", \"maintenance-test-3\"));\n+        assertThat(getJob(\"maintenance-test-1\").get(0).isDeleting(), is(false));\n+        assertThat(getJob(\"maintenance-test-2\").get(0).isDeleting(), is(true));\n+        assertThat(getJob(\"maintenance-test-3\").get(0).isDeleting(), is(true));\n+\n+        blockingCall(maintenanceService::triggerDeleteJobsInStateDeletingWithoutDeletionTask);\n+        assertThat(getJobIds(), containsInAnyOrder(\"maintenance-test-1\"));\n+    }\n+\n+    private <T> void blockingCall(Consumer<ActionListener<T>> function) throws InterruptedException {\n+        CountDownLatch latch = new CountDownLatch(1);\n+        ActionListener<T> listener = ActionListener.wrap(\n+            r -> {\n+                latch.countDown();\n+            },\n+            e -> {\n+                latch.countDown();\n+                fail(e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8018e0bb5823ba1ec95b785142f1c6f450efac88"}, "originalPosition": 87}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8018e0bb5823ba1ec95b785142f1c6f450efac88", "author": {"user": {"login": "przemekwitek", "name": "Przemys\u0142aw Witek"}}, "url": "https://github.com/elastic/elasticsearch/commit/8018e0bb5823ba1ec95b785142f1c6f450efac88", "committedDate": "2020-07-27T11:31:26Z", "message": "Revert debug-related change"}, "afterCommit": {"oid": "8cb8b50068fa283f17f992856d747bda1d130ab0", "author": {"user": {"login": "przemekwitek", "name": "Przemys\u0142aw Witek"}}, "url": "https://github.com/elastic/elasticsearch/commit/8cb8b50068fa283f17f992856d747bda1d130ab0", "committedDate": "2020-07-28T09:29:14Z", "message": "Apply review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU2NDIwMDc1", "url": "https://github.com/elastic/elasticsearch/pull/60121#pullrequestreview-456420075", "createdAt": "2020-07-28T08:37:01Z", "commit": {"oid": "8018e0bb5823ba1ec95b785142f1c6f450efac88"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwODozNzowMVrOG4CdiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwOToxNDoyOFrOG4D9HA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQxMzc2OA==", "bodyText": "Done.\nI've put the log message in triggerDeleteJobsInStateDeletingWithoutDeletionTask method, depending on the value of isAcknowledged.", "url": "https://github.com/elastic/elasticsearch/pull/60121#discussion_r461413768", "createdAt": "2020-07-28T08:37:01Z", "author": {"login": "przemekwitek"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/MlDailyMaintenanceService.java", "diffHunk": "@@ -136,32 +150,107 @@ private void triggerTasks() {\n                 return;\n             }\n             LOGGER.info(\"triggering scheduled [ML] maintenance tasks\");\n-            executeAsyncWithOrigin(client,\n-                ML_ORIGIN,\n-                DeleteExpiredDataAction.INSTANCE,\n-                new DeleteExpiredDataAction.Request(deleteExpiredDataRequestsPerSecond, TimeValue.timeValueHours(8)),\n+            triggerDeleteExpiredDataTask();\n+            triggerDeleteJobsInStateDeletingWithoutDeletionTask(\n                 ActionListener.wrap(\n-                    response -> {\n-                        if (response.isDeleted()) {\n-                            LOGGER.info(\"Successfully completed [ML] maintenance tasks\");\n-                        } else {\n-                            LOGGER.info(\"Halting [ML] maintenance tasks before completion as elapsed time is too great\");\n-                        }\n-                    },\n-                    e -> LOGGER.error(\"An error occurred during maintenance tasks execution\", e)));\n-            auditUnassignedMlTasks(clusterService.state());\n+                    response -> {},", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgzMjI1MA=="}, "originalCommit": {"oid": "8018e0bb5823ba1ec95b785142f1c6f450efac88"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQzODIzNg==", "bodyText": "I agree it's safer to assert on the main test thread so I changed it the way you suggested.\nNow the code is very similar between my blockingCall and MlSingleNodeTestCase::blockingCall. Do you think it's worth extracting this method to some common place between single-node and multi-node tests?", "url": "https://github.com/elastic/elasticsearch/pull/60121#discussion_r461438236", "createdAt": "2020-07-28T09:14:28Z", "author": {"login": "przemekwitek"}, "path": "x-pack/plugin/ml/qa/native-multi-node-tests/src/test/java/org/elasticsearch/xpack/ml/integration/MlDailyMaintenanceServiceIT.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.ml.integration;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.cluster.ClusterName;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.common.util.concurrent.EsExecutors;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.xpack.core.ml.job.config.AnalysisConfig;\n+import org.elasticsearch.xpack.core.ml.job.config.DataDescription;\n+import org.elasticsearch.xpack.core.ml.job.config.Detector;\n+import org.elasticsearch.xpack.core.ml.job.config.Job;\n+import org.elasticsearch.xpack.ml.MlAssignmentNotifier;\n+import org.elasticsearch.xpack.ml.MlDailyMaintenanceService;\n+import org.elasticsearch.xpack.ml.job.persistence.JobConfigProvider;\n+import org.junit.Before;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.Consumer;\n+\n+import static java.util.stream.Collectors.toSet;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+public class MlDailyMaintenanceServiceIT extends MlNativeAutodetectIntegTestCase {\n+\n+    private JobConfigProvider jobConfigProvider;\n+    private ThreadPool threadPool;\n+\n+    @Before\n+    public void setUpMocks() {\n+        jobConfigProvider = new JobConfigProvider(client(), xContentRegistry());\n+        threadPool = mock(ThreadPool.class);\n+        ExecutorService directExecutorService = EsExecutors.newDirectExecutorService();\n+        when(threadPool.generic()).thenReturn(directExecutorService);\n+    }\n+\n+    public void testTriggerDeleteJobsInStateDeletingWithoutDeletionTask() throws InterruptedException {\n+        MlDailyMaintenanceService maintenanceService =\n+            new MlDailyMaintenanceService(\n+                settings(Version.CURRENT).build(),\n+                ClusterName.DEFAULT,\n+                threadPool,\n+                client(),\n+                mock(ClusterService.class),\n+                mock(MlAssignmentNotifier.class));\n+\n+        putJob(\"maintenance-test-1\");\n+        putJob(\"maintenance-test-2\");\n+        putJob(\"maintenance-test-3\");\n+        assertThat(getJobIds(), containsInAnyOrder(\"maintenance-test-1\", \"maintenance-test-2\", \"maintenance-test-3\"));\n+\n+        blockingCall(maintenanceService::triggerDeleteJobsInStateDeletingWithoutDeletionTask);\n+        assertThat(getJobIds(), containsInAnyOrder(\"maintenance-test-1\", \"maintenance-test-2\", \"maintenance-test-3\"));\n+\n+        this.<Boolean>blockingCall(listener -> jobConfigProvider.markJobAsDeleting(\"maintenance-test-2\", listener));\n+        this.<Boolean>blockingCall(listener -> jobConfigProvider.markJobAsDeleting(\"maintenance-test-3\", listener));\n+        assertThat(getJobIds(), containsInAnyOrder(\"maintenance-test-1\", \"maintenance-test-2\", \"maintenance-test-3\"));\n+        assertThat(getJob(\"maintenance-test-1\").get(0).isDeleting(), is(false));\n+        assertThat(getJob(\"maintenance-test-2\").get(0).isDeleting(), is(true));\n+        assertThat(getJob(\"maintenance-test-3\").get(0).isDeleting(), is(true));\n+\n+        blockingCall(maintenanceService::triggerDeleteJobsInStateDeletingWithoutDeletionTask);\n+        assertThat(getJobIds(), containsInAnyOrder(\"maintenance-test-1\"));\n+    }\n+\n+    private <T> void blockingCall(Consumer<ActionListener<T>> function) throws InterruptedException {\n+        CountDownLatch latch = new CountDownLatch(1);\n+        ActionListener<T> listener = ActionListener.wrap(\n+            r -> {\n+                latch.countDown();\n+            },\n+            e -> {\n+                latch.countDown();\n+                fail(e.getMessage());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDg0MDE0Nw=="}, "originalCommit": {"oid": "8018e0bb5823ba1ec95b785142f1c6f450efac88"}, "originalPosition": 87}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU2NTg3MDQ4", "url": "https://github.com/elastic/elasticsearch/pull/60121#pullrequestreview-456587048", "createdAt": "2020-07-28T12:37:42Z", "commit": {"oid": "4f4dcd60f9af1836be0d4ad720e7a526da5fe001"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU2NTc5MjAw", "url": "https://github.com/elastic/elasticsearch/pull/60121#pullrequestreview-456579200", "createdAt": "2020-07-28T12:26:56Z", "commit": {"oid": "8cb8b50068fa283f17f992856d747bda1d130ab0"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxMjoyNjo1N1rOG4KITQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxMjo0NTo0MVrOG4K0dA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTUzOTQwNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            e -> LOGGER.error(\"An error occurred during maintenance tasks execution\", e)\n          \n          \n            \n                            e -> LOGGER.error(\"An error occurred during [ML] maintenance tasks execution\", e)", "url": "https://github.com/elastic/elasticsearch/pull/60121#discussion_r461539405", "createdAt": "2020-07-28T12:26:57Z", "author": {"login": "droberts195"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/MlDailyMaintenanceService.java", "diffHunk": "@@ -136,32 +149,122 @@ private void triggerTasks() {\n                 return;\n             }\n             LOGGER.info(\"triggering scheduled [ML] maintenance tasks\");\n-            executeAsyncWithOrigin(client,\n-                ML_ORIGIN,\n-                DeleteExpiredDataAction.INSTANCE,\n-                new DeleteExpiredDataAction.Request(deleteExpiredDataRequestsPerSecond, TimeValue.timeValueHours(8)),\n-                ActionListener.wrap(\n-                    response -> {\n-                        if (response.isDeleted()) {\n-                            LOGGER.info(\"Successfully completed [ML] maintenance tasks\");\n-                        } else {\n-                            LOGGER.info(\"Halting [ML] maintenance tasks before completion as elapsed time is too great\");\n-                        }\n-                    },\n-                    e -> LOGGER.error(\"An error occurred during maintenance tasks execution\", e)));\n-            auditUnassignedMlTasks(clusterService.state());\n+\n+            // Step 3: Log whether the tasks have finished\n+            ActionListener<AcknowledgedResponse> finalListener = ActionListener.wrap(\n+                unused -> LOGGER.info(\"Completed [ML] maintenance tasks\"),\n+                e -> LOGGER.error(\"An error occurred during maintenance tasks execution\", e)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8cb8b50068fa283f17f992856d747bda1d130ab0"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTU0MzUyNg==", "bodyText": "If we ever see this in a log it will frustrate us.  We will want to know which ones failed.  The low level error logging for the failure might be on a different node in the cluster that we haven't been sent the logs for.  So this should list the job IDs that failed to be deleted.", "url": "https://github.com/elastic/elasticsearch/pull/60121#discussion_r461543526", "createdAt": "2020-07-28T12:33:47Z", "author": {"login": "droberts195"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/MlDailyMaintenanceService.java", "diffHunk": "@@ -136,32 +149,127 @@ private void triggerTasks() {\n                 return;\n             }\n             LOGGER.info(\"triggering scheduled [ML] maintenance tasks\");\n-            executeAsyncWithOrigin(client,\n-                ML_ORIGIN,\n-                DeleteExpiredDataAction.INSTANCE,\n-                new DeleteExpiredDataAction.Request(deleteExpiredDataRequestsPerSecond, TimeValue.timeValueHours(8)),\n-                ActionListener.wrap(\n-                    response -> {\n-                        if (response.isDeleted()) {\n-                            LOGGER.info(\"Successfully completed [ML] maintenance tasks\");\n-                        } else {\n-                            LOGGER.info(\"Halting [ML] maintenance tasks before completion as elapsed time is too great\");\n-                        }\n-                    },\n-                    e -> LOGGER.error(\"An error occurred during maintenance tasks execution\", e)));\n-            auditUnassignedMlTasks(clusterService.state());\n+\n+            // Step 3: Log whether the tasks have finished\n+            ActionListener<AcknowledgedResponse> finalListener = ActionListener.wrap(\n+                unused -> LOGGER.info(\"Completed [ML] maintenance tasks\"),\n+                e -> LOGGER.error(\"An error occurred during maintenance tasks execution\", e)\n+            );\n+\n+            // Step 2: Delete expired data\n+            ActionListener<AcknowledgedResponse> deleteJobsListener = ActionListener.wrap(\n+                unused -> triggerDeleteExpiredDataTask(finalListener),\n+                e -> {\n+                    LOGGER.info(\"[ML] maintenance task: triggerDeleteJobsInStateDeletingWithoutDeletionTask failed\", e);\n+                    // Note: Steps 1 and 2 are independent of each other and step 2 is executed even if step 1 failed.\n+                    triggerDeleteExpiredDataTask(finalListener);\n+                }\n+            );\n+\n+            // Step 1: Delete jobs that are in deleting state\n+            triggerDeleteJobsInStateDeletingWithoutDeletionTask(deleteJobsListener);\n+\n+            auditUnassignedMlTasks();\n         } finally {\n             scheduleNext();\n         }\n     }\n \n+    private void triggerDeleteExpiredDataTask(ActionListener<AcknowledgedResponse> finalListener) {\n+        ActionListener<DeleteExpiredDataAction.Response> deleteExpiredDataActionListener = ActionListener.wrap(\n+            deleteExpiredDataResponse -> {\n+                if (deleteExpiredDataResponse.isDeleted()) {\n+                    LOGGER.info(\"Successfully completed [ML] maintenance task: triggerDeleteExpiredDataTask\");\n+                } else {\n+                    LOGGER.info(\"Halting [ML] maintenance tasks before completion as elapsed time is too great\");\n+                }\n+                finalListener.onResponse(new AcknowledgedResponse(true));\n+            },\n+            finalListener::onFailure\n+        );\n+\n+        executeAsyncWithOrigin(\n+            client,\n+            ML_ORIGIN,\n+            DeleteExpiredDataAction.INSTANCE,\n+            new DeleteExpiredDataAction.Request(deleteExpiredDataRequestsPerSecond, TimeValue.timeValueHours(8)),\n+            deleteExpiredDataActionListener);\n+    }\n+\n+    // Visible for testing\n+    public void triggerDeleteJobsInStateDeletingWithoutDeletionTask(ActionListener<AcknowledgedResponse> finalListener) {\n+        SetOnce<Set<String>> jobsInStateDeletingHolder = new SetOnce<>();\n+\n+        ActionListener<List<AcknowledgedResponse>> deleteJobsActionListener = ActionListener.wrap(\n+            deleteJobsResponses -> {\n+                if (deleteJobsResponses.stream().allMatch(AcknowledgedResponse::isAcknowledged)) {\n+                    LOGGER.info(\"Successfully completed [ML] maintenance task: triggerDeleteJobsInStateDeletingWithoutDeletionTask\");\n+                } else {\n+                    LOGGER.info(\"At least one of the ML jobs could not be deleted\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f4dcd60f9af1836be0d4ad720e7a526da5fe001"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTU0Njg4MA==", "bodyText": "I wonder if it's best to remove this line and leave the success logging to the individual steps.  This will get logged when the last step succeeds, even if earlier steps failed.  As long as every other step logs successful completion this doesn't really add anything.", "url": "https://github.com/elastic/elasticsearch/pull/60121#discussion_r461546880", "createdAt": "2020-07-28T12:39:30Z", "author": {"login": "droberts195"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/MlDailyMaintenanceService.java", "diffHunk": "@@ -136,32 +149,127 @@ private void triggerTasks() {\n                 return;\n             }\n             LOGGER.info(\"triggering scheduled [ML] maintenance tasks\");\n-            executeAsyncWithOrigin(client,\n-                ML_ORIGIN,\n-                DeleteExpiredDataAction.INSTANCE,\n-                new DeleteExpiredDataAction.Request(deleteExpiredDataRequestsPerSecond, TimeValue.timeValueHours(8)),\n-                ActionListener.wrap(\n-                    response -> {\n-                        if (response.isDeleted()) {\n-                            LOGGER.info(\"Successfully completed [ML] maintenance tasks\");\n-                        } else {\n-                            LOGGER.info(\"Halting [ML] maintenance tasks before completion as elapsed time is too great\");\n-                        }\n-                    },\n-                    e -> LOGGER.error(\"An error occurred during maintenance tasks execution\", e)));\n-            auditUnassignedMlTasks(clusterService.state());\n+\n+            // Step 3: Log whether the tasks have finished\n+            ActionListener<AcknowledgedResponse> finalListener = ActionListener.wrap(\n+                unused -> LOGGER.info(\"Completed [ML] maintenance tasks\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f4dcd60f9af1836be0d4ad720e7a526da5fe001"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTU1MDcwOA==", "bodyText": "This will get logged in the case where jobs are being deleted when the daily maintenance runs, but all of them already had deletion tasks.  I think it should only be logged when a job had lost its original deletion task.", "url": "https://github.com/elastic/elasticsearch/pull/60121#discussion_r461550708", "createdAt": "2020-07-28T12:45:41Z", "author": {"login": "droberts195"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/MlDailyMaintenanceService.java", "diffHunk": "@@ -136,32 +149,127 @@ private void triggerTasks() {\n                 return;\n             }\n             LOGGER.info(\"triggering scheduled [ML] maintenance tasks\");\n-            executeAsyncWithOrigin(client,\n-                ML_ORIGIN,\n-                DeleteExpiredDataAction.INSTANCE,\n-                new DeleteExpiredDataAction.Request(deleteExpiredDataRequestsPerSecond, TimeValue.timeValueHours(8)),\n-                ActionListener.wrap(\n-                    response -> {\n-                        if (response.isDeleted()) {\n-                            LOGGER.info(\"Successfully completed [ML] maintenance tasks\");\n-                        } else {\n-                            LOGGER.info(\"Halting [ML] maintenance tasks before completion as elapsed time is too great\");\n-                        }\n-                    },\n-                    e -> LOGGER.error(\"An error occurred during maintenance tasks execution\", e)));\n-            auditUnassignedMlTasks(clusterService.state());\n+\n+            // Step 3: Log whether the tasks have finished\n+            ActionListener<AcknowledgedResponse> finalListener = ActionListener.wrap(\n+                unused -> LOGGER.info(\"Completed [ML] maintenance tasks\"),\n+                e -> LOGGER.error(\"An error occurred during maintenance tasks execution\", e)\n+            );\n+\n+            // Step 2: Delete expired data\n+            ActionListener<AcknowledgedResponse> deleteJobsListener = ActionListener.wrap(\n+                unused -> triggerDeleteExpiredDataTask(finalListener),\n+                e -> {\n+                    LOGGER.info(\"[ML] maintenance task: triggerDeleteJobsInStateDeletingWithoutDeletionTask failed\", e);\n+                    // Note: Steps 1 and 2 are independent of each other and step 2 is executed even if step 1 failed.\n+                    triggerDeleteExpiredDataTask(finalListener);\n+                }\n+            );\n+\n+            // Step 1: Delete jobs that are in deleting state\n+            triggerDeleteJobsInStateDeletingWithoutDeletionTask(deleteJobsListener);\n+\n+            auditUnassignedMlTasks();\n         } finally {\n             scheduleNext();\n         }\n     }\n \n+    private void triggerDeleteExpiredDataTask(ActionListener<AcknowledgedResponse> finalListener) {\n+        ActionListener<DeleteExpiredDataAction.Response> deleteExpiredDataActionListener = ActionListener.wrap(\n+            deleteExpiredDataResponse -> {\n+                if (deleteExpiredDataResponse.isDeleted()) {\n+                    LOGGER.info(\"Successfully completed [ML] maintenance task: triggerDeleteExpiredDataTask\");\n+                } else {\n+                    LOGGER.info(\"Halting [ML] maintenance tasks before completion as elapsed time is too great\");\n+                }\n+                finalListener.onResponse(new AcknowledgedResponse(true));\n+            },\n+            finalListener::onFailure\n+        );\n+\n+        executeAsyncWithOrigin(\n+            client,\n+            ML_ORIGIN,\n+            DeleteExpiredDataAction.INSTANCE,\n+            new DeleteExpiredDataAction.Request(deleteExpiredDataRequestsPerSecond, TimeValue.timeValueHours(8)),\n+            deleteExpiredDataActionListener);\n+    }\n+\n+    // Visible for testing\n+    public void triggerDeleteJobsInStateDeletingWithoutDeletionTask(ActionListener<AcknowledgedResponse> finalListener) {\n+        SetOnce<Set<String>> jobsInStateDeletingHolder = new SetOnce<>();\n+\n+        ActionListener<List<AcknowledgedResponse>> deleteJobsActionListener = ActionListener.wrap(\n+            deleteJobsResponses -> {\n+                if (deleteJobsResponses.stream().allMatch(AcknowledgedResponse::isAcknowledged)) {\n+                    LOGGER.info(\"Successfully completed [ML] maintenance task: triggerDeleteJobsInStateDeletingWithoutDeletionTask\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f4dcd60f9af1836be0d4ad720e7a526da5fe001"}, "originalPosition": 112}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0a9caaa703a107f9c08d62c6653a79c35d894faf", "author": {"user": {"login": "przemekwitek", "name": "Przemys\u0142aw Witek"}}, "url": "https://github.com/elastic/elasticsearch/commit/0a9caaa703a107f9c08d62c6653a79c35d894faf", "committedDate": "2020-07-29T09:46:04Z", "message": "Make MlDailyMaintenanceService delete jobs that are in deleting state anyway"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2d09e6ec1652edc7c7aa35da3d8debcb445b6707", "author": {"user": {"login": "przemekwitek", "name": "Przemys\u0142aw Witek"}}, "url": "https://github.com/elastic/elasticsearch/commit/2d09e6ec1652edc7c7aa35da3d8debcb445b6707", "committedDate": "2020-07-29T09:46:04Z", "message": "Apply review comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "45eb59135921766542fdf0c428de2554bd475105", "author": {"user": {"login": "przemekwitek", "name": "Przemys\u0142aw Witek"}}, "url": "https://github.com/elastic/elasticsearch/commit/45eb59135921766542fdf0c428de2554bd475105", "committedDate": "2020-07-29T09:46:04Z", "message": "Revert debug-related change"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aa0d7898b15dafdd536d85495a2d6d3387086ad7", "author": {"user": {"login": "przemekwitek", "name": "Przemys\u0142aw Witek"}}, "url": "https://github.com/elastic/elasticsearch/commit/aa0d7898b15dafdd536d85495a2d6d3387086ad7", "committedDate": "2020-07-29T09:46:04Z", "message": "Apply review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4dc1a5ccacc17bac5b92a43f7d4885327b04dab0", "author": {"user": {"login": "przemekwitek", "name": "Przemys\u0142aw Witek"}}, "url": "https://github.com/elastic/elasticsearch/commit/4dc1a5ccacc17bac5b92a43f7d4885327b04dab0", "committedDate": "2020-07-29T09:46:04Z", "message": "Swap the order of execution of tasks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e1ac1fa7f6cf5bcc75af775ac2dc2c274e09adf8", "author": {"user": {"login": "przemekwitek", "name": "Przemys\u0142aw Witek"}}, "url": "https://github.com/elastic/elasticsearch/commit/e1ac1fa7f6cf5bcc75af775ac2dc2c274e09adf8", "committedDate": "2020-07-29T09:46:04Z", "message": "Apply review comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f7cb7e4fbb390e26fd00d0b6a23e363ce36b5b68", "author": {"user": {"login": "przemekwitek", "name": "Przemys\u0142aw Witek"}}, "url": "https://github.com/elastic/elasticsearch/commit/f7cb7e4fbb390e26fd00d0b6a23e363ce36b5b68", "committedDate": "2020-07-29T09:00:19Z", "message": "Apply review comments"}, "afterCommit": {"oid": "e1ac1fa7f6cf5bcc75af775ac2dc2c274e09adf8", "author": {"user": {"login": "przemekwitek", "name": "Przemys\u0142aw Witek"}}, "url": "https://github.com/elastic/elasticsearch/commit/e1ac1fa7f6cf5bcc75af775ac2dc2c274e09adf8", "committedDate": "2020-07-29T09:46:04Z", "message": "Apply review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3NTg0OTQ0", "url": "https://github.com/elastic/elasticsearch/pull/60121#pullrequestreview-457584944", "createdAt": "2020-07-29T14:34:15Z", "commit": {"oid": "e1ac1fa7f6cf5bcc75af775ac2dc2c274e09adf8"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4118, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}