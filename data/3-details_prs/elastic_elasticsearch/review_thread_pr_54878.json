{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAwMjIzODUy", "number": 54878, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxMzoyNTowMFrODvj1JQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMTowODo1NlrODv8cSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMTk2NzA5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ilm/src/main/java/org/elasticsearch/xpack/ilm/IndexLifecycleRunner.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxMzoyNTowMFrOGCDYnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxMzoyNTowMFrOGCDYnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDgwNTc4OA==", "bodyText": "This is code formatting", "url": "https://github.com/elastic/elasticsearch/pull/54878#discussion_r404805788", "createdAt": "2020-04-07T13:25:00Z", "author": {"login": "andreidan"}, "path": "x-pack/plugin/ilm/src/main/java/org/elasticsearch/xpack/ilm/IndexLifecycleRunner.java", "diffHunk": "@@ -204,33 +206,45 @@ void onErrorMaybeRetryFailedStep(String policy, IndexMetadata indexMetadata) {\n             int currentRetryAttempt = lifecycleState.getFailedStepRetryCount() == null ? 1 : 1 + lifecycleState.getFailedStepRetryCount();\n             logger.info(\"policy [{}] for index [{}] on an error step due to a transitive error, moving back to the failed \" +\n                 \"step [{}] for execution. retry attempt [{}]\", policy, index, lifecycleState.getFailedStep(), currentRetryAttempt);\n-            clusterService.submitStateUpdateTask(\"ilm-retry-failed-step\", new ClusterStateUpdateTask() {\n-                @Override\n-                public ClusterState execute(ClusterState currentState) {\n-                    return IndexLifecycleTransition.moveClusterStateToPreviouslyFailedStep(currentState, index,\n-                        nowSupplier, stepRegistry, true);\n-                }\n+            clusterService.submitStateUpdateTask(\n+                String.format(Locale.ROOT, \"ilm-retry-failed-step {policy [%s], index [%s], failedStep [%s]}\", policy, index,\n+                    failedStep.getKey()),\n+                new ClusterStateUpdateTask() {\n \n-                @Override\n-                public void onFailure(String source, Exception e) {\n-                    logger.error(new ParameterizedMessage(\"retry execution of step [{}] for index [{}] failed\",\n-                        failedStep.getKey().getName(), index), e);\n-                }\n+                    @Override\n+                    public TimeValue timeout() {\n+                        // we can afford to drop these requests if they timeout as on the next {@link\n+                        // IndexLifecycleRunner#runPeriodicStep} run the policy will still be in the ERROR step, as we haven't been able\n+                        // to move it back into the failed step, so we'll try again\n+                        return MasterNodeRequest.DEFAULT_MASTER_NODE_TIMEOUT;\n+                    }\n \n-                @Override\n-                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n-                    if (oldState.equals(newState) == false) {\n-                        IndexMetadata newIndexMeta = newState.metadata().index(index);\n-                        Step indexMetaCurrentStep = getCurrentStep(stepRegistry, policy, newIndexMeta);\n-                        StepKey stepKey = indexMetaCurrentStep.getKey();\n-                        if (stepKey != null && stepKey != TerminalPolicyStep.KEY && newIndexMeta != null) {\n-                            logger.trace(\"policy [{}] for index [{}] was moved back on the failed step for as part of an automatic \" +\n-                                \"retry. Attempting to execute the failed step [{}] if it's an async action\", policy, index, stepKey);\n-                            maybeRunAsyncAction(newState, newIndexMeta, policy, stepKey);\n+                    @Override\n+                    public ClusterState execute(ClusterState currentState) {\n+                        return IndexLifecycleTransition.moveClusterStateToPreviouslyFailedStep(currentState, index,\n+                            nowSupplier, stepRegistry, true);\n+                    }\n+\n+                    @Override\n+                    public void onFailure(String source, Exception e) {\n+                        logger.error(new ParameterizedMessage(\"retry execution of step [{}] for index [{}] failed\",\n+                            failedStep.getKey().getName(), index), e);\n+                    }\n+\n+                    @Override\n+                    public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n+                        if (oldState.equals(newState) == false) {\n+                            IndexMetadata newIndexMeta = newState.metadata().index(index);\n+                            Step indexMetaCurrentStep = getCurrentStep(stepRegistry, policy, newIndexMeta);\n+                            StepKey stepKey = indexMetaCurrentStep.getKey();\n+                            if (stepKey != null && stepKey != TerminalPolicyStep.KEY && newIndexMeta != null) {\n+                                logger.trace(\"policy [{}] for index [{}] was moved back on the failed step for as part of an automatic \" +\n+                                    \"retry. Attempting to execute the failed step [{}] if it's an async action\", policy, index, stepKey);\n+                                maybeRunAsyncAction(newState, newIndexMeta, policy, stepKey);\n+                            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19502aa054e5617b3ec87cdbcb4fe60c61c355cf"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNTk5OTQ1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ilm/src/main/java/org/elasticsearch/xpack/ilm/IndexLifecycleRunner.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMTowODo1NlrOGCqUAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNToyNzoyMVrOGC0k0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ0MzU4NQ==", "bodyText": "I think we can use the setting we already created to manipulate the ILM related master timeouts. What do you think @dakrone ?", "url": "https://github.com/elastic/elasticsearch/pull/54878#discussion_r405443585", "createdAt": "2020-04-08T11:08:56Z", "author": {"login": "andreidan"}, "path": "x-pack/plugin/ilm/src/main/java/org/elasticsearch/xpack/ilm/IndexLifecycleRunner.java", "diffHunk": "@@ -204,33 +205,45 @@ void onErrorMaybeRetryFailedStep(String policy, IndexMetadata indexMetadata) {\n             int currentRetryAttempt = lifecycleState.getFailedStepRetryCount() == null ? 1 : 1 + lifecycleState.getFailedStepRetryCount();\n             logger.info(\"policy [{}] for index [{}] on an error step due to a transitive error, moving back to the failed \" +\n                 \"step [{}] for execution. retry attempt [{}]\", policy, index, lifecycleState.getFailedStep(), currentRetryAttempt);\n-            clusterService.submitStateUpdateTask(\"ilm-retry-failed-step\", new ClusterStateUpdateTask() {\n-                @Override\n-                public ClusterState execute(ClusterState currentState) {\n-                    return IndexLifecycleTransition.moveClusterStateToPreviouslyFailedStep(currentState, index,\n-                        nowSupplier, stepRegistry, true);\n-                }\n+            clusterService.submitStateUpdateTask(\n+                String.format(Locale.ROOT, \"ilm-retry-failed-step {policy [%s], index [%s], failedStep [%s]}\", policy, index,\n+                    failedStep.getKey()),\n+                new ClusterStateUpdateTask() {\n \n-                @Override\n-                public void onFailure(String source, Exception e) {\n-                    logger.error(new ParameterizedMessage(\"retry execution of step [{}] for index [{}] failed\",\n-                        failedStep.getKey().getName(), index), e);\n-                }\n+                    @Override\n+                    public TimeValue timeout() {\n+                        // we can afford to drop these requests if they timeout as on the next {@link\n+                        // IndexLifecycleRunner#runPeriodicStep} run the policy will still be in the ERROR step, as we haven't been able\n+                        // to move it back into the failed step, so we'll try again\n+                        return LifecycleSettings.LIFECYCLE_STEP_MASTER_TIMEOUT_SETTING.get(clusterService.state().metadata().settings());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "376485e1fc9636fc447becddea286ef6dd07ad5a"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU5MzAwMQ==", "bodyText": "That sounds reasonable to me \ud83d\udc4d", "url": "https://github.com/elastic/elasticsearch/pull/54878#discussion_r405593001", "createdAt": "2020-04-08T15:02:06Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/ilm/src/main/java/org/elasticsearch/xpack/ilm/IndexLifecycleRunner.java", "diffHunk": "@@ -204,33 +205,45 @@ void onErrorMaybeRetryFailedStep(String policy, IndexMetadata indexMetadata) {\n             int currentRetryAttempt = lifecycleState.getFailedStepRetryCount() == null ? 1 : 1 + lifecycleState.getFailedStepRetryCount();\n             logger.info(\"policy [{}] for index [{}] on an error step due to a transitive error, moving back to the failed \" +\n                 \"step [{}] for execution. retry attempt [{}]\", policy, index, lifecycleState.getFailedStep(), currentRetryAttempt);\n-            clusterService.submitStateUpdateTask(\"ilm-retry-failed-step\", new ClusterStateUpdateTask() {\n-                @Override\n-                public ClusterState execute(ClusterState currentState) {\n-                    return IndexLifecycleTransition.moveClusterStateToPreviouslyFailedStep(currentState, index,\n-                        nowSupplier, stepRegistry, true);\n-                }\n+            clusterService.submitStateUpdateTask(\n+                String.format(Locale.ROOT, \"ilm-retry-failed-step {policy [%s], index [%s], failedStep [%s]}\", policy, index,\n+                    failedStep.getKey()),\n+                new ClusterStateUpdateTask() {\n \n-                @Override\n-                public void onFailure(String source, Exception e) {\n-                    logger.error(new ParameterizedMessage(\"retry execution of step [{}] for index [{}] failed\",\n-                        failedStep.getKey().getName(), index), e);\n-                }\n+                    @Override\n+                    public TimeValue timeout() {\n+                        // we can afford to drop these requests if they timeout as on the next {@link\n+                        // IndexLifecycleRunner#runPeriodicStep} run the policy will still be in the ERROR step, as we haven't been able\n+                        // to move it back into the failed step, so we'll try again\n+                        return LifecycleSettings.LIFECYCLE_STEP_MASTER_TIMEOUT_SETTING.get(clusterService.state().metadata().settings());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ0MzU4NQ=="}, "originalCommit": {"oid": "376485e1fc9636fc447becddea286ef6dd07ad5a"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYxMTcyOQ==", "bodyText": "@dakrone cool, thanks for confirming, this is ready for review then \ud83d\ude4f\ud83c\udffb", "url": "https://github.com/elastic/elasticsearch/pull/54878#discussion_r405611729", "createdAt": "2020-04-08T15:27:21Z", "author": {"login": "andreidan"}, "path": "x-pack/plugin/ilm/src/main/java/org/elasticsearch/xpack/ilm/IndexLifecycleRunner.java", "diffHunk": "@@ -204,33 +205,45 @@ void onErrorMaybeRetryFailedStep(String policy, IndexMetadata indexMetadata) {\n             int currentRetryAttempt = lifecycleState.getFailedStepRetryCount() == null ? 1 : 1 + lifecycleState.getFailedStepRetryCount();\n             logger.info(\"policy [{}] for index [{}] on an error step due to a transitive error, moving back to the failed \" +\n                 \"step [{}] for execution. retry attempt [{}]\", policy, index, lifecycleState.getFailedStep(), currentRetryAttempt);\n-            clusterService.submitStateUpdateTask(\"ilm-retry-failed-step\", new ClusterStateUpdateTask() {\n-                @Override\n-                public ClusterState execute(ClusterState currentState) {\n-                    return IndexLifecycleTransition.moveClusterStateToPreviouslyFailedStep(currentState, index,\n-                        nowSupplier, stepRegistry, true);\n-                }\n+            clusterService.submitStateUpdateTask(\n+                String.format(Locale.ROOT, \"ilm-retry-failed-step {policy [%s], index [%s], failedStep [%s]}\", policy, index,\n+                    failedStep.getKey()),\n+                new ClusterStateUpdateTask() {\n \n-                @Override\n-                public void onFailure(String source, Exception e) {\n-                    logger.error(new ParameterizedMessage(\"retry execution of step [{}] for index [{}] failed\",\n-                        failedStep.getKey().getName(), index), e);\n-                }\n+                    @Override\n+                    public TimeValue timeout() {\n+                        // we can afford to drop these requests if they timeout as on the next {@link\n+                        // IndexLifecycleRunner#runPeriodicStep} run the policy will still be in the ERROR step, as we haven't been able\n+                        // to move it back into the failed step, so we'll try again\n+                        return LifecycleSettings.LIFECYCLE_STEP_MASTER_TIMEOUT_SETTING.get(clusterService.state().metadata().settings());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ0MzU4NQ=="}, "originalCommit": {"oid": "376485e1fc9636fc447becddea286ef6dd07ad5a"}, "originalPosition": 33}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1292, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}