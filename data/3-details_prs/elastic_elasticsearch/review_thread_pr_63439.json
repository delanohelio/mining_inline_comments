{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk5NDYyMTQ0", "number": 63439, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxOTozODo1N1rOErVFTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxOTozODo1N1rOErVFTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzODY5NjQ2OnYy", "diffSide": "RIGHT", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/api/Augmentation.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxOTozODo1N1rOHeCsLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMDozOTo1OVrOHeErIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI2MzQwNw==", "bodyText": "No suggestions here. Just surprised this is the best way to do it :).", "url": "https://github.com/elastic/elasticsearch/pull/63439#discussion_r501263407", "createdAt": "2020-10-07T19:38:57Z", "author": {"login": "jdconrad"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/api/Augmentation.java", "diffHunk": "@@ -712,4 +715,13 @@ public static Matcher matcher(Pattern receiver, int limitFactor, CharSequence in\n         }\n         return receiver.matcher(new LimitedCharSequence(input, receiver, limitFactor));\n     }\n+\n+    /**\n+     * Convert a {@link TemporalAccessor} into millis since epoch like {@link Instant#toEpochMilli()}.\n+     */\n+    public static long toEpochMilli(TemporalAccessor v) {\n+        long millis = Math.multiplyExact(v.getLong(ChronoField.INSTANT_SECONDS), 1_000);\n+        millis = Math.addExact(millis, v.get(ChronoField.NANO_OF_SECOND) / 1_000_000);\n+        return millis;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ecabcaec8bc537175163e0b220b8a9891987ff1"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI3NTA3MQ==", "bodyText": "Its not exactly the clearest thing, no. If you know that you have a ZonedDateTime you can do zdt.toInstant().toEpochMilli() which does about the same thing but you have to worry about if the JVM can skip allocating the Instant.... And we're not sure we have a ZonedDateTime here either.", "url": "https://github.com/elastic/elasticsearch/pull/63439#discussion_r501275071", "createdAt": "2020-10-07T20:00:57Z", "author": {"login": "nik9000"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/api/Augmentation.java", "diffHunk": "@@ -712,4 +715,13 @@ public static Matcher matcher(Pattern receiver, int limitFactor, CharSequence in\n         }\n         return receiver.matcher(new LimitedCharSequence(input, receiver, limitFactor));\n     }\n+\n+    /**\n+     * Convert a {@link TemporalAccessor} into millis since epoch like {@link Instant#toEpochMilli()}.\n+     */\n+    public static long toEpochMilli(TemporalAccessor v) {\n+        long millis = Math.multiplyExact(v.getLong(ChronoField.INSTANT_SECONDS), 1_000);\n+        millis = Math.addExact(millis, v.get(ChronoField.NANO_OF_SECOND) / 1_000_000);\n+        return millis;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI2MzQwNw=="}, "originalCommit": {"oid": "8ecabcaec8bc537175163e0b220b8a9891987ff1"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI4MDU5OQ==", "bodyText": "Makes sense. Thanks for the explanation!", "url": "https://github.com/elastic/elasticsearch/pull/63439#discussion_r501280599", "createdAt": "2020-10-07T20:11:31Z", "author": {"login": "jdconrad"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/api/Augmentation.java", "diffHunk": "@@ -712,4 +715,13 @@ public static Matcher matcher(Pattern receiver, int limitFactor, CharSequence in\n         }\n         return receiver.matcher(new LimitedCharSequence(input, receiver, limitFactor));\n     }\n+\n+    /**\n+     * Convert a {@link TemporalAccessor} into millis since epoch like {@link Instant#toEpochMilli()}.\n+     */\n+    public static long toEpochMilli(TemporalAccessor v) {\n+        long millis = Math.multiplyExact(v.getLong(ChronoField.INSTANT_SECONDS), 1_000);\n+        millis = Math.addExact(millis, v.get(ChronoField.NANO_OF_SECOND) / 1_000_000);\n+        return millis;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI2MzQwNw=="}, "originalCommit": {"oid": "8ecabcaec8bc537175163e0b220b8a9891987ff1"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI5NTkwNg==", "bodyText": "Why the Math. calls instead of actual math?", "url": "https://github.com/elastic/elasticsearch/pull/63439#discussion_r501295906", "createdAt": "2020-10-07T20:39:59Z", "author": {"login": "rjernst"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/api/Augmentation.java", "diffHunk": "@@ -712,4 +715,13 @@ public static Matcher matcher(Pattern receiver, int limitFactor, CharSequence in\n         }\n         return receiver.matcher(new LimitedCharSequence(input, receiver, limitFactor));\n     }\n+\n+    /**\n+     * Convert a {@link TemporalAccessor} into millis since epoch like {@link Instant#toEpochMilli()}.\n+     */\n+    public static long toEpochMilli(TemporalAccessor v) {\n+        long millis = Math.multiplyExact(v.getLong(ChronoField.INSTANT_SECONDS), 1_000);\n+        millis = Math.addExact(millis, v.get(ChronoField.NANO_OF_SECOND) / 1_000_000);\n+        return millis;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI2MzQwNw=="}, "originalCommit": {"oid": "8ecabcaec8bc537175163e0b220b8a9891987ff1"}, "originalPosition": 21}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3026, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}