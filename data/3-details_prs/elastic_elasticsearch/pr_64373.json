{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEyNDY1NDA3", "number": 64373, "title": "Add action to decommission legacy monitoring cluster alerts", "bodyText": "This follows on from #62668 by adding an action that will proactively remove any watches that monitoring has configured. The action toggles on the new setting that informs the cluster to tear down any previously created cluster alerts, and after that is accepted, the action immediately attempts a best-effort refresh of cluster alert resources in order to force their removal in case collection is disabled or delayed.\nSince resources are controlled lazily by the existing monitoring exporters, extra care was taken to ensure that any in-flight resource management operations do not race against any resource actions taken by the migration action. Resource installation code was updated with callbacks to report any errors instead of just logging them.", "createdAt": "2020-10-29T18:09:29Z", "url": "https://github.com/elastic/elasticsearch/pull/64373", "merged": true, "mergeCommit": {"oid": "abda989bd6f80f91f480357fd175dc831062060d"}, "closed": true, "closedAt": "2020-12-14T18:37:40Z", "author": {"login": "jbaiera"}, "timelineItems": {"totalCount": 28, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdXWD6sgH2gAyNTEyNDY1NDA3OjZkMTVjYjI3YTk5ZTI0MDg5M2IyMWVmYjNhNzVlMjg2NjdiNzM0Y2Q=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdmICeVAH2gAyNTEyNDY1NDA3OmFlNWJlNGM1ZDgwNmFmNTgwZjhjN2NkYzJhZGEyZThjMGZkN2UzMzk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "6d15cb27a99e240893b21efb3a75e28667b734cd", "author": {"user": {"login": "jbaiera", "name": "James Baiera"}}, "url": "https://github.com/elastic/elasticsearch/commit/6d15cb27a99e240893b21efb3a75e28667b734cd", "committedDate": "2020-10-29T17:59:41Z", "message": "Basic action definitions made"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fd7bc4ada4ab178dc32eae32dcbba9b51dcc87f1", "author": {"user": {"login": "jbaiera", "name": "James Baiera"}}, "url": "https://github.com/elastic/elasticsearch/commit/fd7bc4ada4ab178dc32eae32dcbba9b51dcc87f1", "committedDate": "2020-10-29T17:59:41Z", "message": "Add ability to specify a consumer for when setup is completed by asynchronous tasks.\n\nHTTP Exporter still WIP."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "76e4303a8d04cada138a697c1a436e54d56ea1a0", "author": {"user": {"login": "jbaiera", "name": "James Baiera"}}, "url": "https://github.com/elastic/elasticsearch/commit/76e4303a8d04cada138a697c1a436e54d56ea1a0", "committedDate": "2020-10-29T17:59:41Z", "message": "Refactor HttpResource to return more information on its success or failure to publish resources."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9060cfb818998bc37309d606a31f9a26e9ec1dd6", "author": {"user": {"login": "jbaiera", "name": "James Baiera"}}, "url": "https://github.com/elastic/elasticsearch/commit/9060cfb818998bc37309d606a31f9a26e9ec1dd6", "committedDate": "2020-10-29T17:59:41Z", "message": "Transport action to remove existing cluster alerts from configured exporters.\n\nSpecifically refresh alerts as part of the migration instead of re-running resource installation.\nWe don't want to re-publish old templates if all the old monitoring resources have already been\nremoved."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b0c5638cb3b26bc3114da4cc862dbd2eb8a2d132", "author": {"user": {"login": "jbaiera", "name": "James Baiera"}}, "url": "https://github.com/elastic/elasticsearch/commit/b0c5638cb3b26bc3114da4cc862dbd2eb8a2d132", "committedDate": "2020-10-29T17:59:41Z", "message": "satisfy precommit"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "63704e50a855124dca7444eb4942857d6ee9588c", "author": {"user": {"login": "jbaiera", "name": "James Baiera"}}, "url": "https://github.com/elastic/elasticsearch/commit/63704e50a855124dca7444eb4942857d6ee9588c", "committedDate": "2020-10-29T17:59:41Z", "message": "Fix duplicate setting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a9e7413af30bd5c4d7f0fb68771fc2357aef7134", "author": {"user": {"login": "jbaiera", "name": "James Baiera"}}, "url": "https://github.com/elastic/elasticsearch/commit/a9e7413af30bd5c4d7f0fb68771fc2357aef7134", "committedDate": "2020-10-29T17:59:41Z", "message": "Add preliminary rest handler"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dfa08773bc0ca8b77255d9ff6fef357e159bdfa8", "author": {"user": {"login": "jbaiera", "name": "James Baiera"}}, "url": "https://github.com/elastic/elasticsearch/commit/dfa08773bc0ca8b77255d9ff6fef357e159bdfa8", "committedDate": "2020-10-29T17:59:42Z", "message": "Some serious test cleanup, including a fix for a testing bug"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d9c6f00bd02a2fd12c4ac3b2ad7fc0acbecf76fb", "author": {"user": {"login": "jbaiera", "name": "James Baiera"}}, "url": "https://github.com/elastic/elasticsearch/commit/d9c6f00bd02a2fd12c4ac3b2ad7fc0acbecf76fb", "committedDate": "2020-10-29T18:22:51Z", "message": "The infinite struggle of forgetting to run precommit"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c3355ba08c3909ce9ce56993f922c8ce63e4e7f", "author": {"user": {"login": "jbaiera", "name": "James Baiera"}}, "url": "https://github.com/elastic/elasticsearch/commit/6c3355ba08c3909ce9ce56993f922c8ce63e4e7f", "committedDate": "2020-10-29T20:04:41Z", "message": "The struggle continues"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyMDQwOTc3", "url": "https://github.com/elastic/elasticsearch/pull/64373#pullrequestreview-522040977", "createdAt": "2020-11-02T22:11:26Z", "commit": {"oid": "6c3355ba08c3909ce9ce56993f922c8ce63e4e7f"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMjoxMToyNlrOHsXhYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMjoxNjoyMlrOHsXqSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI4NDc3MQ==", "bodyText": "nit: include the setting name in the error.\nnit: prefer == false over !", "url": "https://github.com/elastic/elasticsearch/pull/64373#discussion_r516284771", "createdAt": "2020-11-02T22:11:26Z", "author": {"login": "jakelandis"}, "path": "x-pack/plugin/monitoring/src/main/java/org/elasticsearch/xpack/monitoring/action/TransportMonitoringMigrateAlertsAction.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.monitoring.action;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.cluster.settings.ClusterUpdateSettingsResponse;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.master.TransportMasterNodeAction;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.block.ClusterBlockLevel;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.core.monitoring.action.MonitoringMigrateAlertsAction;\n+import org.elasticsearch.xpack.core.monitoring.action.MonitoringMigrateAlertsRequest;\n+import org.elasticsearch.xpack.core.monitoring.action.MonitoringMigrateAlertsResponse;\n+import org.elasticsearch.xpack.core.monitoring.action.MonitoringMigrateAlertsResponse.ExporterMigrationResult;\n+import org.elasticsearch.xpack.monitoring.Monitoring;\n+import org.elasticsearch.xpack.monitoring.exporter.Exporter;\n+import org.elasticsearch.xpack.monitoring.exporter.Exporter.ExporterResourceStatus;\n+import org.elasticsearch.xpack.monitoring.exporter.Exporters;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+\n+public class TransportMonitoringMigrateAlertsAction extends TransportMasterNodeAction<MonitoringMigrateAlertsRequest,\n+    MonitoringMigrateAlertsResponse> {\n+\n+    private static final Logger logger = LogManager.getLogger(TransportMonitoringMigrateAlertsAction.class);\n+\n+    private static final TimeValue ALERT_MIGRATION_BACK_OFF_RETRY = new TimeValue(5, TimeUnit.SECONDS);\n+    private static final int ALERT_MIGRATION_MAX_RETRY = 3;\n+\n+    private final Client client;\n+    private final Exporters exporters;\n+\n+    @Inject\n+    public TransportMonitoringMigrateAlertsAction(Client client, Exporters exporters, TransportService transportService,\n+                                                  ClusterService clusterService, ThreadPool threadPool,\n+                                                  ActionFilters actionFilters, IndexNameExpressionResolver indexNameExpressionResolver) {\n+        super(MonitoringMigrateAlertsAction.NAME, transportService, clusterService, threadPool, actionFilters,\n+            MonitoringMigrateAlertsRequest::new, indexNameExpressionResolver, MonitoringMigrateAlertsResponse::new,\n+            ThreadPool.Names.MANAGEMENT);\n+        this.client = client;\n+        this.exporters = exporters;\n+    }\n+\n+    @Override\n+    protected void masterOperation(Task task, MonitoringMigrateAlertsRequest request, ClusterState state,\n+                                   ActionListener<MonitoringMigrateAlertsResponse> listener) throws Exception {\n+        Settings.Builder decommissionAlertSetting = Settings.builder().put(Monitoring.MIGRATION_DECOMMISSION_ALERTS.getKey(), true);\n+        client.admin().cluster().prepareUpdateSettings().setPersistentSettings(decommissionAlertSetting)\n+            .execute(afterSettingUpdate(listener));\n+    }\n+\n+    /**\n+     * Executed after the settings update has been accepted, this collects the enabled and disabled exporters, requesting each of them\n+     * to explicitly remove their installed alerts if possible. This makes sure that alerts are removed in a timely fashion instead of\n+     * waiting for metrics to be bulked into the monitoring cluster.\n+     */\n+    private ActionListener<ClusterUpdateSettingsResponse> afterSettingUpdate(ActionListener<MonitoringMigrateAlertsResponse> listener) {\n+        return ActionListener.wrap(clusterUpdateSettingsResponse -> {\n+\n+            // Ensure positive result\n+            if (!clusterUpdateSettingsResponse.isAcknowledged()) {\n+                listener.onFailure(new ElasticsearchException(\"Failed to update monitoring migration settings\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c3355ba08c3909ce9ce56993f922c8ce63e4e7f"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI4NzA1MA==", "bodyText": "If the setting is already true, does clusterUpdateSettingResponse.isAcknoledged() still return true ?", "url": "https://github.com/elastic/elasticsearch/pull/64373#discussion_r516287050", "createdAt": "2020-11-02T22:16:22Z", "author": {"login": "jakelandis"}, "path": "x-pack/plugin/monitoring/src/main/java/org/elasticsearch/xpack/monitoring/action/TransportMonitoringMigrateAlertsAction.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.monitoring.action;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.cluster.settings.ClusterUpdateSettingsResponse;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.master.TransportMasterNodeAction;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.block.ClusterBlockLevel;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.core.monitoring.action.MonitoringMigrateAlertsAction;\n+import org.elasticsearch.xpack.core.monitoring.action.MonitoringMigrateAlertsRequest;\n+import org.elasticsearch.xpack.core.monitoring.action.MonitoringMigrateAlertsResponse;\n+import org.elasticsearch.xpack.core.monitoring.action.MonitoringMigrateAlertsResponse.ExporterMigrationResult;\n+import org.elasticsearch.xpack.monitoring.Monitoring;\n+import org.elasticsearch.xpack.monitoring.exporter.Exporter;\n+import org.elasticsearch.xpack.monitoring.exporter.Exporter.ExporterResourceStatus;\n+import org.elasticsearch.xpack.monitoring.exporter.Exporters;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+\n+public class TransportMonitoringMigrateAlertsAction extends TransportMasterNodeAction<MonitoringMigrateAlertsRequest,\n+    MonitoringMigrateAlertsResponse> {\n+\n+    private static final Logger logger = LogManager.getLogger(TransportMonitoringMigrateAlertsAction.class);\n+\n+    private static final TimeValue ALERT_MIGRATION_BACK_OFF_RETRY = new TimeValue(5, TimeUnit.SECONDS);\n+    private static final int ALERT_MIGRATION_MAX_RETRY = 3;\n+\n+    private final Client client;\n+    private final Exporters exporters;\n+\n+    @Inject\n+    public TransportMonitoringMigrateAlertsAction(Client client, Exporters exporters, TransportService transportService,\n+                                                  ClusterService clusterService, ThreadPool threadPool,\n+                                                  ActionFilters actionFilters, IndexNameExpressionResolver indexNameExpressionResolver) {\n+        super(MonitoringMigrateAlertsAction.NAME, transportService, clusterService, threadPool, actionFilters,\n+            MonitoringMigrateAlertsRequest::new, indexNameExpressionResolver, MonitoringMigrateAlertsResponse::new,\n+            ThreadPool.Names.MANAGEMENT);\n+        this.client = client;\n+        this.exporters = exporters;\n+    }\n+\n+    @Override\n+    protected void masterOperation(Task task, MonitoringMigrateAlertsRequest request, ClusterState state,\n+                                   ActionListener<MonitoringMigrateAlertsResponse> listener) throws Exception {\n+        Settings.Builder decommissionAlertSetting = Settings.builder().put(Monitoring.MIGRATION_DECOMMISSION_ALERTS.getKey(), true);\n+        client.admin().cluster().prepareUpdateSettings().setPersistentSettings(decommissionAlertSetting)\n+            .execute(afterSettingUpdate(listener));\n+    }\n+\n+    /**\n+     * Executed after the settings update has been accepted, this collects the enabled and disabled exporters, requesting each of them\n+     * to explicitly remove their installed alerts if possible. This makes sure that alerts are removed in a timely fashion instead of\n+     * waiting for metrics to be bulked into the monitoring cluster.\n+     */\n+    private ActionListener<ClusterUpdateSettingsResponse> afterSettingUpdate(ActionListener<MonitoringMigrateAlertsResponse> listener) {\n+        return ActionListener.wrap(clusterUpdateSettingsResponse -> {\n+\n+            // Ensure positive result\n+            if (!clusterUpdateSettingsResponse.isAcknowledged()) {\n+                listener.onFailure(new ElasticsearchException(\"Failed to update monitoring migration settings\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI4NDc3MQ=="}, "originalCommit": {"oid": "6c3355ba08c3909ce9ce56993f922c8ce63e4e7f"}, "originalPosition": 86}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7881f15533fba0b663413ca01704c17441d431bb", "author": {"user": {"login": "jbaiera", "name": "James Baiera"}}, "url": "https://github.com/elastic/elasticsearch/commit/7881f15533fba0b663413ca01704c17441d431bb", "committedDate": "2020-11-11T19:11:55Z", "message": "Use a semaphore to lock the exporters out of running their setup until after migration"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "25633f19a2e18802ccb2dafaf60c4d5ef4fd4dc8", "author": {"user": {"login": "elasticmachine", "name": "Elastic Machine"}}, "url": "https://github.com/elastic/elasticsearch/commit/25633f19a2e18802ccb2dafaf60c4d5ef4fd4dc8", "committedDate": "2020-11-12T15:53:23Z", "message": "Merge branch 'master' into monitoring-decommission-watch-action"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMxNjE5NDU0", "url": "https://github.com/elastic/elasticsearch/pull/64373#pullrequestreview-531619454", "createdAt": "2020-11-16T19:03:00Z", "commit": {"oid": "25633f19a2e18802ccb2dafaf60c4d5ef4fd4dc8"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQxOTowMzowMFrOH0NNYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwMDoyOTozN1rOH0foGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDUwNDQxNw==", "bodyText": "update @return in javadoc", "url": "https://github.com/elastic/elasticsearch/pull/64373#discussion_r524504417", "createdAt": "2020-11-16T19:03:00Z", "author": {"login": "jakelandis"}, "path": "x-pack/plugin/monitoring/src/main/java/org/elasticsearch/xpack/monitoring/exporter/http/VersionHttpResource.java", "diffHunk": "@@ -91,7 +91,7 @@ public void onFailure(final Exception exception) {\n      * @throws ClassCastException if the response is malformed.\n      * @throws IOException if any parsing issue occurs.\n      */\n-    private boolean validateVersion(final Response response) throws IOException {\n+    private ResourcePublishResult validateVersion(final Response response) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25633f19a2e18802ccb2dafaf60c4d5ef4fd4dc8"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDUxMDEyOA==", "bodyText": "Can you update the java doc for all of the params (for all the these constructors)", "url": "https://github.com/elastic/elasticsearch/pull/64373#discussion_r524510128", "createdAt": "2020-11-16T19:13:01Z", "author": {"login": "jakelandis"}, "path": "x-pack/plugin/monitoring/src/main/java/org/elasticsearch/xpack/monitoring/exporter/http/HttpExporter.java", "diffHunk": "@@ -359,24 +362,49 @@ public void validate(final String username, final Map<Setting<?>, Object> settin\n      */\n     private final HttpResource resource;\n \n+    /**\n+     * {@link HttpResource} for setting up or tearing down cluster alerts specifically.\n+     */\n+    private final HttpResource alertingResource;\n+\n     /**\n      * Track whether cluster alerts are allowed or not between requests. This allows us to avoid wiring a listener and to lazily change it.\n      */\n     private final AtomicBoolean clusterAlertsAllowed = new AtomicBoolean(false);\n \n+    /**\n+     * A barrier object to keep the exporter from installing or operating during a migration operation.\n+     */\n+    private final MonitoringMigrationCoordinator migrationCoordinator;\n+\n     private static final ConcurrentHashMap<String, SecureString> SECURE_AUTH_PASSWORDS = new ConcurrentHashMap<>();\n     private final ThreadContext threadContext;\n     private final DateFormatter dateTimeFormatter;\n     private final ClusterStateListener onLocalMasterListener;\n+\n+    /**\n+     * Helper class to separate all resources from just watcher resources\n+     */\n+    static class Resources {\n+        MultiHttpResource allResources;\n+        HttpResource alertingResource;\n+\n+        Resources(MultiHttpResource allResources, HttpResource alertingResource) {\n+            this.allResources = allResources;\n+            this.alertingResource = alertingResource;\n+        }\n+    }\n+\n     /**\n      * Create an {@link HttpExporter}.\n      *\n      * @param config The HTTP Exporter's configuration\n      * @param sslService The SSL Service used to create the SSL Context necessary for TLS / SSL communication\n      * @throws SettingsException if any setting is malformed\n      */\n-    public HttpExporter(final Config config, final SSLService sslService, final ThreadContext threadContext) {\n-        this(config, sslService, threadContext, new NodeFailureListener(), createResources(config));\n+    public HttpExporter(final Config config, final SSLService sslService, final ThreadContext threadContext,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25633f19a2e18802ccb2dafaf60c4d5ef4fd4dc8"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDUyNzU4OQ==", "bodyText": "tryBlockInstallationTasks and unblockInstallationTasks should be in a corresponding try/finally block...just incase.", "url": "https://github.com/elastic/elasticsearch/pull/64373#discussion_r524527589", "createdAt": "2020-11-16T19:43:39Z", "author": {"login": "jakelandis"}, "path": "x-pack/plugin/monitoring/src/main/java/org/elasticsearch/xpack/monitoring/action/TransportMonitoringMigrateAlertsAction.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.monitoring.action;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.cluster.settings.ClusterUpdateSettingsResponse;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.master.TransportMasterNodeAction;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.block.ClusterBlockLevel;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.common.util.concurrent.EsRejectedExecutionException;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.core.monitoring.action.MonitoringMigrateAlertsAction;\n+import org.elasticsearch.xpack.core.monitoring.action.MonitoringMigrateAlertsRequest;\n+import org.elasticsearch.xpack.core.monitoring.action.MonitoringMigrateAlertsResponse;\n+import org.elasticsearch.xpack.core.monitoring.action.MonitoringMigrateAlertsResponse.ExporterMigrationResult;\n+import org.elasticsearch.xpack.monitoring.Monitoring;\n+import org.elasticsearch.xpack.monitoring.exporter.Exporter;\n+import org.elasticsearch.xpack.monitoring.exporter.Exporter.ExporterResourceStatus;\n+import org.elasticsearch.xpack.monitoring.exporter.Exporters;\n+import org.elasticsearch.xpack.monitoring.exporter.MonitoringMigrationCoordinator;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+\n+public class TransportMonitoringMigrateAlertsAction extends TransportMasterNodeAction<MonitoringMigrateAlertsRequest,\n+    MonitoringMigrateAlertsResponse> {\n+\n+    private static final Logger logger = LogManager.getLogger(TransportMonitoringMigrateAlertsAction.class);\n+\n+    private static final TimeValue ALERT_MIGRATION_INSTALLATION_WAIT_TIMEOUT = new TimeValue(10, TimeUnit.SECONDS);\n+    private static final TimeValue ALERT_MIGRATION_BACK_OFF_RETRY = new TimeValue(5, TimeUnit.SECONDS);\n+    private static final int ALERT_MIGRATION_MAX_RETRY = 3;\n+\n+    private final Client client;\n+    private final MonitoringMigrationCoordinator migrationCoordinator;\n+    private final Exporters exporters;\n+\n+    @Inject\n+    public TransportMonitoringMigrateAlertsAction(Client client, Exporters exporters, MonitoringMigrationCoordinator migrationCoordinator,\n+                                                  TransportService transportService, ClusterService clusterService, ThreadPool threadPool,\n+                                                  ActionFilters actionFilters, IndexNameExpressionResolver indexNameExpressionResolver) {\n+        super(MonitoringMigrateAlertsAction.NAME, transportService, clusterService, threadPool, actionFilters,\n+            MonitoringMigrateAlertsRequest::new, indexNameExpressionResolver, MonitoringMigrateAlertsResponse::new,\n+            ThreadPool.Names.MANAGEMENT);\n+        this.client = client;\n+        this.migrationCoordinator = migrationCoordinator;\n+        this.exporters = exporters;\n+    }\n+\n+    @Override\n+    protected void masterOperation(Task task, MonitoringMigrateAlertsRequest request, ClusterState state,\n+                                   ActionListener<MonitoringMigrateAlertsResponse> listener) throws Exception {\n+        // First, enable the migration coordinator block\n+        if (migrationCoordinator.tryBlockInstallationTasks(ALERT_MIGRATION_INSTALLATION_WAIT_TIMEOUT) == false) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25633f19a2e18802ccb2dafaf60c4d5ef4fd4dc8"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDczODAxNQ==", "bodyText": "nit: addClusterAlertsRemovalAsyncActions (not get)\nAlso, can you update the java doc.", "url": "https://github.com/elastic/elasticsearch/pull/64373#discussion_r524738015", "createdAt": "2020-11-16T23:20:07Z", "author": {"login": "jakelandis"}, "path": "x-pack/plugin/monitoring/src/main/java/org/elasticsearch/xpack/monitoring/exporter/local/LocalExporter.java", "diffHunk": "@@ -481,8 +583,26 @@ private void getClusterAlertsInstallationAsyncActions(final boolean indexExists,\n         }\n     }\n \n-    private void putWatch(final Client client, final String watchId, final String uniqueWatchId,\n-                          final AtomicInteger pendingResponses) {\n+    /**\n+     * Removes Cluster Alerts (Watches) from the cluster\n+     *\n+     * @param asyncActions Asynchronous actions are added to for each Watch.\n+     * @param pendingResponses Pending response countdown we use to track completion.\n+     */\n+    private void getClusterAlertsRemovalAsyncActions(final boolean indexExists, final List<Runnable> asyncActions,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25633f19a2e18802ccb2dafaf60c4d5ef4fd4dc8"}, "originalPosition": 296}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDc0NzU0OA==", "bodyText": "Should this be removeAlerts ? (and javadoc updated)", "url": "https://github.com/elastic/elasticsearch/pull/64373#discussion_r524747548", "createdAt": "2020-11-16T23:28:23Z", "author": {"login": "jakelandis"}, "path": "x-pack/plugin/monitoring/src/main/java/org/elasticsearch/xpack/monitoring/exporter/Exporter.java", "diffHunk": "@@ -136,6 +139,12 @@ public boolean isSingleton() {\n         return false;\n     }\n \n+    /**\n+     * Forces an exporter to deploy (or clean up) cluster alerts immediately instead of waiting to do it\n+     * lazily as part of accepting a bulk operation.\n+     */\n+    public abstract void refreshAlerts(Consumer<ExporterResourceStatus> listener);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25633f19a2e18802ccb2dafaf60c4d5ef4fd4dc8"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDc0OTQzMg==", "bodyText": "should this be deleteAlertsFromOpenExporter ? (or the like ...i.e. not refresh since it just deletes)\nAlso, so probably assert that the exporter is indeed open.", "url": "https://github.com/elastic/elasticsearch/pull/64373#discussion_r524749432", "createdAt": "2020-11-16T23:30:08Z", "author": {"login": "jakelandis"}, "path": "x-pack/plugin/monitoring/src/main/java/org/elasticsearch/xpack/monitoring/action/TransportMonitoringMigrateAlertsAction.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.monitoring.action;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.cluster.settings.ClusterUpdateSettingsResponse;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.master.TransportMasterNodeAction;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.block.ClusterBlockLevel;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.common.util.concurrent.EsRejectedExecutionException;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.core.monitoring.action.MonitoringMigrateAlertsAction;\n+import org.elasticsearch.xpack.core.monitoring.action.MonitoringMigrateAlertsRequest;\n+import org.elasticsearch.xpack.core.monitoring.action.MonitoringMigrateAlertsResponse;\n+import org.elasticsearch.xpack.core.monitoring.action.MonitoringMigrateAlertsResponse.ExporterMigrationResult;\n+import org.elasticsearch.xpack.monitoring.Monitoring;\n+import org.elasticsearch.xpack.monitoring.exporter.Exporter;\n+import org.elasticsearch.xpack.monitoring.exporter.Exporter.ExporterResourceStatus;\n+import org.elasticsearch.xpack.monitoring.exporter.Exporters;\n+import org.elasticsearch.xpack.monitoring.exporter.MonitoringMigrationCoordinator;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+\n+public class TransportMonitoringMigrateAlertsAction extends TransportMasterNodeAction<MonitoringMigrateAlertsRequest,\n+    MonitoringMigrateAlertsResponse> {\n+\n+    private static final Logger logger = LogManager.getLogger(TransportMonitoringMigrateAlertsAction.class);\n+\n+    private static final TimeValue ALERT_MIGRATION_INSTALLATION_WAIT_TIMEOUT = new TimeValue(10, TimeUnit.SECONDS);\n+    private static final TimeValue ALERT_MIGRATION_BACK_OFF_RETRY = new TimeValue(5, TimeUnit.SECONDS);\n+    private static final int ALERT_MIGRATION_MAX_RETRY = 3;\n+\n+    private final Client client;\n+    private final MonitoringMigrationCoordinator migrationCoordinator;\n+    private final Exporters exporters;\n+\n+    @Inject\n+    public TransportMonitoringMigrateAlertsAction(Client client, Exporters exporters, MonitoringMigrationCoordinator migrationCoordinator,\n+                                                  TransportService transportService, ClusterService clusterService, ThreadPool threadPool,\n+                                                  ActionFilters actionFilters, IndexNameExpressionResolver indexNameExpressionResolver) {\n+        super(MonitoringMigrateAlertsAction.NAME, transportService, clusterService, threadPool, actionFilters,\n+            MonitoringMigrateAlertsRequest::new, indexNameExpressionResolver, MonitoringMigrateAlertsResponse::new,\n+            ThreadPool.Names.MANAGEMENT);\n+        this.client = client;\n+        this.migrationCoordinator = migrationCoordinator;\n+        this.exporters = exporters;\n+    }\n+\n+    @Override\n+    protected void masterOperation(Task task, MonitoringMigrateAlertsRequest request, ClusterState state,\n+                                   ActionListener<MonitoringMigrateAlertsResponse> listener) throws Exception {\n+        // First, enable the migration coordinator block\n+        if (migrationCoordinator.tryBlockInstallationTasks(ALERT_MIGRATION_INSTALLATION_WAIT_TIMEOUT) == false) {\n+            throw new EsRejectedExecutionException(\"Could not migrate cluster alerts. Timed out waiting to block resource operations.\");\n+        }\n+        // Wrap the listener to unblock resource installation before completing\n+        listener = ActionListener.runBefore(listener, migrationCoordinator::unblockInstallationTasks);\n+        try {\n+            Settings.Builder decommissionAlertSetting = Settings.builder().put(Monitoring.MIGRATION_DECOMMISSION_ALERTS.getKey(), true);\n+            client.admin().cluster().prepareUpdateSettings().setPersistentSettings(decommissionAlertSetting)\n+                .execute(afterSettingUpdate(listener));\n+        } catch (Exception e) {\n+            // unblock resource installation if something fails here\n+            migrationCoordinator.unblockInstallationTasks();\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * Executed after the settings update has been accepted, this collects the enabled and disabled exporters, requesting each of them\n+     * to explicitly remove their installed alerts if possible. This makes sure that alerts are removed in a timely fashion instead of\n+     * waiting for metrics to be bulked into the monitoring cluster.\n+     */\n+    private ActionListener<ClusterUpdateSettingsResponse> afterSettingUpdate(ActionListener<MonitoringMigrateAlertsResponse> listener) {\n+        return ActionListener.wrap(clusterUpdateSettingsResponse -> {\n+            // Ensure positive result\n+            if (!clusterUpdateSettingsResponse.isAcknowledged()) {\n+                listener.onFailure(new ElasticsearchException(\"Failed to update monitoring migration settings\"));\n+            }\n+\n+            // iterate over all the exporters and refresh the alerts\n+            Collection<Exporter> enabledExporters = exporters.getEnabledExporters();\n+            Collection<Exporter.Config> disabledExporterConfigs = exporters.getDisabledExporterConfigs();\n+\n+            List<Runnable> refreshTasks = new ArrayList<>();\n+            AtomicInteger remaining = new AtomicInteger(enabledExporters.size() + disabledExporterConfigs.size());\n+            List<ExporterResourceStatus> results = Collections.synchronizedList(new ArrayList<>(remaining.get()));\n+            logger.debug(\"Exporters in need of refreshing [{}]; enabled [{}], disabled [{}]\", remaining.get(), enabledExporters.size(),\n+                disabledExporterConfigs.size());\n+\n+            for (Exporter enabledExporter : enabledExporters) {\n+                refreshTasks.add(() -> refreshOpenExporter(enabledExporter,\n+                    resultCollector(enabledExporter.config(), listener, remaining, results)));\n+            }\n+            for (Exporter.Config disabledExporter : disabledExporterConfigs) {\n+                refreshTasks.add(() -> refreshDisabledExporter(disabledExporter,\n+                    resultCollector(disabledExporter, listener, remaining, results)));\n+            }\n+            for (Runnable refreshTask : refreshTasks) {\n+                threadPool.executor(ThreadPool.Names.MANAGEMENT).execute(refreshTask);\n+            }\n+        }, listener::onFailure);\n+    }\n+\n+    /**\n+     * Create an action listener that will collect results and finish the request once all results are in.\n+     * @param exporterConfig The exporter being refreshed in this operation (in case of failure)\n+     * @param listener The listener to call after all refresh operations are complete\n+     * @param remaining The counter used to determine if any other operations are in flight\n+     * @param results A thread-safe collection to hold results\n+     */\n+    private ActionListener<ExporterResourceStatus> resultCollector(final Exporter.Config exporterConfig,\n+                                                                   final ActionListener<MonitoringMigrateAlertsResponse> listener,\n+                                                                   final AtomicInteger remaining,\n+                                                                   final List<ExporterResourceStatus> results) {\n+        return new ActionListener<>() {\n+            @Override\n+            public void onResponse(ExporterResourceStatus exporterResourceStatus) {\n+                addStatus(exporterResourceStatus);\n+            }\n+\n+            @Override\n+            public void onFailure(Exception e) {\n+                // Need the exporter name and type here for reporting purposes. Maybe we need to make multiple of these listeners\n+                addStatus(ExporterResourceStatus.notReady(exporterConfig.name(), exporterConfig.type(), e));\n+            }\n+\n+            private void addStatus(ExporterResourceStatus exporterResourceStatus) {\n+                results.add(exporterResourceStatus);\n+                int tasksRemaining = remaining.decrementAndGet();\n+                if (tasksRemaining == 0) {\n+                    finalResult();\n+                }\n+            }\n+\n+            private void finalResult() {\n+                try {\n+                    List<ExporterMigrationResult> collectedResults = results.stream().map(status ->\n+                        new ExporterMigrationResult(\n+                            status.getExporterName(),\n+                            status.getExporterType(),\n+                            status.isComplete(),\n+                            compileReason(status))\n+                    ).collect(Collectors.toList());\n+                    MonitoringMigrateAlertsResponse response = new MonitoringMigrateAlertsResponse(collectedResults);\n+                    listener.onResponse(response);\n+                } catch (Exception e) {\n+                    // Make this self contained, we don't want to bubble up exceptions in a way where this listener's\n+                    // onFailure method could be called multiple times.\n+                    listener.onFailure(e);\n+                }\n+            }\n+\n+            private Exception compileReason(ExporterResourceStatus status) {\n+                // The reason for unsuccessful setup could be multiple exceptions: one or more watches\n+                // may fail to be removed for any reason.\n+                List<Exception> exceptions = status.getExceptions();\n+                if (exceptions == null || exceptions.size() == 0) {\n+                    return null;\n+                } else if (exceptions.size() == 1) {\n+                    return exceptions.get(0);\n+                } else {\n+                    // Set first exception as the cause, and the rest as suppressed under it.\n+                    Exception head = new ElasticsearchException(\"multiple errors occurred during migration\", exceptions.get(0));\n+                    List<Exception> tail = exceptions.subList(1, exceptions.size());\n+                    return tail.stream().reduce(head, ExceptionsHelper::useOrSuppress);\n+                }\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Attempts to migrate a given exporter's alerts, retrying a number of times in case the exporter is busy doing a previous setup task.\n+     * @param exporter The exporter to migrate\n+     * @param listener Notified of success or failure\n+     */\n+    private void refreshOpenExporter(Exporter exporter, ActionListener<ExporterResourceStatus> listener) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25633f19a2e18802ccb2dafaf60c4d5ef4fd4dc8"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDc1Mjc5OA==", "bodyText": "Am I missing the retry logic ? I see the _RETRY values up above, but I don't think they are used.", "url": "https://github.com/elastic/elasticsearch/pull/64373#discussion_r524752798", "createdAt": "2020-11-16T23:33:22Z", "author": {"login": "jakelandis"}, "path": "x-pack/plugin/monitoring/src/main/java/org/elasticsearch/xpack/monitoring/action/TransportMonitoringMigrateAlertsAction.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.monitoring.action;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.cluster.settings.ClusterUpdateSettingsResponse;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.master.TransportMasterNodeAction;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.block.ClusterBlockLevel;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.common.util.concurrent.EsRejectedExecutionException;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.core.monitoring.action.MonitoringMigrateAlertsAction;\n+import org.elasticsearch.xpack.core.monitoring.action.MonitoringMigrateAlertsRequest;\n+import org.elasticsearch.xpack.core.monitoring.action.MonitoringMigrateAlertsResponse;\n+import org.elasticsearch.xpack.core.monitoring.action.MonitoringMigrateAlertsResponse.ExporterMigrationResult;\n+import org.elasticsearch.xpack.monitoring.Monitoring;\n+import org.elasticsearch.xpack.monitoring.exporter.Exporter;\n+import org.elasticsearch.xpack.monitoring.exporter.Exporter.ExporterResourceStatus;\n+import org.elasticsearch.xpack.monitoring.exporter.Exporters;\n+import org.elasticsearch.xpack.monitoring.exporter.MonitoringMigrationCoordinator;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+\n+public class TransportMonitoringMigrateAlertsAction extends TransportMasterNodeAction<MonitoringMigrateAlertsRequest,\n+    MonitoringMigrateAlertsResponse> {\n+\n+    private static final Logger logger = LogManager.getLogger(TransportMonitoringMigrateAlertsAction.class);\n+\n+    private static final TimeValue ALERT_MIGRATION_INSTALLATION_WAIT_TIMEOUT = new TimeValue(10, TimeUnit.SECONDS);\n+    private static final TimeValue ALERT_MIGRATION_BACK_OFF_RETRY = new TimeValue(5, TimeUnit.SECONDS);\n+    private static final int ALERT_MIGRATION_MAX_RETRY = 3;\n+\n+    private final Client client;\n+    private final MonitoringMigrationCoordinator migrationCoordinator;\n+    private final Exporters exporters;\n+\n+    @Inject\n+    public TransportMonitoringMigrateAlertsAction(Client client, Exporters exporters, MonitoringMigrationCoordinator migrationCoordinator,\n+                                                  TransportService transportService, ClusterService clusterService, ThreadPool threadPool,\n+                                                  ActionFilters actionFilters, IndexNameExpressionResolver indexNameExpressionResolver) {\n+        super(MonitoringMigrateAlertsAction.NAME, transportService, clusterService, threadPool, actionFilters,\n+            MonitoringMigrateAlertsRequest::new, indexNameExpressionResolver, MonitoringMigrateAlertsResponse::new,\n+            ThreadPool.Names.MANAGEMENT);\n+        this.client = client;\n+        this.migrationCoordinator = migrationCoordinator;\n+        this.exporters = exporters;\n+    }\n+\n+    @Override\n+    protected void masterOperation(Task task, MonitoringMigrateAlertsRequest request, ClusterState state,\n+                                   ActionListener<MonitoringMigrateAlertsResponse> listener) throws Exception {\n+        // First, enable the migration coordinator block\n+        if (migrationCoordinator.tryBlockInstallationTasks(ALERT_MIGRATION_INSTALLATION_WAIT_TIMEOUT) == false) {\n+            throw new EsRejectedExecutionException(\"Could not migrate cluster alerts. Timed out waiting to block resource operations.\");\n+        }\n+        // Wrap the listener to unblock resource installation before completing\n+        listener = ActionListener.runBefore(listener, migrationCoordinator::unblockInstallationTasks);\n+        try {\n+            Settings.Builder decommissionAlertSetting = Settings.builder().put(Monitoring.MIGRATION_DECOMMISSION_ALERTS.getKey(), true);\n+            client.admin().cluster().prepareUpdateSettings().setPersistentSettings(decommissionAlertSetting)\n+                .execute(afterSettingUpdate(listener));\n+        } catch (Exception e) {\n+            // unblock resource installation if something fails here\n+            migrationCoordinator.unblockInstallationTasks();\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * Executed after the settings update has been accepted, this collects the enabled and disabled exporters, requesting each of them\n+     * to explicitly remove their installed alerts if possible. This makes sure that alerts are removed in a timely fashion instead of\n+     * waiting for metrics to be bulked into the monitoring cluster.\n+     */\n+    private ActionListener<ClusterUpdateSettingsResponse> afterSettingUpdate(ActionListener<MonitoringMigrateAlertsResponse> listener) {\n+        return ActionListener.wrap(clusterUpdateSettingsResponse -> {\n+            // Ensure positive result\n+            if (!clusterUpdateSettingsResponse.isAcknowledged()) {\n+                listener.onFailure(new ElasticsearchException(\"Failed to update monitoring migration settings\"));\n+            }\n+\n+            // iterate over all the exporters and refresh the alerts\n+            Collection<Exporter> enabledExporters = exporters.getEnabledExporters();\n+            Collection<Exporter.Config> disabledExporterConfigs = exporters.getDisabledExporterConfigs();\n+\n+            List<Runnable> refreshTasks = new ArrayList<>();\n+            AtomicInteger remaining = new AtomicInteger(enabledExporters.size() + disabledExporterConfigs.size());\n+            List<ExporterResourceStatus> results = Collections.synchronizedList(new ArrayList<>(remaining.get()));\n+            logger.debug(\"Exporters in need of refreshing [{}]; enabled [{}], disabled [{}]\", remaining.get(), enabledExporters.size(),\n+                disabledExporterConfigs.size());\n+\n+            for (Exporter enabledExporter : enabledExporters) {\n+                refreshTasks.add(() -> refreshOpenExporter(enabledExporter,\n+                    resultCollector(enabledExporter.config(), listener, remaining, results)));\n+            }\n+            for (Exporter.Config disabledExporter : disabledExporterConfigs) {\n+                refreshTasks.add(() -> refreshDisabledExporter(disabledExporter,\n+                    resultCollector(disabledExporter, listener, remaining, results)));\n+            }\n+            for (Runnable refreshTask : refreshTasks) {\n+                threadPool.executor(ThreadPool.Names.MANAGEMENT).execute(refreshTask);\n+            }\n+        }, listener::onFailure);\n+    }\n+\n+    /**\n+     * Create an action listener that will collect results and finish the request once all results are in.\n+     * @param exporterConfig The exporter being refreshed in this operation (in case of failure)\n+     * @param listener The listener to call after all refresh operations are complete\n+     * @param remaining The counter used to determine if any other operations are in flight\n+     * @param results A thread-safe collection to hold results\n+     */\n+    private ActionListener<ExporterResourceStatus> resultCollector(final Exporter.Config exporterConfig,\n+                                                                   final ActionListener<MonitoringMigrateAlertsResponse> listener,\n+                                                                   final AtomicInteger remaining,\n+                                                                   final List<ExporterResourceStatus> results) {\n+        return new ActionListener<>() {\n+            @Override\n+            public void onResponse(ExporterResourceStatus exporterResourceStatus) {\n+                addStatus(exporterResourceStatus);\n+            }\n+\n+            @Override\n+            public void onFailure(Exception e) {\n+                // Need the exporter name and type here for reporting purposes. Maybe we need to make multiple of these listeners\n+                addStatus(ExporterResourceStatus.notReady(exporterConfig.name(), exporterConfig.type(), e));\n+            }\n+\n+            private void addStatus(ExporterResourceStatus exporterResourceStatus) {\n+                results.add(exporterResourceStatus);\n+                int tasksRemaining = remaining.decrementAndGet();\n+                if (tasksRemaining == 0) {\n+                    finalResult();\n+                }\n+            }\n+\n+            private void finalResult() {\n+                try {\n+                    List<ExporterMigrationResult> collectedResults = results.stream().map(status ->\n+                        new ExporterMigrationResult(\n+                            status.getExporterName(),\n+                            status.getExporterType(),\n+                            status.isComplete(),\n+                            compileReason(status))\n+                    ).collect(Collectors.toList());\n+                    MonitoringMigrateAlertsResponse response = new MonitoringMigrateAlertsResponse(collectedResults);\n+                    listener.onResponse(response);\n+                } catch (Exception e) {\n+                    // Make this self contained, we don't want to bubble up exceptions in a way where this listener's\n+                    // onFailure method could be called multiple times.\n+                    listener.onFailure(e);\n+                }\n+            }\n+\n+            private Exception compileReason(ExporterResourceStatus status) {\n+                // The reason for unsuccessful setup could be multiple exceptions: one or more watches\n+                // may fail to be removed for any reason.\n+                List<Exception> exceptions = status.getExceptions();\n+                if (exceptions == null || exceptions.size() == 0) {\n+                    return null;\n+                } else if (exceptions.size() == 1) {\n+                    return exceptions.get(0);\n+                } else {\n+                    // Set first exception as the cause, and the rest as suppressed under it.\n+                    Exception head = new ElasticsearchException(\"multiple errors occurred during migration\", exceptions.get(0));\n+                    List<Exception> tail = exceptions.subList(1, exceptions.size());\n+                    return tail.stream().reduce(head, ExceptionsHelper::useOrSuppress);\n+                }\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Attempts to migrate a given exporter's alerts, retrying a number of times in case the exporter is busy doing a previous setup task.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25633f19a2e18802ccb2dafaf60c4d5ef4fd4dc8"}, "originalPosition": 197}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDgwNjE2OA==", "bodyText": "should this be an assert instead ? since this would be a programmer's error, not a runtime error ?", "url": "https://github.com/elastic/elasticsearch/pull/64373#discussion_r524806168", "createdAt": "2020-11-17T00:29:37Z", "author": {"login": "jakelandis"}, "path": "x-pack/plugin/monitoring/src/main/java/org/elasticsearch/xpack/monitoring/exporter/local/LocalExporter.java", "diffHunk": "@@ -167,6 +174,55 @@ boolean isExporterReady() {\n         return running && installingSomething.get() == false && alertsProcessed;\n     }\n \n+    @Override\n+    public void refreshAlerts(Consumer<ExporterResourceStatus> listener) {\n+        if (state.get() == State.TERMINATED) {\n+            throw new IllegalStateException(\"Cannot refresh alerts on terminated exporter\");\n+        }\n+\n+        ClusterState clusterState = clusterService.state();\n+        if (clusterState.nodes().isLocalNodeElectedMaster()) {\n+            // we are on the elected master\n+            // Check that there is nothing that could block metadata updates\n+            if (clusterState.blocks().hasGlobalBlockWithLevel(ClusterBlockLevel.METADATA_WRITE)) {\n+                throw new ElasticsearchException(\"waiting until metadata writes are unblocked\");\n+            }\n+\n+            if (migrationCoordinator.canInstall()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25633f19a2e18802ccb2dafaf60c4d5ef4fd4dc8"}, "originalPosition": 85}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMxOTg0Mjk2", "url": "https://github.com/elastic/elasticsearch/pull/64373#pullrequestreview-531984296", "createdAt": "2020-11-17T02:51:21Z", "commit": {"oid": "25633f19a2e18802ccb2dafaf60c4d5ef4fd4dc8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwMjo1MToyMVrOH0iX1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwMjo1MToyMVrOH0iX1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg1MTE1Nw==", "bodyText": "What thread is all this work happening on ?", "url": "https://github.com/elastic/elasticsearch/pull/64373#discussion_r524851157", "createdAt": "2020-11-17T02:51:21Z", "author": {"login": "jakelandis"}, "path": "x-pack/plugin/monitoring/src/main/java/org/elasticsearch/xpack/monitoring/action/TransportMonitoringMigrateAlertsAction.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.monitoring.action;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.cluster.settings.ClusterUpdateSettingsResponse;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.master.TransportMasterNodeAction;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.block.ClusterBlockLevel;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.common.util.concurrent.EsRejectedExecutionException;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.core.monitoring.action.MonitoringMigrateAlertsAction;\n+import org.elasticsearch.xpack.core.monitoring.action.MonitoringMigrateAlertsRequest;\n+import org.elasticsearch.xpack.core.monitoring.action.MonitoringMigrateAlertsResponse;\n+import org.elasticsearch.xpack.core.monitoring.action.MonitoringMigrateAlertsResponse.ExporterMigrationResult;\n+import org.elasticsearch.xpack.monitoring.Monitoring;\n+import org.elasticsearch.xpack.monitoring.exporter.Exporter;\n+import org.elasticsearch.xpack.monitoring.exporter.Exporter.ExporterResourceStatus;\n+import org.elasticsearch.xpack.monitoring.exporter.Exporters;\n+import org.elasticsearch.xpack.monitoring.exporter.MonitoringMigrationCoordinator;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+\n+public class TransportMonitoringMigrateAlertsAction extends TransportMasterNodeAction<MonitoringMigrateAlertsRequest,\n+    MonitoringMigrateAlertsResponse> {\n+\n+    private static final Logger logger = LogManager.getLogger(TransportMonitoringMigrateAlertsAction.class);\n+\n+    private static final TimeValue ALERT_MIGRATION_INSTALLATION_WAIT_TIMEOUT = new TimeValue(10, TimeUnit.SECONDS);\n+    private static final TimeValue ALERT_MIGRATION_BACK_OFF_RETRY = new TimeValue(5, TimeUnit.SECONDS);\n+    private static final int ALERT_MIGRATION_MAX_RETRY = 3;\n+\n+    private final Client client;\n+    private final MonitoringMigrationCoordinator migrationCoordinator;\n+    private final Exporters exporters;\n+\n+    @Inject\n+    public TransportMonitoringMigrateAlertsAction(Client client, Exporters exporters, MonitoringMigrationCoordinator migrationCoordinator,\n+                                                  TransportService transportService, ClusterService clusterService, ThreadPool threadPool,\n+                                                  ActionFilters actionFilters, IndexNameExpressionResolver indexNameExpressionResolver) {\n+        super(MonitoringMigrateAlertsAction.NAME, transportService, clusterService, threadPool, actionFilters,\n+            MonitoringMigrateAlertsRequest::new, indexNameExpressionResolver, MonitoringMigrateAlertsResponse::new,\n+            ThreadPool.Names.MANAGEMENT);\n+        this.client = client;\n+        this.migrationCoordinator = migrationCoordinator;\n+        this.exporters = exporters;\n+    }\n+\n+    @Override\n+    protected void masterOperation(Task task, MonitoringMigrateAlertsRequest request, ClusterState state,\n+                                   ActionListener<MonitoringMigrateAlertsResponse> listener) throws Exception {\n+        // First, enable the migration coordinator block\n+        if (migrationCoordinator.tryBlockInstallationTasks(ALERT_MIGRATION_INSTALLATION_WAIT_TIMEOUT) == false) {\n+            throw new EsRejectedExecutionException(\"Could not migrate cluster alerts. Timed out waiting to block resource operations.\");\n+        }\n+        // Wrap the listener to unblock resource installation before completing\n+        listener = ActionListener.runBefore(listener, migrationCoordinator::unblockInstallationTasks);\n+        try {\n+            Settings.Builder decommissionAlertSetting = Settings.builder().put(Monitoring.MIGRATION_DECOMMISSION_ALERTS.getKey(), true);\n+            client.admin().cluster().prepareUpdateSettings().setPersistentSettings(decommissionAlertSetting)\n+                .execute(afterSettingUpdate(listener));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25633f19a2e18802ccb2dafaf60c4d5ef4fd4dc8"}, "originalPosition": 85}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0996f6ed1e8a72696f36ec4beb75ddc6f3837965", "author": {"user": {"login": "jbaiera", "name": "James Baiera"}}, "url": "https://github.com/elastic/elasticsearch/commit/0996f6ed1e8a72696f36ec4beb75ddc6f3837965", "committedDate": "2020-12-07T17:30:49Z", "message": "PR feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8b52a5b6c6041fe6910853fe2d3df881670ac4ac", "author": {"user": {"login": "jbaiera", "name": "James Baiera"}}, "url": "https://github.com/elastic/elasticsearch/commit/8b52a5b6c6041fe6910853fe2d3df881670ac4ac", "committedDate": "2020-12-07T18:12:28Z", "message": "precommit"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "16065ed08deb8d66230d055c17a4969be7924527", "author": {"user": {"login": "elasticmachine", "name": "Elastic Machine"}}, "url": "https://github.com/elastic/elasticsearch/commit/16065ed08deb8d66230d055c17a4969be7924527", "committedDate": "2020-12-07T18:54:18Z", "message": "Merge branch 'master' into monitoring-decommission-watch-action"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1642f52bcab21729665187bb0f635159bbc2b143", "author": {"user": {"login": "jbaiera", "name": "James Baiera"}}, "url": "https://github.com/elastic/elasticsearch/commit/1642f52bcab21729665187bb0f635159bbc2b143", "committedDate": "2020-12-08T21:00:12Z", "message": "Wrap mocked listeners to fix calls to ActionListener.map"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e911d7a0a8d556ef9d35b1b04397cf265055a704", "author": {"user": {"login": "jbaiera", "name": "James Baiera"}}, "url": "https://github.com/elastic/elasticsearch/commit/e911d7a0a8d556ef9d35b1b04397cf265055a704", "committedDate": "2020-12-09T15:51:26Z", "message": "overzealous with one of my reverts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9942a2583068988e572984bdce5b5f7e3d0eb016", "author": {"user": {"login": "elasticmachine", "name": "Elastic Machine"}}, "url": "https://github.com/elastic/elasticsearch/commit/9942a2583068988e572984bdce5b5f7e3d0eb016", "committedDate": "2020-12-10T19:07:59Z", "message": "Merge branch 'master' into monitoring-decommission-watch-action"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6a3e4726779573f320fdbe5d9ffe4cae3b637b7c", "author": {"user": {"login": "jbaiera", "name": "James Baiera"}}, "url": "https://github.com/elastic/elasticsearch/commit/6a3e4726779573f320fdbe5d9ffe4cae3b637b7c", "committedDate": "2020-12-10T21:13:31Z", "message": "Add alert migration API to non operator actions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "062259964ac805553bc29f3a5549f1d5c979328f", "author": {"user": {"login": "elasticmachine", "name": "Elastic Machine"}}, "url": "https://github.com/elastic/elasticsearch/commit/062259964ac805553bc29f3a5549f1d5c979328f", "committedDate": "2020-12-13T20:27:37Z", "message": "Merge branch 'master' into monitoring-decommission-watch-action"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwOTU3MjM4", "url": "https://github.com/elastic/elasticsearch/pull/64373#pullrequestreview-550957238", "createdAt": "2020-12-13T20:34:11Z", "commit": {"oid": "062259964ac805553bc29f3a5549f1d5c979328f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xM1QyMDozNDoxMVrOIE5CxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xM1QyMDozNDoxMVrOIE5CxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk5OTgxMw==", "bodyText": "nit: there is no more time out.\nAlso, can we change the language from \"block\" to \"currently running\"  ?", "url": "https://github.com/elastic/elasticsearch/pull/64373#discussion_r541999813", "createdAt": "2020-12-13T20:34:11Z", "author": {"login": "jakelandis"}, "path": "x-pack/plugin/monitoring/src/main/java/org/elasticsearch/xpack/monitoring/action/TransportMonitoringMigrateAlertsAction.java", "diffHunk": "@@ -0,0 +1,235 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.monitoring.action;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.ActionRunnable;\n+import org.elasticsearch.action.admin.cluster.settings.ClusterUpdateSettingsResponse;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.master.TransportMasterNodeAction;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.block.ClusterBlockLevel;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.EsRejectedExecutionException;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.core.monitoring.action.MonitoringMigrateAlertsAction;\n+import org.elasticsearch.xpack.core.monitoring.action.MonitoringMigrateAlertsRequest;\n+import org.elasticsearch.xpack.core.monitoring.action.MonitoringMigrateAlertsResponse;\n+import org.elasticsearch.xpack.core.monitoring.action.MonitoringMigrateAlertsResponse.ExporterMigrationResult;\n+import org.elasticsearch.xpack.monitoring.Monitoring;\n+import org.elasticsearch.xpack.monitoring.exporter.Exporter;\n+import org.elasticsearch.xpack.monitoring.exporter.Exporter.ExporterResourceStatus;\n+import org.elasticsearch.xpack.monitoring.exporter.Exporters;\n+import org.elasticsearch.xpack.monitoring.exporter.MonitoringMigrationCoordinator;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+\n+public class TransportMonitoringMigrateAlertsAction extends TransportMasterNodeAction<MonitoringMigrateAlertsRequest,\n+    MonitoringMigrateAlertsResponse> {\n+\n+    private static final Logger logger = LogManager.getLogger(TransportMonitoringMigrateAlertsAction.class);\n+\n+    private final Client client;\n+    private final MonitoringMigrationCoordinator migrationCoordinator;\n+    private final Exporters exporters;\n+\n+    @Inject\n+    public TransportMonitoringMigrateAlertsAction(Client client, Exporters exporters, MonitoringMigrationCoordinator migrationCoordinator,\n+                                                  TransportService transportService, ClusterService clusterService, ThreadPool threadPool,\n+                                                  ActionFilters actionFilters, IndexNameExpressionResolver indexNameExpressionResolver) {\n+        super(MonitoringMigrateAlertsAction.NAME, transportService, clusterService, threadPool, actionFilters,\n+            MonitoringMigrateAlertsRequest::new, indexNameExpressionResolver, MonitoringMigrateAlertsResponse::new,\n+            ThreadPool.Names.MANAGEMENT);\n+        this.client = client;\n+        this.migrationCoordinator = migrationCoordinator;\n+        this.exporters = exporters;\n+    }\n+\n+    @Override\n+    protected void masterOperation(Task task, MonitoringMigrateAlertsRequest request, ClusterState state,\n+                                   ActionListener<MonitoringMigrateAlertsResponse> listener) throws Exception {\n+        // First, enable the migration coordinator block\n+        if (migrationCoordinator.tryBlockInstallationTasks() == false) {\n+            throw new EsRejectedExecutionException(\"Could not migrate cluster alerts. Timed out waiting to block resource operations.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "062259964ac805553bc29f3a5549f1d5c979328f"}, "originalPosition": 73}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwOTU4NTc0", "url": "https://github.com/elastic/elasticsearch/pull/64373#pullrequestreview-550958574", "createdAt": "2020-12-13T20:48:28Z", "commit": {"oid": "062259964ac805553bc29f3a5549f1d5c979328f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xM1QyMDo0ODoyOVrOIE5NCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xM1QyMDo0ODoyOVrOIE5NCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjAwMjQ0MA==", "bodyText": "nit: no longer blocking", "url": "https://github.com/elastic/elasticsearch/pull/64373#discussion_r542002440", "createdAt": "2020-12-13T20:48:29Z", "author": {"login": "jakelandis"}, "path": "x-pack/plugin/monitoring/src/main/java/org/elasticsearch/xpack/monitoring/exporter/MonitoringMigrationCoordinator.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.monitoring.exporter;\n+\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A shared coordination object for blocking execution of exporters when a migration that involves them is in progress", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "062259964ac805553bc29f3a5549f1d5c979328f"}, "originalPosition": 12}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwOTYwNzY4", "url": "https://github.com/elastic/elasticsearch/pull/64373#pullrequestreview-550960768", "createdAt": "2020-12-13T21:13:02Z", "commit": {"oid": "062259964ac805553bc29f3a5549f1d5c979328f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xM1QyMToxMzowMlrOIE5eCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xM1QyMToxMzowMlrOIE5eCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjAwNjc5Mw==", "bodyText": "This instance is passed to the exporters, but I don't think this is the instance that passed into the Transport action (that one is created by Guice and injected). Which would mean that any state set by the transport actions would not be read by the exporters, which defeats the purpose of having an external coordinator.\nI wonder if we should just remove the MonitoringMigrationCoordinator class entirely in favor of boolean in the tranport action that dis-allows running that action overlapping.\nIf I understand the global coordinator is there to ensure that our cluster state updates from these operations don't end up re-constructing the exporters we are trying to disable while we are disabling them ? If so, can the transport action write a small piece of cluster state and the exporters onClusterState change read that and skip reconstruction while that state exists in the cluster ?", "url": "https://github.com/elastic/elasticsearch/pull/64373#discussion_r542006793", "createdAt": "2020-12-13T21:13:02Z", "author": {"login": "jakelandis"}, "path": "x-pack/plugin/monitoring/src/main/java/org/elasticsearch/xpack/monitoring/Monitoring.java", "diffHunk": "@@ -103,10 +106,12 @@ public Monitoring(Settings settings) {\n         final ClusterSettings clusterSettings = clusterService.getClusterSettings();\n         final CleanerService cleanerService = new CleanerService(settings, clusterSettings, threadPool, getLicenseState());\n         final SSLService dynamicSSLService = getSslService().createDynamicSSLService();\n+        final MonitoringMigrationCoordinator migrationCoordinator = new MonitoringMigrationCoordinator();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "062259964ac805553bc29f3a5549f1d5c979328f"}, "originalPosition": 35}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUxNDQ4NDQ4", "url": "https://github.com/elastic/elasticsearch/pull/64373#pullrequestreview-551448448", "createdAt": "2020-12-14T14:56:56Z", "commit": {"oid": "062259964ac805553bc29f3a5549f1d5c979328f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ae5be4c5d806af580f8c7cdc2ada2e8c0fd7e339", "author": {"user": {"login": "jbaiera", "name": "James Baiera"}}, "url": "https://github.com/elastic/elasticsearch/commit/ae5be4c5d806af580f8c7cdc2ada2e8c0fd7e339", "committedDate": "2020-12-14T16:08:18Z", "message": "PR comments"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 835, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}