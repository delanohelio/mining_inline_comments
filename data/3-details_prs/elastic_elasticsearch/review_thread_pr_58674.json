{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQxNDQwNzI5", "number": 58674, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxODo0Mzo1OVrOEKOxHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNjoyMTo0M1rOEMJpaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MTYzMTY3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/indices/breaker/HierarchyCircuitBreakerService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxODo0Mzo1OVrOGrJ0Xw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxOTo1Nzo1MVrOGrzeyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkwMjgxNQ==", "bodyText": "Maybe name it OverLimitStrategy?", "url": "https://github.com/elastic/elasticsearch/pull/58674#discussion_r447902815", "createdAt": "2020-06-30T18:43:59Z", "author": {"login": "jaymode"}, "path": "server/src/main/java/org/elasticsearch/indices/breaker/HierarchyCircuitBreakerService.java", "diffHunk": "@@ -334,4 +360,113 @@ private CircuitBreaker validateAndCreateBreaker(BreakerSettings breakerSettings)\n                 this,\n                 breakerSettings.getName());\n     }\n+\n+    private static DoubleCheckStrategy createDoubleCheckStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,\n+                                                                 LongSupplier timeSupplier, long minimumInterval) {\n+        if (jvmInfo.useG1GC().equals(\"true\")\n+            // messing with GC is \"dangerous\" so we apply an escape hatch. Not intended to be used.\n+            && Boolean.parseBoolean(System.getProperty(\"es.real_memory_circuit_breaker.g1.double_check.enabled\", \"true\"))) {\n+            return new G1DoubleCheckStrategy(jvmInfo, currentMemoryUsageSupplier, timeSupplier, minimumInterval);\n+        } else {\n+            return memoryUsed -> memoryUsed;\n+        }\n+    }\n+\n+    interface DoubleCheckStrategy {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05ec98a32ac3e5dfb516726bf4904f412fc62595"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU4NTQxOQ==", "bodyText": "++, see 1d007ca", "url": "https://github.com/elastic/elasticsearch/pull/58674#discussion_r448585419", "createdAt": "2020-07-01T19:57:51Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/indices/breaker/HierarchyCircuitBreakerService.java", "diffHunk": "@@ -334,4 +360,113 @@ private CircuitBreaker validateAndCreateBreaker(BreakerSettings breakerSettings)\n                 this,\n                 breakerSettings.getName());\n     }\n+\n+    private static DoubleCheckStrategy createDoubleCheckStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,\n+                                                                 LongSupplier timeSupplier, long minimumInterval) {\n+        if (jvmInfo.useG1GC().equals(\"true\")\n+            // messing with GC is \"dangerous\" so we apply an escape hatch. Not intended to be used.\n+            && Boolean.parseBoolean(System.getProperty(\"es.real_memory_circuit_breaker.g1.double_check.enabled\", \"true\"))) {\n+            return new G1DoubleCheckStrategy(jvmInfo, currentMemoryUsageSupplier, timeSupplier, minimumInterval);\n+        } else {\n+            return memoryUsed -> memoryUsed;\n+        }\n+    }\n+\n+    interface DoubleCheckStrategy {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkwMjgxNQ=="}, "originalCommit": {"oid": "05ec98a32ac3e5dfb516726bf4904f412fc62595"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MTYzMzc2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/indices/breaker/HierarchyCircuitBreakerService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxODo0NDozNlrOGrJ1sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxOTo1NzoxMFrOGrzdkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkwMzE1NA==", "bodyText": "can you add a link or reference to this calculation?", "url": "https://github.com/elastic/elasticsearch/pull/58674#discussion_r447903154", "createdAt": "2020-06-30T18:44:36Z", "author": {"login": "jaymode"}, "path": "server/src/main/java/org/elasticsearch/indices/breaker/HierarchyCircuitBreakerService.java", "diffHunk": "@@ -334,4 +360,113 @@ private CircuitBreaker validateAndCreateBreaker(BreakerSettings breakerSettings)\n                 this,\n                 breakerSettings.getName());\n     }\n+\n+    private static DoubleCheckStrategy createDoubleCheckStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,\n+                                                                 LongSupplier timeSupplier, long minimumInterval) {\n+        if (jvmInfo.useG1GC().equals(\"true\")\n+            // messing with GC is \"dangerous\" so we apply an escape hatch. Not intended to be used.\n+            && Boolean.parseBoolean(System.getProperty(\"es.real_memory_circuit_breaker.g1.double_check.enabled\", \"true\"))) {\n+            return new G1DoubleCheckStrategy(jvmInfo, currentMemoryUsageSupplier, timeSupplier, minimumInterval);\n+        } else {\n+            return memoryUsed -> memoryUsed;\n+        }\n+    }\n+\n+    interface DoubleCheckStrategy {\n+        MemoryUsage doubleCheck(MemoryUsage memoryUsed);\n+    }\n+\n+    static class G1DoubleCheckStrategy implements DoubleCheckStrategy {\n+        private final long g1RegionSize;\n+        private final LongSupplier currentMemoryUsageSupplier;\n+        private final LongSupplier timeSupplier;\n+\n+        private long lastCheckTime = Long.MIN_VALUE;\n+        private final long minimumInterval;\n+\n+        private long blackHole;\n+        private final Object lock = new Object();\n+\n+        G1DoubleCheckStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,\n+                                     LongSupplier timeSupplier, long minimumInterval) {\n+            assert minimumInterval > 0;\n+            this.currentMemoryUsageSupplier = currentMemoryUsageSupplier;\n+            this.timeSupplier = timeSupplier;\n+            this.minimumInterval = minimumInterval;\n+            long g1RegionSize = jvmInfo.getG1RegionSize();\n+            if (g1RegionSize <= 0) {\n+\n+                this.g1RegionSize = fallbackRegionSize(jvmInfo);\n+            } else {\n+                this.g1RegionSize = g1RegionSize;\n+            }\n+        }\n+\n+        static long fallbackRegionSize(JvmInfo jvmInfo) {\n+            // mimick JDK calculation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05ec98a32ac3e5dfb516726bf4904f412fc62595"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU4NTEwNA==", "bodyText": "Added in c8ac1af", "url": "https://github.com/elastic/elasticsearch/pull/58674#discussion_r448585104", "createdAt": "2020-07-01T19:57:10Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/indices/breaker/HierarchyCircuitBreakerService.java", "diffHunk": "@@ -334,4 +360,113 @@ private CircuitBreaker validateAndCreateBreaker(BreakerSettings breakerSettings)\n                 this,\n                 breakerSettings.getName());\n     }\n+\n+    private static DoubleCheckStrategy createDoubleCheckStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,\n+                                                                 LongSupplier timeSupplier, long minimumInterval) {\n+        if (jvmInfo.useG1GC().equals(\"true\")\n+            // messing with GC is \"dangerous\" so we apply an escape hatch. Not intended to be used.\n+            && Boolean.parseBoolean(System.getProperty(\"es.real_memory_circuit_breaker.g1.double_check.enabled\", \"true\"))) {\n+            return new G1DoubleCheckStrategy(jvmInfo, currentMemoryUsageSupplier, timeSupplier, minimumInterval);\n+        } else {\n+            return memoryUsed -> memoryUsed;\n+        }\n+    }\n+\n+    interface DoubleCheckStrategy {\n+        MemoryUsage doubleCheck(MemoryUsage memoryUsed);\n+    }\n+\n+    static class G1DoubleCheckStrategy implements DoubleCheckStrategy {\n+        private final long g1RegionSize;\n+        private final LongSupplier currentMemoryUsageSupplier;\n+        private final LongSupplier timeSupplier;\n+\n+        private long lastCheckTime = Long.MIN_VALUE;\n+        private final long minimumInterval;\n+\n+        private long blackHole;\n+        private final Object lock = new Object();\n+\n+        G1DoubleCheckStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,\n+                                     LongSupplier timeSupplier, long minimumInterval) {\n+            assert minimumInterval > 0;\n+            this.currentMemoryUsageSupplier = currentMemoryUsageSupplier;\n+            this.timeSupplier = timeSupplier;\n+            this.minimumInterval = minimumInterval;\n+            long g1RegionSize = jvmInfo.getG1RegionSize();\n+            if (g1RegionSize <= 0) {\n+\n+                this.g1RegionSize = fallbackRegionSize(jvmInfo);\n+            } else {\n+                this.g1RegionSize = g1RegionSize;\n+            }\n+        }\n+\n+        static long fallbackRegionSize(JvmInfo jvmInfo) {\n+            // mimick JDK calculation", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkwMzE1NA=="}, "originalCommit": {"oid": "05ec98a32ac3e5dfb516726bf4904f412fc62595"}, "originalPosition": 135}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MTY2OTA4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/indices/breaker/HierarchyCircuitBreakerService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxODo1Mzo0MlrOGrKK1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxOTo1Njo0NVrOGrzcyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkwODU2NQ==", "bodyText": "unfortunately neither System.currentTimeMillis() nor System.nanoTime() are always monotonic so now could be less than the last checked time so I do not believe that this assert should be here", "url": "https://github.com/elastic/elasticsearch/pull/58674#discussion_r447908565", "createdAt": "2020-06-30T18:53:42Z", "author": {"login": "jaymode"}, "path": "server/src/main/java/org/elasticsearch/indices/breaker/HierarchyCircuitBreakerService.java", "diffHunk": "@@ -334,4 +360,113 @@ private CircuitBreaker validateAndCreateBreaker(BreakerSettings breakerSettings)\n                 this,\n                 breakerSettings.getName());\n     }\n+\n+    private static DoubleCheckStrategy createDoubleCheckStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,\n+                                                                 LongSupplier timeSupplier, long minimumInterval) {\n+        if (jvmInfo.useG1GC().equals(\"true\")\n+            // messing with GC is \"dangerous\" so we apply an escape hatch. Not intended to be used.\n+            && Boolean.parseBoolean(System.getProperty(\"es.real_memory_circuit_breaker.g1.double_check.enabled\", \"true\"))) {\n+            return new G1DoubleCheckStrategy(jvmInfo, currentMemoryUsageSupplier, timeSupplier, minimumInterval);\n+        } else {\n+            return memoryUsed -> memoryUsed;\n+        }\n+    }\n+\n+    interface DoubleCheckStrategy {\n+        MemoryUsage doubleCheck(MemoryUsage memoryUsed);\n+    }\n+\n+    static class G1DoubleCheckStrategy implements DoubleCheckStrategy {\n+        private final long g1RegionSize;\n+        private final LongSupplier currentMemoryUsageSupplier;\n+        private final LongSupplier timeSupplier;\n+\n+        private long lastCheckTime = Long.MIN_VALUE;\n+        private final long minimumInterval;\n+\n+        private long blackHole;\n+        private final Object lock = new Object();\n+\n+        G1DoubleCheckStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,\n+                                     LongSupplier timeSupplier, long minimumInterval) {\n+            assert minimumInterval > 0;\n+            this.currentMemoryUsageSupplier = currentMemoryUsageSupplier;\n+            this.timeSupplier = timeSupplier;\n+            this.minimumInterval = minimumInterval;\n+            long g1RegionSize = jvmInfo.getG1RegionSize();\n+            if (g1RegionSize <= 0) {\n+\n+                this.g1RegionSize = fallbackRegionSize(jvmInfo);\n+            } else {\n+                this.g1RegionSize = g1RegionSize;\n+            }\n+        }\n+\n+        static long fallbackRegionSize(JvmInfo jvmInfo) {\n+            // mimick JDK calculation\n+            long averageHeapSize =\n+                (jvmInfo.getMem().getHeapMax().getBytes() + JvmInfo.jvmInfo().getMem().getHeapMax().getBytes()) / 2;\n+            long regionSize = Long.highestOneBit(averageHeapSize / 2048);\n+            if (regionSize < ByteSizeUnit.MB.toBytes(1)) {\n+                regionSize = ByteSizeUnit.MB.toBytes(1);\n+            } else if (regionSize > ByteSizeUnit.MB.toBytes(32)) {\n+                regionSize = ByteSizeUnit.MB.toBytes(32);\n+            }\n+            return regionSize;\n+        }\n+\n+        @Override\n+        public MemoryUsage doubleCheck(MemoryUsage memoryUsed) {\n+            long maxHeap = JvmInfo.jvmInfo().getMem().getHeapMax().getBytes();\n+            boolean leader;\n+            synchronized (lock) {\n+                leader = timeSupplier.getAsLong() >= lastCheckTime + minimumInterval;\n+                doubleCheckingRealMemoryUsed(leader);\n+                if (leader) {\n+                    logger.info(\"attempting to trigger G1GC due to high heap usage [{}]\", memoryUsed.baseUsage);\n+                    long localBlackHole = 0;\n+                    // number of allocations, corresponding to (approximately) number of free regions + 1\n+                    long allocationCount = (maxHeap - memoryUsed.baseUsage) / g1RegionSize + 1;\n+                    // allocations of half-region size becomes single humongous alloc, thus taking up a full region.\n+                    int allocationSize = (int) (g1RegionSize >> 1);\n+                    long maxUsageObserved = memoryUsed.baseUsage;\n+                    for (long i = 0; i < allocationCount; ++i) {\n+                        long current = currentMemoryUsageSupplier.getAsLong();\n+                        if (current >= maxUsageObserved) {\n+                            maxUsageObserved = current;\n+                        } else {\n+                            // we observed a memory drop, so some GC must have occurred\n+                            break;\n+                        }\n+                        localBlackHole += new byte[allocationSize].hashCode();\n+                    }\n+\n+                    blackHole += localBlackHole;\n+                    logger.trace(\"black hole [{}]\", blackHole);\n+                    long now = timeSupplier.getAsLong();\n+                    assert now > this.lastCheckTime;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05ec98a32ac3e5dfb516726bf4904f412fc62595"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU4NDkwNw==", "bodyText": "Thanks, removed in b6b565a", "url": "https://github.com/elastic/elasticsearch/pull/58674#discussion_r448584907", "createdAt": "2020-07-01T19:56:45Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/indices/breaker/HierarchyCircuitBreakerService.java", "diffHunk": "@@ -334,4 +360,113 @@ private CircuitBreaker validateAndCreateBreaker(BreakerSettings breakerSettings)\n                 this,\n                 breakerSettings.getName());\n     }\n+\n+    private static DoubleCheckStrategy createDoubleCheckStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,\n+                                                                 LongSupplier timeSupplier, long minimumInterval) {\n+        if (jvmInfo.useG1GC().equals(\"true\")\n+            // messing with GC is \"dangerous\" so we apply an escape hatch. Not intended to be used.\n+            && Boolean.parseBoolean(System.getProperty(\"es.real_memory_circuit_breaker.g1.double_check.enabled\", \"true\"))) {\n+            return new G1DoubleCheckStrategy(jvmInfo, currentMemoryUsageSupplier, timeSupplier, minimumInterval);\n+        } else {\n+            return memoryUsed -> memoryUsed;\n+        }\n+    }\n+\n+    interface DoubleCheckStrategy {\n+        MemoryUsage doubleCheck(MemoryUsage memoryUsed);\n+    }\n+\n+    static class G1DoubleCheckStrategy implements DoubleCheckStrategy {\n+        private final long g1RegionSize;\n+        private final LongSupplier currentMemoryUsageSupplier;\n+        private final LongSupplier timeSupplier;\n+\n+        private long lastCheckTime = Long.MIN_VALUE;\n+        private final long minimumInterval;\n+\n+        private long blackHole;\n+        private final Object lock = new Object();\n+\n+        G1DoubleCheckStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,\n+                                     LongSupplier timeSupplier, long minimumInterval) {\n+            assert minimumInterval > 0;\n+            this.currentMemoryUsageSupplier = currentMemoryUsageSupplier;\n+            this.timeSupplier = timeSupplier;\n+            this.minimumInterval = minimumInterval;\n+            long g1RegionSize = jvmInfo.getG1RegionSize();\n+            if (g1RegionSize <= 0) {\n+\n+                this.g1RegionSize = fallbackRegionSize(jvmInfo);\n+            } else {\n+                this.g1RegionSize = g1RegionSize;\n+            }\n+        }\n+\n+        static long fallbackRegionSize(JvmInfo jvmInfo) {\n+            // mimick JDK calculation\n+            long averageHeapSize =\n+                (jvmInfo.getMem().getHeapMax().getBytes() + JvmInfo.jvmInfo().getMem().getHeapMax().getBytes()) / 2;\n+            long regionSize = Long.highestOneBit(averageHeapSize / 2048);\n+            if (regionSize < ByteSizeUnit.MB.toBytes(1)) {\n+                regionSize = ByteSizeUnit.MB.toBytes(1);\n+            } else if (regionSize > ByteSizeUnit.MB.toBytes(32)) {\n+                regionSize = ByteSizeUnit.MB.toBytes(32);\n+            }\n+            return regionSize;\n+        }\n+\n+        @Override\n+        public MemoryUsage doubleCheck(MemoryUsage memoryUsed) {\n+            long maxHeap = JvmInfo.jvmInfo().getMem().getHeapMax().getBytes();\n+            boolean leader;\n+            synchronized (lock) {\n+                leader = timeSupplier.getAsLong() >= lastCheckTime + minimumInterval;\n+                doubleCheckingRealMemoryUsed(leader);\n+                if (leader) {\n+                    logger.info(\"attempting to trigger G1GC due to high heap usage [{}]\", memoryUsed.baseUsage);\n+                    long localBlackHole = 0;\n+                    // number of allocations, corresponding to (approximately) number of free regions + 1\n+                    long allocationCount = (maxHeap - memoryUsed.baseUsage) / g1RegionSize + 1;\n+                    // allocations of half-region size becomes single humongous alloc, thus taking up a full region.\n+                    int allocationSize = (int) (g1RegionSize >> 1);\n+                    long maxUsageObserved = memoryUsed.baseUsage;\n+                    for (long i = 0; i < allocationCount; ++i) {\n+                        long current = currentMemoryUsageSupplier.getAsLong();\n+                        if (current >= maxUsageObserved) {\n+                            maxUsageObserved = current;\n+                        } else {\n+                            // we observed a memory drop, so some GC must have occurred\n+                            break;\n+                        }\n+                        localBlackHole += new byte[allocationSize].hashCode();\n+                    }\n+\n+                    blackHole += localBlackHole;\n+                    logger.trace(\"black hole [{}]\", blackHole);\n+                    long now = timeSupplier.getAsLong();\n+                    assert now > this.lastCheckTime;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkwODU2NQ=="}, "originalCommit": {"oid": "05ec98a32ac3e5dfb516726bf4904f412fc62595"}, "originalPosition": 176}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MjEwODA0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/indices/breaker/HierarchyCircuitBreakerService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMTowNDowNFrOGrOZiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxOTozNDowNFrOGryz2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3Nzg2Nw==", "bodyText": "is it possible for this to trigger an OOM?", "url": "https://github.com/elastic/elasticsearch/pull/58674#discussion_r447977867", "createdAt": "2020-06-30T21:04:04Z", "author": {"login": "jaymode"}, "path": "server/src/main/java/org/elasticsearch/indices/breaker/HierarchyCircuitBreakerService.java", "diffHunk": "@@ -334,4 +360,113 @@ private CircuitBreaker validateAndCreateBreaker(BreakerSettings breakerSettings)\n                 this,\n                 breakerSettings.getName());\n     }\n+\n+    private static DoubleCheckStrategy createDoubleCheckStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,\n+                                                                 LongSupplier timeSupplier, long minimumInterval) {\n+        if (jvmInfo.useG1GC().equals(\"true\")\n+            // messing with GC is \"dangerous\" so we apply an escape hatch. Not intended to be used.\n+            && Boolean.parseBoolean(System.getProperty(\"es.real_memory_circuit_breaker.g1.double_check.enabled\", \"true\"))) {\n+            return new G1DoubleCheckStrategy(jvmInfo, currentMemoryUsageSupplier, timeSupplier, minimumInterval);\n+        } else {\n+            return memoryUsed -> memoryUsed;\n+        }\n+    }\n+\n+    interface DoubleCheckStrategy {\n+        MemoryUsage doubleCheck(MemoryUsage memoryUsed);\n+    }\n+\n+    static class G1DoubleCheckStrategy implements DoubleCheckStrategy {\n+        private final long g1RegionSize;\n+        private final LongSupplier currentMemoryUsageSupplier;\n+        private final LongSupplier timeSupplier;\n+\n+        private long lastCheckTime = Long.MIN_VALUE;\n+        private final long minimumInterval;\n+\n+        private long blackHole;\n+        private final Object lock = new Object();\n+\n+        G1DoubleCheckStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,\n+                                     LongSupplier timeSupplier, long minimumInterval) {\n+            assert minimumInterval > 0;\n+            this.currentMemoryUsageSupplier = currentMemoryUsageSupplier;\n+            this.timeSupplier = timeSupplier;\n+            this.minimumInterval = minimumInterval;\n+            long g1RegionSize = jvmInfo.getG1RegionSize();\n+            if (g1RegionSize <= 0) {\n+\n+                this.g1RegionSize = fallbackRegionSize(jvmInfo);\n+            } else {\n+                this.g1RegionSize = g1RegionSize;\n+            }\n+        }\n+\n+        static long fallbackRegionSize(JvmInfo jvmInfo) {\n+            // mimick JDK calculation\n+            long averageHeapSize =\n+                (jvmInfo.getMem().getHeapMax().getBytes() + JvmInfo.jvmInfo().getMem().getHeapMax().getBytes()) / 2;\n+            long regionSize = Long.highestOneBit(averageHeapSize / 2048);\n+            if (regionSize < ByteSizeUnit.MB.toBytes(1)) {\n+                regionSize = ByteSizeUnit.MB.toBytes(1);\n+            } else if (regionSize > ByteSizeUnit.MB.toBytes(32)) {\n+                regionSize = ByteSizeUnit.MB.toBytes(32);\n+            }\n+            return regionSize;\n+        }\n+\n+        @Override\n+        public MemoryUsage doubleCheck(MemoryUsage memoryUsed) {\n+            long maxHeap = JvmInfo.jvmInfo().getMem().getHeapMax().getBytes();\n+            boolean leader;\n+            synchronized (lock) {\n+                leader = timeSupplier.getAsLong() >= lastCheckTime + minimumInterval;\n+                doubleCheckingRealMemoryUsed(leader);\n+                if (leader) {\n+                    logger.info(\"attempting to trigger G1GC due to high heap usage [{}]\", memoryUsed.baseUsage);\n+                    long localBlackHole = 0;\n+                    // number of allocations, corresponding to (approximately) number of free regions + 1\n+                    long allocationCount = (maxHeap - memoryUsed.baseUsage) / g1RegionSize + 1;\n+                    // allocations of half-region size becomes single humongous alloc, thus taking up a full region.\n+                    int allocationSize = (int) (g1RegionSize >> 1);\n+                    long maxUsageObserved = memoryUsed.baseUsage;\n+                    for (long i = 0; i < allocationCount; ++i) {\n+                        long current = currentMemoryUsageSupplier.getAsLong();\n+                        if (current >= maxUsageObserved) {\n+                            maxUsageObserved = current;\n+                        } else {\n+                            // we observed a memory drop, so some GC must have occurred\n+                            break;\n+                        }\n+                        localBlackHole += new byte[allocationSize].hashCode();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05ec98a32ac3e5dfb516726bf4904f412fc62595"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU3NDQyNg==", "bodyText": "Yes and no.\nIn theory yes, if there is really no collectible heap left.\nBut if that was the case, just creating the CircuitBreakingException poses the same risk. And if we are that close, we are doomed anyway I think. The chances of us having a workload at exactly 99.95 percent heap  (corresponding to approximately 2000 regions) and surviving is so small that even if it was the case, the next time round we enter the same workload it would fall over.\nNotice that we only need 1 region of space free or collectible space for this to succeed.", "url": "https://github.com/elastic/elasticsearch/pull/58674#discussion_r448574426", "createdAt": "2020-07-01T19:34:04Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/indices/breaker/HierarchyCircuitBreakerService.java", "diffHunk": "@@ -334,4 +360,113 @@ private CircuitBreaker validateAndCreateBreaker(BreakerSettings breakerSettings)\n                 this,\n                 breakerSettings.getName());\n     }\n+\n+    private static DoubleCheckStrategy createDoubleCheckStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,\n+                                                                 LongSupplier timeSupplier, long minimumInterval) {\n+        if (jvmInfo.useG1GC().equals(\"true\")\n+            // messing with GC is \"dangerous\" so we apply an escape hatch. Not intended to be used.\n+            && Boolean.parseBoolean(System.getProperty(\"es.real_memory_circuit_breaker.g1.double_check.enabled\", \"true\"))) {\n+            return new G1DoubleCheckStrategy(jvmInfo, currentMemoryUsageSupplier, timeSupplier, minimumInterval);\n+        } else {\n+            return memoryUsed -> memoryUsed;\n+        }\n+    }\n+\n+    interface DoubleCheckStrategy {\n+        MemoryUsage doubleCheck(MemoryUsage memoryUsed);\n+    }\n+\n+    static class G1DoubleCheckStrategy implements DoubleCheckStrategy {\n+        private final long g1RegionSize;\n+        private final LongSupplier currentMemoryUsageSupplier;\n+        private final LongSupplier timeSupplier;\n+\n+        private long lastCheckTime = Long.MIN_VALUE;\n+        private final long minimumInterval;\n+\n+        private long blackHole;\n+        private final Object lock = new Object();\n+\n+        G1DoubleCheckStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,\n+                                     LongSupplier timeSupplier, long minimumInterval) {\n+            assert minimumInterval > 0;\n+            this.currentMemoryUsageSupplier = currentMemoryUsageSupplier;\n+            this.timeSupplier = timeSupplier;\n+            this.minimumInterval = minimumInterval;\n+            long g1RegionSize = jvmInfo.getG1RegionSize();\n+            if (g1RegionSize <= 0) {\n+\n+                this.g1RegionSize = fallbackRegionSize(jvmInfo);\n+            } else {\n+                this.g1RegionSize = g1RegionSize;\n+            }\n+        }\n+\n+        static long fallbackRegionSize(JvmInfo jvmInfo) {\n+            // mimick JDK calculation\n+            long averageHeapSize =\n+                (jvmInfo.getMem().getHeapMax().getBytes() + JvmInfo.jvmInfo().getMem().getHeapMax().getBytes()) / 2;\n+            long regionSize = Long.highestOneBit(averageHeapSize / 2048);\n+            if (regionSize < ByteSizeUnit.MB.toBytes(1)) {\n+                regionSize = ByteSizeUnit.MB.toBytes(1);\n+            } else if (regionSize > ByteSizeUnit.MB.toBytes(32)) {\n+                regionSize = ByteSizeUnit.MB.toBytes(32);\n+            }\n+            return regionSize;\n+        }\n+\n+        @Override\n+        public MemoryUsage doubleCheck(MemoryUsage memoryUsed) {\n+            long maxHeap = JvmInfo.jvmInfo().getMem().getHeapMax().getBytes();\n+            boolean leader;\n+            synchronized (lock) {\n+                leader = timeSupplier.getAsLong() >= lastCheckTime + minimumInterval;\n+                doubleCheckingRealMemoryUsed(leader);\n+                if (leader) {\n+                    logger.info(\"attempting to trigger G1GC due to high heap usage [{}]\", memoryUsed.baseUsage);\n+                    long localBlackHole = 0;\n+                    // number of allocations, corresponding to (approximately) number of free regions + 1\n+                    long allocationCount = (maxHeap - memoryUsed.baseUsage) / g1RegionSize + 1;\n+                    // allocations of half-region size becomes single humongous alloc, thus taking up a full region.\n+                    int allocationSize = (int) (g1RegionSize >> 1);\n+                    long maxUsageObserved = memoryUsed.baseUsage;\n+                    for (long i = 0; i < allocationCount; ++i) {\n+                        long current = currentMemoryUsageSupplier.getAsLong();\n+                        if (current >= maxUsageObserved) {\n+                            maxUsageObserved = current;\n+                        } else {\n+                            // we observed a memory drop, so some GC must have occurred\n+                            break;\n+                        }\n+                        localBlackHole += new byte[allocationSize].hashCode();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3Nzg2Nw=="}, "originalCommit": {"oid": "05ec98a32ac3e5dfb516726bf4904f412fc62595"}, "originalPosition": 170}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NDcyNDQyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/indices/breaker/HierarchyCircuitBreakerService.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxNDowNzowMlrOGrncRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxNzowMToyNFrOGtfylA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODM4ODE2Nw==", "bodyText": "Any reason to use lock over this?", "url": "https://github.com/elastic/elasticsearch/pull/58674#discussion_r448388167", "createdAt": "2020-07-01T14:07:02Z", "author": {"login": "jaymode"}, "path": "server/src/main/java/org/elasticsearch/indices/breaker/HierarchyCircuitBreakerService.java", "diffHunk": "@@ -334,4 +360,113 @@ private CircuitBreaker validateAndCreateBreaker(BreakerSettings breakerSettings)\n                 this,\n                 breakerSettings.getName());\n     }\n+\n+    private static DoubleCheckStrategy createDoubleCheckStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,\n+                                                                 LongSupplier timeSupplier, long minimumInterval) {\n+        if (jvmInfo.useG1GC().equals(\"true\")\n+            // messing with GC is \"dangerous\" so we apply an escape hatch. Not intended to be used.\n+            && Boolean.parseBoolean(System.getProperty(\"es.real_memory_circuit_breaker.g1.double_check.enabled\", \"true\"))) {\n+            return new G1DoubleCheckStrategy(jvmInfo, currentMemoryUsageSupplier, timeSupplier, minimumInterval);\n+        } else {\n+            return memoryUsed -> memoryUsed;\n+        }\n+    }\n+\n+    interface DoubleCheckStrategy {\n+        MemoryUsage doubleCheck(MemoryUsage memoryUsed);\n+    }\n+\n+    static class G1DoubleCheckStrategy implements DoubleCheckStrategy {\n+        private final long g1RegionSize;\n+        private final LongSupplier currentMemoryUsageSupplier;\n+        private final LongSupplier timeSupplier;\n+\n+        private long lastCheckTime = Long.MIN_VALUE;\n+        private final long minimumInterval;\n+\n+        private long blackHole;\n+        private final Object lock = new Object();\n+\n+        G1DoubleCheckStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,\n+                                     LongSupplier timeSupplier, long minimumInterval) {\n+            assert minimumInterval > 0;\n+            this.currentMemoryUsageSupplier = currentMemoryUsageSupplier;\n+            this.timeSupplier = timeSupplier;\n+            this.minimumInterval = minimumInterval;\n+            long g1RegionSize = jvmInfo.getG1RegionSize();\n+            if (g1RegionSize <= 0) {\n+\n+                this.g1RegionSize = fallbackRegionSize(jvmInfo);\n+            } else {\n+                this.g1RegionSize = g1RegionSize;\n+            }\n+        }\n+\n+        static long fallbackRegionSize(JvmInfo jvmInfo) {\n+            // mimick JDK calculation\n+            long averageHeapSize =\n+                (jvmInfo.getMem().getHeapMax().getBytes() + JvmInfo.jvmInfo().getMem().getHeapMax().getBytes()) / 2;\n+            long regionSize = Long.highestOneBit(averageHeapSize / 2048);\n+            if (regionSize < ByteSizeUnit.MB.toBytes(1)) {\n+                regionSize = ByteSizeUnit.MB.toBytes(1);\n+            } else if (regionSize > ByteSizeUnit.MB.toBytes(32)) {\n+                regionSize = ByteSizeUnit.MB.toBytes(32);\n+            }\n+            return regionSize;\n+        }\n+\n+        @Override\n+        public MemoryUsage doubleCheck(MemoryUsage memoryUsed) {\n+            long maxHeap = JvmInfo.jvmInfo().getMem().getHeapMax().getBytes();\n+            boolean leader;\n+            synchronized (lock) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05ec98a32ac3e5dfb516726bf4904f412fc62595"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU3MjA5Ng==", "bodyText": "Given the locality of the usage, not really, it is just a personal preference since it avoids thinking about external synchronization on this. I am OK turning it into this if you prefer?", "url": "https://github.com/elastic/elasticsearch/pull/58674#discussion_r448572096", "createdAt": "2020-07-01T19:28:40Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/indices/breaker/HierarchyCircuitBreakerService.java", "diffHunk": "@@ -334,4 +360,113 @@ private CircuitBreaker validateAndCreateBreaker(BreakerSettings breakerSettings)\n                 this,\n                 breakerSettings.getName());\n     }\n+\n+    private static DoubleCheckStrategy createDoubleCheckStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,\n+                                                                 LongSupplier timeSupplier, long minimumInterval) {\n+        if (jvmInfo.useG1GC().equals(\"true\")\n+            // messing with GC is \"dangerous\" so we apply an escape hatch. Not intended to be used.\n+            && Boolean.parseBoolean(System.getProperty(\"es.real_memory_circuit_breaker.g1.double_check.enabled\", \"true\"))) {\n+            return new G1DoubleCheckStrategy(jvmInfo, currentMemoryUsageSupplier, timeSupplier, minimumInterval);\n+        } else {\n+            return memoryUsed -> memoryUsed;\n+        }\n+    }\n+\n+    interface DoubleCheckStrategy {\n+        MemoryUsage doubleCheck(MemoryUsage memoryUsed);\n+    }\n+\n+    static class G1DoubleCheckStrategy implements DoubleCheckStrategy {\n+        private final long g1RegionSize;\n+        private final LongSupplier currentMemoryUsageSupplier;\n+        private final LongSupplier timeSupplier;\n+\n+        private long lastCheckTime = Long.MIN_VALUE;\n+        private final long minimumInterval;\n+\n+        private long blackHole;\n+        private final Object lock = new Object();\n+\n+        G1DoubleCheckStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,\n+                                     LongSupplier timeSupplier, long minimumInterval) {\n+            assert minimumInterval > 0;\n+            this.currentMemoryUsageSupplier = currentMemoryUsageSupplier;\n+            this.timeSupplier = timeSupplier;\n+            this.minimumInterval = minimumInterval;\n+            long g1RegionSize = jvmInfo.getG1RegionSize();\n+            if (g1RegionSize <= 0) {\n+\n+                this.g1RegionSize = fallbackRegionSize(jvmInfo);\n+            } else {\n+                this.g1RegionSize = g1RegionSize;\n+            }\n+        }\n+\n+        static long fallbackRegionSize(JvmInfo jvmInfo) {\n+            // mimick JDK calculation\n+            long averageHeapSize =\n+                (jvmInfo.getMem().getHeapMax().getBytes() + JvmInfo.jvmInfo().getMem().getHeapMax().getBytes()) / 2;\n+            long regionSize = Long.highestOneBit(averageHeapSize / 2048);\n+            if (regionSize < ByteSizeUnit.MB.toBytes(1)) {\n+                regionSize = ByteSizeUnit.MB.toBytes(1);\n+            } else if (regionSize > ByteSizeUnit.MB.toBytes(32)) {\n+                regionSize = ByteSizeUnit.MB.toBytes(32);\n+            }\n+            return regionSize;\n+        }\n+\n+        @Override\n+        public MemoryUsage doubleCheck(MemoryUsage memoryUsed) {\n+            long maxHeap = JvmInfo.jvmInfo().getMem().getHeapMax().getBytes();\n+            boolean leader;\n+            synchronized (lock) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODM4ODE2Nw=="}, "originalCommit": {"oid": "05ec98a32ac3e5dfb516726bf4904f412fc62595"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM1OTk1Ng==", "bodyText": "I'm fine with it; just curious.", "url": "https://github.com/elastic/elasticsearch/pull/58674#discussion_r450359956", "createdAt": "2020-07-06T17:01:24Z", "author": {"login": "jaymode"}, "path": "server/src/main/java/org/elasticsearch/indices/breaker/HierarchyCircuitBreakerService.java", "diffHunk": "@@ -334,4 +360,113 @@ private CircuitBreaker validateAndCreateBreaker(BreakerSettings breakerSettings)\n                 this,\n                 breakerSettings.getName());\n     }\n+\n+    private static DoubleCheckStrategy createDoubleCheckStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,\n+                                                                 LongSupplier timeSupplier, long minimumInterval) {\n+        if (jvmInfo.useG1GC().equals(\"true\")\n+            // messing with GC is \"dangerous\" so we apply an escape hatch. Not intended to be used.\n+            && Boolean.parseBoolean(System.getProperty(\"es.real_memory_circuit_breaker.g1.double_check.enabled\", \"true\"))) {\n+            return new G1DoubleCheckStrategy(jvmInfo, currentMemoryUsageSupplier, timeSupplier, minimumInterval);\n+        } else {\n+            return memoryUsed -> memoryUsed;\n+        }\n+    }\n+\n+    interface DoubleCheckStrategy {\n+        MemoryUsage doubleCheck(MemoryUsage memoryUsed);\n+    }\n+\n+    static class G1DoubleCheckStrategy implements DoubleCheckStrategy {\n+        private final long g1RegionSize;\n+        private final LongSupplier currentMemoryUsageSupplier;\n+        private final LongSupplier timeSupplier;\n+\n+        private long lastCheckTime = Long.MIN_VALUE;\n+        private final long minimumInterval;\n+\n+        private long blackHole;\n+        private final Object lock = new Object();\n+\n+        G1DoubleCheckStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,\n+                                     LongSupplier timeSupplier, long minimumInterval) {\n+            assert minimumInterval > 0;\n+            this.currentMemoryUsageSupplier = currentMemoryUsageSupplier;\n+            this.timeSupplier = timeSupplier;\n+            this.minimumInterval = minimumInterval;\n+            long g1RegionSize = jvmInfo.getG1RegionSize();\n+            if (g1RegionSize <= 0) {\n+\n+                this.g1RegionSize = fallbackRegionSize(jvmInfo);\n+            } else {\n+                this.g1RegionSize = g1RegionSize;\n+            }\n+        }\n+\n+        static long fallbackRegionSize(JvmInfo jvmInfo) {\n+            // mimick JDK calculation\n+            long averageHeapSize =\n+                (jvmInfo.getMem().getHeapMax().getBytes() + JvmInfo.jvmInfo().getMem().getHeapMax().getBytes()) / 2;\n+            long regionSize = Long.highestOneBit(averageHeapSize / 2048);\n+            if (regionSize < ByteSizeUnit.MB.toBytes(1)) {\n+                regionSize = ByteSizeUnit.MB.toBytes(1);\n+            } else if (regionSize > ByteSizeUnit.MB.toBytes(32)) {\n+                regionSize = ByteSizeUnit.MB.toBytes(32);\n+            }\n+            return regionSize;\n+        }\n+\n+        @Override\n+        public MemoryUsage doubleCheck(MemoryUsage memoryUsed) {\n+            long maxHeap = JvmInfo.jvmInfo().getMem().getHeapMax().getBytes();\n+            boolean leader;\n+            synchronized (lock) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODM4ODE2Nw=="}, "originalCommit": {"oid": "05ec98a32ac3e5dfb516726bf4904f412fc62595"}, "originalPosition": 151}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwNzc3ODg1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/indices/breaker/HierarchyCircuitBreakerService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxNzowMDo0MVrOGtfxOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMDo1OTo1M1rOGuPZbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM1OTYxMA==", "bodyText": "Since this appears to be a consistent value, maybe we just keep it as a final long that is a class member.", "url": "https://github.com/elastic/elasticsearch/pull/58674#discussion_r450359610", "createdAt": "2020-07-06T17:00:41Z", "author": {"login": "jaymode"}, "path": "server/src/main/java/org/elasticsearch/indices/breaker/HierarchyCircuitBreakerService.java", "diffHunk": "@@ -334,4 +360,116 @@ private CircuitBreaker validateAndCreateBreaker(BreakerSettings breakerSettings)\n                 this,\n                 breakerSettings.getName());\n     }\n+\n+    private static OverLimitStrategy createDoubleCheckStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,\n+                                                               LongSupplier timeSupplier, long minimumInterval) {\n+        if (jvmInfo.useG1GC().equals(\"true\")\n+            // messing with GC is \"dangerous\" so we apply an escape hatch. Not intended to be used.\n+            && Boolean.parseBoolean(System.getProperty(\"es.real_memory_circuit_breaker.g1.double_check.enabled\", \"true\"))) {\n+            return new G1OverLimitStrategy(jvmInfo, currentMemoryUsageSupplier, timeSupplier, minimumInterval);\n+        } else {\n+            return memoryUsed -> memoryUsed;\n+        }\n+    }\n+\n+    interface OverLimitStrategy {\n+        MemoryUsage overLimit(MemoryUsage memoryUsed);\n+    }\n+\n+    static class G1OverLimitStrategy implements OverLimitStrategy {\n+        private final long g1RegionSize;\n+        private final LongSupplier currentMemoryUsageSupplier;\n+        private final LongSupplier timeSupplier;\n+\n+        private long lastCheckTime = Long.MIN_VALUE;\n+        private final long minimumInterval;\n+\n+        private long blackHole;\n+        private final Object lock = new Object();\n+\n+        G1OverLimitStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,\n+                            LongSupplier timeSupplier, long minimumInterval) {\n+            assert minimumInterval > 0;\n+            this.currentMemoryUsageSupplier = currentMemoryUsageSupplier;\n+            this.timeSupplier = timeSupplier;\n+            this.minimumInterval = minimumInterval;\n+            long g1RegionSize = jvmInfo.getG1RegionSize();\n+            if (g1RegionSize <= 0) {\n+\n+                this.g1RegionSize = fallbackRegionSize(jvmInfo);\n+            } else {\n+                this.g1RegionSize = g1RegionSize;\n+            }\n+        }\n+\n+        static long fallbackRegionSize(JvmInfo jvmInfo) {\n+            // mimick JDK calculation based on JDK 14 source:\n+            // https://hg.openjdk.java.net/jdk/jdk14/file/6c954123ee8d/src/hotspot/share/gc/g1/heapRegion.cpp#l65\n+            // notice that newer JDKs will have a slight variant only considering max-heap:\n+            // https://hg.openjdk.java.net/jdk/jdk/file/e7d0ec2d06e8/src/hotspot/share/gc/g1/heapRegion.cpp#l67\n+            // based on this JDK \"bug\":\n+            // https://bugs.openjdk.java.net/browse/JDK-8241670\n+            long averageHeapSize =\n+                (jvmInfo.getMem().getHeapMax().getBytes() + JvmInfo.jvmInfo().getMem().getHeapMax().getBytes()) / 2;\n+            long regionSize = Long.highestOneBit(averageHeapSize / 2048);\n+            if (regionSize < ByteSizeUnit.MB.toBytes(1)) {\n+                regionSize = ByteSizeUnit.MB.toBytes(1);\n+            } else if (regionSize > ByteSizeUnit.MB.toBytes(32)) {\n+                regionSize = ByteSizeUnit.MB.toBytes(32);\n+            }\n+            return regionSize;\n+        }\n+\n+        @Override\n+        public MemoryUsage overLimit(MemoryUsage memoryUsed) {\n+            long maxHeap = JvmInfo.jvmInfo().getMem().getHeapMax().getBytes();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66d642dd32bc3f92510a94ecfba3da12b2cd3f86"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTEzOTk0OA==", "bodyText": "Fixed in 3eacf32", "url": "https://github.com/elastic/elasticsearch/pull/58674#discussion_r451139948", "createdAt": "2020-07-07T20:59:53Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/indices/breaker/HierarchyCircuitBreakerService.java", "diffHunk": "@@ -334,4 +360,116 @@ private CircuitBreaker validateAndCreateBreaker(BreakerSettings breakerSettings)\n                 this,\n                 breakerSettings.getName());\n     }\n+\n+    private static OverLimitStrategy createDoubleCheckStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,\n+                                                               LongSupplier timeSupplier, long minimumInterval) {\n+        if (jvmInfo.useG1GC().equals(\"true\")\n+            // messing with GC is \"dangerous\" so we apply an escape hatch. Not intended to be used.\n+            && Boolean.parseBoolean(System.getProperty(\"es.real_memory_circuit_breaker.g1.double_check.enabled\", \"true\"))) {\n+            return new G1OverLimitStrategy(jvmInfo, currentMemoryUsageSupplier, timeSupplier, minimumInterval);\n+        } else {\n+            return memoryUsed -> memoryUsed;\n+        }\n+    }\n+\n+    interface OverLimitStrategy {\n+        MemoryUsage overLimit(MemoryUsage memoryUsed);\n+    }\n+\n+    static class G1OverLimitStrategy implements OverLimitStrategy {\n+        private final long g1RegionSize;\n+        private final LongSupplier currentMemoryUsageSupplier;\n+        private final LongSupplier timeSupplier;\n+\n+        private long lastCheckTime = Long.MIN_VALUE;\n+        private final long minimumInterval;\n+\n+        private long blackHole;\n+        private final Object lock = new Object();\n+\n+        G1OverLimitStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,\n+                            LongSupplier timeSupplier, long minimumInterval) {\n+            assert minimumInterval > 0;\n+            this.currentMemoryUsageSupplier = currentMemoryUsageSupplier;\n+            this.timeSupplier = timeSupplier;\n+            this.minimumInterval = minimumInterval;\n+            long g1RegionSize = jvmInfo.getG1RegionSize();\n+            if (g1RegionSize <= 0) {\n+\n+                this.g1RegionSize = fallbackRegionSize(jvmInfo);\n+            } else {\n+                this.g1RegionSize = g1RegionSize;\n+            }\n+        }\n+\n+        static long fallbackRegionSize(JvmInfo jvmInfo) {\n+            // mimick JDK calculation based on JDK 14 source:\n+            // https://hg.openjdk.java.net/jdk/jdk14/file/6c954123ee8d/src/hotspot/share/gc/g1/heapRegion.cpp#l65\n+            // notice that newer JDKs will have a slight variant only considering max-heap:\n+            // https://hg.openjdk.java.net/jdk/jdk/file/e7d0ec2d06e8/src/hotspot/share/gc/g1/heapRegion.cpp#l67\n+            // based on this JDK \"bug\":\n+            // https://bugs.openjdk.java.net/browse/JDK-8241670\n+            long averageHeapSize =\n+                (jvmInfo.getMem().getHeapMax().getBytes() + JvmInfo.jvmInfo().getMem().getHeapMax().getBytes()) / 2;\n+            long regionSize = Long.highestOneBit(averageHeapSize / 2048);\n+            if (regionSize < ByteSizeUnit.MB.toBytes(1)) {\n+                regionSize = ByteSizeUnit.MB.toBytes(1);\n+            } else if (regionSize > ByteSizeUnit.MB.toBytes(32)) {\n+                regionSize = ByteSizeUnit.MB.toBytes(32);\n+            }\n+            return regionSize;\n+        }\n+\n+        @Override\n+        public MemoryUsage overLimit(MemoryUsage memoryUsed) {\n+            long maxHeap = JvmInfo.jvmInfo().getMem().getHeapMax().getBytes();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM1OTYxMA=="}, "originalCommit": {"oid": "66d642dd32bc3f92510a94ecfba3da12b2cd3f86"}, "originalPosition": 154}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMTY3Nzg1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/indices/breaker/HierarchyCircuitBreakerService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNjowMDoyMlrOGuFTUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMTowMDozNVrOGuPbKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk3NDU0Nw==", "bodyText": "Maybe the method call can be replaced with overLimitStrategy.apply(memoryUsed) and the construction of the OverLimitStrategy will be responsible for handling the behavior of what to do?", "url": "https://github.com/elastic/elasticsearch/pull/58674#discussion_r450974547", "createdAt": "2020-07-07T16:00:22Z", "author": {"login": "jaymode"}, "path": "server/src/main/java/org/elasticsearch/indices/breaker/HierarchyCircuitBreakerService.java", "diffHunk": "@@ -290,7 +308,7 @@ public long getParentLimit() {\n     public void checkParentLimit(long newBytesReserved, String label) throws CircuitBreakingException {\n         final MemoryUsage memoryUsed = memoryUsed(newBytesReserved);\n         long parentLimit = this.parentSettings.getLimit();\n-        if (memoryUsed.totalUsage > parentLimit) {\n+        if (memoryUsed.totalUsage > parentLimit && doubleCheckMemoryUsed(memoryUsed).totalUsage > parentLimit) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66d642dd32bc3f92510a94ecfba3da12b2cd3f86"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE0MDM5NA==", "bodyText": "Good idea, done in 3f61f93", "url": "https://github.com/elastic/elasticsearch/pull/58674#discussion_r451140394", "createdAt": "2020-07-07T21:00:35Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/indices/breaker/HierarchyCircuitBreakerService.java", "diffHunk": "@@ -290,7 +308,7 @@ public long getParentLimit() {\n     public void checkParentLimit(long newBytesReserved, String label) throws CircuitBreakingException {\n         final MemoryUsage memoryUsed = memoryUsed(newBytesReserved);\n         long parentLimit = this.parentSettings.getLimit();\n-        if (memoryUsed.totalUsage > parentLimit) {\n+        if (memoryUsed.totalUsage > parentLimit && doubleCheckMemoryUsed(memoryUsed).totalUsage > parentLimit) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk3NDU0Nw=="}, "originalCommit": {"oid": "66d642dd32bc3f92510a94ecfba3da12b2cd3f86"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMTc0NTE3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/indices/breaker/HierarchyCircuitBreakerService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNjoxNjo0N1rOGuF9Sw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNjoxNjo0N1rOGuF9Sw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk4NTI5MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static OverLimitStrategy createDoubleCheckStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,\n          \n          \n            \n                private static OverLimitStrategy createOverLimitStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,", "url": "https://github.com/elastic/elasticsearch/pull/58674#discussion_r450985291", "createdAt": "2020-07-07T16:16:47Z", "author": {"login": "jaymode"}, "path": "server/src/main/java/org/elasticsearch/indices/breaker/HierarchyCircuitBreakerService.java", "diffHunk": "@@ -334,4 +360,116 @@ private CircuitBreaker validateAndCreateBreaker(BreakerSettings breakerSettings)\n                 this,\n                 breakerSettings.getName());\n     }\n+\n+    private static OverLimitStrategy createDoubleCheckStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66d642dd32bc3f92510a94ecfba3da12b2cd3f86"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMTc1NzEzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/indices/breaker/HierarchyCircuitBreakerService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNjoxOTo1OFrOGuGEzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMTowMToyMVrOGuPcqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk4NzIxNA==", "bodyText": "In line with an earlier comment, we could pass in trackRealMemoryUsage to this method and add it to this check.", "url": "https://github.com/elastic/elasticsearch/pull/58674#discussion_r450987214", "createdAt": "2020-07-07T16:19:58Z", "author": {"login": "jaymode"}, "path": "server/src/main/java/org/elasticsearch/indices/breaker/HierarchyCircuitBreakerService.java", "diffHunk": "@@ -334,4 +360,116 @@ private CircuitBreaker validateAndCreateBreaker(BreakerSettings breakerSettings)\n                 this,\n                 breakerSettings.getName());\n     }\n+\n+    private static OverLimitStrategy createDoubleCheckStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,\n+                                                               LongSupplier timeSupplier, long minimumInterval) {\n+        if (jvmInfo.useG1GC().equals(\"true\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66d642dd32bc3f92510a94ecfba3da12b2cd3f86"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE0MDc3Ng==", "bodyText": "Also part of 3f61f93", "url": "https://github.com/elastic/elasticsearch/pull/58674#discussion_r451140776", "createdAt": "2020-07-07T21:01:21Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/indices/breaker/HierarchyCircuitBreakerService.java", "diffHunk": "@@ -334,4 +360,116 @@ private CircuitBreaker validateAndCreateBreaker(BreakerSettings breakerSettings)\n                 this,\n                 breakerSettings.getName());\n     }\n+\n+    private static OverLimitStrategy createDoubleCheckStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,\n+                                                               LongSupplier timeSupplier, long minimumInterval) {\n+        if (jvmInfo.useG1GC().equals(\"true\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk4NzIxNA=="}, "originalCommit": {"oid": "66d642dd32bc3f92510a94ecfba3da12b2cd3f86"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMTc2NDI3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/indices/breaker/HierarchyCircuitBreakerService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNjoyMTo0M1rOGuGJQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMTowMTo0NVrOGuPdbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk4ODM1NA==", "bodyText": "Do you mind using Booleans.parseBoolean(System.getProperty(\"es.real_memory_circuit_breaker.g1.double_check.enabled\"), true)? The java Boolean parsing is pretty lenient and I thought it was a forbidden api at some point :|", "url": "https://github.com/elastic/elasticsearch/pull/58674#discussion_r450988354", "createdAt": "2020-07-07T16:21:43Z", "author": {"login": "jaymode"}, "path": "server/src/main/java/org/elasticsearch/indices/breaker/HierarchyCircuitBreakerService.java", "diffHunk": "@@ -334,4 +360,116 @@ private CircuitBreaker validateAndCreateBreaker(BreakerSettings breakerSettings)\n                 this,\n                 breakerSettings.getName());\n     }\n+\n+    private static OverLimitStrategy createDoubleCheckStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,\n+                                                               LongSupplier timeSupplier, long minimumInterval) {\n+        if (jvmInfo.useG1GC().equals(\"true\")\n+            // messing with GC is \"dangerous\" so we apply an escape hatch. Not intended to be used.\n+            && Boolean.parseBoolean(System.getProperty(\"es.real_memory_circuit_breaker.g1.double_check.enabled\", \"true\"))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66d642dd32bc3f92510a94ecfba3da12b2cd3f86"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE0MDk3NA==", "bodyText": "Thanks, fixed in 845dc10", "url": "https://github.com/elastic/elasticsearch/pull/58674#discussion_r451140974", "createdAt": "2020-07-07T21:01:45Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/indices/breaker/HierarchyCircuitBreakerService.java", "diffHunk": "@@ -334,4 +360,116 @@ private CircuitBreaker validateAndCreateBreaker(BreakerSettings breakerSettings)\n                 this,\n                 breakerSettings.getName());\n     }\n+\n+    private static OverLimitStrategy createDoubleCheckStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,\n+                                                               LongSupplier timeSupplier, long minimumInterval) {\n+        if (jvmInfo.useG1GC().equals(\"true\")\n+            // messing with GC is \"dangerous\" so we apply an escape hatch. Not intended to be used.\n+            && Boolean.parseBoolean(System.getProperty(\"es.real_memory_circuit_breaker.g1.double_check.enabled\", \"true\"))) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk4ODM1NA=="}, "originalCommit": {"oid": "66d642dd32bc3f92510a94ecfba3da12b2cd3f86"}, "originalPosition": 97}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2245, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}