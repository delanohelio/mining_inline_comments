{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA5MDQ4OTg0", "number": 64098, "title": "Make Primary Relocation Not Blocking on Transport Request", "bodyText": "Resolving TODOs about primary relocation blocking on network IO.", "createdAt": "2020-10-23T15:37:25Z", "url": "https://github.com/elastic/elasticsearch/pull/64098", "merged": true, "mergeCommit": {"oid": "7b8637e3a680af6a3930b2e2fc9f4f1f121bd797"}, "closed": true, "closedAt": "2020-11-23T14:28:19Z", "author": {"login": "original-brownbear"}, "timelineItems": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdVP-yUAH2gAyNTA5MDQ4OTg0OjQ2YTU4MWI4MGQyMWEyYzZlMmY4MjBiNmM5NTcwNWY2OTA2ODRjOGU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdfV-jSgFqTUzNjUxODA5MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "46a581b80d21a2c6e2f820b6c95705f690684c8e", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/46a581b80d21a2c6e2f820b6c95705f690684c8e", "committedDate": "2020-10-23T05:46:48Z", "message": "Make Primary Relocation Fully Async\n\nResolving TODOs about primary relocation not being fully async."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "02a19dc505ee95dd790221fac5146019a41870f1", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/02a19dc505ee95dd790221fac5146019a41870f1", "committedDate": "2020-10-23T05:46:48Z", "message": "works"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1b0b521b8d6ea1bf4027bc7e5838d6752d1a265b", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/1b0b521b8d6ea1bf4027bc7e5838d6752d1a265b", "committedDate": "2020-10-23T09:26:43Z", "message": "Merge remote-tracking branch 'elastic/master' into fully-async-relocations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b384c3bca221b351832a8559b8a0c5e6eb8851cf", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/b384c3bca221b351832a8559b8a0c5e6eb8851cf", "committedDate": "2020-10-23T14:39:10Z", "message": "nicer"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7138b9796762b1ffa87bbfc0736c2686629e96ae", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/7138b9796762b1ffa87bbfc0736c2686629e96ae", "committedDate": "2020-10-23T15:32:57Z", "message": "nicer + docs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e55c33bf2338eb2ce901a55c27cd7beaa1bc9dbd", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/e55c33bf2338eb2ce901a55c27cd7beaa1bc9dbd", "committedDate": "2020-11-19T09:15:28Z", "message": "Merge remote-tracking branch 'elastic/master' into fully-async-relocations"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM0NDAxODU2", "url": "https://github.com/elastic/elasticsearch/pull/64098#pullrequestreview-534401856", "createdAt": "2020-11-19T12:45:01Z", "commit": {"oid": "e55c33bf2338eb2ce901a55c27cd7beaa1bc9dbd"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxMjo0NTowMlrOH2cgYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxMzowNzoxMVrOH2dVRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjg1MjE5NA==", "bodyText": "This is pretty much the following, right?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                            ActionListener.wrap(\n          \n          \n            \n                                            ActionListener.map(new ChannelActionListener<>(channel, Actions.HANDOFF_PRIMARY_CONTEXT, request), \n          \n          \n            \n                                                    v -> TransportResponse.Empty.INSTANCE),", "url": "https://github.com/elastic/elasticsearch/pull/64098#discussion_r526852194", "createdAt": "2020-11-19T12:45:02Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/indices/recovery/PeerRecoveryTargetService.java", "diffHunk": "@@ -311,10 +311,27 @@ public void messageReceived(RecoveryFinalizeRecoveryRequest request, TransportCh\n         @Override\n         public void messageReceived(final RecoveryHandoffPrimaryContextRequest request, final TransportChannel channel,\n                                     Task task) throws Exception {\n-            try (RecoveryRef recoveryRef = onGoingRecoveries.getRecoverySafe(request.recoveryId(), request.shardId())) {\n-                recoveryRef.target().handoffPrimaryContext(request.primaryContext());\n+            final RecoveryRef recoveryRef = onGoingRecoveries.getRecoverySafe(request.recoveryId(), request.shardId());\n+            boolean success = false;\n+            try {\n+                recoveryRef.target().handoffPrimaryContext(request.primaryContext(),\n+                        ActionListener.runBefore(\n+                                ActionListener.wrap(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e55c33bf2338eb2ce901a55c27cd7beaa1bc9dbd"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjg1NzQ3Nw==", "bodyText": "This forks a new thread which blocks, pending acquiring all the permits, but that means we are now blocking outside the scope of the CancellableThreads so will no longer interrupt this wait if the recovery is cancelled.", "url": "https://github.com/elastic/elasticsearch/pull/64098#discussion_r526857477", "createdAt": "2020-11-19T12:53:40Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/index/shard/IndexShard.java", "diffHunk": "@@ -659,49 +659,94 @@ public IndexShardState markAsRecovering(String reason, RecoveryState recoverySta\n \n     /**\n      * Completes the relocation. Operations are blocked and current operations are drained before changing state to relocated. The provided\n-     * {@link Runnable} is executed after all operations are successfully blocked.\n+     * {@link BiConsumer} is executed after all operations are successfully blocked.\n      *\n-     * @param consumer a {@link Runnable} that is executed after operations are blocked\n+     * @param consumer a {@link BiConsumer} that is executed after operations are blocked and that consumes the primary context as well as\n+     *                 a listener to resolve once it finished\n+     * @param listener listener to resolve once this method actions including executing {@code consumer} in the non-failure case complete\n      * @throws IllegalIndexShardStateException if the shard is not relocating due to concurrent cancellation\n      * @throws IllegalStateException           if the relocation target is no longer part of the replication group\n-     * @throws InterruptedException            if blocking operations is interrupted\n      */\n-    public void relocated(final String targetAllocationId, final Consumer<ReplicationTracker.PrimaryContext> consumer)\n-        throws IllegalIndexShardStateException, IllegalStateException, InterruptedException {\n+    public void relocated(final String targetAllocationId,\n+                          final BiConsumer<ReplicationTracker.PrimaryContext, ActionListener<Void>> consumer,\n+                          final ActionListener<Void> listener)\n+            throws IllegalIndexShardStateException, IllegalStateException {\n         assert shardRouting.primary() : \"only primaries can be marked as relocated: \" + shardRouting;\n         try (Releasable forceRefreshes = refreshListeners.forceRefreshes()) {\n-            indexShardOperationPermits.blockOperations(30, TimeUnit.MINUTES, () -> {\n-                forceRefreshes.close();\n-                // no shard operation permits are being held here, move state from started to relocated\n-                assert indexShardOperationPermits.getActiveOperationsCount() == OPERATIONS_BLOCKED :\n-                        \"in-flight operations in progress while moving shard state to relocated\";\n-                /*\n-                 * We should not invoke the runnable under the mutex as the expected implementation is to handoff the primary context via a\n-                 * network operation. Doing this under the mutex can implicitly block the cluster state update thread on network operations.\n-                 */\n-                verifyRelocatingState();\n-                final ReplicationTracker.PrimaryContext primaryContext = replicationTracker.startRelocationHandoff(targetAllocationId);\n-                try {\n-                    consumer.accept(primaryContext);\n-                    synchronized (mutex) {\n+            indexShardOperationPermits.asyncBlockOperations(new ActionListener<>() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e55c33bf2338eb2ce901a55c27cd7beaa1bc9dbd"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjg1ODUxMA==", "bodyText": "We used to wait for 30 minutes to acquire all the permits -- I don't think 30 seconds is enough in general.", "url": "https://github.com/elastic/elasticsearch/pull/64098#discussion_r526858510", "createdAt": "2020-11-19T12:55:22Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/index/shard/IndexShard.java", "diffHunk": "@@ -659,49 +659,94 @@ public IndexShardState markAsRecovering(String reason, RecoveryState recoverySta\n \n     /**\n      * Completes the relocation. Operations are blocked and current operations are drained before changing state to relocated. The provided\n-     * {@link Runnable} is executed after all operations are successfully blocked.\n+     * {@link BiConsumer} is executed after all operations are successfully blocked.\n      *\n-     * @param consumer a {@link Runnable} that is executed after operations are blocked\n+     * @param consumer a {@link BiConsumer} that is executed after operations are blocked and that consumes the primary context as well as\n+     *                 a listener to resolve once it finished\n+     * @param listener listener to resolve once this method actions including executing {@code consumer} in the non-failure case complete\n      * @throws IllegalIndexShardStateException if the shard is not relocating due to concurrent cancellation\n      * @throws IllegalStateException           if the relocation target is no longer part of the replication group\n-     * @throws InterruptedException            if blocking operations is interrupted\n      */\n-    public void relocated(final String targetAllocationId, final Consumer<ReplicationTracker.PrimaryContext> consumer)\n-        throws IllegalIndexShardStateException, IllegalStateException, InterruptedException {\n+    public void relocated(final String targetAllocationId,\n+                          final BiConsumer<ReplicationTracker.PrimaryContext, ActionListener<Void>> consumer,\n+                          final ActionListener<Void> listener)\n+            throws IllegalIndexShardStateException, IllegalStateException {\n         assert shardRouting.primary() : \"only primaries can be marked as relocated: \" + shardRouting;\n         try (Releasable forceRefreshes = refreshListeners.forceRefreshes()) {\n-            indexShardOperationPermits.blockOperations(30, TimeUnit.MINUTES, () -> {\n-                forceRefreshes.close();\n-                // no shard operation permits are being held here, move state from started to relocated\n-                assert indexShardOperationPermits.getActiveOperationsCount() == OPERATIONS_BLOCKED :\n-                        \"in-flight operations in progress while moving shard state to relocated\";\n-                /*\n-                 * We should not invoke the runnable under the mutex as the expected implementation is to handoff the primary context via a\n-                 * network operation. Doing this under the mutex can implicitly block the cluster state update thread on network operations.\n-                 */\n-                verifyRelocatingState();\n-                final ReplicationTracker.PrimaryContext primaryContext = replicationTracker.startRelocationHandoff(targetAllocationId);\n-                try {\n-                    consumer.accept(primaryContext);\n-                    synchronized (mutex) {\n+            indexShardOperationPermits.asyncBlockOperations(new ActionListener<>() {\n+                @Override\n+                public void onResponse(Releasable releasable) {\n+                    boolean success = false;\n+                    try {\n+                        forceRefreshes.close();\n+                        // no shard operation permits are being held here, move state from started to relocated\n+                        assert indexShardOperationPermits.getActiveOperationsCount() == OPERATIONS_BLOCKED :\n+                                \"in-flight operations in progress while moving shard state to relocated\";\n+                        /*\n+                         * We should not invoke the runnable under the mutex as the expected implementation is to handoff the primary\n+                         * context via a network operation. Doing this under the mutex can implicitly block the cluster state update thread\n+                         * on network operations.\n+                         */\n                         verifyRelocatingState();\n-                        replicationTracker.completeRelocationHandoff(); // make changes to primaryMode and relocated flag only under mutex\n+                        final ReplicationTracker.PrimaryContext primaryContext =\n+                                replicationTracker.startRelocationHandoff(targetAllocationId);\n+                        // make sure we release all permits before we resolve the final listener\n+                        final ActionListener<Void> wrappedInnerListener = ActionListener.runBefore(listener, releasable::close);\n+                        final ActionListener<Void> wrappedListener = new ActionListener<>() {\n+                            @Override\n+                            public void onResponse(Void unused) {\n+                                try {\n+                                    // make changes to primaryMode and relocated flag only under mutex\n+                                    synchronized (mutex) {\n+                                        verifyRelocatingState();\n+                                        replicationTracker.completeRelocationHandoff();\n+                                    }\n+                                    wrappedInnerListener.onResponse(null);\n+                                } catch (Exception e) {\n+                                    onFailure(e);\n+                                }\n+                            }\n+\n+                            @Override\n+                            public void onFailure(Exception e) {\n+                                try {\n+                                    replicationTracker.abortRelocationHandoff();\n+                                } catch (final Exception inner) {\n+                                    e.addSuppressed(inner);\n+                                }\n+                                wrappedInnerListener.onFailure(e);\n+                            }\n+                        };\n+                        try {\n+                            consumer.accept(primaryContext, wrappedListener);\n+                        } catch (final Exception e) {\n+                            wrappedListener.onFailure(e);\n+                        }\n+                        success = true;\n+                    } catch (Exception e) {\n+                        listener.onFailure(e);\n+                    } finally {\n+                        if (success == false) {\n+                            releasable.close();\n+                        }\n                     }\n-                } catch (final Exception e) {\n-                    try {\n-                        replicationTracker.abortRelocationHandoff();\n-                    } catch (final Exception inner) {\n-                        e.addSuppressed(inner);\n+                }\n+\n+                @Override\n+                public void onFailure(Exception e) {\n+                    if (e instanceof TimeoutException) {\n+                        logger.warn(\"timed out waiting for relocation hand-off to complete\");\n+                        // This is really bad as ongoing replication operations are preventing this shard from completing relocation\n+                        // hand-off.\n+                        // Fail primary relocation source and target shards.\n+                        failShard(\"timed out waiting for relocation hand-off to complete\", null);\n+                        listener.onFailure(\n+                                new IndexShardClosedException(shardId(), \"timed out waiting for relocation hand-off to complete\"));\n+                    } else {\n+                        listener.onFailure(e);\n                     }\n-                    throw e;\n                 }\n-            });\n-        } catch (TimeoutException e) {\n-            logger.warn(\"timed out waiting for relocation hand-off to complete\");\n-            // This is really bad as ongoing replication operations are preventing this shard from completing relocation hand-off.\n-            // Fail primary relocation source and target shards.\n-            failShard(\"timed out waiting for relocation hand-off to complete\", null);\n-            throw new IndexShardClosedException(shardId(), \"timed out waiting for relocation hand-off to complete\");\n+            }, 30L, TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e55c33bf2338eb2ce901a55c27cd7beaa1bc9dbd"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjg2MjM1MA==", "bodyText": "Wondering why this doesn't use the executor like the other methods in this class.", "url": "https://github.com/elastic/elasticsearch/pull/64098#discussion_r526862350", "createdAt": "2020-11-19T13:01:30Z", "author": {"login": "DaveCTurner"}, "path": "test/framework/src/main/java/org/elasticsearch/indices/recovery/AsyncRecoveryTarget.java", "diffHunk": "@@ -55,8 +55,8 @@ public void finalizeRecovery(long globalCheckpoint, long trimAboveSeqNo, ActionL\n     }\n \n     @Override\n-    public void handoffPrimaryContext(ReplicationTracker.PrimaryContext primaryContext) {\n-        target.handoffPrimaryContext(primaryContext);\n+    public void handoffPrimaryContext(ReplicationTracker.PrimaryContext primaryContext, ActionListener<Void> listener) {\n+        target.handoffPrimaryContext(primaryContext, listener);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e55c33bf2338eb2ce901a55c27cd7beaa1bc9dbd"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjg2NTczNA==", "bodyText": "If listener.onResponse(null) throws an exception in here (e.g. the recovery was cancelled) then we've already closed the releasable, but calling onFailure() in the following catch clause will close it again.", "url": "https://github.com/elastic/elasticsearch/pull/64098#discussion_r526865734", "createdAt": "2020-11-19T13:07:11Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/index/shard/IndexShard.java", "diffHunk": "@@ -659,49 +659,94 @@ public IndexShardState markAsRecovering(String reason, RecoveryState recoverySta\n \n     /**\n      * Completes the relocation. Operations are blocked and current operations are drained before changing state to relocated. The provided\n-     * {@link Runnable} is executed after all operations are successfully blocked.\n+     * {@link BiConsumer} is executed after all operations are successfully blocked.\n      *\n-     * @param consumer a {@link Runnable} that is executed after operations are blocked\n+     * @param consumer a {@link BiConsumer} that is executed after operations are blocked and that consumes the primary context as well as\n+     *                 a listener to resolve once it finished\n+     * @param listener listener to resolve once this method actions including executing {@code consumer} in the non-failure case complete\n      * @throws IllegalIndexShardStateException if the shard is not relocating due to concurrent cancellation\n      * @throws IllegalStateException           if the relocation target is no longer part of the replication group\n-     * @throws InterruptedException            if blocking operations is interrupted\n      */\n-    public void relocated(final String targetAllocationId, final Consumer<ReplicationTracker.PrimaryContext> consumer)\n-        throws IllegalIndexShardStateException, IllegalStateException, InterruptedException {\n+    public void relocated(final String targetAllocationId,\n+                          final BiConsumer<ReplicationTracker.PrimaryContext, ActionListener<Void>> consumer,\n+                          final ActionListener<Void> listener)\n+            throws IllegalIndexShardStateException, IllegalStateException {\n         assert shardRouting.primary() : \"only primaries can be marked as relocated: \" + shardRouting;\n         try (Releasable forceRefreshes = refreshListeners.forceRefreshes()) {\n-            indexShardOperationPermits.blockOperations(30, TimeUnit.MINUTES, () -> {\n-                forceRefreshes.close();\n-                // no shard operation permits are being held here, move state from started to relocated\n-                assert indexShardOperationPermits.getActiveOperationsCount() == OPERATIONS_BLOCKED :\n-                        \"in-flight operations in progress while moving shard state to relocated\";\n-                /*\n-                 * We should not invoke the runnable under the mutex as the expected implementation is to handoff the primary context via a\n-                 * network operation. Doing this under the mutex can implicitly block the cluster state update thread on network operations.\n-                 */\n-                verifyRelocatingState();\n-                final ReplicationTracker.PrimaryContext primaryContext = replicationTracker.startRelocationHandoff(targetAllocationId);\n-                try {\n-                    consumer.accept(primaryContext);\n-                    synchronized (mutex) {\n+            indexShardOperationPermits.asyncBlockOperations(new ActionListener<>() {\n+                @Override\n+                public void onResponse(Releasable releasable) {\n+                    boolean success = false;\n+                    try {\n+                        forceRefreshes.close();\n+                        // no shard operation permits are being held here, move state from started to relocated\n+                        assert indexShardOperationPermits.getActiveOperationsCount() == OPERATIONS_BLOCKED :\n+                                \"in-flight operations in progress while moving shard state to relocated\";\n+                        /*\n+                         * We should not invoke the runnable under the mutex as the expected implementation is to handoff the primary\n+                         * context via a network operation. Doing this under the mutex can implicitly block the cluster state update thread\n+                         * on network operations.\n+                         */\n                         verifyRelocatingState();\n-                        replicationTracker.completeRelocationHandoff(); // make changes to primaryMode and relocated flag only under mutex\n+                        final ReplicationTracker.PrimaryContext primaryContext =\n+                                replicationTracker.startRelocationHandoff(targetAllocationId);\n+                        // make sure we release all permits before we resolve the final listener\n+                        final ActionListener<Void> wrappedInnerListener = ActionListener.runBefore(listener, releasable::close);\n+                        final ActionListener<Void> wrappedListener = new ActionListener<>() {\n+                            @Override\n+                            public void onResponse(Void unused) {\n+                                try {\n+                                    // make changes to primaryMode and relocated flag only under mutex\n+                                    synchronized (mutex) {\n+                                        verifyRelocatingState();\n+                                        replicationTracker.completeRelocationHandoff();\n+                                    }\n+                                    wrappedInnerListener.onResponse(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e55c33bf2338eb2ce901a55c27cd7beaa1bc9dbd"}, "originalPosition": 66}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a9d3fa6be6a70db0bb931f5d0dda95a1f5c7b006", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/a9d3fa6be6a70db0bb931f5d0dda95a1f5c7b006", "committedDate": "2020-11-19T14:09:16Z", "message": "Merge remote-tracking branch 'elastic/master' into fully-async-relocations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f93339eb826a88b7f66f6c525e5303baf44c188d", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/f93339eb826a88b7f66f6c525e5303baf44c188d", "committedDate": "2020-11-19T15:32:11Z", "message": "Merge remote-tracking branch 'elastic/master' into fully-async-relocations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9cdb46ba1c1d67af7ac555734d560cfc83578ff2", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/9cdb46ba1c1d67af7ac555734d560cfc83578ff2", "committedDate": "2020-11-22T18:54:44Z", "message": "keep it on SAME"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d140fc4a311db963c674449533abca71647e37e8", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/d140fc4a311db963c674449533abca71647e37e8", "committedDate": "2020-11-22T18:55:39Z", "message": "Merge remote-tracking branch 'elastic/master' into fully-async-relocations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3d4e7a68b5484b8d2e18c1829ad1552062b6c27e", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/3d4e7a68b5484b8d2e18c1829ad1552062b6c27e", "committedDate": "2020-11-22T19:02:51Z", "message": "fix formatting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "08d7e3b6b08393dfa52ebc5873797f5f9fd961c3", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/08d7e3b6b08393dfa52ebc5873797f5f9fd961c3", "committedDate": "2020-11-22T21:34:36Z", "message": "Merge remote-tracking branch 'elastic/master' into fully-async-relocations"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2NTE4MDkw", "url": "https://github.com/elastic/elasticsearch/pull/64098#pullrequestreview-536518090", "createdAt": "2020-11-23T14:23:59Z", "commit": {"oid": "08d7e3b6b08393dfa52ebc5873797f5f9fd961c3"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxNDoyNDowMFrOH4Pn3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxNDoyNDowMFrOH4Pn3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODczODI3MA==", "bodyText": "Aha I see, that makes sense then.", "url": "https://github.com/elastic/elasticsearch/pull/64098#discussion_r528738270", "createdAt": "2020-11-23T14:24:00Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/index/shard/IndexShard.java", "diffHunk": "@@ -659,49 +659,94 @@ public IndexShardState markAsRecovering(String reason, RecoveryState recoverySta\n \n     /**\n      * Completes the relocation. Operations are blocked and current operations are drained before changing state to relocated. The provided\n-     * {@link Runnable} is executed after all operations are successfully blocked.\n+     * {@link BiConsumer} is executed after all operations are successfully blocked.\n      *\n-     * @param consumer a {@link Runnable} that is executed after operations are blocked\n+     * @param consumer a {@link BiConsumer} that is executed after operations are blocked and that consumes the primary context as well as\n+     *                 a listener to resolve once it finished\n+     * @param listener listener to resolve once this method actions including executing {@code consumer} in the non-failure case complete\n      * @throws IllegalIndexShardStateException if the shard is not relocating due to concurrent cancellation\n      * @throws IllegalStateException           if the relocation target is no longer part of the replication group\n-     * @throws InterruptedException            if blocking operations is interrupted\n      */\n-    public void relocated(final String targetAllocationId, final Consumer<ReplicationTracker.PrimaryContext> consumer)\n-        throws IllegalIndexShardStateException, IllegalStateException, InterruptedException {\n+    public void relocated(final String targetAllocationId,\n+                          final BiConsumer<ReplicationTracker.PrimaryContext, ActionListener<Void>> consumer,\n+                          final ActionListener<Void> listener)\n+            throws IllegalIndexShardStateException, IllegalStateException {\n         assert shardRouting.primary() : \"only primaries can be marked as relocated: \" + shardRouting;\n         try (Releasable forceRefreshes = refreshListeners.forceRefreshes()) {\n-            indexShardOperationPermits.blockOperations(30, TimeUnit.MINUTES, () -> {\n-                forceRefreshes.close();\n-                // no shard operation permits are being held here, move state from started to relocated\n-                assert indexShardOperationPermits.getActiveOperationsCount() == OPERATIONS_BLOCKED :\n-                        \"in-flight operations in progress while moving shard state to relocated\";\n-                /*\n-                 * We should not invoke the runnable under the mutex as the expected implementation is to handoff the primary context via a\n-                 * network operation. Doing this under the mutex can implicitly block the cluster state update thread on network operations.\n-                 */\n-                verifyRelocatingState();\n-                final ReplicationTracker.PrimaryContext primaryContext = replicationTracker.startRelocationHandoff(targetAllocationId);\n-                try {\n-                    consumer.accept(primaryContext);\n-                    synchronized (mutex) {\n+            indexShardOperationPermits.asyncBlockOperations(new ActionListener<>() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjg1NzQ3Nw=="}, "originalCommit": {"oid": "e55c33bf2338eb2ce901a55c27cd7beaa1bc9dbd"}, "originalPosition": 37}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1144, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}