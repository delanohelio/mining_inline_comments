{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAzNDMwNzMx", "number": 55182, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMTo0NzozOFrODx1cng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wM1QxMjoyNDozNFrOD4xDpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNTgyNDk0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/analysis/VerifierTests.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMTo0NzozOFrOGFiLUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxMDowMDozMFrOGFymTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ1NjAxNg==", "bodyText": "Any idea why I'm getting an error here at all?", "url": "https://github.com/elastic/elasticsearch/pull/55182#discussion_r408456016", "createdAt": "2020-04-14T21:47:38Z", "author": {"login": "rw-access"}, "path": "x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/analysis/VerifierTests.java", "diffHunk": "@@ -111,8 +111,8 @@ public void testArrayFunctionsUnsupported() {\n \n     // Some functions fail with \"Unknown\" message at the parse stage\n     public void testFunctionParsingUnknown() {\n-        assertEquals(\"1:15: Unknown function [matchLite]\",\n-                error(\"process where matchLite(?'.*?net1\\\\s+localgroup\\\\s+.*?', command_line)\"));\n+        assertEquals(\"1:15: Unknown function [matchLite], did you mean any of [matchLite, match]?\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98d6e7a0a53843074529c26b0a5dca5de87a692f"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcyNTA2OA==", "bodyText": "This being a test unit, it would have been easier to debug in an IDE.", "url": "https://github.com/elastic/elasticsearch/pull/55182#discussion_r408725068", "createdAt": "2020-04-15T10:00:30Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/analysis/VerifierTests.java", "diffHunk": "@@ -111,8 +111,8 @@ public void testArrayFunctionsUnsupported() {\n \n     // Some functions fail with \"Unknown\" message at the parse stage\n     public void testFunctionParsingUnknown() {\n-        assertEquals(\"1:15: Unknown function [matchLite]\",\n-                error(\"process where matchLite(?'.*?net1\\\\s+localgroup\\\\s+.*?', command_line)\"));\n+        assertEquals(\"1:15: Unknown function [matchLite], did you mean any of [matchLite, match]?\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ1NjAxNg=="}, "originalCommit": {"oid": "98d6e7a0a53843074529c26b0a5dca5de87a692f"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNTgzMzIzOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/EqlFunctionRegistry.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMTo1MDoxMlrOGFiQDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNjoyMjozNlrOGGBm-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ1NzIyOA==", "bodyText": "This function is just an old alias for match that was kept for compatibility. Should we drop?", "url": "https://github.com/elastic/elasticsearch/pull/55182#discussion_r408457228", "createdAt": "2020-04-14T21:50:12Z", "author": {"login": "rw-access"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/EqlFunctionRegistry.java", "diffHunk": "@@ -37,6 +38,8 @@ public EqlFunctionRegistry() {\n                 def(EndsWith.class, EndsWith::new, \"endswith\"),\n                 def(IndexOf.class, IndexOf::new, \"indexof\"),\n                 def(Length.class, Length::new, \"length\"),\n+                def(Match.class, Match::new, \"match\"),\n+                def(Match.class, Match::new, \"matchLite\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98d6e7a0a53843074529c26b0a5dca5de87a692f"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcyMzgzMg==", "bodyText": "I think this is the answer for the question you asked here. The definition of def accepts more values for the third argument. Everything past the first value is an \"alias\". I would try with matchLite definition as an alias. There are plenty of examples in SqlFunctionRegistry.", "url": "https://github.com/elastic/elasticsearch/pull/55182#discussion_r408723832", "createdAt": "2020-04-15T09:58:33Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/EqlFunctionRegistry.java", "diffHunk": "@@ -37,6 +38,8 @@ public EqlFunctionRegistry() {\n                 def(EndsWith.class, EndsWith::new, \"endswith\"),\n                 def(IndexOf.class, IndexOf::new, \"indexof\"),\n                 def(Length.class, Length::new, \"length\"),\n+                def(Match.class, Match::new, \"match\"),\n+                def(Match.class, Match::new, \"matchLite\"),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ1NzIyOA=="}, "originalCommit": {"oid": "98d6e7a0a53843074529c26b0a5dca5de87a692f"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk3MTAwMA==", "bodyText": "fixed in 521b3f9", "url": "https://github.com/elastic/elasticsearch/pull/55182#discussion_r408971000", "createdAt": "2020-04-15T16:22:36Z", "author": {"login": "rw-access"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/EqlFunctionRegistry.java", "diffHunk": "@@ -37,6 +38,8 @@ public EqlFunctionRegistry() {\n                 def(EndsWith.class, EndsWith::new, \"endswith\"),\n                 def(IndexOf.class, IndexOf::new, \"indexof\"),\n                 def(Length.class, Length::new, \"length\"),\n+                def(Match.class, Match::new, \"match\"),\n+                def(Match.class, Match::new, \"matchLite\"),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ1NzIyOA=="}, "originalCommit": {"oid": "98d6e7a0a53843074529c26b0a5dca5de87a692f"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzYxODA1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/planner/QueryFolderFailTests.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxMDoxMzo0OVrOGFzDuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNjo1OTowMlrOGGDBcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODczMjYwMQ==", "bodyText": "No test for regexes?", "url": "https://github.com/elastic/elasticsearch/pull/55182#discussion_r408732601", "createdAt": "2020-04-15T10:13:49Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/planner/QueryFolderFailTests.java", "diffHunk": "@@ -62,53 +62,61 @@ public void testBetweenWrongTypeParams() {\n                 error(\"process where between(process_name, \\\"s\\\", \\\"e\\\", false, 2)\"));\n     }\n \n+    public void testMatchWithText() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b65ff9939332953c4d313c16c52584adbeef995"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk5NDE2Mg==", "bodyText": "added more in 44af6a6", "url": "https://github.com/elastic/elasticsearch/pull/55182#discussion_r408994162", "createdAt": "2020-04-15T16:59:02Z", "author": {"login": "rw-access"}, "path": "x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/planner/QueryFolderFailTests.java", "diffHunk": "@@ -62,53 +62,61 @@ public void testBetweenWrongTypeParams() {\n                 error(\"process where between(process_name, \\\"s\\\", \\\"e\\\", false, 2)\"));\n     }\n \n+    public void testMatchWithText() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODczMjYwMQ=="}, "originalCommit": {"oid": "8b65ff9939332953c4d313c16c52584adbeef995"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzY3ODExOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/qa/common/src/main/resources/test_queries_supported.toml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxMDozMToyMlrOGFzokQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNjoyMjoxM1rOGGBl6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc0MjAzMw==", "bodyText": "I don't think you are correct about this statement.\nThis is a valid query in SQL: SELECT first_name FROM test_emp WHERE first_name RLIKE 'A[m-o]+.*' which gets translated into ES query DSL like this:\n    \"query\": {\n        \"regexp\": {\n            \"first_name.keyword\": {\n                \"value\": \"A[m-o]+.*\",\n                \"flags_value\": 65535,\n                \"max_determinized_states\": 10000,\n                \"boost\": 1\n            }\n        }\n    }\n\nWhich is valid and works.\nIf you are talking about shorthand character classes, yes, those are not supported by Elasticsearch.", "url": "https://github.com/elastic/elasticsearch/pull/55182#discussion_r408742033", "createdAt": "2020-04-15T10:31:22Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/eql/qa/common/src/main/resources/test_queries_supported.toml", "diffHunk": "@@ -17,3 +17,26 @@ file where between(file_path, \"dev\", \".json\", true) == \"\\\\TestLogs\\\\something\"\n [[queries]]\n query = 'process where string(serial_event_id) = \"1\"'\n expected_event_ids  = [1]\n+\n+[[queries]]\n+expected_event_ids  = [98]\n+notes = \"regexp doesn't support character classes\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b65ff9939332953c4d313c16c52584adbeef995"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk3MDczMA==", "bodyText": "If you are talking about shorthand character classes, yes, those are not supported by Elasticsearch.\n\nyep. good catch.. updated the comment to be more specific. 521b3f9", "url": "https://github.com/elastic/elasticsearch/pull/55182#discussion_r408970730", "createdAt": "2020-04-15T16:22:13Z", "author": {"login": "rw-access"}, "path": "x-pack/plugin/eql/qa/common/src/main/resources/test_queries_supported.toml", "diffHunk": "@@ -17,3 +17,26 @@ file where between(file_path, \"dev\", \".json\", true) == \"\\\\TestLogs\\\\something\"\n [[queries]]\n query = 'process where string(serial_event_id) = \"1\"'\n expected_event_ids  = [1]\n+\n+[[queries]]\n+expected_event_ids  = [98]\n+notes = \"regexp doesn't support character classes\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc0MjAzMw=="}, "originalCommit": {"oid": "8b65ff9939332953c4d313c16c52584adbeef995"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzY5MjgxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/qa/common/src/main/resources/test_queries_supported.toml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxMDozNTo1MlrOGFzx9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNjoyMjoyMFrOGGBmOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc0NDQzNg==", "bodyText": "There is no test here with more than one pattern. Can you add some, please?", "url": "https://github.com/elastic/elasticsearch/pull/55182#discussion_r408744436", "createdAt": "2020-04-15T10:35:52Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/eql/qa/common/src/main/resources/test_queries_supported.toml", "diffHunk": "@@ -17,3 +17,26 @@ file where between(file_path, \"dev\", \".json\", true) == \"\\\\TestLogs\\\\something\"\n [[queries]]\n query = 'process where string(serial_event_id) = \"1\"'\n expected_event_ids  = [1]\n+\n+[[queries]]\n+expected_event_ids  = [98]\n+notes = \"regexp doesn't support character classes\"\n+query = '''\n+//\n+//                                ?'.*?net1\\s+localgroup.*?')\n+process where match(command_line, ?'.*?net1[ ]+localgroup.*?')\n+'''\n+\n+[[queries]]\n+expected_event_ids  = [98]\n+query = '''\n+process where match(command_line, ?'.*?net1.*?')\n+'''\n+\n+[[queries]]\n+expected_event_ids  = [98]\n+notes = \"regexp doesn't support character classes\"\n+query = '''\n+//                                ?'.*?net1\\s+\\w{4,15}\\s+.*?'\n+process where match(command_line, ?'.*?net1[ ]+[a-z]{4,15}[ ]+.*?')\n+'''", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b65ff9939332953c4d313c16c52584adbeef995"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk3MDgwOA==", "bodyText": "added in 521b3f9", "url": "https://github.com/elastic/elasticsearch/pull/55182#discussion_r408970808", "createdAt": "2020-04-15T16:22:20Z", "author": {"login": "rw-access"}, "path": "x-pack/plugin/eql/qa/common/src/main/resources/test_queries_supported.toml", "diffHunk": "@@ -17,3 +17,26 @@ file where between(file_path, \"dev\", \".json\", true) == \"\\\\TestLogs\\\\something\"\n [[queries]]\n query = 'process where string(serial_event_id) = \"1\"'\n expected_event_ids  = [1]\n+\n+[[queries]]\n+expected_event_ids  = [98]\n+notes = \"regexp doesn't support character classes\"\n+query = '''\n+//\n+//                                ?'.*?net1\\s+localgroup.*?')\n+process where match(command_line, ?'.*?net1[ ]+localgroup.*?')\n+'''\n+\n+[[queries]]\n+expected_event_ids  = [98]\n+query = '''\n+process where match(command_line, ?'.*?net1.*?')\n+'''\n+\n+[[queries]]\n+expected_event_ids  = [98]\n+notes = \"regexp doesn't support character classes\"\n+query = '''\n+//                                ?'.*?net1\\s+\\w{4,15}\\s+.*?'\n+process where match(command_line, ?'.*?net1[ ]+[a-z]{4,15}[ ]+.*?')\n+'''", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc0NDQzNg=="}, "originalCommit": {"oid": "8b65ff9939332953c4d313c16c52584adbeef995"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2ODg1NDUwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/planner/QueryFolderFailTests.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMTo0MDozNVrOGKNB-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMTo0MDozNVrOGKNB-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM1MjQ0Mg==", "bodyText": "I rearranged these test methods alphabetically in hopes that it makes git conflicts less likely", "url": "https://github.com/elastic/elasticsearch/pull/55182#discussion_r413352442", "createdAt": "2020-04-22T21:40:35Z", "author": {"login": "rw-access"}, "path": "x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/planner/QueryFolderFailTests.java", "diffHunk": "@@ -62,51 +62,78 @@ public void testBetweenWrongTypeParams() {\n                 error(\"process where between(process_name, \\\"s\\\", \\\"e\\\", false, 2)\"));\n     }\n \n-    public void testCIDRMatchNonIPField() {\n+    public void testCIDRMatchAgainstField() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cf4707625020cc518aa79d4ecdc699cc69661af"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMjg5NDAzOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/planner/QueryFolderFailTests.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQyMjozOToxMVrOGO8w0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQyMjo0MDoyM1rOGO8ybQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMyODc4NA==", "bodyText": "is there a test where match is passed only one argument?", "url": "https://github.com/elastic/elasticsearch/pull/55182#discussion_r418328784", "createdAt": "2020-04-30T22:39:11Z", "author": {"login": "aleksmaus"}, "path": "x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/planner/QueryFolderFailTests.java", "diffHunk": "@@ -62,51 +62,78 @@ public void testBetweenWrongTypeParams() {\n                 error(\"process where between(process_name, \\\"s\\\", \\\"e\\\", false, 2)\"));\n     }\n \n-    public void testCIDRMatchNonIPField() {\n+    public void testCIDRMatchAgainstField() {\n         VerificationException e = expectThrows(VerificationException.class,\n-                () -> plan(\"process where cidrMatch(hostname, \\\"10.0.0.0/8\\\")\"));\n+            () -> plan(\"process where cidrMatch(source_address, hostname)\"));\n         String msg = e.getMessage();\n         assertEquals(\"Found 1 problem\\n\" +\n-                \"line 1:15: first argument of [cidrMatch(hostname, \\\"10.0.0.0/8\\\")] must be [ip], found value [hostname] type [text]\", msg);\n+            \"line 1:15: second argument of [cidrMatch(source_address, hostname)] must be a constant, received [hostname]\", msg);\n     }\n \n     public void testCIDRMatchMissingValue() {\n         ParsingException e = expectThrows(ParsingException.class,\n-                () -> plan(\"process where cidrMatch(source_address)\"));\n+            () -> plan(\"process where cidrMatch(source_address)\"));\n         String msg = e.getMessage();\n         assertEquals(\"line 1:16: error building [cidrmatch]: expects at least two arguments\", msg);\n     }\n \n-    public void testCIDRMatchAgainstField() {\n+    public void testCIDRMatchNonIPField() {\n         VerificationException e = expectThrows(VerificationException.class,\n-                () -> plan(\"process where cidrMatch(source_address, hostname)\"));\n+            () -> plan(\"process where cidrMatch(hostname, \\\"10.0.0.0/8\\\")\"));\n         String msg = e.getMessage();\n         assertEquals(\"Found 1 problem\\n\" +\n-                \"line 1:15: second argument of [cidrMatch(source_address, hostname)] must be a constant, received [hostname]\", msg);\n+            \"line 1:15: first argument of [cidrMatch(hostname, \\\"10.0.0.0/8\\\")] must be [ip], found value [hostname] type [text]\", msg);\n     }\n \n     public void testCIDRMatchNonString() {\n         VerificationException e = expectThrows(VerificationException.class,\n-                () -> plan(\"process where cidrMatch(source_address, 12345)\"));\n+            () -> plan(\"process where cidrMatch(source_address, 12345)\"));\n         String msg = e.getMessage();\n         assertEquals(\"Found 1 problem\\n\" +\n-                \"line 1:15: argument of [cidrMatch(source_address, 12345)] must be [string], found value [12345] type [integer]\", msg);\n+            \"line 1:15: argument of [cidrMatch(source_address, 12345)] must be [string], found value [12345] type [integer]\", msg);\n     }\n \n     public void testEndsWithFunctionWithInexact() {\n         VerificationException e = expectThrows(VerificationException.class,\n-                () -> plan(\"process where endsWith(plain_text, \\\"foo\\\") == true\"));\n+            () -> plan(\"process where endsWith(plain_text, \\\"foo\\\") == true\"));\n         String msg = e.getMessage();\n         assertEquals(\"Found 1 problem\\nline 1:15: [endsWith(plain_text, \\\"foo\\\")] cannot operate on first argument field of data type \"\n-                + \"[text]: No keyword/multi-field defined exact matches for [plain_text]; define one or use MATCH/QUERY instead\", msg);\n+            + \"[text]: No keyword/multi-field defined exact matches for [plain_text]; define one or use MATCH/QUERY instead\", msg);\n     }\n \n     public void testLengthFunctionWithInexact() {\n         VerificationException e = expectThrows(VerificationException.class,\n-                () -> plan(\"process where length(plain_text) > 0\"));\n+            () -> plan(\"process where length(plain_text) > 0\"));\n         String msg = e.getMessage();\n         assertEquals(\"Found 1 problem\\nline 1:15: [length(plain_text)] cannot operate on field of data type [text]: No keyword/multi-field \"\n-                + \"defined exact matches for [plain_text]; define one or use MATCH/QUERY instead\", msg);\n+            + \"defined exact matches for [plain_text]; define one or use MATCH/QUERY instead\", msg);\n+    }\n+\n+    public void testMatchWithText() {\n+        VerificationException e = expectThrows(VerificationException.class,\n+            () -> plan(\"process where match(plain_text, 'foo.*')\"));\n+        String msg = e.getMessage();\n+        assertEquals(\"Found 1 problem\\n\" +\n+            \"line 1:15: [match(plain_text, 'foo.*')] cannot operate on first argument field of data type [text]: No keyword/multi-field \" +\n+            \"defined exact matches for [plain_text]; define one or use MATCH/QUERY instead\", msg);\n+    }\n+\n+    public void testMatchWithNonString() {\n+        VerificationException e = expectThrows(VerificationException.class,\n+            () -> plan(\"process where match(process_name, parent_process_name)\"));\n+        String msg = e.getMessage();\n+        assertEquals(\"Found 1 problem\\n\" +\n+            \"line 1:15: second argument of [match(process_name, parent_process_name)] \" +\n+            \"must be a constant, received [parent_process_name]\", msg);\n+    }\n+\n+    public void testMatchWithNonRegex() {\n+        VerificationException e = expectThrows(VerificationException.class,\n+            () -> plan(\"process where match(process_name, 1)\"));\n+        String msg = e.getMessage();\n+        assertEquals(\"Found 1 problem\\n\" +\n+            \"line 1:15: second argument of [match(process_name, 1)] \" +\n+            \"must be [string], found value [1] type [integer]\", msg);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1138373011db156d225ce5392dbc29e22427e95"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMyOTE5Nw==", "bodyText": "what about?\nprocess where match(process_name, null)", "url": "https://github.com/elastic/elasticsearch/pull/55182#discussion_r418329197", "createdAt": "2020-04-30T22:40:23Z", "author": {"login": "aleksmaus"}, "path": "x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/planner/QueryFolderFailTests.java", "diffHunk": "@@ -62,51 +62,78 @@ public void testBetweenWrongTypeParams() {\n                 error(\"process where between(process_name, \\\"s\\\", \\\"e\\\", false, 2)\"));\n     }\n \n-    public void testCIDRMatchNonIPField() {\n+    public void testCIDRMatchAgainstField() {\n         VerificationException e = expectThrows(VerificationException.class,\n-                () -> plan(\"process where cidrMatch(hostname, \\\"10.0.0.0/8\\\")\"));\n+            () -> plan(\"process where cidrMatch(source_address, hostname)\"));\n         String msg = e.getMessage();\n         assertEquals(\"Found 1 problem\\n\" +\n-                \"line 1:15: first argument of [cidrMatch(hostname, \\\"10.0.0.0/8\\\")] must be [ip], found value [hostname] type [text]\", msg);\n+            \"line 1:15: second argument of [cidrMatch(source_address, hostname)] must be a constant, received [hostname]\", msg);\n     }\n \n     public void testCIDRMatchMissingValue() {\n         ParsingException e = expectThrows(ParsingException.class,\n-                () -> plan(\"process where cidrMatch(source_address)\"));\n+            () -> plan(\"process where cidrMatch(source_address)\"));\n         String msg = e.getMessage();\n         assertEquals(\"line 1:16: error building [cidrmatch]: expects at least two arguments\", msg);\n     }\n \n-    public void testCIDRMatchAgainstField() {\n+    public void testCIDRMatchNonIPField() {\n         VerificationException e = expectThrows(VerificationException.class,\n-                () -> plan(\"process where cidrMatch(source_address, hostname)\"));\n+            () -> plan(\"process where cidrMatch(hostname, \\\"10.0.0.0/8\\\")\"));\n         String msg = e.getMessage();\n         assertEquals(\"Found 1 problem\\n\" +\n-                \"line 1:15: second argument of [cidrMatch(source_address, hostname)] must be a constant, received [hostname]\", msg);\n+            \"line 1:15: first argument of [cidrMatch(hostname, \\\"10.0.0.0/8\\\")] must be [ip], found value [hostname] type [text]\", msg);\n     }\n \n     public void testCIDRMatchNonString() {\n         VerificationException e = expectThrows(VerificationException.class,\n-                () -> plan(\"process where cidrMatch(source_address, 12345)\"));\n+            () -> plan(\"process where cidrMatch(source_address, 12345)\"));\n         String msg = e.getMessage();\n         assertEquals(\"Found 1 problem\\n\" +\n-                \"line 1:15: argument of [cidrMatch(source_address, 12345)] must be [string], found value [12345] type [integer]\", msg);\n+            \"line 1:15: argument of [cidrMatch(source_address, 12345)] must be [string], found value [12345] type [integer]\", msg);\n     }\n \n     public void testEndsWithFunctionWithInexact() {\n         VerificationException e = expectThrows(VerificationException.class,\n-                () -> plan(\"process where endsWith(plain_text, \\\"foo\\\") == true\"));\n+            () -> plan(\"process where endsWith(plain_text, \\\"foo\\\") == true\"));\n         String msg = e.getMessage();\n         assertEquals(\"Found 1 problem\\nline 1:15: [endsWith(plain_text, \\\"foo\\\")] cannot operate on first argument field of data type \"\n-                + \"[text]: No keyword/multi-field defined exact matches for [plain_text]; define one or use MATCH/QUERY instead\", msg);\n+            + \"[text]: No keyword/multi-field defined exact matches for [plain_text]; define one or use MATCH/QUERY instead\", msg);\n     }\n \n     public void testLengthFunctionWithInexact() {\n         VerificationException e = expectThrows(VerificationException.class,\n-                () -> plan(\"process where length(plain_text) > 0\"));\n+            () -> plan(\"process where length(plain_text) > 0\"));\n         String msg = e.getMessage();\n         assertEquals(\"Found 1 problem\\nline 1:15: [length(plain_text)] cannot operate on field of data type [text]: No keyword/multi-field \"\n-                + \"defined exact matches for [plain_text]; define one or use MATCH/QUERY instead\", msg);\n+            + \"defined exact matches for [plain_text]; define one or use MATCH/QUERY instead\", msg);\n+    }\n+\n+    public void testMatchWithText() {\n+        VerificationException e = expectThrows(VerificationException.class,\n+            () -> plan(\"process where match(plain_text, 'foo.*')\"));\n+        String msg = e.getMessage();\n+        assertEquals(\"Found 1 problem\\n\" +\n+            \"line 1:15: [match(plain_text, 'foo.*')] cannot operate on first argument field of data type [text]: No keyword/multi-field \" +\n+            \"defined exact matches for [plain_text]; define one or use MATCH/QUERY instead\", msg);\n+    }\n+\n+    public void testMatchWithNonString() {\n+        VerificationException e = expectThrows(VerificationException.class,\n+            () -> plan(\"process where match(process_name, parent_process_name)\"));\n+        String msg = e.getMessage();\n+        assertEquals(\"Found 1 problem\\n\" +\n+            \"line 1:15: second argument of [match(process_name, parent_process_name)] \" +\n+            \"must be a constant, received [parent_process_name]\", msg);\n+    }\n+\n+    public void testMatchWithNonRegex() {\n+        VerificationException e = expectThrows(VerificationException.class,\n+            () -> plan(\"process where match(process_name, 1)\"));\n+        String msg = e.getMessage();\n+        assertEquals(\"Found 1 problem\\n\" +\n+            \"line 1:15: second argument of [match(process_name, 1)] \" +\n+            \"must be [string], found value [1] type [integer]\", msg);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMyODc4NA=="}, "originalCommit": {"oid": "f1138373011db156d225ce5392dbc29e22427e95"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwODUwNTk4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/EqlFunctionRegistry.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wM1QxMjoyNDozNFrOGPrmpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNToyODoxM1rOGQFmxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA5NjIzMQ==", "bodyText": "matchLite as an alias to match?", "url": "https://github.com/elastic/elasticsearch/pull/55182#discussion_r419096231", "createdAt": "2020-05-03T12:24:34Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/EqlFunctionRegistry.java", "diffHunk": "@@ -42,6 +43,7 @@ public EqlFunctionRegistry() {\n                 def(EndsWith.class, EndsWith::new, \"endswith\"),\n                 def(IndexOf.class, IndexOf::new, \"indexof\"),\n                 def(Length.class, Length::new, \"length\"),\n+                def(Match.class, Match::new, \"match\", \"matchlite\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1138373011db156d225ce5392dbc29e22427e95"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTUyMjI0NA==", "bodyText": "I originally had \"matchLite\" but apparently the aliases have to also be normalized to lowercase, so it's \"matchlite\"\nboth functions have been around for a while, but matchLite was more limited than regex -- had character clasess and *, *?,  and + because of our underlying implementation.\nnow, they both have the same functionality, so the alias is just for backwards compatibility.", "url": "https://github.com/elastic/elasticsearch/pull/55182#discussion_r419522244", "createdAt": "2020-05-04T15:28:13Z", "author": {"login": "rw-access"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/EqlFunctionRegistry.java", "diffHunk": "@@ -42,6 +43,7 @@ public EqlFunctionRegistry() {\n                 def(EndsWith.class, EndsWith::new, \"endswith\"),\n                 def(IndexOf.class, IndexOf::new, \"indexof\"),\n                 def(Length.class, Length::new, \"length\"),\n+                def(Match.class, Match::new, \"match\", \"matchlite\"),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA5NjIzMQ=="}, "originalCommit": {"oid": "f1138373011db156d225ce5392dbc29e22427e95"}, "originalPosition": 12}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1021, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}