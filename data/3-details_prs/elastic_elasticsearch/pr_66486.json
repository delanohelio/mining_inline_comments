{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQxNjUxODg2", "number": 66486, "title": "SQL: Implement TO_CHAR() function", "bodyText": "This PR is based on the #54964 community PR. Made the following changes to the community contribution:\n\nRemoved the recursive pattern matching that also required specific\nordering in the configuration of the Formatter\nUpgraded the formatter to Postgres 13\nAll the Postgres formats are supported, there is also partial supports\nfor the modifiers\nRandom unit test data generator script (in case we need to upgrade the\nformat in the future)\nFixed several bugs where Postgres TO_CHAR did not behave the same\nway as this implementation (based on unit tests)\nUpdated the documentation, added examples\nAdded Integration tests", "createdAt": "2020-12-17T06:57:50Z", "url": "https://github.com/elastic/elasticsearch/pull/66486", "merged": true, "mergeCommit": {"oid": "f855e5235cda077c6853b99f6ea0a3e5d96b3d91"}, "closed": true, "closedAt": "2021-01-20T23:32:12Z", "author": {"login": "palesz"}, "timelineItems": {"totalCount": 46, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdm92z1AH2gAyNTQxNjUxODg2OjE3ZWM2Mjg0ZTUwMzc1ZDljMWNlZDNiNDQwYWZiN2NhM2VlYTk3OGM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdyFzL8gFqTU3MjYxMzAxMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "17ec6284e50375d9c1ced3b440afb7ca3eea978c", "author": {"user": {"login": "vonsowic", "name": "Micha\u0142 W\u0105sowicz"}}, "url": "https://github.com/elastic/elasticsearch/commit/17ec6284e50375d9c1ced3b440afb7ca3eea978c", "committedDate": "2020-12-17T06:50:26Z", "message": "SQL: Implement to_char function (#54964)\n\nImplement to_char according to the PostgreSQL spec: https://www.postgresql.org/docs/9.1/functions-formatting.html by translating to the java.time patterns used in DATETIME_FORMAT.\nFollows: #54832"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "32bbe9facef7d6a7b434a421966cfd342522abdf", "author": {"user": {"login": "palesz", "name": "Andras Palinkas"}}, "url": "https://github.com/elastic/elasticsearch/commit/32bbe9facef7d6a7b434a421966cfd342522abdf", "committedDate": "2020-12-17T06:50:27Z", "message": "SQL: TO_CHAR function implementation\n\n* Removed the recursive pattern matching that also required specific\nordering in the configuration of the Formatter\n* Upgraded the formatter to Postgres 13\n* All the Postgres formats are supported, there is also partial supports\n for the modifiers\n* Random unit test data generator script (in case we need to upgrade the\n format in the future)\n* Updated the documentation, added examples\n* Integration tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0MzIzMjUy", "url": "https://github.com/elastic/elasticsearch/pull/66486#pullrequestreview-554323252", "createdAt": "2020-12-17T06:58:37Z", "commit": {"oid": "32bbe9facef7d6a7b434a421966cfd342522abdf"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwNjo1ODozN1rOIHnRiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwNjo1ODozN1rOIHnRiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg1NDQwOQ==", "bodyText": "Missed these ones, will revert the whitespace changes in this file.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r544854409", "createdAt": "2020-12-17T06:58:37Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/sql/qa/server/src/main/resources/command.csv-spec", "diffHunk": "@@ -9,15 +9,15 @@ showFunctions\n SHOW FUNCTIONS;\n \n     name:s       |    type:s\n-AVG              |AGGREGATE      \n+AVG              |AGGREGATE", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32bbe9facef7d6a7b434a421966cfd342522abdf"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0MzI0MzIz", "url": "https://github.com/elastic/elasticsearch/pull/66486#pullrequestreview-554324323", "createdAt": "2020-12-17T07:01:13Z", "commit": {"oid": "32bbe9facef7d6a7b434a421966cfd342522abdf"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwNzowMToxM1rOIHnVEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwNzowMToxM1rOIHnVEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg1NTMxNQ==", "bodyText": "Will move this out into a separate file.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r544855315", "createdAt": "2020-12-17T07:01:13Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeFormatProcessor.java", "diffHunk": "@@ -36,22 +49,379 @@\n         {\"F\", \"S\"},\n         {\"z\", \"X\"}\n     };\n-    private final Formatter formatter;\n+    \n+    private static class ToCharFormatter {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32bbe9facef7d6a7b434a421966cfd342522abdf"}, "originalPosition": 38}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0MzI1MDQ4", "url": "https://github.com/elastic/elasticsearch/pull/66486#pullrequestreview-554325048", "createdAt": "2020-12-17T07:02:42Z", "commit": {"oid": "32bbe9facef7d6a7b434a421966cfd342522abdf"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwNzowMjo0MlrOIHnXvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwNzowMjo0MlrOIHnXvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg1NTk5Nw==", "bodyText": "I think our tests don't run in parallel in the same JVM, so this should be safe, but if you have a better idea how to do this, I am all ears.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r544855997", "createdAt": "2020-12-17T07:02:42Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.junit.After;\n+import org.junit.Before;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    public static class TestCase {\n+        private static final AtomicInteger COUNTER = new AtomicInteger(0);\n+\n+        private final int id;\n+        private final BigDecimal secondsAndFractionsSinceEpoch;\n+        private final String formatString;\n+        private final String zoneId;\n+        \n+        TestCase(BigDecimal secondsAndFractionsSinceEpoch, String formatString) {\n+            this.id = COUNTER.incrementAndGet();\n+            this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+            this.formatString = formatString;\n+            this.zoneId = TestGenerator.randomFromCollection(ZoneId.getAvailableZoneIds().stream().filter(\n+                z -> z.startsWith(\"America\") || z.startsWith(\"Europe\") || z.startsWith(\"Asia\") || z.startsWith(\"Africa\") \n+                    || Set.of(\"UTC\", \"GMT\", \"Z\").contains(z)\n+            ).collect(Collectors.toList()));\n+        }\n+\n+    }\n+\n+    private static class TestGenerator {\n+        \n+        private static final long SECONDS_IN_YEAR = 365 * 24 * 60 * 60L;\n+        private static final String DELIMITER = \"|\";\n+        private static final String PATTERN_DELIMITER = \" @ \";\n+        // these patterns are hard to sync up between PostgreSQL and Elasticsearch, so we just warn, but actually\n+        // accept the output of Elasticsearch as is\n+        private static final Set<String> NOT_FULLY_MATCHABLE_PATTERNS = Set.of(\"TZ\", \"tz\", \"TZH\", \"tzh\", \"TZM\", \"tzm\");\n+        private static final Set<String> UNSUPPORTED_PATTERN_MODIFIERS = Set.of(\"FX\", \"TM\", \"SP\");\n+        private static final String[] PATTERNS = new String[] {\n+            \"HH\", \"HH12\", \"HH24\", \"MI\", \"SS\", \"MS\", \"US\", \"FF1\", \"FF2\", \"FF3\", \"FF4\", \"FF5\", \"FF6\", \"SSSS\", \"SSSSS\", \"AM\", \"am\", \"PM\",\n+            \"pm\", \"A.M.\", \"a.m.\", \"P.M.\", \"p.m.\", \"Y,YYY\", \"YYYY\", \"YYY\", \"YY\", \"Y\", \"IYYY\", \"IYY\", \"IY\", \"I\", \"BC\", \"bc\", \"AD\", \"ad\",\n+            \"B.C.\", \"b.c.\", \"A.D.\", \"a.d.\", \"MONTH\", \"Month\", \"month\", \"MON\", \"Mon\", \"mon\", \"MM\", \"DAY\", \"Day\", \"day\", \"DY\", \"Dy\",\n+            \"dy\", \"DDD\", \"IDDD\", \"DD\", \"D\", \"ID\", \"W\", \"WW\", \"IW\", \"CC\", \"J\", \"Q\", \"RM\", \"rm\", \"TZ\", \"tz\", \"TZH\", \"TZM\", \"OF\"\n+        };\n+        private static final Set<String> PATTERNS_WITHOUT_MODIFIER_TEST = NOT_FULLY_MATCHABLE_PATTERNS;\n+        private static final List<String> FILL_MODIFIERS = List.of(\"FM\", \"fm\", \"\");\n+        private static final List<String> ORDINAL_SUFFIX_MODIFIERS = List.of(\"TH\", \"th\", \"\");\n+\n+        @SuppressForbidden(reason = \"It is ok to use ThreadLocalRandom outside of an actual test\")\n+        private static Random rnd() {\n+            return ThreadLocalRandom.current();\n+        }\n+\n+        private static BigDecimal randomSecondsWithFractions(int minYear, int maxYear) {\n+            BigDecimal seconds = new BigDecimal(RandomNumbers.randomLongBetween(rnd(), \n+                (minYear - 1970) * SECONDS_IN_YEAR, (maxYear - 1970) * SECONDS_IN_YEAR));\n+            BigDecimal fractions = new BigDecimal(RandomNumbers.randomIntBetween(rnd(), 0, 999_999)).movePointLeft(6);\n+            return seconds.add(fractions);\n+        }\n+\n+        private static <T> T randomFromCollection(Collection<T> list) {\n+            List<T> l = new ArrayList<>(list);\n+            return l.get(rnd().nextInt(l.size()));\n+        }\n+        \n+        private static String patternWithRandomModifiers(String pattern) {\n+            if (PATTERNS_WITHOUT_MODIFIER_TEST.contains(pattern)) {\n+                return pattern;\n+            }\n+            return randomFromCollection(FILL_MODIFIERS) + pattern + randomFromCollection(ORDINAL_SUFFIX_MODIFIERS);\n+        }\n+    \n+        private static List<TestCase> generateTestCases() {\n+            \n+            final List<BigDecimal> testEpochSeconds = new LinkedList<>();\n+            for (int i = 0; i < 50; i++) {\n+                testEpochSeconds.add(randomSecondsWithFractions(-1200, 2500));\n+            }\n+            for (int i = 0; i < 5; i++) {\n+                testEpochSeconds.add(randomSecondsWithFractions(-1, 1));\n+            }\n+    \n+            List<TestCase> testCases = new ArrayList<>();\n+    \n+            // check each format string alone\n+            for (String pattern : PATTERNS) {\n+                testCases.add(new TestCase(randomFromCollection(testEpochSeconds), PATTERNS_WITHOUT_MODIFIER_TEST.contains(pattern) \n+                    ? pattern \n+                    : String.join(PATTERN_DELIMITER, pattern, FILL_MODIFIERS.get(0) + pattern + ORDINAL_SUFFIX_MODIFIERS.get(0))));\n+            }\n+            \n+            // let's check all of the format strings with a non-ambiguous format string\n+            for (BigDecimal es : testEpochSeconds) {\n+                testCases.add(new TestCase(es, IntStream.range(0, PATTERNS.length)\n+                    .mapToObj(idx -> idx + \":\" + patternWithRandomModifiers(PATTERNS[idx]))\n+                    .collect(Collectors.joining(PATTERN_DELIMITER))));\n+            }\n+    \n+            // check the lowercase versions of the format strings\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), IntStream.range(0, PATTERNS.length)\n+                .mapToObj(idx -> (idx + \":\" + patternWithRandomModifiers(PATTERNS[idx])).toLowerCase(Locale.ROOT))\n+                .collect(Collectors.joining(PATTERN_DELIMITER))));\n+    \n+            // potentially ambiguous format string test cases, to check if our format string parsing is in-sync with PostgreSQL\n+            // greedy and prefers the longer format strings\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"YYYYYYYYYYYYYYY,YYYYYYYYY\"));\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"SSSSSSSSSSSSSSSS\"));\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"DDDDDDDD\"));\n+    \n+            // Roman numbers\n+            for (int i = 1; i <= 12; i++) {\n+                testCases.add(new TestCase(\n+                    new BigDecimal(dateTime(0).withMonth(i).toEpochSecond()), rnd().nextBoolean() ? \"RM\" : \"rm\"));\n+            }\n+            \n+            // random strings made out of template patterns and random characters\n+            final String randomCharacters = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYabcdefghijklmnopqrstuvwxy _-.:;\";\n+            final List<String> formatStringsToRandomTest = Arrays.stream(PATTERNS)\n+                .filter(s -> NOT_FULLY_MATCHABLE_PATTERNS.contains(s) == false)\n+                .collect(Collectors.toList());\n+            \n+            for (int i = 0; i < 20; i++) {\n+                String patternWithLiterals = IntStream.rangeClosed(1, 30).mapToObj(idx -> \n+                    rnd().nextInt(100) < 80 \n+                        ? randomCharacters.substring(rnd().nextInt(randomCharacters.length())).substring(0, 1) \n+                        : (randomFromCollection(FILL_MODIFIERS) \n+                            + randomFromCollection(formatStringsToRandomTest) \n+                            + randomFromCollection(ORDINAL_SUFFIX_MODIFIERS)))\n+                    .collect(Collectors.joining());\n+                \n+                // clean up the random string from the unsupported modifiers\n+                for (String unsupportedPatternModifier : UNSUPPORTED_PATTERN_MODIFIERS) {\n+                    patternWithLiterals = patternWithLiterals\n+                        .replace(unsupportedPatternModifier, \"\")\n+                        .replace(unsupportedPatternModifier.toLowerCase(Locale.ROOT), \"\");\n+                }\n+                testCases.add(new TestCase(randomFromCollection(testEpochSeconds), patternWithLiterals));\n+            }\n+    \n+            return testCases;\n+        }\n+        \n+        /**\n+         * Generates an SQL file that can be used to create the test dataset for the unit test of the <code>TO_CHAR</code>\n+         * implementation. In case the <code>TO_CHAR</code> implementation needs an upgrade, add the list of the new format\n+         * strings to the list of the format string, regenerate the SQL, run it against the PostgreSQL version you are targeting\n+         * and update the test CSV file.\n+         */\n+        private static String unitTestExporterScript() {\n+            return generateTestCases().stream().map(tc -> {\n+                long seconds = tc.secondsAndFractionsSinceEpoch.longValue();\n+                BigDecimal fractions = tc.secondsAndFractionsSinceEpoch.remainder(BigDecimal.ONE).movePointRight(6);\n+                return String.format(Locale.ROOT,\n+                    \"SET TIME ZONE '%6$s';\\n\" +\n+                    \"\\\\copy (SELECT %1$d as id, %2$s as epoch_seconds_and_microsends, '%6$s' as zone_id, '%5$s' as format_string, \" +\n+                        \"TO_CHAR((TO_TIMESTAMP(%3$d) + INTERVAL '%4$d microseconds'), '%5$s') as to_char_result) to stdout \" +\n+                        \"with DELIMITER as '\" + DELIMITER + \"' NULL as '' csv \\n\",\n+                    tc.id, tc.secondsAndFractionsSinceEpoch.toPlainString(), seconds, fractions.intValue(), tc.formatString, tc.zoneId\n+                );\n+            }).collect(Collectors.joining(\"\\n\"));\n+        }\n+    \n+        /**\n+         * Saves the generated test script into the file specified as the first and only argument.\n+         *\n+         * Once the file is generated, you can execute the following command to generate the output dataset with:\n+         *\n+         * <p>\n+         *  <code>\n+         *  PGPASSWORD=\"mysecretpassword\" psql --quiet -h localhost -p 5432 -U postgres -f /tmp/postgresql-tochar-test.sql &gt; /tochar.csv\n+         *  </code>\n+         * </p>\n+         */\n+        public static void main(String[] args) throws Exception {\n+            String scriptFilename = args.length < 1 ? \"/tmp/postgresql-tochar-test.sql\" : args[0];\n+            Files.writeString(Path.of(scriptFilename), unitTestExporterScript(), StandardCharsets.UTF_8);\n+        }\n+    }\n+\n+    @ParametersFactory(argumentFormatting = \"%1$s: timestamp=%2$s, zone=%3$s, format=%4$s\")\n+    public static List<Object[]> readCsv() throws Exception {\n+        Path testFilePath = Path.of(DateTimeToCharProcessorTests.class.getResource(\"tochar.csv\").toURI());\n+        return Files.readAllLines(testFilePath).stream().map(line -> {\n+            String[] cols = line.split(Pattern.quote(TestGenerator.DELIMITER));\n+            return new Object[]{ cols[0], cols[1], cols[2], cols[3], cols[4] };\n+        }).collect(Collectors.toList());\n+    }\n+\n+    private final String id;\n+    private final String secondsAndFractionsSinceEpoch;\n+    private final String zone;\n+    private final String formatString;\n+    private final String expectedResult;\n+    \n+    private Locale defaultLocale = null;\n+\n+    public DateTimeToCharProcessorTests(String id, String secondsAndFractionsSinceEpoch, String zone, String formatString, \n+        String expectedResult) {\n+        this.id = id;\n+        this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+        this.zone = zone;\n+        this.formatString = formatString;\n+        this.expectedResult = expectedResult;\n+    }\n+\n+    private static ZonedDateTime dateTimeWithFractions(String secondAndFractionsSinceEpoch) {\n+        BigDecimal b = new BigDecimal(secondAndFractionsSinceEpoch);\n+        long seconds = b.longValue();\n+        int fractions = b.remainder(BigDecimal.ONE).movePointRight(9).intValueExact();\n+        int adjustment = 0;\n+        if (fractions < 0) {\n+            fractions += 1e9;\n+            adjustment = -1;\n+        }\n+        return dateTime((seconds + adjustment) * 1000).withNano(fractions);\n+    }\n+\n+    /**\n+     * Since the test dataset was exported from PostgreSQL using en_US locale, \n+     * let's stick with to that Locale during the testing of this function.\n+     */\n+    @Before\n+    public void changeLocaleToUS() {\n+        this.defaultLocale = Locale.getDefault();\n+        Locale.setDefault(Locale.US);\n+    }\n+    \n+    @After\n+    public void revertLocale() {\n+        Locale.setDefault(this.defaultLocale);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32bbe9facef7d6a7b434a421966cfd342522abdf"}, "originalPosition": 264}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "95d32c3446b72b895ce424ee37ea901cbb21ff4e", "author": {"user": {"login": "palesz", "name": "Andras Palinkas"}}, "url": "https://github.com/elastic/elasticsearch/commit/95d32c3446b72b895ce424ee37ea901cbb21ff4e", "committedDate": "2020-12-17T16:00:08Z", "message": "Reverted the whitespace changes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0Nzc5OTUw", "url": "https://github.com/elastic/elasticsearch/pull/66486#pullrequestreview-554779950", "createdAt": "2020-12-17T16:36:30Z", "commit": {"oid": "95d32c3446b72b895ce424ee37ea901cbb21ff4e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxNjozNjozMVrOIH-RFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxNjozNjozMVrOIH-RFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTIzMTEyNA==", "bodyText": "Switching this to use offset instead of the zone names (so it will work on the CI server and with other Java versions too).", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545231124", "createdAt": "2020-12-17T16:36:31Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.junit.After;\n+import org.junit.Before;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    public static class TestCase {\n+        private static final AtomicInteger COUNTER = new AtomicInteger(0);\n+\n+        private final int id;\n+        private final BigDecimal secondsAndFractionsSinceEpoch;\n+        private final String formatString;\n+        private final String zoneId;\n+        \n+        TestCase(BigDecimal secondsAndFractionsSinceEpoch, String formatString) {\n+            this.id = COUNTER.incrementAndGet();\n+            this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+            this.formatString = formatString;\n+            this.zoneId = TestGenerator.randomFromCollection(ZoneId.getAvailableZoneIds().stream().filter(\n+                z -> z.startsWith(\"America\") || z.startsWith(\"Europe\") || z.startsWith(\"Asia\") || z.startsWith(\"Africa\") \n+                    || Set.of(\"UTC\", \"GMT\", \"Z\").contains(z)\n+            ).collect(Collectors.toList()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95d32c3446b72b895ce424ee37ea901cbb21ff4e"}, "originalPosition": 58}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2a9e30304ee7cf9689007bdb640bd28a1ec3578b", "author": {"user": {"login": "palesz", "name": "Andras Palinkas"}}, "url": "https://github.com/elastic/elasticsearch/commit/2a9e30304ee7cf9689007bdb640bd28a1ec3578b", "committedDate": "2020-12-17T22:39:14Z", "message": "Cleanups, minor bugfix, test timezone changes\n\n* Moved the ToCharFormatter into it's own file\n* Using a static set of timezones (full name, abbreviation and offsets)\navailable in Java and Postgres\n* Changed the way the century is calculated"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0b828fedd9b57a3b1be4257f367d0e85d9176f07", "author": {"user": {"login": "palesz", "name": "Andras Palinkas"}}, "url": "https://github.com/elastic/elasticsearch/commit/0b828fedd9b57a3b1be4257f367d0e85d9176f07", "committedDate": "2020-12-17T23:14:00Z", "message": "Checkstyle fixes, minor documentation tweaks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5babe13ca152b6d4b2cd38bc2c435fa0c50060b9", "author": {"user": {"login": "elasticmachine", "name": "Elastic Machine"}}, "url": "https://github.com/elastic/elasticsearch/commit/5babe13ca152b6d4b2cd38bc2c435fa0c50060b9", "committedDate": "2020-12-17T23:46:14Z", "message": "Merge branch 'master' into feature/to-char-function"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1Mzc1ODcw", "url": "https://github.com/elastic/elasticsearch/pull/66486#pullrequestreview-555375870", "createdAt": "2020-12-18T10:35:41Z", "commit": {"oid": "5babe13ca152b6d4b2cd38bc2c435fa0c50060b9"}, "state": "COMMENTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMDozNTo0MVrOIIdoJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxNToxMjo0MlrOIInC4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc0NDkzNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            - The result of the pattern `TZ`, `tz` and `OF` patterns is equivalent with, but differs from the results returned by the PostgreSQL implementation.\n          \n          \n            \n            - The result of the pattern `TZ`, `tz` and `OF` is equivalent with, but differs from the results returned by the PostgreSQL implementation.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545744934", "createdAt": "2020-12-18T10:35:41Z", "author": {"login": "bpintea"}, "path": "docs/reference/sql/functions/date-time.asciidoc", "diffHunk": "@@ -818,6 +818,54 @@ include-tagged::{sql-specs}/docs/docs.csv-spec[formatDateTime]\n include-tagged::{sql-specs}/docs/docs.csv-spec[formatTime]\n --------------------------------------------------\n \n+\n+[[sql-functions-datetime-to_char]]\n+==== `TO_CHAR`\n+\n+.Synopsis:\n+[source, sql]\n+--------------------------------------------------\n+TO_CHAR(\n+    date_exp/datetime_exp/time_exp, <1>\n+    string_exp) <2>\n+--------------------------------------------------\n+\n+*Input*:\n+\n+<1> date/datetime/time expression\n+<2> format pattern\n+\n+*Output*: string\n+\n+*Description*: Returns the date/datetime/time as a string using the format specified in the 2nd argument. The formatting\n+pattern conforms to\n+https://www.postgresql.org/docs/13/functions-formatting.html[PostgreSQL Template Patterns for Date/Time Formatting].\n+If any of the two arguments is `null` or the pattern is an empty string `null` is returned.\n+\n+[NOTE]\n+If the 1st argument is of type `time`, then the pattern specified by the 2nd argument cannot contain date related units\n+(e.g. 'dd', 'MM', 'YYYY', etc.). If it contains such units an error is returned.\n+\n+*Special Cases*\n+\n+- The result of the pattern `TZ`, `tz` and `OF` patterns is equivalent with, but differs from the results returned by the PostgreSQL implementation.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5babe13ca152b6d4b2cd38bc2c435fa0c50060b9"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc1ODI1Mg==", "bodyText": "Do we want to briefly explain the difference? Would this be too long? The tests don't seem to exemplify either.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545758252", "createdAt": "2020-12-18T11:00:43Z", "author": {"login": "bpintea"}, "path": "docs/reference/sql/functions/date-time.asciidoc", "diffHunk": "@@ -818,6 +818,54 @@ include-tagged::{sql-specs}/docs/docs.csv-spec[formatDateTime]\n include-tagged::{sql-specs}/docs/docs.csv-spec[formatTime]\n --------------------------------------------------\n \n+\n+[[sql-functions-datetime-to_char]]\n+==== `TO_CHAR`\n+\n+.Synopsis:\n+[source, sql]\n+--------------------------------------------------\n+TO_CHAR(\n+    date_exp/datetime_exp/time_exp, <1>\n+    string_exp) <2>\n+--------------------------------------------------\n+\n+*Input*:\n+\n+<1> date/datetime/time expression\n+<2> format pattern\n+\n+*Output*: string\n+\n+*Description*: Returns the date/datetime/time as a string using the format specified in the 2nd argument. The formatting\n+pattern conforms to\n+https://www.postgresql.org/docs/13/functions-formatting.html[PostgreSQL Template Patterns for Date/Time Formatting].\n+If any of the two arguments is `null` or the pattern is an empty string `null` is returned.\n+\n+[NOTE]\n+If the 1st argument is of type `time`, then the pattern specified by the 2nd argument cannot contain date related units\n+(e.g. 'dd', 'MM', 'YYYY', etc.). If it contains such units an error is returned.\n+\n+*Special Cases*\n+\n+- The result of the pattern `TZ`, `tz` and `OF` patterns is equivalent with, but differs from the results returned by the PostgreSQL implementation.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc0NDkzNA=="}, "originalCommit": {"oid": "5babe13ca152b6d4b2cd38bc2c435fa0c50060b9"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc1ODU1Mw==", "bodyText": "...and not FX, TM, SP, you mean?", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545758553", "createdAt": "2020-12-18T11:01:19Z", "author": {"login": "bpintea"}, "path": "docs/reference/sql/functions/date-time.asciidoc", "diffHunk": "@@ -818,6 +818,54 @@ include-tagged::{sql-specs}/docs/docs.csv-spec[formatDateTime]\n include-tagged::{sql-specs}/docs/docs.csv-spec[formatTime]\n --------------------------------------------------\n \n+\n+[[sql-functions-datetime-to_char]]\n+==== `TO_CHAR`\n+\n+.Synopsis:\n+[source, sql]\n+--------------------------------------------------\n+TO_CHAR(\n+    date_exp/datetime_exp/time_exp, <1>\n+    string_exp) <2>\n+--------------------------------------------------\n+\n+*Input*:\n+\n+<1> date/datetime/time expression\n+<2> format pattern\n+\n+*Output*: string\n+\n+*Description*: Returns the date/datetime/time as a string using the format specified in the 2nd argument. The formatting\n+pattern conforms to\n+https://www.postgresql.org/docs/13/functions-formatting.html[PostgreSQL Template Patterns for Date/Time Formatting].\n+If any of the two arguments is `null` or the pattern is an empty string `null` is returned.\n+\n+[NOTE]\n+If the 1st argument is of type `time`, then the pattern specified by the 2nd argument cannot contain date related units\n+(e.g. 'dd', 'MM', 'YYYY', etc.). If it contains such units an error is returned.\n+\n+*Special Cases*\n+\n+- The result of the pattern `TZ`, `tz` and `OF` patterns is equivalent with, but differs from the results returned by the PostgreSQL implementation.\n+- Only the `FM`, `TH` and `th` pattern modifiers implemented.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5babe13ca152b6d4b2cd38bc2c435fa0c50060b9"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc2NjAxNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            SELECT birth_date, TO_CHAR(birth_date, 'MM/DD/YYYY') AS df_birth_date1, TO_CHAR(birth_date, concat(gender, 'M/DD')) AS df_birth_date2\n          \n          \n            \n            SELECT birth_date, TO_CHAR(birth_date, 'MM/DD/YYYY') AS df_birth_date1, TO_CHAR(birth_date, CONCAT(gender, 'M/DD')) AS df_birth_date2\n          \n      \n    \n    \n  \n\nNice. A funky outcome would also be without the 'M' filtering and / separation (for the FM to work).", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545766015", "createdAt": "2020-12-18T11:15:46Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/sql/qa/server/src/main/resources/datetime.csv-spec", "diffHunk": "@@ -601,6 +601,110 @@ HAVING DATETIME_FORMAT(MAX(birth_date), 'dd')::integer > 20  ORDER BY 1 DESC;\n 1961-02-26 00:00:00.000Z | 02\n ;\n \n+selectToChar\n+schema::df_date:s|df_datetime:s|df_time:s\n+SELECT TO_CHAR('2020-04-05T11:22:33.123Z'::date, 'DD/MM/YYYY HH24:MI:SS.FF3') AS df_date,\n+TO_CHAR('2020-04-05T11:22:33.123Z'::datetime, 'DD/MM/YYYY HH24:MI:SS.FF2') AS df_datetime,\n+TO_CHAR('11:22:33.123456789Z'::time, 'HH24:MI:SS.FF2') AS df_time;\n+\n+       df_date          |    df_datetime         |   df_time\n+------------------------+------------------------+----------------\n+05/04/2020 00:00:00.000 | 05/04/2020 11:22:33.12 | 11:22:33.12\n+;\n+\n+selectToCharWithField\n+schema::birth_date:ts|df_birth_date1:s|df_birth_date2:s\n+SELECT birth_date, TO_CHAR(birth_date, 'MM/DD/YYYY') AS df_birth_date1, TO_CHAR(birth_date, concat(gender, 'M/DD')) AS df_birth_date2", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5babe13ca152b6d4b2cd38bc2c435fa0c50060b9"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc2OTM4MA==", "bodyText": "Maybe\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            SELECT TO_CHAR(CAST('11:22:33.987' AS TIME), 'HH24 MI SS.FF1') AS \"time\";\n          \n          \n            \n            SELECT TO_CHAR(CAST('23:22:33.987' AS TIME), 'HH12 MI SS.FF1') AS \"time\";\n          \n      \n    \n    \n  \n\nfor a change, HH24 appeared a few times already.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545769380", "createdAt": "2020-12-18T11:23:06Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/sql/qa/server/src/main/resources/docs/docs.csv-spec", "diffHunk": "@@ -2876,6 +2877,36 @@ SELECT DATETIME_FORMAT(CAST('11:22:33.987' AS TIME), 'HH mm ss.S') AS \"time\";\n // end::dateTimeFormatTime\n ;\n \n+toCharDate\n+// tag::toCharDate\n+SELECT TO_CHAR(CAST('2020-04-05' AS DATE), 'DD/MM/YYYY') AS \"date\";\n+\n+      date\n+------------------\n+05/04/2020\n+// end::toCharDate\n+;\n+\n+toCharDateTime\n+// tag::toCharDateTime\n+SELECT TO_CHAR(CAST('2020-04-05T11:22:33.987654' AS DATETIME), 'DD/MM/YYYY HH24:MI:SS.FF2') AS \"datetime\";\n+\n+      datetime\n+------------------\n+05/04/2020 11:22:33.98\n+// end::toCharDateTime\n+;\n+\n+toCharTime\n+// tag::toCharTime\n+SELECT TO_CHAR(CAST('11:22:33.987' AS TIME), 'HH24 MI SS.FF1') AS \"time\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5babe13ca152b6d4b2cd38bc2c435fa0c50060b9"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc3OTQyMA==", "bodyText": "was this line breaking intentional?", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545779420", "createdAt": "2020-12-18T11:44:30Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::fillOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int\n+        MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().getAsInt();\n+\n+    private final String pattern;\n+    private final boolean lowercaseAccepted;\n+    private final Function<String, String> fillMode;\n+    private final boolean hasOrdinalSuffix;\n+    private final Function<TemporalAccessor, String> formatFn;\n+\n+    private ToCharFormatter(\n+        String pattern,\n+        boolean lowercaseAccepted,\n+        Function<String, String> fillMode,\n+        boolean hasOrdinalSuffix,\n+        Function<TemporalAccessor, String> formatFn) {\n+\n+        this.pattern = pattern;\n+        this.lowercaseAccepted = lowercaseAccepted;\n+        this.fillMode = fillMode;\n+        this.hasOrdinalSuffix = hasOrdinalSuffix;\n+        this.formatFn = formatFn;\n+    }\n+\n+    private static Builder of(String pattern) {\n+        return new Builder(pattern);\n+    }\n+\n+    private String format(TemporalAccessor temporalAccessor) {\n+        return formatFn.apply(temporalAccessor);\n+    }\n+\n+    private ToCharFormatter withModifier(Function<String, String> modifierFn) {\n+        return new ToCharFormatter(pattern, lowercaseAccepted, fillMode, hasOrdinalSuffix, formatFn.andThen(modifierFn));\n+    }\n+\n+    private static List<ToCharFormatter> parsePattern(String toCharPattern) {\n+        LinkedList<ToCharFormatter> formatters = new LinkedList<>();\n+\n+        boolean fillModeModifierActive = false;\n+\n+        while (toCharPattern.isEmpty() == false) {\n+            boolean foundPattern = false;\n+            for (int length = Math.min(MAX_TO_CHAR_FORMAT_STRING_LENGTH, toCharPattern.length()); length >= 1; length--) {\n+                final String potentialPattern = toCharPattern.substring(0, length);\n+                if (\"FM\".equals(potentialPattern) || \"fm\".equals(potentialPattern)) {\n+                    // try to apply the fill mode modifier to the next formatter\n+                    fillModeModifierActive = true;\n+                    foundPattern = true;\n+                } else if (\"TH\".equals(potentialPattern) || \"th\".equals(potentialPattern)) {\n+                    // try to apply the ordinal suffix modifier to the last formatter\n+                    ToCharFormatter lastFormatter = formatters.removeLast();\n+                    if (lastFormatter == null) {\n+                        lastFormatter = literal(potentialPattern);\n+                    } else if (lastFormatter.hasOrdinalSuffix) {\n+                        // if there was no previous pattern, simply prints the ordinal suffix pattern\n+                        final boolean upperCase = \"TH\".equals(potentialPattern);\n+                        lastFormatter = lastFormatter.withModifier(s -> appendOrdinalSuffix(potentialPattern, upperCase, s));\n+                    }\n+                    formatters.addLast(lastFormatter);\n+                    foundPattern = true;\n+                } else {\n+                    ToCharFormatter formatter = FORMATTER_MAP.get(potentialPattern);\n+                    // check if it is a known pattern string, if so apply it, with any modifier\n+                    if (formatter != null) {\n+                        if (fillModeModifierActive && formatter.fillMode != null) {\n+                            formatter = formatter.withModifier(formatter.fillMode);\n+                        }\n+                        formatters.addLast(formatter);\n+                        fillModeModifierActive = false;\n+                        foundPattern = true;\n+                    }\n+                }\n+                if (foundPattern) {\n+                    toCharPattern = toCharPattern.substring(length);\n+                    break;\n+                }\n+            }\n+            if (foundPattern == false) {\n+                // the fill mode modifier does not apply in case of literals\n+                formatters.addLast(literal(toCharPattern.substring(0, 1)));\n+                toCharPattern = toCharPattern.substring(1);\n+                fillModeModifierActive = false;\n+            }\n+        }\n+        return formatters;\n+    }\n+\n+    public static Function<TemporalAccessor, String> ofPattern(String pattern) {\n+        if (Strings.isEmpty(pattern)) {\n+            return timestamp -> \"\";\n+        }\n+        final List<ToCharFormatter> toCharFormatters = parsePattern(pattern);\n+        return timestamp -> toCharFormatters.stream().map(p -> p.format(timestamp)).collect(Collectors.joining());\n+    }\n+\n+    private static ToCharFormatter literal(String literal) {\n+        return new ToCharFormatter(literal, false, null, true, t -> literal);\n+    }\n+\n+    private static String ordinalSuffix(int i) {\n+        if (i < 0) {\n+            i = -i;\n+        }\n+        int mod100 = i % 100;\n+        int mod10 = i % 10;\n+        if (mod10 == 1 && mod100 != 11) {\n+            return \"st\";\n+        } else if (mod10 == 2 && mod100 != 12) {\n+            return \"nd\";\n+        } else if (mod10 == 3 && mod100 != 13) {\n+            return \"rd\";\n+        } else {\n+            return \"th\";\n+        }\n+    }\n+\n+    private static String appendOrdinalSuffix(String defaultSuffix, boolean upperCase, String s) {\n+        try {\n+            // the Y,YYY pattern might can cause problems with the parsing, but thankfully the last 3\n+            // characters is enough to calculate the suffix\n+            int i = Integer.parseInt(lastNCharacter(s, 3));\n+            return s + (upperCase ? ordinalSuffix(i).toUpperCase(Locale.ROOT) : ordinalSuffix(i));\n+        } catch (NumberFormatException ex) {\n+            return s + defaultSuffix;\n+        }\n+    }\n+\n+    private static String fillNumeric(String paddedNumber) {\n+        return String.valueOf(Integer.parseInt(paddedNumber));\n+    }\n+\n+    private static String fillText(String paddedText) {\n+        return paddedText.replaceAll(\" +$\", \"\");\n+    }\n+\n+    private static String formatOffset(String offset) {\n+        if (offset.equals(\"Z\")) {\n+            return \"+00\";\n+        }\n+        if (offset.matches(\"^[+-][0-9][0-9]00$\")) {\n+            offset = offset.substring(0, offset.length() - 2);\n+        } else if (offset.matches(\"^[+-][0-9]{3,4}$\")) {\n+            offset = offset.substring(0, offset.length() - 2) + \":\" + offset.substring(offset.length() - 2);\n+        } else if (offset.matches(\"^[+-][0-9][0-9]:00$\")) {\n+            offset = offset.substring(0, offset.length() - 3);\n+        }\n+        return offset.substring(0, Math.min(offset.length(), 6));\n+    }\n+\n+    private static String fillOffset(String offset) {\n+        //offset = offset.replace(\":{0,1}00$\", \"\");\n+        if (offset.matches(\"[+-]0{1,2}\")) {\n+            return offset.substring(0, 2);\n+        } else {\n+            if (offset.startsWith(\"+0\")) {\n+                return \"+\" + offset.substring(2);\n+            } else if (offset.startsWith(\"-0\")) {\n+                return \"-\" + offset.substring(2);\n+            } else {\n+                return offset;\n+            }\n+        }\n+    }\n+\n+    private static String absoluteWeekBasedYear(TemporalAccessor t) {\n+        int year = t.get(IsoFields.WEEK_BASED_YEAR);\n+        year = year > 0 ? year : -(year - 1);\n+        return String.format(Locale.ROOT, \"%04d\", year);\n+    }\n+\n+    private static String firstDigitsOfNanos(String nano, int digits) {\n+        return String.format(Locale.ROOT, \"%09d\", Integer.parseInt(nano)).substring(0, digits);\n+    }\n+\n+    private static String lastNCharacter(String s, int n) {\n+        return s.substring(Math.max(0, s.length() - n));\n+    }\n+\n+    private static String zoneAbbreviationOf(TemporalAccessor temporalAccessor) {\n+        String zone = ZoneId.from(temporalAccessor).getDisplayName(TextStyle.SHORT, Locale.ROOT);\n+        return \"Z\".equals(zone) ? \"UTC\" : zone;\n+    }\n+\n+    private static class Builder {\n+\n+        private final String pattern;\n+        private boolean lowercaseAccepted = true;\n+        private Function<String, String> fillMode = ToCharFormatter::fillNumeric;\n+        private boolean hasOrdinalSuffix = true;\n+        private Function<TemporalAccessor, String> formatFn;\n+\n+        Builder(String pattern) {\n+            this.pattern = pattern;\n+        }\n+\n+        public Builder formatFn(final String javaPatterm) {\n+            return formatFn(javaPatterm, null);\n+        }\n+\n+        public Builder formatFn(final String javaPattern, final Function<String, String> additionalMapper) {\n+            this.formatFn = temporalAccessor -> {\n+                String\n+                    formatted =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5babe13ca152b6d4b2cd38bc2c435fa0c50060b9"}, "originalPosition": 334}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTgzNDc2Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    public Builder formatFn(final String javaPatterm) {\n          \n          \n            \n                    public Builder formatFn(final String javaPattern) {", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545834762", "createdAt": "2020-12-18T13:36:31Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::fillOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int\n+        MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().getAsInt();\n+\n+    private final String pattern;\n+    private final boolean lowercaseAccepted;\n+    private final Function<String, String> fillMode;\n+    private final boolean hasOrdinalSuffix;\n+    private final Function<TemporalAccessor, String> formatFn;\n+\n+    private ToCharFormatter(\n+        String pattern,\n+        boolean lowercaseAccepted,\n+        Function<String, String> fillMode,\n+        boolean hasOrdinalSuffix,\n+        Function<TemporalAccessor, String> formatFn) {\n+\n+        this.pattern = pattern;\n+        this.lowercaseAccepted = lowercaseAccepted;\n+        this.fillMode = fillMode;\n+        this.hasOrdinalSuffix = hasOrdinalSuffix;\n+        this.formatFn = formatFn;\n+    }\n+\n+    private static Builder of(String pattern) {\n+        return new Builder(pattern);\n+    }\n+\n+    private String format(TemporalAccessor temporalAccessor) {\n+        return formatFn.apply(temporalAccessor);\n+    }\n+\n+    private ToCharFormatter withModifier(Function<String, String> modifierFn) {\n+        return new ToCharFormatter(pattern, lowercaseAccepted, fillMode, hasOrdinalSuffix, formatFn.andThen(modifierFn));\n+    }\n+\n+    private static List<ToCharFormatter> parsePattern(String toCharPattern) {\n+        LinkedList<ToCharFormatter> formatters = new LinkedList<>();\n+\n+        boolean fillModeModifierActive = false;\n+\n+        while (toCharPattern.isEmpty() == false) {\n+            boolean foundPattern = false;\n+            for (int length = Math.min(MAX_TO_CHAR_FORMAT_STRING_LENGTH, toCharPattern.length()); length >= 1; length--) {\n+                final String potentialPattern = toCharPattern.substring(0, length);\n+                if (\"FM\".equals(potentialPattern) || \"fm\".equals(potentialPattern)) {\n+                    // try to apply the fill mode modifier to the next formatter\n+                    fillModeModifierActive = true;\n+                    foundPattern = true;\n+                } else if (\"TH\".equals(potentialPattern) || \"th\".equals(potentialPattern)) {\n+                    // try to apply the ordinal suffix modifier to the last formatter\n+                    ToCharFormatter lastFormatter = formatters.removeLast();\n+                    if (lastFormatter == null) {\n+                        lastFormatter = literal(potentialPattern);\n+                    } else if (lastFormatter.hasOrdinalSuffix) {\n+                        // if there was no previous pattern, simply prints the ordinal suffix pattern\n+                        final boolean upperCase = \"TH\".equals(potentialPattern);\n+                        lastFormatter = lastFormatter.withModifier(s -> appendOrdinalSuffix(potentialPattern, upperCase, s));\n+                    }\n+                    formatters.addLast(lastFormatter);\n+                    foundPattern = true;\n+                } else {\n+                    ToCharFormatter formatter = FORMATTER_MAP.get(potentialPattern);\n+                    // check if it is a known pattern string, if so apply it, with any modifier\n+                    if (formatter != null) {\n+                        if (fillModeModifierActive && formatter.fillMode != null) {\n+                            formatter = formatter.withModifier(formatter.fillMode);\n+                        }\n+                        formatters.addLast(formatter);\n+                        fillModeModifierActive = false;\n+                        foundPattern = true;\n+                    }\n+                }\n+                if (foundPattern) {\n+                    toCharPattern = toCharPattern.substring(length);\n+                    break;\n+                }\n+            }\n+            if (foundPattern == false) {\n+                // the fill mode modifier does not apply in case of literals\n+                formatters.addLast(literal(toCharPattern.substring(0, 1)));\n+                toCharPattern = toCharPattern.substring(1);\n+                fillModeModifierActive = false;\n+            }\n+        }\n+        return formatters;\n+    }\n+\n+    public static Function<TemporalAccessor, String> ofPattern(String pattern) {\n+        if (Strings.isEmpty(pattern)) {\n+            return timestamp -> \"\";\n+        }\n+        final List<ToCharFormatter> toCharFormatters = parsePattern(pattern);\n+        return timestamp -> toCharFormatters.stream().map(p -> p.format(timestamp)).collect(Collectors.joining());\n+    }\n+\n+    private static ToCharFormatter literal(String literal) {\n+        return new ToCharFormatter(literal, false, null, true, t -> literal);\n+    }\n+\n+    private static String ordinalSuffix(int i) {\n+        if (i < 0) {\n+            i = -i;\n+        }\n+        int mod100 = i % 100;\n+        int mod10 = i % 10;\n+        if (mod10 == 1 && mod100 != 11) {\n+            return \"st\";\n+        } else if (mod10 == 2 && mod100 != 12) {\n+            return \"nd\";\n+        } else if (mod10 == 3 && mod100 != 13) {\n+            return \"rd\";\n+        } else {\n+            return \"th\";\n+        }\n+    }\n+\n+    private static String appendOrdinalSuffix(String defaultSuffix, boolean upperCase, String s) {\n+        try {\n+            // the Y,YYY pattern might can cause problems with the parsing, but thankfully the last 3\n+            // characters is enough to calculate the suffix\n+            int i = Integer.parseInt(lastNCharacter(s, 3));\n+            return s + (upperCase ? ordinalSuffix(i).toUpperCase(Locale.ROOT) : ordinalSuffix(i));\n+        } catch (NumberFormatException ex) {\n+            return s + defaultSuffix;\n+        }\n+    }\n+\n+    private static String fillNumeric(String paddedNumber) {\n+        return String.valueOf(Integer.parseInt(paddedNumber));\n+    }\n+\n+    private static String fillText(String paddedText) {\n+        return paddedText.replaceAll(\" +$\", \"\");\n+    }\n+\n+    private static String formatOffset(String offset) {\n+        if (offset.equals(\"Z\")) {\n+            return \"+00\";\n+        }\n+        if (offset.matches(\"^[+-][0-9][0-9]00$\")) {\n+            offset = offset.substring(0, offset.length() - 2);\n+        } else if (offset.matches(\"^[+-][0-9]{3,4}$\")) {\n+            offset = offset.substring(0, offset.length() - 2) + \":\" + offset.substring(offset.length() - 2);\n+        } else if (offset.matches(\"^[+-][0-9][0-9]:00$\")) {\n+            offset = offset.substring(0, offset.length() - 3);\n+        }\n+        return offset.substring(0, Math.min(offset.length(), 6));\n+    }\n+\n+    private static String fillOffset(String offset) {\n+        //offset = offset.replace(\":{0,1}00$\", \"\");\n+        if (offset.matches(\"[+-]0{1,2}\")) {\n+            return offset.substring(0, 2);\n+        } else {\n+            if (offset.startsWith(\"+0\")) {\n+                return \"+\" + offset.substring(2);\n+            } else if (offset.startsWith(\"-0\")) {\n+                return \"-\" + offset.substring(2);\n+            } else {\n+                return offset;\n+            }\n+        }\n+    }\n+\n+    private static String absoluteWeekBasedYear(TemporalAccessor t) {\n+        int year = t.get(IsoFields.WEEK_BASED_YEAR);\n+        year = year > 0 ? year : -(year - 1);\n+        return String.format(Locale.ROOT, \"%04d\", year);\n+    }\n+\n+    private static String firstDigitsOfNanos(String nano, int digits) {\n+        return String.format(Locale.ROOT, \"%09d\", Integer.parseInt(nano)).substring(0, digits);\n+    }\n+\n+    private static String lastNCharacter(String s, int n) {\n+        return s.substring(Math.max(0, s.length() - n));\n+    }\n+\n+    private static String zoneAbbreviationOf(TemporalAccessor temporalAccessor) {\n+        String zone = ZoneId.from(temporalAccessor).getDisplayName(TextStyle.SHORT, Locale.ROOT);\n+        return \"Z\".equals(zone) ? \"UTC\" : zone;\n+    }\n+\n+    private static class Builder {\n+\n+        private final String pattern;\n+        private boolean lowercaseAccepted = true;\n+        private Function<String, String> fillMode = ToCharFormatter::fillNumeric;\n+        private boolean hasOrdinalSuffix = true;\n+        private Function<TemporalAccessor, String> formatFn;\n+\n+        Builder(String pattern) {\n+            this.pattern = pattern;\n+        }\n+\n+        public Builder formatFn(final String javaPatterm) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5babe13ca152b6d4b2cd38bc2c435fa0c50060b9"}, "originalPosition": 327}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTgzOTc1OA==", "bodyText": "I guess the function naming is inspired from Posgres' docs (FM being the \"fill mode\"), but I still find it a tad misleading, since they actually strip (padding, like leading zeros or trailing spaces). Anyways, half a concern, maybe a quick comment would \"fill in\" the next reader. :-)", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545839758", "createdAt": "2020-12-18T13:45:40Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::fillOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int\n+        MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().getAsInt();\n+\n+    private final String pattern;\n+    private final boolean lowercaseAccepted;\n+    private final Function<String, String> fillMode;\n+    private final boolean hasOrdinalSuffix;\n+    private final Function<TemporalAccessor, String> formatFn;\n+\n+    private ToCharFormatter(\n+        String pattern,\n+        boolean lowercaseAccepted,\n+        Function<String, String> fillMode,\n+        boolean hasOrdinalSuffix,\n+        Function<TemporalAccessor, String> formatFn) {\n+\n+        this.pattern = pattern;\n+        this.lowercaseAccepted = lowercaseAccepted;\n+        this.fillMode = fillMode;\n+        this.hasOrdinalSuffix = hasOrdinalSuffix;\n+        this.formatFn = formatFn;\n+    }\n+\n+    private static Builder of(String pattern) {\n+        return new Builder(pattern);\n+    }\n+\n+    private String format(TemporalAccessor temporalAccessor) {\n+        return formatFn.apply(temporalAccessor);\n+    }\n+\n+    private ToCharFormatter withModifier(Function<String, String> modifierFn) {\n+        return new ToCharFormatter(pattern, lowercaseAccepted, fillMode, hasOrdinalSuffix, formatFn.andThen(modifierFn));\n+    }\n+\n+    private static List<ToCharFormatter> parsePattern(String toCharPattern) {\n+        LinkedList<ToCharFormatter> formatters = new LinkedList<>();\n+\n+        boolean fillModeModifierActive = false;\n+\n+        while (toCharPattern.isEmpty() == false) {\n+            boolean foundPattern = false;\n+            for (int length = Math.min(MAX_TO_CHAR_FORMAT_STRING_LENGTH, toCharPattern.length()); length >= 1; length--) {\n+                final String potentialPattern = toCharPattern.substring(0, length);\n+                if (\"FM\".equals(potentialPattern) || \"fm\".equals(potentialPattern)) {\n+                    // try to apply the fill mode modifier to the next formatter\n+                    fillModeModifierActive = true;\n+                    foundPattern = true;\n+                } else if (\"TH\".equals(potentialPattern) || \"th\".equals(potentialPattern)) {\n+                    // try to apply the ordinal suffix modifier to the last formatter\n+                    ToCharFormatter lastFormatter = formatters.removeLast();\n+                    if (lastFormatter == null) {\n+                        lastFormatter = literal(potentialPattern);\n+                    } else if (lastFormatter.hasOrdinalSuffix) {\n+                        // if there was no previous pattern, simply prints the ordinal suffix pattern\n+                        final boolean upperCase = \"TH\".equals(potentialPattern);\n+                        lastFormatter = lastFormatter.withModifier(s -> appendOrdinalSuffix(potentialPattern, upperCase, s));\n+                    }\n+                    formatters.addLast(lastFormatter);\n+                    foundPattern = true;\n+                } else {\n+                    ToCharFormatter formatter = FORMATTER_MAP.get(potentialPattern);\n+                    // check if it is a known pattern string, if so apply it, with any modifier\n+                    if (formatter != null) {\n+                        if (fillModeModifierActive && formatter.fillMode != null) {\n+                            formatter = formatter.withModifier(formatter.fillMode);\n+                        }\n+                        formatters.addLast(formatter);\n+                        fillModeModifierActive = false;\n+                        foundPattern = true;\n+                    }\n+                }\n+                if (foundPattern) {\n+                    toCharPattern = toCharPattern.substring(length);\n+                    break;\n+                }\n+            }\n+            if (foundPattern == false) {\n+                // the fill mode modifier does not apply in case of literals\n+                formatters.addLast(literal(toCharPattern.substring(0, 1)));\n+                toCharPattern = toCharPattern.substring(1);\n+                fillModeModifierActive = false;\n+            }\n+        }\n+        return formatters;\n+    }\n+\n+    public static Function<TemporalAccessor, String> ofPattern(String pattern) {\n+        if (Strings.isEmpty(pattern)) {\n+            return timestamp -> \"\";\n+        }\n+        final List<ToCharFormatter> toCharFormatters = parsePattern(pattern);\n+        return timestamp -> toCharFormatters.stream().map(p -> p.format(timestamp)).collect(Collectors.joining());\n+    }\n+\n+    private static ToCharFormatter literal(String literal) {\n+        return new ToCharFormatter(literal, false, null, true, t -> literal);\n+    }\n+\n+    private static String ordinalSuffix(int i) {\n+        if (i < 0) {\n+            i = -i;\n+        }\n+        int mod100 = i % 100;\n+        int mod10 = i % 10;\n+        if (mod10 == 1 && mod100 != 11) {\n+            return \"st\";\n+        } else if (mod10 == 2 && mod100 != 12) {\n+            return \"nd\";\n+        } else if (mod10 == 3 && mod100 != 13) {\n+            return \"rd\";\n+        } else {\n+            return \"th\";\n+        }\n+    }\n+\n+    private static String appendOrdinalSuffix(String defaultSuffix, boolean upperCase, String s) {\n+        try {\n+            // the Y,YYY pattern might can cause problems with the parsing, but thankfully the last 3\n+            // characters is enough to calculate the suffix\n+            int i = Integer.parseInt(lastNCharacter(s, 3));\n+            return s + (upperCase ? ordinalSuffix(i).toUpperCase(Locale.ROOT) : ordinalSuffix(i));\n+        } catch (NumberFormatException ex) {\n+            return s + defaultSuffix;\n+        }\n+    }\n+\n+    private static String fillNumeric(String paddedNumber) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5babe13ca152b6d4b2cd38bc2c435fa0c50060b9"}, "originalPosition": 259}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg0MTg3Mg==", "bodyText": "I guess the comment can go.\n(Also, I thought that C++-style comments required a space after the leading slashes, I def. got some failures b/c of it.)", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545841872", "createdAt": "2020-12-18T13:49:12Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::fillOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int\n+        MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().getAsInt();\n+\n+    private final String pattern;\n+    private final boolean lowercaseAccepted;\n+    private final Function<String, String> fillMode;\n+    private final boolean hasOrdinalSuffix;\n+    private final Function<TemporalAccessor, String> formatFn;\n+\n+    private ToCharFormatter(\n+        String pattern,\n+        boolean lowercaseAccepted,\n+        Function<String, String> fillMode,\n+        boolean hasOrdinalSuffix,\n+        Function<TemporalAccessor, String> formatFn) {\n+\n+        this.pattern = pattern;\n+        this.lowercaseAccepted = lowercaseAccepted;\n+        this.fillMode = fillMode;\n+        this.hasOrdinalSuffix = hasOrdinalSuffix;\n+        this.formatFn = formatFn;\n+    }\n+\n+    private static Builder of(String pattern) {\n+        return new Builder(pattern);\n+    }\n+\n+    private String format(TemporalAccessor temporalAccessor) {\n+        return formatFn.apply(temporalAccessor);\n+    }\n+\n+    private ToCharFormatter withModifier(Function<String, String> modifierFn) {\n+        return new ToCharFormatter(pattern, lowercaseAccepted, fillMode, hasOrdinalSuffix, formatFn.andThen(modifierFn));\n+    }\n+\n+    private static List<ToCharFormatter> parsePattern(String toCharPattern) {\n+        LinkedList<ToCharFormatter> formatters = new LinkedList<>();\n+\n+        boolean fillModeModifierActive = false;\n+\n+        while (toCharPattern.isEmpty() == false) {\n+            boolean foundPattern = false;\n+            for (int length = Math.min(MAX_TO_CHAR_FORMAT_STRING_LENGTH, toCharPattern.length()); length >= 1; length--) {\n+                final String potentialPattern = toCharPattern.substring(0, length);\n+                if (\"FM\".equals(potentialPattern) || \"fm\".equals(potentialPattern)) {\n+                    // try to apply the fill mode modifier to the next formatter\n+                    fillModeModifierActive = true;\n+                    foundPattern = true;\n+                } else if (\"TH\".equals(potentialPattern) || \"th\".equals(potentialPattern)) {\n+                    // try to apply the ordinal suffix modifier to the last formatter\n+                    ToCharFormatter lastFormatter = formatters.removeLast();\n+                    if (lastFormatter == null) {\n+                        lastFormatter = literal(potentialPattern);\n+                    } else if (lastFormatter.hasOrdinalSuffix) {\n+                        // if there was no previous pattern, simply prints the ordinal suffix pattern\n+                        final boolean upperCase = \"TH\".equals(potentialPattern);\n+                        lastFormatter = lastFormatter.withModifier(s -> appendOrdinalSuffix(potentialPattern, upperCase, s));\n+                    }\n+                    formatters.addLast(lastFormatter);\n+                    foundPattern = true;\n+                } else {\n+                    ToCharFormatter formatter = FORMATTER_MAP.get(potentialPattern);\n+                    // check if it is a known pattern string, if so apply it, with any modifier\n+                    if (formatter != null) {\n+                        if (fillModeModifierActive && formatter.fillMode != null) {\n+                            formatter = formatter.withModifier(formatter.fillMode);\n+                        }\n+                        formatters.addLast(formatter);\n+                        fillModeModifierActive = false;\n+                        foundPattern = true;\n+                    }\n+                }\n+                if (foundPattern) {\n+                    toCharPattern = toCharPattern.substring(length);\n+                    break;\n+                }\n+            }\n+            if (foundPattern == false) {\n+                // the fill mode modifier does not apply in case of literals\n+                formatters.addLast(literal(toCharPattern.substring(0, 1)));\n+                toCharPattern = toCharPattern.substring(1);\n+                fillModeModifierActive = false;\n+            }\n+        }\n+        return formatters;\n+    }\n+\n+    public static Function<TemporalAccessor, String> ofPattern(String pattern) {\n+        if (Strings.isEmpty(pattern)) {\n+            return timestamp -> \"\";\n+        }\n+        final List<ToCharFormatter> toCharFormatters = parsePattern(pattern);\n+        return timestamp -> toCharFormatters.stream().map(p -> p.format(timestamp)).collect(Collectors.joining());\n+    }\n+\n+    private static ToCharFormatter literal(String literal) {\n+        return new ToCharFormatter(literal, false, null, true, t -> literal);\n+    }\n+\n+    private static String ordinalSuffix(int i) {\n+        if (i < 0) {\n+            i = -i;\n+        }\n+        int mod100 = i % 100;\n+        int mod10 = i % 10;\n+        if (mod10 == 1 && mod100 != 11) {\n+            return \"st\";\n+        } else if (mod10 == 2 && mod100 != 12) {\n+            return \"nd\";\n+        } else if (mod10 == 3 && mod100 != 13) {\n+            return \"rd\";\n+        } else {\n+            return \"th\";\n+        }\n+    }\n+\n+    private static String appendOrdinalSuffix(String defaultSuffix, boolean upperCase, String s) {\n+        try {\n+            // the Y,YYY pattern might can cause problems with the parsing, but thankfully the last 3\n+            // characters is enough to calculate the suffix\n+            int i = Integer.parseInt(lastNCharacter(s, 3));\n+            return s + (upperCase ? ordinalSuffix(i).toUpperCase(Locale.ROOT) : ordinalSuffix(i));\n+        } catch (NumberFormatException ex) {\n+            return s + defaultSuffix;\n+        }\n+    }\n+\n+    private static String fillNumeric(String paddedNumber) {\n+        return String.valueOf(Integer.parseInt(paddedNumber));\n+    }\n+\n+    private static String fillText(String paddedText) {\n+        return paddedText.replaceAll(\" +$\", \"\");\n+    }\n+\n+    private static String formatOffset(String offset) {\n+        if (offset.equals(\"Z\")) {\n+            return \"+00\";\n+        }\n+        if (offset.matches(\"^[+-][0-9][0-9]00$\")) {\n+            offset = offset.substring(0, offset.length() - 2);\n+        } else if (offset.matches(\"^[+-][0-9]{3,4}$\")) {\n+            offset = offset.substring(0, offset.length() - 2) + \":\" + offset.substring(offset.length() - 2);\n+        } else if (offset.matches(\"^[+-][0-9][0-9]:00$\")) {\n+            offset = offset.substring(0, offset.length() - 3);\n+        }\n+        return offset.substring(0, Math.min(offset.length(), 6));\n+    }\n+\n+    private static String fillOffset(String offset) {\n+        //offset = offset.replace(\":{0,1}00$\", \"\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5babe13ca152b6d4b2cd38bc2c435fa0c50060b9"}, "originalPosition": 282}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg1NTc3OA==", "bodyText": "Since you're iterating over the patterns in the loops above in the static block, you could also get the max length there. Just point it out, not saying it's any better.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545855778", "createdAt": "2020-12-18T14:13:28Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::fillOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int\n+        MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().getAsInt();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5babe13ca152b6d4b2cd38bc2c435fa0c50060b9"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg2NjM5NA==", "bodyText": "Wondering if extracting these strings (and the ones below) into static final vars would make sense.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545866394", "createdAt": "2020-12-18T14:30:53Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::fillOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int\n+        MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().getAsInt();\n+\n+    private final String pattern;\n+    private final boolean lowercaseAccepted;\n+    private final Function<String, String> fillMode;\n+    private final boolean hasOrdinalSuffix;\n+    private final Function<TemporalAccessor, String> formatFn;\n+\n+    private ToCharFormatter(\n+        String pattern,\n+        boolean lowercaseAccepted,\n+        Function<String, String> fillMode,\n+        boolean hasOrdinalSuffix,\n+        Function<TemporalAccessor, String> formatFn) {\n+\n+        this.pattern = pattern;\n+        this.lowercaseAccepted = lowercaseAccepted;\n+        this.fillMode = fillMode;\n+        this.hasOrdinalSuffix = hasOrdinalSuffix;\n+        this.formatFn = formatFn;\n+    }\n+\n+    private static Builder of(String pattern) {\n+        return new Builder(pattern);\n+    }\n+\n+    private String format(TemporalAccessor temporalAccessor) {\n+        return formatFn.apply(temporalAccessor);\n+    }\n+\n+    private ToCharFormatter withModifier(Function<String, String> modifierFn) {\n+        return new ToCharFormatter(pattern, lowercaseAccepted, fillMode, hasOrdinalSuffix, formatFn.andThen(modifierFn));\n+    }\n+\n+    private static List<ToCharFormatter> parsePattern(String toCharPattern) {\n+        LinkedList<ToCharFormatter> formatters = new LinkedList<>();\n+\n+        boolean fillModeModifierActive = false;\n+\n+        while (toCharPattern.isEmpty() == false) {\n+            boolean foundPattern = false;\n+            for (int length = Math.min(MAX_TO_CHAR_FORMAT_STRING_LENGTH, toCharPattern.length()); length >= 1; length--) {\n+                final String potentialPattern = toCharPattern.substring(0, length);\n+                if (\"FM\".equals(potentialPattern) || \"fm\".equals(potentialPattern)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5babe13ca152b6d4b2cd38bc2c435fa0c50060b9"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg4NTcxMQ==", "bodyText": "Wondering about the data type choice of a LinkedList (vs maybe just an ArrayList). I only see additions and removal from the tail. Has this remained like that after maybe a refactoring, or an explicit choice. I guess .removeLast() is more comfy than .remove(formatters.size() - 1), but just curious.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545885711", "createdAt": "2020-12-18T14:54:50Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::fillOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int\n+        MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().getAsInt();\n+\n+    private final String pattern;\n+    private final boolean lowercaseAccepted;\n+    private final Function<String, String> fillMode;\n+    private final boolean hasOrdinalSuffix;\n+    private final Function<TemporalAccessor, String> formatFn;\n+\n+    private ToCharFormatter(\n+        String pattern,\n+        boolean lowercaseAccepted,\n+        Function<String, String> fillMode,\n+        boolean hasOrdinalSuffix,\n+        Function<TemporalAccessor, String> formatFn) {\n+\n+        this.pattern = pattern;\n+        this.lowercaseAccepted = lowercaseAccepted;\n+        this.fillMode = fillMode;\n+        this.hasOrdinalSuffix = hasOrdinalSuffix;\n+        this.formatFn = formatFn;\n+    }\n+\n+    private static Builder of(String pattern) {\n+        return new Builder(pattern);\n+    }\n+\n+    private String format(TemporalAccessor temporalAccessor) {\n+        return formatFn.apply(temporalAccessor);\n+    }\n+\n+    private ToCharFormatter withModifier(Function<String, String> modifierFn) {\n+        return new ToCharFormatter(pattern, lowercaseAccepted, fillMode, hasOrdinalSuffix, formatFn.andThen(modifierFn));\n+    }\n+\n+    private static List<ToCharFormatter> parsePattern(String toCharPattern) {\n+        LinkedList<ToCharFormatter> formatters = new LinkedList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5babe13ca152b6d4b2cd38bc2c435fa0c50060b9"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg5NDA0NQ==", "bodyText": "Couldn't this be moved inside the while loop, reset to false on every iteration, like foundPattern? It currently seems reset whether a pattern is found or not.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545894045", "createdAt": "2020-12-18T15:04:13Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::fillOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int\n+        MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().getAsInt();\n+\n+    private final String pattern;\n+    private final boolean lowercaseAccepted;\n+    private final Function<String, String> fillMode;\n+    private final boolean hasOrdinalSuffix;\n+    private final Function<TemporalAccessor, String> formatFn;\n+\n+    private ToCharFormatter(\n+        String pattern,\n+        boolean lowercaseAccepted,\n+        Function<String, String> fillMode,\n+        boolean hasOrdinalSuffix,\n+        Function<TemporalAccessor, String> formatFn) {\n+\n+        this.pattern = pattern;\n+        this.lowercaseAccepted = lowercaseAccepted;\n+        this.fillMode = fillMode;\n+        this.hasOrdinalSuffix = hasOrdinalSuffix;\n+        this.formatFn = formatFn;\n+    }\n+\n+    private static Builder of(String pattern) {\n+        return new Builder(pattern);\n+    }\n+\n+    private String format(TemporalAccessor temporalAccessor) {\n+        return formatFn.apply(temporalAccessor);\n+    }\n+\n+    private ToCharFormatter withModifier(Function<String, String> modifierFn) {\n+        return new ToCharFormatter(pattern, lowercaseAccepted, fillMode, hasOrdinalSuffix, formatFn.andThen(modifierFn));\n+    }\n+\n+    private static List<ToCharFormatter> parsePattern(String toCharPattern) {\n+        LinkedList<ToCharFormatter> formatters = new LinkedList<>();\n+\n+        boolean fillModeModifierActive = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5babe13ca152b6d4b2cd38bc2c435fa0c50060b9"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg5OTIzNQ==", "bodyText": "Should this comment go two lines up?\nThen interestingly, for a FM dd pattern, the FM is just swallowed. Comparatively, the dd TH does print the TH. Not sure if so on purpose or not (I think it's not tested), but I guess it's acceptable, since Postgres behaves exactly the same.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545899235", "createdAt": "2020-12-18T15:12:42Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::fillOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int\n+        MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().getAsInt();\n+\n+    private final String pattern;\n+    private final boolean lowercaseAccepted;\n+    private final Function<String, String> fillMode;\n+    private final boolean hasOrdinalSuffix;\n+    private final Function<TemporalAccessor, String> formatFn;\n+\n+    private ToCharFormatter(\n+        String pattern,\n+        boolean lowercaseAccepted,\n+        Function<String, String> fillMode,\n+        boolean hasOrdinalSuffix,\n+        Function<TemporalAccessor, String> formatFn) {\n+\n+        this.pattern = pattern;\n+        this.lowercaseAccepted = lowercaseAccepted;\n+        this.fillMode = fillMode;\n+        this.hasOrdinalSuffix = hasOrdinalSuffix;\n+        this.formatFn = formatFn;\n+    }\n+\n+    private static Builder of(String pattern) {\n+        return new Builder(pattern);\n+    }\n+\n+    private String format(TemporalAccessor temporalAccessor) {\n+        return formatFn.apply(temporalAccessor);\n+    }\n+\n+    private ToCharFormatter withModifier(Function<String, String> modifierFn) {\n+        return new ToCharFormatter(pattern, lowercaseAccepted, fillMode, hasOrdinalSuffix, formatFn.andThen(modifierFn));\n+    }\n+\n+    private static List<ToCharFormatter> parsePattern(String toCharPattern) {\n+        LinkedList<ToCharFormatter> formatters = new LinkedList<>();\n+\n+        boolean fillModeModifierActive = false;\n+\n+        while (toCharPattern.isEmpty() == false) {\n+            boolean foundPattern = false;\n+            for (int length = Math.min(MAX_TO_CHAR_FORMAT_STRING_LENGTH, toCharPattern.length()); length >= 1; length--) {\n+                final String potentialPattern = toCharPattern.substring(0, length);\n+                if (\"FM\".equals(potentialPattern) || \"fm\".equals(potentialPattern)) {\n+                    // try to apply the fill mode modifier to the next formatter\n+                    fillModeModifierActive = true;\n+                    foundPattern = true;\n+                } else if (\"TH\".equals(potentialPattern) || \"th\".equals(potentialPattern)) {\n+                    // try to apply the ordinal suffix modifier to the last formatter\n+                    ToCharFormatter lastFormatter = formatters.removeLast();\n+                    if (lastFormatter == null) {\n+                        lastFormatter = literal(potentialPattern);\n+                    } else if (lastFormatter.hasOrdinalSuffix) {\n+                        // if there was no previous pattern, simply prints the ordinal suffix pattern", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5babe13ca152b6d4b2cd38bc2c435fa0c50060b9"}, "originalPosition": 186}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2c7a42af7a5fe597d511db3c49de369dfbe786f4", "author": {"user": {"login": "palesz", "name": "Andras Palinkas"}}, "url": "https://github.com/elastic/elasticsearch/commit/2c7a42af7a5fe597d511db3c49de369dfbe786f4", "committedDate": "2020-12-18T18:06:01Z", "message": "PR suggestions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62", "author": {"user": {"login": "palesz", "name": "Andras Palinkas"}}, "url": "https://github.com/elastic/elasticsearch/commit/216ae9777e6e2104d3fb7af52e58b7f90310bb62", "committedDate": "2020-12-18T18:06:12Z", "message": "Merge remote-tracking branch 'origin/master' into feature/to-char-function"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYxOTM2NzAw", "url": "https://github.com/elastic/elasticsearch/pull/66486#pullrequestreview-561936700", "createdAt": "2021-01-05T16:26:13Z", "commit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 26, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNjoyNjoxM1rOIOd--g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNzowOTozOFrOIOfphw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA0MjIzNA==", "bodyText": "I think you mean monthToRoman", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552042234", "createdAt": "2021-01-05T16:26:13Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/util/DateUtils.java", "diffHunk": "@@ -216,6 +216,45 @@ public static TemporalAccessor atTimeZone(TemporalAccessor ta, ZoneId zoneId) {\n         }\n     }\n \n+    public static String toRome(int month) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA0NDI0NA==", "bodyText": "yearToCentury. Is it this method (and the one above) used across multiple classes to justify declaring it in the utils class? Their purpose seems quite narrow.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552044244", "createdAt": "2021-01-05T16:29:12Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/util/DateUtils.java", "diffHunk": "@@ -216,6 +216,45 @@ public static TemporalAccessor atTimeZone(TemporalAccessor ta, ZoneId zoneId) {\n         }\n     }\n \n+    public static String toRome(int month) {\n+        switch (month) {\n+            case 1:\n+                return \"I\";\n+            case 2:\n+                return \"II\";\n+            case 3:\n+                return \"III\";\n+            case 4:\n+                return \"IV\";\n+            case 5:\n+                return \"V\";\n+            case 6:\n+                return \"VI\";\n+            case 7:\n+                return \"VII\";\n+            case 8:\n+                return \"VIII\";\n+            case 9:\n+                return \"IX\";\n+            case 10:\n+                return \"X\";\n+            case 11:\n+                return \"XI\";\n+            case 12:\n+                return \"XII\";\n+            default:\n+                throw new IllegalArgumentException(\"invalid month: \" + month);\n+        }\n+    }\n+\n+    public static int century(int year) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA0NDM2Ng==", "bodyText": "QlIllegalArgumentException.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552044366", "createdAt": "2021-01-05T16:29:23Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/util/DateUtils.java", "diffHunk": "@@ -216,6 +216,45 @@ public static TemporalAccessor atTimeZone(TemporalAccessor ta, ZoneId zoneId) {\n         }\n     }\n \n+    public static String toRome(int month) {\n+        switch (month) {\n+            case 1:\n+                return \"I\";\n+            case 2:\n+                return \"II\";\n+            case 3:\n+                return \"III\";\n+            case 4:\n+                return \"IV\";\n+            case 5:\n+                return \"V\";\n+            case 6:\n+                return \"VI\";\n+            case 7:\n+                return \"VII\";\n+            case 8:\n+                return \"VIII\";\n+            case 9:\n+                return \"IX\";\n+            case 10:\n+                return \"X\";\n+            case 11:\n+                return \"XI\";\n+            case 12:\n+                return \"XII\";\n+            default:\n+                throw new IllegalArgumentException(\"invalid month: \" + month);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA0NTUwNQ==", "bodyText": "This file seems to be generated and it's worth noting that through a basic header such as :\n#\n# DO NOT EDIT! This file is generated, see xxxxx.java\n#", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552045505", "createdAt": "2021-01-05T16:31:09Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/test/resources/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/tochar.csv", "diffHunk": "@@ -0,0 +1,162 @@\n+1|-5888618147.561663|+00:00|HH @ FMHHTH|1783-05-25 16:44:12.438337+00|04 @ 4TH", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA0NjUwMQ==", "bodyText": "Why is this class called TestCase yet it doesn't have a test method?", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552046501", "createdAt": "2021-01-05T16:32:36Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    private static class TestCase {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA0Njg5Ng==", "bodyText": "Is there any concurrency for this counter?", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552046896", "createdAt": "2021-01-05T16:33:09Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    private static class TestCase {\n+        private static final AtomicInteger COUNTER = new AtomicInteger(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA0NzEzMw==", "bodyText": "This is much better externalized to a file", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552047133", "createdAt": "2021-01-05T16:33:29Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    private static class TestCase {\n+        private static final AtomicInteger COUNTER = new AtomicInteger(0);\n+        \n+        // timezones that are valid both in Java and in Postgres\n+        public static final List<String> POSTGRES_TEST_ZONE_LIST = List.of(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA0ODQyNA==", "bodyText": "This utility is better pulled out from this class since it is used manually for testing the results.  It's use can be indicated documented in the test or the result file.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552048424", "createdAt": "2021-01-05T16:35:22Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    private static class TestCase {\n+        private static final AtomicInteger COUNTER = new AtomicInteger(0);\n+        \n+        // timezones that are valid both in Java and in Postgres\n+        public static final List<String> POSTGRES_TEST_ZONE_LIST = List.of(\n+            // location-based and long-names\n+            \"US/Samoa\", \"Pacific/Honolulu\", \"Pacific/Marquesas\", \"Pacific/Gambier\", \"America/Juneau\", \"Canada/Yukon\", \"America/Vancouver\",\n+            \"Pacific/Easter\", \"US/Mountain\", \"America/Chicago\", \"US/Michigan\", \"Atlantic/Bermuda\", \"Canada/Newfoundland\",\n+            \"Atlantic/Cape_Verde\", \"Pacific/Kiritimati\", \"Pacific/Chatham\", \"Pacific/Auckland\", \"Asia/Sakhalin\", \"Australia/Tasmania\", \n+            \"Australia/North\", \"Asia/Tokyo\", \"Australia/Eucla\", \"Asia/Singapore\", \"Asia/Rangoon\", \"Indian/Chagos\", \"Asia/Calcutta\", \n+            \"Asia/Tashkent\", \"Asia/Tehran\", \"Asia/Dubai\", \"Africa/Nairobi\", \"Europe/Brussels\", \"Europe/Vienna\", \"Europe/London\", \n+            \"Etc/GMT+12\",\n+            // short names of zones\n+            \"GMT\", \"UTC\", \"CET\",\n+            // offsets\n+            \"+11:00\", \"+04:30\", \"+01:00\", \"+00:00\", \"-00:00\", \"-01:15\", \"-02:00\", \"-11:00\");\n+\n+        private final int id;\n+        private final BigDecimal secondsAndFractionsSinceEpoch;\n+        private final String formatString;\n+        private final String zoneId;\n+        \n+        TestCase(BigDecimal secondsAndFractionsSinceEpoch, String formatString) {\n+            this.id = COUNTER.incrementAndGet();\n+            this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+            this.formatString = formatString;\n+            this.zoneId = TestGenerator.randomFromCollection(POSTGRES_TEST_ZONE_LIST);\n+        }\n+\n+    }\n+\n+    /**\n+     * Generates an sql file that can be used to generate the test dataset for this unit test (to be used with the <code>psql</code> cli).\n+     *\n+     * Run the @{link {@link TestGenerator#main(String[])}} class and execute the following command to generate the output dataset with:\n+     *\n+     * <p>\n+     *  <code>\n+     *      # easy way to spin up the latest Postgres\n+     *      docker run --rm --name postgres-latest -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres:latest\n+     *\n+     *      # generate the csv for the unit test\n+     *      PGPASSWORD=\"mysecretpassword\" psql --quiet -h localhost -p 5432 -U postgres -f /tmp/postgresql-tochar-test.sql \\\n+     *          &gt; /path/to/tochar.csv\n+     *  </code>\n+     * </p>\n+     */\n+    private static class TestGenerator {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA0ODUxNw==", "bodyText": "All these parameters need to be externalized (say to a Properties file).", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552048517", "createdAt": "2021-01-05T16:35:33Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    private static class TestCase {\n+        private static final AtomicInteger COUNTER = new AtomicInteger(0);\n+        \n+        // timezones that are valid both in Java and in Postgres\n+        public static final List<String> POSTGRES_TEST_ZONE_LIST = List.of(\n+            // location-based and long-names\n+            \"US/Samoa\", \"Pacific/Honolulu\", \"Pacific/Marquesas\", \"Pacific/Gambier\", \"America/Juneau\", \"Canada/Yukon\", \"America/Vancouver\",\n+            \"Pacific/Easter\", \"US/Mountain\", \"America/Chicago\", \"US/Michigan\", \"Atlantic/Bermuda\", \"Canada/Newfoundland\",\n+            \"Atlantic/Cape_Verde\", \"Pacific/Kiritimati\", \"Pacific/Chatham\", \"Pacific/Auckland\", \"Asia/Sakhalin\", \"Australia/Tasmania\", \n+            \"Australia/North\", \"Asia/Tokyo\", \"Australia/Eucla\", \"Asia/Singapore\", \"Asia/Rangoon\", \"Indian/Chagos\", \"Asia/Calcutta\", \n+            \"Asia/Tashkent\", \"Asia/Tehran\", \"Asia/Dubai\", \"Africa/Nairobi\", \"Europe/Brussels\", \"Europe/Vienna\", \"Europe/London\", \n+            \"Etc/GMT+12\",\n+            // short names of zones\n+            \"GMT\", \"UTC\", \"CET\",\n+            // offsets\n+            \"+11:00\", \"+04:30\", \"+01:00\", \"+00:00\", \"-00:00\", \"-01:15\", \"-02:00\", \"-11:00\");\n+\n+        private final int id;\n+        private final BigDecimal secondsAndFractionsSinceEpoch;\n+        private final String formatString;\n+        private final String zoneId;\n+        \n+        TestCase(BigDecimal secondsAndFractionsSinceEpoch, String formatString) {\n+            this.id = COUNTER.incrementAndGet();\n+            this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+            this.formatString = formatString;\n+            this.zoneId = TestGenerator.randomFromCollection(POSTGRES_TEST_ZONE_LIST);\n+        }\n+\n+    }\n+\n+    /**\n+     * Generates an sql file that can be used to generate the test dataset for this unit test (to be used with the <code>psql</code> cli).\n+     *\n+     * Run the @{link {@link TestGenerator#main(String[])}} class and execute the following command to generate the output dataset with:\n+     *\n+     * <p>\n+     *  <code>\n+     *      # easy way to spin up the latest Postgres\n+     *      docker run --rm --name postgres-latest -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres:latest\n+     *\n+     *      # generate the csv for the unit test\n+     *      PGPASSWORD=\"mysecretpassword\" psql --quiet -h localhost -p 5432 -U postgres -f /tmp/postgresql-tochar-test.sql \\\n+     *          &gt; /path/to/tochar.csv\n+     *  </code>\n+     * </p>\n+     */\n+    private static class TestGenerator {\n+        \n+        private static final long SECONDS_IN_YEAR = 365 * 24 * 60 * 60L;\n+        private static final String DELIMITER = \"|\";\n+        private static final String PATTERN_DELIMITER = \" @ \";\n+        // these patterns are hard to sync up between PostgreSQL and Elasticsearch, so we just warn, but actually\n+        // accept the output of Elasticsearch as is\n+        private static final Set<String> NOT_FULLY_MATCHABLE_PATTERNS = Set.of(\"TZ\", \"tz\");\n+        private static final Set<String> UNSUPPORTED_PATTERN_MODIFIERS = Set.of(\"FX\", \"TM\", \"SP\");\n+        private static final String[] PATTERNS = new String[] {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA1MDEzNg==", "bodyText": "You can just make the runner to be a test - otherwise this is going to be quite fragile.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552050136", "createdAt": "2021-01-05T16:38:08Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    private static class TestCase {\n+        private static final AtomicInteger COUNTER = new AtomicInteger(0);\n+        \n+        // timezones that are valid both in Java and in Postgres\n+        public static final List<String> POSTGRES_TEST_ZONE_LIST = List.of(\n+            // location-based and long-names\n+            \"US/Samoa\", \"Pacific/Honolulu\", \"Pacific/Marquesas\", \"Pacific/Gambier\", \"America/Juneau\", \"Canada/Yukon\", \"America/Vancouver\",\n+            \"Pacific/Easter\", \"US/Mountain\", \"America/Chicago\", \"US/Michigan\", \"Atlantic/Bermuda\", \"Canada/Newfoundland\",\n+            \"Atlantic/Cape_Verde\", \"Pacific/Kiritimati\", \"Pacific/Chatham\", \"Pacific/Auckland\", \"Asia/Sakhalin\", \"Australia/Tasmania\", \n+            \"Australia/North\", \"Asia/Tokyo\", \"Australia/Eucla\", \"Asia/Singapore\", \"Asia/Rangoon\", \"Indian/Chagos\", \"Asia/Calcutta\", \n+            \"Asia/Tashkent\", \"Asia/Tehran\", \"Asia/Dubai\", \"Africa/Nairobi\", \"Europe/Brussels\", \"Europe/Vienna\", \"Europe/London\", \n+            \"Etc/GMT+12\",\n+            // short names of zones\n+            \"GMT\", \"UTC\", \"CET\",\n+            // offsets\n+            \"+11:00\", \"+04:30\", \"+01:00\", \"+00:00\", \"-00:00\", \"-01:15\", \"-02:00\", \"-11:00\");\n+\n+        private final int id;\n+        private final BigDecimal secondsAndFractionsSinceEpoch;\n+        private final String formatString;\n+        private final String zoneId;\n+        \n+        TestCase(BigDecimal secondsAndFractionsSinceEpoch, String formatString) {\n+            this.id = COUNTER.incrementAndGet();\n+            this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+            this.formatString = formatString;\n+            this.zoneId = TestGenerator.randomFromCollection(POSTGRES_TEST_ZONE_LIST);\n+        }\n+\n+    }\n+\n+    /**\n+     * Generates an sql file that can be used to generate the test dataset for this unit test (to be used with the <code>psql</code> cli).\n+     *\n+     * Run the @{link {@link TestGenerator#main(String[])}} class and execute the following command to generate the output dataset with:\n+     *\n+     * <p>\n+     *  <code>\n+     *      # easy way to spin up the latest Postgres\n+     *      docker run --rm --name postgres-latest -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres:latest\n+     *\n+     *      # generate the csv for the unit test\n+     *      PGPASSWORD=\"mysecretpassword\" psql --quiet -h localhost -p 5432 -U postgres -f /tmp/postgresql-tochar-test.sql \\\n+     *          &gt; /path/to/tochar.csv\n+     *  </code>\n+     * </p>\n+     */\n+    private static class TestGenerator {\n+        \n+        private static final long SECONDS_IN_YEAR = 365 * 24 * 60 * 60L;\n+        private static final String DELIMITER = \"|\";\n+        private static final String PATTERN_DELIMITER = \" @ \";\n+        // these patterns are hard to sync up between PostgreSQL and Elasticsearch, so we just warn, but actually\n+        // accept the output of Elasticsearch as is\n+        private static final Set<String> NOT_FULLY_MATCHABLE_PATTERNS = Set.of(\"TZ\", \"tz\");\n+        private static final Set<String> UNSUPPORTED_PATTERN_MODIFIERS = Set.of(\"FX\", \"TM\", \"SP\");\n+        private static final String[] PATTERNS = new String[] {\n+            \"HH\", \"HH12\", \"HH24\", \"MI\", \"SS\", \"MS\", \"US\", \"FF1\", \"FF2\", \"FF3\", \"FF4\", \"FF5\", \"FF6\", \"SSSS\", \"SSSSS\", \"AM\", \"am\", \"PM\",\n+            \"pm\", \"A.M.\", \"a.m.\", \"P.M.\", \"p.m.\", \"Y,YYY\", \"YYYY\", \"YYY\", \"YY\", \"Y\", \"IYYY\", \"IYY\", \"IY\", \"I\", \"BC\", \"bc\", \"AD\", \"ad\",\n+            \"B.C.\", \"b.c.\", \"A.D.\", \"a.d.\", \"MONTH\", \"Month\", \"month\", \"MON\", \"Mon\", \"mon\", \"MM\", \"DAY\", \"Day\", \"day\", \"DY\", \"Dy\",\n+            \"dy\", \"DDD\", \"IDDD\", \"DD\", \"D\", \"ID\", \"W\", \"WW\", \"IW\", \"CC\", \"J\", \"Q\", \"RM\", \"rm\", \"TZ\", \"tz\", \"TZH\", \"TZM\", \"OF\"\n+        };\n+        private static final List<String> FILL_MODIFIERS = List.of(\"FM\", \"fm\", \"\");\n+        private static final List<String> ORDINAL_SUFFIX_MODIFIERS = List.of(\"TH\", \"th\", \"\");\n+\n+        @SuppressForbidden(reason = \"It is ok to use ThreadLocalRandom outside of an actual test\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA1MDg3Nw==", "bodyText": "What the reason for this values? 50, 5, -1200?", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552050877", "createdAt": "2021-01-05T16:39:14Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    private static class TestCase {\n+        private static final AtomicInteger COUNTER = new AtomicInteger(0);\n+        \n+        // timezones that are valid both in Java and in Postgres\n+        public static final List<String> POSTGRES_TEST_ZONE_LIST = List.of(\n+            // location-based and long-names\n+            \"US/Samoa\", \"Pacific/Honolulu\", \"Pacific/Marquesas\", \"Pacific/Gambier\", \"America/Juneau\", \"Canada/Yukon\", \"America/Vancouver\",\n+            \"Pacific/Easter\", \"US/Mountain\", \"America/Chicago\", \"US/Michigan\", \"Atlantic/Bermuda\", \"Canada/Newfoundland\",\n+            \"Atlantic/Cape_Verde\", \"Pacific/Kiritimati\", \"Pacific/Chatham\", \"Pacific/Auckland\", \"Asia/Sakhalin\", \"Australia/Tasmania\", \n+            \"Australia/North\", \"Asia/Tokyo\", \"Australia/Eucla\", \"Asia/Singapore\", \"Asia/Rangoon\", \"Indian/Chagos\", \"Asia/Calcutta\", \n+            \"Asia/Tashkent\", \"Asia/Tehran\", \"Asia/Dubai\", \"Africa/Nairobi\", \"Europe/Brussels\", \"Europe/Vienna\", \"Europe/London\", \n+            \"Etc/GMT+12\",\n+            // short names of zones\n+            \"GMT\", \"UTC\", \"CET\",\n+            // offsets\n+            \"+11:00\", \"+04:30\", \"+01:00\", \"+00:00\", \"-00:00\", \"-01:15\", \"-02:00\", \"-11:00\");\n+\n+        private final int id;\n+        private final BigDecimal secondsAndFractionsSinceEpoch;\n+        private final String formatString;\n+        private final String zoneId;\n+        \n+        TestCase(BigDecimal secondsAndFractionsSinceEpoch, String formatString) {\n+            this.id = COUNTER.incrementAndGet();\n+            this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+            this.formatString = formatString;\n+            this.zoneId = TestGenerator.randomFromCollection(POSTGRES_TEST_ZONE_LIST);\n+        }\n+\n+    }\n+\n+    /**\n+     * Generates an sql file that can be used to generate the test dataset for this unit test (to be used with the <code>psql</code> cli).\n+     *\n+     * Run the @{link {@link TestGenerator#main(String[])}} class and execute the following command to generate the output dataset with:\n+     *\n+     * <p>\n+     *  <code>\n+     *      # easy way to spin up the latest Postgres\n+     *      docker run --rm --name postgres-latest -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres:latest\n+     *\n+     *      # generate the csv for the unit test\n+     *      PGPASSWORD=\"mysecretpassword\" psql --quiet -h localhost -p 5432 -U postgres -f /tmp/postgresql-tochar-test.sql \\\n+     *          &gt; /path/to/tochar.csv\n+     *  </code>\n+     * </p>\n+     */\n+    private static class TestGenerator {\n+        \n+        private static final long SECONDS_IN_YEAR = 365 * 24 * 60 * 60L;\n+        private static final String DELIMITER = \"|\";\n+        private static final String PATTERN_DELIMITER = \" @ \";\n+        // these patterns are hard to sync up between PostgreSQL and Elasticsearch, so we just warn, but actually\n+        // accept the output of Elasticsearch as is\n+        private static final Set<String> NOT_FULLY_MATCHABLE_PATTERNS = Set.of(\"TZ\", \"tz\");\n+        private static final Set<String> UNSUPPORTED_PATTERN_MODIFIERS = Set.of(\"FX\", \"TM\", \"SP\");\n+        private static final String[] PATTERNS = new String[] {\n+            \"HH\", \"HH12\", \"HH24\", \"MI\", \"SS\", \"MS\", \"US\", \"FF1\", \"FF2\", \"FF3\", \"FF4\", \"FF5\", \"FF6\", \"SSSS\", \"SSSSS\", \"AM\", \"am\", \"PM\",\n+            \"pm\", \"A.M.\", \"a.m.\", \"P.M.\", \"p.m.\", \"Y,YYY\", \"YYYY\", \"YYY\", \"YY\", \"Y\", \"IYYY\", \"IYY\", \"IY\", \"I\", \"BC\", \"bc\", \"AD\", \"ad\",\n+            \"B.C.\", \"b.c.\", \"A.D.\", \"a.d.\", \"MONTH\", \"Month\", \"month\", \"MON\", \"Mon\", \"mon\", \"MM\", \"DAY\", \"Day\", \"day\", \"DY\", \"Dy\",\n+            \"dy\", \"DDD\", \"IDDD\", \"DD\", \"D\", \"ID\", \"W\", \"WW\", \"IW\", \"CC\", \"J\", \"Q\", \"RM\", \"rm\", \"TZ\", \"tz\", \"TZH\", \"TZM\", \"OF\"\n+        };\n+        private static final List<String> FILL_MODIFIERS = List.of(\"FM\", \"fm\", \"\");\n+        private static final List<String> ORDINAL_SUFFIX_MODIFIERS = List.of(\"TH\", \"th\", \"\");\n+\n+        @SuppressForbidden(reason = \"It is ok to use ThreadLocalRandom outside of an actual test\")\n+        private static Random rnd() {\n+            return ThreadLocalRandom.current();\n+        }\n+\n+        private static BigDecimal randomSecondsWithFractions(int minYear, int maxYear) {\n+            BigDecimal seconds = new BigDecimal(RandomNumbers.randomLongBetween(rnd(), \n+                (minYear - 1970) * SECONDS_IN_YEAR, (maxYear - 1970) * SECONDS_IN_YEAR));\n+            BigDecimal fractions = new BigDecimal(RandomNumbers.randomIntBetween(rnd(), 0, 999_999)).movePointLeft(6);\n+            return seconds.add(fractions);\n+        }\n+\n+        private static <T> T randomFromCollection(Collection<T> list) {\n+            List<T> l = new ArrayList<>(list);\n+            return l.get(rnd().nextInt(l.size()));\n+        }\n+        \n+        private static String patternWithRandomModifiers(String pattern) {\n+            if (NOT_FULLY_MATCHABLE_PATTERNS.contains(pattern)) {\n+                return pattern;\n+            }\n+            return randomFromCollection(FILL_MODIFIERS) + pattern + randomFromCollection(ORDINAL_SUFFIX_MODIFIERS);\n+        }\n+    \n+        private static List<TestCase> generateTestCases() {\n+            \n+            final List<BigDecimal> testEpochSeconds = new LinkedList<>();\n+            for (int i = 0; i < 50; i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA1NDA4OA==", "bodyText": "Alignment is off", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552054088", "createdAt": "2021-01-05T16:44:47Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    private static class TestCase {\n+        private static final AtomicInteger COUNTER = new AtomicInteger(0);\n+        \n+        // timezones that are valid both in Java and in Postgres\n+        public static final List<String> POSTGRES_TEST_ZONE_LIST = List.of(\n+            // location-based and long-names\n+            \"US/Samoa\", \"Pacific/Honolulu\", \"Pacific/Marquesas\", \"Pacific/Gambier\", \"America/Juneau\", \"Canada/Yukon\", \"America/Vancouver\",\n+            \"Pacific/Easter\", \"US/Mountain\", \"America/Chicago\", \"US/Michigan\", \"Atlantic/Bermuda\", \"Canada/Newfoundland\",\n+            \"Atlantic/Cape_Verde\", \"Pacific/Kiritimati\", \"Pacific/Chatham\", \"Pacific/Auckland\", \"Asia/Sakhalin\", \"Australia/Tasmania\", \n+            \"Australia/North\", \"Asia/Tokyo\", \"Australia/Eucla\", \"Asia/Singapore\", \"Asia/Rangoon\", \"Indian/Chagos\", \"Asia/Calcutta\", \n+            \"Asia/Tashkent\", \"Asia/Tehran\", \"Asia/Dubai\", \"Africa/Nairobi\", \"Europe/Brussels\", \"Europe/Vienna\", \"Europe/London\", \n+            \"Etc/GMT+12\",\n+            // short names of zones\n+            \"GMT\", \"UTC\", \"CET\",\n+            // offsets\n+            \"+11:00\", \"+04:30\", \"+01:00\", \"+00:00\", \"-00:00\", \"-01:15\", \"-02:00\", \"-11:00\");\n+\n+        private final int id;\n+        private final BigDecimal secondsAndFractionsSinceEpoch;\n+        private final String formatString;\n+        private final String zoneId;\n+        \n+        TestCase(BigDecimal secondsAndFractionsSinceEpoch, String formatString) {\n+            this.id = COUNTER.incrementAndGet();\n+            this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+            this.formatString = formatString;\n+            this.zoneId = TestGenerator.randomFromCollection(POSTGRES_TEST_ZONE_LIST);\n+        }\n+\n+    }\n+\n+    /**\n+     * Generates an sql file that can be used to generate the test dataset for this unit test (to be used with the <code>psql</code> cli).\n+     *\n+     * Run the @{link {@link TestGenerator#main(String[])}} class and execute the following command to generate the output dataset with:\n+     *\n+     * <p>\n+     *  <code>\n+     *      # easy way to spin up the latest Postgres\n+     *      docker run --rm --name postgres-latest -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres:latest\n+     *\n+     *      # generate the csv for the unit test\n+     *      PGPASSWORD=\"mysecretpassword\" psql --quiet -h localhost -p 5432 -U postgres -f /tmp/postgresql-tochar-test.sql \\\n+     *          &gt; /path/to/tochar.csv\n+     *  </code>\n+     * </p>\n+     */\n+    private static class TestGenerator {\n+        \n+        private static final long SECONDS_IN_YEAR = 365 * 24 * 60 * 60L;\n+        private static final String DELIMITER = \"|\";\n+        private static final String PATTERN_DELIMITER = \" @ \";\n+        // these patterns are hard to sync up between PostgreSQL and Elasticsearch, so we just warn, but actually\n+        // accept the output of Elasticsearch as is\n+        private static final Set<String> NOT_FULLY_MATCHABLE_PATTERNS = Set.of(\"TZ\", \"tz\");\n+        private static final Set<String> UNSUPPORTED_PATTERN_MODIFIERS = Set.of(\"FX\", \"TM\", \"SP\");\n+        private static final String[] PATTERNS = new String[] {\n+            \"HH\", \"HH12\", \"HH24\", \"MI\", \"SS\", \"MS\", \"US\", \"FF1\", \"FF2\", \"FF3\", \"FF4\", \"FF5\", \"FF6\", \"SSSS\", \"SSSSS\", \"AM\", \"am\", \"PM\",\n+            \"pm\", \"A.M.\", \"a.m.\", \"P.M.\", \"p.m.\", \"Y,YYY\", \"YYYY\", \"YYY\", \"YY\", \"Y\", \"IYYY\", \"IYY\", \"IY\", \"I\", \"BC\", \"bc\", \"AD\", \"ad\",\n+            \"B.C.\", \"b.c.\", \"A.D.\", \"a.d.\", \"MONTH\", \"Month\", \"month\", \"MON\", \"Mon\", \"mon\", \"MM\", \"DAY\", \"Day\", \"day\", \"DY\", \"Dy\",\n+            \"dy\", \"DDD\", \"IDDD\", \"DD\", \"D\", \"ID\", \"W\", \"WW\", \"IW\", \"CC\", \"J\", \"Q\", \"RM\", \"rm\", \"TZ\", \"tz\", \"TZH\", \"TZM\", \"OF\"\n+        };\n+        private static final List<String> FILL_MODIFIERS = List.of(\"FM\", \"fm\", \"\");\n+        private static final List<String> ORDINAL_SUFFIX_MODIFIERS = List.of(\"TH\", \"th\", \"\");\n+\n+        @SuppressForbidden(reason = \"It is ok to use ThreadLocalRandom outside of an actual test\")\n+        private static Random rnd() {\n+            return ThreadLocalRandom.current();\n+        }\n+\n+        private static BigDecimal randomSecondsWithFractions(int minYear, int maxYear) {\n+            BigDecimal seconds = new BigDecimal(RandomNumbers.randomLongBetween(rnd(), \n+                (minYear - 1970) * SECONDS_IN_YEAR, (maxYear - 1970) * SECONDS_IN_YEAR));\n+            BigDecimal fractions = new BigDecimal(RandomNumbers.randomIntBetween(rnd(), 0, 999_999)).movePointLeft(6);\n+            return seconds.add(fractions);\n+        }\n+\n+        private static <T> T randomFromCollection(Collection<T> list) {\n+            List<T> l = new ArrayList<>(list);\n+            return l.get(rnd().nextInt(l.size()));\n+        }\n+        \n+        private static String patternWithRandomModifiers(String pattern) {\n+            if (NOT_FULLY_MATCHABLE_PATTERNS.contains(pattern)) {\n+                return pattern;\n+            }\n+            return randomFromCollection(FILL_MODIFIERS) + pattern + randomFromCollection(ORDINAL_SUFFIX_MODIFIERS);\n+        }\n+    \n+        private static List<TestCase> generateTestCases() {\n+            \n+            final List<BigDecimal> testEpochSeconds = new LinkedList<>();\n+            for (int i = 0; i < 50; i++) {\n+                testEpochSeconds.add(randomSecondsWithFractions(-1200, 2500));\n+            }\n+            for (int i = 0; i < 5; i++) {\n+                testEpochSeconds.add(randomSecondsWithFractions(-1, 1));\n+            }\n+    \n+            List<TestCase> testCases = new ArrayList<>();\n+    \n+            // check each format string alone\n+            for (String pattern : PATTERNS) {\n+                testCases.add(new TestCase(randomFromCollection(testEpochSeconds), NOT_FULLY_MATCHABLE_PATTERNS.contains(pattern) \n+                    ? pattern \n+                    : String.join(PATTERN_DELIMITER, pattern, FILL_MODIFIERS.get(0) + pattern + ORDINAL_SUFFIX_MODIFIERS.get(0))));\n+            }\n+            \n+            // let's check all of the format strings with a non-ambiguous format string\n+            for (BigDecimal es : testEpochSeconds) {\n+                testCases.add(new TestCase(es, IntStream.range(0, PATTERNS.length)\n+                    .mapToObj(idx -> idx + \":\" + patternWithRandomModifiers(PATTERNS[idx]))\n+                    .collect(Collectors.joining(PATTERN_DELIMITER))));\n+            }\n+    \n+            // check the lowercase versions of the format strings\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), IntStream.range(0, PATTERNS.length)\n+                .mapToObj(idx -> (idx + \":\" + patternWithRandomModifiers(PATTERNS[idx])).toLowerCase(Locale.ROOT))\n+                .collect(Collectors.joining(PATTERN_DELIMITER))));\n+    \n+            // potentially ambiguous format string test cases, to check if our format string parsing is in-sync with PostgreSQL\n+            // greedy and prefers the longer format strings\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"YYYYYYYYYYYYYYY,YYYYYYYYY\"));\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"SSSSSSSSSSSSSSSS\"));\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"DDDDDDDD\"));\n+    \n+            // Roman numbers\n+            for (int i = 1; i <= 12; i++) {\n+                testCases.add(new TestCase(\n+                    new BigDecimal(dateTime(0).withMonth(i).toEpochSecond()), rnd().nextBoolean() ? \"RM\" : \"rm\"));\n+            }\n+            \n+            // random strings made out of template patterns and random characters\n+            final String randomCharacters = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYabcdefghijklmnopqrstuvwxy _-.:;\";\n+            final List<String> formatStringsToRandomTest = Arrays.stream(PATTERNS)\n+                .filter(s -> NOT_FULLY_MATCHABLE_PATTERNS.contains(s) == false)\n+                .collect(Collectors.toList());\n+            \n+            for (int i = 0; i < 20; i++) {\n+                String patternWithLiterals = IntStream.rangeClosed(1, 30).mapToObj(idx -> \n+                    rnd().nextInt(100) < 80 \n+                        ? randomCharacters.substring(rnd().nextInt(randomCharacters.length())).substring(0, 1) \n+                        : (randomFromCollection(FILL_MODIFIERS) \n+                            + randomFromCollection(formatStringsToRandomTest) \n+                            + randomFromCollection(ORDINAL_SUFFIX_MODIFIERS)))\n+                    .collect(Collectors.joining());\n+                \n+                // clean up the random string from the unsupported modifiers\n+                for (String unsupportedPatternModifier : UNSUPPORTED_PATTERN_MODIFIERS) {\n+                    patternWithLiterals = patternWithLiterals\n+                        .replace(unsupportedPatternModifier, \"\")\n+                        .replace(unsupportedPatternModifier.toLowerCase(Locale.ROOT), \"\");\n+                }\n+                testCases.add(new TestCase(randomFromCollection(testEpochSeconds), patternWithLiterals));\n+            }\n+    \n+            return testCases;\n+        }\n+        \n+        private static String adjustZoneIdToPostgres(String zoneId) {\n+            // when the zone is specified by the offset in Postgres, it follows the POSIX definition, so the +- signs are flipped\n+            // compared to ISO-8601, see more info at: https://www.postgresql.org/docs/current/datetime-posix-timezone-specs.html\n+            if (zoneId.startsWith(\"+\")) {\n+                zoneId = zoneId.replaceFirst(quote(\"+\"), \"-\");\n+            } else if (zoneId.startsWith(\"-\")) {\n+                zoneId = zoneId.replaceFirst(quote(\"-\"), \"+\");\n+            }\n+            return zoneId;\n+        }\n+        \n+        /**\n+         * Generates an SQL file that can be used to create the test dataset for the unit test of the <code>TO_CHAR</code>\n+         * implementation. In case the <code>TO_CHAR</code> implementation needs an upgrade, add the list of the new format\n+         * strings to the list of the format string, regenerate the SQL, run it against the PostgreSQL version you are targeting\n+         * and update the test CSV file.\n+         */\n+        private static String unitTestExporterScript() {\n+            return generateTestCases().stream().map(tc -> {\n+                long seconds = tc.secondsAndFractionsSinceEpoch.longValue();\n+                BigDecimal fractions = tc.secondsAndFractionsSinceEpoch.remainder(BigDecimal.ONE).movePointRight(6);\n+                return String.format(Locale.ROOT,\n+                    \"SET TIME ZONE '%7$s';\\n\" +\n+                    \"\\\\copy (SELECT %1$d as id, %2$s as epoch_seconds_and_microsends, '%6$s' as zone_id, '%5$s' as format_string, \" +\n+                        \"(TO_TIMESTAMP(%3$d) + INTERVAL '%4$d microseconds') as to_timestamp_result, \" +\n+                        \"TO_CHAR((TO_TIMESTAMP(%3$d) + INTERVAL '%4$d microseconds'), '%5$s') as to_char_result) to stdout \" +\n+                        \"with DELIMITER as '\" + DELIMITER + \"' NULL as '' csv \\n\",\n+                    tc.id, tc.secondsAndFractionsSinceEpoch.toPlainString(), seconds, fractions.intValue(), tc.formatString, tc.zoneId, \n+                    adjustZoneIdToPostgres(tc.zoneId)\n+                );\n+            }).collect(Collectors.joining(\"\\n\"));\n+        }\n+        \n+        public static void main(String[] args) throws Exception {\n+            String scriptFilename = args.length < 1 ? \"/tmp/postgresql-tochar-test.sql\" : args[0];\n+            Files.writeString(Path.of(scriptFilename), unitTestExporterScript(), StandardCharsets.UTF_8);\n+        }\n+    }\n+\n+    @ParametersFactory(argumentFormatting = \"%1$s: timestamp=%5$s, zone=%3$s, format=%4$s\")\n+    public static List<Object[]> readCsv() throws Exception {\n+        Path testFilePath = Path.of(DateTimeToCharProcessorTests.class.getResource(\"tochar.csv\").toURI());\n+        return Files.readAllLines(testFilePath).stream().map(line -> {\n+            String[] cols = line.split(quote(TestGenerator.DELIMITER));\n+            return new Object[]{ cols[0], cols[1], cols[2], cols[3], cols[4], cols[5] };\n+        }).collect(Collectors.toList());\n+    }\n+\n+    private final String id;\n+    private final String secondsAndFractionsSinceEpoch;\n+    private final String zone;\n+    private final String formatString;\n+    private final String posgresTimestamp;\n+    private final String expectedResult;\n+\n+    public DateTimeToCharProcessorTests(String id, String secondsAndFractionsSinceEpoch, String zone, String formatString,\n+        String postgresTimestamp, String expectedResult) {\n+        this.id = id;\n+        this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+        this.zone = zone;\n+        this.formatString = formatString;\n+        this.posgresTimestamp = postgresTimestamp;\n+        this.expectedResult = expectedResult;\n+    }\n+\n+    private static ZonedDateTime dateTimeWithFractions(String secondAndFractionsSinceEpoch) {\n+        BigDecimal b = new BigDecimal(secondAndFractionsSinceEpoch);\n+        long seconds = b.longValue();\n+        int fractions = b.remainder(BigDecimal.ONE).movePointRight(9).intValueExact();\n+        int adjustment = 0;\n+        if (fractions < 0) {\n+            fractions += 1e9;\n+            adjustment = -1;\n+        }\n+        return dateTime((seconds + adjustment) * 1000).withNano(fractions);\n+    }\n+    \n+    public void test() throws Exception {\n+        ZoneId zoneId = ZoneId.of(zone);\n+        ZonedDateTime timestamp = dateTimeWithFractions(secondsAndFractionsSinceEpoch);\n+        String actualResult =\n+            (String) new ToChar(Source.EMPTY, l(timestamp, DataTypes.DATETIME), l(formatString, DataTypes.KEYWORD), zoneId)\n+                .makePipe()\n+                .asProcessor()\n+                .process(null);\n+        List<String> expectedResultSplitted = List.of(expectedResult.split(quote(TestGenerator.PATTERN_DELIMITER)));\n+        List<String> resultSplitted = List.of(actualResult.split(quote(TestGenerator.PATTERN_DELIMITER)));\n+        List<String> formatStringSplitted = List.of(formatString.split(TestGenerator.PATTERN_DELIMITER));\n+        assertEquals(formatStringSplitted.size(), resultSplitted.size());\n+        assertEquals(formatStringSplitted.size(), expectedResultSplitted.size());\n+        for (int i = 0; i < formatStringSplitted.size(); i++) {\n+            String patternMaybeWithIndex = formatStringSplitted.get(i);\n+            String pattern = patternMaybeWithIndex.contains(\":\") \n+                ? patternMaybeWithIndex.substring(patternMaybeWithIndex.indexOf(\":\") + 1)\n+                : patternMaybeWithIndex;\n+            String expectedPart = expectedResultSplitted.get(i);\n+            String actualPart = resultSplitted.get(i);\n+            try {\n+                assertEquals(\n+                    String.format(Locale.ROOT, \n+                        \"\\nTest id:                            %s\\n\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 300}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA1NDI4MQ==", "bodyText": "Use assume instead of catching the error. Further more why not check for this pattern before generating the test cases?", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552054281", "createdAt": "2021-01-05T16:45:06Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    private static class TestCase {\n+        private static final AtomicInteger COUNTER = new AtomicInteger(0);\n+        \n+        // timezones that are valid both in Java and in Postgres\n+        public static final List<String> POSTGRES_TEST_ZONE_LIST = List.of(\n+            // location-based and long-names\n+            \"US/Samoa\", \"Pacific/Honolulu\", \"Pacific/Marquesas\", \"Pacific/Gambier\", \"America/Juneau\", \"Canada/Yukon\", \"America/Vancouver\",\n+            \"Pacific/Easter\", \"US/Mountain\", \"America/Chicago\", \"US/Michigan\", \"Atlantic/Bermuda\", \"Canada/Newfoundland\",\n+            \"Atlantic/Cape_Verde\", \"Pacific/Kiritimati\", \"Pacific/Chatham\", \"Pacific/Auckland\", \"Asia/Sakhalin\", \"Australia/Tasmania\", \n+            \"Australia/North\", \"Asia/Tokyo\", \"Australia/Eucla\", \"Asia/Singapore\", \"Asia/Rangoon\", \"Indian/Chagos\", \"Asia/Calcutta\", \n+            \"Asia/Tashkent\", \"Asia/Tehran\", \"Asia/Dubai\", \"Africa/Nairobi\", \"Europe/Brussels\", \"Europe/Vienna\", \"Europe/London\", \n+            \"Etc/GMT+12\",\n+            // short names of zones\n+            \"GMT\", \"UTC\", \"CET\",\n+            // offsets\n+            \"+11:00\", \"+04:30\", \"+01:00\", \"+00:00\", \"-00:00\", \"-01:15\", \"-02:00\", \"-11:00\");\n+\n+        private final int id;\n+        private final BigDecimal secondsAndFractionsSinceEpoch;\n+        private final String formatString;\n+        private final String zoneId;\n+        \n+        TestCase(BigDecimal secondsAndFractionsSinceEpoch, String formatString) {\n+            this.id = COUNTER.incrementAndGet();\n+            this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+            this.formatString = formatString;\n+            this.zoneId = TestGenerator.randomFromCollection(POSTGRES_TEST_ZONE_LIST);\n+        }\n+\n+    }\n+\n+    /**\n+     * Generates an sql file that can be used to generate the test dataset for this unit test (to be used with the <code>psql</code> cli).\n+     *\n+     * Run the @{link {@link TestGenerator#main(String[])}} class and execute the following command to generate the output dataset with:\n+     *\n+     * <p>\n+     *  <code>\n+     *      # easy way to spin up the latest Postgres\n+     *      docker run --rm --name postgres-latest -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres:latest\n+     *\n+     *      # generate the csv for the unit test\n+     *      PGPASSWORD=\"mysecretpassword\" psql --quiet -h localhost -p 5432 -U postgres -f /tmp/postgresql-tochar-test.sql \\\n+     *          &gt; /path/to/tochar.csv\n+     *  </code>\n+     * </p>\n+     */\n+    private static class TestGenerator {\n+        \n+        private static final long SECONDS_IN_YEAR = 365 * 24 * 60 * 60L;\n+        private static final String DELIMITER = \"|\";\n+        private static final String PATTERN_DELIMITER = \" @ \";\n+        // these patterns are hard to sync up between PostgreSQL and Elasticsearch, so we just warn, but actually\n+        // accept the output of Elasticsearch as is\n+        private static final Set<String> NOT_FULLY_MATCHABLE_PATTERNS = Set.of(\"TZ\", \"tz\");\n+        private static final Set<String> UNSUPPORTED_PATTERN_MODIFIERS = Set.of(\"FX\", \"TM\", \"SP\");\n+        private static final String[] PATTERNS = new String[] {\n+            \"HH\", \"HH12\", \"HH24\", \"MI\", \"SS\", \"MS\", \"US\", \"FF1\", \"FF2\", \"FF3\", \"FF4\", \"FF5\", \"FF6\", \"SSSS\", \"SSSSS\", \"AM\", \"am\", \"PM\",\n+            \"pm\", \"A.M.\", \"a.m.\", \"P.M.\", \"p.m.\", \"Y,YYY\", \"YYYY\", \"YYY\", \"YY\", \"Y\", \"IYYY\", \"IYY\", \"IY\", \"I\", \"BC\", \"bc\", \"AD\", \"ad\",\n+            \"B.C.\", \"b.c.\", \"A.D.\", \"a.d.\", \"MONTH\", \"Month\", \"month\", \"MON\", \"Mon\", \"mon\", \"MM\", \"DAY\", \"Day\", \"day\", \"DY\", \"Dy\",\n+            \"dy\", \"DDD\", \"IDDD\", \"DD\", \"D\", \"ID\", \"W\", \"WW\", \"IW\", \"CC\", \"J\", \"Q\", \"RM\", \"rm\", \"TZ\", \"tz\", \"TZH\", \"TZM\", \"OF\"\n+        };\n+        private static final List<String> FILL_MODIFIERS = List.of(\"FM\", \"fm\", \"\");\n+        private static final List<String> ORDINAL_SUFFIX_MODIFIERS = List.of(\"TH\", \"th\", \"\");\n+\n+        @SuppressForbidden(reason = \"It is ok to use ThreadLocalRandom outside of an actual test\")\n+        private static Random rnd() {\n+            return ThreadLocalRandom.current();\n+        }\n+\n+        private static BigDecimal randomSecondsWithFractions(int minYear, int maxYear) {\n+            BigDecimal seconds = new BigDecimal(RandomNumbers.randomLongBetween(rnd(), \n+                (minYear - 1970) * SECONDS_IN_YEAR, (maxYear - 1970) * SECONDS_IN_YEAR));\n+            BigDecimal fractions = new BigDecimal(RandomNumbers.randomIntBetween(rnd(), 0, 999_999)).movePointLeft(6);\n+            return seconds.add(fractions);\n+        }\n+\n+        private static <T> T randomFromCollection(Collection<T> list) {\n+            List<T> l = new ArrayList<>(list);\n+            return l.get(rnd().nextInt(l.size()));\n+        }\n+        \n+        private static String patternWithRandomModifiers(String pattern) {\n+            if (NOT_FULLY_MATCHABLE_PATTERNS.contains(pattern)) {\n+                return pattern;\n+            }\n+            return randomFromCollection(FILL_MODIFIERS) + pattern + randomFromCollection(ORDINAL_SUFFIX_MODIFIERS);\n+        }\n+    \n+        private static List<TestCase> generateTestCases() {\n+            \n+            final List<BigDecimal> testEpochSeconds = new LinkedList<>();\n+            for (int i = 0; i < 50; i++) {\n+                testEpochSeconds.add(randomSecondsWithFractions(-1200, 2500));\n+            }\n+            for (int i = 0; i < 5; i++) {\n+                testEpochSeconds.add(randomSecondsWithFractions(-1, 1));\n+            }\n+    \n+            List<TestCase> testCases = new ArrayList<>();\n+    \n+            // check each format string alone\n+            for (String pattern : PATTERNS) {\n+                testCases.add(new TestCase(randomFromCollection(testEpochSeconds), NOT_FULLY_MATCHABLE_PATTERNS.contains(pattern) \n+                    ? pattern \n+                    : String.join(PATTERN_DELIMITER, pattern, FILL_MODIFIERS.get(0) + pattern + ORDINAL_SUFFIX_MODIFIERS.get(0))));\n+            }\n+            \n+            // let's check all of the format strings with a non-ambiguous format string\n+            for (BigDecimal es : testEpochSeconds) {\n+                testCases.add(new TestCase(es, IntStream.range(0, PATTERNS.length)\n+                    .mapToObj(idx -> idx + \":\" + patternWithRandomModifiers(PATTERNS[idx]))\n+                    .collect(Collectors.joining(PATTERN_DELIMITER))));\n+            }\n+    \n+            // check the lowercase versions of the format strings\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), IntStream.range(0, PATTERNS.length)\n+                .mapToObj(idx -> (idx + \":\" + patternWithRandomModifiers(PATTERNS[idx])).toLowerCase(Locale.ROOT))\n+                .collect(Collectors.joining(PATTERN_DELIMITER))));\n+    \n+            // potentially ambiguous format string test cases, to check if our format string parsing is in-sync with PostgreSQL\n+            // greedy and prefers the longer format strings\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"YYYYYYYYYYYYYYY,YYYYYYYYY\"));\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"SSSSSSSSSSSSSSSS\"));\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"DDDDDDDD\"));\n+    \n+            // Roman numbers\n+            for (int i = 1; i <= 12; i++) {\n+                testCases.add(new TestCase(\n+                    new BigDecimal(dateTime(0).withMonth(i).toEpochSecond()), rnd().nextBoolean() ? \"RM\" : \"rm\"));\n+            }\n+            \n+            // random strings made out of template patterns and random characters\n+            final String randomCharacters = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYabcdefghijklmnopqrstuvwxy _-.:;\";\n+            final List<String> formatStringsToRandomTest = Arrays.stream(PATTERNS)\n+                .filter(s -> NOT_FULLY_MATCHABLE_PATTERNS.contains(s) == false)\n+                .collect(Collectors.toList());\n+            \n+            for (int i = 0; i < 20; i++) {\n+                String patternWithLiterals = IntStream.rangeClosed(1, 30).mapToObj(idx -> \n+                    rnd().nextInt(100) < 80 \n+                        ? randomCharacters.substring(rnd().nextInt(randomCharacters.length())).substring(0, 1) \n+                        : (randomFromCollection(FILL_MODIFIERS) \n+                            + randomFromCollection(formatStringsToRandomTest) \n+                            + randomFromCollection(ORDINAL_SUFFIX_MODIFIERS)))\n+                    .collect(Collectors.joining());\n+                \n+                // clean up the random string from the unsupported modifiers\n+                for (String unsupportedPatternModifier : UNSUPPORTED_PATTERN_MODIFIERS) {\n+                    patternWithLiterals = patternWithLiterals\n+                        .replace(unsupportedPatternModifier, \"\")\n+                        .replace(unsupportedPatternModifier.toLowerCase(Locale.ROOT), \"\");\n+                }\n+                testCases.add(new TestCase(randomFromCollection(testEpochSeconds), patternWithLiterals));\n+            }\n+    \n+            return testCases;\n+        }\n+        \n+        private static String adjustZoneIdToPostgres(String zoneId) {\n+            // when the zone is specified by the offset in Postgres, it follows the POSIX definition, so the +- signs are flipped\n+            // compared to ISO-8601, see more info at: https://www.postgresql.org/docs/current/datetime-posix-timezone-specs.html\n+            if (zoneId.startsWith(\"+\")) {\n+                zoneId = zoneId.replaceFirst(quote(\"+\"), \"-\");\n+            } else if (zoneId.startsWith(\"-\")) {\n+                zoneId = zoneId.replaceFirst(quote(\"-\"), \"+\");\n+            }\n+            return zoneId;\n+        }\n+        \n+        /**\n+         * Generates an SQL file that can be used to create the test dataset for the unit test of the <code>TO_CHAR</code>\n+         * implementation. In case the <code>TO_CHAR</code> implementation needs an upgrade, add the list of the new format\n+         * strings to the list of the format string, regenerate the SQL, run it against the PostgreSQL version you are targeting\n+         * and update the test CSV file.\n+         */\n+        private static String unitTestExporterScript() {\n+            return generateTestCases().stream().map(tc -> {\n+                long seconds = tc.secondsAndFractionsSinceEpoch.longValue();\n+                BigDecimal fractions = tc.secondsAndFractionsSinceEpoch.remainder(BigDecimal.ONE).movePointRight(6);\n+                return String.format(Locale.ROOT,\n+                    \"SET TIME ZONE '%7$s';\\n\" +\n+                    \"\\\\copy (SELECT %1$d as id, %2$s as epoch_seconds_and_microsends, '%6$s' as zone_id, '%5$s' as format_string, \" +\n+                        \"(TO_TIMESTAMP(%3$d) + INTERVAL '%4$d microseconds') as to_timestamp_result, \" +\n+                        \"TO_CHAR((TO_TIMESTAMP(%3$d) + INTERVAL '%4$d microseconds'), '%5$s') as to_char_result) to stdout \" +\n+                        \"with DELIMITER as '\" + DELIMITER + \"' NULL as '' csv \\n\",\n+                    tc.id, tc.secondsAndFractionsSinceEpoch.toPlainString(), seconds, fractions.intValue(), tc.formatString, tc.zoneId, \n+                    adjustZoneIdToPostgres(tc.zoneId)\n+                );\n+            }).collect(Collectors.joining(\"\\n\"));\n+        }\n+        \n+        public static void main(String[] args) throws Exception {\n+            String scriptFilename = args.length < 1 ? \"/tmp/postgresql-tochar-test.sql\" : args[0];\n+            Files.writeString(Path.of(scriptFilename), unitTestExporterScript(), StandardCharsets.UTF_8);\n+        }\n+    }\n+\n+    @ParametersFactory(argumentFormatting = \"%1$s: timestamp=%5$s, zone=%3$s, format=%4$s\")\n+    public static List<Object[]> readCsv() throws Exception {\n+        Path testFilePath = Path.of(DateTimeToCharProcessorTests.class.getResource(\"tochar.csv\").toURI());\n+        return Files.readAllLines(testFilePath).stream().map(line -> {\n+            String[] cols = line.split(quote(TestGenerator.DELIMITER));\n+            return new Object[]{ cols[0], cols[1], cols[2], cols[3], cols[4], cols[5] };\n+        }).collect(Collectors.toList());\n+    }\n+\n+    private final String id;\n+    private final String secondsAndFractionsSinceEpoch;\n+    private final String zone;\n+    private final String formatString;\n+    private final String posgresTimestamp;\n+    private final String expectedResult;\n+\n+    public DateTimeToCharProcessorTests(String id, String secondsAndFractionsSinceEpoch, String zone, String formatString,\n+        String postgresTimestamp, String expectedResult) {\n+        this.id = id;\n+        this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+        this.zone = zone;\n+        this.formatString = formatString;\n+        this.posgresTimestamp = postgresTimestamp;\n+        this.expectedResult = expectedResult;\n+    }\n+\n+    private static ZonedDateTime dateTimeWithFractions(String secondAndFractionsSinceEpoch) {\n+        BigDecimal b = new BigDecimal(secondAndFractionsSinceEpoch);\n+        long seconds = b.longValue();\n+        int fractions = b.remainder(BigDecimal.ONE).movePointRight(9).intValueExact();\n+        int adjustment = 0;\n+        if (fractions < 0) {\n+            fractions += 1e9;\n+            adjustment = -1;\n+        }\n+        return dateTime((seconds + adjustment) * 1000).withNano(fractions);\n+    }\n+    \n+    public void test() throws Exception {\n+        ZoneId zoneId = ZoneId.of(zone);\n+        ZonedDateTime timestamp = dateTimeWithFractions(secondsAndFractionsSinceEpoch);\n+        String actualResult =\n+            (String) new ToChar(Source.EMPTY, l(timestamp, DataTypes.DATETIME), l(formatString, DataTypes.KEYWORD), zoneId)\n+                .makePipe()\n+                .asProcessor()\n+                .process(null);\n+        List<String> expectedResultSplitted = List.of(expectedResult.split(quote(TestGenerator.PATTERN_DELIMITER)));\n+        List<String> resultSplitted = List.of(actualResult.split(quote(TestGenerator.PATTERN_DELIMITER)));\n+        List<String> formatStringSplitted = List.of(formatString.split(TestGenerator.PATTERN_DELIMITER));\n+        assertEquals(formatStringSplitted.size(), resultSplitted.size());\n+        assertEquals(formatStringSplitted.size(), expectedResultSplitted.size());\n+        for (int i = 0; i < formatStringSplitted.size(); i++) {\n+            String patternMaybeWithIndex = formatStringSplitted.get(i);\n+            String pattern = patternMaybeWithIndex.contains(\":\") \n+                ? patternMaybeWithIndex.substring(patternMaybeWithIndex.indexOf(\":\") + 1)\n+                : patternMaybeWithIndex;\n+            String expectedPart = expectedResultSplitted.get(i);\n+            String actualPart = resultSplitted.get(i);\n+            try {\n+                assertEquals(\n+                    String.format(Locale.ROOT, \n+                        \"\\nTest id:                            %s\\n\" +\n+                        \"zone:                               %s\\n\" +\n+                        \"timestamp (as epoch):               %s\\n\" +\n+                        \"timestamp (java, UTC):              %s\\n\" +\n+                        \"timestamp (postgres, to_timestamp): %s\\n\" +\n+                        \"timestamp (java with zone):         %s\\n\" +\n+                        \"format string:                      %s\\n\" +\n+                        \"expected (postgres to_char result): %s\\n\" +\n+                        \"actual (ES to_char result):         %s\\n\" +\n+                        \"    FAILED (sub)pattern: %s,\",\n+                        id, zone, secondsAndFractionsSinceEpoch, timestamp, posgresTimestamp, timestamp.withZoneSameInstant(zoneId), \n+                        formatString, expectedResult, actualResult, patternMaybeWithIndex), \n+                    expectedPart, actualPart);\n+            } catch (AssertionError err) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 313}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA1NTMzMw==", "bodyText": "Arrays.asList()", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552055333", "createdAt": "2021-01-05T16:46:59Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    private static class TestCase {\n+        private static final AtomicInteger COUNTER = new AtomicInteger(0);\n+        \n+        // timezones that are valid both in Java and in Postgres\n+        public static final List<String> POSTGRES_TEST_ZONE_LIST = List.of(\n+            // location-based and long-names\n+            \"US/Samoa\", \"Pacific/Honolulu\", \"Pacific/Marquesas\", \"Pacific/Gambier\", \"America/Juneau\", \"Canada/Yukon\", \"America/Vancouver\",\n+            \"Pacific/Easter\", \"US/Mountain\", \"America/Chicago\", \"US/Michigan\", \"Atlantic/Bermuda\", \"Canada/Newfoundland\",\n+            \"Atlantic/Cape_Verde\", \"Pacific/Kiritimati\", \"Pacific/Chatham\", \"Pacific/Auckland\", \"Asia/Sakhalin\", \"Australia/Tasmania\", \n+            \"Australia/North\", \"Asia/Tokyo\", \"Australia/Eucla\", \"Asia/Singapore\", \"Asia/Rangoon\", \"Indian/Chagos\", \"Asia/Calcutta\", \n+            \"Asia/Tashkent\", \"Asia/Tehran\", \"Asia/Dubai\", \"Africa/Nairobi\", \"Europe/Brussels\", \"Europe/Vienna\", \"Europe/London\", \n+            \"Etc/GMT+12\",\n+            // short names of zones\n+            \"GMT\", \"UTC\", \"CET\",\n+            // offsets\n+            \"+11:00\", \"+04:30\", \"+01:00\", \"+00:00\", \"-00:00\", \"-01:15\", \"-02:00\", \"-11:00\");\n+\n+        private final int id;\n+        private final BigDecimal secondsAndFractionsSinceEpoch;\n+        private final String formatString;\n+        private final String zoneId;\n+        \n+        TestCase(BigDecimal secondsAndFractionsSinceEpoch, String formatString) {\n+            this.id = COUNTER.incrementAndGet();\n+            this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+            this.formatString = formatString;\n+            this.zoneId = TestGenerator.randomFromCollection(POSTGRES_TEST_ZONE_LIST);\n+        }\n+\n+    }\n+\n+    /**\n+     * Generates an sql file that can be used to generate the test dataset for this unit test (to be used with the <code>psql</code> cli).\n+     *\n+     * Run the @{link {@link TestGenerator#main(String[])}} class and execute the following command to generate the output dataset with:\n+     *\n+     * <p>\n+     *  <code>\n+     *      # easy way to spin up the latest Postgres\n+     *      docker run --rm --name postgres-latest -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres:latest\n+     *\n+     *      # generate the csv for the unit test\n+     *      PGPASSWORD=\"mysecretpassword\" psql --quiet -h localhost -p 5432 -U postgres -f /tmp/postgresql-tochar-test.sql \\\n+     *          &gt; /path/to/tochar.csv\n+     *  </code>\n+     * </p>\n+     */\n+    private static class TestGenerator {\n+        \n+        private static final long SECONDS_IN_YEAR = 365 * 24 * 60 * 60L;\n+        private static final String DELIMITER = \"|\";\n+        private static final String PATTERN_DELIMITER = \" @ \";\n+        // these patterns are hard to sync up between PostgreSQL and Elasticsearch, so we just warn, but actually\n+        // accept the output of Elasticsearch as is\n+        private static final Set<String> NOT_FULLY_MATCHABLE_PATTERNS = Set.of(\"TZ\", \"tz\");\n+        private static final Set<String> UNSUPPORTED_PATTERN_MODIFIERS = Set.of(\"FX\", \"TM\", \"SP\");\n+        private static final String[] PATTERNS = new String[] {\n+            \"HH\", \"HH12\", \"HH24\", \"MI\", \"SS\", \"MS\", \"US\", \"FF1\", \"FF2\", \"FF3\", \"FF4\", \"FF5\", \"FF6\", \"SSSS\", \"SSSSS\", \"AM\", \"am\", \"PM\",\n+            \"pm\", \"A.M.\", \"a.m.\", \"P.M.\", \"p.m.\", \"Y,YYY\", \"YYYY\", \"YYY\", \"YY\", \"Y\", \"IYYY\", \"IYY\", \"IY\", \"I\", \"BC\", \"bc\", \"AD\", \"ad\",\n+            \"B.C.\", \"b.c.\", \"A.D.\", \"a.d.\", \"MONTH\", \"Month\", \"month\", \"MON\", \"Mon\", \"mon\", \"MM\", \"DAY\", \"Day\", \"day\", \"DY\", \"Dy\",\n+            \"dy\", \"DDD\", \"IDDD\", \"DD\", \"D\", \"ID\", \"W\", \"WW\", \"IW\", \"CC\", \"J\", \"Q\", \"RM\", \"rm\", \"TZ\", \"tz\", \"TZH\", \"TZM\", \"OF\"\n+        };\n+        private static final List<String> FILL_MODIFIERS = List.of(\"FM\", \"fm\", \"\");\n+        private static final List<String> ORDINAL_SUFFIX_MODIFIERS = List.of(\"TH\", \"th\", \"\");\n+\n+        @SuppressForbidden(reason = \"It is ok to use ThreadLocalRandom outside of an actual test\")\n+        private static Random rnd() {\n+            return ThreadLocalRandom.current();\n+        }\n+\n+        private static BigDecimal randomSecondsWithFractions(int minYear, int maxYear) {\n+            BigDecimal seconds = new BigDecimal(RandomNumbers.randomLongBetween(rnd(), \n+                (minYear - 1970) * SECONDS_IN_YEAR, (maxYear - 1970) * SECONDS_IN_YEAR));\n+            BigDecimal fractions = new BigDecimal(RandomNumbers.randomIntBetween(rnd(), 0, 999_999)).movePointLeft(6);\n+            return seconds.add(fractions);\n+        }\n+\n+        private static <T> T randomFromCollection(Collection<T> list) {\n+            List<T> l = new ArrayList<>(list);\n+            return l.get(rnd().nextInt(l.size()));\n+        }\n+        \n+        private static String patternWithRandomModifiers(String pattern) {\n+            if (NOT_FULLY_MATCHABLE_PATTERNS.contains(pattern)) {\n+                return pattern;\n+            }\n+            return randomFromCollection(FILL_MODIFIERS) + pattern + randomFromCollection(ORDINAL_SUFFIX_MODIFIERS);\n+        }\n+    \n+        private static List<TestCase> generateTestCases() {\n+            \n+            final List<BigDecimal> testEpochSeconds = new LinkedList<>();\n+            for (int i = 0; i < 50; i++) {\n+                testEpochSeconds.add(randomSecondsWithFractions(-1200, 2500));\n+            }\n+            for (int i = 0; i < 5; i++) {\n+                testEpochSeconds.add(randomSecondsWithFractions(-1, 1));\n+            }\n+    \n+            List<TestCase> testCases = new ArrayList<>();\n+    \n+            // check each format string alone\n+            for (String pattern : PATTERNS) {\n+                testCases.add(new TestCase(randomFromCollection(testEpochSeconds), NOT_FULLY_MATCHABLE_PATTERNS.contains(pattern) \n+                    ? pattern \n+                    : String.join(PATTERN_DELIMITER, pattern, FILL_MODIFIERS.get(0) + pattern + ORDINAL_SUFFIX_MODIFIERS.get(0))));\n+            }\n+            \n+            // let's check all of the format strings with a non-ambiguous format string\n+            for (BigDecimal es : testEpochSeconds) {\n+                testCases.add(new TestCase(es, IntStream.range(0, PATTERNS.length)\n+                    .mapToObj(idx -> idx + \":\" + patternWithRandomModifiers(PATTERNS[idx]))\n+                    .collect(Collectors.joining(PATTERN_DELIMITER))));\n+            }\n+    \n+            // check the lowercase versions of the format strings\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), IntStream.range(0, PATTERNS.length)\n+                .mapToObj(idx -> (idx + \":\" + patternWithRandomModifiers(PATTERNS[idx])).toLowerCase(Locale.ROOT))\n+                .collect(Collectors.joining(PATTERN_DELIMITER))));\n+    \n+            // potentially ambiguous format string test cases, to check if our format string parsing is in-sync with PostgreSQL\n+            // greedy and prefers the longer format strings\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"YYYYYYYYYYYYYYY,YYYYYYYYY\"));\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"SSSSSSSSSSSSSSSS\"));\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"DDDDDDDD\"));\n+    \n+            // Roman numbers\n+            for (int i = 1; i <= 12; i++) {\n+                testCases.add(new TestCase(\n+                    new BigDecimal(dateTime(0).withMonth(i).toEpochSecond()), rnd().nextBoolean() ? \"RM\" : \"rm\"));\n+            }\n+            \n+            // random strings made out of template patterns and random characters\n+            final String randomCharacters = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYabcdefghijklmnopqrstuvwxy _-.:;\";\n+            final List<String> formatStringsToRandomTest = Arrays.stream(PATTERNS)\n+                .filter(s -> NOT_FULLY_MATCHABLE_PATTERNS.contains(s) == false)\n+                .collect(Collectors.toList());\n+            \n+            for (int i = 0; i < 20; i++) {\n+                String patternWithLiterals = IntStream.rangeClosed(1, 30).mapToObj(idx -> \n+                    rnd().nextInt(100) < 80 \n+                        ? randomCharacters.substring(rnd().nextInt(randomCharacters.length())).substring(0, 1) \n+                        : (randomFromCollection(FILL_MODIFIERS) \n+                            + randomFromCollection(formatStringsToRandomTest) \n+                            + randomFromCollection(ORDINAL_SUFFIX_MODIFIERS)))\n+                    .collect(Collectors.joining());\n+                \n+                // clean up the random string from the unsupported modifiers\n+                for (String unsupportedPatternModifier : UNSUPPORTED_PATTERN_MODIFIERS) {\n+                    patternWithLiterals = patternWithLiterals\n+                        .replace(unsupportedPatternModifier, \"\")\n+                        .replace(unsupportedPatternModifier.toLowerCase(Locale.ROOT), \"\");\n+                }\n+                testCases.add(new TestCase(randomFromCollection(testEpochSeconds), patternWithLiterals));\n+            }\n+    \n+            return testCases;\n+        }\n+        \n+        private static String adjustZoneIdToPostgres(String zoneId) {\n+            // when the zone is specified by the offset in Postgres, it follows the POSIX definition, so the +- signs are flipped\n+            // compared to ISO-8601, see more info at: https://www.postgresql.org/docs/current/datetime-posix-timezone-specs.html\n+            if (zoneId.startsWith(\"+\")) {\n+                zoneId = zoneId.replaceFirst(quote(\"+\"), \"-\");\n+            } else if (zoneId.startsWith(\"-\")) {\n+                zoneId = zoneId.replaceFirst(quote(\"-\"), \"+\");\n+            }\n+            return zoneId;\n+        }\n+        \n+        /**\n+         * Generates an SQL file that can be used to create the test dataset for the unit test of the <code>TO_CHAR</code>\n+         * implementation. In case the <code>TO_CHAR</code> implementation needs an upgrade, add the list of the new format\n+         * strings to the list of the format string, regenerate the SQL, run it against the PostgreSQL version you are targeting\n+         * and update the test CSV file.\n+         */\n+        private static String unitTestExporterScript() {\n+            return generateTestCases().stream().map(tc -> {\n+                long seconds = tc.secondsAndFractionsSinceEpoch.longValue();\n+                BigDecimal fractions = tc.secondsAndFractionsSinceEpoch.remainder(BigDecimal.ONE).movePointRight(6);\n+                return String.format(Locale.ROOT,\n+                    \"SET TIME ZONE '%7$s';\\n\" +\n+                    \"\\\\copy (SELECT %1$d as id, %2$s as epoch_seconds_and_microsends, '%6$s' as zone_id, '%5$s' as format_string, \" +\n+                        \"(TO_TIMESTAMP(%3$d) + INTERVAL '%4$d microseconds') as to_timestamp_result, \" +\n+                        \"TO_CHAR((TO_TIMESTAMP(%3$d) + INTERVAL '%4$d microseconds'), '%5$s') as to_char_result) to stdout \" +\n+                        \"with DELIMITER as '\" + DELIMITER + \"' NULL as '' csv \\n\",\n+                    tc.id, tc.secondsAndFractionsSinceEpoch.toPlainString(), seconds, fractions.intValue(), tc.formatString, tc.zoneId, \n+                    adjustZoneIdToPostgres(tc.zoneId)\n+                );\n+            }).collect(Collectors.joining(\"\\n\"));\n+        }\n+        \n+        public static void main(String[] args) throws Exception {\n+            String scriptFilename = args.length < 1 ? \"/tmp/postgresql-tochar-test.sql\" : args[0];\n+            Files.writeString(Path.of(scriptFilename), unitTestExporterScript(), StandardCharsets.UTF_8);\n+        }\n+    }\n+\n+    @ParametersFactory(argumentFormatting = \"%1$s: timestamp=%5$s, zone=%3$s, format=%4$s\")\n+    public static List<Object[]> readCsv() throws Exception {\n+        Path testFilePath = Path.of(DateTimeToCharProcessorTests.class.getResource(\"tochar.csv\").toURI());\n+        return Files.readAllLines(testFilePath).stream().map(line -> {\n+            String[] cols = line.split(quote(TestGenerator.DELIMITER));\n+            return new Object[]{ cols[0], cols[1], cols[2], cols[3], cols[4], cols[5] };\n+        }).collect(Collectors.toList());\n+    }\n+\n+    private final String id;\n+    private final String secondsAndFractionsSinceEpoch;\n+    private final String zone;\n+    private final String formatString;\n+    private final String posgresTimestamp;\n+    private final String expectedResult;\n+\n+    public DateTimeToCharProcessorTests(String id, String secondsAndFractionsSinceEpoch, String zone, String formatString,\n+        String postgresTimestamp, String expectedResult) {\n+        this.id = id;\n+        this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+        this.zone = zone;\n+        this.formatString = formatString;\n+        this.posgresTimestamp = postgresTimestamp;\n+        this.expectedResult = expectedResult;\n+    }\n+\n+    private static ZonedDateTime dateTimeWithFractions(String secondAndFractionsSinceEpoch) {\n+        BigDecimal b = new BigDecimal(secondAndFractionsSinceEpoch);\n+        long seconds = b.longValue();\n+        int fractions = b.remainder(BigDecimal.ONE).movePointRight(9).intValueExact();\n+        int adjustment = 0;\n+        if (fractions < 0) {\n+            fractions += 1e9;\n+            adjustment = -1;\n+        }\n+        return dateTime((seconds + adjustment) * 1000).withNano(fractions);\n+    }\n+    \n+    public void test() throws Exception {\n+        ZoneId zoneId = ZoneId.of(zone);\n+        ZonedDateTime timestamp = dateTimeWithFractions(secondsAndFractionsSinceEpoch);\n+        String actualResult =\n+            (String) new ToChar(Source.EMPTY, l(timestamp, DataTypes.DATETIME), l(formatString, DataTypes.KEYWORD), zoneId)\n+                .makePipe()\n+                .asProcessor()\n+                .process(null);\n+        List<String> expectedResultSplitted = List.of(expectedResult.split(quote(TestGenerator.PATTERN_DELIMITER)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 285}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA1NjgxMQ==", "bodyText": "Please add some docs on the number of arguments and their purpose so that folks that pick this test in the future under what they're after without having to dig too much into Postgres.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552056811", "createdAt": "2021-01-05T16:49:20Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    private static class TestCase {\n+        private static final AtomicInteger COUNTER = new AtomicInteger(0);\n+        \n+        // timezones that are valid both in Java and in Postgres\n+        public static final List<String> POSTGRES_TEST_ZONE_LIST = List.of(\n+            // location-based and long-names\n+            \"US/Samoa\", \"Pacific/Honolulu\", \"Pacific/Marquesas\", \"Pacific/Gambier\", \"America/Juneau\", \"Canada/Yukon\", \"America/Vancouver\",\n+            \"Pacific/Easter\", \"US/Mountain\", \"America/Chicago\", \"US/Michigan\", \"Atlantic/Bermuda\", \"Canada/Newfoundland\",\n+            \"Atlantic/Cape_Verde\", \"Pacific/Kiritimati\", \"Pacific/Chatham\", \"Pacific/Auckland\", \"Asia/Sakhalin\", \"Australia/Tasmania\", \n+            \"Australia/North\", \"Asia/Tokyo\", \"Australia/Eucla\", \"Asia/Singapore\", \"Asia/Rangoon\", \"Indian/Chagos\", \"Asia/Calcutta\", \n+            \"Asia/Tashkent\", \"Asia/Tehran\", \"Asia/Dubai\", \"Africa/Nairobi\", \"Europe/Brussels\", \"Europe/Vienna\", \"Europe/London\", \n+            \"Etc/GMT+12\",\n+            // short names of zones\n+            \"GMT\", \"UTC\", \"CET\",\n+            // offsets\n+            \"+11:00\", \"+04:30\", \"+01:00\", \"+00:00\", \"-00:00\", \"-01:15\", \"-02:00\", \"-11:00\");\n+\n+        private final int id;\n+        private final BigDecimal secondsAndFractionsSinceEpoch;\n+        private final String formatString;\n+        private final String zoneId;\n+        \n+        TestCase(BigDecimal secondsAndFractionsSinceEpoch, String formatString) {\n+            this.id = COUNTER.incrementAndGet();\n+            this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+            this.formatString = formatString;\n+            this.zoneId = TestGenerator.randomFromCollection(POSTGRES_TEST_ZONE_LIST);\n+        }\n+\n+    }\n+\n+    /**\n+     * Generates an sql file that can be used to generate the test dataset for this unit test (to be used with the <code>psql</code> cli).\n+     *\n+     * Run the @{link {@link TestGenerator#main(String[])}} class and execute the following command to generate the output dataset with:\n+     *\n+     * <p>\n+     *  <code>\n+     *      # easy way to spin up the latest Postgres\n+     *      docker run --rm --name postgres-latest -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres:latest\n+     *\n+     *      # generate the csv for the unit test\n+     *      PGPASSWORD=\"mysecretpassword\" psql --quiet -h localhost -p 5432 -U postgres -f /tmp/postgresql-tochar-test.sql \\\n+     *          &gt; /path/to/tochar.csv\n+     *  </code>\n+     * </p>\n+     */\n+    private static class TestGenerator {\n+        \n+        private static final long SECONDS_IN_YEAR = 365 * 24 * 60 * 60L;\n+        private static final String DELIMITER = \"|\";\n+        private static final String PATTERN_DELIMITER = \" @ \";\n+        // these patterns are hard to sync up between PostgreSQL and Elasticsearch, so we just warn, but actually\n+        // accept the output of Elasticsearch as is\n+        private static final Set<String> NOT_FULLY_MATCHABLE_PATTERNS = Set.of(\"TZ\", \"tz\");\n+        private static final Set<String> UNSUPPORTED_PATTERN_MODIFIERS = Set.of(\"FX\", \"TM\", \"SP\");\n+        private static final String[] PATTERNS = new String[] {\n+            \"HH\", \"HH12\", \"HH24\", \"MI\", \"SS\", \"MS\", \"US\", \"FF1\", \"FF2\", \"FF3\", \"FF4\", \"FF5\", \"FF6\", \"SSSS\", \"SSSSS\", \"AM\", \"am\", \"PM\",\n+            \"pm\", \"A.M.\", \"a.m.\", \"P.M.\", \"p.m.\", \"Y,YYY\", \"YYYY\", \"YYY\", \"YY\", \"Y\", \"IYYY\", \"IYY\", \"IY\", \"I\", \"BC\", \"bc\", \"AD\", \"ad\",\n+            \"B.C.\", \"b.c.\", \"A.D.\", \"a.d.\", \"MONTH\", \"Month\", \"month\", \"MON\", \"Mon\", \"mon\", \"MM\", \"DAY\", \"Day\", \"day\", \"DY\", \"Dy\",\n+            \"dy\", \"DDD\", \"IDDD\", \"DD\", \"D\", \"ID\", \"W\", \"WW\", \"IW\", \"CC\", \"J\", \"Q\", \"RM\", \"rm\", \"TZ\", \"tz\", \"TZH\", \"TZM\", \"OF\"\n+        };\n+        private static final List<String> FILL_MODIFIERS = List.of(\"FM\", \"fm\", \"\");\n+        private static final List<String> ORDINAL_SUFFIX_MODIFIERS = List.of(\"TH\", \"th\", \"\");\n+\n+        @SuppressForbidden(reason = \"It is ok to use ThreadLocalRandom outside of an actual test\")\n+        private static Random rnd() {\n+            return ThreadLocalRandom.current();\n+        }\n+\n+        private static BigDecimal randomSecondsWithFractions(int minYear, int maxYear) {\n+            BigDecimal seconds = new BigDecimal(RandomNumbers.randomLongBetween(rnd(), \n+                (minYear - 1970) * SECONDS_IN_YEAR, (maxYear - 1970) * SECONDS_IN_YEAR));\n+            BigDecimal fractions = new BigDecimal(RandomNumbers.randomIntBetween(rnd(), 0, 999_999)).movePointLeft(6);\n+            return seconds.add(fractions);\n+        }\n+\n+        private static <T> T randomFromCollection(Collection<T> list) {\n+            List<T> l = new ArrayList<>(list);\n+            return l.get(rnd().nextInt(l.size()));\n+        }\n+        \n+        private static String patternWithRandomModifiers(String pattern) {\n+            if (NOT_FULLY_MATCHABLE_PATTERNS.contains(pattern)) {\n+                return pattern;\n+            }\n+            return randomFromCollection(FILL_MODIFIERS) + pattern + randomFromCollection(ORDINAL_SUFFIX_MODIFIERS);\n+        }\n+    \n+        private static List<TestCase> generateTestCases() {\n+            \n+            final List<BigDecimal> testEpochSeconds = new LinkedList<>();\n+            for (int i = 0; i < 50; i++) {\n+                testEpochSeconds.add(randomSecondsWithFractions(-1200, 2500));\n+            }\n+            for (int i = 0; i < 5; i++) {\n+                testEpochSeconds.add(randomSecondsWithFractions(-1, 1));\n+            }\n+    \n+            List<TestCase> testCases = new ArrayList<>();\n+    \n+            // check each format string alone\n+            for (String pattern : PATTERNS) {\n+                testCases.add(new TestCase(randomFromCollection(testEpochSeconds), NOT_FULLY_MATCHABLE_PATTERNS.contains(pattern) \n+                    ? pattern \n+                    : String.join(PATTERN_DELIMITER, pattern, FILL_MODIFIERS.get(0) + pattern + ORDINAL_SUFFIX_MODIFIERS.get(0))));\n+            }\n+            \n+            // let's check all of the format strings with a non-ambiguous format string\n+            for (BigDecimal es : testEpochSeconds) {\n+                testCases.add(new TestCase(es, IntStream.range(0, PATTERNS.length)\n+                    .mapToObj(idx -> idx + \":\" + patternWithRandomModifiers(PATTERNS[idx]))\n+                    .collect(Collectors.joining(PATTERN_DELIMITER))));\n+            }\n+    \n+            // check the lowercase versions of the format strings\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), IntStream.range(0, PATTERNS.length)\n+                .mapToObj(idx -> (idx + \":\" + patternWithRandomModifiers(PATTERNS[idx])).toLowerCase(Locale.ROOT))\n+                .collect(Collectors.joining(PATTERN_DELIMITER))));\n+    \n+            // potentially ambiguous format string test cases, to check if our format string parsing is in-sync with PostgreSQL\n+            // greedy and prefers the longer format strings\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"YYYYYYYYYYYYYYY,YYYYYYYYY\"));\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"SSSSSSSSSSSSSSSS\"));\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"DDDDDDDD\"));\n+    \n+            // Roman numbers\n+            for (int i = 1; i <= 12; i++) {\n+                testCases.add(new TestCase(\n+                    new BigDecimal(dateTime(0).withMonth(i).toEpochSecond()), rnd().nextBoolean() ? \"RM\" : \"rm\"));\n+            }\n+            \n+            // random strings made out of template patterns and random characters\n+            final String randomCharacters = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYabcdefghijklmnopqrstuvwxy _-.:;\";\n+            final List<String> formatStringsToRandomTest = Arrays.stream(PATTERNS)\n+                .filter(s -> NOT_FULLY_MATCHABLE_PATTERNS.contains(s) == false)\n+                .collect(Collectors.toList());\n+            \n+            for (int i = 0; i < 20; i++) {\n+                String patternWithLiterals = IntStream.rangeClosed(1, 30).mapToObj(idx -> \n+                    rnd().nextInt(100) < 80 \n+                        ? randomCharacters.substring(rnd().nextInt(randomCharacters.length())).substring(0, 1) \n+                        : (randomFromCollection(FILL_MODIFIERS) \n+                            + randomFromCollection(formatStringsToRandomTest) \n+                            + randomFromCollection(ORDINAL_SUFFIX_MODIFIERS)))\n+                    .collect(Collectors.joining());\n+                \n+                // clean up the random string from the unsupported modifiers\n+                for (String unsupportedPatternModifier : UNSUPPORTED_PATTERN_MODIFIERS) {\n+                    patternWithLiterals = patternWithLiterals\n+                        .replace(unsupportedPatternModifier, \"\")\n+                        .replace(unsupportedPatternModifier.toLowerCase(Locale.ROOT), \"\");\n+                }\n+                testCases.add(new TestCase(randomFromCollection(testEpochSeconds), patternWithLiterals));\n+            }\n+    \n+            return testCases;\n+        }\n+        \n+        private static String adjustZoneIdToPostgres(String zoneId) {\n+            // when the zone is specified by the offset in Postgres, it follows the POSIX definition, so the +- signs are flipped\n+            // compared to ISO-8601, see more info at: https://www.postgresql.org/docs/current/datetime-posix-timezone-specs.html\n+            if (zoneId.startsWith(\"+\")) {\n+                zoneId = zoneId.replaceFirst(quote(\"+\"), \"-\");\n+            } else if (zoneId.startsWith(\"-\")) {\n+                zoneId = zoneId.replaceFirst(quote(\"-\"), \"+\");\n+            }\n+            return zoneId;\n+        }\n+        \n+        /**\n+         * Generates an SQL file that can be used to create the test dataset for the unit test of the <code>TO_CHAR</code>\n+         * implementation. In case the <code>TO_CHAR</code> implementation needs an upgrade, add the list of the new format\n+         * strings to the list of the format string, regenerate the SQL, run it against the PostgreSQL version you are targeting\n+         * and update the test CSV file.\n+         */\n+        private static String unitTestExporterScript() {\n+            return generateTestCases().stream().map(tc -> {\n+                long seconds = tc.secondsAndFractionsSinceEpoch.longValue();\n+                BigDecimal fractions = tc.secondsAndFractionsSinceEpoch.remainder(BigDecimal.ONE).movePointRight(6);\n+                return String.format(Locale.ROOT,\n+                    \"SET TIME ZONE '%7$s';\\n\" +\n+                    \"\\\\copy (SELECT %1$d as id, %2$s as epoch_seconds_and_microsends, '%6$s' as zone_id, '%5$s' as format_string, \" +\n+                        \"(TO_TIMESTAMP(%3$d) + INTERVAL '%4$d microseconds') as to_timestamp_result, \" +\n+                        \"TO_CHAR((TO_TIMESTAMP(%3$d) + INTERVAL '%4$d microseconds'), '%5$s') as to_char_result) to stdout \" +\n+                        \"with DELIMITER as '\" + DELIMITER + \"' NULL as '' csv \\n\",\n+                    tc.id, tc.secondsAndFractionsSinceEpoch.toPlainString(), seconds, fractions.intValue(), tc.formatString, tc.zoneId, \n+                    adjustZoneIdToPostgres(tc.zoneId)\n+                );\n+            }).collect(Collectors.joining(\"\\n\"));\n+        }\n+        \n+        public static void main(String[] args) throws Exception {\n+            String scriptFilename = args.length < 1 ? \"/tmp/postgresql-tochar-test.sql\" : args[0];\n+            Files.writeString(Path.of(scriptFilename), unitTestExporterScript(), StandardCharsets.UTF_8);\n+        }\n+    }\n+\n+    @ParametersFactory(argumentFormatting = \"%1$s: timestamp=%5$s, zone=%3$s, format=%4$s\")\n+    public static List<Object[]> readCsv() throws Exception {\n+        Path testFilePath = Path.of(DateTimeToCharProcessorTests.class.getResource(\"tochar.csv\").toURI());\n+        return Files.readAllLines(testFilePath).stream().map(line -> {\n+            String[] cols = line.split(quote(TestGenerator.DELIMITER));\n+            return new Object[]{ cols[0], cols[1], cols[2], cols[3], cols[4], cols[5] };\n+        }).collect(Collectors.toList());\n+    }\n+\n+    private final String id;\n+    private final String secondsAndFractionsSinceEpoch;\n+    private final String zone;\n+    private final String formatString;\n+    private final String posgresTimestamp;\n+    private final String expectedResult;\n+\n+    public DateTimeToCharProcessorTests(String id, String secondsAndFractionsSinceEpoch, String zone, String formatString,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 255}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA1ODMxMw==", "bodyText": "It looks like this is the only class where these methods are defined so why not move them here?", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552058313", "createdAt": "2021-01-05T16:51:43Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,376 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA1ODk5NQ==", "bodyText": "Fully qualifying the static method in the same class is just noise. Please update your formatting rule and just call of", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552058995", "createdAt": "2021-01-05T16:52:44Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,376 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA1OTQ0Ng==", "bodyText": "It's worth adding some static imports for String, Integer, etc.. to simplify these function definitions.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552059446", "createdAt": "2021-01-05T16:53:30Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,376 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2MDA0NQ==", "bodyText": "Please add a comment on why 24000001 - isn't this constant defined anywhere in the Java time API?", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552060045", "createdAt": "2021-01-05T16:54:21Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,376 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2MTI5MQ==", "bodyText": "Either fix the supress warning or initialize the variable in the static block above where FORMATTER_MAP is defined.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552061291", "createdAt": "2021-01-05T16:56:19Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,376 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::removeLeadingZerosFromOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2MTUxNg==", "bodyText": "What is fillMode?", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552061516", "createdAt": "2021-01-05T16:56:41Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,376 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::removeLeadingZerosFromOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int\n+        MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().getAsInt();\n+\n+    private final String pattern;\n+    private final boolean lowercaseAccepted;\n+    private final Function<String, String> fillMode;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2MTcyOA==", "bodyText": "acceptsLowercase", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552061728", "createdAt": "2021-01-05T16:57:03Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,376 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::removeLeadingZerosFromOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int\n+        MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().getAsInt();\n+\n+    private final String pattern;\n+    private final boolean lowercaseAccepted;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2MjM5MA==", "bodyText": "formatter, toString, asString", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552062390", "createdAt": "2021-01-05T16:57:54Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,376 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::removeLeadingZerosFromOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int\n+        MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().getAsInt();\n+\n+    private final String pattern;\n+    private final boolean lowercaseAccepted;\n+    private final Function<String, String> fillMode;\n+    private final boolean hasOrdinalSuffix;\n+    private final Function<TemporalAccessor, String> formatFn;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2NTQwNg==", "bodyText": "Why is this called text yet it accepts a fillMode? Why is defined as a general Function yet seems to have limited implementations?", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552065406", "createdAt": "2021-01-05T17:02:46Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,376 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::removeLeadingZerosFromOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int\n+        MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().getAsInt();\n+\n+    private final String pattern;\n+    private final boolean lowercaseAccepted;\n+    private final Function<String, String> fillMode;\n+    private final boolean hasOrdinalSuffix;\n+    private final Function<TemporalAccessor, String> formatFn;\n+\n+    private ToCharFormatter(\n+        String pattern,\n+        boolean lowercaseAccepted,\n+        Function<String, String> fillMode,\n+        boolean hasOrdinalSuffix,\n+        Function<TemporalAccessor, String> formatFn) {\n+\n+        this.pattern = pattern;\n+        this.lowercaseAccepted = lowercaseAccepted;\n+        this.fillMode = fillMode;\n+        this.hasOrdinalSuffix = hasOrdinalSuffix;\n+        this.formatFn = formatFn;\n+    }\n+\n+    private static Builder of(String pattern) {\n+        return new Builder(pattern);\n+    }\n+\n+    private String format(TemporalAccessor temporalAccessor) {\n+        return formatFn.apply(temporalAccessor);\n+    }\n+\n+    private ToCharFormatter withModifier(Function<String, String> modifierFn) {\n+        return new ToCharFormatter(pattern, lowercaseAccepted, fillMode, hasOrdinalSuffix, formatFn.andThen(modifierFn));\n+    }\n+\n+    private static List<ToCharFormatter> parsePattern(String toCharPattern) {\n+        LinkedList<ToCharFormatter> formatters = new LinkedList<>();\n+\n+        boolean fillModeModifierActive = false;\n+\n+        while (toCharPattern.isEmpty() == false) {\n+            boolean foundPattern = false;\n+            for (int length = Math.min(MAX_TO_CHAR_FORMAT_STRING_LENGTH, toCharPattern.length()); length >= 1; length--) {\n+                final String potentialPattern = toCharPattern.substring(0, length);\n+                if (isFillModeModifier(potentialPattern)) {\n+                    // try to apply the fill mode modifier to the next formatter\n+                    fillModeModifierActive = true;\n+                    foundPattern = true;\n+                } else if (isOrdinalSuffixModifier(potentialPattern)) {\n+                    // try to apply the ordinal suffix modifier to the last formatter\n+                    ToCharFormatter lastFormatter = formatters.removeLast();\n+                    if (lastFormatter == null) {\n+                        // if there was no previous pattern, simply prints the ordinal suffix pattern\n+                        lastFormatter = literal(potentialPattern);\n+                    } else if (lastFormatter.hasOrdinalSuffix) {\n+                        lastFormatter = lastFormatter.withModifier(s -> appendOrdinalSuffix(potentialPattern, s));\n+                    }\n+                    formatters.addLast(lastFormatter);\n+                    foundPattern = true;\n+                } else {\n+                    ToCharFormatter formatter = FORMATTER_MAP.get(potentialPattern);\n+                    // check if it is a known pattern string, if so apply it, with any modifier\n+                    if (formatter != null) {\n+                        if (fillModeModifierActive && formatter.fillMode != null) {\n+                            formatter = formatter.withModifier(formatter.fillMode);\n+                        }\n+                        formatters.addLast(formatter);\n+                        fillModeModifierActive = false;\n+                        foundPattern = true;\n+                    }\n+                }\n+                if (foundPattern) {\n+                    toCharPattern = toCharPattern.substring(length);\n+                    break;\n+                }\n+            }\n+            if (foundPattern == false) {\n+                // the fill mode modifier does not apply in case of literals\n+                formatters.addLast(literal(toCharPattern.substring(0, 1)));\n+                toCharPattern = toCharPattern.substring(1);\n+                fillModeModifierActive = false;\n+            }\n+        }\n+        return formatters;\n+    }\n+\n+    private static boolean isOrdinalSuffixModifier(String potentialPattern) {\n+        return \"TH\".equals(potentialPattern) || \"th\".equals(potentialPattern);\n+    }\n+\n+    private static boolean isFillModeModifier(String potentialPattern) {\n+        return \"FM\".equals(potentialPattern) || \"fm\".equals(potentialPattern);\n+    }\n+\n+    public static Function<TemporalAccessor, String> ofPattern(String pattern) {\n+        if (Strings.isEmpty(pattern)) {\n+            return timestamp -> \"\";\n+        }\n+        final List<ToCharFormatter> toCharFormatters = parsePattern(pattern);\n+        return timestamp -> toCharFormatters.stream().map(p -> p.format(timestamp)).collect(Collectors.joining());\n+    }\n+\n+    private static ToCharFormatter literal(String literal) {\n+        return new ToCharFormatter(literal, false, null, true, t -> literal);\n+    }\n+\n+    private static String ordinalSuffix(int i) {\n+        if (i < 0) {\n+            i = -i;\n+        }\n+        int mod100 = i % 100;\n+        int mod10 = i % 10;\n+        if (mod10 == 1 && mod100 != 11) {\n+            return \"st\";\n+        } else if (mod10 == 2 && mod100 != 12) {\n+            return \"nd\";\n+        } else if (mod10 == 3 && mod100 != 13) {\n+            return \"rd\";\n+        } else {\n+            return \"th\";\n+        }\n+    }\n+\n+    private static String appendOrdinalSuffix(String defaultSuffix, String s) {\n+        try {\n+            // the Y,YYY pattern might can cause problems with the parsing, but thankfully the last 3\n+            // characters is enough to calculate the suffix\n+            int i = Integer.parseInt(lastNCharacter(s, 3));\n+            final boolean upperCase = defaultSuffix.equals(defaultSuffix.toUpperCase(Locale.ROOT));\n+            return s + (upperCase ? ordinalSuffix(i).toUpperCase(Locale.ROOT) : ordinalSuffix(i));\n+        } catch (NumberFormatException ex) {\n+            return s + defaultSuffix;\n+        }\n+    }\n+\n+    private static String removeLeadingZeros(String number) {\n+        return String.valueOf(Integer.parseInt(number));\n+    }\n+\n+    private static String removePadding(String paddedText) {\n+        return paddedText.replaceAll(\" +$\", \"\");\n+    }\n+\n+    private static String formatOffset(String offset) {\n+        if (offset.equals(\"Z\")) {\n+            return \"+00\";\n+        }\n+        if (offset.matches(\"^[+-][0-9][0-9]00$\")) {\n+            offset = offset.substring(0, offset.length() - 2);\n+        } else if (offset.matches(\"^[+-][0-9]{3,4}$\")) {\n+            offset = offset.substring(0, offset.length() - 2) + \":\" + offset.substring(offset.length() - 2);\n+        } else if (offset.matches(\"^[+-][0-9][0-9]:00$\")) {\n+            offset = offset.substring(0, offset.length() - 3);\n+        }\n+        return offset.substring(0, Math.min(offset.length(), 6));\n+    }\n+\n+    private static String removeLeadingZerosFromOffset(String offset) {\n+        if (offset.matches(\"[+-]0{1,2}\")) {\n+            return offset.substring(0, 2);\n+        } else {\n+            if (offset.startsWith(\"+0\")) {\n+                return \"+\" + offset.substring(2);\n+            } else if (offset.startsWith(\"-0\")) {\n+                return \"-\" + offset.substring(2);\n+            } else {\n+                return offset;\n+            }\n+        }\n+    }\n+\n+    private static String absoluteWeekBasedYear(TemporalAccessor t) {\n+        int year = t.get(IsoFields.WEEK_BASED_YEAR);\n+        year = year > 0 ? year : -(year - 1);\n+        return String.format(Locale.ROOT, \"%04d\", year);\n+    }\n+\n+    private static String firstDigitsOfNanos(String nano, int digits) {\n+        return String.format(Locale.ROOT, \"%09d\", Integer.parseInt(nano)).substring(0, digits);\n+    }\n+\n+    private static String lastNCharacter(String s, int n) {\n+        return s.substring(Math.max(0, s.length() - n));\n+    }\n+\n+    private static String zoneAbbreviationOf(TemporalAccessor temporalAccessor) {\n+        String zone = ZoneId.from(temporalAccessor).getDisplayName(TextStyle.SHORT, Locale.ROOT);\n+        return \"Z\".equals(zone) ? \"UTC\" : zone;\n+    }\n+\n+    private static class Builder {\n+\n+        private final String pattern;\n+        private boolean lowercaseAccepted = true;\n+        private Function<String, String> fillMode = ToCharFormatter::removeLeadingZeros;\n+        private boolean hasOrdinalSuffix = true;\n+        private Function<TemporalAccessor, String> formatFn;\n+\n+        Builder(String pattern) {\n+            this.pattern = pattern;\n+        }\n+\n+        public Builder formatFn(final String javaPattern) {\n+            return formatFn(javaPattern, null);\n+        }\n+\n+        public Builder formatFn(final String javaPattern, final Function<String, String> additionalMapper) {\n+            this.formatFn = temporalAccessor -> {\n+                String formatted = DateTimeFormatter.ofPattern(javaPattern != null ? javaPattern : \"'\" + pattern + \"'\", Locale.ROOT)\n+                    .format(temporalAccessor);\n+                return additionalMapper == null ? formatted : additionalMapper.apply(formatted);\n+            };\n+            return this;\n+        }\n+\n+        public Builder formatFn(Function<TemporalAccessor, String> formatFn) {\n+            this.formatFn = formatFn;\n+            return this;\n+        }\n+\n+        public Builder noFillMode() {\n+            this.fillMode = null;\n+            return this;\n+        }\n+\n+        public Builder text() {\n+            return text(ToCharFormatter::removePadding);\n+        }\n+\n+        public Builder text(Function<String, String> fillMode) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 361}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2NTY4MQ==", "bodyText": "Since there is a relationship between fillMode and ordinalSuffix should that apply to noFillMode as well?", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552065681", "createdAt": "2021-01-05T17:03:17Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,376 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::removeLeadingZerosFromOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int\n+        MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().getAsInt();\n+\n+    private final String pattern;\n+    private final boolean lowercaseAccepted;\n+    private final Function<String, String> fillMode;\n+    private final boolean hasOrdinalSuffix;\n+    private final Function<TemporalAccessor, String> formatFn;\n+\n+    private ToCharFormatter(\n+        String pattern,\n+        boolean lowercaseAccepted,\n+        Function<String, String> fillMode,\n+        boolean hasOrdinalSuffix,\n+        Function<TemporalAccessor, String> formatFn) {\n+\n+        this.pattern = pattern;\n+        this.lowercaseAccepted = lowercaseAccepted;\n+        this.fillMode = fillMode;\n+        this.hasOrdinalSuffix = hasOrdinalSuffix;\n+        this.formatFn = formatFn;\n+    }\n+\n+    private static Builder of(String pattern) {\n+        return new Builder(pattern);\n+    }\n+\n+    private String format(TemporalAccessor temporalAccessor) {\n+        return formatFn.apply(temporalAccessor);\n+    }\n+\n+    private ToCharFormatter withModifier(Function<String, String> modifierFn) {\n+        return new ToCharFormatter(pattern, lowercaseAccepted, fillMode, hasOrdinalSuffix, formatFn.andThen(modifierFn));\n+    }\n+\n+    private static List<ToCharFormatter> parsePattern(String toCharPattern) {\n+        LinkedList<ToCharFormatter> formatters = new LinkedList<>();\n+\n+        boolean fillModeModifierActive = false;\n+\n+        while (toCharPattern.isEmpty() == false) {\n+            boolean foundPattern = false;\n+            for (int length = Math.min(MAX_TO_CHAR_FORMAT_STRING_LENGTH, toCharPattern.length()); length >= 1; length--) {\n+                final String potentialPattern = toCharPattern.substring(0, length);\n+                if (isFillModeModifier(potentialPattern)) {\n+                    // try to apply the fill mode modifier to the next formatter\n+                    fillModeModifierActive = true;\n+                    foundPattern = true;\n+                } else if (isOrdinalSuffixModifier(potentialPattern)) {\n+                    // try to apply the ordinal suffix modifier to the last formatter\n+                    ToCharFormatter lastFormatter = formatters.removeLast();\n+                    if (lastFormatter == null) {\n+                        // if there was no previous pattern, simply prints the ordinal suffix pattern\n+                        lastFormatter = literal(potentialPattern);\n+                    } else if (lastFormatter.hasOrdinalSuffix) {\n+                        lastFormatter = lastFormatter.withModifier(s -> appendOrdinalSuffix(potentialPattern, s));\n+                    }\n+                    formatters.addLast(lastFormatter);\n+                    foundPattern = true;\n+                } else {\n+                    ToCharFormatter formatter = FORMATTER_MAP.get(potentialPattern);\n+                    // check if it is a known pattern string, if so apply it, with any modifier\n+                    if (formatter != null) {\n+                        if (fillModeModifierActive && formatter.fillMode != null) {\n+                            formatter = formatter.withModifier(formatter.fillMode);\n+                        }\n+                        formatters.addLast(formatter);\n+                        fillModeModifierActive = false;\n+                        foundPattern = true;\n+                    }\n+                }\n+                if (foundPattern) {\n+                    toCharPattern = toCharPattern.substring(length);\n+                    break;\n+                }\n+            }\n+            if (foundPattern == false) {\n+                // the fill mode modifier does not apply in case of literals\n+                formatters.addLast(literal(toCharPattern.substring(0, 1)));\n+                toCharPattern = toCharPattern.substring(1);\n+                fillModeModifierActive = false;\n+            }\n+        }\n+        return formatters;\n+    }\n+\n+    private static boolean isOrdinalSuffixModifier(String potentialPattern) {\n+        return \"TH\".equals(potentialPattern) || \"th\".equals(potentialPattern);\n+    }\n+\n+    private static boolean isFillModeModifier(String potentialPattern) {\n+        return \"FM\".equals(potentialPattern) || \"fm\".equals(potentialPattern);\n+    }\n+\n+    public static Function<TemporalAccessor, String> ofPattern(String pattern) {\n+        if (Strings.isEmpty(pattern)) {\n+            return timestamp -> \"\";\n+        }\n+        final List<ToCharFormatter> toCharFormatters = parsePattern(pattern);\n+        return timestamp -> toCharFormatters.stream().map(p -> p.format(timestamp)).collect(Collectors.joining());\n+    }\n+\n+    private static ToCharFormatter literal(String literal) {\n+        return new ToCharFormatter(literal, false, null, true, t -> literal);\n+    }\n+\n+    private static String ordinalSuffix(int i) {\n+        if (i < 0) {\n+            i = -i;\n+        }\n+        int mod100 = i % 100;\n+        int mod10 = i % 10;\n+        if (mod10 == 1 && mod100 != 11) {\n+            return \"st\";\n+        } else if (mod10 == 2 && mod100 != 12) {\n+            return \"nd\";\n+        } else if (mod10 == 3 && mod100 != 13) {\n+            return \"rd\";\n+        } else {\n+            return \"th\";\n+        }\n+    }\n+\n+    private static String appendOrdinalSuffix(String defaultSuffix, String s) {\n+        try {\n+            // the Y,YYY pattern might can cause problems with the parsing, but thankfully the last 3\n+            // characters is enough to calculate the suffix\n+            int i = Integer.parseInt(lastNCharacter(s, 3));\n+            final boolean upperCase = defaultSuffix.equals(defaultSuffix.toUpperCase(Locale.ROOT));\n+            return s + (upperCase ? ordinalSuffix(i).toUpperCase(Locale.ROOT) : ordinalSuffix(i));\n+        } catch (NumberFormatException ex) {\n+            return s + defaultSuffix;\n+        }\n+    }\n+\n+    private static String removeLeadingZeros(String number) {\n+        return String.valueOf(Integer.parseInt(number));\n+    }\n+\n+    private static String removePadding(String paddedText) {\n+        return paddedText.replaceAll(\" +$\", \"\");\n+    }\n+\n+    private static String formatOffset(String offset) {\n+        if (offset.equals(\"Z\")) {\n+            return \"+00\";\n+        }\n+        if (offset.matches(\"^[+-][0-9][0-9]00$\")) {\n+            offset = offset.substring(0, offset.length() - 2);\n+        } else if (offset.matches(\"^[+-][0-9]{3,4}$\")) {\n+            offset = offset.substring(0, offset.length() - 2) + \":\" + offset.substring(offset.length() - 2);\n+        } else if (offset.matches(\"^[+-][0-9][0-9]:00$\")) {\n+            offset = offset.substring(0, offset.length() - 3);\n+        }\n+        return offset.substring(0, Math.min(offset.length(), 6));\n+    }\n+\n+    private static String removeLeadingZerosFromOffset(String offset) {\n+        if (offset.matches(\"[+-]0{1,2}\")) {\n+            return offset.substring(0, 2);\n+        } else {\n+            if (offset.startsWith(\"+0\")) {\n+                return \"+\" + offset.substring(2);\n+            } else if (offset.startsWith(\"-0\")) {\n+                return \"-\" + offset.substring(2);\n+            } else {\n+                return offset;\n+            }\n+        }\n+    }\n+\n+    private static String absoluteWeekBasedYear(TemporalAccessor t) {\n+        int year = t.get(IsoFields.WEEK_BASED_YEAR);\n+        year = year > 0 ? year : -(year - 1);\n+        return String.format(Locale.ROOT, \"%04d\", year);\n+    }\n+\n+    private static String firstDigitsOfNanos(String nano, int digits) {\n+        return String.format(Locale.ROOT, \"%09d\", Integer.parseInt(nano)).substring(0, digits);\n+    }\n+\n+    private static String lastNCharacter(String s, int n) {\n+        return s.substring(Math.max(0, s.length() - n));\n+    }\n+\n+    private static String zoneAbbreviationOf(TemporalAccessor temporalAccessor) {\n+        String zone = ZoneId.from(temporalAccessor).getDisplayName(TextStyle.SHORT, Locale.ROOT);\n+        return \"Z\".equals(zone) ? \"UTC\" : zone;\n+    }\n+\n+    private static class Builder {\n+\n+        private final String pattern;\n+        private boolean lowercaseAccepted = true;\n+        private Function<String, String> fillMode = ToCharFormatter::removeLeadingZeros;\n+        private boolean hasOrdinalSuffix = true;\n+        private Function<TemporalAccessor, String> formatFn;\n+\n+        Builder(String pattern) {\n+            this.pattern = pattern;\n+        }\n+\n+        public Builder formatFn(final String javaPattern) {\n+            return formatFn(javaPattern, null);\n+        }\n+\n+        public Builder formatFn(final String javaPattern, final Function<String, String> additionalMapper) {\n+            this.formatFn = temporalAccessor -> {\n+                String formatted = DateTimeFormatter.ofPattern(javaPattern != null ? javaPattern : \"'\" + pattern + \"'\", Locale.ROOT)\n+                    .format(temporalAccessor);\n+                return additionalMapper == null ? formatted : additionalMapper.apply(formatted);\n+            };\n+            return this;\n+        }\n+\n+        public Builder formatFn(Function<TemporalAccessor, String> formatFn) {\n+            this.formatFn = formatFn;\n+            return this;\n+        }\n+\n+        public Builder noFillMode() {\n+            this.fillMode = null;\n+            return this;\n+        }\n+\n+        public Builder text() {\n+            return text(ToCharFormatter::removePadding);\n+        }\n+\n+        public Builder text(Function<String, String> fillMode) {\n+            this.hasOrdinalSuffix = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 362}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2OTUxMQ==", "bodyText": "Based on the code, it looks like the builder always ends up with text(), noFillMode or the default fill mode. If this assertion is correct, this behavior should be incapsulated in the builder to avoid calling build() and make these methods the final ones. Additionally aligned the names to better express what's going on:\ntext() -> noPadding()/removePadding()\ntext(fillMode) -> methodWithNameOfTheGivenFunction", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552069511", "createdAt": "2021-01-05T17:09:38Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,376 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::removeLeadingZerosFromOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int\n+        MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().getAsInt();\n+\n+    private final String pattern;\n+    private final boolean lowercaseAccepted;\n+    private final Function<String, String> fillMode;\n+    private final boolean hasOrdinalSuffix;\n+    private final Function<TemporalAccessor, String> formatFn;\n+\n+    private ToCharFormatter(\n+        String pattern,\n+        boolean lowercaseAccepted,\n+        Function<String, String> fillMode,\n+        boolean hasOrdinalSuffix,\n+        Function<TemporalAccessor, String> formatFn) {\n+\n+        this.pattern = pattern;\n+        this.lowercaseAccepted = lowercaseAccepted;\n+        this.fillMode = fillMode;\n+        this.hasOrdinalSuffix = hasOrdinalSuffix;\n+        this.formatFn = formatFn;\n+    }\n+\n+    private static Builder of(String pattern) {\n+        return new Builder(pattern);\n+    }\n+\n+    private String format(TemporalAccessor temporalAccessor) {\n+        return formatFn.apply(temporalAccessor);\n+    }\n+\n+    private ToCharFormatter withModifier(Function<String, String> modifierFn) {\n+        return new ToCharFormatter(pattern, lowercaseAccepted, fillMode, hasOrdinalSuffix, formatFn.andThen(modifierFn));\n+    }\n+\n+    private static List<ToCharFormatter> parsePattern(String toCharPattern) {\n+        LinkedList<ToCharFormatter> formatters = new LinkedList<>();\n+\n+        boolean fillModeModifierActive = false;\n+\n+        while (toCharPattern.isEmpty() == false) {\n+            boolean foundPattern = false;\n+            for (int length = Math.min(MAX_TO_CHAR_FORMAT_STRING_LENGTH, toCharPattern.length()); length >= 1; length--) {\n+                final String potentialPattern = toCharPattern.substring(0, length);\n+                if (isFillModeModifier(potentialPattern)) {\n+                    // try to apply the fill mode modifier to the next formatter\n+                    fillModeModifierActive = true;\n+                    foundPattern = true;\n+                } else if (isOrdinalSuffixModifier(potentialPattern)) {\n+                    // try to apply the ordinal suffix modifier to the last formatter\n+                    ToCharFormatter lastFormatter = formatters.removeLast();\n+                    if (lastFormatter == null) {\n+                        // if there was no previous pattern, simply prints the ordinal suffix pattern\n+                        lastFormatter = literal(potentialPattern);\n+                    } else if (lastFormatter.hasOrdinalSuffix) {\n+                        lastFormatter = lastFormatter.withModifier(s -> appendOrdinalSuffix(potentialPattern, s));\n+                    }\n+                    formatters.addLast(lastFormatter);\n+                    foundPattern = true;\n+                } else {\n+                    ToCharFormatter formatter = FORMATTER_MAP.get(potentialPattern);\n+                    // check if it is a known pattern string, if so apply it, with any modifier\n+                    if (formatter != null) {\n+                        if (fillModeModifierActive && formatter.fillMode != null) {\n+                            formatter = formatter.withModifier(formatter.fillMode);\n+                        }\n+                        formatters.addLast(formatter);\n+                        fillModeModifierActive = false;\n+                        foundPattern = true;\n+                    }\n+                }\n+                if (foundPattern) {\n+                    toCharPattern = toCharPattern.substring(length);\n+                    break;\n+                }\n+            }\n+            if (foundPattern == false) {\n+                // the fill mode modifier does not apply in case of literals\n+                formatters.addLast(literal(toCharPattern.substring(0, 1)));\n+                toCharPattern = toCharPattern.substring(1);\n+                fillModeModifierActive = false;\n+            }\n+        }\n+        return formatters;\n+    }\n+\n+    private static boolean isOrdinalSuffixModifier(String potentialPattern) {\n+        return \"TH\".equals(potentialPattern) || \"th\".equals(potentialPattern);\n+    }\n+\n+    private static boolean isFillModeModifier(String potentialPattern) {\n+        return \"FM\".equals(potentialPattern) || \"fm\".equals(potentialPattern);\n+    }\n+\n+    public static Function<TemporalAccessor, String> ofPattern(String pattern) {\n+        if (Strings.isEmpty(pattern)) {\n+            return timestamp -> \"\";\n+        }\n+        final List<ToCharFormatter> toCharFormatters = parsePattern(pattern);\n+        return timestamp -> toCharFormatters.stream().map(p -> p.format(timestamp)).collect(Collectors.joining());\n+    }\n+\n+    private static ToCharFormatter literal(String literal) {\n+        return new ToCharFormatter(literal, false, null, true, t -> literal);\n+    }\n+\n+    private static String ordinalSuffix(int i) {\n+        if (i < 0) {\n+            i = -i;\n+        }\n+        int mod100 = i % 100;\n+        int mod10 = i % 10;\n+        if (mod10 == 1 && mod100 != 11) {\n+            return \"st\";\n+        } else if (mod10 == 2 && mod100 != 12) {\n+            return \"nd\";\n+        } else if (mod10 == 3 && mod100 != 13) {\n+            return \"rd\";\n+        } else {\n+            return \"th\";\n+        }\n+    }\n+\n+    private static String appendOrdinalSuffix(String defaultSuffix, String s) {\n+        try {\n+            // the Y,YYY pattern might can cause problems with the parsing, but thankfully the last 3\n+            // characters is enough to calculate the suffix\n+            int i = Integer.parseInt(lastNCharacter(s, 3));\n+            final boolean upperCase = defaultSuffix.equals(defaultSuffix.toUpperCase(Locale.ROOT));\n+            return s + (upperCase ? ordinalSuffix(i).toUpperCase(Locale.ROOT) : ordinalSuffix(i));\n+        } catch (NumberFormatException ex) {\n+            return s + defaultSuffix;\n+        }\n+    }\n+\n+    private static String removeLeadingZeros(String number) {\n+        return String.valueOf(Integer.parseInt(number));\n+    }\n+\n+    private static String removePadding(String paddedText) {\n+        return paddedText.replaceAll(\" +$\", \"\");\n+    }\n+\n+    private static String formatOffset(String offset) {\n+        if (offset.equals(\"Z\")) {\n+            return \"+00\";\n+        }\n+        if (offset.matches(\"^[+-][0-9][0-9]00$\")) {\n+            offset = offset.substring(0, offset.length() - 2);\n+        } else if (offset.matches(\"^[+-][0-9]{3,4}$\")) {\n+            offset = offset.substring(0, offset.length() - 2) + \":\" + offset.substring(offset.length() - 2);\n+        } else if (offset.matches(\"^[+-][0-9][0-9]:00$\")) {\n+            offset = offset.substring(0, offset.length() - 3);\n+        }\n+        return offset.substring(0, Math.min(offset.length(), 6));\n+    }\n+\n+    private static String removeLeadingZerosFromOffset(String offset) {\n+        if (offset.matches(\"[+-]0{1,2}\")) {\n+            return offset.substring(0, 2);\n+        } else {\n+            if (offset.startsWith(\"+0\")) {\n+                return \"+\" + offset.substring(2);\n+            } else if (offset.startsWith(\"-0\")) {\n+                return \"-\" + offset.substring(2);\n+            } else {\n+                return offset;\n+            }\n+        }\n+    }\n+\n+    private static String absoluteWeekBasedYear(TemporalAccessor t) {\n+        int year = t.get(IsoFields.WEEK_BASED_YEAR);\n+        year = year > 0 ? year : -(year - 1);\n+        return String.format(Locale.ROOT, \"%04d\", year);\n+    }\n+\n+    private static String firstDigitsOfNanos(String nano, int digits) {\n+        return String.format(Locale.ROOT, \"%09d\", Integer.parseInt(nano)).substring(0, digits);\n+    }\n+\n+    private static String lastNCharacter(String s, int n) {\n+        return s.substring(Math.max(0, s.length() - n));\n+    }\n+\n+    private static String zoneAbbreviationOf(TemporalAccessor temporalAccessor) {\n+        String zone = ZoneId.from(temporalAccessor).getDisplayName(TextStyle.SHORT, Locale.ROOT);\n+        return \"Z\".equals(zone) ? \"UTC\" : zone;\n+    }\n+\n+    private static class Builder {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 322}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5975d3a60746a937e035337f2d96104c8ad4e0a0", "author": {"user": {"login": "palesz", "name": "Andras Palinkas"}}, "url": "https://github.com/elastic/elasticsearch/commit/5975d3a60746a937e035337f2d96104c8ad4e0a0", "committedDate": "2021-01-05T21:31:31Z", "message": "Merge remote-tracking branch 'origin/master' into feature/to-char-function"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYxOTYzMjY3", "url": "https://github.com/elastic/elasticsearch/pull/66486#pullrequestreview-561963267", "createdAt": "2021-01-05T16:58:34Z", "commit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNjo1ODozNVrOIOfPXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQyMTozMjowNlrOIOoTHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2MjgxNA==", "bodyText": "If you order by a field, I think it's better to show that field in the result to \"prove\" that the order is correct, otherwise the tests orders by emp_no, but one cannot tell the results are correct. This is valid for all other tests in this PR.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552062814", "createdAt": "2021-01-05T16:58:35Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/qa/server/src/main/resources/datetime.csv-spec", "diffHunk": "@@ -601,6 +601,110 @@ HAVING DATETIME_FORMAT(MAX(birth_date), 'dd')::integer > 20  ORDER BY 1 DESC;\n 1961-02-26 00:00:00.000Z | 02\n ;\n \n+selectToChar\n+schema::df_date:s|df_datetime:s|df_time:s\n+SELECT TO_CHAR('2020-04-05T11:22:33.123Z'::date, 'DD/MM/YYYY HH24:MI:SS.FF3') AS df_date,\n+TO_CHAR('2020-04-05T11:22:33.123Z'::datetime, 'DD/MM/YYYY HH24:MI:SS.FF2') AS df_datetime,\n+TO_CHAR('11:22:33.123456789Z'::time, 'HH24:MI:SS.FF2') AS df_time;\n+\n+       df_date          |    df_datetime         |   df_time\n+------------------------+------------------------+----------------\n+05/04/2020 00:00:00.000 | 05/04/2020 11:22:33.12 | 11:22:33.12\n+;\n+\n+selectToCharWithField\n+schema::birth_date:ts|gender:s|df_birth_date1:s|df_birth_date2:s\n+SELECT birth_date, gender, TO_CHAR(birth_date, 'MM/DD/YYYY') AS df_birth_date1, \n+TO_CHAR(birth_date, CONCAT(gender, 'MDD')) AS df_birth_date2 FROM test_emp WHERE emp_no BETWEEN 10047 AND 10057 ORDER BY emp_no;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2NzA0MA==", "bodyText": "Is this needed? The default implementation is doing getClass().getSimpleName().toLowerCase(Locale.ROOT) which should be toChar, if I'm not missing anything.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552067040", "createdAt": "2021-01-05T17:05:23Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToChar.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.BinaryScalarFunction;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+\n+import java.time.ZoneId;\n+\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeFormatProcessor.Formatter.TO_CHAR;\n+\n+public class ToChar extends BaseDateTimeFormatFunction {\n+    public ToChar(Source source, Expression timestamp, Expression pattern, ZoneId zoneId) {\n+        super(source, timestamp, pattern, zoneId);\n+    }\n+\n+    @Override\n+    protected DateTimeFormatProcessor.Formatter formatter() {\n+        return TO_CHAR;\n+    }\n+\n+    @Override\n+    protected NodeInfo.NodeCtor3<Expression, Expression, ZoneId, BaseDateTimeFormatFunction> ctor() {\n+        return ToChar::new;\n+    }\n+    \n+    @Override\n+    protected String scriptMethodName() {\n+        return \"toChar\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA3NTI4Ng==", "bodyText": "I would have used a [NOTE] for these two cases, as well.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552075286", "createdAt": "2021-01-05T17:18:54Z", "author": {"login": "astefan"}, "path": "docs/reference/sql/functions/date-time.asciidoc", "diffHunk": "@@ -818,6 +818,57 @@ include-tagged::{sql-specs}/docs/docs.csv-spec[formatDateTime]\n include-tagged::{sql-specs}/docs/docs.csv-spec[formatTime]\n --------------------------------------------------\n \n+\n+[[sql-functions-datetime-to_char]]\n+==== `TO_CHAR`\n+\n+.Synopsis:\n+[source, sql]\n+--------------------------------------------------\n+TO_CHAR(\n+    date_exp/datetime_exp/time_exp, <1>\n+    string_exp) <2>\n+--------------------------------------------------\n+\n+*Input*:\n+\n+<1> date/datetime/time expression\n+<2> format pattern\n+\n+*Output*: string\n+\n+*Description*: Returns the date/datetime/time as a string using the format specified in the 2nd argument. The formatting\n+pattern conforms to\n+https://www.postgresql.org/docs/13/functions-formatting.html[PostgreSQL Template Patterns for Date/Time Formatting].\n+If any of the two arguments is `null` or the pattern is an empty string `null` is returned.\n+\n+[NOTE]\n+If the 1st argument is of type `time`, then the pattern specified by the 2nd argument cannot contain date related units\n+(e.g. 'dd', 'MM', 'YYYY', etc.). If it contains such units an error is returned.\n+\n+*Special Cases*", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA3NTcyNw==", "bodyText": "Not sure if \"implemented\" should be used or \"supported\". I'd lean towards the latter though.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552075727", "createdAt": "2021-01-05T17:19:42Z", "author": {"login": "astefan"}, "path": "docs/reference/sql/functions/date-time.asciidoc", "diffHunk": "@@ -818,6 +818,57 @@ include-tagged::{sql-specs}/docs/docs.csv-spec[formatDateTime]\n include-tagged::{sql-specs}/docs/docs.csv-spec[formatTime]\n --------------------------------------------------\n \n+\n+[[sql-functions-datetime-to_char]]\n+==== `TO_CHAR`\n+\n+.Synopsis:\n+[source, sql]\n+--------------------------------------------------\n+TO_CHAR(\n+    date_exp/datetime_exp/time_exp, <1>\n+    string_exp) <2>\n+--------------------------------------------------\n+\n+*Input*:\n+\n+<1> date/datetime/time expression\n+<2> format pattern\n+\n+*Output*: string\n+\n+*Description*: Returns the date/datetime/time as a string using the format specified in the 2nd argument. The formatting\n+pattern conforms to\n+https://www.postgresql.org/docs/13/functions-formatting.html[PostgreSQL Template Patterns for Date/Time Formatting].\n+If any of the two arguments is `null` or the pattern is an empty string `null` is returned.\n+\n+[NOTE]\n+If the 1st argument is of type `time`, then the pattern specified by the 2nd argument cannot contain date related units\n+(e.g. 'dd', 'MM', 'YYYY', etc.). If it contains such units an error is returned.\n+\n+*Special Cases*\n+\n+- The result of the patterns `TZ` and `tz` (time zone abbreviations) in some cases differ from the results returned by the TO_CHAR \n+in PostgreSQL. The reason is that the time zone abbreviations specified by the JDK are different from the ones specified by PostgreSQL. \n+This function might show an actual time zone abbreviation instead of the generic `LMT` or empty string or offset returned by the PostgreSQL \n+implementation. The summer/daylight markers might also differ between the two implementations (will see `HT` instead of `HST`).\n+- The `FX`, `TM`, `SP` pattern modifiers are not implemented and will  show up as `FX`, `TM` `SP` literals in the output.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA3NzA5NA==", "bodyText": "Comma after TM in the last sentence is missing.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552077094", "createdAt": "2021-01-05T17:22:11Z", "author": {"login": "astefan"}, "path": "docs/reference/sql/functions/date-time.asciidoc", "diffHunk": "@@ -818,6 +818,57 @@ include-tagged::{sql-specs}/docs/docs.csv-spec[formatDateTime]\n include-tagged::{sql-specs}/docs/docs.csv-spec[formatTime]\n --------------------------------------------------\n \n+\n+[[sql-functions-datetime-to_char]]\n+==== `TO_CHAR`\n+\n+.Synopsis:\n+[source, sql]\n+--------------------------------------------------\n+TO_CHAR(\n+    date_exp/datetime_exp/time_exp, <1>\n+    string_exp) <2>\n+--------------------------------------------------\n+\n+*Input*:\n+\n+<1> date/datetime/time expression\n+<2> format pattern\n+\n+*Output*: string\n+\n+*Description*: Returns the date/datetime/time as a string using the format specified in the 2nd argument. The formatting\n+pattern conforms to\n+https://www.postgresql.org/docs/13/functions-formatting.html[PostgreSQL Template Patterns for Date/Time Formatting].\n+If any of the two arguments is `null` or the pattern is an empty string `null` is returned.\n+\n+[NOTE]\n+If the 1st argument is of type `time`, then the pattern specified by the 2nd argument cannot contain date related units\n+(e.g. 'dd', 'MM', 'YYYY', etc.). If it contains such units an error is returned.\n+\n+*Special Cases*\n+\n+- The result of the patterns `TZ` and `tz` (time zone abbreviations) in some cases differ from the results returned by the TO_CHAR \n+in PostgreSQL. The reason is that the time zone abbreviations specified by the JDK are different from the ones specified by PostgreSQL. \n+This function might show an actual time zone abbreviation instead of the generic `LMT` or empty string or offset returned by the PostgreSQL \n+implementation. The summer/daylight markers might also differ between the two implementations (will see `HT` instead of `HST`).\n+- The `FX`, `TM`, `SP` pattern modifiers are not implemented and will  show up as `FX`, `TM` `SP` literals in the output.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA3NTcyNw=="}, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA4MTIxNw==", "bodyText": "The list of functions in each category should be ordered alphabetically. As it is now it's wrong, not only for TO_CHAR but also (from previous code changes) for EXTRACT and TIME_PARSE functions.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552081217", "createdAt": "2021-01-05T17:28:50Z", "author": {"login": "astefan"}, "path": "docs/reference/sql/functions/index.asciidoc", "diffHunk": "@@ -59,6 +59,7 @@\n ** <<sql-functions-datetime-datetimeformat>>\n ** <<sql-functions-datetime-datetimeparse>>\n ** <<sql-functions-datetime-format>>\n+** <<sql-functions-datetime-to_char>>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA4OTk1Mg==", "bodyText": "You need a test in QueryTranslatorTests as well.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552089952", "createdAt": "2021-01-05T17:44:19Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/whitelist/InternalSqlScriptUtils.java", "diffHunk": "@@ -300,6 +300,10 @@ public static String format(Object dateTime, String pattern, String tzId) {\n         return (String) Formatter.FORMAT.format(asDateTime(dateTime), pattern, ZoneId.of(tzId));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE5NDI3OQ==", "bodyText": "And some tests in VerifierErrorMessagesTests.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552194279", "createdAt": "2021-01-05T21:06:02Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/whitelist/InternalSqlScriptUtils.java", "diffHunk": "@@ -300,6 +300,10 @@ public static String format(Object dateTime, String pattern, String tzId) {\n         return (String) Formatter.FORMAT.format(asDateTime(dateTime), pattern, ZoneId.of(tzId));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA4OTk1Mg=="}, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIwNTAzOQ==", "bodyText": "Could you take these patterns from ToCharFormatter's FORMATTER_MAP content? Manually listing that long list of patterns feels brittle to me (things could be missed).", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552205039", "createdAt": "2021-01-05T21:25:37Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    private static class TestCase {\n+        private static final AtomicInteger COUNTER = new AtomicInteger(0);\n+        \n+        // timezones that are valid both in Java and in Postgres\n+        public static final List<String> POSTGRES_TEST_ZONE_LIST = List.of(\n+            // location-based and long-names\n+            \"US/Samoa\", \"Pacific/Honolulu\", \"Pacific/Marquesas\", \"Pacific/Gambier\", \"America/Juneau\", \"Canada/Yukon\", \"America/Vancouver\",\n+            \"Pacific/Easter\", \"US/Mountain\", \"America/Chicago\", \"US/Michigan\", \"Atlantic/Bermuda\", \"Canada/Newfoundland\",\n+            \"Atlantic/Cape_Verde\", \"Pacific/Kiritimati\", \"Pacific/Chatham\", \"Pacific/Auckland\", \"Asia/Sakhalin\", \"Australia/Tasmania\", \n+            \"Australia/North\", \"Asia/Tokyo\", \"Australia/Eucla\", \"Asia/Singapore\", \"Asia/Rangoon\", \"Indian/Chagos\", \"Asia/Calcutta\", \n+            \"Asia/Tashkent\", \"Asia/Tehran\", \"Asia/Dubai\", \"Africa/Nairobi\", \"Europe/Brussels\", \"Europe/Vienna\", \"Europe/London\", \n+            \"Etc/GMT+12\",\n+            // short names of zones\n+            \"GMT\", \"UTC\", \"CET\",\n+            // offsets\n+            \"+11:00\", \"+04:30\", \"+01:00\", \"+00:00\", \"-00:00\", \"-01:15\", \"-02:00\", \"-11:00\");\n+\n+        private final int id;\n+        private final BigDecimal secondsAndFractionsSinceEpoch;\n+        private final String formatString;\n+        private final String zoneId;\n+        \n+        TestCase(BigDecimal secondsAndFractionsSinceEpoch, String formatString) {\n+            this.id = COUNTER.incrementAndGet();\n+            this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+            this.formatString = formatString;\n+            this.zoneId = TestGenerator.randomFromCollection(POSTGRES_TEST_ZONE_LIST);\n+        }\n+\n+    }\n+\n+    /**\n+     * Generates an sql file that can be used to generate the test dataset for this unit test (to be used with the <code>psql</code> cli).\n+     *\n+     * Run the @{link {@link TestGenerator#main(String[])}} class and execute the following command to generate the output dataset with:\n+     *\n+     * <p>\n+     *  <code>\n+     *      # easy way to spin up the latest Postgres\n+     *      docker run --rm --name postgres-latest -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres:latest\n+     *\n+     *      # generate the csv for the unit test\n+     *      PGPASSWORD=\"mysecretpassword\" psql --quiet -h localhost -p 5432 -U postgres -f /tmp/postgresql-tochar-test.sql \\\n+     *          &gt; /path/to/tochar.csv\n+     *  </code>\n+     * </p>\n+     */\n+    private static class TestGenerator {\n+        \n+        private static final long SECONDS_IN_YEAR = 365 * 24 * 60 * 60L;\n+        private static final String DELIMITER = \"|\";\n+        private static final String PATTERN_DELIMITER = \" @ \";\n+        // these patterns are hard to sync up between PostgreSQL and Elasticsearch, so we just warn, but actually\n+        // accept the output of Elasticsearch as is\n+        private static final Set<String> NOT_FULLY_MATCHABLE_PATTERNS = Set.of(\"TZ\", \"tz\");\n+        private static final Set<String> UNSUPPORTED_PATTERN_MODIFIERS = Set.of(\"FX\", \"TM\", \"SP\");\n+        private static final String[] PATTERNS = new String[] {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIwNzI0Mw==", "bodyText": "Any good reason for not using ESTestCase's random() ?", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552207243", "createdAt": "2021-01-05T21:27:38Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    private static class TestCase {\n+        private static final AtomicInteger COUNTER = new AtomicInteger(0);\n+        \n+        // timezones that are valid both in Java and in Postgres\n+        public static final List<String> POSTGRES_TEST_ZONE_LIST = List.of(\n+            // location-based and long-names\n+            \"US/Samoa\", \"Pacific/Honolulu\", \"Pacific/Marquesas\", \"Pacific/Gambier\", \"America/Juneau\", \"Canada/Yukon\", \"America/Vancouver\",\n+            \"Pacific/Easter\", \"US/Mountain\", \"America/Chicago\", \"US/Michigan\", \"Atlantic/Bermuda\", \"Canada/Newfoundland\",\n+            \"Atlantic/Cape_Verde\", \"Pacific/Kiritimati\", \"Pacific/Chatham\", \"Pacific/Auckland\", \"Asia/Sakhalin\", \"Australia/Tasmania\", \n+            \"Australia/North\", \"Asia/Tokyo\", \"Australia/Eucla\", \"Asia/Singapore\", \"Asia/Rangoon\", \"Indian/Chagos\", \"Asia/Calcutta\", \n+            \"Asia/Tashkent\", \"Asia/Tehran\", \"Asia/Dubai\", \"Africa/Nairobi\", \"Europe/Brussels\", \"Europe/Vienna\", \"Europe/London\", \n+            \"Etc/GMT+12\",\n+            // short names of zones\n+            \"GMT\", \"UTC\", \"CET\",\n+            // offsets\n+            \"+11:00\", \"+04:30\", \"+01:00\", \"+00:00\", \"-00:00\", \"-01:15\", \"-02:00\", \"-11:00\");\n+\n+        private final int id;\n+        private final BigDecimal secondsAndFractionsSinceEpoch;\n+        private final String formatString;\n+        private final String zoneId;\n+        \n+        TestCase(BigDecimal secondsAndFractionsSinceEpoch, String formatString) {\n+            this.id = COUNTER.incrementAndGet();\n+            this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+            this.formatString = formatString;\n+            this.zoneId = TestGenerator.randomFromCollection(POSTGRES_TEST_ZONE_LIST);\n+        }\n+\n+    }\n+\n+    /**\n+     * Generates an sql file that can be used to generate the test dataset for this unit test (to be used with the <code>psql</code> cli).\n+     *\n+     * Run the @{link {@link TestGenerator#main(String[])}} class and execute the following command to generate the output dataset with:\n+     *\n+     * <p>\n+     *  <code>\n+     *      # easy way to spin up the latest Postgres\n+     *      docker run --rm --name postgres-latest -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres:latest\n+     *\n+     *      # generate the csv for the unit test\n+     *      PGPASSWORD=\"mysecretpassword\" psql --quiet -h localhost -p 5432 -U postgres -f /tmp/postgresql-tochar-test.sql \\\n+     *          &gt; /path/to/tochar.csv\n+     *  </code>\n+     * </p>\n+     */\n+    private static class TestGenerator {\n+        \n+        private static final long SECONDS_IN_YEAR = 365 * 24 * 60 * 60L;\n+        private static final String DELIMITER = \"|\";\n+        private static final String PATTERN_DELIMITER = \" @ \";\n+        // these patterns are hard to sync up between PostgreSQL and Elasticsearch, so we just warn, but actually\n+        // accept the output of Elasticsearch as is\n+        private static final Set<String> NOT_FULLY_MATCHABLE_PATTERNS = Set.of(\"TZ\", \"tz\");\n+        private static final Set<String> UNSUPPORTED_PATTERN_MODIFIERS = Set.of(\"FX\", \"TM\", \"SP\");\n+        private static final String[] PATTERNS = new String[] {\n+            \"HH\", \"HH12\", \"HH24\", \"MI\", \"SS\", \"MS\", \"US\", \"FF1\", \"FF2\", \"FF3\", \"FF4\", \"FF5\", \"FF6\", \"SSSS\", \"SSSSS\", \"AM\", \"am\", \"PM\",\n+            \"pm\", \"A.M.\", \"a.m.\", \"P.M.\", \"p.m.\", \"Y,YYY\", \"YYYY\", \"YYY\", \"YY\", \"Y\", \"IYYY\", \"IYY\", \"IY\", \"I\", \"BC\", \"bc\", \"AD\", \"ad\",\n+            \"B.C.\", \"b.c.\", \"A.D.\", \"a.d.\", \"MONTH\", \"Month\", \"month\", \"MON\", \"Mon\", \"mon\", \"MM\", \"DAY\", \"Day\", \"day\", \"DY\", \"Dy\",\n+            \"dy\", \"DDD\", \"IDDD\", \"DD\", \"D\", \"ID\", \"W\", \"WW\", \"IW\", \"CC\", \"J\", \"Q\", \"RM\", \"rm\", \"TZ\", \"tz\", \"TZH\", \"TZM\", \"OF\"\n+        };\n+        private static final List<String> FILL_MODIFIERS = List.of(\"FM\", \"fm\", \"\");\n+        private static final List<String> ORDINAL_SUFFIX_MODIFIERS = List.of(\"TH\", \"th\", \"\");\n+\n+        @SuppressForbidden(reason = \"It is ok to use ThreadLocalRandom outside of an actual test\")\n+        private static Random rnd() {\n+            return ThreadLocalRandom.current();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIxMTIyOQ==", "bodyText": "Our test infra does have a lot of helper methods for generating random stuff. I feel like you are re-inventing the wheel here with all the randomization logic in this class.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552211229", "createdAt": "2021-01-05T21:32:06Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    private static class TestCase {\n+        private static final AtomicInteger COUNTER = new AtomicInteger(0);\n+        \n+        // timezones that are valid both in Java and in Postgres\n+        public static final List<String> POSTGRES_TEST_ZONE_LIST = List.of(\n+            // location-based and long-names\n+            \"US/Samoa\", \"Pacific/Honolulu\", \"Pacific/Marquesas\", \"Pacific/Gambier\", \"America/Juneau\", \"Canada/Yukon\", \"America/Vancouver\",\n+            \"Pacific/Easter\", \"US/Mountain\", \"America/Chicago\", \"US/Michigan\", \"Atlantic/Bermuda\", \"Canada/Newfoundland\",\n+            \"Atlantic/Cape_Verde\", \"Pacific/Kiritimati\", \"Pacific/Chatham\", \"Pacific/Auckland\", \"Asia/Sakhalin\", \"Australia/Tasmania\", \n+            \"Australia/North\", \"Asia/Tokyo\", \"Australia/Eucla\", \"Asia/Singapore\", \"Asia/Rangoon\", \"Indian/Chagos\", \"Asia/Calcutta\", \n+            \"Asia/Tashkent\", \"Asia/Tehran\", \"Asia/Dubai\", \"Africa/Nairobi\", \"Europe/Brussels\", \"Europe/Vienna\", \"Europe/London\", \n+            \"Etc/GMT+12\",\n+            // short names of zones\n+            \"GMT\", \"UTC\", \"CET\",\n+            // offsets\n+            \"+11:00\", \"+04:30\", \"+01:00\", \"+00:00\", \"-00:00\", \"-01:15\", \"-02:00\", \"-11:00\");\n+\n+        private final int id;\n+        private final BigDecimal secondsAndFractionsSinceEpoch;\n+        private final String formatString;\n+        private final String zoneId;\n+        \n+        TestCase(BigDecimal secondsAndFractionsSinceEpoch, String formatString) {\n+            this.id = COUNTER.incrementAndGet();\n+            this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+            this.formatString = formatString;\n+            this.zoneId = TestGenerator.randomFromCollection(POSTGRES_TEST_ZONE_LIST);\n+        }\n+\n+    }\n+\n+    /**\n+     * Generates an sql file that can be used to generate the test dataset for this unit test (to be used with the <code>psql</code> cli).\n+     *\n+     * Run the @{link {@link TestGenerator#main(String[])}} class and execute the following command to generate the output dataset with:\n+     *\n+     * <p>\n+     *  <code>\n+     *      # easy way to spin up the latest Postgres\n+     *      docker run --rm --name postgres-latest -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres:latest\n+     *\n+     *      # generate the csv for the unit test\n+     *      PGPASSWORD=\"mysecretpassword\" psql --quiet -h localhost -p 5432 -U postgres -f /tmp/postgresql-tochar-test.sql \\\n+     *          &gt; /path/to/tochar.csv\n+     *  </code>\n+     * </p>\n+     */\n+    private static class TestGenerator {\n+        \n+        private static final long SECONDS_IN_YEAR = 365 * 24 * 60 * 60L;\n+        private static final String DELIMITER = \"|\";\n+        private static final String PATTERN_DELIMITER = \" @ \";\n+        // these patterns are hard to sync up between PostgreSQL and Elasticsearch, so we just warn, but actually\n+        // accept the output of Elasticsearch as is\n+        private static final Set<String> NOT_FULLY_MATCHABLE_PATTERNS = Set.of(\"TZ\", \"tz\");\n+        private static final Set<String> UNSUPPORTED_PATTERN_MODIFIERS = Set.of(\"FX\", \"TM\", \"SP\");\n+        private static final String[] PATTERNS = new String[] {\n+            \"HH\", \"HH12\", \"HH24\", \"MI\", \"SS\", \"MS\", \"US\", \"FF1\", \"FF2\", \"FF3\", \"FF4\", \"FF5\", \"FF6\", \"SSSS\", \"SSSSS\", \"AM\", \"am\", \"PM\",\n+            \"pm\", \"A.M.\", \"a.m.\", \"P.M.\", \"p.m.\", \"Y,YYY\", \"YYYY\", \"YYY\", \"YY\", \"Y\", \"IYYY\", \"IYY\", \"IY\", \"I\", \"BC\", \"bc\", \"AD\", \"ad\",\n+            \"B.C.\", \"b.c.\", \"A.D.\", \"a.d.\", \"MONTH\", \"Month\", \"month\", \"MON\", \"Mon\", \"mon\", \"MM\", \"DAY\", \"Day\", \"day\", \"DY\", \"Dy\",\n+            \"dy\", \"DDD\", \"IDDD\", \"DD\", \"D\", \"ID\", \"W\", \"WW\", \"IW\", \"CC\", \"J\", \"Q\", \"RM\", \"rm\", \"TZ\", \"tz\", \"TZH\", \"TZM\", \"OF\"\n+        };\n+        private static final List<String> FILL_MODIFIERS = List.of(\"FM\", \"fm\", \"\");\n+        private static final List<String> ORDINAL_SUFFIX_MODIFIERS = List.of(\"TH\", \"th\", \"\");\n+\n+        @SuppressForbidden(reason = \"It is ok to use ThreadLocalRandom outside of an actual test\")\n+        private static Random rnd() {\n+            return ThreadLocalRandom.current();\n+        }\n+\n+        private static BigDecimal randomSecondsWithFractions(int minYear, int maxYear) {\n+            BigDecimal seconds = new BigDecimal(RandomNumbers.randomLongBetween(rnd(), \n+                (minYear - 1970) * SECONDS_IN_YEAR, (maxYear - 1970) * SECONDS_IN_YEAR));\n+            BigDecimal fractions = new BigDecimal(RandomNumbers.randomIntBetween(rnd(), 0, 999_999)).movePointLeft(6);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 114}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e1c373e1e9fa444f9a6ad4ea02fe45cbd81106a3", "author": {"user": {"login": "palesz", "name": "Andras Palinkas"}}, "url": "https://github.com/elastic/elasticsearch/commit/e1c373e1e9fa444f9a6ad4ea02fe45cbd81106a3", "committedDate": "2021-01-05T23:56:51Z", "message": "PR suggestions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6e9e8525c376cf2dbd6acab7d8e92b11229c5c36", "author": {"user": {"login": "palesz", "name": "Andras Palinkas"}}, "url": "https://github.com/elastic/elasticsearch/commit/6e9e8525c376cf2dbd6acab7d8e92b11229c5c36", "committedDate": "2021-01-05T23:57:48Z", "message": "Merge remote-tracking branch 'origin/master' into feature/to-char-function"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "20eb9356bfdb9260c46091870288cdc2f90a09ad", "author": {"user": {"login": "palesz", "name": "Andras Palinkas"}}, "url": "https://github.com/elastic/elasticsearch/commit/20eb9356bfdb9260c46091870288cdc2f90a09ad", "committedDate": "2021-01-06T01:50:29Z", "message": "Merge remote-tracking branch 'origin/master' into feature/to-char-function"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1NjEwNzg0", "url": "https://github.com/elastic/elasticsearch/pull/66486#pullrequestreview-555610784", "createdAt": "2020-12-18T15:57:45Z", "commit": {"oid": "5babe13ca152b6d4b2cd38bc2c435fa0c50060b9"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxNTo1Nzo0NlrOIIow3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxNDoyNjozNVrOIPDwmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTkyNzM4OQ==", "bodyText": "A matter of taste, I guess.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return year % 100 == 0 ? year / 100 : year / 100 + 1;\n          \n          \n            \n                        return year / 100 + (year % 100 == 0 ? 0 : 1);", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545927389", "createdAt": "2020-12-18T15:57:46Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/util/DateUtils.java", "diffHunk": "@@ -216,6 +216,45 @@ public static TemporalAccessor atTimeZone(TemporalAccessor ta, ZoneId zoneId) {\n         }\n     }\n \n+    public static String toRome(int month) {\n+        switch (month) {\n+            case 1:\n+                return \"I\";\n+            case 2:\n+                return \"II\";\n+            case 3:\n+                return \"III\";\n+            case 4:\n+                return \"IV\";\n+            case 5:\n+                return \"V\";\n+            case 6:\n+                return \"VI\";\n+            case 7:\n+                return \"VII\";\n+            case 8:\n+                return \"VIII\";\n+            case 9:\n+                return \"IX\";\n+            case 10:\n+                return \"X\";\n+            case 11:\n+                return \"XI\";\n+            case 12:\n+                return \"XII\";\n+            default:\n+                throw new IllegalArgumentException(\"invalid month: \" + month);\n+        }\n+    }\n+\n+    public static int century(int year) {\n+        if (year > 0) {\n+            return year % 100 == 0 ? year / 100 : year / 100 + 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5babe13ca152b6d4b2cd38bc2c435fa0c50060b9"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTkyOTcwNg==", "bodyText": "I would have indexed an array, but this works too. (I guess this is imported from the original PR).", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r545929706", "createdAt": "2020-12-18T16:01:52Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/util/DateUtils.java", "diffHunk": "@@ -216,6 +216,45 @@ public static TemporalAccessor atTimeZone(TemporalAccessor ta, ZoneId zoneId) {\n         }\n     }\n \n+    public static String toRome(int month) {\n+        switch (month) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5babe13ca152b6d4b2cd38bc2c435fa0c50060b9"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjY2MTE0Nw==", "bodyText": "Thx.\n\n.remove(formatters.size() - 1) requires iteration over the list.\n\nA shift would be needed, I believe, but not when popping the last element. Just a FYI, I agree removeLast() is simpler.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r552661147", "createdAt": "2021-01-06T14:26:35Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.sql.util.DateUtils.century;\n+import static org.elasticsearch.xpack.sql.util.DateUtils.toRome;\n+\n+class ToCharFormatter {\n+\n+    private static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            ToCharFormatter.of(\"HH\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH12\").formatFn(\"hh\"),\n+            ToCharFormatter.of(\"HH24\").formatFn(\"HH\"),\n+            ToCharFormatter.of(\"MI\").formatFn(\"mm\"),\n+            ToCharFormatter.of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).noFillMode(),\n+            ToCharFormatter.of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).noFillMode(),\n+            ToCharFormatter.of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).noFillMode(),\n+            ToCharFormatter.of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).noFillMode(),\n+            ToCharFormatter.of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).noFillMode(),\n+            ToCharFormatter.of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).noFillMode(),\n+            ToCharFormatter.of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(Integer.parseInt(milliSecondOfDay) / 1000)),\n+            ToCharFormatter.of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).noFillMode(),\n+            ToCharFormatter.of(\"YYYY\").formatFn(\"yyyy\"),\n+            ToCharFormatter.of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"YY\").formatFn(\"yy\"),\n+            ToCharFormatter.of(\"Y\").formatFn(\"yy\", year -> year.substring(1)),\n+            ToCharFormatter.of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)),\n+            ToCharFormatter.of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)),\n+            ToCharFormatter.of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)),\n+            ToCharFormatter.of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)),\n+            ToCharFormatter.of(\"BC\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"AD\").formatFn(\"G\").text(),\n+            ToCharFormatter.of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            ToCharFormatter.of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Mon\").formatFn(\"MMM\").text(),\n+            ToCharFormatter.of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"MM\").formatFn(\"MM\"),\n+            ToCharFormatter.of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            ToCharFormatter.of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            ToCharFormatter.of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"Dy\").formatFn(\"E\").text(),\n+            ToCharFormatter.of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"DDD\").formatFn(\"DDD\"),\n+            ToCharFormatter.of(\"IDDD\")\n+                .formatFn(t -> String.format(Locale.ROOT,\n+                    \"%03d\",\n+                    (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))),\n+            ToCharFormatter.of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", Integer.parseInt(x))),\n+            ToCharFormatter.of(\"ID\").formatFn(\"e\"),\n+            ToCharFormatter.of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))),\n+            ToCharFormatter.of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))),\n+            ToCharFormatter.of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))),\n+            ToCharFormatter.of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))),\n+            ToCharFormatter.of(\"CC\").formatFn(t -> {\n+                int century = century(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }),\n+            ToCharFormatter.of(\"J\").formatFn(\"g\", modifiedJulianDay -> String.valueOf(Integer.parseInt(modifiedJulianDay) + 2400001)),\n+            ToCharFormatter.of(\"Q\").formatFn(\"Q\"),\n+            ToCharFormatter.of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)))).text(),\n+            ToCharFormatter.of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", toRome(Integer.parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            ToCharFormatter.of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            ToCharFormatter.of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            ToCharFormatter.of(\"TZH\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            ToCharFormatter.of(\"TZM\").lowercaseAccepted(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            ToCharFormatter.of(\"OF\")\n+                .lowercaseAccepted(false)\n+                .formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset)\n+                .text(ToCharFormatter::fillOffset)).stream().map(Builder::build).collect(Collectors.toList());\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.lowercaseAccepted) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") private static final int\n+        MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().getAsInt();\n+\n+    private final String pattern;\n+    private final boolean lowercaseAccepted;\n+    private final Function<String, String> fillMode;\n+    private final boolean hasOrdinalSuffix;\n+    private final Function<TemporalAccessor, String> formatFn;\n+\n+    private ToCharFormatter(\n+        String pattern,\n+        boolean lowercaseAccepted,\n+        Function<String, String> fillMode,\n+        boolean hasOrdinalSuffix,\n+        Function<TemporalAccessor, String> formatFn) {\n+\n+        this.pattern = pattern;\n+        this.lowercaseAccepted = lowercaseAccepted;\n+        this.fillMode = fillMode;\n+        this.hasOrdinalSuffix = hasOrdinalSuffix;\n+        this.formatFn = formatFn;\n+    }\n+\n+    private static Builder of(String pattern) {\n+        return new Builder(pattern);\n+    }\n+\n+    private String format(TemporalAccessor temporalAccessor) {\n+        return formatFn.apply(temporalAccessor);\n+    }\n+\n+    private ToCharFormatter withModifier(Function<String, String> modifierFn) {\n+        return new ToCharFormatter(pattern, lowercaseAccepted, fillMode, hasOrdinalSuffix, formatFn.andThen(modifierFn));\n+    }\n+\n+    private static List<ToCharFormatter> parsePattern(String toCharPattern) {\n+        LinkedList<ToCharFormatter> formatters = new LinkedList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg4NTcxMQ=="}, "originalCommit": {"oid": "5babe13ca152b6d4b2cd38bc2c435fa0c50060b9"}, "originalPosition": 168}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7d25b353205f8d0ca7cfb001e1d501045860710a", "author": {"user": {"login": "palesz", "name": "Andras Palinkas"}}, "url": "https://github.com/elastic/elasticsearch/commit/7d25b353205f8d0ca7cfb001e1d501045860710a", "committedDate": "2021-01-06T17:44:21Z", "message": "PR suggestions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5c4ad485a652ed0272e5145cdd9ceb2dd7ebebd1", "author": {"user": {"login": "palesz", "name": "Andras Palinkas"}}, "url": "https://github.com/elastic/elasticsearch/commit/5c4ad485a652ed0272e5145cdd9ceb2dd7ebebd1", "committedDate": "2021-01-06T18:32:50Z", "message": "PR suggestions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6439c669ab52a0c8cdc0a3faf85bf459b2d85532", "author": {"user": {"login": "palesz", "name": "Andras Palinkas"}}, "url": "https://github.com/elastic/elasticsearch/commit/6439c669ab52a0c8cdc0a3faf85bf459b2d85532", "committedDate": "2021-01-06T18:55:20Z", "message": "Merge remote-tracking branch 'origin/master' into feature/to-char-function"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "49a036095ea65cf07249ac15e22e99416df4a18c", "author": {"user": {"login": "palesz", "name": "Andras Palinkas"}}, "url": "https://github.com/elastic/elasticsearch/commit/49a036095ea65cf07249ac15e22e99416df4a18c", "committedDate": "2021-01-06T19:11:29Z", "message": "QueryTranslator and VerifierErrorMessages tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ffbdb3f4aaea069ce5bd2f11b1333ced8580a963", "author": {"user": {"login": "palesz", "name": "Andras Palinkas"}}, "url": "https://github.com/elastic/elasticsearch/commit/ffbdb3f4aaea069ce5bd2f11b1333ced8580a963", "committedDate": "2021-01-06T19:11:39Z", "message": "Merge remote-tracking branch 'origin/master' into feature/to-char-function"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYzMzQ0ODY4", "url": "https://github.com/elastic/elasticsearch/pull/66486#pullrequestreview-563344868", "createdAt": "2021-01-07T09:45:58Z", "commit": {"oid": "ffbdb3f4aaea069ce5bd2f11b1333ced8580a963"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QwOTo0NTo1OFrOIPlvmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QwOTo0ODozNFrOIPl17g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzIxNzk0NA==", "bodyText": "Store the result in current directory, it's much more common - /tmp is not portable nor something where folks will typically look.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r553217944", "createdAt": "2021-01-07T09:45:58Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharTestScript.java", "diffHunk": "@@ -0,0 +1,242 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.common.util.set.Sets;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+/**\n+ * Generates an psql file that can be used to generate the test dataset for the {@link DateTimeToCharProcessorTests}.\n+ */\n+public class ToCharTestScript {\n+\n+    private static class TestRecord {\n+\n+        // timezones that are valid both in Java and in Postgres\n+        public static final List<String> POSTGRES_TEST_ZONE_LIST = asList(\n+            // location-based and long-names\n+            \"US/Samoa\", \"Pacific/Honolulu\", \"Pacific/Marquesas\", \"Pacific/Gambier\", \"America/Juneau\", \"Canada/Yukon\", \"America/Vancouver\",\n+            \"Pacific/Easter\", \"US/Mountain\", \"America/Chicago\", \"US/Michigan\", \"Atlantic/Bermuda\", \"Canada/Newfoundland\",\n+            \"Atlantic/Cape_Verde\", \"Pacific/Kiritimati\", \"Pacific/Chatham\", \"Pacific/Auckland\", \"Asia/Sakhalin\", \"Australia/Tasmania\",\n+            \"Australia/North\", \"Asia/Tokyo\", \"Australia/Eucla\", \"Asia/Singapore\", \"Asia/Rangoon\", \"Indian/Chagos\", \"Asia/Calcutta\",\n+            \"Asia/Tashkent\", \"Asia/Tehran\", \"Asia/Dubai\", \"Africa/Nairobi\", \"Europe/Brussels\", \"Europe/Vienna\", \"Europe/London\",\n+            \"Etc/GMT+12\",\n+            // short names of zones\n+            \"GMT\", \"UTC\", \"CET\",\n+            // offsets\n+            \"+11:00\", \"+04:30\", \"+01:00\", \"+00:00\", \"-00:00\", \"-01:15\", \"-02:00\", \"-11:00\");\n+        \n+        private final BigDecimal secondsAndFractionsSinceEpoch;\n+        private final String formatString;\n+        private final String zoneId;\n+\n+        TestRecord(BigDecimal secondsAndFractionsSinceEpoch, String formatString) {\n+            this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+            this.formatString = formatString;\n+            this.zoneId = ToCharTestScript.randomFromCollection(POSTGRES_TEST_ZONE_LIST);\n+        }\n+\n+    }\n+\n+    private static final long SECONDS_IN_YEAR = 365 * 24 * 60 * 60L;\n+    public static final String DELIMITER = \"|\";\n+    public static final String PATTERN_DELIMITER = \" @ \";\n+    // these patterns are hard to sync up between PostgreSQL and Elasticsearch, so we just warn, but actually\n+    // accept the output of Elasticsearch as is\n+    public static final Set<String> NOT_FULLY_MATCHABLE_PATTERNS = Set.of(\"TZ\", \"tz\");\n+    private static final Set<String> UNSUPPORTED_PATTERN_MODIFIERS = Set.of(\"FX\", \"TM\", \"SP\");\n+    private static final List<String> PATTERNS = new ArrayList<>(ToCharFormatter.FORMATTER_MAP.keySet());\n+    private static final List<String> FILL_MODIFIERS = asList(\"FM\", \"fm\", \"\");\n+    private static final List<String> ORDINAL_SUFFIX_MODIFIERS = asList(\"TH\", \"th\", \"\");\n+\n+    private final List<TestRecord> testRecords = new ArrayList<>();\n+    private final List<BigDecimal> testEpochSeconds = new ArrayList<>();\n+\n+    @SuppressForbidden(reason = \"It is ok to use ThreadLocalRandom outside of an actual test\")\n+    private static Random rnd() {\n+        return ThreadLocalRandom.current();\n+    }\n+\n+    public ToCharTestScript() {\n+        generateTestTimestamps();\n+        \n+        patternsOneByOne();\n+        allPatternsTogether();\n+        lowercasePatterns();\n+        postgreSQLPatternParsingBehaviour();\n+        monthsAsRomanNumbers();\n+        randomizedPatternStrings();\n+    }\n+\n+    private void generateTestTimestamps() {\n+        final int latestYearToTest = 3000;\n+        int countOfTestYears = 150;\n+        for (int i = 0; i < countOfTestYears; i++) {\n+            testEpochSeconds.add(randomSecondsWithFractions(-latestYearToTest, latestYearToTest));\n+        }\n+\n+        int countOfTestYearsAroundYearZero = 10;\n+        for (int i = 0; i < countOfTestYearsAroundYearZero; i++) {\n+            testEpochSeconds.add(randomSecondsWithFractions(-1, 1));\n+        }\n+    }\n+\n+    private void patternsOneByOne() {\n+        for (String pattern : PATTERNS) {\n+            testRecords.add(new TestRecord(\n+                randomFromCollection(testEpochSeconds),\n+                NOT_FULLY_MATCHABLE_PATTERNS.contains(pattern) ?\n+                    pattern :\n+                    String.join(PATTERN_DELIMITER, pattern, FILL_MODIFIERS.get(0) + pattern + ORDINAL_SUFFIX_MODIFIERS.get(0))));\n+        }\n+    }\n+\n+    private void allPatternsTogether() {\n+        for (BigDecimal es : testEpochSeconds) {\n+            testRecords.add(new TestRecord(\n+                es,\n+                IntStream.range(0, PATTERNS.size())\n+                    .mapToObj(idx -> idx + \":\" + patternWithRandomModifiers(PATTERNS.get(idx)))\n+                    .collect(Collectors.joining(PATTERN_DELIMITER))));\n+        }\n+    }\n+\n+    private void lowercasePatterns() {\n+        testRecords.add(new TestRecord(\n+            randomFromCollection(testEpochSeconds),\n+            IntStream.range(0, PATTERNS.size())\n+                .mapToObj(idx -> (idx + \":\" + patternWithRandomModifiers(PATTERNS.get(idx))).toLowerCase(Locale.ROOT))\n+                .collect(Collectors.joining(PATTERN_DELIMITER))));\n+    }\n+\n+    private void postgreSQLPatternParsingBehaviour() {\n+        // potentially ambiguous format string test cases, to check if our format string parsing is in-sync with PostgreSQL\n+        // that is greedy and prefers the longer format strings\n+        testRecords.add(new TestRecord(randomFromCollection(testEpochSeconds), \"YYYYYYYYYYYYYYY,YYYYYYYYY\"));\n+        testRecords.add(new TestRecord(randomFromCollection(testEpochSeconds), \"SSSSSSSSSSSSSSSS\"));\n+        testRecords.add(new TestRecord(randomFromCollection(testEpochSeconds), \"DDDDDDDD\"));\n+    }\n+\n+    private void monthsAsRomanNumbers() {\n+        for (int i = 1; i <= 12; i++) {\n+            testRecords.add(new TestRecord(\n+                new BigDecimal(dateTime(0).withMonth(i).toEpochSecond()),\n+                rnd().nextBoolean() ? \"RM\" : \"rm\"));\n+        }\n+    }\n+\n+    private void randomizedPatternStrings() {\n+        final String randomCharacters = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYabcdefghijklmnopqrstuvwxy _-.:;\";\n+\n+        final int randomizedPatternCount = 20;\n+        final int lengthOfRandomizedPattern = 30;\n+        final int pctChanceOfRandomCharacter = 80;\n+        for (int i = 0; i < randomizedPatternCount; i++) {\n+            String patternWithLiterals = IntStream.rangeClosed(1, lengthOfRandomizedPattern)\n+                    .mapToObj(idx -> {\n+                        if (rnd().nextInt(100) < pctChanceOfRandomCharacter) {\n+                            return randomCharacters.substring(rnd().nextInt(randomCharacters.length())).substring(0, 1);\n+                        } else {\n+                            return (randomFromCollection(FILL_MODIFIERS) + randomFromCollection(PATTERNS) \n+                                + randomFromCollection(ORDINAL_SUFFIX_MODIFIERS));\n+                        }})\n+                    .collect(Collectors.joining());\n+\n+            // clean up the random string from the unsupported modifiers\n+            for (String unsupportedPatternModifier : Sets.union(UNSUPPORTED_PATTERN_MODIFIERS, NOT_FULLY_MATCHABLE_PATTERNS)) {\n+                patternWithLiterals = patternWithLiterals\n+                    .replace(unsupportedPatternModifier, \"\")\n+                    .replace(unsupportedPatternModifier.toLowerCase(Locale.ROOT), \"\");\n+            }\n+            testRecords.add(new TestRecord(randomFromCollection(testEpochSeconds), patternWithLiterals));\n+        }\n+    }\n+\n+    private static BigDecimal randomSecondsWithFractions(int minYear, int maxYear) {\n+        BigDecimal seconds =\n+            new BigDecimal(RandomNumbers.randomLongBetween(rnd(), (minYear - 1970) * SECONDS_IN_YEAR, (maxYear - 1970) * SECONDS_IN_YEAR));\n+        BigDecimal fractions = new BigDecimal(RandomNumbers.randomIntBetween(rnd(), 0, 999_999)).movePointLeft(6);\n+        return seconds.add(fractions);\n+    }\n+\n+    private static <T> T randomFromCollection(Collection<T> list) {\n+        List<T> l = new ArrayList<>(list);\n+        return l.get(rnd().nextInt(l.size()));\n+    }\n+\n+    private static String patternWithRandomModifiers(String pattern) {\n+        if (NOT_FULLY_MATCHABLE_PATTERNS.contains(pattern)) {\n+            return pattern;\n+        }\n+        return randomFromCollection(FILL_MODIFIERS) + pattern + randomFromCollection(ORDINAL_SUFFIX_MODIFIERS);\n+    }\n+\n+    private static String adjustZoneIdToPostgres(String zoneId) {\n+        // when the zone is specified by the offset in Postgres, it follows the POSIX definition, so the +- signs are flipped\n+        // compared to ISO-8601, see more info at: https://www.postgresql.org/docs/current/datetime-posix-timezone-specs.html\n+        if (zoneId.startsWith(\"+\")) {\n+            zoneId = zoneId.replaceFirst(quote(\"+\"), \"-\");\n+        } else if (zoneId.startsWith(\"-\")) {\n+            zoneId = zoneId.replaceFirst(quote(\"-\"), \"+\");\n+        }\n+        return zoneId;\n+    }\n+\n+    /**\n+     * Generates an SQL file (psql input) that can be used to create the test dataset for the unit test of the <code>TO_CHAR</code>\n+     * implementation. In case the <code>TO_CHAR</code> implementation needs an upgrade, add the list of the new format\n+     * strings to the list of the format string, regenerate the SQL, run it against the PostgreSQL version you are targeting\n+     * and update the test CSV file.\n+     */\n+    private String unitTestExporterScript() {\n+        String header =\n+            \"\\n\\\\echo #\" +\n+            \"\\n\\\\echo # DO NOT EDIT manually, was generated using \" + ToCharTestScript.class.getName() +\n+            \"\\n\\\\echo #\\n\\n\";\n+        String testCases = testRecords.stream().map(tc -> {\n+            long seconds = tc.secondsAndFractionsSinceEpoch.longValue();\n+            BigDecimal fractions = tc.secondsAndFractionsSinceEpoch.remainder(BigDecimal.ONE).movePointRight(6);\n+            return String.format(Locale.ROOT, \n+                \"SET TIME ZONE '%6$s';\\n\"\n+                    + \"\\\\copy (SELECT %1$s as epoch_seconds_and_microsends, '%5$s' as zone_id, '%4$s' as format_string, \" \n+                    + \"(TO_TIMESTAMP(%2$d) + INTERVAL '%3$d microseconds') as to_timestamp_result, \"\n+                    + \"TO_CHAR((TO_TIMESTAMP(%2$d) + INTERVAL '%3$d microseconds'), '%4$s') as to_char_result) to stdout \" \n+                    + \"with DELIMITER as '\" + DELIMITER + \"' NULL as '' csv \\n\",\n+                tc.secondsAndFractionsSinceEpoch.toPlainString(),\n+                seconds,\n+                fractions.intValue(),\n+                tc.formatString,\n+                tc.zoneId,\n+                adjustZoneIdToPostgres(tc.zoneId));\n+        }).collect(Collectors.joining(\"\\n\"));\n+        return header + testCases;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        String scriptFilename = args.length < 1 ? \"/tmp/postgresql-tochar-test.sql\" : args[0];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ffbdb3f4aaea069ce5bd2f11b1333ced8580a963"}, "originalPosition": 239}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzIxOTU2Ng==", "bodyText": "Instead of calling the test suite Random externally, which is unsupported since there are no guarantees about its initialization, simply the ESTestCase.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r553219566", "createdAt": "2021-01-07T09:48:34Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    private static class TestCase {\n+        private static final AtomicInteger COUNTER = new AtomicInteger(0);\n+        \n+        // timezones that are valid both in Java and in Postgres\n+        public static final List<String> POSTGRES_TEST_ZONE_LIST = List.of(\n+            // location-based and long-names\n+            \"US/Samoa\", \"Pacific/Honolulu\", \"Pacific/Marquesas\", \"Pacific/Gambier\", \"America/Juneau\", \"Canada/Yukon\", \"America/Vancouver\",\n+            \"Pacific/Easter\", \"US/Mountain\", \"America/Chicago\", \"US/Michigan\", \"Atlantic/Bermuda\", \"Canada/Newfoundland\",\n+            \"Atlantic/Cape_Verde\", \"Pacific/Kiritimati\", \"Pacific/Chatham\", \"Pacific/Auckland\", \"Asia/Sakhalin\", \"Australia/Tasmania\", \n+            \"Australia/North\", \"Asia/Tokyo\", \"Australia/Eucla\", \"Asia/Singapore\", \"Asia/Rangoon\", \"Indian/Chagos\", \"Asia/Calcutta\", \n+            \"Asia/Tashkent\", \"Asia/Tehran\", \"Asia/Dubai\", \"Africa/Nairobi\", \"Europe/Brussels\", \"Europe/Vienna\", \"Europe/London\", \n+            \"Etc/GMT+12\",\n+            // short names of zones\n+            \"GMT\", \"UTC\", \"CET\",\n+            // offsets\n+            \"+11:00\", \"+04:30\", \"+01:00\", \"+00:00\", \"-00:00\", \"-01:15\", \"-02:00\", \"-11:00\");\n+\n+        private final int id;\n+        private final BigDecimal secondsAndFractionsSinceEpoch;\n+        private final String formatString;\n+        private final String zoneId;\n+        \n+        TestCase(BigDecimal secondsAndFractionsSinceEpoch, String formatString) {\n+            this.id = COUNTER.incrementAndGet();\n+            this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+            this.formatString = formatString;\n+            this.zoneId = TestGenerator.randomFromCollection(POSTGRES_TEST_ZONE_LIST);\n+        }\n+\n+    }\n+\n+    /**\n+     * Generates an sql file that can be used to generate the test dataset for this unit test (to be used with the <code>psql</code> cli).\n+     *\n+     * Run the @{link {@link TestGenerator#main(String[])}} class and execute the following command to generate the output dataset with:\n+     *\n+     * <p>\n+     *  <code>\n+     *      # easy way to spin up the latest Postgres\n+     *      docker run --rm --name postgres-latest -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres:latest\n+     *\n+     *      # generate the csv for the unit test\n+     *      PGPASSWORD=\"mysecretpassword\" psql --quiet -h localhost -p 5432 -U postgres -f /tmp/postgresql-tochar-test.sql \\\n+     *          &gt; /path/to/tochar.csv\n+     *  </code>\n+     * </p>\n+     */\n+    private static class TestGenerator {\n+        \n+        private static final long SECONDS_IN_YEAR = 365 * 24 * 60 * 60L;\n+        private static final String DELIMITER = \"|\";\n+        private static final String PATTERN_DELIMITER = \" @ \";\n+        // these patterns are hard to sync up between PostgreSQL and Elasticsearch, so we just warn, but actually\n+        // accept the output of Elasticsearch as is\n+        private static final Set<String> NOT_FULLY_MATCHABLE_PATTERNS = Set.of(\"TZ\", \"tz\");\n+        private static final Set<String> UNSUPPORTED_PATTERN_MODIFIERS = Set.of(\"FX\", \"TM\", \"SP\");\n+        private static final String[] PATTERNS = new String[] {\n+            \"HH\", \"HH12\", \"HH24\", \"MI\", \"SS\", \"MS\", \"US\", \"FF1\", \"FF2\", \"FF3\", \"FF4\", \"FF5\", \"FF6\", \"SSSS\", \"SSSSS\", \"AM\", \"am\", \"PM\",\n+            \"pm\", \"A.M.\", \"a.m.\", \"P.M.\", \"p.m.\", \"Y,YYY\", \"YYYY\", \"YYY\", \"YY\", \"Y\", \"IYYY\", \"IYY\", \"IY\", \"I\", \"BC\", \"bc\", \"AD\", \"ad\",\n+            \"B.C.\", \"b.c.\", \"A.D.\", \"a.d.\", \"MONTH\", \"Month\", \"month\", \"MON\", \"Mon\", \"mon\", \"MM\", \"DAY\", \"Day\", \"day\", \"DY\", \"Dy\",\n+            \"dy\", \"DDD\", \"IDDD\", \"DD\", \"D\", \"ID\", \"W\", \"WW\", \"IW\", \"CC\", \"J\", \"Q\", \"RM\", \"rm\", \"TZ\", \"tz\", \"TZH\", \"TZM\", \"OF\"\n+        };\n+        private static final List<String> FILL_MODIFIERS = List.of(\"FM\", \"fm\", \"\");\n+        private static final List<String> ORDINAL_SUFFIX_MODIFIERS = List.of(\"TH\", \"th\", \"\");\n+\n+        @SuppressForbidden(reason = \"It is ok to use ThreadLocalRandom outside of an actual test\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA1MDEzNg=="}, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 106}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYzMzUxNTgz", "url": "https://github.com/elastic/elasticsearch/pull/66486#pullrequestreview-563351583", "createdAt": "2021-01-07T09:54:56Z", "commit": {"oid": "ffbdb3f4aaea069ce5bd2f11b1333ced8580a963"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QwOTo1NDo1NlrOIPmEaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QwOTo1NDo1NlrOIPmEaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzIyMzI3Mg==", "bodyText": "My initial comment stands - why aren't these strings externalized as in declared into a separate file?\nI'm not clear how they were produced nor why they have to be declared inside the java file and not separately?\nI like the idea of having everything in one place however in this case the input clearly comes from postgres and since the input is actually external, why not apply that to the zone list as well considering the declaration is ~ 40 strings.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r553223272", "createdAt": "2021-01-07T09:54:56Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharTestScript.java", "diffHunk": "@@ -0,0 +1,242 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.common.util.set.Sets;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+/**\n+ * Generates an psql file that can be used to generate the test dataset for the {@link DateTimeToCharProcessorTests}.\n+ */\n+public class ToCharTestScript {\n+\n+    private static class TestRecord {\n+\n+        // timezones that are valid both in Java and in Postgres\n+        public static final List<String> POSTGRES_TEST_ZONE_LIST = asList(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ffbdb3f4aaea069ce5bd2f11b1333ced8580a963"}, "originalPosition": 39}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYzODM5MDA3", "url": "https://github.com/elastic/elasticsearch/pull/66486#pullrequestreview-563839007", "createdAt": "2021-01-07T21:27:26Z", "commit": {"oid": "7d25b353205f8d0ca7cfb001e1d501045860710a"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QyMToyNzoyN1rOIP8_XA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QyMTo0MjoyMlrOIP9Y7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzU5ODgxMg==", "bodyText": "Specifier with lowercase letters.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r553598812", "createdAt": "2021-01-07T21:27:27Z", "author": {"login": "astefan"}, "path": "docs/reference/sql/functions/date-time.asciidoc", "diffHunk": "@@ -791,15 +791,12 @@ If any of the two arguments is `null` or the pattern is an empty string `null` i\n \n [NOTE]\n If the 1st argument is of type `time`, then pattern specified by the 2nd argument cannot contain date related units\n-(e.g. 'dd', 'MM', 'YYYY', etc.). If it contains such units an error is returned.\n-\n-*Special Cases*\n-\n-- Format specifier `F` will be working similar to format specifier `f`.\n+(e.g. 'dd', 'MM', 'YYYY', etc.). If it contains such units an error is returned. +\n+Format specifier `F` will be working similar to format specifier `f`.\n It will return the fractional part of seconds, and the number of digits will be same as of the number of `Fs` provided as input (up to 9 digits).\n Result will contain `0` appended in the end to match with number of `F` provided.\n-e.g.: for a time part `10:20:30.1234` and pattern `HH:mm:ss.FFFFFF`, the output string of the function would be: `10:20:30.123400`.\n-- Format Specifier `y` will return year-of-era instead of one/two low-order digits.\n+e.g.: for a time part `10:20:30.1234` and pattern `HH:mm:ss.FFFFFF`, the output string of the function would be: `10:20:30.123400`. +\n+Format Specifier `y` will return year-of-era instead of one/two low-order digits.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d25b353205f8d0ca7cfb001e1d501045860710a"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzYwNTM1OQ==", "bodyText": "I think all these lines would be more readable if you'd import static all these static types.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r553605359", "createdAt": "2021-01-07T21:42:22Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.List;\n+import java.util.Locale;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    /**\n+     * Tests the {@link ToCharFormatter} against actual PostgreSQL output.\n+     * \n+     * Process to (re)generate the test data:\n+     * <ol>\n+     *     <li>Run the @{link {@link ToCharTestScript#main(String[])}} class</li>\n+     *     <li>Spin up a Postgres instance (latest or a specific version) using docker:\n+     *       <pre>\n+     *       docker run --rm --name postgres-latest -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres:latest\n+     *       </pre>\n+     *     </li>\n+     *     <li>Generate the test dataset by execution the SQL against PostgreSQL and capturing the output:\n+     *       <pre>\n+     *       PGPASSWORD=\"mysecretpassword\" psql --quiet -h localhost -p 5432 -U postgres -f /tmp/postgresql-tochar-test.sql \\\n+     *           &gt; /path/to/tochar.generated.csv\n+     *       </pre>\n+     *     </li>\n+     * </ol>\n+     */\n+    public void testAgainstPostgreSQLOutput() throws Exception {\n+        String testFile = \"tochar.generated.csv\";\n+        Path testFilePath = Path.of(DateTimeToCharProcessorTests.class.getResource(testFile).toURI());\n+        int lineNumber = 0;\n+        for (String line : Files.readAllLines(testFilePath)) {\n+            lineNumber += 1;\n+            if (line.startsWith(\"#\")) {\n+                continue;\n+            }\n+            String[] cols = line.split(quote(ToCharTestScript.DELIMITER));\n+            testOneCase(testFile, lineNumber, cols[0], cols[1], cols[2], cols[3], cols[4]);\n+        }\n+    }\n+\n+    /**\n+     * @param testFile The name of the testfile where this testcase is coming from\n+     * @param lineNumber The line number of the testcase within the testfile\n+     * @param secondsAndFractionsSinceEpoch The date represented by seconds and fractions since epoch that was used to \n+     *                                      generate the TO_CHAR() PostgreSQL output.\n+     * @param zone The long/short name or offset for the timezone used when generating the expected TO_CHAR() output.\n+     * @param formatString The pattern to be tested (this is exactly the pattern that was passed into the TO_CHAR() function in PostgreSQL).\n+     * @param posgresTimestamp The timestamp represented by PostgreSQL as string in the default format (without calling TO_CHAR()).\n+     * @param expectedResult The PostgreSQL output of <code>TO_CHAR(\n+     *                       (TO_TIMESTAMP([[secondsSinceEpoch]]) + INTERVAL '[[fractions]] microseconds'), \n+     *                       '[[formatString]]')</code>.\n+     */\n+    private void testOneCase(\n+        String testFile, int lineNumber, String secondsAndFractionsSinceEpoch, String zone,\n+        String formatString, String posgresTimestamp, String expectedResult) {\n+        ZoneId zoneId = ZoneId.of(zone);\n+        ZonedDateTime timestamp = dateTimeWithFractions(secondsAndFractionsSinceEpoch);\n+        String actualResult =\n+            (String) new ToChar(Source.EMPTY, l(timestamp, DataTypes.DATETIME), l(formatString, DataTypes.KEYWORD), zoneId)\n+                .makePipe()\n+                .asProcessor()\n+                .process(null);\n+        List<String> expectedResultSplitted = asList(expectedResult.split(quote(ToCharTestScript.PATTERN_DELIMITER)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ffbdb3f4aaea069ce5bd2f11b1333ced8580a963"}, "originalPosition": 83}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dc3d108ac7da3e5bddce059f5aab34d0dfa05e76", "author": {"user": {"login": "palesz", "name": "Andras Palinkas"}}, "url": "https://github.com/elastic/elasticsearch/commit/dc3d108ac7da3e5bddce059f5aab34d0dfa05e76", "committedDate": "2021-01-07T23:51:09Z", "message": "Bugfix, simplified the ToCharFormatter parser\n\nBug was related to handling `1FMth` which turned into `1st` instead of\n`1th`."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ab2349576f284a57562e1ec90d0bee13841371dd", "author": {"user": {"login": "palesz", "name": "Andras Palinkas"}}, "url": "https://github.com/elastic/elasticsearch/commit/ab2349576f284a57562e1ec90d0bee13841371dd", "committedDate": "2021-01-08T00:07:42Z", "message": "PR suggestions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "22da6f66707f5b4317b90b37bdcb8fcbd8dc62b4", "author": {"user": {"login": "palesz", "name": "Andras Palinkas"}}, "url": "https://github.com/elastic/elasticsearch/commit/22da6f66707f5b4317b90b37bdcb8fcbd8dc62b4", "committedDate": "2021-01-08T00:08:13Z", "message": "Merge remote-tracking branch 'origin/master' into feature/to-char-function"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY0NDUyODMw", "url": "https://github.com/elastic/elasticsearch/pull/66486#pullrequestreview-564452830", "createdAt": "2021-01-08T17:36:42Z", "commit": {"oid": "22da6f66707f5b4317b90b37bdcb8fcbd8dc62b4"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY1MjgyNDY5", "url": "https://github.com/elastic/elasticsearch/pull/66486#pullrequestreview-565282469", "createdAt": "2021-01-11T11:49:24Z", "commit": {"oid": "22da6f66707f5b4317b90b37bdcb8fcbd8dc62b4"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxMTo0OToyNFrOIRSEWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxMTo1ODowNlrOIRSWBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDk5MjcyOA==", "bodyText": "Did this mean to say \"will show\"? If HT refers to Hawaii, an indication that this is an example would clarify the intent (e.g. ... for Hawaii)", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r554992728", "createdAt": "2021-01-11T11:49:24Z", "author": {"login": "bpintea"}, "path": "docs/reference/sql/functions/date-time.asciidoc", "diffHunk": "@@ -818,6 +815,54 @@ include-tagged::{sql-specs}/docs/docs.csv-spec[formatDateTime]\n include-tagged::{sql-specs}/docs/docs.csv-spec[formatTime]\n --------------------------------------------------\n \n+\n+[[sql-functions-datetime-to_char]]\n+==== `TO_CHAR`\n+\n+.Synopsis:\n+[source, sql]\n+--------------------------------------------------\n+TO_CHAR(\n+    date_exp/datetime_exp/time_exp, <1>\n+    string_exp) <2>\n+--------------------------------------------------\n+\n+*Input*:\n+\n+<1> date/datetime/time expression\n+<2> format pattern\n+\n+*Output*: string\n+\n+*Description*: Returns the date/datetime/time as a string using the format specified in the 2nd argument. The formatting\n+pattern conforms to\n+https://www.postgresql.org/docs/13/functions-formatting.html[PostgreSQL Template Patterns for Date/Time Formatting].\n+If any of the two arguments is `null` or the pattern is an empty string `null` is returned.\n+\n+[NOTE]\n+If the 1st argument is of type `time`, then the pattern specified by the 2nd argument cannot contain date related units\n+(e.g. 'dd', 'MM', 'YYYY', etc.). If it contains such units an error is returned. +\n+The result of the patterns `TZ` and `tz` (time zone abbreviations) in some cases differ from the results returned by the `TO_CHAR`\n+in PostgreSQL. The reason is that the time zone abbreviations specified by the JDK are different from the ones specified by PostgreSQL. \n+This function might show an actual time zone abbreviation instead of the generic `LMT` or empty string or offset returned by the PostgreSQL \n+implementation. The summer/daylight markers might also differ between the two implementations (will see `HT` instead of `HST`). +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22da6f66707f5b4317b90b37bdcb8fcbd8dc62b4"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDk5NzI1Mg==", "bodyText": "Does this need a bounds check (2021-13-11)? month seems to come straight out of parseInt.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r554997252", "createdAt": "2021-01-11T11:58:06Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharFormatter.java", "diffHunk": "@@ -0,0 +1,377 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.common.Strings;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.TextStyle;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.JulianFields;\n+import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.WeekFields;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static java.lang.Integer.parseInt;\n+\n+/**\n+ * Formatting according to the PostgreSQL <code>to_char</code> function specification:\n+ * https://www.postgresql.org/docs/13/functions-formatting.html#FUNCTIONS-FORMATTING-DATETIME-TABLE\n+ */\n+class ToCharFormatter {\n+\n+    protected static final Map<String, ToCharFormatter> FORMATTER_MAP;\n+\n+    static {\n+        List<ToCharFormatter> formatters = List.of(\n+            of(\"HH\").formatFn(\"hh\").numeric(),\n+            of(\"HH12\").formatFn(\"hh\").numeric(),\n+            of(\"HH24\").formatFn(\"HH\").numeric(),\n+            of(\"MI\").formatFn(\"mm\").numeric(),\n+            of(\"SS\").formatFn(\"s\", x -> String.format(Locale.ROOT, \"%02d\", parseInt(x))).numeric(),\n+            of(\"MS\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).numericWithLeadingZeros(),\n+            of(\"US\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).numericWithLeadingZeros(),\n+            of(\"FF1\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 1)).numericWithLeadingZeros(),\n+            of(\"FF2\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 2)).numericWithLeadingZeros(),\n+            of(\"FF3\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 3)).numericWithLeadingZeros(),\n+            of(\"FF4\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 4)).numericWithLeadingZeros(),\n+            of(\"FF5\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 5)).numericWithLeadingZeros(),\n+            of(\"FF6\").formatFn(\"n\", nano -> firstDigitsOfNanos(nano, 6)).numericWithLeadingZeros(),\n+            of(\"SSSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(parseInt(milliSecondOfDay) / 1000)).numeric(),\n+            of(\"SSSS\").formatFn(\"A\", milliSecondOfDay -> String.valueOf(parseInt(milliSecondOfDay) / 1000)).numeric(),\n+            of(\"AM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            of(\"am\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            of(\"PM\").formatFn(\"a\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            of(\"pm\").formatFn(\"a\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            of(\"A.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            of(\"a.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            of(\"P.M.\").formatFn(\"a\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            of(\"p.m.\").formatFn(\"a\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            of(\"Y,YYY\").formatFn(\"yyyy\", year -> year.charAt(0) + \",\" + year.substring(1)).numericWithLeadingZeros(),\n+            of(\"YYYY\").formatFn(\"yyyy\").numeric(),\n+            of(\"YYY\").formatFn(\"yyyy\", year -> year.substring(1)).numeric(),\n+            of(\"YY\").formatFn(\"yy\").numeric(),\n+            of(\"Y\").formatFn(\"yy\", year -> year.substring(1)).numeric(),\n+            of(\"IYYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 4)).numeric(),\n+            of(\"IYY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 3)).numeric(),\n+            of(\"IY\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 2)).numeric(),\n+            of(\"I\").formatFn(t -> lastNCharacter(absoluteWeekBasedYear(t), 1)).numeric(),\n+            of(\"BC\").formatFn(\"G\").text(),\n+            of(\"bc\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            of(\"AD\").formatFn(\"G\").text(),\n+            of(\"ad\").formatFn(\"G\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            of(\"B.C.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            of(\"b.c.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            of(\"A.D.\").formatFn(\"G\", x -> x.charAt(0) + \".\" + x.charAt(1) + \".\").text(),\n+            of(\"a.d.\").formatFn(\"G\", x -> (x.charAt(0) + \".\" + x.charAt(1) + \".\").toLowerCase(Locale.ROOT)).text(),\n+            of(\"MONTH\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            of(\"Month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            of(\"month\").formatFn(\"MMMM\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            of(\"MON\").formatFn(\"MMM\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            of(\"Mon\").formatFn(\"MMM\").text(),\n+            of(\"mon\").formatFn(\"MMM\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            of(\"MM\").formatFn(\"MM\").numeric(),\n+            of(\"DAY\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toUpperCase(Locale.ROOT))).text(),\n+            of(\"Day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x)).text(),\n+            of(\"day\").formatFn(\"EEEE\", x -> String.format(Locale.ROOT, \"%-9s\", x.toLowerCase(Locale.ROOT))).text(),\n+            of(\"DY\").formatFn(\"E\", x -> x.toUpperCase(Locale.ROOT)).text(),\n+            of(\"Dy\").formatFn(\"E\").text(),\n+            of(\"dy\").formatFn(\"E\", x -> x.toLowerCase(Locale.ROOT)).text(),\n+            of(\"DDD\").formatFn(\"DDD\").numeric(),\n+            of(\"IDDD\").formatFn(t -> String.format(Locale.ROOT,\n+                \"%03d\",\n+                (t.get(WeekFields.ISO.weekOfWeekBasedYear()) - 1) * 7 + t.get(ChronoField.DAY_OF_WEEK))\n+            ).numeric(),\n+            of(\"DD\").formatFn(\"d\", x -> String.format(Locale.ROOT, \"%02d\", parseInt(x))).numeric(),\n+            of(\"ID\").formatFn(\"e\").numeric(),\n+            of(\"D\").formatFn(t -> String.valueOf(t.get(WeekFields.SUNDAY_START.dayOfWeek()))).numeric(),\n+            of(\"W\").formatFn(t -> String.valueOf(t.get(ChronoField.ALIGNED_WEEK_OF_MONTH))).numeric(),\n+            of(\"WW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(ChronoField.ALIGNED_WEEK_OF_YEAR))).numeric(),\n+            of(\"IW\").formatFn(t -> String.format(Locale.ROOT, \"%02d\", t.get(WeekFields.ISO.weekOfWeekBasedYear()))).numeric(),\n+            of(\"CC\").formatFn(t -> {\n+                int century = yearToCentury(t.get(ChronoField.YEAR));\n+                return String.format(Locale.ROOT, century < 0 ? \"%03d\" : \"%02d\", century);\n+            }).numeric(),\n+            of(\"J\").formatFn(t -> String.valueOf(t.getLong(JulianFields.JULIAN_DAY))).numeric(),\n+            of(\"Q\").formatFn(\"Q\").numeric(),\n+            of(\"RM\").formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", monthToRoman(parseInt(month)))).text(),\n+            of(\"rm\")\n+                .formatFn(\"MM\", month -> String.format(Locale.ROOT, \"%-4s\", monthToRoman(parseInt(month)).toLowerCase(Locale.ROOT)))\n+                .text(),\n+            of(\"TZ\").formatFn(ToCharFormatter::zoneAbbreviationOf).text(),\n+            of(\"tz\").formatFn(t -> zoneAbbreviationOf(t).toLowerCase(Locale.ROOT)).text(),\n+            of(\"TZH\").acceptsLowercase(false).formatFn(\"ZZ\", s -> s.substring(0, 3)).text(),\n+            of(\"TZM\").acceptsLowercase(false).formatFn(\"ZZ\", s -> lastNCharacter(s, 2)).text(),\n+            of(\"OF\").acceptsLowercase(false).formatFn(\"ZZZZZ\", ToCharFormatter::formatOffset).offset()\n+        );\n+\n+        Map<String, ToCharFormatter> formatterMap = new LinkedHashMap<>();\n+        for (ToCharFormatter formatter : formatters) {\n+            formatterMap.put(formatter.pattern, formatter);\n+        }\n+        // also index the lower case version of the patterns if accepted\n+        for (ToCharFormatter formatter : formatters) {\n+            if (formatter.acceptsLowercase) {\n+                formatterMap.putIfAbsent(formatter.pattern.toLowerCase(Locale.ROOT), formatter);\n+            }\n+        }\n+        FORMATTER_MAP = formatterMap;\n+    }\n+    \n+    private static final int MAX_TO_CHAR_FORMAT_STRING_LENGTH =\n+        FORMATTER_MAP.keySet().stream().mapToInt(String::length).max().orElse(Integer.MAX_VALUE);\n+    \n+    private static final String[] ROMAN_NUMBERS = {\"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\"};\n+\n+    private final String pattern;\n+    private final boolean acceptsLowercase;\n+    // Fill mode: suppress leading zeroes and padding blanks\n+    // https://www.postgresql.org/docs/13/functions-formatting.html#FUNCTIONS-FORMATTING-DATETIMEMOD-TABLE\n+    private final Function<String, String> fillModeFn;\n+    private final boolean hasOrdinalSuffix;\n+    private final Function<TemporalAccessor, String> formatter;\n+\n+    private ToCharFormatter(\n+        String pattern,\n+        boolean acceptsLowercase,\n+        Function<String, String> fillModeFn,\n+        boolean hasOrdinalSuffix,\n+        Function<TemporalAccessor, String> formatter) {\n+\n+        this.pattern = pattern;\n+        this.acceptsLowercase = acceptsLowercase;\n+        this.fillModeFn = fillModeFn;\n+        this.hasOrdinalSuffix = hasOrdinalSuffix;\n+        this.formatter = formatter;\n+    }\n+\n+    private static Builder of(String pattern) {\n+        return new Builder(pattern);\n+    }\n+\n+    private static String monthToRoman(int month) {\n+        return ROMAN_NUMBERS[month - 1];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22da6f66707f5b4317b90b37bdcb8fcbd8dc62b4"}, "originalPosition": 165}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f12630082bf9b467a552d68e2cbc934a1871c33e", "author": {"user": {"login": "palesz", "name": "Andras Palinkas"}}, "url": "https://github.com/elastic/elasticsearch/commit/f12630082bf9b467a552d68e2cbc934a1871c33e", "committedDate": "2021-01-11T14:24:28Z", "message": "PR suggestions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "114dce9d497e2be83412e4e6293448629b2aa081", "author": {"user": {"login": "palesz", "name": "Andras Palinkas"}}, "url": "https://github.com/elastic/elasticsearch/commit/114dce9d497e2be83412e4e6293448629b2aa081", "committedDate": "2021-01-11T14:25:00Z", "message": "Merge remote-tracking branch 'origin/master' into feature/to-char-function"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY2MzE0MjIz", "url": "https://github.com/elastic/elasticsearch/pull/66486#pullrequestreview-566314223", "createdAt": "2021-01-12T14:18:25Z", "commit": {"oid": "114dce9d497e2be83412e4e6293448629b2aa081"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQxNDoxODoyNVrOISDgAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQxNDozNDozNFrOISEU9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTgwMjYyNg==", "bodyText": "replace the dot in the filename with a dash instead - tochar-test_timezones.txt or tochar-test-tz.txt", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r555802626", "createdAt": "2021-01-12T14:18:25Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharTestScript.java", "diffHunk": "@@ -71,6 +57,9 @@\n     private static final List<String> PATTERNS = new ArrayList<>(ToCharFormatter.FORMATTER_MAP.keySet());\n     private static final List<String> FILL_MODIFIERS = asList(\"FM\", \"fm\", \"\");\n     private static final List<String> ORDINAL_SUFFIX_MODIFIERS = asList(\"TH\", \"th\", \"\");\n+    // timezones that are valid both in Java and in Postgres\n+    public static final List<String> TIMEZONES_TO_TEST =\n+            readAllLinesWithoutComment(ToCharTestScript.class.getResource(\"tochar.test_timezones.txt\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "114dce9d497e2be83412e4e6293448629b2aa081"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTgwMzg5MQ==", "bodyText": "Replace the dot in the filename with -, tochar-generated.csv", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r555803891", "createdAt": "2021-01-12T14:19:25Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -44,16 +46,15 @@\n      *     </li>\n      * </ol>\n      */\n-    public void testAgainstPostgreSQLOutput() throws Exception {\n+    public void testAgainstPostgreSQLOutput() {\n         String testFile = \"tochar.generated.csv\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "114dce9d497e2be83412e4e6293448629b2aa081"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTgwOTA2NQ==", "bodyText": "This issue is still in place - why use a ThreadLocalRandom when no concurrency is needed and not rely on Random itself?\nAlso try to move away from it being static as that's tricky to clean-up. The new Random can be created within the main method and then passed around.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r555809065", "createdAt": "2021-01-12T14:25:05Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/ToCharTestScript.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.common.util.set.Sets;\n+\n+import java.math.BigDecimal;\n+import java.net.URI;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+/**\n+ * Generates an psql file that can be used to generate the test dataset for the {@link DateTimeToCharProcessorTests}.\n+ */\n+public class ToCharTestScript {\n+\n+    private static class TestRecord {\n+        private final BigDecimal secondsAndFractionsSinceEpoch;\n+        private final String formatString;\n+        private final String zoneId;\n+\n+        TestRecord(BigDecimal secondsAndFractionsSinceEpoch, String formatString) {\n+            this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+            this.formatString = formatString;\n+            this.zoneId = ToCharTestScript.randomFromCollection(TIMEZONES_TO_TEST);\n+        }\n+    }\n+\n+    private static final long SECONDS_IN_YEAR = 365 * 24 * 60 * 60L;\n+    public static final String DELIMITER = \"|\";\n+    public static final String PATTERN_DELIMITER = \" @ \";\n+    // these patterns are hard to sync up between PostgreSQL and Elasticsearch, so we just warn, but actually\n+    // accept the output of Elasticsearch as is\n+    public static final Set<String> NOT_FULLY_MATCHABLE_PATTERNS = Set.of(\"TZ\", \"tz\");\n+    private static final Set<String> UNSUPPORTED_PATTERN_MODIFIERS = Set.of(\"FX\", \"TM\", \"SP\");\n+    private static final List<String> PATTERNS = new ArrayList<>(ToCharFormatter.FORMATTER_MAP.keySet());\n+    private static final List<String> FILL_MODIFIERS = asList(\"FM\", \"fm\", \"\");\n+    private static final List<String> ORDINAL_SUFFIX_MODIFIERS = asList(\"TH\", \"th\", \"\");\n+    // timezones that are valid both in Java and in Postgres\n+    public static final List<String> TIMEZONES_TO_TEST =\n+            readAllLinesWithoutComment(ToCharTestScript.class.getResource(\"tochar.test_timezones.txt\"));\n+\n+    private final List<TestRecord> testRecords = new ArrayList<>();\n+    private final List<BigDecimal> testEpochSeconds = new ArrayList<>();\n+\n+    @SuppressForbidden(reason = \"It is ok to use ThreadLocalRandom outside of an actual test\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "114dce9d497e2be83412e4e6293448629b2aa081"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTgxNjE4MA==", "bodyText": "Why not generate a test per pattern?\nMy previous question stands, why the check for not fully matchable is done after and not before the test execution?\nAlso what's the story behind not fully matchable? I didn't see any docs for them...", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r555816180", "createdAt": "2021-01-12T14:34:34Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+import com.carrotsearch.randomizedtesting.generators.RandomNumbers;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.regex.Pattern.quote;\n+import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+\n+public class DateTimeToCharProcessorTests extends ESTestCase {\n+\n+    private static class TestCase {\n+        private static final AtomicInteger COUNTER = new AtomicInteger(0);\n+        \n+        // timezones that are valid both in Java and in Postgres\n+        public static final List<String> POSTGRES_TEST_ZONE_LIST = List.of(\n+            // location-based and long-names\n+            \"US/Samoa\", \"Pacific/Honolulu\", \"Pacific/Marquesas\", \"Pacific/Gambier\", \"America/Juneau\", \"Canada/Yukon\", \"America/Vancouver\",\n+            \"Pacific/Easter\", \"US/Mountain\", \"America/Chicago\", \"US/Michigan\", \"Atlantic/Bermuda\", \"Canada/Newfoundland\",\n+            \"Atlantic/Cape_Verde\", \"Pacific/Kiritimati\", \"Pacific/Chatham\", \"Pacific/Auckland\", \"Asia/Sakhalin\", \"Australia/Tasmania\", \n+            \"Australia/North\", \"Asia/Tokyo\", \"Australia/Eucla\", \"Asia/Singapore\", \"Asia/Rangoon\", \"Indian/Chagos\", \"Asia/Calcutta\", \n+            \"Asia/Tashkent\", \"Asia/Tehran\", \"Asia/Dubai\", \"Africa/Nairobi\", \"Europe/Brussels\", \"Europe/Vienna\", \"Europe/London\", \n+            \"Etc/GMT+12\",\n+            // short names of zones\n+            \"GMT\", \"UTC\", \"CET\",\n+            // offsets\n+            \"+11:00\", \"+04:30\", \"+01:00\", \"+00:00\", \"-00:00\", \"-01:15\", \"-02:00\", \"-11:00\");\n+\n+        private final int id;\n+        private final BigDecimal secondsAndFractionsSinceEpoch;\n+        private final String formatString;\n+        private final String zoneId;\n+        \n+        TestCase(BigDecimal secondsAndFractionsSinceEpoch, String formatString) {\n+            this.id = COUNTER.incrementAndGet();\n+            this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+            this.formatString = formatString;\n+            this.zoneId = TestGenerator.randomFromCollection(POSTGRES_TEST_ZONE_LIST);\n+        }\n+\n+    }\n+\n+    /**\n+     * Generates an sql file that can be used to generate the test dataset for this unit test (to be used with the <code>psql</code> cli).\n+     *\n+     * Run the @{link {@link TestGenerator#main(String[])}} class and execute the following command to generate the output dataset with:\n+     *\n+     * <p>\n+     *  <code>\n+     *      # easy way to spin up the latest Postgres\n+     *      docker run --rm --name postgres-latest -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres:latest\n+     *\n+     *      # generate the csv for the unit test\n+     *      PGPASSWORD=\"mysecretpassword\" psql --quiet -h localhost -p 5432 -U postgres -f /tmp/postgresql-tochar-test.sql \\\n+     *          &gt; /path/to/tochar.csv\n+     *  </code>\n+     * </p>\n+     */\n+    private static class TestGenerator {\n+        \n+        private static final long SECONDS_IN_YEAR = 365 * 24 * 60 * 60L;\n+        private static final String DELIMITER = \"|\";\n+        private static final String PATTERN_DELIMITER = \" @ \";\n+        // these patterns are hard to sync up between PostgreSQL and Elasticsearch, so we just warn, but actually\n+        // accept the output of Elasticsearch as is\n+        private static final Set<String> NOT_FULLY_MATCHABLE_PATTERNS = Set.of(\"TZ\", \"tz\");\n+        private static final Set<String> UNSUPPORTED_PATTERN_MODIFIERS = Set.of(\"FX\", \"TM\", \"SP\");\n+        private static final String[] PATTERNS = new String[] {\n+            \"HH\", \"HH12\", \"HH24\", \"MI\", \"SS\", \"MS\", \"US\", \"FF1\", \"FF2\", \"FF3\", \"FF4\", \"FF5\", \"FF6\", \"SSSS\", \"SSSSS\", \"AM\", \"am\", \"PM\",\n+            \"pm\", \"A.M.\", \"a.m.\", \"P.M.\", \"p.m.\", \"Y,YYY\", \"YYYY\", \"YYY\", \"YY\", \"Y\", \"IYYY\", \"IYY\", \"IY\", \"I\", \"BC\", \"bc\", \"AD\", \"ad\",\n+            \"B.C.\", \"b.c.\", \"A.D.\", \"a.d.\", \"MONTH\", \"Month\", \"month\", \"MON\", \"Mon\", \"mon\", \"MM\", \"DAY\", \"Day\", \"day\", \"DY\", \"Dy\",\n+            \"dy\", \"DDD\", \"IDDD\", \"DD\", \"D\", \"ID\", \"W\", \"WW\", \"IW\", \"CC\", \"J\", \"Q\", \"RM\", \"rm\", \"TZ\", \"tz\", \"TZH\", \"TZM\", \"OF\"\n+        };\n+        private static final List<String> FILL_MODIFIERS = List.of(\"FM\", \"fm\", \"\");\n+        private static final List<String> ORDINAL_SUFFIX_MODIFIERS = List.of(\"TH\", \"th\", \"\");\n+\n+        @SuppressForbidden(reason = \"It is ok to use ThreadLocalRandom outside of an actual test\")\n+        private static Random rnd() {\n+            return ThreadLocalRandom.current();\n+        }\n+\n+        private static BigDecimal randomSecondsWithFractions(int minYear, int maxYear) {\n+            BigDecimal seconds = new BigDecimal(RandomNumbers.randomLongBetween(rnd(), \n+                (minYear - 1970) * SECONDS_IN_YEAR, (maxYear - 1970) * SECONDS_IN_YEAR));\n+            BigDecimal fractions = new BigDecimal(RandomNumbers.randomIntBetween(rnd(), 0, 999_999)).movePointLeft(6);\n+            return seconds.add(fractions);\n+        }\n+\n+        private static <T> T randomFromCollection(Collection<T> list) {\n+            List<T> l = new ArrayList<>(list);\n+            return l.get(rnd().nextInt(l.size()));\n+        }\n+        \n+        private static String patternWithRandomModifiers(String pattern) {\n+            if (NOT_FULLY_MATCHABLE_PATTERNS.contains(pattern)) {\n+                return pattern;\n+            }\n+            return randomFromCollection(FILL_MODIFIERS) + pattern + randomFromCollection(ORDINAL_SUFFIX_MODIFIERS);\n+        }\n+    \n+        private static List<TestCase> generateTestCases() {\n+            \n+            final List<BigDecimal> testEpochSeconds = new LinkedList<>();\n+            for (int i = 0; i < 50; i++) {\n+                testEpochSeconds.add(randomSecondsWithFractions(-1200, 2500));\n+            }\n+            for (int i = 0; i < 5; i++) {\n+                testEpochSeconds.add(randomSecondsWithFractions(-1, 1));\n+            }\n+    \n+            List<TestCase> testCases = new ArrayList<>();\n+    \n+            // check each format string alone\n+            for (String pattern : PATTERNS) {\n+                testCases.add(new TestCase(randomFromCollection(testEpochSeconds), NOT_FULLY_MATCHABLE_PATTERNS.contains(pattern) \n+                    ? pattern \n+                    : String.join(PATTERN_DELIMITER, pattern, FILL_MODIFIERS.get(0) + pattern + ORDINAL_SUFFIX_MODIFIERS.get(0))));\n+            }\n+            \n+            // let's check all of the format strings with a non-ambiguous format string\n+            for (BigDecimal es : testEpochSeconds) {\n+                testCases.add(new TestCase(es, IntStream.range(0, PATTERNS.length)\n+                    .mapToObj(idx -> idx + \":\" + patternWithRandomModifiers(PATTERNS[idx]))\n+                    .collect(Collectors.joining(PATTERN_DELIMITER))));\n+            }\n+    \n+            // check the lowercase versions of the format strings\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), IntStream.range(0, PATTERNS.length)\n+                .mapToObj(idx -> (idx + \":\" + patternWithRandomModifiers(PATTERNS[idx])).toLowerCase(Locale.ROOT))\n+                .collect(Collectors.joining(PATTERN_DELIMITER))));\n+    \n+            // potentially ambiguous format string test cases, to check if our format string parsing is in-sync with PostgreSQL\n+            // greedy and prefers the longer format strings\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"YYYYYYYYYYYYYYY,YYYYYYYYY\"));\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"SSSSSSSSSSSSSSSS\"));\n+            testCases.add(new TestCase(randomFromCollection(testEpochSeconds), \"DDDDDDDD\"));\n+    \n+            // Roman numbers\n+            for (int i = 1; i <= 12; i++) {\n+                testCases.add(new TestCase(\n+                    new BigDecimal(dateTime(0).withMonth(i).toEpochSecond()), rnd().nextBoolean() ? \"RM\" : \"rm\"));\n+            }\n+            \n+            // random strings made out of template patterns and random characters\n+            final String randomCharacters = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYabcdefghijklmnopqrstuvwxy _-.:;\";\n+            final List<String> formatStringsToRandomTest = Arrays.stream(PATTERNS)\n+                .filter(s -> NOT_FULLY_MATCHABLE_PATTERNS.contains(s) == false)\n+                .collect(Collectors.toList());\n+            \n+            for (int i = 0; i < 20; i++) {\n+                String patternWithLiterals = IntStream.rangeClosed(1, 30).mapToObj(idx -> \n+                    rnd().nextInt(100) < 80 \n+                        ? randomCharacters.substring(rnd().nextInt(randomCharacters.length())).substring(0, 1) \n+                        : (randomFromCollection(FILL_MODIFIERS) \n+                            + randomFromCollection(formatStringsToRandomTest) \n+                            + randomFromCollection(ORDINAL_SUFFIX_MODIFIERS)))\n+                    .collect(Collectors.joining());\n+                \n+                // clean up the random string from the unsupported modifiers\n+                for (String unsupportedPatternModifier : UNSUPPORTED_PATTERN_MODIFIERS) {\n+                    patternWithLiterals = patternWithLiterals\n+                        .replace(unsupportedPatternModifier, \"\")\n+                        .replace(unsupportedPatternModifier.toLowerCase(Locale.ROOT), \"\");\n+                }\n+                testCases.add(new TestCase(randomFromCollection(testEpochSeconds), patternWithLiterals));\n+            }\n+    \n+            return testCases;\n+        }\n+        \n+        private static String adjustZoneIdToPostgres(String zoneId) {\n+            // when the zone is specified by the offset in Postgres, it follows the POSIX definition, so the +- signs are flipped\n+            // compared to ISO-8601, see more info at: https://www.postgresql.org/docs/current/datetime-posix-timezone-specs.html\n+            if (zoneId.startsWith(\"+\")) {\n+                zoneId = zoneId.replaceFirst(quote(\"+\"), \"-\");\n+            } else if (zoneId.startsWith(\"-\")) {\n+                zoneId = zoneId.replaceFirst(quote(\"-\"), \"+\");\n+            }\n+            return zoneId;\n+        }\n+        \n+        /**\n+         * Generates an SQL file that can be used to create the test dataset for the unit test of the <code>TO_CHAR</code>\n+         * implementation. In case the <code>TO_CHAR</code> implementation needs an upgrade, add the list of the new format\n+         * strings to the list of the format string, regenerate the SQL, run it against the PostgreSQL version you are targeting\n+         * and update the test CSV file.\n+         */\n+        private static String unitTestExporterScript() {\n+            return generateTestCases().stream().map(tc -> {\n+                long seconds = tc.secondsAndFractionsSinceEpoch.longValue();\n+                BigDecimal fractions = tc.secondsAndFractionsSinceEpoch.remainder(BigDecimal.ONE).movePointRight(6);\n+                return String.format(Locale.ROOT,\n+                    \"SET TIME ZONE '%7$s';\\n\" +\n+                    \"\\\\copy (SELECT %1$d as id, %2$s as epoch_seconds_and_microsends, '%6$s' as zone_id, '%5$s' as format_string, \" +\n+                        \"(TO_TIMESTAMP(%3$d) + INTERVAL '%4$d microseconds') as to_timestamp_result, \" +\n+                        \"TO_CHAR((TO_TIMESTAMP(%3$d) + INTERVAL '%4$d microseconds'), '%5$s') as to_char_result) to stdout \" +\n+                        \"with DELIMITER as '\" + DELIMITER + \"' NULL as '' csv \\n\",\n+                    tc.id, tc.secondsAndFractionsSinceEpoch.toPlainString(), seconds, fractions.intValue(), tc.formatString, tc.zoneId, \n+                    adjustZoneIdToPostgres(tc.zoneId)\n+                );\n+            }).collect(Collectors.joining(\"\\n\"));\n+        }\n+        \n+        public static void main(String[] args) throws Exception {\n+            String scriptFilename = args.length < 1 ? \"/tmp/postgresql-tochar-test.sql\" : args[0];\n+            Files.writeString(Path.of(scriptFilename), unitTestExporterScript(), StandardCharsets.UTF_8);\n+        }\n+    }\n+\n+    @ParametersFactory(argumentFormatting = \"%1$s: timestamp=%5$s, zone=%3$s, format=%4$s\")\n+    public static List<Object[]> readCsv() throws Exception {\n+        Path testFilePath = Path.of(DateTimeToCharProcessorTests.class.getResource(\"tochar.csv\").toURI());\n+        return Files.readAllLines(testFilePath).stream().map(line -> {\n+            String[] cols = line.split(quote(TestGenerator.DELIMITER));\n+            return new Object[]{ cols[0], cols[1], cols[2], cols[3], cols[4], cols[5] };\n+        }).collect(Collectors.toList());\n+    }\n+\n+    private final String id;\n+    private final String secondsAndFractionsSinceEpoch;\n+    private final String zone;\n+    private final String formatString;\n+    private final String posgresTimestamp;\n+    private final String expectedResult;\n+\n+    public DateTimeToCharProcessorTests(String id, String secondsAndFractionsSinceEpoch, String zone, String formatString,\n+        String postgresTimestamp, String expectedResult) {\n+        this.id = id;\n+        this.secondsAndFractionsSinceEpoch = secondsAndFractionsSinceEpoch;\n+        this.zone = zone;\n+        this.formatString = formatString;\n+        this.posgresTimestamp = postgresTimestamp;\n+        this.expectedResult = expectedResult;\n+    }\n+\n+    private static ZonedDateTime dateTimeWithFractions(String secondAndFractionsSinceEpoch) {\n+        BigDecimal b = new BigDecimal(secondAndFractionsSinceEpoch);\n+        long seconds = b.longValue();\n+        int fractions = b.remainder(BigDecimal.ONE).movePointRight(9).intValueExact();\n+        int adjustment = 0;\n+        if (fractions < 0) {\n+            fractions += 1e9;\n+            adjustment = -1;\n+        }\n+        return dateTime((seconds + adjustment) * 1000).withNano(fractions);\n+    }\n+    \n+    public void test() throws Exception {\n+        ZoneId zoneId = ZoneId.of(zone);\n+        ZonedDateTime timestamp = dateTimeWithFractions(secondsAndFractionsSinceEpoch);\n+        String actualResult =\n+            (String) new ToChar(Source.EMPTY, l(timestamp, DataTypes.DATETIME), l(formatString, DataTypes.KEYWORD), zoneId)\n+                .makePipe()\n+                .asProcessor()\n+                .process(null);\n+        List<String> expectedResultSplitted = List.of(expectedResult.split(quote(TestGenerator.PATTERN_DELIMITER)));\n+        List<String> resultSplitted = List.of(actualResult.split(quote(TestGenerator.PATTERN_DELIMITER)));\n+        List<String> formatStringSplitted = List.of(formatString.split(TestGenerator.PATTERN_DELIMITER));\n+        assertEquals(formatStringSplitted.size(), resultSplitted.size());\n+        assertEquals(formatStringSplitted.size(), expectedResultSplitted.size());\n+        for (int i = 0; i < formatStringSplitted.size(); i++) {\n+            String patternMaybeWithIndex = formatStringSplitted.get(i);\n+            String pattern = patternMaybeWithIndex.contains(\":\") \n+                ? patternMaybeWithIndex.substring(patternMaybeWithIndex.indexOf(\":\") + 1)\n+                : patternMaybeWithIndex;\n+            String expectedPart = expectedResultSplitted.get(i);\n+            String actualPart = resultSplitted.get(i);\n+            try {\n+                assertEquals(\n+                    String.format(Locale.ROOT, \n+                        \"\\nTest id:                            %s\\n\" +\n+                        \"zone:                               %s\\n\" +\n+                        \"timestamp (as epoch):               %s\\n\" +\n+                        \"timestamp (java, UTC):              %s\\n\" +\n+                        \"timestamp (postgres, to_timestamp): %s\\n\" +\n+                        \"timestamp (java with zone):         %s\\n\" +\n+                        \"format string:                      %s\\n\" +\n+                        \"expected (postgres to_char result): %s\\n\" +\n+                        \"actual (ES to_char result):         %s\\n\" +\n+                        \"    FAILED (sub)pattern: %s,\",\n+                        id, zone, secondsAndFractionsSinceEpoch, timestamp, posgresTimestamp, timestamp.withZoneSameInstant(zoneId), \n+                        formatString, expectedResult, actualResult, patternMaybeWithIndex), \n+                    expectedPart, actualPart);\n+            } catch (AssertionError err) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA1NDI4MQ=="}, "originalCommit": {"oid": "216ae9777e6e2104d3fb7af52e58b7f90310bb62"}, "originalPosition": 313}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5ce0078ae467acacd3e0f4fbbc6a18a2bc280a19", "author": {"user": {"login": "palesz", "name": "Andras Palinkas"}}, "url": "https://github.com/elastic/elasticsearch/commit/5ce0078ae467acacd3e0f4fbbc6a18a2bc280a19", "committedDate": "2021-01-12T14:47:18Z", "message": "Merge remote-tracking branch 'origin/master' into feature/to-char-function"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "68c5ba096234842004f5a26e2a0f6e85a6200ac7", "author": {"user": {"login": "palesz", "name": "Andras Palinkas"}}, "url": "https://github.com/elastic/elasticsearch/commit/68c5ba096234842004f5a26e2a0f6e85a6200ac7", "committedDate": "2021-01-12T15:10:04Z", "message": "PR suggestions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c0a10a1c8007195fe059046dfecbd7ac33d37da5", "author": {"user": {"login": "palesz", "name": "Andras Palinkas"}}, "url": "https://github.com/elastic/elasticsearch/commit/c0a10a1c8007195fe059046dfecbd7ac33d37da5", "committedDate": "2021-01-12T15:10:18Z", "message": "Merge remote-tracking branch 'origin/master' into feature/to-char-function"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aa16611c2aa0a288ad7e9fc5caa3035fac4d979f", "author": {"user": {"login": "palesz", "name": "Andras Palinkas"}}, "url": "https://github.com/elastic/elasticsearch/commit/aa16611c2aa0a288ad7e9fc5caa3035fac4d979f", "committedDate": "2021-01-19T18:03:58Z", "message": "One missed file rename"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7252aaddd86faf2658ba8d6682561cca34345d03", "author": {"user": {"login": "palesz", "name": "Andras Palinkas"}}, "url": "https://github.com/elastic/elasticsearch/commit/7252aaddd86faf2658ba8d6682561cca34345d03", "committedDate": "2021-01-19T18:04:10Z", "message": "Merge remote-tracking branch 'origin/master' into feature/to-char-function"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "75a93befbfffdcd65a30ccc53b10d0ed11e5bb19", "author": {"user": {"login": "elasticmachine", "name": "Elastic Machine"}}, "url": "https://github.com/elastic/elasticsearch/commit/75a93befbfffdcd65a30ccc53b10d0ed11e5bb19", "committedDate": "2021-01-19T20:52:02Z", "message": "Merge branch 'master' into feature/to-char-function"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6771c86da5d2d1a6286c55a3b7aac4f988bb45ed", "author": {"user": {"login": "palesz", "name": "Andras Palinkas"}}, "url": "https://github.com/elastic/elasticsearch/commit/6771c86da5d2d1a6286c55a3b7aac4f988bb45ed", "committedDate": "2021-01-20T15:42:38Z", "message": "PR suggestions (ParametersFactory, removes silencing of AssertionError)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5b067b8e13a7aa5330c65d2bb247cbb69488ddbf", "author": {"user": {"login": "palesz", "name": "Andras Palinkas"}}, "url": "https://github.com/elastic/elasticsearch/commit/5b067b8e13a7aa5330c65d2bb247cbb69488ddbf", "committedDate": "2021-01-20T15:52:33Z", "message": "Merge remote-tracking branch 'origin/master' into feature/to-char-function"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcyNjExMjY5", "url": "https://github.com/elastic/elasticsearch/pull/66486#pullrequestreview-572611269", "createdAt": "2021-01-20T20:16:21Z", "commit": {"oid": "5b067b8e13a7aa5330c65d2bb247cbb69488ddbf"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcyNjEzMDEy", "url": "https://github.com/elastic/elasticsearch/pull/66486#pullrequestreview-572613012", "createdAt": "2021-01-20T20:18:53Z", "commit": {"oid": "6771c86da5d2d1a6286c55a3b7aac4f988bb45ed"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMFQyMDoxODo1M1rOIXQZSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMFQyMDoxODo1M1rOIXQZSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTI1Njc3Nw==", "bodyText": "I believe it is possible to pass a rich object instead of primitives inside Object[] - not sure whether formatting works.\nAnyway, it's just a note for future reference.", "url": "https://github.com/elastic/elasticsearch/pull/66486#discussion_r561256777", "createdAt": "2021-01-20T20:18:53Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeToCharProcessorTests.java", "diffHunk": "@@ -22,43 +27,56 @@\n import static org.elasticsearch.xpack.ql.type.DataTypes.KEYWORD;\n import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.ToCharTestScript.DELIMITER;\n-import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.ToCharTestScript.NOT_FULLY_MATCHABLE_PATTERNS;\n import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.ToCharTestScript.PATTERN_DELIMITER;\n \n+/**\n+ * Tests the {@link ToCharFormatter} against actual PostgreSQL output.\n+ *\n+ * Process to (re)generate the test data:\n+ * <ol>\n+ *     <li>Run the @{link {@link ToCharTestScript#main(String[])}} class</li>\n+ *     <li>Spin up a Postgres instance (latest or a specific version) using docker:\n+ *       <pre>\n+ *       docker run --rm --name postgres-latest -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres:latest\n+ *       </pre>\n+ *     </li>\n+ *     <li>Generate the test dataset by execution the SQL against PostgreSQL and capturing the output:\n+ *       <pre>\n+ *       PGPASSWORD=\"mysecretpassword\" psql --quiet -h localhost -p 5432 -U postgres -f /tmp/postgresql-tochar-test.sql \\\n+ *           &gt; /path/to/tochar-generated.csv\n+ *       </pre>\n+ *     </li>\n+ * </ol>\n+ * \n+ * In case you need to mute any of the tests, mute all tests by adding {@link org.apache.lucene.util.LuceneTestCase.AwaitsFix}\n+ * on the class level.\n+ */\n public class DateTimeToCharProcessorTests extends ESTestCase {\n-\n-    /**\n-     * Tests the {@link ToCharFormatter} against actual PostgreSQL output.\n-     * \n-     * Process to (re)generate the test data:\n-     * <ol>\n-     *     <li>Run the @{link {@link ToCharTestScript#main(String[])}} class</li>\n-     *     <li>Spin up a Postgres instance (latest or a specific version) using docker:\n-     *       <pre>\n-     *       docker run --rm --name postgres-latest -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres:latest\n-     *       </pre>\n-     *     </li>\n-     *     <li>Generate the test dataset by execution the SQL against PostgreSQL and capturing the output:\n-     *       <pre>\n-     *       PGPASSWORD=\"mysecretpassword\" psql --quiet -h localhost -p 5432 -U postgres -f /tmp/postgresql-tochar-test.sql \\\n-     *           &gt; /path/to/tochar-generated.csv\n-     *       </pre>\n-     *     </li>\n-     * </ol>\n-     */\n-    public void testAgainstPostgreSQLOutput() {\n+    \n+    @ParametersFactory(argumentFormatting = \"%1$s:%2$s %5$s\")\n+    public static Iterable<Object[]> parameters() throws Exception {\n+        List<Object[]> params = new ArrayList<>();\n         String testFile = \"tochar-generated.csv\";\n         int lineNumber = 0;\n-        for (String line : ToCharTestScript.readAllLinesWithoutComment(DateTimeToCharProcessorTests.class.getResource(testFile))) {\n+        for (String line : Files.readAllLines(Path.of(DateTimeToCharProcessorTests.class.getResource(testFile).toURI()))) {\n             lineNumber += 1;\n             if (line.startsWith(\"#\")) {\n                 continue;\n             }\n             String[] cols = line.split(quote(DELIMITER));\n-            testOneCase(testFile, lineNumber, cols[0], cols[1], cols[2], cols[3], cols[4]);\n+            params.add(new Object[]{testFile, lineNumber, cols[0], cols[1], cols[2], cols[3], cols[4]});\n         }\n+        return params;\n     }\n \n+    private final String testFile;\n+    private final int lineNumber;\n+    private final String secondsAndFractionsSinceEpoch;\n+    private final String zone;\n+    private final String formatString;\n+    private final String posgresTimestamp;\n+    private final String expectedResult;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6771c86da5d2d1a6286c55a3b7aac4f988bb45ed"}, "originalPosition": 93}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4453, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}