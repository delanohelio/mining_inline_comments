{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM1MDk0NTI3", "number": 58159, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxMjoyNzozMVrOEF6gbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxODoxMDoxMVrOEGDWaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NjM2OTEwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CheckNotDataStreamWriteIndexStep.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxMjoyNzozMVrOGkY5zw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxMjoyNzozMVrOGkY5zw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDgwOTkzNQ==", "bodyText": "Minor, but other places we've made a point to compare Index instances so both the index name and UUID match.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (dataStream.getWriteIndex().getIndex().getName().equals(indexName)) {\n          \n          \n            \n                        if (dataStream.getWriteIndex().getIndex().equals(index)) {", "url": "https://github.com/elastic/elasticsearch/pull/58159#discussion_r440809935", "createdAt": "2020-06-16T12:27:31Z", "author": {"login": "danhermann"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CheckNotDataStreamWriteIndexStep.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexAbstraction;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.metadata.Metadata;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.Index;\n+\n+import java.io.IOException;\n+import java.util.Locale;\n+import java.util.Objects;\n+\n+/**\n+ * Some actions cannot be executed on a data stream's write index (eg. `searchable-snapshot`). This step checks if the managed index is\n+ * part of a data stream, in which case it will check it's not the write index. If the managed index is the write index of a data stream\n+ * this step will wait until that's not the case (ie. rolling over the data stream will create a new index as the data stream's write\n+ * index and this step will be able to complete)\n+ */\n+public class CheckNotDataStreamWriteIndexStep extends ClusterStateWaitStep {\n+\n+    public static final String NAME = \"check-no-write-index\";\n+\n+    private static final Logger logger = LogManager.getLogger(CheckNotDataStreamWriteIndexStep.class);\n+\n+    CheckNotDataStreamWriteIndexStep(StepKey key, StepKey nextStepKey) {\n+        super(key, nextStepKey);\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public Result isConditionMet(Index index, ClusterState clusterState) {\n+        Metadata metadata = clusterState.metadata();\n+        IndexMetadata indexMetadata = metadata.index(index);\n+        String indexName = index.getName();\n+\n+        if (indexMetadata == null) {\n+            String errorMessage = String.format(Locale.ROOT, \"[%s] lifecycle action for index [%s] executed but index no longer exists\",\n+                getKey().getAction(), indexName);\n+            // Index must have been since deleted\n+            logger.debug(errorMessage);\n+            return new Result(false, new Info(errorMessage));\n+        }\n+\n+        String policyName = indexMetadata.getSettings().get(LifecycleSettings.LIFECYCLE_NAME);\n+        IndexAbstraction indexAbstraction = clusterState.metadata().getIndicesLookup().get(indexName);\n+        assert indexAbstraction != null : \"invalid cluster metadata. index [\" + indexName + \"] was not found\";\n+        IndexAbstraction.DataStream dataStream = indexAbstraction.getParentDataStream();\n+        if (dataStream != null) {\n+            assert dataStream.getWriteIndex() != null : dataStream.getName() + \" has no write index\";\n+            if (dataStream.getWriteIndex().getIndex().getName().equals(indexName)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4788a4cfe703be11d92728c46fff88d9afd4d098"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NzgwMjQxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CheckNotDataStreamWriteIndexStep.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxODowNTo1NlrOGknJpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxODowNTo1NlrOGknJpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA0MzM2Ng==", "bodyText": "Minor suggestion to make it clearer that we're not waiting for the write index not to exist:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final String NAME = \"check-no-write-index\";\n          \n          \n            \n                public static final String NAME = \"check-not-write-index\";", "url": "https://github.com/elastic/elasticsearch/pull/58159#discussion_r441043366", "createdAt": "2020-06-16T18:05:56Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CheckNotDataStreamWriteIndexStep.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexAbstraction;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.metadata.Metadata;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.Index;\n+\n+import java.io.IOException;\n+import java.util.Locale;\n+import java.util.Objects;\n+\n+/**\n+ * Some actions cannot be executed on a data stream's write index (eg. `searchable-snapshot`). This step checks if the managed index is\n+ * part of a data stream, in which case it will check it's not the write index. If the managed index is the write index of a data stream\n+ * this step will wait until that's not the case (ie. rolling over the data stream will create a new index as the data stream's write\n+ * index and this step will be able to complete)\n+ */\n+public class CheckNotDataStreamWriteIndexStep extends ClusterStateWaitStep {\n+\n+    public static final String NAME = \"check-no-write-index\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4788a4cfe703be11d92728c46fff88d9afd4d098"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NzgxODAxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CheckNotDataStreamWriteIndexStep.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxODoxMDoxMVrOGknTfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxODoyMTo1NVrOGkn0Sg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA0NTg4Ng==", "bodyText": "I think calling it \"stopping\" might be a little confusing, I would suggest something like:\n\"index [.ds-foo-0001] is the write index for data stream [foo], pausing ILM execution until this index is no longer the write index for the data stream via manual or automated rollover\"\nWhat do you think?", "url": "https://github.com/elastic/elasticsearch/pull/58159#discussion_r441045886", "createdAt": "2020-06-16T18:10:11Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CheckNotDataStreamWriteIndexStep.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexAbstraction;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.metadata.Metadata;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.Index;\n+\n+import java.io.IOException;\n+import java.util.Locale;\n+import java.util.Objects;\n+\n+/**\n+ * Some actions cannot be executed on a data stream's write index (eg. `searchable-snapshot`). This step checks if the managed index is\n+ * part of a data stream, in which case it will check it's not the write index. If the managed index is the write index of a data stream\n+ * this step will wait until that's not the case (ie. rolling over the data stream will create a new index as the data stream's write\n+ * index and this step will be able to complete)\n+ */\n+public class CheckNotDataStreamWriteIndexStep extends ClusterStateWaitStep {\n+\n+    public static final String NAME = \"check-no-write-index\";\n+\n+    private static final Logger logger = LogManager.getLogger(CheckNotDataStreamWriteIndexStep.class);\n+\n+    CheckNotDataStreamWriteIndexStep(StepKey key, StepKey nextStepKey) {\n+        super(key, nextStepKey);\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public Result isConditionMet(Index index, ClusterState clusterState) {\n+        Metadata metadata = clusterState.metadata();\n+        IndexMetadata indexMetadata = metadata.index(index);\n+        String indexName = index.getName();\n+\n+        if (indexMetadata == null) {\n+            String errorMessage = String.format(Locale.ROOT, \"[%s] lifecycle action for index [%s] executed but index no longer exists\",\n+                getKey().getAction(), indexName);\n+            // Index must have been since deleted\n+            logger.debug(errorMessage);\n+            return new Result(false, new Info(errorMessage));\n+        }\n+\n+        String policyName = indexMetadata.getSettings().get(LifecycleSettings.LIFECYCLE_NAME);\n+        IndexAbstraction indexAbstraction = clusterState.metadata().getIndicesLookup().get(indexName);\n+        assert indexAbstraction != null : \"invalid cluster metadata. index [\" + indexName + \"] was not found\";\n+        IndexAbstraction.DataStream dataStream = indexAbstraction.getParentDataStream();\n+        if (dataStream != null) {\n+            assert dataStream.getWriteIndex() != null : dataStream.getName() + \" has no write index\";\n+            if (dataStream.getWriteIndex().getIndex().getName().equals(indexName)) {\n+                String errorMessage = String.format(Locale.ROOT, \"index [%s] is the write index for data stream [%s]. \" +\n+                    \"stopping execution of lifecycle [%s]. manually rolling over the index will resume the execution of the policy as \" +\n+                    \"the index will not be the data stream's write index anymore\", indexName, dataStream.getName(), policyName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4788a4cfe703be11d92728c46fff88d9afd4d098"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA1NDI4Mg==", "bodyText": "sure, good point", "url": "https://github.com/elastic/elasticsearch/pull/58159#discussion_r441054282", "createdAt": "2020-06-16T18:21:55Z", "author": {"login": "andreidan"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CheckNotDataStreamWriteIndexStep.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexAbstraction;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.metadata.Metadata;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.Index;\n+\n+import java.io.IOException;\n+import java.util.Locale;\n+import java.util.Objects;\n+\n+/**\n+ * Some actions cannot be executed on a data stream's write index (eg. `searchable-snapshot`). This step checks if the managed index is\n+ * part of a data stream, in which case it will check it's not the write index. If the managed index is the write index of a data stream\n+ * this step will wait until that's not the case (ie. rolling over the data stream will create a new index as the data stream's write\n+ * index and this step will be able to complete)\n+ */\n+public class CheckNotDataStreamWriteIndexStep extends ClusterStateWaitStep {\n+\n+    public static final String NAME = \"check-no-write-index\";\n+\n+    private static final Logger logger = LogManager.getLogger(CheckNotDataStreamWriteIndexStep.class);\n+\n+    CheckNotDataStreamWriteIndexStep(StepKey key, StepKey nextStepKey) {\n+        super(key, nextStepKey);\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public Result isConditionMet(Index index, ClusterState clusterState) {\n+        Metadata metadata = clusterState.metadata();\n+        IndexMetadata indexMetadata = metadata.index(index);\n+        String indexName = index.getName();\n+\n+        if (indexMetadata == null) {\n+            String errorMessage = String.format(Locale.ROOT, \"[%s] lifecycle action for index [%s] executed but index no longer exists\",\n+                getKey().getAction(), indexName);\n+            // Index must have been since deleted\n+            logger.debug(errorMessage);\n+            return new Result(false, new Info(errorMessage));\n+        }\n+\n+        String policyName = indexMetadata.getSettings().get(LifecycleSettings.LIFECYCLE_NAME);\n+        IndexAbstraction indexAbstraction = clusterState.metadata().getIndicesLookup().get(indexName);\n+        assert indexAbstraction != null : \"invalid cluster metadata. index [\" + indexName + \"] was not found\";\n+        IndexAbstraction.DataStream dataStream = indexAbstraction.getParentDataStream();\n+        if (dataStream != null) {\n+            assert dataStream.getWriteIndex() != null : dataStream.getName() + \" has no write index\";\n+            if (dataStream.getWriteIndex().getIndex().getName().equals(indexName)) {\n+                String errorMessage = String.format(Locale.ROOT, \"index [%s] is the write index for data stream [%s]. \" +\n+                    \"stopping execution of lifecycle [%s]. manually rolling over the index will resume the execution of the policy as \" +\n+                    \"the index will not be the data stream's write index anymore\", indexName, dataStream.getName(), policyName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA0NTg4Ng=="}, "originalCommit": {"oid": "4788a4cfe703be11d92728c46fff88d9afd4d098"}, "originalPosition": 67}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1495, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}