{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc5NjM5ODg1", "number": 52769, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNDo1MToyMVrODjGzFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxOTo0MzowNVrODjNutw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MTM4MTMyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/aggregations/Aggregator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNDo1MToyMVrOFuui_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxNjowNjoxNFrOFvXKsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU0MTQzNw==", "bodyText": "Would be nice to note when an aggregator should implement this, like the old doc.  Something like Aggregations that support sorting should override this, otherwise leave the default implementation maybe?", "url": "https://github.com/elastic/elasticsearch/pull/52769#discussion_r384541437", "createdAt": "2020-02-26T14:51:21Z", "author": {"login": "not-napoleon"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/Aggregator.java", "diffHunk": "@@ -130,15 +131,23 @@ public Aggregator resolveSortPath(AggregationPath.PathElement next, Iterator<Agg\n     }\n \n     /**\n-     * Validates the \"key\" portion of a sort on this aggregation.\n-     * <p>\n-     * The default implementation throws an exception but we override it on aggregations that support sorting.\n+     * Builds a comparator that compares two buckets aggregated by this {@linkplain Aggregator}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd02073c9b3e36bb54d83d949c21c032b0315175"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTIwNjk2Mw==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/elastic/elasticsearch/pull/52769#discussion_r385206963", "createdAt": "2020-02-27T16:06:14Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/Aggregator.java", "diffHunk": "@@ -130,15 +131,23 @@ public Aggregator resolveSortPath(AggregationPath.PathElement next, Iterator<Agg\n     }\n \n     /**\n-     * Validates the \"key\" portion of a sort on this aggregation.\n-     * <p>\n-     * The default implementation throws an exception but we override it on aggregations that support sorting.\n+     * Builds a comparator that compares two buckets aggregated by this {@linkplain Aggregator}.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU0MTQzNw=="}, "originalCommit": {"oid": "bd02073c9b3e36bb54d83d949c21c032b0315175"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MTQwMzY4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/aggregations/BucketOrder.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNDo1NjoxM1rOFuuwcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxNjowNzoyN1rOFvXN0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU0NDg4MQ==", "bodyText": "This looks like we expect it to throw if the ordering is invalid for the given aggregator.  Presuming that's correct, let's note what we expect it to throw, even though it's unchecked.", "url": "https://github.com/elastic/elasticsearch/pull/52769#discussion_r384544881", "createdAt": "2020-02-26T14:56:13Z", "author": {"login": "not-napoleon"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/BucketOrder.java", "diffHunk": "@@ -98,16 +101,39 @@ public static BucketOrder compound(BucketOrder... orders) {\n     }\n \n     /**\n-     * @return A comparator for the bucket based on the given aggregator. The comparator is used in two phases:\n-     * <p>\n-     * - aggregation phase, where each shard builds a list of buckets to be sent to the coordinating node.\n-     * In this phase, the passed in aggregator will be the aggregator that aggregates the buckets on the\n-     * shard level.\n+     * Validate an aggregation against an aggregator.\n+     */\n+    public final void validate(Aggregator aggregator) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd02073c9b3e36bb54d83d949c21c032b0315175"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTIwNzc2Mg==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/elastic/elasticsearch/pull/52769#discussion_r385207762", "createdAt": "2020-02-27T16:07:27Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/BucketOrder.java", "diffHunk": "@@ -98,16 +101,39 @@ public static BucketOrder compound(BucketOrder... orders) {\n     }\n \n     /**\n-     * @return A comparator for the bucket based on the given aggregator. The comparator is used in two phases:\n-     * <p>\n-     * - aggregation phase, where each shard builds a list of buckets to be sent to the coordinating node.\n-     * In this phase, the passed in aggregator will be the aggregator that aggregates the buckets on the\n-     * shard level.\n+     * Validate an aggregation against an aggregator.\n+     */\n+    public final void validate(Aggregator aggregator) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU0NDg4MQ=="}, "originalCommit": {"oid": "bd02073c9b3e36bb54d83d949c21c032b0315175"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MjIzODc1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/TermsAggregator.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxODoyMzo1MFrOFu25NA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxODozMDo0MFrOFvcaGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY3ODE5Ng==", "bodyText": "Possible I'm missing something, but couldn't this NPE if an order isn't set?  E.g. order == null which means partiallyBuiltBucketComparator == null, and then later when we use it in a PQ we pass in a null comparator and the PQ chokes (because comparator.compare() NPEs)?", "url": "https://github.com/elastic/elasticsearch/pull/52769#discussion_r384678196", "createdAt": "2020-02-26T18:23:50Z", "author": {"login": "polyfractal"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/TermsAggregator.java", "diffHunk": "@@ -189,7 +183,8 @@ public TermsAggregator(String name, AggregatorFactories factories, SearchContext\n             List<PipelineAggregator> pipelineAggregators, Map<String, Object> metaData) throws IOException {\n         super(name, factories, context, parent, pipelineAggregators, metaData);\n         this.bucketCountThresholds = bucketCountThresholds;\n-        this.order = InternalOrder.validate(order, this);\n+        this.order = order;\n+        partiallyBuiltBucketComparator = order == null ? null : order.partiallyBuiltBucketComparator(b -> b.bucketOrd, this);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd02073c9b3e36bb54d83d949c21c032b0315175"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc2NDI4Mw==", "bodyText": "I believe this comes up when the agg is unmapped. Either way, in that case we don't use the comparator.", "url": "https://github.com/elastic/elasticsearch/pull/52769#discussion_r384764283", "createdAt": "2020-02-26T21:04:32Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/TermsAggregator.java", "diffHunk": "@@ -189,7 +183,8 @@ public TermsAggregator(String name, AggregatorFactories factories, SearchContext\n             List<PipelineAggregator> pipelineAggregators, Map<String, Object> metaData) throws IOException {\n         super(name, factories, context, parent, pipelineAggregators, metaData);\n         this.bucketCountThresholds = bucketCountThresholds;\n-        this.order = InternalOrder.validate(order, this);\n+        this.order = order;\n+        partiallyBuiltBucketComparator = order == null ? null : order.partiallyBuiltBucketComparator(b -> b.bucketOrd, this);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY3ODE5Ng=="}, "originalCommit": {"oid": "bd02073c9b3e36bb54d83d949c21c032b0315175"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc5NjA1OQ==", "bodyText": "Ahh, I see.  And it appears we default to an Order in the Builder so theoretically this should never be null if it's mapped. \ud83d\udc4d", "url": "https://github.com/elastic/elasticsearch/pull/52769#discussion_r384796059", "createdAt": "2020-02-26T22:06:09Z", "author": {"login": "polyfractal"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/TermsAggregator.java", "diffHunk": "@@ -189,7 +183,8 @@ public TermsAggregator(String name, AggregatorFactories factories, SearchContext\n             List<PipelineAggregator> pipelineAggregators, Map<String, Object> metaData) throws IOException {\n         super(name, factories, context, parent, pipelineAggregators, metaData);\n         this.bucketCountThresholds = bucketCountThresholds;\n-        this.order = InternalOrder.validate(order, this);\n+        this.order = order;\n+        partiallyBuiltBucketComparator = order == null ? null : order.partiallyBuiltBucketComparator(b -> b.bucketOrd, this);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY3ODE5Ng=="}, "originalCommit": {"oid": "bd02073c9b3e36bb54d83d949c21c032b0315175"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTIwOTQ4Mg==", "bodyText": "It looks like SignificantStringTermsAggregator always passes null here. Which is kind of a smell, but something for another day.", "url": "https://github.com/elastic/elasticsearch/pull/52769#discussion_r385209482", "createdAt": "2020-02-27T16:09:59Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/TermsAggregator.java", "diffHunk": "@@ -189,7 +183,8 @@ public TermsAggregator(String name, AggregatorFactories factories, SearchContext\n             List<PipelineAggregator> pipelineAggregators, Map<String, Object> metaData) throws IOException {\n         super(name, factories, context, parent, pipelineAggregators, metaData);\n         this.bucketCountThresholds = bucketCountThresholds;\n-        this.order = InternalOrder.validate(order, this);\n+        this.order = order;\n+        partiallyBuiltBucketComparator = order == null ? null : order.partiallyBuiltBucketComparator(b -> b.bucketOrd, this);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY3ODE5Ng=="}, "originalCommit": {"oid": "bd02073c9b3e36bb54d83d949c21c032b0315175"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI5MjgyNQ==", "bodyText": "agreed", "url": "https://github.com/elastic/elasticsearch/pull/52769#discussion_r385292825", "createdAt": "2020-02-27T18:30:40Z", "author": {"login": "polyfractal"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/TermsAggregator.java", "diffHunk": "@@ -189,7 +183,8 @@ public TermsAggregator(String name, AggregatorFactories factories, SearchContext\n             List<PipelineAggregator> pipelineAggregators, Map<String, Object> metaData) throws IOException {\n         super(name, factories, context, parent, pipelineAggregators, metaData);\n         this.bucketCountThresholds = bucketCountThresholds;\n-        this.order = InternalOrder.validate(order, this);\n+        this.order = order;\n+        partiallyBuiltBucketComparator = order == null ? null : order.partiallyBuiltBucketComparator(b -> b.bucketOrd, this);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY3ODE5Ng=="}, "originalCommit": {"oid": "bd02073c9b3e36bb54d83d949c21c032b0315175"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MjM4NzA0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/aggregations/InternalOrder.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxOTowODoxN1rOFu4XtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMTowNDozOFrOFu8Jow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcwMjM4OQ==", "bodyText": "Could we add small javadoc on this?  Just thinking that since it's private, someone might some day decide to escalate it public and a description of what it does will either be useful, or convince them not to escalate to public :)", "url": "https://github.com/elastic/elasticsearch/pull/52769#discussion_r384702389", "createdAt": "2020-02-26T19:08:17Z", "author": {"login": "polyfractal"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/InternalOrder.java", "diffHunk": "@@ -244,34 +223,59 @@ public boolean equals(Object obj) {\n             CompoundOrder other = (CompoundOrder) obj;\n             return Objects.equals(orderElements, other.orderElements);\n         }\n+    }\n \n-        /**\n-         * {@code Comparator} for sorting buckets by multiple criteria.\n-         */\n-        static class CompoundOrderComparator implements Comparator<Bucket> {\n-\n-            private List<BucketOrder> compoundOrder;\n-            private Aggregator aggregator;\n-\n-            /**\n-             * Create a new {@code Comparator} for sorting buckets by multiple criteria.\n-             *\n-             * @param compoundOrder a list of {@link BucketOrder}s to sort on, in order of priority.\n-             * @param aggregator    {@link BucketOrder#comparator(Aggregator)}\n-             */\n-            CompoundOrderComparator(List<BucketOrder> compoundOrder, Aggregator aggregator) {\n-                this.compoundOrder = compoundOrder;\n-                this.aggregator = aggregator;\n-            }\n+    private static class SimpleOrder extends InternalOrder {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd02073c9b3e36bb54d83d949c21c032b0315175"}, "originalPosition": 241}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc2NDMyMw==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/elastic/elasticsearch/pull/52769#discussion_r384764323", "createdAt": "2020-02-26T21:04:38Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/InternalOrder.java", "diffHunk": "@@ -244,34 +223,59 @@ public boolean equals(Object obj) {\n             CompoundOrder other = (CompoundOrder) obj;\n             return Objects.equals(orderElements, other.orderElements);\n         }\n+    }\n \n-        /**\n-         * {@code Comparator} for sorting buckets by multiple criteria.\n-         */\n-        static class CompoundOrderComparator implements Comparator<Bucket> {\n-\n-            private List<BucketOrder> compoundOrder;\n-            private Aggregator aggregator;\n-\n-            /**\n-             * Create a new {@code Comparator} for sorting buckets by multiple criteria.\n-             *\n-             * @param compoundOrder a list of {@link BucketOrder}s to sort on, in order of priority.\n-             * @param aggregator    {@link BucketOrder#comparator(Aggregator)}\n-             */\n-            CompoundOrderComparator(List<BucketOrder> compoundOrder, Aggregator aggregator) {\n-                this.compoundOrder = compoundOrder;\n-                this.aggregator = aggregator;\n-            }\n+    private static class SimpleOrder extends InternalOrder {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcwMjM4OQ=="}, "originalCommit": {"oid": "bd02073c9b3e36bb54d83d949c21c032b0315175"}, "originalPosition": 241}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MjUxNzAzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/aggregations/BucketOrder.java", "isResolved": false, "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxOTo0MzowNVrOFu5lmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxODozMDoxN1rOFvcZUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcyMjMyOQ==", "bodyText": "Hmm, despite the warning it makes me a bit uncomfortable exposing this everywhere since only Terms needs it.  Perhaps we could have some kind of \"OrderBySubaggWrapper\" that Terms agg wraps over the order which implements this functionality?\nI'm not sure if that's possible (or a good idea), so I'm ok leaving this method + warning if we can't find a way to hide it.", "url": "https://github.com/elastic/elasticsearch/pull/52769#discussion_r384722329", "createdAt": "2020-02-26T19:43:05Z", "author": {"login": "polyfractal"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/BucketOrder.java", "diffHunk": "@@ -98,16 +101,39 @@ public static BucketOrder compound(BucketOrder... orders) {\n     }\n \n     /**\n-     * @return A comparator for the bucket based on the given aggregator. The comparator is used in two phases:\n-     * <p>\n-     * - aggregation phase, where each shard builds a list of buckets to be sent to the coordinating node.\n-     * In this phase, the passed in aggregator will be the aggregator that aggregates the buckets on the\n-     * shard level.\n+     * Validate an aggregation against an aggregator.\n+     */\n+    public final void validate(Aggregator aggregator) {\n+        /*\n+         * Building partiallyBuiltBucketComparator and throwing it away is enough\n+         * to validate this order because doing so checks all of the appropriate\n+         * paths.\n+         */\n+        partiallyBuiltBucketComparator(null, aggregator);\n+    }\n+\n+    /**\n+     * A builds comparator comparing buckets partially built buckets by\n+     * delegating comparison of the results of any \"child\" aggregations to\n+     * the provided {@linkplain Aggregator}.\n      * <p>\n-     * - reduce phase, where the coordinating node gathers all the buckets from all the shards and reduces them\n-     * to a final bucket list. In this case, the passed in aggregator will be {@code null}.\n+     * Warning: This is fairly difficult to use and impossible to use cleanly.\n+     * In addition, this exists primarily to return the \"top n\" buckets based\n+     * on the results of a sub aggregation. The trouble is that could end up\n+     * throwing away buckets on the data nodes that should ultimately be kept\n+     * after reducing all of the results. If you know that this is coming it\n+     * is fine, but most folks that use \"generic\" sorts don't. In other words:\n+     * before you use this method think super duper hard if you want to have\n+     * these kinds of issues. The terms agg does an folks get into trouble\n+     * with it all the time.\n+     * </p> \n+     */\n+    public abstract <T extends Bucket> Comparator<T> partiallyBuiltBucketComparator(ToLongFunction<T> ordinalReader, Aggregator aggregator);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd02073c9b3e36bb54d83d949c21c032b0315175"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcyNzc2NQ==", "bodyText": "(I realize this sorta goes back to how it was before, but it at least avoids a special-case instanceof in ordering classes :), and retains all the other nice benefits of this refactor )", "url": "https://github.com/elastic/elasticsearch/pull/52769#discussion_r384727765", "createdAt": "2020-02-26T19:52:35Z", "author": {"login": "polyfractal"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/BucketOrder.java", "diffHunk": "@@ -98,16 +101,39 @@ public static BucketOrder compound(BucketOrder... orders) {\n     }\n \n     /**\n-     * @return A comparator for the bucket based on the given aggregator. The comparator is used in two phases:\n-     * <p>\n-     * - aggregation phase, where each shard builds a list of buckets to be sent to the coordinating node.\n-     * In this phase, the passed in aggregator will be the aggregator that aggregates the buckets on the\n-     * shard level.\n+     * Validate an aggregation against an aggregator.\n+     */\n+    public final void validate(Aggregator aggregator) {\n+        /*\n+         * Building partiallyBuiltBucketComparator and throwing it away is enough\n+         * to validate this order because doing so checks all of the appropriate\n+         * paths.\n+         */\n+        partiallyBuiltBucketComparator(null, aggregator);\n+    }\n+\n+    /**\n+     * A builds comparator comparing buckets partially built buckets by\n+     * delegating comparison of the results of any \"child\" aggregations to\n+     * the provided {@linkplain Aggregator}.\n      * <p>\n-     * - reduce phase, where the coordinating node gathers all the buckets from all the shards and reduces them\n-     * to a final bucket list. In this case, the passed in aggregator will be {@code null}.\n+     * Warning: This is fairly difficult to use and impossible to use cleanly.\n+     * In addition, this exists primarily to return the \"top n\" buckets based\n+     * on the results of a sub aggregation. The trouble is that could end up\n+     * throwing away buckets on the data nodes that should ultimately be kept\n+     * after reducing all of the results. If you know that this is coming it\n+     * is fine, but most folks that use \"generic\" sorts don't. In other words:\n+     * before you use this method think super duper hard if you want to have\n+     * these kinds of issues. The terms agg does an folks get into trouble\n+     * with it all the time.\n+     * </p> \n+     */\n+    public abstract <T extends Bucket> Comparator<T> partiallyBuiltBucketComparator(ToLongFunction<T> ordinalReader, Aggregator aggregator);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcyMjMyOQ=="}, "originalCommit": {"oid": "bd02073c9b3e36bb54d83d949c21c032b0315175"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc2NDk0OA==", "bodyText": "The trouble with that is that validating the sort just calls this method. That prevents us from having all that \"mirrored\" validation code. I could make this method protected. What would you think of that?", "url": "https://github.com/elastic/elasticsearch/pull/52769#discussion_r384764948", "createdAt": "2020-02-26T21:05:55Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/BucketOrder.java", "diffHunk": "@@ -98,16 +101,39 @@ public static BucketOrder compound(BucketOrder... orders) {\n     }\n \n     /**\n-     * @return A comparator for the bucket based on the given aggregator. The comparator is used in two phases:\n-     * <p>\n-     * - aggregation phase, where each shard builds a list of buckets to be sent to the coordinating node.\n-     * In this phase, the passed in aggregator will be the aggregator that aggregates the buckets on the\n-     * shard level.\n+     * Validate an aggregation against an aggregator.\n+     */\n+    public final void validate(Aggregator aggregator) {\n+        /*\n+         * Building partiallyBuiltBucketComparator and throwing it away is enough\n+         * to validate this order because doing so checks all of the appropriate\n+         * paths.\n+         */\n+        partiallyBuiltBucketComparator(null, aggregator);\n+    }\n+\n+    /**\n+     * A builds comparator comparing buckets partially built buckets by\n+     * delegating comparison of the results of any \"child\" aggregations to\n+     * the provided {@linkplain Aggregator}.\n      * <p>\n-     * - reduce phase, where the coordinating node gathers all the buckets from all the shards and reduces them\n-     * to a final bucket list. In this case, the passed in aggregator will be {@code null}.\n+     * Warning: This is fairly difficult to use and impossible to use cleanly.\n+     * In addition, this exists primarily to return the \"top n\" buckets based\n+     * on the results of a sub aggregation. The trouble is that could end up\n+     * throwing away buckets on the data nodes that should ultimately be kept\n+     * after reducing all of the results. If you know that this is coming it\n+     * is fine, but most folks that use \"generic\" sorts don't. In other words:\n+     * before you use this method think super duper hard if you want to have\n+     * these kinds of issues. The terms agg does an folks get into trouble\n+     * with it all the time.\n+     * </p> \n+     */\n+    public abstract <T extends Bucket> Comparator<T> partiallyBuiltBucketComparator(ToLongFunction<T> ordinalReader, Aggregator aggregator);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcyMjMyOQ=="}, "originalCommit": {"oid": "bd02073c9b3e36bb54d83d949c21c032b0315175"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc2NTIxNQ==", "bodyText": "I feel like that'd be fairly tricky though.", "url": "https://github.com/elastic/elasticsearch/pull/52769#discussion_r384765215", "createdAt": "2020-02-26T21:06:28Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/BucketOrder.java", "diffHunk": "@@ -98,16 +101,39 @@ public static BucketOrder compound(BucketOrder... orders) {\n     }\n \n     /**\n-     * @return A comparator for the bucket based on the given aggregator. The comparator is used in two phases:\n-     * <p>\n-     * - aggregation phase, where each shard builds a list of buckets to be sent to the coordinating node.\n-     * In this phase, the passed in aggregator will be the aggregator that aggregates the buckets on the\n-     * shard level.\n+     * Validate an aggregation against an aggregator.\n+     */\n+    public final void validate(Aggregator aggregator) {\n+        /*\n+         * Building partiallyBuiltBucketComparator and throwing it away is enough\n+         * to validate this order because doing so checks all of the appropriate\n+         * paths.\n+         */\n+        partiallyBuiltBucketComparator(null, aggregator);\n+    }\n+\n+    /**\n+     * A builds comparator comparing buckets partially built buckets by\n+     * delegating comparison of the results of any \"child\" aggregations to\n+     * the provided {@linkplain Aggregator}.\n      * <p>\n-     * - reduce phase, where the coordinating node gathers all the buckets from all the shards and reduces them\n-     * to a final bucket list. In this case, the passed in aggregator will be {@code null}.\n+     * Warning: This is fairly difficult to use and impossible to use cleanly.\n+     * In addition, this exists primarily to return the \"top n\" buckets based\n+     * on the results of a sub aggregation. The trouble is that could end up\n+     * throwing away buckets on the data nodes that should ultimately be kept\n+     * after reducing all of the results. If you know that this is coming it\n+     * is fine, but most folks that use \"generic\" sorts don't. In other words:\n+     * before you use this method think super duper hard if you want to have\n+     * these kinds of issues. The terms agg does an folks get into trouble\n+     * with it all the time.\n+     * </p> \n+     */\n+    public abstract <T extends Bucket> Comparator<T> partiallyBuiltBucketComparator(ToLongFunction<T> ordinalReader, Aggregator aggregator);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcyMjMyOQ=="}, "originalCommit": {"oid": "bd02073c9b3e36bb54d83d949c21c032b0315175"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc5NjI0Ng==", "bodyText": "Hmm I see, and there's really no good way to currently validate without just running through the order components.\nOk, we can go with the current setup.  The javadocs are sufficiently scary, and we can keep it in mind if we ever find an opportunity to refactor and hide the method.", "url": "https://github.com/elastic/elasticsearch/pull/52769#discussion_r384796246", "createdAt": "2020-02-26T22:06:36Z", "author": {"login": "polyfractal"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/BucketOrder.java", "diffHunk": "@@ -98,16 +101,39 @@ public static BucketOrder compound(BucketOrder... orders) {\n     }\n \n     /**\n-     * @return A comparator for the bucket based on the given aggregator. The comparator is used in two phases:\n-     * <p>\n-     * - aggregation phase, where each shard builds a list of buckets to be sent to the coordinating node.\n-     * In this phase, the passed in aggregator will be the aggregator that aggregates the buckets on the\n-     * shard level.\n+     * Validate an aggregation against an aggregator.\n+     */\n+    public final void validate(Aggregator aggregator) {\n+        /*\n+         * Building partiallyBuiltBucketComparator and throwing it away is enough\n+         * to validate this order because doing so checks all of the appropriate\n+         * paths.\n+         */\n+        partiallyBuiltBucketComparator(null, aggregator);\n+    }\n+\n+    /**\n+     * A builds comparator comparing buckets partially built buckets by\n+     * delegating comparison of the results of any \"child\" aggregations to\n+     * the provided {@linkplain Aggregator}.\n      * <p>\n-     * - reduce phase, where the coordinating node gathers all the buckets from all the shards and reduces them\n-     * to a final bucket list. In this case, the passed in aggregator will be {@code null}.\n+     * Warning: This is fairly difficult to use and impossible to use cleanly.\n+     * In addition, this exists primarily to return the \"top n\" buckets based\n+     * on the results of a sub aggregation. The trouble is that could end up\n+     * throwing away buckets on the data nodes that should ultimately be kept\n+     * after reducing all of the results. If you know that this is coming it\n+     * is fine, but most folks that use \"generic\" sorts don't. In other words:\n+     * before you use this method think super duper hard if you want to have\n+     * these kinds of issues. The terms agg does an folks get into trouble\n+     * with it all the time.\n+     * </p> \n+     */\n+    public abstract <T extends Bucket> Comparator<T> partiallyBuiltBucketComparator(ToLongFunction<T> ordinalReader, Aggregator aggregator);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcyMjMyOQ=="}, "originalCommit": {"oid": "bd02073c9b3e36bb54d83d949c21c032b0315175"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI0MzI3MQ==", "bodyText": "So I've been poking around the PR a little, and I remembered this issue regarding validation: #20003\nE.g. the \"validation\" we do today is pretty poor, as it happens way after we parse the aggregations.  But the builders do have a full list of all the aggregation builders (that's how pipeline aggs validate their buckets_path, albeit that system has it's own issues).\nI wonder if we could -- in a followup PR -- make validation a parse-time issue, and then it would potentially allow us to remove validation from the Ordering classes and then also hide the terms-specific details?  WDYT?  Or are there other details that still make it difficult?", "url": "https://github.com/elastic/elasticsearch/pull/52769#discussion_r385243271", "createdAt": "2020-02-27T17:01:22Z", "author": {"login": "polyfractal"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/BucketOrder.java", "diffHunk": "@@ -98,16 +101,39 @@ public static BucketOrder compound(BucketOrder... orders) {\n     }\n \n     /**\n-     * @return A comparator for the bucket based on the given aggregator. The comparator is used in two phases:\n-     * <p>\n-     * - aggregation phase, where each shard builds a list of buckets to be sent to the coordinating node.\n-     * In this phase, the passed in aggregator will be the aggregator that aggregates the buckets on the\n-     * shard level.\n+     * Validate an aggregation against an aggregator.\n+     */\n+    public final void validate(Aggregator aggregator) {\n+        /*\n+         * Building partiallyBuiltBucketComparator and throwing it away is enough\n+         * to validate this order because doing so checks all of the appropriate\n+         * paths.\n+         */\n+        partiallyBuiltBucketComparator(null, aggregator);\n+    }\n+\n+    /**\n+     * A builds comparator comparing buckets partially built buckets by\n+     * delegating comparison of the results of any \"child\" aggregations to\n+     * the provided {@linkplain Aggregator}.\n      * <p>\n-     * - reduce phase, where the coordinating node gathers all the buckets from all the shards and reduces them\n-     * to a final bucket list. In this case, the passed in aggregator will be {@code null}.\n+     * Warning: This is fairly difficult to use and impossible to use cleanly.\n+     * In addition, this exists primarily to return the \"top n\" buckets based\n+     * on the results of a sub aggregation. The trouble is that could end up\n+     * throwing away buckets on the data nodes that should ultimately be kept\n+     * after reducing all of the results. If you know that this is coming it\n+     * is fine, but most folks that use \"generic\" sorts don't. In other words:\n+     * before you use this method think super duper hard if you want to have\n+     * these kinds of issues. The terms agg does an folks get into trouble\n+     * with it all the time.\n+     * </p> \n+     */\n+    public abstract <T extends Bucket> Comparator<T> partiallyBuiltBucketComparator(ToLongFunction<T> ordinalReader, Aggregator aggregator);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcyMjMyOQ=="}, "originalCommit": {"oid": "bd02073c9b3e36bb54d83d949c21c032b0315175"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI4OTY1Nw==", "bodyText": "That'd certainly make this something we could drop! I'd be happy to do that in a follow up. Reading it has got me thinking about ways we can do this without having so many \"paths\".", "url": "https://github.com/elastic/elasticsearch/pull/52769#discussion_r385289657", "createdAt": "2020-02-27T18:24:46Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/BucketOrder.java", "diffHunk": "@@ -98,16 +101,39 @@ public static BucketOrder compound(BucketOrder... orders) {\n     }\n \n     /**\n-     * @return A comparator for the bucket based on the given aggregator. The comparator is used in two phases:\n-     * <p>\n-     * - aggregation phase, where each shard builds a list of buckets to be sent to the coordinating node.\n-     * In this phase, the passed in aggregator will be the aggregator that aggregates the buckets on the\n-     * shard level.\n+     * Validate an aggregation against an aggregator.\n+     */\n+    public final void validate(Aggregator aggregator) {\n+        /*\n+         * Building partiallyBuiltBucketComparator and throwing it away is enough\n+         * to validate this order because doing so checks all of the appropriate\n+         * paths.\n+         */\n+        partiallyBuiltBucketComparator(null, aggregator);\n+    }\n+\n+    /**\n+     * A builds comparator comparing buckets partially built buckets by\n+     * delegating comparison of the results of any \"child\" aggregations to\n+     * the provided {@linkplain Aggregator}.\n      * <p>\n-     * - reduce phase, where the coordinating node gathers all the buckets from all the shards and reduces them\n-     * to a final bucket list. In this case, the passed in aggregator will be {@code null}.\n+     * Warning: This is fairly difficult to use and impossible to use cleanly.\n+     * In addition, this exists primarily to return the \"top n\" buckets based\n+     * on the results of a sub aggregation. The trouble is that could end up\n+     * throwing away buckets on the data nodes that should ultimately be kept\n+     * after reducing all of the results. If you know that this is coming it\n+     * is fine, but most folks that use \"generic\" sorts don't. In other words:\n+     * before you use this method think super duper hard if you want to have\n+     * these kinds of issues. The terms agg does an folks get into trouble\n+     * with it all the time.\n+     * </p> \n+     */\n+    public abstract <T extends Bucket> Comparator<T> partiallyBuiltBucketComparator(ToLongFunction<T> ordinalReader, Aggregator aggregator);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcyMjMyOQ=="}, "originalCommit": {"oid": "bd02073c9b3e36bb54d83d949c21c032b0315175"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI5MjYyNg==", "bodyText": "Coolio.  A battle for a different day then!", "url": "https://github.com/elastic/elasticsearch/pull/52769#discussion_r385292626", "createdAt": "2020-02-27T18:30:17Z", "author": {"login": "polyfractal"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/BucketOrder.java", "diffHunk": "@@ -98,16 +101,39 @@ public static BucketOrder compound(BucketOrder... orders) {\n     }\n \n     /**\n-     * @return A comparator for the bucket based on the given aggregator. The comparator is used in two phases:\n-     * <p>\n-     * - aggregation phase, where each shard builds a list of buckets to be sent to the coordinating node.\n-     * In this phase, the passed in aggregator will be the aggregator that aggregates the buckets on the\n-     * shard level.\n+     * Validate an aggregation against an aggregator.\n+     */\n+    public final void validate(Aggregator aggregator) {\n+        /*\n+         * Building partiallyBuiltBucketComparator and throwing it away is enough\n+         * to validate this order because doing so checks all of the appropriate\n+         * paths.\n+         */\n+        partiallyBuiltBucketComparator(null, aggregator);\n+    }\n+\n+    /**\n+     * A builds comparator comparing buckets partially built buckets by\n+     * delegating comparison of the results of any \"child\" aggregations to\n+     * the provided {@linkplain Aggregator}.\n      * <p>\n-     * - reduce phase, where the coordinating node gathers all the buckets from all the shards and reduces them\n-     * to a final bucket list. In this case, the passed in aggregator will be {@code null}.\n+     * Warning: This is fairly difficult to use and impossible to use cleanly.\n+     * In addition, this exists primarily to return the \"top n\" buckets based\n+     * on the results of a sub aggregation. The trouble is that could end up\n+     * throwing away buckets on the data nodes that should ultimately be kept\n+     * after reducing all of the results. If you know that this is coming it\n+     * is fine, but most folks that use \"generic\" sorts don't. In other words:\n+     * before you use this method think super duper hard if you want to have\n+     * these kinds of issues. The terms agg does an folks get into trouble\n+     * with it all the time.\n+     * </p> \n+     */\n+    public abstract <T extends Bucket> Comparator<T> partiallyBuiltBucketComparator(ToLongFunction<T> ordinalReader, Aggregator aggregator);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcyMjMyOQ=="}, "originalCommit": {"oid": "bd02073c9b3e36bb54d83d949c21c032b0315175"}, "originalPosition": 56}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3786, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}