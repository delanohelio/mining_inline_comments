{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgxMjE1MTcz", "number": 52936, "title": "Add REST endpoint to register a new SAML SP", "bodyText": "This change adds a new PUT /_idp/saml/sp/{entity_id} endpoint that\nregisters (or updates) a Service Provider in the IDP.", "createdAt": "2020-02-28T05:49:49Z", "url": "https://github.com/elastic/elasticsearch/pull/52936", "merged": true, "mergeCommit": {"oid": "0cd3ba919ae24b87f171bb643c5e6e41cc5f6f11"}, "closed": true, "closedAt": "2020-03-05T03:46:34Z", "author": {"login": "tvernum"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcIpW4zgH2gAyMzgxMjE1MTczOjAwMDEyNTc5YjcwNDkzYjg0OWZiYTBkYjZhMDliOThiZWRiZmY2NjI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcKgOejAH2gAyMzgxMjE1MTczOjAxNzA1Mzk3YmYwNmYyOGRhZDAzNDJlNGIzNDkzOTcwMGQ4OTdmMzU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "00012579b70493b849fba0db6a09b98bedbff662", "author": {"user": {"login": "tvernum", "name": "Tim Vernum"}}, "url": "https://github.com/elastic/elasticsearch/commit/00012579b70493b849fba0db6a09b98bedbff662", "committedDate": "2020-02-28T05:48:35Z", "message": "Add REST endpoint to register a new SAML SP\n\nThis change adds a new PUT /_idp/saml/sp/{entity_id} endpoint that\nregisters (or updates) a Service Provider in the IDP."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aa3c3d198ec65e9a226e09d3d37350a39d59aca2", "author": {"user": {"login": "elasticmachine", "name": "Elastic Machine"}}, "url": "https://github.com/elastic/elasticsearch/commit/aa3c3d198ec65e9a226e09d3d37350a39d59aca2", "committedDate": "2020-02-28T06:09:28Z", "message": "Merge branch 'feature-internal-idp' into idp/sp-registration"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2Mjc4ODY5", "url": "https://github.com/elastic/elasticsearch/pull/52936#pullrequestreview-366278869", "createdAt": "2020-02-28T09:58:18Z", "commit": {"oid": "aa3c3d198ec65e9a226e09d3d37350a39d59aca2"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwOTo1ODoxOVrOFvvafw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxMzozMDoxM1rOFv0-eQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTYwNDIyMw==", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    \"[\" + SamlServiceProviderDocument.Fields.ACS + \"] must be a [https] URL\", validationException);\n          \n          \n            \n                                    \"[\" + SamlServiceProviderDocument.Fields.ACS + \"] must be an [https] URL\", validationException);", "url": "https://github.com/elastic/elasticsearch/pull/52936#discussion_r385604223", "createdAt": "2020-02-28T09:58:19Z", "author": {"login": "jkakavas"}, "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/action/PutSamlServiceProviderRequest.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.idp.action;\n+\n+import org.elasticsearch.ElasticsearchParseException;\n+import org.elasticsearch.action.ActionRequest;\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.ValidationException;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.xpack.idp.saml.sp.SamlServiceProviderDocument;\n+\n+import java.io.IOException;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.action.ValidateActions.addValidationError;\n+\n+public class PutSamlServiceProviderRequest extends ActionRequest {\n+\n+    private final SamlServiceProviderDocument document;\n+\n+    public static PutSamlServiceProviderRequest fromXContent(String entityId, XContentParser parser) throws IOException {\n+        final SamlServiceProviderDocument document = SamlServiceProviderDocument.fromXContent(null, parser);\n+        if (document.entityId == null) {\n+            document.setEntityId(entityId);\n+        } else if (entityId != null) {\n+            if (entityId.equals(document.entityId) == false) {\n+                throw new ElasticsearchParseException(\n+                    \"Entity id [{}] inside request body and entity id [{}] from parameter do not match\", document.entityId, entityId);\n+            }\n+        }\n+        if (document.created != null) {\n+            throw new ElasticsearchParseException(\n+                \"Field [{}] may not be specified in a request\", SamlServiceProviderDocument.Fields.CREATED_DATE);\n+        }\n+        if (document.lastModified != null) {\n+            throw new ElasticsearchParseException(\n+                \"Field [{}] may not be specified in a request\", SamlServiceProviderDocument.Fields.LAST_MODIFIED);\n+        }\n+        document.setCreatedMillis(System.currentTimeMillis());\n+        document.setLastModifiedMillis(System.currentTimeMillis());\n+        return new PutSamlServiceProviderRequest(document);\n+    }\n+\n+    public PutSamlServiceProviderRequest(SamlServiceProviderDocument document) {\n+        this.document = document;\n+    }\n+\n+    public PutSamlServiceProviderRequest(StreamInput in) throws IOException {\n+        this.document = new SamlServiceProviderDocument(in);\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        document.writeTo(out);\n+    }\n+\n+    public SamlServiceProviderDocument getDocument() {\n+        return document;\n+    }\n+\n+    @Override\n+    public ActionRequestValidationException validate() {\n+        final ValidationException docException = document.validate();\n+        ActionRequestValidationException validationException = null;\n+        if (docException != null) {\n+            validationException = new ActionRequestValidationException();\n+            validationException.addValidationErrors(docException.validationErrors());\n+        }\n+\n+        if (Strings.hasText(document.acs)) { // if this is blank the document validation will fail\n+            try {\n+                final URL url = new URL(document.acs);\n+                if (url.getProtocol().equals(\"https\") == false) {\n+                    validationException = addValidationError(\n+                        \"[\" + SamlServiceProviderDocument.Fields.ACS + \"] must be a [https] URL\", validationException);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa3c3d198ec65e9a226e09d3d37350a39d59aca2"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY2MDI0Nw==", "bodyText": "Given that we do not have a consensus on which component of the IDP will be generating the IDP signing certificates and the fact that the caller of this API will in principal be only an IDP administrator, why do we disallow this up front ?", "url": "https://github.com/elastic/elasticsearch/pull/52936#discussion_r385660247", "createdAt": "2020-02-28T12:05:55Z", "author": {"login": "jkakavas"}, "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/action/PutSamlServiceProviderRequest.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.idp.action;\n+\n+import org.elasticsearch.ElasticsearchParseException;\n+import org.elasticsearch.action.ActionRequest;\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.ValidationException;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.xpack.idp.saml.sp.SamlServiceProviderDocument;\n+\n+import java.io.IOException;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.action.ValidateActions.addValidationError;\n+\n+public class PutSamlServiceProviderRequest extends ActionRequest {\n+\n+    private final SamlServiceProviderDocument document;\n+\n+    public static PutSamlServiceProviderRequest fromXContent(String entityId, XContentParser parser) throws IOException {\n+        final SamlServiceProviderDocument document = SamlServiceProviderDocument.fromXContent(null, parser);\n+        if (document.entityId == null) {\n+            document.setEntityId(entityId);\n+        } else if (entityId != null) {\n+            if (entityId.equals(document.entityId) == false) {\n+                throw new ElasticsearchParseException(\n+                    \"Entity id [{}] inside request body and entity id [{}] from parameter do not match\", document.entityId, entityId);\n+            }\n+        }\n+        if (document.created != null) {\n+            throw new ElasticsearchParseException(\n+                \"Field [{}] may not be specified in a request\", SamlServiceProviderDocument.Fields.CREATED_DATE);\n+        }\n+        if (document.lastModified != null) {\n+            throw new ElasticsearchParseException(\n+                \"Field [{}] may not be specified in a request\", SamlServiceProviderDocument.Fields.LAST_MODIFIED);\n+        }\n+        document.setCreatedMillis(System.currentTimeMillis());\n+        document.setLastModifiedMillis(System.currentTimeMillis());\n+        return new PutSamlServiceProviderRequest(document);\n+    }\n+\n+    public PutSamlServiceProviderRequest(SamlServiceProviderDocument document) {\n+        this.document = document;\n+    }\n+\n+    public PutSamlServiceProviderRequest(StreamInput in) throws IOException {\n+        this.document = new SamlServiceProviderDocument(in);\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        document.writeTo(out);\n+    }\n+\n+    public SamlServiceProviderDocument getDocument() {\n+        return document;\n+    }\n+\n+    @Override\n+    public ActionRequestValidationException validate() {\n+        final ValidationException docException = document.validate();\n+        ActionRequestValidationException validationException = null;\n+        if (docException != null) {\n+            validationException = new ActionRequestValidationException();\n+            validationException.addValidationErrors(docException.validationErrors());\n+        }\n+\n+        if (Strings.hasText(document.acs)) { // if this is blank the document validation will fail\n+            try {\n+                final URL url = new URL(document.acs);\n+                if (url.getProtocol().equals(\"https\") == false) {\n+                    validationException = addValidationError(\n+                        \"[\" + SamlServiceProviderDocument.Fields.ACS + \"] must be a [https] URL\", validationException);\n+                }\n+            } catch (MalformedURLException e) {\n+                String error = \"[\" + SamlServiceProviderDocument.Fields.ACS + \"] must be a valid URL\";\n+                if (e.getMessage() != null) {\n+                    error += \" - \" + e.getMessage();\n+                }\n+                validationException = addValidationError(error, validationException);\n+            }\n+        }\n+\n+        if (document.certificates.identityProviderSigning.isEmpty() == false) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa3c3d198ec65e9a226e09d3d37350a39d59aca2"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY2MTQwNw==", "bodyText": "nit: use getPreferredName() for consistency. Or. given that toString() actually calls  getPreferredName() maybe remove the getPreferredName() from other places i.e. like SamlServiceProviderDocument#validate ?", "url": "https://github.com/elastic/elasticsearch/pull/52936#discussion_r385661407", "createdAt": "2020-02-28T12:09:07Z", "author": {"login": "jkakavas"}, "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/action/PutSamlServiceProviderRequest.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.idp.action;\n+\n+import org.elasticsearch.ElasticsearchParseException;\n+import org.elasticsearch.action.ActionRequest;\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.ValidationException;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.xpack.idp.saml.sp.SamlServiceProviderDocument;\n+\n+import java.io.IOException;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.action.ValidateActions.addValidationError;\n+\n+public class PutSamlServiceProviderRequest extends ActionRequest {\n+\n+    private final SamlServiceProviderDocument document;\n+\n+    public static PutSamlServiceProviderRequest fromXContent(String entityId, XContentParser parser) throws IOException {\n+        final SamlServiceProviderDocument document = SamlServiceProviderDocument.fromXContent(null, parser);\n+        if (document.entityId == null) {\n+            document.setEntityId(entityId);\n+        } else if (entityId != null) {\n+            if (entityId.equals(document.entityId) == false) {\n+                throw new ElasticsearchParseException(\n+                    \"Entity id [{}] inside request body and entity id [{}] from parameter do not match\", document.entityId, entityId);\n+            }\n+        }\n+        if (document.created != null) {\n+            throw new ElasticsearchParseException(\n+                \"Field [{}] may not be specified in a request\", SamlServiceProviderDocument.Fields.CREATED_DATE);\n+        }\n+        if (document.lastModified != null) {\n+            throw new ElasticsearchParseException(\n+                \"Field [{}] may not be specified in a request\", SamlServiceProviderDocument.Fields.LAST_MODIFIED);\n+        }\n+        document.setCreatedMillis(System.currentTimeMillis());\n+        document.setLastModifiedMillis(System.currentTimeMillis());\n+        return new PutSamlServiceProviderRequest(document);\n+    }\n+\n+    public PutSamlServiceProviderRequest(SamlServiceProviderDocument document) {\n+        this.document = document;\n+    }\n+\n+    public PutSamlServiceProviderRequest(StreamInput in) throws IOException {\n+        this.document = new SamlServiceProviderDocument(in);\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        document.writeTo(out);\n+    }\n+\n+    public SamlServiceProviderDocument getDocument() {\n+        return document;\n+    }\n+\n+    @Override\n+    public ActionRequestValidationException validate() {\n+        final ValidationException docException = document.validate();\n+        ActionRequestValidationException validationException = null;\n+        if (docException != null) {\n+            validationException = new ActionRequestValidationException();\n+            validationException.addValidationErrors(docException.validationErrors());\n+        }\n+\n+        if (Strings.hasText(document.acs)) { // if this is blank the document validation will fail\n+            try {\n+                final URL url = new URL(document.acs);\n+                if (url.getProtocol().equals(\"https\") == false) {\n+                    validationException = addValidationError(\n+                        \"[\" + SamlServiceProviderDocument.Fields.ACS + \"] must be a [https] URL\", validationException);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa3c3d198ec65e9a226e09d3d37350a39d59aca2"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY2MzMwMQ==", "bodyText": "it reads slightly strange that we split the validation in 3 parts ( PutSamlServiceProviderRequest#fromXContent, PutSamlServiceProviderRequest#validate and SamlServiceProviderDocument#validate ) but the semantics of the validation in each step and the fact that we reuse SamlServiceProviderDocument#fromXContent  probably leaves no other choice.  Could maybe a fromSource and fromRequest split where both call fromXContent but do different validation depending on the context make this clearer ? Just a thought", "url": "https://github.com/elastic/elasticsearch/pull/52936#discussion_r385663301", "createdAt": "2020-02-28T12:14:11Z", "author": {"login": "jkakavas"}, "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/action/PutSamlServiceProviderRequest.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.idp.action;\n+\n+import org.elasticsearch.ElasticsearchParseException;\n+import org.elasticsearch.action.ActionRequest;\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.ValidationException;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.xpack.idp.saml.sp.SamlServiceProviderDocument;\n+\n+import java.io.IOException;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.action.ValidateActions.addValidationError;\n+\n+public class PutSamlServiceProviderRequest extends ActionRequest {\n+\n+    private final SamlServiceProviderDocument document;\n+\n+    public static PutSamlServiceProviderRequest fromXContent(String entityId, XContentParser parser) throws IOException {\n+        final SamlServiceProviderDocument document = SamlServiceProviderDocument.fromXContent(null, parser);\n+        if (document.entityId == null) {\n+            document.setEntityId(entityId);\n+        } else if (entityId != null) {\n+            if (entityId.equals(document.entityId) == false) {\n+                throw new ElasticsearchParseException(\n+                    \"Entity id [{}] inside request body and entity id [{}] from parameter do not match\", document.entityId, entityId);\n+            }\n+        }\n+        if (document.created != null) {\n+            throw new ElasticsearchParseException(\n+                \"Field [{}] may not be specified in a request\", SamlServiceProviderDocument.Fields.CREATED_DATE);\n+        }\n+        if (document.lastModified != null) {\n+            throw new ElasticsearchParseException(\n+                \"Field [{}] may not be specified in a request\", SamlServiceProviderDocument.Fields.LAST_MODIFIED);\n+        }\n+        document.setCreatedMillis(System.currentTimeMillis());\n+        document.setLastModifiedMillis(System.currentTimeMillis());\n+        return new PutSamlServiceProviderRequest(document);\n+    }\n+\n+    public PutSamlServiceProviderRequest(SamlServiceProviderDocument document) {\n+        this.document = document;\n+    }\n+\n+    public PutSamlServiceProviderRequest(StreamInput in) throws IOException {\n+        this.document = new SamlServiceProviderDocument(in);\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        document.writeTo(out);\n+    }\n+\n+    public SamlServiceProviderDocument getDocument() {\n+        return document;\n+    }\n+\n+    @Override\n+    public ActionRequestValidationException validate() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa3c3d198ec65e9a226e09d3d37350a39d59aca2"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY2NDcyNw==", "bodyText": "Make these private final and add getters ?", "url": "https://github.com/elastic/elasticsearch/pull/52936#discussion_r385664727", "createdAt": "2020-02-28T12:17:58Z", "author": {"login": "jkakavas"}, "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/action/PutSamlServiceProviderResponse.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.idp.action;\n+\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+\n+public class PutSamlServiceProviderResponse extends ActionResponse implements ToXContentObject {\n+\n+    public String docId;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa3c3d198ec65e9a226e09d3d37350a39d59aca2"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY4NzM1MA==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/elastic/elasticsearch/pull/52936#discussion_r385687350", "createdAt": "2020-02-28T13:12:40Z", "author": {"login": "jkakavas"}, "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/action/TransportPutSamlServiceProviderAction.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.idp.action;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.DocWriteRequest;\n+import org.elasticsearch.action.DocWriteResponse;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.HandledTransportAction;\n+import org.elasticsearch.common.ValidationException;\n+import org.elasticsearch.common.hash.MessageDigests;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.util.iterable.Iterables;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.idp.saml.sp.SamlServiceProviderDocument;\n+import org.elasticsearch.xpack.idp.saml.sp.SamlServiceProviderIndex;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.time.Clock;\n+import java.time.Instant;\n+import java.util.Base64;\n+import java.util.stream.Collectors;\n+\n+public class TransportPutSamlServiceProviderAction\n+    extends HandledTransportAction<PutSamlServiceProviderRequest, PutSamlServiceProviderResponse> {\n+\n+    private final Logger logger = LogManager.getLogger();\n+    private final SamlServiceProviderIndex index;\n+    private final Clock clock;\n+\n+    @Inject\n+    public TransportPutSamlServiceProviderAction(TransportService transportService, ActionFilters actionFilters,\n+                                                 SamlServiceProviderIndex index) {\n+        this(transportService, actionFilters, index, Clock.systemUTC());\n+    }\n+\n+    TransportPutSamlServiceProviderAction(TransportService transportService, ActionFilters actionFilters,\n+                                                 SamlServiceProviderIndex index, Clock clock) {\n+        super(PutSamlServiceProviderAction.NAME, transportService, actionFilters, PutSamlServiceProviderRequest::new);\n+        this.index = index;\n+        this.clock = clock;\n+    }\n+\n+    @Override\n+    protected void doExecute(Task task, final PutSamlServiceProviderRequest request,\n+                             final ActionListener<PutSamlServiceProviderResponse> listener) {\n+        final SamlServiceProviderDocument document = request.getDocument();\n+        if (document.docId != null) {\n+            listener.onFailure(new IllegalArgumentException(\"request document must not have an id [\" + document.docId + \"]\"));\n+            return;\n+        }\n+        index.findByEntityId(document.entityId, ActionListener.wrap(matchingDocuments -> {\n+            if (matchingDocuments.isEmpty()) {\n+                // derive a document id from the entity id so that don't accidentally create duplicate entities due to a race condition\n+                document.docId = deriveDocumentId(document);\n+                // force a create in case there are concurrent requests\n+                writeDocument(document, DocWriteRequest.OpType.CREATE, listener);\n+            } else if (matchingDocuments.size() == 1) {\n+                SamlServiceProviderDocument existingDoc = Iterables.get(matchingDocuments, 0);\n+                assert existingDoc.docId != null : \"Loaded document with no doc id\";\n+                assert existingDoc.entityId.equals(document.entityId) : \"Loaded document with non-matching entity-id\";\n+                document.setDocId(existingDoc.docId);\n+                document.setCreated(existingDoc.created);\n+                writeDocument(document, DocWriteRequest.OpType.INDEX, listener);\n+            } else {\n+                logger.warn(\"Found multiple existing service providers in [{}] with entity id [{}] - [{}]\",\n+                    index, document.entityId, matchingDocuments.stream().map(d -> d.docId).collect(Collectors.joining(\",\")));\n+                listener.onFailure(new IllegalStateException(\n+                    \"Multiple service providers already exist with entity id [\" + document.entityId + \"]\"));\n+            }\n+        }, listener::onFailure));\n+    }\n+\n+    private void writeDocument(SamlServiceProviderDocument document, DocWriteRequest.OpType opType,\n+                               ActionListener<PutSamlServiceProviderResponse> listener) {\n+        final Instant now = clock.instant();\n+        if (document.created == null || opType == DocWriteRequest.OpType.CREATE) {\n+            document.created = now;\n+        }\n+        document.lastModified = now;\n+        final ValidationException validationException = document.validate();\n+        if (validationException != null) {\n+            listener.onFailure(validationException);\n+            return;\n+        }\n+        logger.debug(\"[{}] service provider [{}] in document [{}] of [{}]\", opType, document.entityId, document.docId, index);\n+        index.writeDocument(document, opType, ActionListener.wrap(\n+            response -> listener.onResponse(new PutSamlServiceProviderResponse(\n+                response.getId(),\n+                response.getResult() == DocWriteResponse.Result.CREATED,\n+                response.getSeqNo(),\n+                response.getPrimaryTerm(),\n+                document.entityId,\n+                document.enabled)),\n+            listener::onFailure\n+        ));\n+    }\n+\n+    private String deriveDocumentId(SamlServiceProviderDocument document) {\n+        final byte[] sha256 = MessageDigests.sha256().digest(document.entityId.getBytes(StandardCharsets.UTF_8));\n+        return Base64.getUrlEncoder().withoutPadding().encodeToString(sha256);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa3c3d198ec65e9a226e09d3d37350a39d59aca2"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY4OTMzNA==", "bodyText": "we could export document.entityId in a local var here and call deriveDocumentId with that too below as this is the only field we use from the document", "url": "https://github.com/elastic/elasticsearch/pull/52936#discussion_r385689334", "createdAt": "2020-02-28T13:17:27Z", "author": {"login": "jkakavas"}, "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/action/TransportPutSamlServiceProviderAction.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.idp.action;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.DocWriteRequest;\n+import org.elasticsearch.action.DocWriteResponse;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.HandledTransportAction;\n+import org.elasticsearch.common.ValidationException;\n+import org.elasticsearch.common.hash.MessageDigests;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.util.iterable.Iterables;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.idp.saml.sp.SamlServiceProviderDocument;\n+import org.elasticsearch.xpack.idp.saml.sp.SamlServiceProviderIndex;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.time.Clock;\n+import java.time.Instant;\n+import java.util.Base64;\n+import java.util.stream.Collectors;\n+\n+public class TransportPutSamlServiceProviderAction\n+    extends HandledTransportAction<PutSamlServiceProviderRequest, PutSamlServiceProviderResponse> {\n+\n+    private final Logger logger = LogManager.getLogger();\n+    private final SamlServiceProviderIndex index;\n+    private final Clock clock;\n+\n+    @Inject\n+    public TransportPutSamlServiceProviderAction(TransportService transportService, ActionFilters actionFilters,\n+                                                 SamlServiceProviderIndex index) {\n+        this(transportService, actionFilters, index, Clock.systemUTC());\n+    }\n+\n+    TransportPutSamlServiceProviderAction(TransportService transportService, ActionFilters actionFilters,\n+                                                 SamlServiceProviderIndex index, Clock clock) {\n+        super(PutSamlServiceProviderAction.NAME, transportService, actionFilters, PutSamlServiceProviderRequest::new);\n+        this.index = index;\n+        this.clock = clock;\n+    }\n+\n+    @Override\n+    protected void doExecute(Task task, final PutSamlServiceProviderRequest request,\n+                             final ActionListener<PutSamlServiceProviderResponse> listener) {\n+        final SamlServiceProviderDocument document = request.getDocument();\n+        if (document.docId != null) {\n+            listener.onFailure(new IllegalArgumentException(\"request document must not have an id [\" + document.docId + \"]\"));\n+            return;\n+        }\n+        index.findByEntityId(document.entityId, ActionListener.wrap(matchingDocuments -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa3c3d198ec65e9a226e09d3d37350a39d59aca2"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY5MDk2Mw==", "bodyText": "Question : Why is this a check we fail specifically upon as opposed to just an assertion like the null Id or entityIds not matching ? Isn't this equally improbable ?", "url": "https://github.com/elastic/elasticsearch/pull/52936#discussion_r385690963", "createdAt": "2020-02-28T13:20:57Z", "author": {"login": "jkakavas"}, "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/action/TransportPutSamlServiceProviderAction.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.idp.action;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.DocWriteRequest;\n+import org.elasticsearch.action.DocWriteResponse;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.HandledTransportAction;\n+import org.elasticsearch.common.ValidationException;\n+import org.elasticsearch.common.hash.MessageDigests;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.util.iterable.Iterables;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.idp.saml.sp.SamlServiceProviderDocument;\n+import org.elasticsearch.xpack.idp.saml.sp.SamlServiceProviderIndex;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.time.Clock;\n+import java.time.Instant;\n+import java.util.Base64;\n+import java.util.stream.Collectors;\n+\n+public class TransportPutSamlServiceProviderAction\n+    extends HandledTransportAction<PutSamlServiceProviderRequest, PutSamlServiceProviderResponse> {\n+\n+    private final Logger logger = LogManager.getLogger();\n+    private final SamlServiceProviderIndex index;\n+    private final Clock clock;\n+\n+    @Inject\n+    public TransportPutSamlServiceProviderAction(TransportService transportService, ActionFilters actionFilters,\n+                                                 SamlServiceProviderIndex index) {\n+        this(transportService, actionFilters, index, Clock.systemUTC());\n+    }\n+\n+    TransportPutSamlServiceProviderAction(TransportService transportService, ActionFilters actionFilters,\n+                                                 SamlServiceProviderIndex index, Clock clock) {\n+        super(PutSamlServiceProviderAction.NAME, transportService, actionFilters, PutSamlServiceProviderRequest::new);\n+        this.index = index;\n+        this.clock = clock;\n+    }\n+\n+    @Override\n+    protected void doExecute(Task task, final PutSamlServiceProviderRequest request,\n+                             final ActionListener<PutSamlServiceProviderResponse> listener) {\n+        final SamlServiceProviderDocument document = request.getDocument();\n+        if (document.docId != null) {\n+            listener.onFailure(new IllegalArgumentException(\"request document must not have an id [\" + document.docId + \"]\"));\n+            return;\n+        }\n+        index.findByEntityId(document.entityId, ActionListener.wrap(matchingDocuments -> {\n+            if (matchingDocuments.isEmpty()) {\n+                // derive a document id from the entity id so that don't accidentally create duplicate entities due to a race condition\n+                document.docId = deriveDocumentId(document);\n+                // force a create in case there are concurrent requests\n+                writeDocument(document, DocWriteRequest.OpType.CREATE, listener);\n+            } else if (matchingDocuments.size() == 1) {\n+                SamlServiceProviderDocument existingDoc = Iterables.get(matchingDocuments, 0);\n+                assert existingDoc.docId != null : \"Loaded document with no doc id\";\n+                assert existingDoc.entityId.equals(document.entityId) : \"Loaded document with non-matching entity-id\";\n+                document.setDocId(existingDoc.docId);\n+                document.setCreated(existingDoc.created);\n+                writeDocument(document, DocWriteRequest.OpType.INDEX, listener);\n+            } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa3c3d198ec65e9a226e09d3d37350a39d59aca2"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY5MTIxMw==", "bodyText": "Can you elaborate on this comment?", "url": "https://github.com/elastic/elasticsearch/pull/52936#discussion_r385691213", "createdAt": "2020-02-28T13:21:24Z", "author": {"login": "jkakavas"}, "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/action/TransportPutSamlServiceProviderAction.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.idp.action;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.DocWriteRequest;\n+import org.elasticsearch.action.DocWriteResponse;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.HandledTransportAction;\n+import org.elasticsearch.common.ValidationException;\n+import org.elasticsearch.common.hash.MessageDigests;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.util.iterable.Iterables;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.idp.saml.sp.SamlServiceProviderDocument;\n+import org.elasticsearch.xpack.idp.saml.sp.SamlServiceProviderIndex;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.time.Clock;\n+import java.time.Instant;\n+import java.util.Base64;\n+import java.util.stream.Collectors;\n+\n+public class TransportPutSamlServiceProviderAction\n+    extends HandledTransportAction<PutSamlServiceProviderRequest, PutSamlServiceProviderResponse> {\n+\n+    private final Logger logger = LogManager.getLogger();\n+    private final SamlServiceProviderIndex index;\n+    private final Clock clock;\n+\n+    @Inject\n+    public TransportPutSamlServiceProviderAction(TransportService transportService, ActionFilters actionFilters,\n+                                                 SamlServiceProviderIndex index) {\n+        this(transportService, actionFilters, index, Clock.systemUTC());\n+    }\n+\n+    TransportPutSamlServiceProviderAction(TransportService transportService, ActionFilters actionFilters,\n+                                                 SamlServiceProviderIndex index, Clock clock) {\n+        super(PutSamlServiceProviderAction.NAME, transportService, actionFilters, PutSamlServiceProviderRequest::new);\n+        this.index = index;\n+        this.clock = clock;\n+    }\n+\n+    @Override\n+    protected void doExecute(Task task, final PutSamlServiceProviderRequest request,\n+                             final ActionListener<PutSamlServiceProviderResponse> listener) {\n+        final SamlServiceProviderDocument document = request.getDocument();\n+        if (document.docId != null) {\n+            listener.onFailure(new IllegalArgumentException(\"request document must not have an id [\" + document.docId + \"]\"));\n+            return;\n+        }\n+        index.findByEntityId(document.entityId, ActionListener.wrap(matchingDocuments -> {\n+            if (matchingDocuments.isEmpty()) {\n+                // derive a document id from the entity id so that don't accidentally create duplicate entities due to a race condition\n+                document.docId = deriveDocumentId(document);\n+                // force a create in case there are concurrent requests", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa3c3d198ec65e9a226e09d3d37350a39d59aca2"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY5Mzc3MQ==", "bodyText": "You either rename this to sp_entity_id or we rename the parameter in the get metadata API to entity_id, for consistency", "url": "https://github.com/elastic/elasticsearch/pull/52936#discussion_r385693771", "createdAt": "2020-02-28T13:26:43Z", "author": {"login": "jkakavas"}, "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/saml/rest/action/RestPutSamlServiceProviderAction.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.idp.saml.rest.action;\n+\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.rest.BaseRestHandler;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.RestRequest.Method;\n+import org.elasticsearch.rest.RestResponse;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.rest.action.RestBuilderListener;\n+import org.elasticsearch.xpack.idp.action.PutSamlServiceProviderAction;\n+import org.elasticsearch.xpack.idp.action.PutSamlServiceProviderRequest;\n+import org.elasticsearch.xpack.idp.action.PutSamlServiceProviderResponse;\n+\n+import java.io.IOException;\n+import java.util.List;\n+\n+public class RestPutSamlServiceProviderAction extends BaseRestHandler {\n+\n+    @Override\n+    public String getName() {\n+        return \"idp_put_saml_sp_action\";\n+    }\n+\n+    @Override\n+    public List<Route> routes() {\n+        return List.of(\n+            new Route(Method.PUT, \"/_idp/saml/sp/{entity_id}\"),\n+            new Route(Method.POST, \"/_idp/saml/sp/{entity_id}\")\n+        );\n+    }\n+\n+    @Override\n+    protected RestChannelConsumer prepareRequest(RestRequest restRequest, NodeClient client) throws IOException {\n+        final String entityId = restRequest.param(\"entity_id\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa3c3d198ec65e9a226e09d3d37350a39d59aca2"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY5NTM1Mw==", "bodyText": "Good chance to create StreamOutput#writeOptionalVLong ,StreamInput#readOptionalVLong this could be used in ~15 places in our codebase", "url": "https://github.com/elastic/elasticsearch/pull/52936#discussion_r385695353", "createdAt": "2020-02-28T13:30:13Z", "author": {"login": "jkakavas"}, "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/saml/sp/SamlServiceProviderDocument.java", "diffHunk": "@@ -247,6 +250,68 @@ public int hashCode() {\n     public final AttributeNames attributeNames = new AttributeNames();\n     public final Certificates certificates = new Certificates();\n \n+    public SamlServiceProviderDocument() {\n+    }\n+\n+    public SamlServiceProviderDocument(StreamInput in) throws IOException {\n+        docId = in.readOptionalString();\n+        name = in.readString();\n+        entityId = in.readString();\n+        acs = in.readString();\n+        enabled = in.readBoolean();\n+        created = in.readInstant();\n+        lastModified = in.readInstant();\n+        nameIdFormats = in.readSet(StreamInput::readString);\n+        authenticationExpiryMillis = in.readBoolean() ? in.readVLong() : null;\n+\n+        privileges.application = in.readOptionalString();\n+        privileges.resource = in.readString();\n+        privileges.loginAction = in.readOptionalString();\n+        privileges.groupActions = in.readMap(StreamInput::readString, StreamInput::readString);\n+\n+        attributeNames.principal = in.readString();\n+        attributeNames.email = in.readOptionalString();\n+        attributeNames.name = in.readOptionalString();\n+        attributeNames.groups = in.readOptionalString();\n+\n+        certificates.serviceProviderSigning = in.readStringList();\n+        certificates.identityProviderSigning = in.readStringList();\n+        certificates.identityProviderMetadataSigning = in.readStringList();\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        out.writeOptionalString(docId);\n+        out.writeString(name);\n+        out.writeString(entityId);\n+        out.writeString(acs);\n+        out.writeBoolean(enabled);\n+        out.writeInstant(created);\n+        out.writeInstant(lastModified);\n+        out.writeCollection(nameIdFormats, StreamOutput::writeString);\n+        if (authenticationExpiryMillis == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa3c3d198ec65e9a226e09d3d37350a39d59aca2"}, "originalPosition": 87}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b012d29ae51369ed3de5be4a3e957fc125949acf", "author": {"user": {"login": "tvernum", "name": "Tim Vernum"}}, "url": "https://github.com/elastic/elasticsearch/commit/b012d29ae51369ed3de5be4a3e957fc125949acf", "committedDate": "2020-03-02T03:18:43Z", "message": "Merge branch 'feature-internal-idp' into idp/sp-registration\n\n# Conflicts:\n#\tx-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/IdentityProviderPlugin.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7d62ef488316b5ecccd60bbe16bc145ca7f3fe0c", "author": {"user": {"login": "tvernum", "name": "Tim Vernum"}}, "url": "https://github.com/elastic/elasticsearch/commit/7d62ef488316b5ecccd60bbe16bc145ca7f3fe0c", "committedDate": "2020-03-02T03:23:07Z", "message": "Address feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3d57ca5f9a4a10c0d4aac9c217ac3033c85b5f70", "author": {"user": {"login": "tvernum", "name": "Tim Vernum"}}, "url": "https://github.com/elastic/elasticsearch/commit/3d57ca5f9a4a10c0d4aac9c217ac3033c85b5f70", "committedDate": "2020-03-02T03:24:00Z", "message": "Merge branch 'idp/sp-registration' of github.com:tvernum/elasticsearch into idp/sp-registration"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b7dc2663f731b7748a7cd302e10669e8c637cffc", "author": {"user": {"login": "tvernum", "name": "Tim Vernum"}}, "url": "https://github.com/elastic/elasticsearch/commit/b7dc2663f731b7748a7cd302e10669e8c637cffc", "committedDate": "2020-03-02T04:46:37Z", "message": "Fix test compilation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0a955b5d3141b15028ff5496340cf59d3fe4b7c6", "author": {"user": {"login": "tvernum", "name": "Tim Vernum"}}, "url": "https://github.com/elastic/elasticsearch/commit/0a955b5d3141b15028ff5496340cf59d3fe4b7c6", "committedDate": "2020-03-04T11:20:26Z", "message": "Update comment"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4NzAwNTk5", "url": "https://github.com/elastic/elasticsearch/pull/52936#pullrequestreview-368700599", "createdAt": "2020-03-04T11:27:03Z", "commit": {"oid": "0a955b5d3141b15028ff5496340cf59d3fe4b7c6"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "01705397bf06f28dad0342e4b34939700d897f35", "author": {"user": {"login": "tvernum", "name": "Tim Vernum"}}, "url": "https://github.com/elastic/elasticsearch/commit/01705397bf06f28dad0342e4b34939700d897f35", "committedDate": "2020-03-05T00:18:06Z", "message": "Merge branch 'feature-internal-idp' into idp/sp-registration"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2074, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}