{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYxMTUwMDIz", "number": 50820, "title": "Refresh cached phase policy definition if possible on new poli\u2026", "bodyText": "There are some cases when updating a policy does not change the\nstructure in a significant way. In these cases, we can reread the\npolicy definition for any indices using the updated policy.\nThis commit adds this refreshing to the TransportPutLifecycleAction\nto allow this. It allows us to do things like change the configuration\nvalues for a particular step, even when on that step (for example,\nchanging the rollover criteria while on the check-rollover-ready step).\nThere are more cases where the phase definition can be reread that just\nthe ones checked here (for example, removing an action that has already\nbeen passed), and those will be added in subsequent work.\nRelates to #48431", "createdAt": "2020-01-09T20:43:51Z", "url": "https://github.com/elastic/elasticsearch/pull/50820", "merged": true, "mergeCommit": {"oid": "f53c9680edd20559aa810e754815f1f6c558d7d6"}, "closed": true, "closedAt": "2020-01-13T20:44:57Z", "author": {"login": "dakrone"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb4wLXqgH2gAyMzYxMTUwMDIzOmE3YTIwMDBhMzBhZTU2MWU5NzAwMTVmNTQ1ZmNiZTlhMDIyMWY0NDQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb6Cfa8AFqTM0MjEyMjAwNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "a7a2000a30ae561e970015f545fcbe9a0221f444", "author": {"user": {"login": "dakrone", "name": "Lee Hinman"}}, "url": "https://github.com/elastic/elasticsearch/commit/a7a2000a30ae561e970015f545fcbe9a0221f444", "committedDate": "2020-01-09T20:42:33Z", "message": "Refresh cached phase policy definition if possible on new policy\n\nThere are some cases when updating a policy does not change the\nstructure in a significant way. In these cases, we can reread the\npolicy definition for any indices using the updated policy.\n\nThis commit adds this refreshing to the `TransportPutLifecycleAction`\nto allow this. It allows us to do things like change the configuration\nvalues for a particular step, even when on that step (for example,\nchanging the rollover criteria while on the `check-rollover-ready` step).\n\nThere are more cases where the phase definition can be reread that just\nthe ones checked here (for example, removing an action that has already\nbeen passed), and those will be added in subsequent work.\n\nRelates to #48431"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3f238049777a1b1083ae7c002ccbd8e96df1a6e1", "author": {"user": {"login": "dakrone", "name": "Lee Hinman"}}, "url": "https://github.com/elastic/elasticsearch/commit/3f238049777a1b1083ae7c002ccbd8e96df1a6e1", "committedDate": "2020-01-09T21:59:35Z", "message": "Don't double-build cluster state"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQxODExMTUz", "url": "https://github.com/elastic/elasticsearch/pull/50820#pullrequestreview-341811153", "createdAt": "2020-01-13T12:31:17Z", "commit": {"oid": "3f238049777a1b1083ae7c002ccbd8e96df1a6e1"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxMjozMToxN1rOFc1ZFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxNDowNzoyOFrOFc3-PA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc3OTIyMA==", "bodyText": "would it be clearer to rename this to isIndexPolicyUpdatable or indexPolicyCanBeSafelyUpdated? (to point out we're only looking at the index's ILM policy as opposed to more)", "url": "https://github.com/elastic/elasticsearch/pull/50820#discussion_r365779220", "createdAt": "2020-01-13T12:31:17Z", "author": {"login": "andreidan"}, "path": "x-pack/plugin/ilm/src/main/java/org/elasticsearch/xpack/ilm/action/TransportPutLifecycleAction.java", "diffHunk": "@@ -100,13 +122,195 @@ public ClusterState execute(ClusterState currentState) throws Exception {\n                             logger.info(\"updating index lifecycle policy [{}]\", request.getPolicy().getName());\n                         }\n                         IndexLifecycleMetadata newMetadata = new IndexLifecycleMetadata(newPolicies, currentMetadata.getOperationMode());\n-                        newState.metaData(MetaData.builder(currentState.getMetaData())\n+                        stateBuilder.metaData(MetaData.builder(currentState.getMetaData())\n                                 .putCustom(IndexLifecycleMetadata.TYPE, newMetadata).build());\n-                        return newState.build();\n+                        ClusterState nonRefreshedState = stateBuilder.build();\n+                        if (oldPolicy == null) {\n+                            return nonRefreshedState;\n+                        } else {\n+                            try {\n+                                return updateIndicesForPolicy(nonRefreshedState, xContentRegistry,\n+                                    oldPolicy.getPolicy(), lifecyclePolicyMetadata);\n+                            } catch (Exception e) {\n+                                logger.warn(new ParameterizedMessage(\"unable to refresh indices phase JSON for updated policy [{}]\",\n+                                    oldPolicy.getName()), e);\n+                                // Revert to the non-refreshed state\n+                                return nonRefreshedState;\n+                            }\n+                        }\n                     }\n                 });\n     }\n \n+    /**\n+     * Ensure that we have the minimum amount of metadata necessary to check for cache phase\n+     * refresh. This includes:\n+     * - An execution state\n+     * - Existing phase definition JSON\n+     * - A current step key\n+     * - A current phase in the step key\n+     * - Not currently in the ERROR step\n+     */\n+    static boolean eligibleToCheckForRefresh(final IndexMetaData metaData) {\n+        LifecycleExecutionState executionState = LifecycleExecutionState.fromIndexMetadata(metaData);\n+        if (executionState == null || executionState.getPhaseDefinition() == null) {\n+            return false;\n+        }\n+\n+        Step.StepKey currentStepKey = LifecycleExecutionState.getCurrentStepKey(executionState);\n+        if (currentStepKey == null || currentStepKey.getPhase() == null) {\n+            return false;\n+        }\n+\n+        return ErrorStep.NAME.equals(currentStepKey.getName()) == false;\n+    }\n+\n+    /**\n+     * Parse the {@code phaseDef} phase definition to get the stepkeys for the given phase.\n+     * If there is an error parsing or if the phase definition is missing the required\n+     * information, returns null.\n+     */\n+    @Nullable\n+    static Set<Step.StepKey> readStepKeys(final NamedXContentRegistry xContentRegistry, final String phaseDef,\n+                                          final String currentPhase) {\n+        final PhaseExecutionInfo phaseExecutionInfo;\n+        try (XContentParser parser = JsonXContent.jsonXContent.createParser(xContentRegistry,\n+            DeprecationHandler.THROW_UNSUPPORTED_OPERATION, phaseDef)) {\n+            phaseExecutionInfo = PhaseExecutionInfo.parse(parser, currentPhase);\n+        } catch (Exception e) {\n+            logger.trace(new ParameterizedMessage(\"exception reading step keys checking for refreshability, phase definition: {}\",\n+                phaseDef), e);\n+            return null;\n+        }\n+\n+        if (phaseExecutionInfo == null || phaseExecutionInfo.getPhase() == null) {\n+            return null;\n+        }\n+\n+        return phaseExecutionInfo.getPhase().getActions().values().stream()\n+            .flatMap(a -> a.toSteps(null, phaseExecutionInfo.getPhase().getName(), null).stream())\n+            .map(Step::getKey)\n+            .collect(Collectors.toCollection(LinkedHashSet::new));\n+    }\n+\n+    /**\n+     * Returns 'true' if the index's cached phase JSON can be safely reread, 'false' otherwise.\n+     */\n+    static boolean indexCanBeUpdatedSafely(final NamedXContentRegistry xContentRegistry,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f238049777a1b1083ae7c002ccbd8e96df1a6e1"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgxNDE0Ng==", "bodyText": "is passing null to toSteps safe? (I think it should only be used at execution time, but given that it depends on each action implementing LifecycleAction.toSteps and doing \"the right thing\" this makes me a bit nervous). Would it make sense to update the LifecyclePolicy/LifecyleAction docs to state that the client is nullable (annotate it as well) and maybe add some tests for the actions to make sure the steps are built correctly?", "url": "https://github.com/elastic/elasticsearch/pull/50820#discussion_r365814146", "createdAt": "2020-01-13T13:52:35Z", "author": {"login": "andreidan"}, "path": "x-pack/plugin/ilm/src/main/java/org/elasticsearch/xpack/ilm/action/TransportPutLifecycleAction.java", "diffHunk": "@@ -100,13 +122,195 @@ public ClusterState execute(ClusterState currentState) throws Exception {\n                             logger.info(\"updating index lifecycle policy [{}]\", request.getPolicy().getName());\n                         }\n                         IndexLifecycleMetadata newMetadata = new IndexLifecycleMetadata(newPolicies, currentMetadata.getOperationMode());\n-                        newState.metaData(MetaData.builder(currentState.getMetaData())\n+                        stateBuilder.metaData(MetaData.builder(currentState.getMetaData())\n                                 .putCustom(IndexLifecycleMetadata.TYPE, newMetadata).build());\n-                        return newState.build();\n+                        ClusterState nonRefreshedState = stateBuilder.build();\n+                        if (oldPolicy == null) {\n+                            return nonRefreshedState;\n+                        } else {\n+                            try {\n+                                return updateIndicesForPolicy(nonRefreshedState, xContentRegistry,\n+                                    oldPolicy.getPolicy(), lifecyclePolicyMetadata);\n+                            } catch (Exception e) {\n+                                logger.warn(new ParameterizedMessage(\"unable to refresh indices phase JSON for updated policy [{}]\",\n+                                    oldPolicy.getName()), e);\n+                                // Revert to the non-refreshed state\n+                                return nonRefreshedState;\n+                            }\n+                        }\n                     }\n                 });\n     }\n \n+    /**\n+     * Ensure that we have the minimum amount of metadata necessary to check for cache phase\n+     * refresh. This includes:\n+     * - An execution state\n+     * - Existing phase definition JSON\n+     * - A current step key\n+     * - A current phase in the step key\n+     * - Not currently in the ERROR step\n+     */\n+    static boolean eligibleToCheckForRefresh(final IndexMetaData metaData) {\n+        LifecycleExecutionState executionState = LifecycleExecutionState.fromIndexMetadata(metaData);\n+        if (executionState == null || executionState.getPhaseDefinition() == null) {\n+            return false;\n+        }\n+\n+        Step.StepKey currentStepKey = LifecycleExecutionState.getCurrentStepKey(executionState);\n+        if (currentStepKey == null || currentStepKey.getPhase() == null) {\n+            return false;\n+        }\n+\n+        return ErrorStep.NAME.equals(currentStepKey.getName()) == false;\n+    }\n+\n+    /**\n+     * Parse the {@code phaseDef} phase definition to get the stepkeys for the given phase.\n+     * If there is an error parsing or if the phase definition is missing the required\n+     * information, returns null.\n+     */\n+    @Nullable\n+    static Set<Step.StepKey> readStepKeys(final NamedXContentRegistry xContentRegistry, final String phaseDef,\n+                                          final String currentPhase) {\n+        final PhaseExecutionInfo phaseExecutionInfo;\n+        try (XContentParser parser = JsonXContent.jsonXContent.createParser(xContentRegistry,\n+            DeprecationHandler.THROW_UNSUPPORTED_OPERATION, phaseDef)) {\n+            phaseExecutionInfo = PhaseExecutionInfo.parse(parser, currentPhase);\n+        } catch (Exception e) {\n+            logger.trace(new ParameterizedMessage(\"exception reading step keys checking for refreshability, phase definition: {}\",\n+                phaseDef), e);\n+            return null;\n+        }\n+\n+        if (phaseExecutionInfo == null || phaseExecutionInfo.getPhase() == null) {\n+            return null;\n+        }\n+\n+        return phaseExecutionInfo.getPhase().getActions().values().stream()\n+            .flatMap(a -> a.toSteps(null, phaseExecutionInfo.getPhase().getName(), null).stream())\n+            .map(Step::getKey)\n+            .collect(Collectors.toCollection(LinkedHashSet::new));\n+    }\n+\n+    /**\n+     * Returns 'true' if the index's cached phase JSON can be safely reread, 'false' otherwise.\n+     */\n+    static boolean indexCanBeUpdatedSafely(final NamedXContentRegistry xContentRegistry,\n+                                           final IndexMetaData metaData, final LifecyclePolicy newPolicy) {\n+        final String index = metaData.getIndex().getName();\n+        if (eligibleToCheckForRefresh(metaData) == false) {\n+            logger.debug(\"[{}] does not contain enough information to check for eligibility of refreshing phase\", index);\n+            return false;\n+        }\n+        final String policyId = newPolicy.getName();\n+\n+        final LifecycleExecutionState executionState = LifecycleExecutionState.fromIndexMetadata(metaData);\n+        final Step.StepKey currentStepKey = LifecycleExecutionState.getCurrentStepKey(executionState);\n+        final String currentPhase = currentStepKey.getPhase();\n+\n+        final Set<Step.StepKey> newStepKeys = newPolicy.toSteps(null).stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f238049777a1b1083ae7c002ccbd8e96df1a6e1"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgxNTg2Mw==", "bodyText": "nit (maybe just personal preference so feel free to ignore) but phaseExecutionInfo is more readble to me (phaseExecutionInfoJson too)", "url": "https://github.com/elastic/elasticsearch/pull/50820#discussion_r365815863", "createdAt": "2020-01-13T13:56:00Z", "author": {"login": "andreidan"}, "path": "x-pack/plugin/ilm/src/main/java/org/elasticsearch/xpack/ilm/action/TransportPutLifecycleAction.java", "diffHunk": "@@ -100,13 +122,195 @@ public ClusterState execute(ClusterState currentState) throws Exception {\n                             logger.info(\"updating index lifecycle policy [{}]\", request.getPolicy().getName());\n                         }\n                         IndexLifecycleMetadata newMetadata = new IndexLifecycleMetadata(newPolicies, currentMetadata.getOperationMode());\n-                        newState.metaData(MetaData.builder(currentState.getMetaData())\n+                        stateBuilder.metaData(MetaData.builder(currentState.getMetaData())\n                                 .putCustom(IndexLifecycleMetadata.TYPE, newMetadata).build());\n-                        return newState.build();\n+                        ClusterState nonRefreshedState = stateBuilder.build();\n+                        if (oldPolicy == null) {\n+                            return nonRefreshedState;\n+                        } else {\n+                            try {\n+                                return updateIndicesForPolicy(nonRefreshedState, xContentRegistry,\n+                                    oldPolicy.getPolicy(), lifecyclePolicyMetadata);\n+                            } catch (Exception e) {\n+                                logger.warn(new ParameterizedMessage(\"unable to refresh indices phase JSON for updated policy [{}]\",\n+                                    oldPolicy.getName()), e);\n+                                // Revert to the non-refreshed state\n+                                return nonRefreshedState;\n+                            }\n+                        }\n                     }\n                 });\n     }\n \n+    /**\n+     * Ensure that we have the minimum amount of metadata necessary to check for cache phase\n+     * refresh. This includes:\n+     * - An execution state\n+     * - Existing phase definition JSON\n+     * - A current step key\n+     * - A current phase in the step key\n+     * - Not currently in the ERROR step\n+     */\n+    static boolean eligibleToCheckForRefresh(final IndexMetaData metaData) {\n+        LifecycleExecutionState executionState = LifecycleExecutionState.fromIndexMetadata(metaData);\n+        if (executionState == null || executionState.getPhaseDefinition() == null) {\n+            return false;\n+        }\n+\n+        Step.StepKey currentStepKey = LifecycleExecutionState.getCurrentStepKey(executionState);\n+        if (currentStepKey == null || currentStepKey.getPhase() == null) {\n+            return false;\n+        }\n+\n+        return ErrorStep.NAME.equals(currentStepKey.getName()) == false;\n+    }\n+\n+    /**\n+     * Parse the {@code phaseDef} phase definition to get the stepkeys for the given phase.\n+     * If there is an error parsing or if the phase definition is missing the required\n+     * information, returns null.\n+     */\n+    @Nullable\n+    static Set<Step.StepKey> readStepKeys(final NamedXContentRegistry xContentRegistry, final String phaseDef,\n+                                          final String currentPhase) {\n+        final PhaseExecutionInfo phaseExecutionInfo;\n+        try (XContentParser parser = JsonXContent.jsonXContent.createParser(xContentRegistry,\n+            DeprecationHandler.THROW_UNSUPPORTED_OPERATION, phaseDef)) {\n+            phaseExecutionInfo = PhaseExecutionInfo.parse(parser, currentPhase);\n+        } catch (Exception e) {\n+            logger.trace(new ParameterizedMessage(\"exception reading step keys checking for refreshability, phase definition: {}\",\n+                phaseDef), e);\n+            return null;\n+        }\n+\n+        if (phaseExecutionInfo == null || phaseExecutionInfo.getPhase() == null) {\n+            return null;\n+        }\n+\n+        return phaseExecutionInfo.getPhase().getActions().values().stream()\n+            .flatMap(a -> a.toSteps(null, phaseExecutionInfo.getPhase().getName(), null).stream())\n+            .map(Step::getKey)\n+            .collect(Collectors.toCollection(LinkedHashSet::new));\n+    }\n+\n+    /**\n+     * Returns 'true' if the index's cached phase JSON can be safely reread, 'false' otherwise.\n+     */\n+    static boolean indexCanBeUpdatedSafely(final NamedXContentRegistry xContentRegistry,\n+                                           final IndexMetaData metaData, final LifecyclePolicy newPolicy) {\n+        final String index = metaData.getIndex().getName();\n+        if (eligibleToCheckForRefresh(metaData) == false) {\n+            logger.debug(\"[{}] does not contain enough information to check for eligibility of refreshing phase\", index);\n+            return false;\n+        }\n+        final String policyId = newPolicy.getName();\n+\n+        final LifecycleExecutionState executionState = LifecycleExecutionState.fromIndexMetadata(metaData);\n+        final Step.StepKey currentStepKey = LifecycleExecutionState.getCurrentStepKey(executionState);\n+        final String currentPhase = currentStepKey.getPhase();\n+\n+        final Set<Step.StepKey> newStepKeys = newPolicy.toSteps(null).stream()\n+            .map(Step::getKey)\n+            .collect(Collectors.toCollection(LinkedHashSet::new));\n+\n+        if (newStepKeys.contains(currentStepKey) == false) {\n+            // The index is on a step that doesn't exist in the new policy, we\n+            // can't safely re-read the JSON\n+            logger.debug(\"[{}] updated policy [{}] does not contain the current step key [{}], so the policy phase will not be refreshed\",\n+                index, policyId, currentStepKey);\n+            return false;\n+        }\n+\n+        final String phaseDef = executionState.getPhaseDefinition();\n+        final Set<Step.StepKey> oldStepKeys = readStepKeys(xContentRegistry, phaseDef, currentPhase);\n+        if (oldStepKeys == null) {\n+            logger.debug(\"[{}] unable to parse phase definition for cached policy [{}], policy phase will not be refreshed\",\n+                index, policyId);\n+            return false;\n+        }\n+\n+        final Set<Step.StepKey> oldPhaseStepKeys = oldStepKeys.stream()\n+            .filter(sk -> currentPhase.equals(sk.getPhase()))\n+            .collect(Collectors.toCollection(LinkedHashSet::new));\n+\n+        final PhaseExecutionInfo pei = new PhaseExecutionInfo(policyId, newPolicy.getPhases().get(currentPhase), 1L, 1L);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f238049777a1b1083ae7c002ccbd8e96df1a6e1"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgxNzMxNQ==", "bodyText": "can we merge this log and the return statement into the else branch above?", "url": "https://github.com/elastic/elasticsearch/pull/50820#discussion_r365817315", "createdAt": "2020-01-13T13:59:00Z", "author": {"login": "andreidan"}, "path": "x-pack/plugin/ilm/src/main/java/org/elasticsearch/xpack/ilm/action/TransportPutLifecycleAction.java", "diffHunk": "@@ -100,13 +122,195 @@ public ClusterState execute(ClusterState currentState) throws Exception {\n                             logger.info(\"updating index lifecycle policy [{}]\", request.getPolicy().getName());\n                         }\n                         IndexLifecycleMetadata newMetadata = new IndexLifecycleMetadata(newPolicies, currentMetadata.getOperationMode());\n-                        newState.metaData(MetaData.builder(currentState.getMetaData())\n+                        stateBuilder.metaData(MetaData.builder(currentState.getMetaData())\n                                 .putCustom(IndexLifecycleMetadata.TYPE, newMetadata).build());\n-                        return newState.build();\n+                        ClusterState nonRefreshedState = stateBuilder.build();\n+                        if (oldPolicy == null) {\n+                            return nonRefreshedState;\n+                        } else {\n+                            try {\n+                                return updateIndicesForPolicy(nonRefreshedState, xContentRegistry,\n+                                    oldPolicy.getPolicy(), lifecyclePolicyMetadata);\n+                            } catch (Exception e) {\n+                                logger.warn(new ParameterizedMessage(\"unable to refresh indices phase JSON for updated policy [{}]\",\n+                                    oldPolicy.getName()), e);\n+                                // Revert to the non-refreshed state\n+                                return nonRefreshedState;\n+                            }\n+                        }\n                     }\n                 });\n     }\n \n+    /**\n+     * Ensure that we have the minimum amount of metadata necessary to check for cache phase\n+     * refresh. This includes:\n+     * - An execution state\n+     * - Existing phase definition JSON\n+     * - A current step key\n+     * - A current phase in the step key\n+     * - Not currently in the ERROR step\n+     */\n+    static boolean eligibleToCheckForRefresh(final IndexMetaData metaData) {\n+        LifecycleExecutionState executionState = LifecycleExecutionState.fromIndexMetadata(metaData);\n+        if (executionState == null || executionState.getPhaseDefinition() == null) {\n+            return false;\n+        }\n+\n+        Step.StepKey currentStepKey = LifecycleExecutionState.getCurrentStepKey(executionState);\n+        if (currentStepKey == null || currentStepKey.getPhase() == null) {\n+            return false;\n+        }\n+\n+        return ErrorStep.NAME.equals(currentStepKey.getName()) == false;\n+    }\n+\n+    /**\n+     * Parse the {@code phaseDef} phase definition to get the stepkeys for the given phase.\n+     * If there is an error parsing or if the phase definition is missing the required\n+     * information, returns null.\n+     */\n+    @Nullable\n+    static Set<Step.StepKey> readStepKeys(final NamedXContentRegistry xContentRegistry, final String phaseDef,\n+                                          final String currentPhase) {\n+        final PhaseExecutionInfo phaseExecutionInfo;\n+        try (XContentParser parser = JsonXContent.jsonXContent.createParser(xContentRegistry,\n+            DeprecationHandler.THROW_UNSUPPORTED_OPERATION, phaseDef)) {\n+            phaseExecutionInfo = PhaseExecutionInfo.parse(parser, currentPhase);\n+        } catch (Exception e) {\n+            logger.trace(new ParameterizedMessage(\"exception reading step keys checking for refreshability, phase definition: {}\",\n+                phaseDef), e);\n+            return null;\n+        }\n+\n+        if (phaseExecutionInfo == null || phaseExecutionInfo.getPhase() == null) {\n+            return null;\n+        }\n+\n+        return phaseExecutionInfo.getPhase().getActions().values().stream()\n+            .flatMap(a -> a.toSteps(null, phaseExecutionInfo.getPhase().getName(), null).stream())\n+            .map(Step::getKey)\n+            .collect(Collectors.toCollection(LinkedHashSet::new));\n+    }\n+\n+    /**\n+     * Returns 'true' if the index's cached phase JSON can be safely reread, 'false' otherwise.\n+     */\n+    static boolean indexCanBeUpdatedSafely(final NamedXContentRegistry xContentRegistry,\n+                                           final IndexMetaData metaData, final LifecyclePolicy newPolicy) {\n+        final String index = metaData.getIndex().getName();\n+        if (eligibleToCheckForRefresh(metaData) == false) {\n+            logger.debug(\"[{}] does not contain enough information to check for eligibility of refreshing phase\", index);\n+            return false;\n+        }\n+        final String policyId = newPolicy.getName();\n+\n+        final LifecycleExecutionState executionState = LifecycleExecutionState.fromIndexMetadata(metaData);\n+        final Step.StepKey currentStepKey = LifecycleExecutionState.getCurrentStepKey(executionState);\n+        final String currentPhase = currentStepKey.getPhase();\n+\n+        final Set<Step.StepKey> newStepKeys = newPolicy.toSteps(null).stream()\n+            .map(Step::getKey)\n+            .collect(Collectors.toCollection(LinkedHashSet::new));\n+\n+        if (newStepKeys.contains(currentStepKey) == false) {\n+            // The index is on a step that doesn't exist in the new policy, we\n+            // can't safely re-read the JSON\n+            logger.debug(\"[{}] updated policy [{}] does not contain the current step key [{}], so the policy phase will not be refreshed\",\n+                index, policyId, currentStepKey);\n+            return false;\n+        }\n+\n+        final String phaseDef = executionState.getPhaseDefinition();\n+        final Set<Step.StepKey> oldStepKeys = readStepKeys(xContentRegistry, phaseDef, currentPhase);\n+        if (oldStepKeys == null) {\n+            logger.debug(\"[{}] unable to parse phase definition for cached policy [{}], policy phase will not be refreshed\",\n+                index, policyId);\n+            return false;\n+        }\n+\n+        final Set<Step.StepKey> oldPhaseStepKeys = oldStepKeys.stream()\n+            .filter(sk -> currentPhase.equals(sk.getPhase()))\n+            .collect(Collectors.toCollection(LinkedHashSet::new));\n+\n+        final PhaseExecutionInfo pei = new PhaseExecutionInfo(policyId, newPolicy.getPhases().get(currentPhase), 1L, 1L);\n+        final String peiJson = Strings.toString(pei);\n+\n+        final Set<Step.StepKey> newPhaseStepKeys = readStepKeys(xContentRegistry, peiJson, currentPhase);\n+        if (newPhaseStepKeys == null) {\n+            logger.debug(new ParameterizedMessage(\"[{}] unable to parse phase definition for policy [{}] \" +\n+                \"to determine if it could be refreshed\", index, policyId));\n+            return false;\n+        }\n+\n+        if (newPhaseStepKeys.equals(oldPhaseStepKeys)) {\n+            // The new and old phase have the same stepkeys for this current phase, nothing of note has been changed\n+            logger.debug(\"[{}] updated policy [{}] contains the same phase step keys and can be refreshed\", index, policyId);\n+            return true;\n+        } else {\n+            logger.debug(\"[{}] updated policy [{}] has different phase step keys. old: {}, new: {}\",\n+                index, policyId, oldPhaseStepKeys, newPhaseStepKeys);\n+        }\n+\n+        logger.debug(\"[{}] updated policy [{}] will NOT refresh phase definition as it differs too greatly\", index, policyId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f238049777a1b1083ae7c002ccbd8e96df1a6e1"}, "originalPosition": 217}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgxOTg3NA==", "bodyText": "this comment is a bit confusing as it implies we will not be allowing the update as there is nothing to update. Can we please update it to reflect that we only allow updating of existing steps?", "url": "https://github.com/elastic/elasticsearch/pull/50820#discussion_r365819874", "createdAt": "2020-01-13T14:04:19Z", "author": {"login": "andreidan"}, "path": "x-pack/plugin/ilm/src/main/java/org/elasticsearch/xpack/ilm/action/TransportPutLifecycleAction.java", "diffHunk": "@@ -100,13 +122,195 @@ public ClusterState execute(ClusterState currentState) throws Exception {\n                             logger.info(\"updating index lifecycle policy [{}]\", request.getPolicy().getName());\n                         }\n                         IndexLifecycleMetadata newMetadata = new IndexLifecycleMetadata(newPolicies, currentMetadata.getOperationMode());\n-                        newState.metaData(MetaData.builder(currentState.getMetaData())\n+                        stateBuilder.metaData(MetaData.builder(currentState.getMetaData())\n                                 .putCustom(IndexLifecycleMetadata.TYPE, newMetadata).build());\n-                        return newState.build();\n+                        ClusterState nonRefreshedState = stateBuilder.build();\n+                        if (oldPolicy == null) {\n+                            return nonRefreshedState;\n+                        } else {\n+                            try {\n+                                return updateIndicesForPolicy(nonRefreshedState, xContentRegistry,\n+                                    oldPolicy.getPolicy(), lifecyclePolicyMetadata);\n+                            } catch (Exception e) {\n+                                logger.warn(new ParameterizedMessage(\"unable to refresh indices phase JSON for updated policy [{}]\",\n+                                    oldPolicy.getName()), e);\n+                                // Revert to the non-refreshed state\n+                                return nonRefreshedState;\n+                            }\n+                        }\n                     }\n                 });\n     }\n \n+    /**\n+     * Ensure that we have the minimum amount of metadata necessary to check for cache phase\n+     * refresh. This includes:\n+     * - An execution state\n+     * - Existing phase definition JSON\n+     * - A current step key\n+     * - A current phase in the step key\n+     * - Not currently in the ERROR step\n+     */\n+    static boolean eligibleToCheckForRefresh(final IndexMetaData metaData) {\n+        LifecycleExecutionState executionState = LifecycleExecutionState.fromIndexMetadata(metaData);\n+        if (executionState == null || executionState.getPhaseDefinition() == null) {\n+            return false;\n+        }\n+\n+        Step.StepKey currentStepKey = LifecycleExecutionState.getCurrentStepKey(executionState);\n+        if (currentStepKey == null || currentStepKey.getPhase() == null) {\n+            return false;\n+        }\n+\n+        return ErrorStep.NAME.equals(currentStepKey.getName()) == false;\n+    }\n+\n+    /**\n+     * Parse the {@code phaseDef} phase definition to get the stepkeys for the given phase.\n+     * If there is an error parsing or if the phase definition is missing the required\n+     * information, returns null.\n+     */\n+    @Nullable\n+    static Set<Step.StepKey> readStepKeys(final NamedXContentRegistry xContentRegistry, final String phaseDef,\n+                                          final String currentPhase) {\n+        final PhaseExecutionInfo phaseExecutionInfo;\n+        try (XContentParser parser = JsonXContent.jsonXContent.createParser(xContentRegistry,\n+            DeprecationHandler.THROW_UNSUPPORTED_OPERATION, phaseDef)) {\n+            phaseExecutionInfo = PhaseExecutionInfo.parse(parser, currentPhase);\n+        } catch (Exception e) {\n+            logger.trace(new ParameterizedMessage(\"exception reading step keys checking for refreshability, phase definition: {}\",\n+                phaseDef), e);\n+            return null;\n+        }\n+\n+        if (phaseExecutionInfo == null || phaseExecutionInfo.getPhase() == null) {\n+            return null;\n+        }\n+\n+        return phaseExecutionInfo.getPhase().getActions().values().stream()\n+            .flatMap(a -> a.toSteps(null, phaseExecutionInfo.getPhase().getName(), null).stream())\n+            .map(Step::getKey)\n+            .collect(Collectors.toCollection(LinkedHashSet::new));\n+    }\n+\n+    /**\n+     * Returns 'true' if the index's cached phase JSON can be safely reread, 'false' otherwise.\n+     */\n+    static boolean indexCanBeUpdatedSafely(final NamedXContentRegistry xContentRegistry,\n+                                           final IndexMetaData metaData, final LifecyclePolicy newPolicy) {\n+        final String index = metaData.getIndex().getName();\n+        if (eligibleToCheckForRefresh(metaData) == false) {\n+            logger.debug(\"[{}] does not contain enough information to check for eligibility of refreshing phase\", index);\n+            return false;\n+        }\n+        final String policyId = newPolicy.getName();\n+\n+        final LifecycleExecutionState executionState = LifecycleExecutionState.fromIndexMetadata(metaData);\n+        final Step.StepKey currentStepKey = LifecycleExecutionState.getCurrentStepKey(executionState);\n+        final String currentPhase = currentStepKey.getPhase();\n+\n+        final Set<Step.StepKey> newStepKeys = newPolicy.toSteps(null).stream()\n+            .map(Step::getKey)\n+            .collect(Collectors.toCollection(LinkedHashSet::new));\n+\n+        if (newStepKeys.contains(currentStepKey) == false) {\n+            // The index is on a step that doesn't exist in the new policy, we\n+            // can't safely re-read the JSON\n+            logger.debug(\"[{}] updated policy [{}] does not contain the current step key [{}], so the policy phase will not be refreshed\",\n+                index, policyId, currentStepKey);\n+            return false;\n+        }\n+\n+        final String phaseDef = executionState.getPhaseDefinition();\n+        final Set<Step.StepKey> oldStepKeys = readStepKeys(xContentRegistry, phaseDef, currentPhase);\n+        if (oldStepKeys == null) {\n+            logger.debug(\"[{}] unable to parse phase definition for cached policy [{}], policy phase will not be refreshed\",\n+                index, policyId);\n+            return false;\n+        }\n+\n+        final Set<Step.StepKey> oldPhaseStepKeys = oldStepKeys.stream()\n+            .filter(sk -> currentPhase.equals(sk.getPhase()))\n+            .collect(Collectors.toCollection(LinkedHashSet::new));\n+\n+        final PhaseExecutionInfo pei = new PhaseExecutionInfo(policyId, newPolicy.getPhases().get(currentPhase), 1L, 1L);\n+        final String peiJson = Strings.toString(pei);\n+\n+        final Set<Step.StepKey> newPhaseStepKeys = readStepKeys(xContentRegistry, peiJson, currentPhase);\n+        if (newPhaseStepKeys == null) {\n+            logger.debug(new ParameterizedMessage(\"[{}] unable to parse phase definition for policy [{}] \" +\n+                \"to determine if it could be refreshed\", index, policyId));\n+            return false;\n+        }\n+\n+        if (newPhaseStepKeys.equals(oldPhaseStepKeys)) {\n+            // The new and old phase have the same stepkeys for this current phase, nothing of note has been changed", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f238049777a1b1083ae7c002ccbd8e96df1a6e1"}, "originalPosition": 209}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgyMTUwMA==", "bodyText": "Why don't we allow the update of a policy if it's on the ERROR step? would it make sense to allow updating a policy even if on the error step? (I'm guessing this could be a good way to correct possible typos or such in the policy definition that are only caught at runtime - ie. wait-for-snapshot for a wrongly typed slm policy name)", "url": "https://github.com/elastic/elasticsearch/pull/50820#discussion_r365821500", "createdAt": "2020-01-13T14:07:28Z", "author": {"login": "andreidan"}, "path": "x-pack/plugin/ilm/src/main/java/org/elasticsearch/xpack/ilm/action/TransportPutLifecycleAction.java", "diffHunk": "@@ -100,13 +122,195 @@ public ClusterState execute(ClusterState currentState) throws Exception {\n                             logger.info(\"updating index lifecycle policy [{}]\", request.getPolicy().getName());\n                         }\n                         IndexLifecycleMetadata newMetadata = new IndexLifecycleMetadata(newPolicies, currentMetadata.getOperationMode());\n-                        newState.metaData(MetaData.builder(currentState.getMetaData())\n+                        stateBuilder.metaData(MetaData.builder(currentState.getMetaData())\n                                 .putCustom(IndexLifecycleMetadata.TYPE, newMetadata).build());\n-                        return newState.build();\n+                        ClusterState nonRefreshedState = stateBuilder.build();\n+                        if (oldPolicy == null) {\n+                            return nonRefreshedState;\n+                        } else {\n+                            try {\n+                                return updateIndicesForPolicy(nonRefreshedState, xContentRegistry,\n+                                    oldPolicy.getPolicy(), lifecyclePolicyMetadata);\n+                            } catch (Exception e) {\n+                                logger.warn(new ParameterizedMessage(\"unable to refresh indices phase JSON for updated policy [{}]\",\n+                                    oldPolicy.getName()), e);\n+                                // Revert to the non-refreshed state\n+                                return nonRefreshedState;\n+                            }\n+                        }\n                     }\n                 });\n     }\n \n+    /**\n+     * Ensure that we have the minimum amount of metadata necessary to check for cache phase\n+     * refresh. This includes:\n+     * - An execution state\n+     * - Existing phase definition JSON\n+     * - A current step key\n+     * - A current phase in the step key\n+     * - Not currently in the ERROR step", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f238049777a1b1083ae7c002ccbd8e96df1a6e1"}, "originalPosition": 114}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "74781851c70da12afb5c42d491f8d8a02ee41cf3", "author": {"user": {"login": "dakrone", "name": "Lee Hinman"}}, "url": "https://github.com/elastic/elasticsearch/commit/74781851c70da12afb5c42d491f8d8a02ee41cf3", "committedDate": "2020-01-13T17:25:33Z", "message": "Use a real client instead of null"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7dc759244d9d1c8e1cd7e0e6bcbec74d3658dbaf", "author": {"user": {"login": "dakrone", "name": "Lee Hinman"}}, "url": "https://github.com/elastic/elasticsearch/commit/7dc759244d9d1c8e1cd7e0e6bcbec74d3658dbaf", "committedDate": "2020-01-13T17:26:34Z", "message": "Rename indexCanBeUpdatedSafely -> isIndexPhaseDefinitionUpdatable"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "86f9455ba2951490d4876341e2e3aad1c950baa5", "author": {"user": {"login": "dakrone", "name": "Lee Hinman"}}, "url": "https://github.com/elastic/elasticsearch/commit/86f9455ba2951490d4876341e2e3aad1c950baa5", "committedDate": "2020-01-13T17:27:28Z", "message": "pei -> phaseExecutionInfo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "80822e870b44d94a573fd428bed3c261ef4f5219", "author": {"user": {"login": "dakrone", "name": "Lee Hinman"}}, "url": "https://github.com/elastic/elasticsearch/commit/80822e870b44d94a573fd428bed3c261ef4f5219", "committedDate": "2020-01-13T17:29:17Z", "message": "Collapse two logging statements into one"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8eba91bddf050342efe2dc886951a0b6c46d9a5e", "author": {"user": {"login": "dakrone", "name": "Lee Hinman"}}, "url": "https://github.com/elastic/elasticsearch/commit/8eba91bddf050342efe2dc886951a0b6c46d9a5e", "committedDate": "2020-01-13T17:29:27Z", "message": "Fixup the comment to be clearer"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyMDMyMzc1", "url": "https://github.com/elastic/elasticsearch/pull/50820#pullrequestreview-342032375", "createdAt": "2020-01-13T18:02:10Z", "commit": {"oid": "8eba91bddf050342efe2dc886951a0b6c46d9a5e"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "27342f2981046bcf896afb541df2d05748f75c1f", "author": {"user": {"login": "dakrone", "name": "Lee Hinman"}}, "url": "https://github.com/elastic/elasticsearch/commit/27342f2981046bcf896afb541df2d05748f75c1f", "committedDate": "2020-01-13T18:16:33Z", "message": "Add documentation blurb"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyMTIyMDA2", "url": "https://github.com/elastic/elasticsearch/pull/50820#pullrequestreview-342122006", "createdAt": "2020-01-13T20:36:40Z", "commit": {"oid": "27342f2981046bcf896afb541df2d05748f75c1f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3715, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}