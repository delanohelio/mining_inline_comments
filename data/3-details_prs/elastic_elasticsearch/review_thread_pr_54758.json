{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk4MzkwMjUx", "number": 54758, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QyMzo1MTo0N1rODuoH2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMzoxMjozOFrODv_HxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwMjE4NDU3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/search/SearchPhaseController.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QyMzo1MTo0OFrOGAs1Xw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNDoyMjozMVrOGCxpZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM4Nzc0Mw==", "bodyText": "I think I should add the task id to the output. That'd help a bit with debugging because setting the task manager to trace logging logs the query. Not that it is a good choice on a busy system, but it could be useful.\nI did look into returning this data in other ways but I couldn't come up with the \"right\" way. And it is super useful to be able to see the partial reduction memory usage. I mean, it'd probably be useful in production. But I think it'll be super useful for me when I'm just hacking on things.", "url": "https://github.com/elastic/elasticsearch/pull/54758#discussion_r403387743", "createdAt": "2020-04-03T23:51:48Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/action/search/SearchPhaseController.java", "diffHunk": "@@ -684,15 +697,21 @@ public void consumeResult(SearchPhaseResult result) {\n         private synchronized void consumeInternal(QuerySearchResult querySearchResult) {\n             if (querySearchResult.isNull() == false) {\n                 if (index == bufferSize) {\n+                    InternalAggregations reducedAggs = null;\n                     if (hasAggs) {\n                         List<InternalAggregations> aggs = new ArrayList<>(aggsBuffer.length);\n                         for (int i = 0; i < aggsBuffer.length; i++) {\n                             aggs.add(aggsBuffer[i].get());\n                             aggsBuffer[i] = null; // null the buffer so it can be GCed now.\n                         }\n-                        InternalAggregations reducedAggs = InternalAggregations.topLevelReduce(\n-                                aggs, aggReduceContextBuilder.forPartialReduction());\n-                        aggsBuffer[0] = () -> reducedAggs;\n+                        reducedAggs = InternalAggregations.topLevelReduce(aggs, aggReduceContextBuilder.forPartialReduction());\n+                        aggsBuffer[0] = DelayableWriteable.referencing(reducedAggs)\n+                                .asSerialized(InternalAggregations::new, namedWriteableRegistry);\n+                        long previousBufferSize = aggsCurrentBufferSize;\n+                        aggsMaxBufferSize = Math.max(aggsMaxBufferSize, aggsCurrentBufferSize);\n+                        aggsCurrentBufferSize = aggsBuffer[0].ramBytesUsed();\n+                        logger.trace(\"aggs partial reduction [{}->{}] max [{}]\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e2a0bf49e3faf98727c9cb6b92793d3a679321e"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ3MjY0NA==", "bodyText": "Now that we have SearchProgressListener I think it'd make more sense to forward this information through that interface and have a default implementation that logs the reduction. That is a little more work but makes it so I can test that we make these calls in a sane way which is nice.", "url": "https://github.com/elastic/elasticsearch/pull/54758#discussion_r403472644", "createdAt": "2020-04-04T13:53:39Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/action/search/SearchPhaseController.java", "diffHunk": "@@ -684,15 +697,21 @@ public void consumeResult(SearchPhaseResult result) {\n         private synchronized void consumeInternal(QuerySearchResult querySearchResult) {\n             if (querySearchResult.isNull() == false) {\n                 if (index == bufferSize) {\n+                    InternalAggregations reducedAggs = null;\n                     if (hasAggs) {\n                         List<InternalAggregations> aggs = new ArrayList<>(aggsBuffer.length);\n                         for (int i = 0; i < aggsBuffer.length; i++) {\n                             aggs.add(aggsBuffer[i].get());\n                             aggsBuffer[i] = null; // null the buffer so it can be GCed now.\n                         }\n-                        InternalAggregations reducedAggs = InternalAggregations.topLevelReduce(\n-                                aggs, aggReduceContextBuilder.forPartialReduction());\n-                        aggsBuffer[0] = () -> reducedAggs;\n+                        reducedAggs = InternalAggregations.topLevelReduce(aggs, aggReduceContextBuilder.forPartialReduction());\n+                        aggsBuffer[0] = DelayableWriteable.referencing(reducedAggs)\n+                                .asSerialized(InternalAggregations::new, namedWriteableRegistry);\n+                        long previousBufferSize = aggsCurrentBufferSize;\n+                        aggsMaxBufferSize = Math.max(aggsMaxBufferSize, aggsCurrentBufferSize);\n+                        aggsCurrentBufferSize = aggsBuffer[0].ramBytesUsed();\n+                        logger.trace(\"aggs partial reduction [{}->{}] max [{}]\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM4Nzc0Mw=="}, "originalCommit": {"oid": "4e2a0bf49e3faf98727c9cb6b92793d3a679321e"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ3ODU4NA==", "bodyText": "Another option is to move this information into SearchTask so you can see it in the tasks API. That seems useful.", "url": "https://github.com/elastic/elasticsearch/pull/54758#discussion_r403478584", "createdAt": "2020-04-04T14:50:28Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/action/search/SearchPhaseController.java", "diffHunk": "@@ -684,15 +697,21 @@ public void consumeResult(SearchPhaseResult result) {\n         private synchronized void consumeInternal(QuerySearchResult querySearchResult) {\n             if (querySearchResult.isNull() == false) {\n                 if (index == bufferSize) {\n+                    InternalAggregations reducedAggs = null;\n                     if (hasAggs) {\n                         List<InternalAggregations> aggs = new ArrayList<>(aggsBuffer.length);\n                         for (int i = 0; i < aggsBuffer.length; i++) {\n                             aggs.add(aggsBuffer[i].get());\n                             aggsBuffer[i] = null; // null the buffer so it can be GCed now.\n                         }\n-                        InternalAggregations reducedAggs = InternalAggregations.topLevelReduce(\n-                                aggs, aggReduceContextBuilder.forPartialReduction());\n-                        aggsBuffer[0] = () -> reducedAggs;\n+                        reducedAggs = InternalAggregations.topLevelReduce(aggs, aggReduceContextBuilder.forPartialReduction());\n+                        aggsBuffer[0] = DelayableWriteable.referencing(reducedAggs)\n+                                .asSerialized(InternalAggregations::new, namedWriteableRegistry);\n+                        long previousBufferSize = aggsCurrentBufferSize;\n+                        aggsMaxBufferSize = Math.max(aggsMaxBufferSize, aggsCurrentBufferSize);\n+                        aggsCurrentBufferSize = aggsBuffer[0].ramBytesUsed();\n+                        logger.trace(\"aggs partial reduction [{}->{}] max [{}]\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM4Nzc0Mw=="}, "originalCommit": {"oid": "4e2a0bf49e3faf98727c9cb6b92793d3a679321e"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzUzNzE5Mw==", "bodyText": "On the other other hand maybe this is a good start and adding it to the SearchTask would be a good change for a follow up.", "url": "https://github.com/elastic/elasticsearch/pull/54758#discussion_r403537193", "createdAt": "2020-04-04T22:08:55Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/action/search/SearchPhaseController.java", "diffHunk": "@@ -684,15 +697,21 @@ public void consumeResult(SearchPhaseResult result) {\n         private synchronized void consumeInternal(QuerySearchResult querySearchResult) {\n             if (querySearchResult.isNull() == false) {\n                 if (index == bufferSize) {\n+                    InternalAggregations reducedAggs = null;\n                     if (hasAggs) {\n                         List<InternalAggregations> aggs = new ArrayList<>(aggsBuffer.length);\n                         for (int i = 0; i < aggsBuffer.length; i++) {\n                             aggs.add(aggsBuffer[i].get());\n                             aggsBuffer[i] = null; // null the buffer so it can be GCed now.\n                         }\n-                        InternalAggregations reducedAggs = InternalAggregations.topLevelReduce(\n-                                aggs, aggReduceContextBuilder.forPartialReduction());\n-                        aggsBuffer[0] = () -> reducedAggs;\n+                        reducedAggs = InternalAggregations.topLevelReduce(aggs, aggReduceContextBuilder.forPartialReduction());\n+                        aggsBuffer[0] = DelayableWriteable.referencing(reducedAggs)\n+                                .asSerialized(InternalAggregations::new, namedWriteableRegistry);\n+                        long previousBufferSize = aggsCurrentBufferSize;\n+                        aggsMaxBufferSize = Math.max(aggsMaxBufferSize, aggsCurrentBufferSize);\n+                        aggsCurrentBufferSize = aggsBuffer[0].ramBytesUsed();\n+                        logger.trace(\"aggs partial reduction [{}->{}] max [{}]\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM4Nzc0Mw=="}, "originalCommit": {"oid": "4e2a0bf49e3faf98727c9cb6b92793d3a679321e"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU2Mzc0OA==", "bodyText": "+1 to add in the SearchTask as a follow up", "url": "https://github.com/elastic/elasticsearch/pull/54758#discussion_r405563748", "createdAt": "2020-04-08T14:22:31Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/action/search/SearchPhaseController.java", "diffHunk": "@@ -684,15 +697,21 @@ public void consumeResult(SearchPhaseResult result) {\n         private synchronized void consumeInternal(QuerySearchResult querySearchResult) {\n             if (querySearchResult.isNull() == false) {\n                 if (index == bufferSize) {\n+                    InternalAggregations reducedAggs = null;\n                     if (hasAggs) {\n                         List<InternalAggregations> aggs = new ArrayList<>(aggsBuffer.length);\n                         for (int i = 0; i < aggsBuffer.length; i++) {\n                             aggs.add(aggsBuffer[i].get());\n                             aggsBuffer[i] = null; // null the buffer so it can be GCed now.\n                         }\n-                        InternalAggregations reducedAggs = InternalAggregations.topLevelReduce(\n-                                aggs, aggReduceContextBuilder.forPartialReduction());\n-                        aggsBuffer[0] = () -> reducedAggs;\n+                        reducedAggs = InternalAggregations.topLevelReduce(aggs, aggReduceContextBuilder.forPartialReduction());\n+                        aggsBuffer[0] = DelayableWriteable.referencing(reducedAggs)\n+                                .asSerialized(InternalAggregations::new, namedWriteableRegistry);\n+                        long previousBufferSize = aggsCurrentBufferSize;\n+                        aggsMaxBufferSize = Math.max(aggsMaxBufferSize, aggsCurrentBufferSize);\n+                        aggsCurrentBufferSize = aggsBuffer[0].ramBytesUsed();\n+                        logger.trace(\"aggs partial reduction [{}->{}] max [{}]\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM4Nzc0Mw=="}, "originalCommit": {"oid": "4e2a0bf49e3faf98727c9cb6b92793d3a679321e"}, "originalPosition": 148}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNjQzODQ0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/search/SearchPhaseController.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMzoxMjozOFrOGCukfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMzozNjowMVrOGCvlBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUxMzM0MQ==", "bodyText": "I talked to @jimczi and @javanna and this line is a release blocker. We're pretty ok merging it, but not releasing it. Because async_search keeps a hard reference to the aggs passed to it. Actually async search has all kinds of trouble with aggs because it doesn't perform the final reduction until sync search would. But it does return aggs without the final reduction applied if you get the \"progress\" of the search. These aggs are going to be \"funny\". They'll be missing pipeline aggs, for instant. And scripted_metric will be borked in some way. As will a lot of other things. But you'll mostly get something.", "url": "https://github.com/elastic/elasticsearch/pull/54758#discussion_r405513341", "createdAt": "2020-04-08T13:12:38Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/action/search/SearchPhaseController.java", "diffHunk": "@@ -705,12 +724,13 @@ private synchronized void consumeInternal(QuerySearchResult querySearchResult) {\n                     index = 1;\n                     if (hasAggs || hasTopDocs) {\n                         progressListener.notifyPartialReduce(SearchProgressListener.buildSearchShards(processedShards),\n-                            topDocsStats.getTotalHits(), hasAggs ? aggsBuffer[0].get() : null, numReducePhases);\n+                            topDocsStats.getTotalHits(), reducedAggs, numReducePhases);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "155bb49f20464372b94b30c75154789ccf44adae"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUyOTg2MA==", "bodyText": "Actually async search has all kinds of trouble with aggs because it doesn't perform the final reduction until sync search would. But it does return aggs without the final reduction applied if you get the \"progress\" of the search. These aggs are going to be \"funny\". They'll be missing pipeline aggs, for instant. And scripted_metric will be borked in some way. As will a lot of other things. But you'll mostly get something.\n\nScratch that - it does perform the final reduction when you fetch the result. You could still get weird results because things are missing, but they'll be a lot less weird than I was thinking.", "url": "https://github.com/elastic/elasticsearch/pull/54758#discussion_r405529860", "createdAt": "2020-04-08T13:36:01Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/action/search/SearchPhaseController.java", "diffHunk": "@@ -705,12 +724,13 @@ private synchronized void consumeInternal(QuerySearchResult querySearchResult) {\n                     index = 1;\n                     if (hasAggs || hasTopDocs) {\n                         progressListener.notifyPartialReduce(SearchProgressListener.buildSearchShards(processedShards),\n-                            topDocsStats.getTotalHits(), hasAggs ? aggsBuffer[0].get() : null, numReducePhases);\n+                            topDocsStats.getTotalHits(), reducedAggs, numReducePhases);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUxMzM0MQ=="}, "originalCommit": {"oid": "155bb49f20464372b94b30c75154789ccf44adae"}, "originalPosition": 158}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1339, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}