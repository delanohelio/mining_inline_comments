{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQwNDUzNDY4", "number": 58582, "title": "Add data stream timestamp validation via metadata field mapper", "bodyText": "This commit adds a new metadata field mapper that validates,\nthat a document has exactly a single timestamp value in the data stream timestamp field.\nThe MetadataCreateIndexService inserts a data stream timestamp field mapper whenever\na new backing index of a data stream is created.\nThis is a different variant of #58119, which also tries to add timestamp field validation when\ningesting documents. This implementation is cleaner than in #58119, because the validation\nis encapsulated in the DataStreamTimestampFieldMapper class and the data stream\ntimestamp field name is provided to it as mapping configuration. Whereas in #58119\nhard coded validation logic was added in ParseContext#postParse(...) and DateFieldMapper,\nalso a data stream timestamp fieldname field/variable was added in many other classes in\norder to get the right information in the right place.\nRelates to #53100", "createdAt": "2020-06-26T08:29:12Z", "url": "https://github.com/elastic/elasticsearch/pull/58582", "merged": true, "mergeCommit": {"oid": "001b3fb440662ffd06034c6c5793aad6ab45eeed"}, "closed": true, "closedAt": "2020-07-02T08:58:19Z", "author": {"login": "martijnvg"}, "timelineItems": {"totalCount": 25, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcu-6OzgH2gAyNDQwNDUzNDY4OjA2ODhkZDVhZjU0NzU2MTQxYzY0ZWVjYTUxODZjNTBiZGIwYzBhNzk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcwp5H-gH2gAyNDQwNDUzNDY4OmQwZDlmMzMyN2Y1ZjI1NzMzM2E0YmQ0NDVkMDUyMjBmMmNhZmVmM2I=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "0688dd5af54756141c64eeca5186c50bdb0c0a79", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/0688dd5af54756141c64eeca5186c50bdb0c0a79", "committedDate": "2020-06-26T08:24:19Z", "message": "Add data stream timestamp validation via metadata field mapper\n\nThis commit adds a new metadata field mapper that validates,\nthat a document has exactly a single timestamp value in the data stream timestamp field.\n\nThe MetadataCreateIndexService inserts a data stream timestamp field mapper whenever\na new backing index of a data stream is created.\n\nRelates to #53100"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "738f523af2fa2012046647342d5a6beda65d890b", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/738f523af2fa2012046647342d5a6beda65d890b", "committedDate": "2020-06-26T09:02:05Z", "message": "do not serialize at all when disabled"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d97b0d4c23cdeca9647bbc3b183493e5d7ffb9ac", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/d97b0d4c23cdeca9647bbc3b183493e5d7ffb9ac", "committedDate": "2020-06-26T10:04:50Z", "message": "fixed tests and renamed _data_stream_timestamp to _timestamp, some tests were failing\nbecause these tests assumed any field longer then 20 chars is too long."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4MTg4ODEy", "url": "https://github.com/elastic/elasticsearch/pull/58582#pullrequestreview-438188812", "createdAt": "2020-06-26T10:31:31Z", "commit": {"oid": "d97b0d4c23cdeca9647bbc3b183493e5d7ffb9ac"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMDozMTozMlrOGpcBcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMDo0MTo0MFrOGpcRzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEwMzkyMA==", "bodyText": "shouldn't we always return when the fieldName is null ?", "url": "https://github.com/elastic/elasticsearch/pull/58582#discussion_r446103920", "createdAt": "2020-06-26T10:31:32Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/DataStreamTimestampFieldMapper.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.document.FieldType;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.search.Query;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.query.QueryShardContext;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+public class DataStreamTimestampFieldMapper extends MetadataFieldMapper {\n+\n+    public static final String NAME = \"_timestamp\";\n+\n+    public static class Defaults  {\n+\n+        public static final FieldType DATA_STREAM_TIMESTAMP_FIELD_TYPE = new FieldType();\n+\n+        static {\n+            DATA_STREAM_TIMESTAMP_FIELD_TYPE.setIndexOptions(IndexOptions.NONE);\n+            DATA_STREAM_TIMESTAMP_FIELD_TYPE.freeze();\n+        }\n+    }\n+\n+    // For now the field shouldn't be useable in searches.\n+    // In the future it should act as an alias to the actual data stream timestamp field.\n+    public static final class DataStreamTimestampFieldFieldType extends MappedFieldType {\n+\n+        public DataStreamTimestampFieldFieldType() {\n+            super(NAME, false, false, TextSearchInfo.NONE, Map.of());\n+        }\n+\n+        @Override\n+        public MappedFieldType clone() {\n+            return new DataStreamTimestampFieldFieldType();\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return NAME;\n+        }\n+\n+        @Override\n+        public Query termQuery(Object value, QueryShardContext context) {\n+            throw new IllegalArgumentException(\"Field [\" + name() + \"] of type [\" + typeName() + \"] does not support term queries\");\n+        }\n+\n+        @Override\n+        public Query existsQuery(QueryShardContext context) {\n+            throw new IllegalArgumentException(\"Field [\" + name() + \"] of type [\" + typeName() + \"] does not support exists queries\");\n+        }\n+\n+    }\n+\n+    public static class Builder extends MetadataFieldMapper.Builder<Builder> {\n+\n+        private String fieldName;\n+\n+        public Builder() {\n+            super(NAME, Defaults.DATA_STREAM_TIMESTAMP_FIELD_TYPE);\n+        }\n+\n+        public void setFieldName(String fieldName) {\n+            this.fieldName = fieldName;\n+        }\n+\n+        @Override\n+        public MetadataFieldMapper build(BuilderContext context) {\n+            return new DataStreamTimestampFieldMapper(\n+                fieldType,\n+                new DataStreamTimestampFieldFieldType(),\n+                fieldName\n+            );\n+        }\n+    }\n+\n+    public static class TypeParser implements MetadataFieldMapper.TypeParser {\n+\n+        @Override\n+        public MetadataFieldMapper.Builder<?> parse(String name,\n+                                                    Map<String, Object> node,\n+                                                    ParserContext parserContext) throws MapperParsingException {\n+            Builder builder = new Builder();\n+            for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(); iterator.hasNext();) {\n+                Map.Entry<String, Object> entry = iterator.next();\n+                String fieldName = entry.getKey();\n+                Object fieldNode = entry.getValue();\n+                if (fieldName.equals(\"field_name\")) {\n+                    builder.setFieldName((String) fieldNode);\n+                    iterator.remove();\n+                }\n+            }\n+            return builder;\n+        }\n+\n+        @Override\n+        public MetadataFieldMapper getDefault(ParserContext parserContext) {\n+            return new DataStreamTimestampFieldMapper(Defaults.DATA_STREAM_TIMESTAMP_FIELD_TYPE,\n+                new DataStreamTimestampFieldFieldType(), null);\n+        }\n+    }\n+\n+    private final String fieldName;\n+\n+    private DataStreamTimestampFieldMapper(FieldType fieldType, MappedFieldType mappedFieldType, String fieldName) {\n+        super(fieldType, mappedFieldType);\n+        this.fieldName = fieldName;\n+    }\n+\n+    @Override\n+    public void preParse(ParseContext context) throws IOException {\n+\n+    }\n+\n+    @Override\n+    protected void parseCreateField(ParseContext context) throws IOException {\n+\n+    }\n+\n+    @Override\n+    public void postParse(ParseContext context) throws IOException {\n+        if (fieldName == null) {\n+            // not configured, so skip the validation\n+            return;\n+        }\n+\n+        IndexableField[] fields = context.rootDoc().getFields(fieldName);\n+        if (fields.length == 0) {\n+            throw new IllegalArgumentException(\"data stream timestamp field [\" + fieldName + \"] is missing\");\n+        }\n+\n+        long numberOfValues =\n+            Arrays.stream(fields).filter(indexableField -> indexableField.fieldType().pointDimensionCount() > 0).count();\n+        if (numberOfValues > 1) {\n+            throw new IllegalArgumentException(\"data stream timestamp field [\" + fieldName + \"] encountered multiple values\");\n+        }\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        boolean includeDefaults = params.paramAsBoolean(\"include_defaults\", false);\n+        if (includeDefaults == false && fieldName == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d97b0d4c23cdeca9647bbc3b183493e5d7ffb9ac"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEwNjQ2MQ==", "bodyText": "I wonder what this would look like though. It's very similar to the alias field so I wonder what @jtibshirani thinks of how this should work ?", "url": "https://github.com/elastic/elasticsearch/pull/58582#discussion_r446106461", "createdAt": "2020-06-26T10:37:39Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/DataStreamTimestampFieldMapper.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.document.FieldType;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.search.Query;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.query.QueryShardContext;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+public class DataStreamTimestampFieldMapper extends MetadataFieldMapper {\n+\n+    public static final String NAME = \"_timestamp\";\n+\n+    public static class Defaults  {\n+\n+        public static final FieldType DATA_STREAM_TIMESTAMP_FIELD_TYPE = new FieldType();\n+\n+        static {\n+            DATA_STREAM_TIMESTAMP_FIELD_TYPE.setIndexOptions(IndexOptions.NONE);\n+            DATA_STREAM_TIMESTAMP_FIELD_TYPE.freeze();\n+        }\n+    }\n+\n+    // For now the field shouldn't be useable in searches.\n+    // In the future it should act as an alias to the actual data stream timestamp field.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d97b0d4c23cdeca9647bbc3b183493e5d7ffb9ac"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEwNjczNw==", "bodyText": "Why do we need to reference the data stream naming ? It's a generic timestamp metadata field, right ?", "url": "https://github.com/elastic/elasticsearch/pull/58582#discussion_r446106737", "createdAt": "2020-06-26T10:38:23Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/DataStreamTimestampFieldMapper.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.document.FieldType;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.search.Query;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.query.QueryShardContext;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+public class DataStreamTimestampFieldMapper extends MetadataFieldMapper {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d97b0d4c23cdeca9647bbc3b183493e5d7ffb9ac"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEwODExMA==", "bodyText": "It would be nice to add validation in the MapperService that the target field is of  type date and that it is indexed and has doc values. I  know that you validate this in the data stream code but it would be cleaner/safer to do it directly in the MapperService since the metadata field could be used outside of data streams ?", "url": "https://github.com/elastic/elasticsearch/pull/58582#discussion_r446108110", "createdAt": "2020-06-26T10:41:40Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/DataStreamTimestampFieldMapper.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.document.FieldType;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.search.Query;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.query.QueryShardContext;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+public class DataStreamTimestampFieldMapper extends MetadataFieldMapper {\n+\n+    public static final String NAME = \"_timestamp\";\n+\n+    public static class Defaults  {\n+\n+        public static final FieldType DATA_STREAM_TIMESTAMP_FIELD_TYPE = new FieldType();\n+\n+        static {\n+            DATA_STREAM_TIMESTAMP_FIELD_TYPE.setIndexOptions(IndexOptions.NONE);\n+            DATA_STREAM_TIMESTAMP_FIELD_TYPE.freeze();\n+        }\n+    }\n+\n+    // For now the field shouldn't be useable in searches.\n+    // In the future it should act as an alias to the actual data stream timestamp field.\n+    public static final class DataStreamTimestampFieldFieldType extends MappedFieldType {\n+\n+        public DataStreamTimestampFieldFieldType() {\n+            super(NAME, false, false, TextSearchInfo.NONE, Map.of());\n+        }\n+\n+        @Override\n+        public MappedFieldType clone() {\n+            return new DataStreamTimestampFieldFieldType();\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return NAME;\n+        }\n+\n+        @Override\n+        public Query termQuery(Object value, QueryShardContext context) {\n+            throw new IllegalArgumentException(\"Field [\" + name() + \"] of type [\" + typeName() + \"] does not support term queries\");\n+        }\n+\n+        @Override\n+        public Query existsQuery(QueryShardContext context) {\n+            throw new IllegalArgumentException(\"Field [\" + name() + \"] of type [\" + typeName() + \"] does not support exists queries\");\n+        }\n+\n+    }\n+\n+    public static class Builder extends MetadataFieldMapper.Builder<Builder> {\n+\n+        private String fieldName;\n+\n+        public Builder() {\n+            super(NAME, Defaults.DATA_STREAM_TIMESTAMP_FIELD_TYPE);\n+        }\n+\n+        public void setFieldName(String fieldName) {\n+            this.fieldName = fieldName;\n+        }\n+\n+        @Override\n+        public MetadataFieldMapper build(BuilderContext context) {\n+            return new DataStreamTimestampFieldMapper(\n+                fieldType,\n+                new DataStreamTimestampFieldFieldType(),\n+                fieldName\n+            );\n+        }\n+    }\n+\n+    public static class TypeParser implements MetadataFieldMapper.TypeParser {\n+\n+        @Override\n+        public MetadataFieldMapper.Builder<?> parse(String name,\n+                                                    Map<String, Object> node,\n+                                                    ParserContext parserContext) throws MapperParsingException {\n+            Builder builder = new Builder();\n+            for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(); iterator.hasNext();) {\n+                Map.Entry<String, Object> entry = iterator.next();\n+                String fieldName = entry.getKey();\n+                Object fieldNode = entry.getValue();\n+                if (fieldName.equals(\"field_name\")) {\n+                    builder.setFieldName((String) fieldNode);\n+                    iterator.remove();\n+                }\n+            }\n+            return builder;\n+        }\n+\n+        @Override\n+        public MetadataFieldMapper getDefault(ParserContext parserContext) {\n+            return new DataStreamTimestampFieldMapper(Defaults.DATA_STREAM_TIMESTAMP_FIELD_TYPE,\n+                new DataStreamTimestampFieldFieldType(), null);\n+        }\n+    }\n+\n+    private final String fieldName;\n+\n+    private DataStreamTimestampFieldMapper(FieldType fieldType, MappedFieldType mappedFieldType, String fieldName) {\n+        super(fieldType, mappedFieldType);\n+        this.fieldName = fieldName;\n+    }\n+\n+    @Override\n+    public void preParse(ParseContext context) throws IOException {\n+\n+    }\n+\n+    @Override\n+    protected void parseCreateField(ParseContext context) throws IOException {\n+\n+    }\n+\n+    @Override\n+    public void postParse(ParseContext context) throws IOException {\n+        if (fieldName == null) {\n+            // not configured, so skip the validation\n+            return;\n+        }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d97b0d4c23cdeca9647bbc3b183493e5d7ffb9ac"}, "originalPosition": 149}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4NTY5MjU4", "url": "https://github.com/elastic/elasticsearch/pull/58582#pullrequestreview-438569258", "createdAt": "2020-06-26T20:16:05Z", "commit": {"oid": "d97b0d4c23cdeca9647bbc3b183493e5d7ffb9ac"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQyMDoxNjowNVrOGpte7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQyMDo0NDozN1rOGpuLgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjM4OTk5OA==", "bodyText": "Maybe we could instead assert that the field type has at least one docvalues field? This would be more robust if we decide to stop indexing points (#48665).", "url": "https://github.com/elastic/elasticsearch/pull/58582#discussion_r446389998", "createdAt": "2020-06-26T20:16:05Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/DataStreamTimestampFieldMapper.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.document.FieldType;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.search.Query;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.query.QueryShardContext;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+public class DataStreamTimestampFieldMapper extends MetadataFieldMapper {\n+\n+    public static final String NAME = \"_timestamp\";\n+\n+    public static class Defaults  {\n+\n+        public static final FieldType DATA_STREAM_TIMESTAMP_FIELD_TYPE = new FieldType();\n+\n+        static {\n+            DATA_STREAM_TIMESTAMP_FIELD_TYPE.setIndexOptions(IndexOptions.NONE);\n+            DATA_STREAM_TIMESTAMP_FIELD_TYPE.freeze();\n+        }\n+    }\n+\n+    // For now the field shouldn't be useable in searches.\n+    // In the future it should act as an alias to the actual data stream timestamp field.\n+    public static final class DataStreamTimestampFieldFieldType extends MappedFieldType {\n+\n+        public DataStreamTimestampFieldFieldType() {\n+            super(NAME, false, false, TextSearchInfo.NONE, Map.of());\n+        }\n+\n+        @Override\n+        public MappedFieldType clone() {\n+            return new DataStreamTimestampFieldFieldType();\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return NAME;\n+        }\n+\n+        @Override\n+        public Query termQuery(Object value, QueryShardContext context) {\n+            throw new IllegalArgumentException(\"Field [\" + name() + \"] of type [\" + typeName() + \"] does not support term queries\");\n+        }\n+\n+        @Override\n+        public Query existsQuery(QueryShardContext context) {\n+            throw new IllegalArgumentException(\"Field [\" + name() + \"] of type [\" + typeName() + \"] does not support exists queries\");\n+        }\n+\n+    }\n+\n+    public static class Builder extends MetadataFieldMapper.Builder<Builder> {\n+\n+        private String fieldName;\n+\n+        public Builder() {\n+            super(NAME, Defaults.DATA_STREAM_TIMESTAMP_FIELD_TYPE);\n+        }\n+\n+        public void setFieldName(String fieldName) {\n+            this.fieldName = fieldName;\n+        }\n+\n+        @Override\n+        public MetadataFieldMapper build(BuilderContext context) {\n+            return new DataStreamTimestampFieldMapper(\n+                fieldType,\n+                new DataStreamTimestampFieldFieldType(),\n+                fieldName\n+            );\n+        }\n+    }\n+\n+    public static class TypeParser implements MetadataFieldMapper.TypeParser {\n+\n+        @Override\n+        public MetadataFieldMapper.Builder<?> parse(String name,\n+                                                    Map<String, Object> node,\n+                                                    ParserContext parserContext) throws MapperParsingException {\n+            Builder builder = new Builder();\n+            for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(); iterator.hasNext();) {\n+                Map.Entry<String, Object> entry = iterator.next();\n+                String fieldName = entry.getKey();\n+                Object fieldNode = entry.getValue();\n+                if (fieldName.equals(\"field_name\")) {\n+                    builder.setFieldName((String) fieldNode);\n+                    iterator.remove();\n+                }\n+            }\n+            return builder;\n+        }\n+\n+        @Override\n+        public MetadataFieldMapper getDefault(ParserContext parserContext) {\n+            return new DataStreamTimestampFieldMapper(Defaults.DATA_STREAM_TIMESTAMP_FIELD_TYPE,\n+                new DataStreamTimestampFieldFieldType(), null);\n+        }\n+    }\n+\n+    private final String fieldName;\n+\n+    private DataStreamTimestampFieldMapper(FieldType fieldType, MappedFieldType mappedFieldType, String fieldName) {\n+        super(fieldType, mappedFieldType);\n+        this.fieldName = fieldName;\n+    }\n+\n+    @Override\n+    public void preParse(ParseContext context) throws IOException {\n+\n+    }\n+\n+    @Override\n+    protected void parseCreateField(ParseContext context) throws IOException {\n+\n+    }\n+\n+    @Override\n+    public void postParse(ParseContext context) throws IOException {\n+        if (fieldName == null) {\n+            // not configured, so skip the validation\n+            return;\n+        }\n+\n+        IndexableField[] fields = context.rootDoc().getFields(fieldName);\n+        if (fields.length == 0) {\n+            throw new IllegalArgumentException(\"data stream timestamp field [\" + fieldName + \"] is missing\");\n+        }\n+\n+        long numberOfValues =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d97b0d4c23cdeca9647bbc3b183493e5d7ffb9ac"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjM5MTIxNQ==", "bodyText": "I like the idea of moving the validation down into the mapping code even if the field mapper isn't used outside of data streams. It's really nice to have all mapping validation embedded in the mappers/ mapping logic instead of some living outside.", "url": "https://github.com/elastic/elasticsearch/pull/58582#discussion_r446391215", "createdAt": "2020-06-26T20:19:09Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/DataStreamTimestampFieldMapper.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.document.FieldType;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.search.Query;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.query.QueryShardContext;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+public class DataStreamTimestampFieldMapper extends MetadataFieldMapper {\n+\n+    public static final String NAME = \"_timestamp\";\n+\n+    public static class Defaults  {\n+\n+        public static final FieldType DATA_STREAM_TIMESTAMP_FIELD_TYPE = new FieldType();\n+\n+        static {\n+            DATA_STREAM_TIMESTAMP_FIELD_TYPE.setIndexOptions(IndexOptions.NONE);\n+            DATA_STREAM_TIMESTAMP_FIELD_TYPE.freeze();\n+        }\n+    }\n+\n+    // For now the field shouldn't be useable in searches.\n+    // In the future it should act as an alias to the actual data stream timestamp field.\n+    public static final class DataStreamTimestampFieldFieldType extends MappedFieldType {\n+\n+        public DataStreamTimestampFieldFieldType() {\n+            super(NAME, false, false, TextSearchInfo.NONE, Map.of());\n+        }\n+\n+        @Override\n+        public MappedFieldType clone() {\n+            return new DataStreamTimestampFieldFieldType();\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return NAME;\n+        }\n+\n+        @Override\n+        public Query termQuery(Object value, QueryShardContext context) {\n+            throw new IllegalArgumentException(\"Field [\" + name() + \"] of type [\" + typeName() + \"] does not support term queries\");\n+        }\n+\n+        @Override\n+        public Query existsQuery(QueryShardContext context) {\n+            throw new IllegalArgumentException(\"Field [\" + name() + \"] of type [\" + typeName() + \"] does not support exists queries\");\n+        }\n+\n+    }\n+\n+    public static class Builder extends MetadataFieldMapper.Builder<Builder> {\n+\n+        private String fieldName;\n+\n+        public Builder() {\n+            super(NAME, Defaults.DATA_STREAM_TIMESTAMP_FIELD_TYPE);\n+        }\n+\n+        public void setFieldName(String fieldName) {\n+            this.fieldName = fieldName;\n+        }\n+\n+        @Override\n+        public MetadataFieldMapper build(BuilderContext context) {\n+            return new DataStreamTimestampFieldMapper(\n+                fieldType,\n+                new DataStreamTimestampFieldFieldType(),\n+                fieldName\n+            );\n+        }\n+    }\n+\n+    public static class TypeParser implements MetadataFieldMapper.TypeParser {\n+\n+        @Override\n+        public MetadataFieldMapper.Builder<?> parse(String name,\n+                                                    Map<String, Object> node,\n+                                                    ParserContext parserContext) throws MapperParsingException {\n+            Builder builder = new Builder();\n+            for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(); iterator.hasNext();) {\n+                Map.Entry<String, Object> entry = iterator.next();\n+                String fieldName = entry.getKey();\n+                Object fieldNode = entry.getValue();\n+                if (fieldName.equals(\"field_name\")) {\n+                    builder.setFieldName((String) fieldNode);\n+                    iterator.remove();\n+                }\n+            }\n+            return builder;\n+        }\n+\n+        @Override\n+        public MetadataFieldMapper getDefault(ParserContext parserContext) {\n+            return new DataStreamTimestampFieldMapper(Defaults.DATA_STREAM_TIMESTAMP_FIELD_TYPE,\n+                new DataStreamTimestampFieldFieldType(), null);\n+        }\n+    }\n+\n+    private final String fieldName;\n+\n+    private DataStreamTimestampFieldMapper(FieldType fieldType, MappedFieldType mappedFieldType, String fieldName) {\n+        super(fieldType, mappedFieldType);\n+        this.fieldName = fieldName;\n+    }\n+\n+    @Override\n+    public void preParse(ParseContext context) throws IOException {\n+\n+    }\n+\n+    @Override\n+    protected void parseCreateField(ParseContext context) throws IOException {\n+\n+    }\n+\n+    @Override\n+    public void postParse(ParseContext context) throws IOException {\n+        if (fieldName == null) {\n+            // not configured, so skip the validation\n+            return;\n+        }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEwODExMA=="}, "originalCommit": {"oid": "d97b0d4c23cdeca9647bbc3b183493e5d7ffb9ac"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjM5NjkxNA==", "bodyText": "@dakrone brought up the good point that we used to have a _timestamp metadata field (#18980), so there may be some confusion over naming. For me the right naming depends some open questions like if we'll allow searches on this field, and if we see a use for it outside of datastreams.", "url": "https://github.com/elastic/elasticsearch/pull/58582#discussion_r446396914", "createdAt": "2020-06-26T20:33:20Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/DataStreamTimestampFieldMapper.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.document.FieldType;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.search.Query;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.query.QueryShardContext;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+public class DataStreamTimestampFieldMapper extends MetadataFieldMapper {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEwNjczNw=="}, "originalCommit": {"oid": "d97b0d4c23cdeca9647bbc3b183493e5d7ffb9ac"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQwMTQxMA==", "bodyText": "The field alias framework is narrow in scope and unfortunately isn't very extensible. @romseygeek is working on some refactors that will let field mappers delegate to other field types to expose search functionality. I think it will be cleaner and more forward-looking to collaborate on that.\nStepping back though, I don't know if this timestamp mapper should serve as a search-time alias for the delegate field. To me it'd be fine if it were just a hidden mapper that performed validation and recorded the data stream timestamp in the mappings. Generally we lean heavily on ECS to provide a consistent set of field names across individual schemas, and ECS has a convenient @timestamp field at the top level. Users can also define field aliases to allow for searching across different data streams. Does the 'timestamp' field need special treatment?\nOne advantage I can think of is that we could allow the delegate timestamp field to change for future indices in a data stream, and searches keep working on _timestamp. This doesn't seem like a common case though.", "url": "https://github.com/elastic/elasticsearch/pull/58582#discussion_r446401410", "createdAt": "2020-06-26T20:44:37Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/DataStreamTimestampFieldMapper.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.document.FieldType;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.search.Query;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.query.QueryShardContext;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+public class DataStreamTimestampFieldMapper extends MetadataFieldMapper {\n+\n+    public static final String NAME = \"_timestamp\";\n+\n+    public static class Defaults  {\n+\n+        public static final FieldType DATA_STREAM_TIMESTAMP_FIELD_TYPE = new FieldType();\n+\n+        static {\n+            DATA_STREAM_TIMESTAMP_FIELD_TYPE.setIndexOptions(IndexOptions.NONE);\n+            DATA_STREAM_TIMESTAMP_FIELD_TYPE.freeze();\n+        }\n+    }\n+\n+    // For now the field shouldn't be useable in searches.\n+    // In the future it should act as an alias to the actual data stream timestamp field.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEwNjQ2MQ=="}, "originalCommit": {"oid": "d97b0d4c23cdeca9647bbc3b183493e5d7ffb9ac"}, "originalPosition": 49}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "20732c8aa7478704fb5b58ee5ea69b4018c9c84a", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/20732c8aa7478704fb5b58ee5ea69b4018c9c84a", "committedDate": "2020-06-29T10:26:03Z", "message": "Merge remote-tracking branch 'es/master' into data_stream_timestamp_meta_field"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "afcee7f51a44e6e4655954dbaad56f8430b10ec0", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/afcee7f51a44e6e4655954dbaad56f8430b10ec0", "committedDate": "2020-06-29T14:03:04Z", "message": "Added more mapping validation logic and\nunit tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa689613c70206571c00a7d255f3e6420b8dff9b", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/fa689613c70206571c00a7d255f3e6420b8dff9b", "committedDate": "2020-06-29T14:04:40Z", "message": "rename"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5NDkyMzQ2", "url": "https://github.com/elastic/elasticsearch/pull/58582#pullrequestreview-439492346", "createdAt": "2020-06-29T20:53:42Z", "commit": {"oid": "fa689613c70206571c00a7d255f3e6420b8dff9b"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQyMDo1Mzo0MlrOGqh0lg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQyMTo0MzozOVrOGqjSgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzI0NzUxMA==", "bodyText": "I wonder if we could validate the actual mapping config itself, instead of the field type (which is the object used for searches/ aggregations). That way we could ensure the mapping doesn't contain other options that would be harmful: null_value and ignore_malformed.", "url": "https://github.com/elastic/elasticsearch/pull/58582#discussion_r447247510", "createdAt": "2020-06-29T20:53:42Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/TimestampFieldMapper.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.document.FieldType;\n+import org.apache.lucene.index.DocValuesType;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.search.Query;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.query.QueryShardContext;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+public class TimestampFieldMapper extends MetadataFieldMapper {\n+\n+    public static final String NAME = \"_timestamp\";\n+\n+    public static class Defaults  {\n+\n+        public static final FieldType DATA_STREAM_TIMESTAMP_FIELD_TYPE = new FieldType();\n+\n+        static {\n+            DATA_STREAM_TIMESTAMP_FIELD_TYPE.setIndexOptions(IndexOptions.NONE);\n+            DATA_STREAM_TIMESTAMP_FIELD_TYPE.freeze();\n+        }\n+    }\n+\n+    // For now the field shouldn't be useable in searches.\n+    // In the future it should act as an alias to the actual data stream timestamp field.\n+    public static final class DataStreamTimestampFieldFieldType extends MappedFieldType {\n+\n+        public DataStreamTimestampFieldFieldType() {\n+            super(NAME, false, false, TextSearchInfo.NONE, Map.of());\n+        }\n+\n+        @Override\n+        public MappedFieldType clone() {\n+            return new DataStreamTimestampFieldFieldType();\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return NAME;\n+        }\n+\n+        @Override\n+        public Query termQuery(Object value, QueryShardContext context) {\n+            throw new IllegalArgumentException(\"Field [\" + name() + \"] of type [\" + typeName() + \"] does not support term queries\");\n+        }\n+\n+        @Override\n+        public Query existsQuery(QueryShardContext context) {\n+            throw new IllegalArgumentException(\"Field [\" + name() + \"] of type [\" + typeName() + \"] does not support exists queries\");\n+        }\n+\n+    }\n+\n+    public static class Builder extends MetadataFieldMapper.Builder<Builder> {\n+\n+        private String fieldName;\n+\n+        public Builder() {\n+            super(NAME, Defaults.DATA_STREAM_TIMESTAMP_FIELD_TYPE);\n+        }\n+\n+        public void setFieldName(String fieldName) {\n+            this.fieldName = fieldName;\n+        }\n+\n+        @Override\n+        public MetadataFieldMapper build(BuilderContext context) {\n+            return new TimestampFieldMapper(\n+                fieldType,\n+                new DataStreamTimestampFieldFieldType(),\n+                fieldName\n+            );\n+        }\n+    }\n+\n+    public static class TypeParser implements MetadataFieldMapper.TypeParser {\n+\n+        @Override\n+        public MetadataFieldMapper.Builder<?> parse(String name,\n+                                                    Map<String, Object> node,\n+                                                    ParserContext parserContext) throws MapperParsingException {\n+            Builder builder = new Builder();\n+            for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(); iterator.hasNext();) {\n+                Map.Entry<String, Object> entry = iterator.next();\n+                String fieldName = entry.getKey();\n+                Object fieldNode = entry.getValue();\n+                if (fieldName.equals(\"field_name\")) {\n+                    builder.setFieldName((String) fieldNode);\n+                    iterator.remove();\n+                }\n+            }\n+            return builder;\n+        }\n+\n+        @Override\n+        public MetadataFieldMapper getDefault(ParserContext parserContext) {\n+            return new TimestampFieldMapper(Defaults.DATA_STREAM_TIMESTAMP_FIELD_TYPE,\n+                new DataStreamTimestampFieldFieldType(), null);\n+        }\n+    }\n+\n+    private final String fieldName;\n+\n+    private TimestampFieldMapper(FieldType fieldType, MappedFieldType mappedFieldType, String fieldName) {\n+        super(fieldType, mappedFieldType);\n+        this.fieldName = fieldName;\n+    }\n+\n+    public void validate(FieldTypeLookup lookup) {\n+        if (fieldName == null) {\n+            // not configured, so skip the validation\n+            return;\n+        }\n+\n+        MappedFieldType fieldType = lookup.get(fieldName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa689613c70206571c00a7d255f3e6420b8dff9b"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzI1MTkwNg==", "bodyText": "I think we should throw an error here, no one should try to write to the _timestamp field.", "url": "https://github.com/elastic/elasticsearch/pull/58582#discussion_r447251906", "createdAt": "2020-06-29T21:02:09Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/TimestampFieldMapper.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.document.FieldType;\n+import org.apache.lucene.index.DocValuesType;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.search.Query;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.query.QueryShardContext;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+public class TimestampFieldMapper extends MetadataFieldMapper {\n+\n+    public static final String NAME = \"_timestamp\";\n+\n+    public static class Defaults  {\n+\n+        public static final FieldType DATA_STREAM_TIMESTAMP_FIELD_TYPE = new FieldType();\n+\n+        static {\n+            DATA_STREAM_TIMESTAMP_FIELD_TYPE.setIndexOptions(IndexOptions.NONE);\n+            DATA_STREAM_TIMESTAMP_FIELD_TYPE.freeze();\n+        }\n+    }\n+\n+    // For now the field shouldn't be useable in searches.\n+    // In the future it should act as an alias to the actual data stream timestamp field.\n+    public static final class DataStreamTimestampFieldFieldType extends MappedFieldType {\n+\n+        public DataStreamTimestampFieldFieldType() {\n+            super(NAME, false, false, TextSearchInfo.NONE, Map.of());\n+        }\n+\n+        @Override\n+        public MappedFieldType clone() {\n+            return new DataStreamTimestampFieldFieldType();\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return NAME;\n+        }\n+\n+        @Override\n+        public Query termQuery(Object value, QueryShardContext context) {\n+            throw new IllegalArgumentException(\"Field [\" + name() + \"] of type [\" + typeName() + \"] does not support term queries\");\n+        }\n+\n+        @Override\n+        public Query existsQuery(QueryShardContext context) {\n+            throw new IllegalArgumentException(\"Field [\" + name() + \"] of type [\" + typeName() + \"] does not support exists queries\");\n+        }\n+\n+    }\n+\n+    public static class Builder extends MetadataFieldMapper.Builder<Builder> {\n+\n+        private String fieldName;\n+\n+        public Builder() {\n+            super(NAME, Defaults.DATA_STREAM_TIMESTAMP_FIELD_TYPE);\n+        }\n+\n+        public void setFieldName(String fieldName) {\n+            this.fieldName = fieldName;\n+        }\n+\n+        @Override\n+        public MetadataFieldMapper build(BuilderContext context) {\n+            return new TimestampFieldMapper(\n+                fieldType,\n+                new DataStreamTimestampFieldFieldType(),\n+                fieldName\n+            );\n+        }\n+    }\n+\n+    public static class TypeParser implements MetadataFieldMapper.TypeParser {\n+\n+        @Override\n+        public MetadataFieldMapper.Builder<?> parse(String name,\n+                                                    Map<String, Object> node,\n+                                                    ParserContext parserContext) throws MapperParsingException {\n+            Builder builder = new Builder();\n+            for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(); iterator.hasNext();) {\n+                Map.Entry<String, Object> entry = iterator.next();\n+                String fieldName = entry.getKey();\n+                Object fieldNode = entry.getValue();\n+                if (fieldName.equals(\"field_name\")) {\n+                    builder.setFieldName((String) fieldNode);\n+                    iterator.remove();\n+                }\n+            }\n+            return builder;\n+        }\n+\n+        @Override\n+        public MetadataFieldMapper getDefault(ParserContext parserContext) {\n+            return new TimestampFieldMapper(Defaults.DATA_STREAM_TIMESTAMP_FIELD_TYPE,\n+                new DataStreamTimestampFieldFieldType(), null);\n+        }\n+    }\n+\n+    private final String fieldName;\n+\n+    private TimestampFieldMapper(FieldType fieldType, MappedFieldType mappedFieldType, String fieldName) {\n+        super(fieldType, mappedFieldType);\n+        this.fieldName = fieldName;\n+    }\n+\n+    public void validate(FieldTypeLookup lookup) {\n+        if (fieldName == null) {\n+            // not configured, so skip the validation\n+            return;\n+        }\n+\n+        MappedFieldType fieldType = lookup.get(fieldName);\n+        if (fieldType == null) {\n+            throw new IllegalArgumentException(\"timestamp meta field's field_name [\" + fieldName + \"] points to a non existing field\");\n+        }\n+\n+        if (DateFieldMapper.CONTENT_TYPE.equals(fieldType.typeName()) == false &&\n+            DateFieldMapper.DATE_NANOS_CONTENT_TYPE.equals(fieldType.typeName()) == false) {\n+            throw new IllegalArgumentException(\"timestamp meta field's field_name [\" + fieldName + \"] is of type [\" +\n+                fieldType.typeName() + \"], but [\" + DateFieldMapper.CONTENT_TYPE + \",\" + DateFieldMapper.DATE_NANOS_CONTENT_TYPE +\n+                \"] is expected\");\n+        }\n+\n+        if (fieldType.isSearchable() == false) {\n+            throw new IllegalArgumentException(\"timestamp meta field's field_name [\" + fieldName + \"] is not indexed\");\n+        }\n+        if (fieldType.hasDocValues() == false) {\n+            throw new IllegalArgumentException(\"timestamp meta field's field_name [\" + fieldName + \"] doesn't have doc values\");\n+        }\n+    }\n+\n+    @Override\n+    public void preParse(ParseContext context) throws IOException {\n+\n+    }\n+\n+    @Override\n+    protected void parseCreateField(ParseContext context) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa689613c70206571c00a7d255f3e6420b8dff9b"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzI1MzA2NQ==", "bodyText": "We could use the name path instead of fieldName. This would match the naming for field aliases.", "url": "https://github.com/elastic/elasticsearch/pull/58582#discussion_r447253065", "createdAt": "2020-06-29T21:04:29Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/TimestampFieldMapper.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.document.FieldType;\n+import org.apache.lucene.index.DocValuesType;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.search.Query;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.query.QueryShardContext;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+public class TimestampFieldMapper extends MetadataFieldMapper {\n+\n+    public static final String NAME = \"_timestamp\";\n+\n+    public static class Defaults  {\n+\n+        public static final FieldType DATA_STREAM_TIMESTAMP_FIELD_TYPE = new FieldType();\n+\n+        static {\n+            DATA_STREAM_TIMESTAMP_FIELD_TYPE.setIndexOptions(IndexOptions.NONE);\n+            DATA_STREAM_TIMESTAMP_FIELD_TYPE.freeze();\n+        }\n+    }\n+\n+    // For now the field shouldn't be useable in searches.\n+    // In the future it should act as an alias to the actual data stream timestamp field.\n+    public static final class DataStreamTimestampFieldFieldType extends MappedFieldType {\n+\n+        public DataStreamTimestampFieldFieldType() {\n+            super(NAME, false, false, TextSearchInfo.NONE, Map.of());\n+        }\n+\n+        @Override\n+        public MappedFieldType clone() {\n+            return new DataStreamTimestampFieldFieldType();\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return NAME;\n+        }\n+\n+        @Override\n+        public Query termQuery(Object value, QueryShardContext context) {\n+            throw new IllegalArgumentException(\"Field [\" + name() + \"] of type [\" + typeName() + \"] does not support term queries\");\n+        }\n+\n+        @Override\n+        public Query existsQuery(QueryShardContext context) {\n+            throw new IllegalArgumentException(\"Field [\" + name() + \"] of type [\" + typeName() + \"] does not support exists queries\");\n+        }\n+\n+    }\n+\n+    public static class Builder extends MetadataFieldMapper.Builder<Builder> {\n+\n+        private String fieldName;\n+\n+        public Builder() {\n+            super(NAME, Defaults.DATA_STREAM_TIMESTAMP_FIELD_TYPE);\n+        }\n+\n+        public void setFieldName(String fieldName) {\n+            this.fieldName = fieldName;\n+        }\n+\n+        @Override\n+        public MetadataFieldMapper build(BuilderContext context) {\n+            return new TimestampFieldMapper(\n+                fieldType,\n+                new DataStreamTimestampFieldFieldType(),\n+                fieldName\n+            );\n+        }\n+    }\n+\n+    public static class TypeParser implements MetadataFieldMapper.TypeParser {\n+\n+        @Override\n+        public MetadataFieldMapper.Builder<?> parse(String name,\n+                                                    Map<String, Object> node,\n+                                                    ParserContext parserContext) throws MapperParsingException {\n+            Builder builder = new Builder();\n+            for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(); iterator.hasNext();) {\n+                Map.Entry<String, Object> entry = iterator.next();\n+                String fieldName = entry.getKey();\n+                Object fieldNode = entry.getValue();\n+                if (fieldName.equals(\"field_name\")) {\n+                    builder.setFieldName((String) fieldNode);\n+                    iterator.remove();\n+                }\n+            }\n+            return builder;\n+        }\n+\n+        @Override\n+        public MetadataFieldMapper getDefault(ParserContext parserContext) {\n+            return new TimestampFieldMapper(Defaults.DATA_STREAM_TIMESTAMP_FIELD_TYPE,\n+                new DataStreamTimestampFieldFieldType(), null);\n+        }\n+    }\n+\n+    private final String fieldName;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa689613c70206571c00a7d255f3e6420b8dff9b"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzI2MzAyOA==", "bodyText": "We could override mergeOptions and throw an error if the new field_name doesn't match. This includes the case of updating a null source path to a non-null one. I think currently we won't throw an error but just silently ignore the new mapping definition.", "url": "https://github.com/elastic/elasticsearch/pull/58582#discussion_r447263028", "createdAt": "2020-06-29T21:24:59Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/TimestampFieldMapper.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.document.FieldType;\n+import org.apache.lucene.index.DocValuesType;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.search.Query;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.query.QueryShardContext;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+public class TimestampFieldMapper extends MetadataFieldMapper {\n+\n+    public static final String NAME = \"_timestamp\";\n+\n+    public static class Defaults  {\n+\n+        public static final FieldType DATA_STREAM_TIMESTAMP_FIELD_TYPE = new FieldType();\n+\n+        static {\n+            DATA_STREAM_TIMESTAMP_FIELD_TYPE.setIndexOptions(IndexOptions.NONE);\n+            DATA_STREAM_TIMESTAMP_FIELD_TYPE.freeze();\n+        }\n+    }\n+\n+    // For now the field shouldn't be useable in searches.\n+    // In the future it should act as an alias to the actual data stream timestamp field.\n+    public static final class DataStreamTimestampFieldFieldType extends MappedFieldType {\n+\n+        public DataStreamTimestampFieldFieldType() {\n+            super(NAME, false, false, TextSearchInfo.NONE, Map.of());\n+        }\n+\n+        @Override\n+        public MappedFieldType clone() {\n+            return new DataStreamTimestampFieldFieldType();\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return NAME;\n+        }\n+\n+        @Override\n+        public Query termQuery(Object value, QueryShardContext context) {\n+            throw new IllegalArgumentException(\"Field [\" + name() + \"] of type [\" + typeName() + \"] does not support term queries\");\n+        }\n+\n+        @Override\n+        public Query existsQuery(QueryShardContext context) {\n+            throw new IllegalArgumentException(\"Field [\" + name() + \"] of type [\" + typeName() + \"] does not support exists queries\");\n+        }\n+\n+    }\n+\n+    public static class Builder extends MetadataFieldMapper.Builder<Builder> {\n+\n+        private String fieldName;\n+\n+        public Builder() {\n+            super(NAME, Defaults.DATA_STREAM_TIMESTAMP_FIELD_TYPE);\n+        }\n+\n+        public void setFieldName(String fieldName) {\n+            this.fieldName = fieldName;\n+        }\n+\n+        @Override\n+        public MetadataFieldMapper build(BuilderContext context) {\n+            return new TimestampFieldMapper(\n+                fieldType,\n+                new DataStreamTimestampFieldFieldType(),\n+                fieldName\n+            );\n+        }\n+    }\n+\n+    public static class TypeParser implements MetadataFieldMapper.TypeParser {\n+\n+        @Override\n+        public MetadataFieldMapper.Builder<?> parse(String name,\n+                                                    Map<String, Object> node,\n+                                                    ParserContext parserContext) throws MapperParsingException {\n+            Builder builder = new Builder();\n+            for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(); iterator.hasNext();) {\n+                Map.Entry<String, Object> entry = iterator.next();\n+                String fieldName = entry.getKey();\n+                Object fieldNode = entry.getValue();\n+                if (fieldName.equals(\"field_name\")) {\n+                    builder.setFieldName((String) fieldNode);\n+                    iterator.remove();\n+                }\n+            }\n+            return builder;\n+        }\n+\n+        @Override\n+        public MetadataFieldMapper getDefault(ParserContext parserContext) {\n+            return new TimestampFieldMapper(Defaults.DATA_STREAM_TIMESTAMP_FIELD_TYPE,\n+                new DataStreamTimestampFieldFieldType(), null);\n+        }\n+    }\n+\n+    private final String fieldName;\n+\n+    private TimestampFieldMapper(FieldType fieldType, MappedFieldType mappedFieldType, String fieldName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa689613c70206571c00a7d255f3e6420b8dff9b"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzI2NTg3OQ==", "bodyText": "This could just be TimestampFieldType ?", "url": "https://github.com/elastic/elasticsearch/pull/58582#discussion_r447265879", "createdAt": "2020-06-29T21:30:55Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/TimestampFieldMapper.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.document.FieldType;\n+import org.apache.lucene.index.DocValuesType;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.search.Query;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.query.QueryShardContext;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+public class TimestampFieldMapper extends MetadataFieldMapper {\n+\n+    public static final String NAME = \"_timestamp\";\n+\n+    public static class Defaults  {\n+\n+        public static final FieldType DATA_STREAM_TIMESTAMP_FIELD_TYPE = new FieldType();\n+\n+        static {\n+            DATA_STREAM_TIMESTAMP_FIELD_TYPE.setIndexOptions(IndexOptions.NONE);\n+            DATA_STREAM_TIMESTAMP_FIELD_TYPE.freeze();\n+        }\n+    }\n+\n+    // For now the field shouldn't be useable in searches.\n+    // In the future it should act as an alias to the actual data stream timestamp field.\n+    public static final class DataStreamTimestampFieldFieldType extends MappedFieldType {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa689613c70206571c00a7d255f3e6420b8dff9b"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzI3MTU1NQ==", "bodyText": "Is there a case where the data stream does not exist, but we are still creating a new index within it?", "url": "https://github.com/elastic/elasticsearch/pull/58582#discussion_r447271555", "createdAt": "2020-06-29T21:43:39Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataCreateIndexService.java", "diffHunk": "@@ -494,10 +495,19 @@ private ClusterState applyCreateIndexRequestWithV2Template(final ClusterState cu\n         final Map<String, Object> mappings = resolveV2Mappings(request.mappings(), currentState, templateName, xContentRegistry);\n \n         if (request.dataStreamName() != null) {\n+            String timestampField;\n             DataStream dataStream = currentState.metadata().dataStreams().get(request.dataStreamName());\n             if (dataStream != null) {\n+                timestampField = dataStream.getTimeStampField().getName();\n                 dataStream.getTimeStampField().insertTimestampFieldMapping(mappings);\n+            } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa689613c70206571c00a7d255f3e6420b8dff9b"}, "originalPosition": 17}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e0a70d0623527f92d3e8b992bf58c46e46e3eef4", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/e0a70d0623527f92d3e8b992bf58c46e46e3eef4", "committedDate": "2020-06-30T08:50:17Z", "message": "Merge remote-tracking branch 'es/master' into data_stream_timestamp_meta_field"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "63a18f3c96c77a26c34efcf23a7f290c45fe4427", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/63a18f3c96c77a26c34efcf23a7f290c45fe4427", "committedDate": "2020-06-30T09:22:00Z", "message": "iter after merge"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "072d85e5702dc4cfe199eecfcd58f622b52c3a99", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/072d85e5702dc4cfe199eecfcd58f622b52c3a99", "committedDate": "2020-06-30T09:31:47Z", "message": "addressed small comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3cde4c11fc41925ddaef17c869753480b7610049", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/3cde4c11fc41925ddaef17c869753480b7610049", "committedDate": "2020-06-30T09:34:02Z", "message": "fixed test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bbe76fa43dc05f7b040e0df4945b19e1abf1f0db", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/bbe76fa43dc05f7b040e0df4945b19e1abf1f0db", "committedDate": "2020-06-30T12:32:32Z", "message": "improve validation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "195bfa1bc2935ddbe6e5a5eeb80cddb096a41c82", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/195bfa1bc2935ddbe6e5a5eeb80cddb096a41c82", "committedDate": "2020-06-30T12:35:12Z", "message": "fixed more tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "78c67199b6c4cf3e072d8f7f088d5751c99b4469", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/78c67199b6c4cf3e072d8f7f088d5751c99b4469", "committedDate": "2020-06-30T12:59:52Z", "message": "fail with an error if path is updated instead of silently ignoring it."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d8da070716a17744574d68f2a0575a672f029b69", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/d8da070716a17744574d68f2a0575a672f029b69", "committedDate": "2020-06-30T13:44:59Z", "message": "Merge remote-tracking branch 'es/master' into data_stream_timestamp_meta_field"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "28d568e5dfdf8dd93a7d02879747e6544edd5bd7", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/28d568e5dfdf8dd93a7d02879747e6544edd5bd7", "committedDate": "2020-06-30T13:45:48Z", "message": "fixed test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0c03e370cd84928867b97c577dff53a977e1c464", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/0c03e370cd84928867b97c577dff53a977e1c464", "committedDate": "2020-06-30T15:55:22Z", "message": "Merge remote-tracking branch 'es/master' into data_stream_timestamp_meta_field"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7b24a57e94205ad02aecc39518b368e70d476023", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/7b24a57e94205ad02aecc39518b368e70d476023", "committedDate": "2020-06-30T16:04:20Z", "message": "fixed test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwMjc5NjQ1", "url": "https://github.com/elastic/elasticsearch/pull/58582#pullrequestreview-440279645", "createdAt": "2020-06-30T18:27:13Z", "commit": {"oid": "7b24a57e94205ad02aecc39518b368e70d476023"}, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxODoyNzoxM1rOGrJP2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxODo1MjoyOVrOGrKILQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg5MzQ2Nw==", "bodyText": "To me it'd be cleaner to avoid working with the raw JSON and just check specific attributes like 'null value' and 'ignore malformed'. We can add getters to DateFieldMapper if it makes it easier.", "url": "https://github.com/elastic/elasticsearch/pull/58582#discussion_r447893467", "createdAt": "2020-06-30T18:27:13Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/TimestampFieldMapper.java", "diffHunk": "@@ -0,0 +1,255 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.document.FieldType;\n+import org.apache.lucene.index.DocValuesType;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.search.Query;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentHelper;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.index.query.QueryShardContext;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.common.xcontent.XContentFactory.jsonBuilder;\n+\n+public class TimestampFieldMapper extends MetadataFieldMapper {\n+\n+    public static final String NAME = \"_timestamp\";\n+\n+    public static class Defaults  {\n+\n+        public static final FieldType TIMESTAMP_FIELD_TYPE = new FieldType();\n+\n+        static {\n+            TIMESTAMP_FIELD_TYPE.setIndexOptions(IndexOptions.NONE);\n+            TIMESTAMP_FIELD_TYPE.freeze();\n+        }\n+    }\n+\n+    // For now the field shouldn't be useable in searches.\n+    // In the future it should act as an alias to the actual data stream timestamp field.\n+    public static final class TimestampFieldType extends MappedFieldType {\n+\n+        public TimestampFieldType() {\n+            super(NAME, false, false, TextSearchInfo.NONE, Map.of());\n+        }\n+\n+        @Override\n+        public MappedFieldType clone() {\n+            return new TimestampFieldType();\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return NAME;\n+        }\n+\n+        @Override\n+        public Query termQuery(Object value, QueryShardContext context) {\n+            throw new IllegalArgumentException(\"Field [\" + name() + \"] of type [\" + typeName() + \"] does not support term queries\");\n+        }\n+\n+        @Override\n+        public Query existsQuery(QueryShardContext context) {\n+            throw new IllegalArgumentException(\"Field [\" + name() + \"] of type [\" + typeName() + \"] does not support exists queries\");\n+        }\n+\n+    }\n+\n+    public static class Builder extends MetadataFieldMapper.Builder<Builder> {\n+\n+        private String path;\n+\n+        public Builder() {\n+            super(NAME, Defaults.TIMESTAMP_FIELD_TYPE);\n+        }\n+\n+        public void setPath(String path) {\n+            this.path = path;\n+        }\n+\n+        @Override\n+        public MetadataFieldMapper build(BuilderContext context) {\n+            return new TimestampFieldMapper(\n+                fieldType,\n+                new TimestampFieldType(),\n+                path\n+            );\n+        }\n+    }\n+\n+    public static class TypeParser implements MetadataFieldMapper.TypeParser {\n+\n+        @Override\n+        public MetadataFieldMapper.Builder<?> parse(String name,\n+                                                    Map<String, Object> node,\n+                                                    ParserContext parserContext) throws MapperParsingException {\n+            Builder builder = new Builder();\n+            for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(); iterator.hasNext();) {\n+                Map.Entry<String, Object> entry = iterator.next();\n+                String fieldName = entry.getKey();\n+                Object fieldNode = entry.getValue();\n+                if (fieldName.equals(\"path\")) {\n+                    builder.setPath((String) fieldNode);\n+                    iterator.remove();\n+                }\n+            }\n+            return builder;\n+        }\n+\n+        @Override\n+        public MetadataFieldMapper getDefault(ParserContext parserContext) {\n+            return new TimestampFieldMapper(Defaults.TIMESTAMP_FIELD_TYPE,\n+                new TimestampFieldType(), null);\n+        }\n+    }\n+\n+    private final String path;\n+\n+    private TimestampFieldMapper(FieldType fieldType, MappedFieldType mappedFieldType, String path) {\n+        super(fieldType, mappedFieldType);\n+        this.path = path;\n+    }\n+\n+    public void validate(DocumentFieldMappers lookup) {\n+        if (path == null) {\n+            // not configured, so skip the validation\n+            return;\n+        }\n+\n+        Mapper mapper = lookup.getMapper(path);\n+        if (mapper == null) {\n+            throw new IllegalArgumentException(\"timestamp meta field's field_name [\" + path + \"] points to a non existing field\");\n+        }\n+\n+        if (DateFieldMapper.CONTENT_TYPE.equals(mapper.typeName()) == false &&\n+            DateFieldMapper.DATE_NANOS_CONTENT_TYPE.equals(mapper.typeName()) == false) {\n+            throw new IllegalArgumentException(\"timestamp meta field's field_name [\" + path + \"] is of type [\" +\n+                mapper.typeName() + \"], but [\" + DateFieldMapper.CONTENT_TYPE + \",\" + DateFieldMapper.DATE_NANOS_CONTENT_TYPE +\n+                \"] is expected\");\n+        }\n+\n+        DateFieldMapper dateFieldMapper = (DateFieldMapper) mapper;\n+        if (dateFieldMapper.fieldType().isSearchable() == false) {\n+            throw new IllegalArgumentException(\"timestamp meta field's field_name [\" + path + \"] is not indexed\");\n+        }\n+        if (dateFieldMapper.fieldType().hasDocValues() == false) {\n+            throw new IllegalArgumentException(\"timestamp meta field's field_name [\" + path + \"] doesn't have doc values\");\n+        }\n+\n+        // Validate whether disallowed mapping attributes have been specified on the field this meta field refers to:\n+        try (XContentBuilder builder = jsonBuilder()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b24a57e94205ad02aecc39518b368e70d476023"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg5NDUwOQ==", "bodyText": "I think these messages are intended to be end-user friendly? So something like this could be clearer: \"The configured timestamp field does not exist.\"", "url": "https://github.com/elastic/elasticsearch/pull/58582#discussion_r447894509", "createdAt": "2020-06-30T18:28:59Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/TimestampFieldMapper.java", "diffHunk": "@@ -0,0 +1,255 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.document.FieldType;\n+import org.apache.lucene.index.DocValuesType;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.search.Query;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentHelper;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.index.query.QueryShardContext;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.common.xcontent.XContentFactory.jsonBuilder;\n+\n+public class TimestampFieldMapper extends MetadataFieldMapper {\n+\n+    public static final String NAME = \"_timestamp\";\n+\n+    public static class Defaults  {\n+\n+        public static final FieldType TIMESTAMP_FIELD_TYPE = new FieldType();\n+\n+        static {\n+            TIMESTAMP_FIELD_TYPE.setIndexOptions(IndexOptions.NONE);\n+            TIMESTAMP_FIELD_TYPE.freeze();\n+        }\n+    }\n+\n+    // For now the field shouldn't be useable in searches.\n+    // In the future it should act as an alias to the actual data stream timestamp field.\n+    public static final class TimestampFieldType extends MappedFieldType {\n+\n+        public TimestampFieldType() {\n+            super(NAME, false, false, TextSearchInfo.NONE, Map.of());\n+        }\n+\n+        @Override\n+        public MappedFieldType clone() {\n+            return new TimestampFieldType();\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return NAME;\n+        }\n+\n+        @Override\n+        public Query termQuery(Object value, QueryShardContext context) {\n+            throw new IllegalArgumentException(\"Field [\" + name() + \"] of type [\" + typeName() + \"] does not support term queries\");\n+        }\n+\n+        @Override\n+        public Query existsQuery(QueryShardContext context) {\n+            throw new IllegalArgumentException(\"Field [\" + name() + \"] of type [\" + typeName() + \"] does not support exists queries\");\n+        }\n+\n+    }\n+\n+    public static class Builder extends MetadataFieldMapper.Builder<Builder> {\n+\n+        private String path;\n+\n+        public Builder() {\n+            super(NAME, Defaults.TIMESTAMP_FIELD_TYPE);\n+        }\n+\n+        public void setPath(String path) {\n+            this.path = path;\n+        }\n+\n+        @Override\n+        public MetadataFieldMapper build(BuilderContext context) {\n+            return new TimestampFieldMapper(\n+                fieldType,\n+                new TimestampFieldType(),\n+                path\n+            );\n+        }\n+    }\n+\n+    public static class TypeParser implements MetadataFieldMapper.TypeParser {\n+\n+        @Override\n+        public MetadataFieldMapper.Builder<?> parse(String name,\n+                                                    Map<String, Object> node,\n+                                                    ParserContext parserContext) throws MapperParsingException {\n+            Builder builder = new Builder();\n+            for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(); iterator.hasNext();) {\n+                Map.Entry<String, Object> entry = iterator.next();\n+                String fieldName = entry.getKey();\n+                Object fieldNode = entry.getValue();\n+                if (fieldName.equals(\"path\")) {\n+                    builder.setPath((String) fieldNode);\n+                    iterator.remove();\n+                }\n+            }\n+            return builder;\n+        }\n+\n+        @Override\n+        public MetadataFieldMapper getDefault(ParserContext parserContext) {\n+            return new TimestampFieldMapper(Defaults.TIMESTAMP_FIELD_TYPE,\n+                new TimestampFieldType(), null);\n+        }\n+    }\n+\n+    private final String path;\n+\n+    private TimestampFieldMapper(FieldType fieldType, MappedFieldType mappedFieldType, String path) {\n+        super(fieldType, mappedFieldType);\n+        this.path = path;\n+    }\n+\n+    public void validate(DocumentFieldMappers lookup) {\n+        if (path == null) {\n+            // not configured, so skip the validation\n+            return;\n+        }\n+\n+        Mapper mapper = lookup.getMapper(path);\n+        if (mapper == null) {\n+            throw new IllegalArgumentException(\"timestamp meta field's field_name [\" + path + \"] points to a non existing field\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b24a57e94205ad02aecc39518b368e70d476023"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg5NDgwNQ==", "bodyText": "Same thoughts for these other messages, users probably won't understand what \"timestamp meta field's field_name ...\" means.", "url": "https://github.com/elastic/elasticsearch/pull/58582#discussion_r447894805", "createdAt": "2020-06-30T18:29:28Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/TimestampFieldMapper.java", "diffHunk": "@@ -0,0 +1,255 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.mapper;\n+\n+import org.apache.lucene.document.FieldType;\n+import org.apache.lucene.index.DocValuesType;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.search.Query;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentHelper;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.index.query.QueryShardContext;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.common.xcontent.XContentFactory.jsonBuilder;\n+\n+public class TimestampFieldMapper extends MetadataFieldMapper {\n+\n+    public static final String NAME = \"_timestamp\";\n+\n+    public static class Defaults  {\n+\n+        public static final FieldType TIMESTAMP_FIELD_TYPE = new FieldType();\n+\n+        static {\n+            TIMESTAMP_FIELD_TYPE.setIndexOptions(IndexOptions.NONE);\n+            TIMESTAMP_FIELD_TYPE.freeze();\n+        }\n+    }\n+\n+    // For now the field shouldn't be useable in searches.\n+    // In the future it should act as an alias to the actual data stream timestamp field.\n+    public static final class TimestampFieldType extends MappedFieldType {\n+\n+        public TimestampFieldType() {\n+            super(NAME, false, false, TextSearchInfo.NONE, Map.of());\n+        }\n+\n+        @Override\n+        public MappedFieldType clone() {\n+            return new TimestampFieldType();\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return NAME;\n+        }\n+\n+        @Override\n+        public Query termQuery(Object value, QueryShardContext context) {\n+            throw new IllegalArgumentException(\"Field [\" + name() + \"] of type [\" + typeName() + \"] does not support term queries\");\n+        }\n+\n+        @Override\n+        public Query existsQuery(QueryShardContext context) {\n+            throw new IllegalArgumentException(\"Field [\" + name() + \"] of type [\" + typeName() + \"] does not support exists queries\");\n+        }\n+\n+    }\n+\n+    public static class Builder extends MetadataFieldMapper.Builder<Builder> {\n+\n+        private String path;\n+\n+        public Builder() {\n+            super(NAME, Defaults.TIMESTAMP_FIELD_TYPE);\n+        }\n+\n+        public void setPath(String path) {\n+            this.path = path;\n+        }\n+\n+        @Override\n+        public MetadataFieldMapper build(BuilderContext context) {\n+            return new TimestampFieldMapper(\n+                fieldType,\n+                new TimestampFieldType(),\n+                path\n+            );\n+        }\n+    }\n+\n+    public static class TypeParser implements MetadataFieldMapper.TypeParser {\n+\n+        @Override\n+        public MetadataFieldMapper.Builder<?> parse(String name,\n+                                                    Map<String, Object> node,\n+                                                    ParserContext parserContext) throws MapperParsingException {\n+            Builder builder = new Builder();\n+            for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(); iterator.hasNext();) {\n+                Map.Entry<String, Object> entry = iterator.next();\n+                String fieldName = entry.getKey();\n+                Object fieldNode = entry.getValue();\n+                if (fieldName.equals(\"path\")) {\n+                    builder.setPath((String) fieldNode);\n+                    iterator.remove();\n+                }\n+            }\n+            return builder;\n+        }\n+\n+        @Override\n+        public MetadataFieldMapper getDefault(ParserContext parserContext) {\n+            return new TimestampFieldMapper(Defaults.TIMESTAMP_FIELD_TYPE,\n+                new TimestampFieldType(), null);\n+        }\n+    }\n+\n+    private final String path;\n+\n+    private TimestampFieldMapper(FieldType fieldType, MappedFieldType mappedFieldType, String path) {\n+        super(fieldType, mappedFieldType);\n+        this.path = path;\n+    }\n+\n+    public void validate(DocumentFieldMappers lookup) {\n+        if (path == null) {\n+            // not configured, so skip the validation\n+            return;\n+        }\n+\n+        Mapper mapper = lookup.getMapper(path);\n+        if (mapper == null) {\n+            throw new IllegalArgumentException(\"timestamp meta field's field_name [\" + path + \"] points to a non existing field\");\n+        }\n+\n+        if (DateFieldMapper.CONTENT_TYPE.equals(mapper.typeName()) == false &&\n+            DateFieldMapper.DATE_NANOS_CONTENT_TYPE.equals(mapper.typeName()) == false) {\n+            throw new IllegalArgumentException(\"timestamp meta field's field_name [\" + path + \"] is of type [\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b24a57e94205ad02aecc39518b368e70d476023"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkwNzg4NQ==", "bodyText": "We could move this logic into MapperMergeValidator#validateFieldReferences to keep all the cross-field validation in one place.", "url": "https://github.com/elastic/elasticsearch/pull/58582#discussion_r447907885", "createdAt": "2020-06-30T18:52:29Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/index/mapper/MapperService.java", "diffHunk": "@@ -391,6 +391,12 @@ private synchronized DocumentMapper internalMerge(DocumentMapper mapper, MergeRe\n         }\n         checkIndexSortCompatibility(indexSettings.getIndexSortConfig(), hasNested);\n \n+        for (MetadataFieldMapper metadataFieldMapper : metadataMappers) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b24a57e94205ad02aecc39518b368e70d476023"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b8b82f6a584ebe5bc9d750bdcb007594f7d203b5", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/b8b82f6a584ebe5bc9d750bdcb007594f7d203b5", "committedDate": "2020-07-01T12:00:56Z", "message": "Merge remote-tracking branch 'es/master' into data_stream_timestamp_meta_field"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "41aec733ae974da82658a67f469f7063fa379655", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/41aec733ae974da82658a67f469f7063fa379655", "committedDate": "2020-07-01T12:16:25Z", "message": "fixed tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "116f7b9f8a2371543a518325e8de4a72f5026a13", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/116f7b9f8a2371543a518325e8de4a72f5026a13", "committedDate": "2020-07-01T12:28:52Z", "message": "moved validation logic to MapperMergeValidator#validateFieldReferences(...)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d0d9f3327f5f257333a4bd445d05220f2cafef3b", "author": {"user": {"login": "martijnvg", "name": "Martijn van Groningen"}}, "url": "https://github.com/elastic/elasticsearch/commit/d0d9f3327f5f257333a4bd445d05220f2cafef3b", "committedDate": "2020-07-01T13:02:57Z", "message": "changed error messages and specifically check for null_value and ignore_malformed"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2646, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}