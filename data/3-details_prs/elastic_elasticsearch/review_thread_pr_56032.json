{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDExNTE5NTE4", "number": 56032, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNDoxNzo0NFrOD4EFFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNDoxODozMFrOD4EGSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMTEzNjg2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/SearchService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNDoxNzo0NFrOGOra2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNDo1ODo1MFrOGOtS9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA0NDYzNA==", "bodyText": "Why not using markAsUsed ?", "url": "https://github.com/elastic/elasticsearch/pull/56032#discussion_r418044634", "createdAt": "2020-04-30T14:17:44Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/search/SearchService.java", "diffHunk": "@@ -1138,17 +1138,38 @@ public AliasFilter buildAliasFilter(ClusterState state, String index, Set<String\n      */\n     public CanMatchResponse canMatch(ShardSearchRequest request) throws IOException {\n         assert request.searchType() == SearchType.QUERY_THEN_FETCH : \"unexpected search type: \" + request.searchType();\n-        // TODO: support can_match with reader contexts after https://github.com/elastic/elasticsearch/pull/54966\n-        assert request.readerId() == null : \"request with reader_id bypass can_match phase\";\n         IndexService indexService = indicesService.indexServiceSafe(request.shardId().getIndex());\n-        IndexShard indexShard = indexService.getShard(request.shardId().getId());\n-        // we don't want to use the reader wrapper since it could run costly operations\n-        // and we can afford false positives.\n-        final boolean hasRefreshPending = indexShard.hasRefreshPending();\n-        try (Engine.Searcher searcher = indexShard.acquireSearcher(\"can_match\")) {\n+        final boolean hasRefreshPending;\n+        final Engine.Searcher canMatchSearcher;\n+        if (request.readerId() != null) {\n+            final ReaderContext readerContext = findReaderContext(request.readerId());\n+            checkKeepAliveLimit(request.keepAlive().millis());\n+            readerContext.keepAlive(request.keepAlive().millis());\n+            readerContext.incRef();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b960851552cea706770aabb7fabbd2302d17ac2"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA3NTM4Mw==", "bodyText": "markAsUsed is not water-tight. It's possible that the Reaper already decides to reap this reader context, then markAsUsed will be a noop, and the searcher can be closed in midway (see #20095). Should we make markAsUsed as tighten as incRef?", "url": "https://github.com/elastic/elasticsearch/pull/56032#discussion_r418075383", "createdAt": "2020-04-30T14:58:50Z", "author": {"login": "dnhatn"}, "path": "server/src/main/java/org/elasticsearch/search/SearchService.java", "diffHunk": "@@ -1138,17 +1138,38 @@ public AliasFilter buildAliasFilter(ClusterState state, String index, Set<String\n      */\n     public CanMatchResponse canMatch(ShardSearchRequest request) throws IOException {\n         assert request.searchType() == SearchType.QUERY_THEN_FETCH : \"unexpected search type: \" + request.searchType();\n-        // TODO: support can_match with reader contexts after https://github.com/elastic/elasticsearch/pull/54966\n-        assert request.readerId() == null : \"request with reader_id bypass can_match phase\";\n         IndexService indexService = indicesService.indexServiceSafe(request.shardId().getIndex());\n-        IndexShard indexShard = indexService.getShard(request.shardId().getId());\n-        // we don't want to use the reader wrapper since it could run costly operations\n-        // and we can afford false positives.\n-        final boolean hasRefreshPending = indexShard.hasRefreshPending();\n-        try (Engine.Searcher searcher = indexShard.acquireSearcher(\"can_match\")) {\n+        final boolean hasRefreshPending;\n+        final Engine.Searcher canMatchSearcher;\n+        if (request.readerId() != null) {\n+            final ReaderContext readerContext = findReaderContext(request.readerId());\n+            checkKeepAliveLimit(request.keepAlive().millis());\n+            readerContext.keepAlive(request.keepAlive().millis());\n+            readerContext.incRef();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA0NDYzNA=="}, "originalCommit": {"oid": "5b960851552cea706770aabb7fabbd2302d17ac2"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMTEzOTk0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/SearchService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNDoxODozMFrOGOrc7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNDoxODozMFrOGOrc7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA0NTE2Ng==", "bodyText": "Unrelated but I think we can remove this comment now", "url": "https://github.com/elastic/elasticsearch/pull/56032#discussion_r418045166", "createdAt": "2020-04-30T14:18:30Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/search/SearchService.java", "diffHunk": "@@ -1138,17 +1138,38 @@ public AliasFilter buildAliasFilter(ClusterState state, String index, Set<String\n      */\n     public CanMatchResponse canMatch(ShardSearchRequest request) throws IOException {\n         assert request.searchType() == SearchType.QUERY_THEN_FETCH : \"unexpected search type: \" + request.searchType();\n-        // TODO: support can_match with reader contexts after https://github.com/elastic/elasticsearch/pull/54966\n-        assert request.readerId() == null : \"request with reader_id bypass can_match phase\";\n         IndexService indexService = indicesService.indexServiceSafe(request.shardId().getIndex());\n-        IndexShard indexShard = indexService.getShard(request.shardId().getId());\n-        // we don't want to use the reader wrapper since it could run costly operations\n-        // and we can afford false positives.\n-        final boolean hasRefreshPending = indexShard.hasRefreshPending();\n-        try (Engine.Searcher searcher = indexShard.acquireSearcher(\"can_match\")) {\n+        final boolean hasRefreshPending;\n+        final Engine.Searcher canMatchSearcher;\n+        if (request.readerId() != null) {\n+            final ReaderContext readerContext = findReaderContext(request.readerId());\n+            checkKeepAliveLimit(request.keepAlive().millis());\n+            readerContext.keepAlive(request.keepAlive().millis());\n+            readerContext.incRef();\n+            boolean success = false;\n+            try {\n+                final Engine.Searcher searcher = readerContext.acquireSearcher(\"can_match\");\n+                canMatchSearcher = new Engine.Searcher(searcher.source(), searcher.getDirectoryReader(),\n+                    searcher.getSimilarity(), searcher.getQueryCache(), searcher.getQueryCachingPolicy(),\n+                    Releasables.wrap(searcher, readerContext::decRef));\n+                success = true;\n+            } finally {\n+                if (success == false) {\n+                    readerContext.decRef();\n+                }\n+            }\n+            hasRefreshPending = false;\n+        } else {\n+            IndexShard indexShard = indexService.getShard(request.shardId().getId());\n+            hasRefreshPending = indexShard.hasRefreshPending();\n+            // we don't want to use the reader wrapper since it could run costly operations", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b960851552cea706770aabb7fabbd2302d17ac2"}, "originalPosition": 35}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2429, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}