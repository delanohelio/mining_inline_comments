{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg4MDY0NDU1", "number": 62473, "title": "Build local unreleased bwc versions more efficient for tests", "bodyText": "For testing against the local distribution we already avoid the packaging/unpackaging cycle of es distributions when setting up test clusters. This PR adopts the usage of the expanded created distributions for unreleased bwc versions (versions that are checkout from a branch and build from source in the :distribution:bwc:minor / :distribution:bwc:bugfix). This makes the setup of bwc based cross version tests a bit faster by avoiding the unpackaging overhead. We still assemble both in the bwcBuild tasks atm which will be addressed in a later issue.\nAs part of the work I reworked the :distribution:bwc project and made a couple of changes to make working in that area less painful:\n\nConvert all the custom logic from build script logic (groovy) into gradle binary plugins (java)\nTried to make the bwc setup logic a bit more readable\nAdd basic functional test coverage for the bwc logic this PR tweaked.\nExtracted a general internal BWC Git plugin out of the bwc setup plugin to improve maintenance and testability\nChanged the InternalDistributionPlugin to resolve the extracted distro instead on relying on unpacking the distribution archive\n\nFixes #62115", "createdAt": "2020-09-16T15:18:51Z", "url": "https://github.com/elastic/elasticsearch/pull/62473", "merged": true, "mergeCommit": {"oid": "2a8885ae91b19d82998d503a1ba6063b3b79b9f1"}, "closed": true, "closedAt": "2020-10-01T08:45:22Z", "author": {"login": "breskeby"}, "timelineItems": {"totalCount": 29, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdLF8cggBqjM3ODk1NDQ4OTI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdN--DygBqjM4MjUyODEzNTA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6b3b4d71a1e01ace5377b19d55c1466a00f9a1ab", "author": {"user": {"login": "breskeby", "name": "Rene Groeschke"}}, "url": "https://github.com/elastic/elasticsearch/commit/6b3b4d71a1e01ace5377b19d55c1466a00f9a1ab", "committedDate": "2020-09-21T14:46:48Z", "message": "fix bwc jdbc build"}, "afterCommit": {"oid": "60a2c55508206909cba2d8481dafacb59be9e8df", "author": {"user": {"login": "breskeby", "name": "Rene Groeschke"}}, "url": "https://github.com/elastic/elasticsearch/commit/60a2c55508206909cba2d8481dafacb59be9e8df", "committedDate": "2020-09-21T16:11:03Z", "message": "fix bwc jdbc build"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b223a307e31a50517ca72e9921b937ccc33af2c7", "author": {"user": {"login": "breskeby", "name": "Rene Groeschke"}}, "url": "https://github.com/elastic/elasticsearch/commit/b223a307e31a50517ca72e9921b937ccc33af2c7", "committedDate": "2020-09-23T10:23:27Z", "message": "Minor refactoring of the plugin and fixing path calculations"}, "afterCommit": {"oid": "f544a08bf99cc8f92c0b3437702901e42a75b9b2", "author": {"user": {"login": "breskeby", "name": "Rene Groeschke"}}, "url": "https://github.com/elastic/elasticsearch/commit/f544a08bf99cc8f92c0b3437702901e42a75b9b2", "committedDate": "2020-09-23T13:25:38Z", "message": "Minor refactoring of the plugin and fixing path calculations"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1NTYzMDI0", "url": "https://github.com/elastic/elasticsearch/pull/62473#pullrequestreview-495563024", "createdAt": "2020-09-24T13:21:47Z", "commit": {"oid": "7b85294ffa2c256af99d34bb5adf6a08823728f6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxMzoyMTo0N1rOHXaYNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxMzoyMTo0N1rOHXaYNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMxMTQ3Nw==", "bodyText": "From all the changes, this tweaked test actually shows what this PR is all about.", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r494311477", "createdAt": "2020-09-24T13:21:47Z", "author": {"login": "breskeby"}, "path": "buildSrc/src/integTest/groovy/org/elasticsearch/gradle/internal/InternalDistributionDownloadPluginFuncTest.groovy", "diffHunk": "@@ -74,14 +74,13 @@ class InternalDistributionDownloadPluginFuncTest extends AbstractGradleFuncTest\n         then:\n         result.task(\":distribution:archives:linux-tar:buildExploded\").outcome == TaskOutcome.SUCCESS\n         result.task(\":setupDistro\").outcome == TaskOutcome.SUCCESS\n-        assertExtractedDistroIsCreated(distroVersion, \"build/distro\", 'current-marker.txt')\n+        assertExtractedDistroIsCreated(\"build/distro\", 'current-marker.txt')\n     }\n \n-    def \"resolves bwc versions from source\"() {\n+    def \"resolves expanded bwc versions from source\"() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b85294ffa2c256af99d34bb5adf6a08823728f6"}, "originalPosition": 9}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk4NzQwNTEz", "url": "https://github.com/elastic/elasticsearch/pull/62473#pullrequestreview-498740513", "createdAt": "2020-09-29T17:55:02Z", "commit": {"oid": "9df3ee594a24c357bbf8028a317b7596f6e10c85"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNzo1NTowMlrOHZ6RkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxODoxNjozNVrOHZ7DQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkzMTIxNw==", "bodyText": "Will we need to update this as we bump our real ci java properties? If so, can we generate or copy the file when running the test?", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r496931217", "createdAt": "2020-09-29T17:55:02Z", "author": {"login": "rjernst"}, "path": "buildSrc/src/integTest/resources/org/elasticsearch/gradle/internal/fake_git/remote/.ci/java-versions.properties", "diffHunk": "@@ -0,0 +1,21 @@\n+#\n+# Licensed to Elasticsearch under one or more contributor\n+# license agreements. See the NOTICE file distributed with\n+# this work for additional information regarding copyright\n+# ownership. Elasticsearch licenses this file to you under\n+# the Apache License, Version 2.0 (the \"License\"); you may\n+# not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+#\n+ES_BUILD_JAVA=openjdk14", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9df3ee594a24c357bbf8028a317b7596f6e10c85"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkzOTUxNQ==", "bodyText": "What does the entirety of the lifecycle output look like? This comment on its own would be pretty cryptic", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r496939515", "createdAt": "2020-09-29T18:09:01Z", "author": {"login": "rjernst"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalBwcGitPlugin.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.LoggedExec;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.gradle.api.Action;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.logging.Logger;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n+import org.gradle.api.provider.Provider;\n+import org.gradle.api.provider.ProviderFactory;\n+import org.gradle.api.tasks.TaskContainer;\n+import org.gradle.api.tasks.TaskProvider;\n+import org.gradle.process.ExecResult;\n+import org.gradle.process.ExecSpec;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+\n+import static java.util.Arrays.asList;\n+\n+public class InternalBwcGitPlugin implements Plugin<Project> {\n+\n+    private BwcGitExtension gitExtension;\n+    private Project project;\n+\n+    @Override\n+    public void apply(Project project) {\n+        this.project = project;\n+        this.gitExtension = project.getExtensions().create(\"bwcGitConfig\", BwcGitExtension.class);\n+        ProviderFactory providers = project.getProviders();\n+        Provider<String> remote = project.getProviders().systemProperty(\"bwc.remote\").forUseAtConfigurationTime().orElse(\"elastic\");\n+\n+        TaskContainer tasks = project.getTasks();\n+        TaskProvider<LoggedExec> createCloneTaskProvider = tasks.register(\"createClone\", LoggedExec.class, createClone -> {\n+            createClone.onlyIf(task -> this.gitExtension.getCheckoutDir().get().exists() == false);\n+            createClone.setCommandLine(asList(\"git\", \"clone\", project.getRootDir(), gitExtension.getCheckoutDir().get()));\n+        });\n+\n+        TaskProvider<LoggedExec> findRemoteTaskProvider = tasks.register(\"findRemote\", LoggedExec.class, findRemote -> {\n+            findRemote.dependsOn(createCloneTaskProvider);\n+            // TODO Gradle should provide property based configuration here\n+            findRemote.setWorkingDir(gitExtension.getCheckoutDir().get());\n+\n+            findRemote.setCommandLine(asList(\"git\", \"remote\", \"-v\"));\n+            ByteArrayOutputStream output = new ByteArrayOutputStream();\n+            findRemote.setStandardOutput(output);\n+            findRemote.doLast(t -> {\n+                ExtraPropertiesExtension extraProperties = project.getExtensions().getExtraProperties();\n+                extraProperties.set(\"remoteExists\", isRemoteAvailable(remote, output));\n+            });\n+        });\n+\n+        TaskProvider<LoggedExec> addRemoteTaskProvider = tasks.register(\"addRemote\", LoggedExec.class, addRemote -> {\n+            addRemote.dependsOn(findRemoteTaskProvider);\n+            addRemote.onlyIf(task -> ((boolean) project.getExtensions().getExtraProperties().get(\"remoteExists\")) == false);\n+            addRemote.setWorkingDir(gitExtension.getCheckoutDir().get());\n+            String remoteRepo = remote.get();\n+            // for testing only we can override the base remote url\n+            String remoteRepoUrl = project.getProviders()\n+                .systemProperty(\"testRemoteRepo\")\n+                .forUseAtConfigurationTime()\n+                .getOrElse(\"https://github.com/\" + remoteRepo + \"/elasticsearch.git\");\n+            addRemote.setCommandLine(asList(\"git\", \"remote\", \"add\", remoteRepo, remoteRepoUrl));\n+        });\n+\n+        TaskProvider<LoggedExec> fetchLatestTaskProvider = tasks.register(\"fetchLatest\", LoggedExec.class, fetchLatest -> {\n+            var gitFetchLatest = project.getProviders()\n+                .systemProperty(\"tests.bwc.git_fetch_latest\")\n+                .forUseAtConfigurationTime()\n+                .orElse(\"true\")\n+                .map(fetchProp -> {\n+                    if (\"true\".equals(fetchProp)) {\n+                        return true;\n+                    }\n+                    if (\"false\".equals(fetchProp)) {\n+                        return false;\n+                    }\n+                    throw new GradleException(\"tests.bwc.git_fetch_latest must be [true] or [false] but was [\" + fetchProp + \"]\");\n+                });\n+            fetchLatest.onlyIf(t -> project.getGradle().getStartParameter().isOffline() == false && gitFetchLatest.get());\n+            fetchLatest.dependsOn(addRemoteTaskProvider);\n+            fetchLatest.setWorkingDir(gitExtension.getCheckoutDir().get());\n+            fetchLatest.setCommandLine(asList(\"git\", \"fetch\", \"--all\"));\n+        });\n+\n+        tasks.register(\"checkoutBwcBranch\", checkoutBwcBranch -> {\n+            checkoutBwcBranch.dependsOn(fetchLatestTaskProvider);\n+            checkoutBwcBranch.doLast(t -> {\n+                Logger logger = project.getLogger();\n+\n+                String bwcBranch = this.gitExtension.getBwcBranch().get();\n+                final String refspec = providers.systemProperty(\"bwc.refspec.\" + bwcBranch)\n+                    .orElse(providers.systemProperty(\"tests.bwc.refspec.\" + bwcBranch))\n+                    .getOrElse(remote.get() + \"/\" + bwcBranch);\n+\n+                String effectiveRefSpec = maybeAlignedRefSpec(project, logger, refspec);\n+\n+                logger.lifecycle(\"Performing checkout of {}...\", refspec);\n+                LoggedExec.exec(project, spec -> {\n+                    spec.workingDir(gitExtension.getCheckoutDir());\n+                    spec.commandLine(\"git\", \"checkout\", effectiveRefSpec);\n+                });\n+\n+                String checkoutHash = GlobalBuildInfoPlugin.gitInfo(gitExtension.getCheckoutDir().get()).getRevision();\n+                logger.lifecycle(\"Checkout hash for {} is {}\", project.getPath(), checkoutHash);\n+                writeFile(new File(project.getBuildDir(), \"refspec\"), checkoutHash);\n+            });\n+        });\n+    }\n+\n+    public BwcGitExtension getGitExtension() {\n+        return gitExtension;\n+    }\n+\n+    /**\n+     * We use a time based approach to make the bwc versions built deterministic and compatible with the current hash.\n+     * Most of the time we want to test against latest, but when running delayed exhaustive tests or wanting\n+     * reproducible builds we want this to be deterministic by using a hash that was the latest when the current\n+     * commit was made.\n+     * <p>\n+     * This approach doesn't work with merge commits as these can introduce commits in the chronological order\n+     * after the fact e.x. a merge done today can add commits dated with yesterday so the result will no longer be\n+     * deterministic.\n+     * <p>\n+     * We don't use merge commits, but for additional safety we check that no such commits exist in the time period\n+     * we are interested in.\n+     * <p>\n+     * Timestamps are at seconds resolution. rev-parse --before and --after are inclusive w.r.t the second\n+     * passed as input. This means the results might not be deterministic in the current second, but this\n+     * should not matter in practice.\n+     */\n+    private String maybeAlignedRefSpec(Project project, Logger logger, String defaultRefSpec) {\n+        if (project.getProviders().systemProperty(\"bwc.checkout.align\").isPresent() == false) {\n+            return defaultRefSpec;\n+        }\n+\n+        String timeOfCurrent = execGit(execSpec -> {\n+            execSpec.commandLine(asList(\"git\", \"show\", \"--no-patch\", \"--no-notes\", \"--pretty='%cD'\"));\n+            execSpec.workingDir(project.getRootDir());\n+        });\n+\n+        logger.lifecycle(\"Commit date of current: {}\", timeOfCurrent);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9df3ee594a24c357bbf8028a317b7596f6e10c85"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk0MjIzNg==", "bodyText": "We can just use Files.write:\nFiles.writeString(file.toPath(), content);", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r496942236", "createdAt": "2020-09-29T18:13:41Z", "author": {"login": "rjernst"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalBwcGitPlugin.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.LoggedExec;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.gradle.api.Action;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.logging.Logger;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n+import org.gradle.api.provider.Provider;\n+import org.gradle.api.provider.ProviderFactory;\n+import org.gradle.api.tasks.TaskContainer;\n+import org.gradle.api.tasks.TaskProvider;\n+import org.gradle.process.ExecResult;\n+import org.gradle.process.ExecSpec;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+\n+import static java.util.Arrays.asList;\n+\n+public class InternalBwcGitPlugin implements Plugin<Project> {\n+\n+    private BwcGitExtension gitExtension;\n+    private Project project;\n+\n+    @Override\n+    public void apply(Project project) {\n+        this.project = project;\n+        this.gitExtension = project.getExtensions().create(\"bwcGitConfig\", BwcGitExtension.class);\n+        ProviderFactory providers = project.getProviders();\n+        Provider<String> remote = project.getProviders().systemProperty(\"bwc.remote\").forUseAtConfigurationTime().orElse(\"elastic\");\n+\n+        TaskContainer tasks = project.getTasks();\n+        TaskProvider<LoggedExec> createCloneTaskProvider = tasks.register(\"createClone\", LoggedExec.class, createClone -> {\n+            createClone.onlyIf(task -> this.gitExtension.getCheckoutDir().get().exists() == false);\n+            createClone.setCommandLine(asList(\"git\", \"clone\", project.getRootDir(), gitExtension.getCheckoutDir().get()));\n+        });\n+\n+        TaskProvider<LoggedExec> findRemoteTaskProvider = tasks.register(\"findRemote\", LoggedExec.class, findRemote -> {\n+            findRemote.dependsOn(createCloneTaskProvider);\n+            // TODO Gradle should provide property based configuration here\n+            findRemote.setWorkingDir(gitExtension.getCheckoutDir().get());\n+\n+            findRemote.setCommandLine(asList(\"git\", \"remote\", \"-v\"));\n+            ByteArrayOutputStream output = new ByteArrayOutputStream();\n+            findRemote.setStandardOutput(output);\n+            findRemote.doLast(t -> {\n+                ExtraPropertiesExtension extraProperties = project.getExtensions().getExtraProperties();\n+                extraProperties.set(\"remoteExists\", isRemoteAvailable(remote, output));\n+            });\n+        });\n+\n+        TaskProvider<LoggedExec> addRemoteTaskProvider = tasks.register(\"addRemote\", LoggedExec.class, addRemote -> {\n+            addRemote.dependsOn(findRemoteTaskProvider);\n+            addRemote.onlyIf(task -> ((boolean) project.getExtensions().getExtraProperties().get(\"remoteExists\")) == false);\n+            addRemote.setWorkingDir(gitExtension.getCheckoutDir().get());\n+            String remoteRepo = remote.get();\n+            // for testing only we can override the base remote url\n+            String remoteRepoUrl = project.getProviders()\n+                .systemProperty(\"testRemoteRepo\")\n+                .forUseAtConfigurationTime()\n+                .getOrElse(\"https://github.com/\" + remoteRepo + \"/elasticsearch.git\");\n+            addRemote.setCommandLine(asList(\"git\", \"remote\", \"add\", remoteRepo, remoteRepoUrl));\n+        });\n+\n+        TaskProvider<LoggedExec> fetchLatestTaskProvider = tasks.register(\"fetchLatest\", LoggedExec.class, fetchLatest -> {\n+            var gitFetchLatest = project.getProviders()\n+                .systemProperty(\"tests.bwc.git_fetch_latest\")\n+                .forUseAtConfigurationTime()\n+                .orElse(\"true\")\n+                .map(fetchProp -> {\n+                    if (\"true\".equals(fetchProp)) {\n+                        return true;\n+                    }\n+                    if (\"false\".equals(fetchProp)) {\n+                        return false;\n+                    }\n+                    throw new GradleException(\"tests.bwc.git_fetch_latest must be [true] or [false] but was [\" + fetchProp + \"]\");\n+                });\n+            fetchLatest.onlyIf(t -> project.getGradle().getStartParameter().isOffline() == false && gitFetchLatest.get());\n+            fetchLatest.dependsOn(addRemoteTaskProvider);\n+            fetchLatest.setWorkingDir(gitExtension.getCheckoutDir().get());\n+            fetchLatest.setCommandLine(asList(\"git\", \"fetch\", \"--all\"));\n+        });\n+\n+        tasks.register(\"checkoutBwcBranch\", checkoutBwcBranch -> {\n+            checkoutBwcBranch.dependsOn(fetchLatestTaskProvider);\n+            checkoutBwcBranch.doLast(t -> {\n+                Logger logger = project.getLogger();\n+\n+                String bwcBranch = this.gitExtension.getBwcBranch().get();\n+                final String refspec = providers.systemProperty(\"bwc.refspec.\" + bwcBranch)\n+                    .orElse(providers.systemProperty(\"tests.bwc.refspec.\" + bwcBranch))\n+                    .getOrElse(remote.get() + \"/\" + bwcBranch);\n+\n+                String effectiveRefSpec = maybeAlignedRefSpec(project, logger, refspec);\n+\n+                logger.lifecycle(\"Performing checkout of {}...\", refspec);\n+                LoggedExec.exec(project, spec -> {\n+                    spec.workingDir(gitExtension.getCheckoutDir());\n+                    spec.commandLine(\"git\", \"checkout\", effectiveRefSpec);\n+                });\n+\n+                String checkoutHash = GlobalBuildInfoPlugin.gitInfo(gitExtension.getCheckoutDir().get()).getRevision();\n+                logger.lifecycle(\"Checkout hash for {} is {}\", project.getPath(), checkoutHash);\n+                writeFile(new File(project.getBuildDir(), \"refspec\"), checkoutHash);\n+            });\n+        });\n+    }\n+\n+    public BwcGitExtension getGitExtension() {\n+        return gitExtension;\n+    }\n+\n+    /**\n+     * We use a time based approach to make the bwc versions built deterministic and compatible with the current hash.\n+     * Most of the time we want to test against latest, but when running delayed exhaustive tests or wanting\n+     * reproducible builds we want this to be deterministic by using a hash that was the latest when the current\n+     * commit was made.\n+     * <p>\n+     * This approach doesn't work with merge commits as these can introduce commits in the chronological order\n+     * after the fact e.x. a merge done today can add commits dated with yesterday so the result will no longer be\n+     * deterministic.\n+     * <p>\n+     * We don't use merge commits, but for additional safety we check that no such commits exist in the time period\n+     * we are interested in.\n+     * <p>\n+     * Timestamps are at seconds resolution. rev-parse --before and --after are inclusive w.r.t the second\n+     * passed as input. This means the results might not be deterministic in the current second, but this\n+     * should not matter in practice.\n+     */\n+    private String maybeAlignedRefSpec(Project project, Logger logger, String defaultRefSpec) {\n+        if (project.getProviders().systemProperty(\"bwc.checkout.align\").isPresent() == false) {\n+            return defaultRefSpec;\n+        }\n+\n+        String timeOfCurrent = execGit(execSpec -> {\n+            execSpec.commandLine(asList(\"git\", \"show\", \"--no-patch\", \"--no-notes\", \"--pretty='%cD'\"));\n+            execSpec.workingDir(project.getRootDir());\n+        });\n+\n+        logger.lifecycle(\"Commit date of current: {}\", timeOfCurrent);\n+\n+        String mergeCommits = execGit(\n+            spec -> spec.commandLine(asList(\"git\", \"rev-list\", defaultRefSpec, \"--after\", timeOfCurrent, \"--merges\"))\n+        );\n+        if (mergeCommits.isEmpty() == false) {\n+            throw new IllegalStateException(\"Found the following merge commits which prevent determining bwc commits: \" + mergeCommits);\n+        }\n+        return execGit(\n+            spec -> spec.commandLine(asList(\"git\", \"rev-list\", defaultRefSpec, \"-n\", \"1\", \"--before\", timeOfCurrent, \"--date-order\"))\n+        );\n+    }\n+\n+    private void writeFile(File file, String content) {\n+        try {\n+            FileWriter myWriter = new FileWriter(file, false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9df3ee594a24c357bbf8028a317b7596f6e10c85"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk0Mjg0NA==", "bodyText": "Let's not swallow any exceptions. This should cause the build to fail. If we can't let it propagate as is, then wrap it with UncheckedIOException?", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r496942844", "createdAt": "2020-09-29T18:14:42Z", "author": {"login": "rjernst"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalBwcGitPlugin.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.LoggedExec;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.gradle.api.Action;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.logging.Logger;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n+import org.gradle.api.provider.Provider;\n+import org.gradle.api.provider.ProviderFactory;\n+import org.gradle.api.tasks.TaskContainer;\n+import org.gradle.api.tasks.TaskProvider;\n+import org.gradle.process.ExecResult;\n+import org.gradle.process.ExecSpec;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+\n+import static java.util.Arrays.asList;\n+\n+public class InternalBwcGitPlugin implements Plugin<Project> {\n+\n+    private BwcGitExtension gitExtension;\n+    private Project project;\n+\n+    @Override\n+    public void apply(Project project) {\n+        this.project = project;\n+        this.gitExtension = project.getExtensions().create(\"bwcGitConfig\", BwcGitExtension.class);\n+        ProviderFactory providers = project.getProviders();\n+        Provider<String> remote = project.getProviders().systemProperty(\"bwc.remote\").forUseAtConfigurationTime().orElse(\"elastic\");\n+\n+        TaskContainer tasks = project.getTasks();\n+        TaskProvider<LoggedExec> createCloneTaskProvider = tasks.register(\"createClone\", LoggedExec.class, createClone -> {\n+            createClone.onlyIf(task -> this.gitExtension.getCheckoutDir().get().exists() == false);\n+            createClone.setCommandLine(asList(\"git\", \"clone\", project.getRootDir(), gitExtension.getCheckoutDir().get()));\n+        });\n+\n+        TaskProvider<LoggedExec> findRemoteTaskProvider = tasks.register(\"findRemote\", LoggedExec.class, findRemote -> {\n+            findRemote.dependsOn(createCloneTaskProvider);\n+            // TODO Gradle should provide property based configuration here\n+            findRemote.setWorkingDir(gitExtension.getCheckoutDir().get());\n+\n+            findRemote.setCommandLine(asList(\"git\", \"remote\", \"-v\"));\n+            ByteArrayOutputStream output = new ByteArrayOutputStream();\n+            findRemote.setStandardOutput(output);\n+            findRemote.doLast(t -> {\n+                ExtraPropertiesExtension extraProperties = project.getExtensions().getExtraProperties();\n+                extraProperties.set(\"remoteExists\", isRemoteAvailable(remote, output));\n+            });\n+        });\n+\n+        TaskProvider<LoggedExec> addRemoteTaskProvider = tasks.register(\"addRemote\", LoggedExec.class, addRemote -> {\n+            addRemote.dependsOn(findRemoteTaskProvider);\n+            addRemote.onlyIf(task -> ((boolean) project.getExtensions().getExtraProperties().get(\"remoteExists\")) == false);\n+            addRemote.setWorkingDir(gitExtension.getCheckoutDir().get());\n+            String remoteRepo = remote.get();\n+            // for testing only we can override the base remote url\n+            String remoteRepoUrl = project.getProviders()\n+                .systemProperty(\"testRemoteRepo\")\n+                .forUseAtConfigurationTime()\n+                .getOrElse(\"https://github.com/\" + remoteRepo + \"/elasticsearch.git\");\n+            addRemote.setCommandLine(asList(\"git\", \"remote\", \"add\", remoteRepo, remoteRepoUrl));\n+        });\n+\n+        TaskProvider<LoggedExec> fetchLatestTaskProvider = tasks.register(\"fetchLatest\", LoggedExec.class, fetchLatest -> {\n+            var gitFetchLatest = project.getProviders()\n+                .systemProperty(\"tests.bwc.git_fetch_latest\")\n+                .forUseAtConfigurationTime()\n+                .orElse(\"true\")\n+                .map(fetchProp -> {\n+                    if (\"true\".equals(fetchProp)) {\n+                        return true;\n+                    }\n+                    if (\"false\".equals(fetchProp)) {\n+                        return false;\n+                    }\n+                    throw new GradleException(\"tests.bwc.git_fetch_latest must be [true] or [false] but was [\" + fetchProp + \"]\");\n+                });\n+            fetchLatest.onlyIf(t -> project.getGradle().getStartParameter().isOffline() == false && gitFetchLatest.get());\n+            fetchLatest.dependsOn(addRemoteTaskProvider);\n+            fetchLatest.setWorkingDir(gitExtension.getCheckoutDir().get());\n+            fetchLatest.setCommandLine(asList(\"git\", \"fetch\", \"--all\"));\n+        });\n+\n+        tasks.register(\"checkoutBwcBranch\", checkoutBwcBranch -> {\n+            checkoutBwcBranch.dependsOn(fetchLatestTaskProvider);\n+            checkoutBwcBranch.doLast(t -> {\n+                Logger logger = project.getLogger();\n+\n+                String bwcBranch = this.gitExtension.getBwcBranch().get();\n+                final String refspec = providers.systemProperty(\"bwc.refspec.\" + bwcBranch)\n+                    .orElse(providers.systemProperty(\"tests.bwc.refspec.\" + bwcBranch))\n+                    .getOrElse(remote.get() + \"/\" + bwcBranch);\n+\n+                String effectiveRefSpec = maybeAlignedRefSpec(project, logger, refspec);\n+\n+                logger.lifecycle(\"Performing checkout of {}...\", refspec);\n+                LoggedExec.exec(project, spec -> {\n+                    spec.workingDir(gitExtension.getCheckoutDir());\n+                    spec.commandLine(\"git\", \"checkout\", effectiveRefSpec);\n+                });\n+\n+                String checkoutHash = GlobalBuildInfoPlugin.gitInfo(gitExtension.getCheckoutDir().get()).getRevision();\n+                logger.lifecycle(\"Checkout hash for {} is {}\", project.getPath(), checkoutHash);\n+                writeFile(new File(project.getBuildDir(), \"refspec\"), checkoutHash);\n+            });\n+        });\n+    }\n+\n+    public BwcGitExtension getGitExtension() {\n+        return gitExtension;\n+    }\n+\n+    /**\n+     * We use a time based approach to make the bwc versions built deterministic and compatible with the current hash.\n+     * Most of the time we want to test against latest, but when running delayed exhaustive tests or wanting\n+     * reproducible builds we want this to be deterministic by using a hash that was the latest when the current\n+     * commit was made.\n+     * <p>\n+     * This approach doesn't work with merge commits as these can introduce commits in the chronological order\n+     * after the fact e.x. a merge done today can add commits dated with yesterday so the result will no longer be\n+     * deterministic.\n+     * <p>\n+     * We don't use merge commits, but for additional safety we check that no such commits exist in the time period\n+     * we are interested in.\n+     * <p>\n+     * Timestamps are at seconds resolution. rev-parse --before and --after are inclusive w.r.t the second\n+     * passed as input. This means the results might not be deterministic in the current second, but this\n+     * should not matter in practice.\n+     */\n+    private String maybeAlignedRefSpec(Project project, Logger logger, String defaultRefSpec) {\n+        if (project.getProviders().systemProperty(\"bwc.checkout.align\").isPresent() == false) {\n+            return defaultRefSpec;\n+        }\n+\n+        String timeOfCurrent = execGit(execSpec -> {\n+            execSpec.commandLine(asList(\"git\", \"show\", \"--no-patch\", \"--no-notes\", \"--pretty='%cD'\"));\n+            execSpec.workingDir(project.getRootDir());\n+        });\n+\n+        logger.lifecycle(\"Commit date of current: {}\", timeOfCurrent);\n+\n+        String mergeCommits = execGit(\n+            spec -> spec.commandLine(asList(\"git\", \"rev-list\", defaultRefSpec, \"--after\", timeOfCurrent, \"--merges\"))\n+        );\n+        if (mergeCommits.isEmpty() == false) {\n+            throw new IllegalStateException(\"Found the following merge commits which prevent determining bwc commits: \" + mergeCommits);\n+        }\n+        return execGit(\n+            spec -> spec.commandLine(asList(\"git\", \"rev-list\", defaultRefSpec, \"-n\", \"1\", \"--before\", timeOfCurrent, \"--date-order\"))\n+        );\n+    }\n+\n+    private void writeFile(File file, String content) {\n+        try {\n+            FileWriter myWriter = new FileWriter(file, false);\n+            myWriter.write(content);\n+            myWriter.close();\n+        } catch (IOException e) {\n+            e.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9df3ee594a24c357bbf8028a317b7596f6e10c85"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk0MzUyMQ==", "bodyText": "If we need a git specific method, then the spec should set the executable to git? Otherwise how is this different than just a generic exec helper?", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r496943521", "createdAt": "2020-09-29T18:15:51Z", "author": {"login": "rjernst"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalBwcGitPlugin.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.LoggedExec;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.gradle.api.Action;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.logging.Logger;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n+import org.gradle.api.provider.Provider;\n+import org.gradle.api.provider.ProviderFactory;\n+import org.gradle.api.tasks.TaskContainer;\n+import org.gradle.api.tasks.TaskProvider;\n+import org.gradle.process.ExecResult;\n+import org.gradle.process.ExecSpec;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+\n+import static java.util.Arrays.asList;\n+\n+public class InternalBwcGitPlugin implements Plugin<Project> {\n+\n+    private BwcGitExtension gitExtension;\n+    private Project project;\n+\n+    @Override\n+    public void apply(Project project) {\n+        this.project = project;\n+        this.gitExtension = project.getExtensions().create(\"bwcGitConfig\", BwcGitExtension.class);\n+        ProviderFactory providers = project.getProviders();\n+        Provider<String> remote = project.getProviders().systemProperty(\"bwc.remote\").forUseAtConfigurationTime().orElse(\"elastic\");\n+\n+        TaskContainer tasks = project.getTasks();\n+        TaskProvider<LoggedExec> createCloneTaskProvider = tasks.register(\"createClone\", LoggedExec.class, createClone -> {\n+            createClone.onlyIf(task -> this.gitExtension.getCheckoutDir().get().exists() == false);\n+            createClone.setCommandLine(asList(\"git\", \"clone\", project.getRootDir(), gitExtension.getCheckoutDir().get()));\n+        });\n+\n+        TaskProvider<LoggedExec> findRemoteTaskProvider = tasks.register(\"findRemote\", LoggedExec.class, findRemote -> {\n+            findRemote.dependsOn(createCloneTaskProvider);\n+            // TODO Gradle should provide property based configuration here\n+            findRemote.setWorkingDir(gitExtension.getCheckoutDir().get());\n+\n+            findRemote.setCommandLine(asList(\"git\", \"remote\", \"-v\"));\n+            ByteArrayOutputStream output = new ByteArrayOutputStream();\n+            findRemote.setStandardOutput(output);\n+            findRemote.doLast(t -> {\n+                ExtraPropertiesExtension extraProperties = project.getExtensions().getExtraProperties();\n+                extraProperties.set(\"remoteExists\", isRemoteAvailable(remote, output));\n+            });\n+        });\n+\n+        TaskProvider<LoggedExec> addRemoteTaskProvider = tasks.register(\"addRemote\", LoggedExec.class, addRemote -> {\n+            addRemote.dependsOn(findRemoteTaskProvider);\n+            addRemote.onlyIf(task -> ((boolean) project.getExtensions().getExtraProperties().get(\"remoteExists\")) == false);\n+            addRemote.setWorkingDir(gitExtension.getCheckoutDir().get());\n+            String remoteRepo = remote.get();\n+            // for testing only we can override the base remote url\n+            String remoteRepoUrl = project.getProviders()\n+                .systemProperty(\"testRemoteRepo\")\n+                .forUseAtConfigurationTime()\n+                .getOrElse(\"https://github.com/\" + remoteRepo + \"/elasticsearch.git\");\n+            addRemote.setCommandLine(asList(\"git\", \"remote\", \"add\", remoteRepo, remoteRepoUrl));\n+        });\n+\n+        TaskProvider<LoggedExec> fetchLatestTaskProvider = tasks.register(\"fetchLatest\", LoggedExec.class, fetchLatest -> {\n+            var gitFetchLatest = project.getProviders()\n+                .systemProperty(\"tests.bwc.git_fetch_latest\")\n+                .forUseAtConfigurationTime()\n+                .orElse(\"true\")\n+                .map(fetchProp -> {\n+                    if (\"true\".equals(fetchProp)) {\n+                        return true;\n+                    }\n+                    if (\"false\".equals(fetchProp)) {\n+                        return false;\n+                    }\n+                    throw new GradleException(\"tests.bwc.git_fetch_latest must be [true] or [false] but was [\" + fetchProp + \"]\");\n+                });\n+            fetchLatest.onlyIf(t -> project.getGradle().getStartParameter().isOffline() == false && gitFetchLatest.get());\n+            fetchLatest.dependsOn(addRemoteTaskProvider);\n+            fetchLatest.setWorkingDir(gitExtension.getCheckoutDir().get());\n+            fetchLatest.setCommandLine(asList(\"git\", \"fetch\", \"--all\"));\n+        });\n+\n+        tasks.register(\"checkoutBwcBranch\", checkoutBwcBranch -> {\n+            checkoutBwcBranch.dependsOn(fetchLatestTaskProvider);\n+            checkoutBwcBranch.doLast(t -> {\n+                Logger logger = project.getLogger();\n+\n+                String bwcBranch = this.gitExtension.getBwcBranch().get();\n+                final String refspec = providers.systemProperty(\"bwc.refspec.\" + bwcBranch)\n+                    .orElse(providers.systemProperty(\"tests.bwc.refspec.\" + bwcBranch))\n+                    .getOrElse(remote.get() + \"/\" + bwcBranch);\n+\n+                String effectiveRefSpec = maybeAlignedRefSpec(project, logger, refspec);\n+\n+                logger.lifecycle(\"Performing checkout of {}...\", refspec);\n+                LoggedExec.exec(project, spec -> {\n+                    spec.workingDir(gitExtension.getCheckoutDir());\n+                    spec.commandLine(\"git\", \"checkout\", effectiveRefSpec);\n+                });\n+\n+                String checkoutHash = GlobalBuildInfoPlugin.gitInfo(gitExtension.getCheckoutDir().get()).getRevision();\n+                logger.lifecycle(\"Checkout hash for {} is {}\", project.getPath(), checkoutHash);\n+                writeFile(new File(project.getBuildDir(), \"refspec\"), checkoutHash);\n+            });\n+        });\n+    }\n+\n+    public BwcGitExtension getGitExtension() {\n+        return gitExtension;\n+    }\n+\n+    /**\n+     * We use a time based approach to make the bwc versions built deterministic and compatible with the current hash.\n+     * Most of the time we want to test against latest, but when running delayed exhaustive tests or wanting\n+     * reproducible builds we want this to be deterministic by using a hash that was the latest when the current\n+     * commit was made.\n+     * <p>\n+     * This approach doesn't work with merge commits as these can introduce commits in the chronological order\n+     * after the fact e.x. a merge done today can add commits dated with yesterday so the result will no longer be\n+     * deterministic.\n+     * <p>\n+     * We don't use merge commits, but for additional safety we check that no such commits exist in the time period\n+     * we are interested in.\n+     * <p>\n+     * Timestamps are at seconds resolution. rev-parse --before and --after are inclusive w.r.t the second\n+     * passed as input. This means the results might not be deterministic in the current second, but this\n+     * should not matter in practice.\n+     */\n+    private String maybeAlignedRefSpec(Project project, Logger logger, String defaultRefSpec) {\n+        if (project.getProviders().systemProperty(\"bwc.checkout.align\").isPresent() == false) {\n+            return defaultRefSpec;\n+        }\n+\n+        String timeOfCurrent = execGit(execSpec -> {\n+            execSpec.commandLine(asList(\"git\", \"show\", \"--no-patch\", \"--no-notes\", \"--pretty='%cD'\"));\n+            execSpec.workingDir(project.getRootDir());\n+        });\n+\n+        logger.lifecycle(\"Commit date of current: {}\", timeOfCurrent);\n+\n+        String mergeCommits = execGit(\n+            spec -> spec.commandLine(asList(\"git\", \"rev-list\", defaultRefSpec, \"--after\", timeOfCurrent, \"--merges\"))\n+        );\n+        if (mergeCommits.isEmpty() == false) {\n+            throw new IllegalStateException(\"Found the following merge commits which prevent determining bwc commits: \" + mergeCommits);\n+        }\n+        return execGit(\n+            spec -> spec.commandLine(asList(\"git\", \"rev-list\", defaultRefSpec, \"-n\", \"1\", \"--before\", timeOfCurrent, \"--date-order\"))\n+        );\n+    }\n+\n+    private void writeFile(File file, String content) {\n+        try {\n+            FileWriter myWriter = new FileWriter(file, false);\n+            myWriter.write(content);\n+            myWriter.close();\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    private String execGit(Action<ExecSpec> execSpecConfig) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9df3ee594a24c357bbf8028a317b7596f6e10c85"}, "originalPosition": 188}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk0MzkzNw==", "bodyText": "nit: These -> these", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r496943937", "createdAt": "2020-09-29T18:16:35Z", "author": {"login": "rjernst"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionBwcSetupPlugin.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.BwcVersions;\n+import org.elasticsearch.gradle.Version;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.gradle.api.InvalidUserDataException;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.Task;\n+import org.gradle.api.provider.Provider;\n+import org.gradle.api.tasks.TaskProvider;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Arrays.stream;\n+\n+/**\n+ * We want to be able to do BWC tests for unreleased versions without relying on and waiting for snapshots.\n+ * For this we need to check out and build the unreleased versions.\n+ * Since These depend on the current version, we can't name the Gradle projects statically, and don't know what the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9df3ee594a24c357bbf8028a317b7596f6e10c85"}, "originalPosition": 46}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk4ODkzOTEw", "url": "https://github.com/elastic/elasticsearch/pull/62473#pullrequestreview-498893910", "createdAt": "2020-09-29T21:08:04Z", "commit": {"oid": "9df3ee594a24c357bbf8028a317b7596f6e10c85"}, "state": "APPROVED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQyMTowODowNFrOHaCKuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQyMjowMDowNFrOHaDsmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA2MDUzNw==", "bodyText": "Why do we now hard-code this vs relying on BuildParams.bwcVersions? The list of \"unreleased\" projects is dynamic and changes based on where we are at in the stack release process. For example the :staged bwc project is only \"active\" when we have branched for a new minor release but have not gone GA yet. I believe with this change we would never resolve dependencies from that branch, and therefore our CI images would be slightly more out of date than necessary.", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497060537", "createdAt": "2020-09-29T21:08:04Z", "author": {"login": "mark-vieira"}, "path": "distribution/bwc/build.gradle", "diffHunk": "@@ -17,345 +17,20 @@\n  * under the License.\n  */\n \n-import org.apache.tools.ant.taskdefs.condition.Os\n-import org.elasticsearch.gradle.LoggedExec\n-import org.elasticsearch.gradle.Version\n-import org.elasticsearch.gradle.BwcVersions\n-import org.elasticsearch.gradle.info.BuildParams\n-import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin\n-import org.gradle.util.GradleVersion\n-\n-import java.nio.charset.StandardCharsets\n-\n-import static org.elasticsearch.gradle.util.JavaUtil.getJavaHome\n-\n-/**\n- *  We want to be able to do BWC tests for unreleased versions without relying on and waiting for snapshots.\n- *  For this we need to check out and build the unreleased versions.\n- *  Since These depend on the current version, we can't name the Gradle projects statically, and don't know what the\n- *  unreleased versions are when Gradle projects are set up, so we use \"build-unreleased-version-*\" as placeholders\n- *  and configure them to build various versions here.\n- */\n-BuildParams.bwcVersions.forPreviousUnreleased { BwcVersions.UnreleasedVersionInfo unreleasedVersion ->\n-  project(\"${unreleasedVersion.gradleProjectPath}\") {\n-    Version bwcVersion = unreleasedVersion.version\n-    String bwcBranch = unreleasedVersion.branch\n-    apply plugin: 'distribution'\n-    // Not published so no need to assemble\n-    tasks.named(\"assemble\").configure {\n-      enabled = false\n-    }\n-    File checkoutDir = file(\"${buildDir}/bwc/checkout-${bwcBranch}\")\n-\n-    final String remote = System.getProperty(\"bwc.remote\", \"elastic\")\n-\n-    boolean gitFetchLatest\n-    final String gitFetchLatestProperty = System.getProperty(\"tests.bwc.git_fetch_latest\", \"true\")\n-    if (\"true\".equals(gitFetchLatestProperty)) {\n-      gitFetchLatest = true\n-    } else if (\"false\".equals(gitFetchLatestProperty)) {\n-      gitFetchLatest = false\n-    } else {\n-      throw new GradleException(\"tests.bwc.git_fetch_latest must be [true] or [false] but was [\" + gitFetchLatestProperty + \"]\")\n-    }\n-\n-    tasks.register(\"createClone\", LoggedExec) {\n-      onlyIf { checkoutDir.exists() == false }\n-      commandLine = ['git', 'clone', rootDir, checkoutDir]\n-    }\n-\n-    tasks.register(\"findRemote\", LoggedExec) {\n-      dependsOn \"createClone\"\n-      workingDir = checkoutDir\n-      commandLine = ['git', 'remote', '-v']\n-      ByteArrayOutputStream output = new ByteArrayOutputStream()\n-      standardOutput = output\n-      doLast {\n-        project.ext.remoteExists = false\n-        output.toString('UTF-8').eachLine {\n-          if (it.contains(\"${remote}\\t\")) {\n-            project.ext.remoteExists = true\n-          }\n-        }\n-      }\n-    }\n-\n-    tasks.register(\"addRemote\", LoggedExec) {\n-      dependsOn findRemote\n-      onlyIf { project.ext.remoteExists == false }\n-      workingDir = checkoutDir\n-      commandLine = ['git', 'remote', 'add', \"${remote}\", \"https://github.com/${remote}/elasticsearch.git\"]\n-    }\n-\n-    tasks.register(\"fetchLatest\", LoggedExec) {\n-      onlyIf { project.gradle.startParameter.isOffline() == false && gitFetchLatest }\n-      dependsOn(\"addRemote\")\n-      workingDir = checkoutDir\n-      commandLine = ['git', 'fetch', '--all']\n-    }\n-\n-    Closure execGit = { Action<ExecSpec> action ->\n-      new ByteArrayOutputStream().withStream { os ->\n-        ExecResult result = project.exec { spec ->\n-          workingDir = checkoutDir\n-          standardOutput os\n-          action.execute(spec)\n-        }\n-        result.assertNormalExitValue()\n-        return os.toString().trim()\n-      }\n-    }\n-    tasks.register(\"checkoutBwcBranch\") {\n-      dependsOn(\"fetchLatest\")\n-      doLast {\n-        def refspec = System.getProperty(\"bwc.refspec.\" + bwcBranch) ?: System.getProperty(\"tests.bwc.refspec.\" + bwcBranch) ?: \"${remote}/${bwcBranch}\"\n-        if (System.getProperty(\"bwc.checkout.align\") != null) {\n-          /*\n-              We use a time based approach to make the bwc versions built deterministic and compatible with the current hash.\n-              Most of the time we want to test against latest, but when running delayed exhaustive tests or wanting\n-              reproducible builds we want this to be deterministic by using a hash that was the latest when the current\n-              commit was made.\n-\n-              This approach doesn't work with merge commits as these can introduce commits in the chronological order\n-              after the fact e.x. a merge done today can add commits dated with yesterday so the result will no longer be\n-              deterministic.\n-\n-              We don't use merge commits, but for additional safety we check that no such commits exist in the time period\n-              we are interested in.\n-\n-              Timestamps are at seconds resolution. rev-parse --before and --after are inclusive w.r.t the second\n-              passed as input. This means the results might not be deterministic in the current second, but this\n-              should not matter in practice.\n-          */\n-          String timeOfCurrent = execGit { spec ->\n-            spec.commandLine 'git', 'show', '--no-patch', '--no-notes', \"--pretty='%cD'\"\n-            spec.workingDir project.rootDir\n-          }\n-          logger.lifecycle(\"Commit date of current: {}\", timeOfCurrent)\n-          String mergeCommits = execGit { spec ->\n-            spec.commandLine \"git\", \"rev-list\", refspec, \"--after\", timeOfCurrent, \"--merges\"\n-          }\n-          if (mergeCommits.isEmpty() == false) {\n-            throw new IllegalStateException(\n-              \"Found the following merge commits which prevent determining bwc commits: \" + mergeCommits\n-            )\n-          }\n-          refspec = execGit { spec ->\n-            spec.commandLine \"git\", \"rev-list\", refspec, \"-n\", \"1\", \"--before\", timeOfCurrent, \"--date-order\"\n-          }\n-        }\n-\n-        logger.lifecycle(\"Performing checkout of ${refspec}...\")\n-        LoggedExec.exec(project) { spec ->\n-          spec.workingDir = checkoutDir\n-          spec.commandLine \"git\", \"checkout\", refspec\n-        }\n-        String checkoutHash = GlobalBuildInfoPlugin.gitInfo(checkoutDir).revision\n-        logger.lifecycle(\"Checkout hash for ${project.path} is ${checkoutHash}\")\n-        file(\"${project.buildDir}/refspec\").text = checkoutHash\n-      }\n-    }\n-\n-\n-    Closure<TaskProvider> createRunBwcGradleTask = { name, extraConfig ->\n-      return tasks.register(\"$name\", LoggedExec) {\n-        dependsOn \"checkoutBwcBranch\"\n-        spoolOutput = true\n-        workingDir = checkoutDir\n-        doFirst {\n-          // Execution time so that the checkouts are available\n-          List<String> lines = file(\"${checkoutDir}/.ci/java-versions.properties\").readLines()\n-          environment(\n-            'JAVA_HOME',\n-            getJavaHome(Integer.parseInt(\n-              lines\n-                .findAll({ it.startsWith(\"ES_BUILD_JAVA=\") })\n-                .collect({ it.replace(\"ES_BUILD_JAVA=java\", \"\").trim() })\n-                .collect({ it.replace(\"ES_BUILD_JAVA=openjdk\", \"\").trim() })\n-                .join(\"!!\")\n-            ))\n-          )\n-          environment(\n-            'RUNTIME_JAVA_HOME',\n-            getJavaHome(Integer.parseInt(\n-              lines\n-                .findAll({ it.startsWith(\"ES_RUNTIME_JAVA=java\") })\n-                .collect({ it.replace(\"ES_RUNTIME_JAVA=java\", \"\").trim() })\n-                .join(\"!!\")\n-            ))\n-          )\n-        }\n-\n-        if (Os.isFamily(Os.FAMILY_WINDOWS)) {\n-          executable 'cmd'\n-          args '/C', 'call', new File(checkoutDir, 'gradlew').toString()\n-        } else {\n-          executable new File(checkoutDir, 'gradlew').toString()\n-        }\n-        if (gradle.startParameter.isOffline()) {\n-          args \"--offline\"\n-        }\n-        String buildCacheUrl = System.getProperty('org.elasticsearch.build.cache.url')\n-        if (buildCacheUrl) {\n-          args \"-Dorg.elasticsearch.build.cache.url=${buildCacheUrl}\"\n-        }\n-\n-        args \"-Dbuild.snapshot=true\"\n-        args \"-Dscan.tag.NESTED\"\n-        final LogLevel logLevel = gradle.startParameter.logLevel\n-        if ([LogLevel.QUIET, LogLevel.WARN, LogLevel.INFO, LogLevel.DEBUG].contains(logLevel)) {\n-          args \"--${logLevel.name().toLowerCase(Locale.ENGLISH)}\"\n-        }\n-        final String showStacktraceName = gradle.startParameter.showStacktrace.name()\n-        assert [\"INTERNAL_EXCEPTIONS\", \"ALWAYS\", \"ALWAYS_FULL\"].contains(showStacktraceName)\n-        if (showStacktraceName.equals(\"ALWAYS\")) {\n-          args \"--stacktrace\"\n-        } else if (showStacktraceName.equals(\"ALWAYS_FULL\")) {\n-          args \"--full-stacktrace\"\n-        }\n-        if (gradle.getStartParameter().isParallelProjectExecutionEnabled()) {\n-          args \"--parallel\"\n-        }\n-        standardOutput = new IndentingOutputStream(System.out, bwcVersion)\n-        errorOutput = new IndentingOutputStream(System.err, bwcVersion)\n-        configure extraConfig\n-      }\n-    }\n-\n-    Closure buildBwcTaskName = { projectName ->\n-      return \"buildBwc${projectName.replaceAll(/-\\w/) { it[1].toUpperCase() }.capitalize()}\"\n-    }\n-\n-    def buildBwc = tasks.register(\"buildBwc\");\n-\n-    Closure createBuildBwcTask = { projectName, projectDir, projectArtifact ->\n-      def bwcTaskName = buildBwcTaskName(projectName)\n-      createRunBwcGradleTask(bwcTaskName) {\n-        inputs.file(\"${project.buildDir}/refspec\")\n-        outputs.files(projectArtifact)\n-        outputs.cacheIf(\"BWC distribution caching is disabled on 'master' branch\") {\n-          // Don't bother caching in 'master' since the BWC branches move too quickly to make this cost worthwhile\n-          BuildParams.ci && System.getenv('GIT_BRANCH')?.endsWith(\"master\") == false\n-        }\n-        args \":${projectDir.replace('/', ':')}:assemble\"\n-        if (project.gradle.startParameter.buildCacheEnabled) {\n-          args \"--build-cache\"\n-        }\n-        doLast {\n-          if (projectArtifact.exists() == false) {\n-            throw new InvalidUserDataException(\"Building ${bwcVersion} didn't generate expected file ${projectArtifact}\")\n-          }\n-        }\n-      }\n-      buildBwc.configure {\n-        dependsOn(bwcTaskName)\n-      }\n-    }\n+apply plugin:\"elasticsearch.internal-distribution-bwc-setup\"\n \n-    Map<String, File> artifactFiles = [:]\n-    List<String> projectDirs = []\n-    List<String> projects = ['deb', 'rpm']\n-    if (bwcVersion.onOrAfter('7.0.0')) {\n-      projects.addAll(['windows-zip', 'darwin-tar', 'linux-tar'])\n-    } else {\n-      projects.add('zip')\n-    }\n-\n-    for (String projectName : projects) {\n-      String baseDir = \"distribution\"\n-      String classifier = \"\"\n-      String extension = projectName\n-      if (bwcVersion.onOrAfter('7.0.0') && (projectName.contains('zip') || projectName.contains('tar'))) {\n-        int index = projectName.indexOf('-')\n-        classifier = \"-${projectName.substring(0, index)}-x86_64\"\n-        extension = projectName.substring(index + 1)\n-        if (extension.equals('tar')) {\n-          extension += '.gz'\n-        }\n-      }\n-      if (bwcVersion.onOrAfter('7.0.0') && projectName.contains('deb')) {\n-        classifier = \"-amd64\"\n-      }\n-      if (bwcVersion.onOrAfter('7.0.0') && projectName.contains('rpm')) {\n-        classifier = \"-x86_64\"\n-      }\n-      if (bwcVersion.onOrAfter('6.3.0')) {\n-        baseDir += projectName.endsWith('zip') || projectName.endsWith('tar') ? '/archives' : '/packages'\n-        // add oss variant first\n-        projectDirs.add(\"${baseDir}/oss-${projectName}\")\n-        File ossProjectArtifact = file(\"${checkoutDir}/${baseDir}/oss-${projectName}/build/distributions/elasticsearch-oss-${bwcVersion}-SNAPSHOT${classifier}.${extension}\")\n-        artifactFiles.put(\"oss-\" + projectName, ossProjectArtifact)\n-        createBuildBwcTask(\"oss-${projectName}\", \"${baseDir}/oss-${projectName}\", ossProjectArtifact)\n-      }\n-      projectDirs.add(\"${baseDir}/${projectName}\")\n-      File projectArtifact = file(\"${checkoutDir}/${baseDir}/${projectName}/build/distributions/elasticsearch-${bwcVersion}-SNAPSHOT${classifier}.${extension}\")\n-      artifactFiles.put(projectName, projectArtifact)\n-\n-      createBuildBwcTask(projectName, \"${baseDir}/${projectName}\", projectArtifact)\n-    }\n-\n-    // Create build tasks for the JDBC driver used for compatibility testing\n-    String jdbcProjectDir = 'x-pack/plugin/sql/jdbc'\n-    File jdbcProjectArtifact = file(\"${checkoutDir}/${jdbcProjectDir}/build/distributions/x-pack-sql-jdbc-${bwcVersion}-SNAPSHOT.jar\")\n-    createBuildBwcTask('jdbc', jdbcProjectDir, jdbcProjectArtifact)\n+import org.elasticsearch.gradle.Version\n \n-    createRunBwcGradleTask(\"resolveAllBwcDependencies\") {\n-      args 'resolveAllDependencies'\n+[project(\"minor\"), project(\"bugfix\")].each { bwcProject ->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9df3ee594a24c357bbf8028a317b7596f6e10c85"}, "originalPosition": 290}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA2MzczMA==", "bodyText": "Will this go away when these changes are backported?", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497063730", "createdAt": "2020-09-29T21:14:40Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionDownloadPlugin.java", "diffHunk": "@@ -94,14 +94,22 @@ private void registerInternalDistributionResolutions(NamedDomainObjectContainer<\n                             + \"without a bundled JDK is not supported.\"\n                     );\n                 }\n+                String distributionProjectName = distributionProjectName(distribution);\n+                String projectConfig = getProjectConfig(distributionProjectName, unreleasedInfo);\n                 return new ProjectBasedDistributionDependency(\n-                    (config) -> projectDependency(project, unreleasedInfo.gradleProjectPath, distributionProjectName(distribution))\n+                    (config) -> projectDependency(project, unreleasedInfo.gradleProjectPath, projectConfig)\n                 );\n             }\n             return null;\n         }));\n     }\n \n+    private static String getProjectConfig(String distributionProjectName, BwcVersions.UnreleasedVersionInfo info) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9df3ee594a24c357bbf8028a317b7596f6e10c85"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA2NDg5OA==", "bodyText": "Can't this be injected as a constructor arg?", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497064898", "createdAt": "2020-09-29T21:17:02Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalBwcGitPlugin.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.LoggedExec;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.gradle.api.Action;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.logging.Logger;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n+import org.gradle.api.provider.Provider;\n+import org.gradle.api.provider.ProviderFactory;\n+import org.gradle.api.tasks.TaskContainer;\n+import org.gradle.api.tasks.TaskProvider;\n+import org.gradle.process.ExecResult;\n+import org.gradle.process.ExecSpec;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+\n+import static java.util.Arrays.asList;\n+\n+public class InternalBwcGitPlugin implements Plugin<Project> {\n+\n+    private BwcGitExtension gitExtension;\n+    private Project project;\n+\n+    @Override\n+    public void apply(Project project) {\n+        this.project = project;\n+        this.gitExtension = project.getExtensions().create(\"bwcGitConfig\", BwcGitExtension.class);\n+        ProviderFactory providers = project.getProviders();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9df3ee594a24c357bbf8028a317b7596f6e10c85"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA2NzAzMw==", "bodyText": "Does this only technically \"work\" since we are lazily configuring these tasks?", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497067033", "createdAt": "2020-09-29T21:21:10Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalBwcGitPlugin.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.LoggedExec;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.gradle.api.Action;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.logging.Logger;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n+import org.gradle.api.provider.Provider;\n+import org.gradle.api.provider.ProviderFactory;\n+import org.gradle.api.tasks.TaskContainer;\n+import org.gradle.api.tasks.TaskProvider;\n+import org.gradle.process.ExecResult;\n+import org.gradle.process.ExecSpec;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+\n+import static java.util.Arrays.asList;\n+\n+public class InternalBwcGitPlugin implements Plugin<Project> {\n+\n+    private BwcGitExtension gitExtension;\n+    private Project project;\n+\n+    @Override\n+    public void apply(Project project) {\n+        this.project = project;\n+        this.gitExtension = project.getExtensions().create(\"bwcGitConfig\", BwcGitExtension.class);\n+        ProviderFactory providers = project.getProviders();\n+        Provider<String> remote = project.getProviders().systemProperty(\"bwc.remote\").forUseAtConfigurationTime().orElse(\"elastic\");\n+\n+        TaskContainer tasks = project.getTasks();\n+        TaskProvider<LoggedExec> createCloneTaskProvider = tasks.register(\"createClone\", LoggedExec.class, createClone -> {\n+            createClone.onlyIf(task -> this.gitExtension.getCheckoutDir().get().exists() == false);\n+            createClone.setCommandLine(asList(\"git\", \"clone\", project.getRootDir(), gitExtension.getCheckoutDir().get()));\n+        });\n+\n+        TaskProvider<LoggedExec> findRemoteTaskProvider = tasks.register(\"findRemote\", LoggedExec.class, findRemote -> {\n+            findRemote.dependsOn(createCloneTaskProvider);\n+            // TODO Gradle should provide property based configuration here", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9df3ee594a24c357bbf8028a317b7596f6e10c85"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA2ODE1NA==", "bodyText": "Can we leverage Util.getBooleanProperty() here?", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497068154", "createdAt": "2020-09-29T21:23:30Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalBwcGitPlugin.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.LoggedExec;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.gradle.api.Action;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.logging.Logger;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n+import org.gradle.api.provider.Provider;\n+import org.gradle.api.provider.ProviderFactory;\n+import org.gradle.api.tasks.TaskContainer;\n+import org.gradle.api.tasks.TaskProvider;\n+import org.gradle.process.ExecResult;\n+import org.gradle.process.ExecSpec;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+\n+import static java.util.Arrays.asList;\n+\n+public class InternalBwcGitPlugin implements Plugin<Project> {\n+\n+    private BwcGitExtension gitExtension;\n+    private Project project;\n+\n+    @Override\n+    public void apply(Project project) {\n+        this.project = project;\n+        this.gitExtension = project.getExtensions().create(\"bwcGitConfig\", BwcGitExtension.class);\n+        ProviderFactory providers = project.getProviders();\n+        Provider<String> remote = project.getProviders().systemProperty(\"bwc.remote\").forUseAtConfigurationTime().orElse(\"elastic\");\n+\n+        TaskContainer tasks = project.getTasks();\n+        TaskProvider<LoggedExec> createCloneTaskProvider = tasks.register(\"createClone\", LoggedExec.class, createClone -> {\n+            createClone.onlyIf(task -> this.gitExtension.getCheckoutDir().get().exists() == false);\n+            createClone.setCommandLine(asList(\"git\", \"clone\", project.getRootDir(), gitExtension.getCheckoutDir().get()));\n+        });\n+\n+        TaskProvider<LoggedExec> findRemoteTaskProvider = tasks.register(\"findRemote\", LoggedExec.class, findRemote -> {\n+            findRemote.dependsOn(createCloneTaskProvider);\n+            // TODO Gradle should provide property based configuration here\n+            findRemote.setWorkingDir(gitExtension.getCheckoutDir().get());\n+\n+            findRemote.setCommandLine(asList(\"git\", \"remote\", \"-v\"));\n+            ByteArrayOutputStream output = new ByteArrayOutputStream();\n+            findRemote.setStandardOutput(output);\n+            findRemote.doLast(t -> {\n+                ExtraPropertiesExtension extraProperties = project.getExtensions().getExtraProperties();\n+                extraProperties.set(\"remoteExists\", isRemoteAvailable(remote, output));\n+            });\n+        });\n+\n+        TaskProvider<LoggedExec> addRemoteTaskProvider = tasks.register(\"addRemote\", LoggedExec.class, addRemote -> {\n+            addRemote.dependsOn(findRemoteTaskProvider);\n+            addRemote.onlyIf(task -> ((boolean) project.getExtensions().getExtraProperties().get(\"remoteExists\")) == false);\n+            addRemote.setWorkingDir(gitExtension.getCheckoutDir().get());\n+            String remoteRepo = remote.get();\n+            // for testing only we can override the base remote url\n+            String remoteRepoUrl = project.getProviders()\n+                .systemProperty(\"testRemoteRepo\")\n+                .forUseAtConfigurationTime()\n+                .getOrElse(\"https://github.com/\" + remoteRepo + \"/elasticsearch.git\");\n+            addRemote.setCommandLine(asList(\"git\", \"remote\", \"add\", remoteRepo, remoteRepoUrl));\n+        });\n+\n+        TaskProvider<LoggedExec> fetchLatestTaskProvider = tasks.register(\"fetchLatest\", LoggedExec.class, fetchLatest -> {\n+            var gitFetchLatest = project.getProviders()\n+                .systemProperty(\"tests.bwc.git_fetch_latest\")\n+                .forUseAtConfigurationTime()\n+                .orElse(\"true\")\n+                .map(fetchProp -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9df3ee594a24c357bbf8028a317b7596f6e10c85"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA3NDY0OQ==", "bodyText": "Looks like we aren't using bwcProject for anything?", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497074649", "createdAt": "2020-09-29T21:36:24Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionBwcSetupPlugin.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.BwcVersions;\n+import org.elasticsearch.gradle.Version;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.gradle.api.InvalidUserDataException;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.Task;\n+import org.gradle.api.provider.Provider;\n+import org.gradle.api.tasks.TaskProvider;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Arrays.stream;\n+\n+/**\n+ * We want to be able to do BWC tests for unreleased versions without relying on and waiting for snapshots.\n+ * For this we need to check out and build the unreleased versions.\n+ * Since These depend on the current version, we can't name the Gradle projects statically, and don't know what the\n+ * unreleased versions are when Gradle projects are set up, so we use \"build-unreleased-version-*\" as placeholders\n+ * and configure them to build various versions here.\n+ */\n+public class InternalDistributionBwcSetupPlugin implements Plugin<Project> {\n+\n+    @Override\n+    public void apply(Project project) {\n+        project.getRootProject().getPluginManager().apply(GlobalBuildInfoPlugin.class);\n+\n+        BuildParams.getBwcVersions().forPreviousUnreleased((BwcVersions.UnreleasedVersionInfo unreleasedVersion) -> {\n+            Project bwcProject = project.project(unreleasedVersion.gradleProjectPath);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9df3ee594a24c357bbf8028a317b7596f6e10c85"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA3NzE4OA==", "bodyText": "What's the purpose of passing unreleaseVersionInfo to the extension and then just grabbing it back out? Do we need the getUnreleaseVersionInfo() method on the extensions since we already have a handle to that here?", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497077188", "createdAt": "2020-09-29T21:42:06Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionBwcSetupPlugin.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.BwcVersions;\n+import org.elasticsearch.gradle.Version;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.gradle.api.InvalidUserDataException;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.Task;\n+import org.gradle.api.provider.Provider;\n+import org.gradle.api.tasks.TaskProvider;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Arrays.stream;\n+\n+/**\n+ * We want to be able to do BWC tests for unreleased versions without relying on and waiting for snapshots.\n+ * For this we need to check out and build the unreleased versions.\n+ * Since These depend on the current version, we can't name the Gradle projects statically, and don't know what the\n+ * unreleased versions are when Gradle projects are set up, so we use \"build-unreleased-version-*\" as placeholders\n+ * and configure them to build various versions here.\n+ */\n+public class InternalDistributionBwcSetupPlugin implements Plugin<Project> {\n+\n+    @Override\n+    public void apply(Project project) {\n+        project.getRootProject().getPluginManager().apply(GlobalBuildInfoPlugin.class);\n+\n+        BuildParams.getBwcVersions().forPreviousUnreleased((BwcVersions.UnreleasedVersionInfo unreleasedVersion) -> {\n+            Project bwcProject = project.project(unreleasedVersion.gradleProjectPath);\n+            configureBwcProject(project.project(unreleasedVersion.gradleProjectPath), unreleasedVersion);\n+        });\n+    }\n+\n+    private void configureBwcProject(Project project, BwcVersions.UnreleasedVersionInfo unreleasedVersionInfo) {\n+        BwcSetupExtension bwcSetupExtension = project.getExtensions().create(\"bwcSetup\", BwcSetupExtension.class, project);\n+        bwcSetupExtension.setUnreleasedVersionInfo(project.provider(() -> unreleasedVersionInfo));\n+        BwcGitExtension gitExtension = project.getPlugins().apply(InternalBwcGitPlugin.class).getGitExtension();\n+        Provider<BwcVersions.UnreleasedVersionInfo> unreleasedVersionInfoProvider = bwcSetupExtension.getUnreleasedVersionInfo();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9df3ee594a24c357bbf8028a317b7596f6e10c85"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA4MDAxMw==", "bodyText": "I'm not sure ArchiveProject is the right name here since this includes deb and rpm packages. Our packaging nomenclature uses \"archive\" to mean specifically zip and tar.", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497080013", "createdAt": "2020-09-29T21:47:31Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionBwcSetupPlugin.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.BwcVersions;\n+import org.elasticsearch.gradle.Version;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.gradle.api.InvalidUserDataException;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.Task;\n+import org.gradle.api.provider.Provider;\n+import org.gradle.api.tasks.TaskProvider;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Arrays.stream;\n+\n+/**\n+ * We want to be able to do BWC tests for unreleased versions without relying on and waiting for snapshots.\n+ * For this we need to check out and build the unreleased versions.\n+ * Since These depend on the current version, we can't name the Gradle projects statically, and don't know what the\n+ * unreleased versions are when Gradle projects are set up, so we use \"build-unreleased-version-*\" as placeholders\n+ * and configure them to build various versions here.\n+ */\n+public class InternalDistributionBwcSetupPlugin implements Plugin<Project> {\n+\n+    @Override\n+    public void apply(Project project) {\n+        project.getRootProject().getPluginManager().apply(GlobalBuildInfoPlugin.class);\n+\n+        BuildParams.getBwcVersions().forPreviousUnreleased((BwcVersions.UnreleasedVersionInfo unreleasedVersion) -> {\n+            Project bwcProject = project.project(unreleasedVersion.gradleProjectPath);\n+            configureBwcProject(project.project(unreleasedVersion.gradleProjectPath), unreleasedVersion);\n+        });\n+    }\n+\n+    private void configureBwcProject(Project project, BwcVersions.UnreleasedVersionInfo unreleasedVersionInfo) {\n+        BwcSetupExtension bwcSetupExtension = project.getExtensions().create(\"bwcSetup\", BwcSetupExtension.class, project);\n+        bwcSetupExtension.setUnreleasedVersionInfo(project.provider(() -> unreleasedVersionInfo));\n+        BwcGitExtension gitExtension = project.getPlugins().apply(InternalBwcGitPlugin.class).getGitExtension();\n+        Provider<BwcVersions.UnreleasedVersionInfo> unreleasedVersionInfoProvider = bwcSetupExtension.getUnreleasedVersionInfo();\n+        Provider<Version> bwcVersion = unreleasedVersionInfoProvider.map(info -> info.version);\n+        gitExtension.setBwcVersion(unreleasedVersionInfoProvider.map(info -> info.version));\n+        gitExtension.setBwcBranch(unreleasedVersionInfoProvider.map(info -> info.branch));\n+        Provider<File> checkoutDir = bwcSetupExtension.getCheckoutDir();\n+        gitExtension.setCheckoutDir(bwcSetupExtension.getCheckoutDir());\n+\n+        project.getPlugins().apply(\"distribution\");\n+        // Not published so no need to assemble\n+        project.getTasks().named(\"assemble\").configure(t -> t.setEnabled(false));\n+\n+        TaskProvider<Task> buildBwcTaskProvider = project.getTasks().register(\"buildBwc\");\n+        List<ArchiveProject> archiveProjects = resolveArchiveProjects(checkoutDir.get(), bwcVersion.get());\n+\n+        for (ArchiveProject archiveProject : archiveProjects) {\n+            createBuildBwcTask(\n+                bwcSetupExtension,\n+                project,\n+                bwcVersion,\n+                archiveProject.name,\n+                archiveProject.getProjectPath(),\n+                archiveProject.getDistArchiveFile(),\n+                buildBwcTaskProvider\n+            );\n+\n+            registerBwcArtifacts(project, archiveProject);\n+        }\n+\n+        // Create build tasks for the JDBC driver used for compatibility testing\n+        String jdbcProjectDir = \"x-pack/plugin/sql/jdbc\";\n+\n+        File jdbcProjectArtifact = new File(\n+            checkoutDir.get(),\n+            jdbcProjectDir + \"/build/distributions/x-pack-sql-jdbc-\" + bwcVersion.get() + \"-SNAPSHOT.jar\"\n+        );\n+\n+        createBuildBwcTask(bwcSetupExtension, project, bwcVersion, \"jdbc\", jdbcProjectDir, jdbcProjectArtifact, buildBwcTaskProvider);\n+\n+        // make sure no dependencies were added to assemble; we want it to be a no-op\n+        project.getTasks().named(\"assemble\").configure(t -> t.setDependsOn(Collections.emptyList()));\n+    }\n+\n+    private void registerBwcArtifacts(Project bwcProject, ArchiveProject archiveProject) {\n+        String projectName = archiveProject.name;\n+        String buildBwcTask = buildBwcTaskName(projectName);\n+\n+        registerDistributionArchiveArtifact(bwcProject, archiveProject, buildBwcTask);\n+        if (archiveProject.getExpandedDistDirectory() != null) {\n+            String expandedDistConfiguration = \"expanded-\" + projectName;\n+            bwcProject.getConfigurations().create(expandedDistConfiguration);\n+            bwcProject.getArtifacts().add(expandedDistConfiguration, archiveProject.getExpandedDistDirectory(), artifact -> {\n+                artifact.setName(\"elasticsearch\");\n+                artifact.builtBy(buildBwcTask);\n+                artifact.setType(\"directory\");\n+            });\n+        }\n+    }\n+\n+    private void registerDistributionArchiveArtifact(Project bwcProject, ArchiveProject archiveProject, String buildBwcTask) {\n+        String artifactFileName = archiveProject.getDistArchiveFile().getName();\n+        String artifactName = artifactFileName.contains(\"oss\") ? \"elasticsearch-oss\" : \"elasticsearch\";\n+\n+        String suffix = artifactFileName.endsWith(\"tar.gz\") ? \"tar.gz\" : artifactFileName.substring(artifactFileName.length() - 3);\n+        int archIndex = artifactFileName.indexOf(\"x86_64\");\n+\n+        bwcProject.getConfigurations().create(archiveProject.name);\n+        bwcProject.getArtifacts().add(archiveProject.name, archiveProject.getDistArchiveFile(), artifact -> {\n+            artifact.setName(artifactName);\n+            artifact.builtBy(buildBwcTask);\n+            artifact.setType(suffix);\n+\n+            String classifier = \"\";\n+            if (archIndex != -1) {\n+                int osIndex = artifactFileName.lastIndexOf('-', archIndex - 2);\n+                classifier = \"-\" + artifactFileName.substring(osIndex + 1, archIndex - 1) + \"-x86_64\";\n+            }\n+            artifact.setClassifier(classifier);\n+        });\n+    }\n+\n+    private static List<ArchiveProject> resolveArchiveProjects(File checkoutDir, Version bwcVersion) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9df3ee594a24c357bbf8028a317b7596f6e10c85"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA4MTkxOQ==", "bodyText": "I think we can remove this condition given that we will never build a bwc branch prior to this version since the oldest active branch is 6.8.", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497081919", "createdAt": "2020-09-29T21:51:46Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionBwcSetupPlugin.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.BwcVersions;\n+import org.elasticsearch.gradle.Version;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.gradle.api.InvalidUserDataException;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.Task;\n+import org.gradle.api.provider.Provider;\n+import org.gradle.api.tasks.TaskProvider;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Arrays.stream;\n+\n+/**\n+ * We want to be able to do BWC tests for unreleased versions without relying on and waiting for snapshots.\n+ * For this we need to check out and build the unreleased versions.\n+ * Since These depend on the current version, we can't name the Gradle projects statically, and don't know what the\n+ * unreleased versions are when Gradle projects are set up, so we use \"build-unreleased-version-*\" as placeholders\n+ * and configure them to build various versions here.\n+ */\n+public class InternalDistributionBwcSetupPlugin implements Plugin<Project> {\n+\n+    @Override\n+    public void apply(Project project) {\n+        project.getRootProject().getPluginManager().apply(GlobalBuildInfoPlugin.class);\n+\n+        BuildParams.getBwcVersions().forPreviousUnreleased((BwcVersions.UnreleasedVersionInfo unreleasedVersion) -> {\n+            Project bwcProject = project.project(unreleasedVersion.gradleProjectPath);\n+            configureBwcProject(project.project(unreleasedVersion.gradleProjectPath), unreleasedVersion);\n+        });\n+    }\n+\n+    private void configureBwcProject(Project project, BwcVersions.UnreleasedVersionInfo unreleasedVersionInfo) {\n+        BwcSetupExtension bwcSetupExtension = project.getExtensions().create(\"bwcSetup\", BwcSetupExtension.class, project);\n+        bwcSetupExtension.setUnreleasedVersionInfo(project.provider(() -> unreleasedVersionInfo));\n+        BwcGitExtension gitExtension = project.getPlugins().apply(InternalBwcGitPlugin.class).getGitExtension();\n+        Provider<BwcVersions.UnreleasedVersionInfo> unreleasedVersionInfoProvider = bwcSetupExtension.getUnreleasedVersionInfo();\n+        Provider<Version> bwcVersion = unreleasedVersionInfoProvider.map(info -> info.version);\n+        gitExtension.setBwcVersion(unreleasedVersionInfoProvider.map(info -> info.version));\n+        gitExtension.setBwcBranch(unreleasedVersionInfoProvider.map(info -> info.branch));\n+        Provider<File> checkoutDir = bwcSetupExtension.getCheckoutDir();\n+        gitExtension.setCheckoutDir(bwcSetupExtension.getCheckoutDir());\n+\n+        project.getPlugins().apply(\"distribution\");\n+        // Not published so no need to assemble\n+        project.getTasks().named(\"assemble\").configure(t -> t.setEnabled(false));\n+\n+        TaskProvider<Task> buildBwcTaskProvider = project.getTasks().register(\"buildBwc\");\n+        List<ArchiveProject> archiveProjects = resolveArchiveProjects(checkoutDir.get(), bwcVersion.get());\n+\n+        for (ArchiveProject archiveProject : archiveProjects) {\n+            createBuildBwcTask(\n+                bwcSetupExtension,\n+                project,\n+                bwcVersion,\n+                archiveProject.name,\n+                archiveProject.getProjectPath(),\n+                archiveProject.getDistArchiveFile(),\n+                buildBwcTaskProvider\n+            );\n+\n+            registerBwcArtifacts(project, archiveProject);\n+        }\n+\n+        // Create build tasks for the JDBC driver used for compatibility testing\n+        String jdbcProjectDir = \"x-pack/plugin/sql/jdbc\";\n+\n+        File jdbcProjectArtifact = new File(\n+            checkoutDir.get(),\n+            jdbcProjectDir + \"/build/distributions/x-pack-sql-jdbc-\" + bwcVersion.get() + \"-SNAPSHOT.jar\"\n+        );\n+\n+        createBuildBwcTask(bwcSetupExtension, project, bwcVersion, \"jdbc\", jdbcProjectDir, jdbcProjectArtifact, buildBwcTaskProvider);\n+\n+        // make sure no dependencies were added to assemble; we want it to be a no-op\n+        project.getTasks().named(\"assemble\").configure(t -> t.setDependsOn(Collections.emptyList()));\n+    }\n+\n+    private void registerBwcArtifacts(Project bwcProject, ArchiveProject archiveProject) {\n+        String projectName = archiveProject.name;\n+        String buildBwcTask = buildBwcTaskName(projectName);\n+\n+        registerDistributionArchiveArtifact(bwcProject, archiveProject, buildBwcTask);\n+        if (archiveProject.getExpandedDistDirectory() != null) {\n+            String expandedDistConfiguration = \"expanded-\" + projectName;\n+            bwcProject.getConfigurations().create(expandedDistConfiguration);\n+            bwcProject.getArtifacts().add(expandedDistConfiguration, archiveProject.getExpandedDistDirectory(), artifact -> {\n+                artifact.setName(\"elasticsearch\");\n+                artifact.builtBy(buildBwcTask);\n+                artifact.setType(\"directory\");\n+            });\n+        }\n+    }\n+\n+    private void registerDistributionArchiveArtifact(Project bwcProject, ArchiveProject archiveProject, String buildBwcTask) {\n+        String artifactFileName = archiveProject.getDistArchiveFile().getName();\n+        String artifactName = artifactFileName.contains(\"oss\") ? \"elasticsearch-oss\" : \"elasticsearch\";\n+\n+        String suffix = artifactFileName.endsWith(\"tar.gz\") ? \"tar.gz\" : artifactFileName.substring(artifactFileName.length() - 3);\n+        int archIndex = artifactFileName.indexOf(\"x86_64\");\n+\n+        bwcProject.getConfigurations().create(archiveProject.name);\n+        bwcProject.getArtifacts().add(archiveProject.name, archiveProject.getDistArchiveFile(), artifact -> {\n+            artifact.setName(artifactName);\n+            artifact.builtBy(buildBwcTask);\n+            artifact.setType(suffix);\n+\n+            String classifier = \"\";\n+            if (archIndex != -1) {\n+                int osIndex = artifactFileName.lastIndexOf('-', archIndex - 2);\n+                classifier = \"-\" + artifactFileName.substring(osIndex + 1, archIndex - 1) + \"-x86_64\";\n+            }\n+            artifact.setClassifier(classifier);\n+        });\n+    }\n+\n+    private static List<ArchiveProject> resolveArchiveProjects(File checkoutDir, Version bwcVersion) {\n+        List<String> projects = new ArrayList<>();\n+        projects.addAll(asList(\"deb\", \"rpm\"));\n+        if (bwcVersion.onOrAfter(\"7.0.0\")) {\n+            projects.addAll(asList(\"oss-windows-zip\", \"windows-zip\", \"oss-darwin-tar\", \"darwin-tar\", \"oss-linux-tar\", \"linux-tar\"));\n+        } else if (bwcVersion.onOrAfter(\"6.3.0\")) {\n+            projects.addAll(asList(\"oss-zip\", \"zip\", \"oss-deb\", \"oss-rpm\"));\n+        } else {\n+            projects.addAll(asList(\"zip\"));\n+        }\n+\n+        return projects.stream().map(name -> {\n+            String baseDir = \"distribution\";\n+            if (bwcVersion.onOrAfter(\"6.3.0\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9df3ee594a24c357bbf8028a317b7596f6e10c85"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA4MjQwNg==", "bodyText": "I think we can ditch this conditional branch. As mentioned below, we no longer will ever build versions prior to 6.8 from source for bwc.", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497082406", "createdAt": "2020-09-29T21:52:54Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionBwcSetupPlugin.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.BwcVersions;\n+import org.elasticsearch.gradle.Version;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.gradle.api.InvalidUserDataException;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.Task;\n+import org.gradle.api.provider.Provider;\n+import org.gradle.api.tasks.TaskProvider;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Arrays.stream;\n+\n+/**\n+ * We want to be able to do BWC tests for unreleased versions without relying on and waiting for snapshots.\n+ * For this we need to check out and build the unreleased versions.\n+ * Since These depend on the current version, we can't name the Gradle projects statically, and don't know what the\n+ * unreleased versions are when Gradle projects are set up, so we use \"build-unreleased-version-*\" as placeholders\n+ * and configure them to build various versions here.\n+ */\n+public class InternalDistributionBwcSetupPlugin implements Plugin<Project> {\n+\n+    @Override\n+    public void apply(Project project) {\n+        project.getRootProject().getPluginManager().apply(GlobalBuildInfoPlugin.class);\n+\n+        BuildParams.getBwcVersions().forPreviousUnreleased((BwcVersions.UnreleasedVersionInfo unreleasedVersion) -> {\n+            Project bwcProject = project.project(unreleasedVersion.gradleProjectPath);\n+            configureBwcProject(project.project(unreleasedVersion.gradleProjectPath), unreleasedVersion);\n+        });\n+    }\n+\n+    private void configureBwcProject(Project project, BwcVersions.UnreleasedVersionInfo unreleasedVersionInfo) {\n+        BwcSetupExtension bwcSetupExtension = project.getExtensions().create(\"bwcSetup\", BwcSetupExtension.class, project);\n+        bwcSetupExtension.setUnreleasedVersionInfo(project.provider(() -> unreleasedVersionInfo));\n+        BwcGitExtension gitExtension = project.getPlugins().apply(InternalBwcGitPlugin.class).getGitExtension();\n+        Provider<BwcVersions.UnreleasedVersionInfo> unreleasedVersionInfoProvider = bwcSetupExtension.getUnreleasedVersionInfo();\n+        Provider<Version> bwcVersion = unreleasedVersionInfoProvider.map(info -> info.version);\n+        gitExtension.setBwcVersion(unreleasedVersionInfoProvider.map(info -> info.version));\n+        gitExtension.setBwcBranch(unreleasedVersionInfoProvider.map(info -> info.branch));\n+        Provider<File> checkoutDir = bwcSetupExtension.getCheckoutDir();\n+        gitExtension.setCheckoutDir(bwcSetupExtension.getCheckoutDir());\n+\n+        project.getPlugins().apply(\"distribution\");\n+        // Not published so no need to assemble\n+        project.getTasks().named(\"assemble\").configure(t -> t.setEnabled(false));\n+\n+        TaskProvider<Task> buildBwcTaskProvider = project.getTasks().register(\"buildBwc\");\n+        List<ArchiveProject> archiveProjects = resolveArchiveProjects(checkoutDir.get(), bwcVersion.get());\n+\n+        for (ArchiveProject archiveProject : archiveProjects) {\n+            createBuildBwcTask(\n+                bwcSetupExtension,\n+                project,\n+                bwcVersion,\n+                archiveProject.name,\n+                archiveProject.getProjectPath(),\n+                archiveProject.getDistArchiveFile(),\n+                buildBwcTaskProvider\n+            );\n+\n+            registerBwcArtifacts(project, archiveProject);\n+        }\n+\n+        // Create build tasks for the JDBC driver used for compatibility testing\n+        String jdbcProjectDir = \"x-pack/plugin/sql/jdbc\";\n+\n+        File jdbcProjectArtifact = new File(\n+            checkoutDir.get(),\n+            jdbcProjectDir + \"/build/distributions/x-pack-sql-jdbc-\" + bwcVersion.get() + \"-SNAPSHOT.jar\"\n+        );\n+\n+        createBuildBwcTask(bwcSetupExtension, project, bwcVersion, \"jdbc\", jdbcProjectDir, jdbcProjectArtifact, buildBwcTaskProvider);\n+\n+        // make sure no dependencies were added to assemble; we want it to be a no-op\n+        project.getTasks().named(\"assemble\").configure(t -> t.setDependsOn(Collections.emptyList()));\n+    }\n+\n+    private void registerBwcArtifacts(Project bwcProject, ArchiveProject archiveProject) {\n+        String projectName = archiveProject.name;\n+        String buildBwcTask = buildBwcTaskName(projectName);\n+\n+        registerDistributionArchiveArtifact(bwcProject, archiveProject, buildBwcTask);\n+        if (archiveProject.getExpandedDistDirectory() != null) {\n+            String expandedDistConfiguration = \"expanded-\" + projectName;\n+            bwcProject.getConfigurations().create(expandedDistConfiguration);\n+            bwcProject.getArtifacts().add(expandedDistConfiguration, archiveProject.getExpandedDistDirectory(), artifact -> {\n+                artifact.setName(\"elasticsearch\");\n+                artifact.builtBy(buildBwcTask);\n+                artifact.setType(\"directory\");\n+            });\n+        }\n+    }\n+\n+    private void registerDistributionArchiveArtifact(Project bwcProject, ArchiveProject archiveProject, String buildBwcTask) {\n+        String artifactFileName = archiveProject.getDistArchiveFile().getName();\n+        String artifactName = artifactFileName.contains(\"oss\") ? \"elasticsearch-oss\" : \"elasticsearch\";\n+\n+        String suffix = artifactFileName.endsWith(\"tar.gz\") ? \"tar.gz\" : artifactFileName.substring(artifactFileName.length() - 3);\n+        int archIndex = artifactFileName.indexOf(\"x86_64\");\n+\n+        bwcProject.getConfigurations().create(archiveProject.name);\n+        bwcProject.getArtifacts().add(archiveProject.name, archiveProject.getDistArchiveFile(), artifact -> {\n+            artifact.setName(artifactName);\n+            artifact.builtBy(buildBwcTask);\n+            artifact.setType(suffix);\n+\n+            String classifier = \"\";\n+            if (archIndex != -1) {\n+                int osIndex = artifactFileName.lastIndexOf('-', archIndex - 2);\n+                classifier = \"-\" + artifactFileName.substring(osIndex + 1, archIndex - 1) + \"-x86_64\";\n+            }\n+            artifact.setClassifier(classifier);\n+        });\n+    }\n+\n+    private static List<ArchiveProject> resolveArchiveProjects(File checkoutDir, Version bwcVersion) {\n+        List<String> projects = new ArrayList<>();\n+        projects.addAll(asList(\"deb\", \"rpm\"));\n+        if (bwcVersion.onOrAfter(\"7.0.0\")) {\n+            projects.addAll(asList(\"oss-windows-zip\", \"windows-zip\", \"oss-darwin-tar\", \"darwin-tar\", \"oss-linux-tar\", \"linux-tar\"));\n+        } else if (bwcVersion.onOrAfter(\"6.3.0\")) {\n+            projects.addAll(asList(\"oss-zip\", \"zip\", \"oss-deb\", \"oss-rpm\"));\n+        } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9df3ee594a24c357bbf8028a317b7596f6e10c85"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA4NTU5Mw==", "bodyText": "Here we zero out the task dependencies but above we actually disable the task. Should we do one or the other?", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497085593", "createdAt": "2020-09-29T22:00:04Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionBwcSetupPlugin.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.BwcVersions;\n+import org.elasticsearch.gradle.Version;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.gradle.api.InvalidUserDataException;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.Task;\n+import org.gradle.api.provider.Provider;\n+import org.gradle.api.tasks.TaskProvider;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Arrays.stream;\n+\n+/**\n+ * We want to be able to do BWC tests for unreleased versions without relying on and waiting for snapshots.\n+ * For this we need to check out and build the unreleased versions.\n+ * Since These depend on the current version, we can't name the Gradle projects statically, and don't know what the\n+ * unreleased versions are when Gradle projects are set up, so we use \"build-unreleased-version-*\" as placeholders\n+ * and configure them to build various versions here.\n+ */\n+public class InternalDistributionBwcSetupPlugin implements Plugin<Project> {\n+\n+    @Override\n+    public void apply(Project project) {\n+        project.getRootProject().getPluginManager().apply(GlobalBuildInfoPlugin.class);\n+\n+        BuildParams.getBwcVersions().forPreviousUnreleased((BwcVersions.UnreleasedVersionInfo unreleasedVersion) -> {\n+            Project bwcProject = project.project(unreleasedVersion.gradleProjectPath);\n+            configureBwcProject(project.project(unreleasedVersion.gradleProjectPath), unreleasedVersion);\n+        });\n+    }\n+\n+    private void configureBwcProject(Project project, BwcVersions.UnreleasedVersionInfo unreleasedVersionInfo) {\n+        BwcSetupExtension bwcSetupExtension = project.getExtensions().create(\"bwcSetup\", BwcSetupExtension.class, project);\n+        bwcSetupExtension.setUnreleasedVersionInfo(project.provider(() -> unreleasedVersionInfo));\n+        BwcGitExtension gitExtension = project.getPlugins().apply(InternalBwcGitPlugin.class).getGitExtension();\n+        Provider<BwcVersions.UnreleasedVersionInfo> unreleasedVersionInfoProvider = bwcSetupExtension.getUnreleasedVersionInfo();\n+        Provider<Version> bwcVersion = unreleasedVersionInfoProvider.map(info -> info.version);\n+        gitExtension.setBwcVersion(unreleasedVersionInfoProvider.map(info -> info.version));\n+        gitExtension.setBwcBranch(unreleasedVersionInfoProvider.map(info -> info.branch));\n+        Provider<File> checkoutDir = bwcSetupExtension.getCheckoutDir();\n+        gitExtension.setCheckoutDir(bwcSetupExtension.getCheckoutDir());\n+\n+        project.getPlugins().apply(\"distribution\");\n+        // Not published so no need to assemble\n+        project.getTasks().named(\"assemble\").configure(t -> t.setEnabled(false));\n+\n+        TaskProvider<Task> buildBwcTaskProvider = project.getTasks().register(\"buildBwc\");\n+        List<ArchiveProject> archiveProjects = resolveArchiveProjects(checkoutDir.get(), bwcVersion.get());\n+\n+        for (ArchiveProject archiveProject : archiveProjects) {\n+            createBuildBwcTask(\n+                bwcSetupExtension,\n+                project,\n+                bwcVersion,\n+                archiveProject.name,\n+                archiveProject.getProjectPath(),\n+                archiveProject.getDistArchiveFile(),\n+                buildBwcTaskProvider\n+            );\n+\n+            registerBwcArtifacts(project, archiveProject);\n+        }\n+\n+        // Create build tasks for the JDBC driver used for compatibility testing\n+        String jdbcProjectDir = \"x-pack/plugin/sql/jdbc\";\n+\n+        File jdbcProjectArtifact = new File(\n+            checkoutDir.get(),\n+            jdbcProjectDir + \"/build/distributions/x-pack-sql-jdbc-\" + bwcVersion.get() + \"-SNAPSHOT.jar\"\n+        );\n+\n+        createBuildBwcTask(bwcSetupExtension, project, bwcVersion, \"jdbc\", jdbcProjectDir, jdbcProjectArtifact, buildBwcTaskProvider);\n+\n+        // make sure no dependencies were added to assemble; we want it to be a no-op\n+        project.getTasks().named(\"assemble\").configure(t -> t.setDependsOn(Collections.emptyList()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9df3ee594a24c357bbf8028a317b7596f6e10c85"}, "originalPosition": 105}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aa2ac780e895911fd352a98a290ecb286e767626", "author": {"user": {"login": "breskeby", "name": "Rene Groeschke"}}, "url": "https://github.com/elastic/elasticsearch/commit/aa2ac780e895911fd352a98a290ecb286e767626", "committedDate": "2020-09-30T08:33:37Z", "message": "Start porting bwc distribution setup into plugin"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0661fe2183fcb7af8f376961ea7dfaad1efec7ad", "author": {"user": {"login": "breskeby", "name": "Rene Groeschke"}}, "url": "https://github.com/elastic/elasticsearch/commit/0661fe2183fcb7af8f376961ea7dfaad1efec7ad", "committedDate": "2020-09-30T08:33:37Z", "message": "Move git checkout logic into its own plugin"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "27decd8d692f49640205923064472798c2ae444f", "author": {"user": {"login": "breskeby", "name": "Rene Groeschke"}}, "url": "https://github.com/elastic/elasticsearch/commit/27decd8d692f49640205923064472798c2ae444f", "committedDate": "2020-09-30T08:33:38Z", "message": "Fix spotless"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "876be3303e61ad8ce1366d23a10132e24812ca1e", "author": {"user": {"login": "breskeby", "name": "Rene Groeschke"}}, "url": "https://github.com/elastic/elasticsearch/commit/876be3303e61ad8ce1366d23a10132e24812ca1e", "committedDate": "2020-09-30T08:33:38Z", "message": "Port more bwc setup into binary plugin"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c490dbe281e85c53a9d97a01919154dd5517999c", "author": {"user": {"login": "breskeby", "name": "Rene Groeschke"}}, "url": "https://github.com/elastic/elasticsearch/commit/c490dbe281e85c53a9d97a01919154dd5517999c", "committedDate": "2020-09-30T08:33:38Z", "message": "Cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0473bd731f336227259dc60a908d912d70dd53c9", "author": {"user": {"login": "breskeby", "name": "Rene Groeschke"}}, "url": "https://github.com/elastic/elasticsearch/commit/0473bd731f336227259dc60a908d912d70dd53c9", "committedDate": "2020-09-30T08:33:38Z", "message": "Fix minor issues in bwc setup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2a16102ced91dd3745d780841bbed4fc73aa87fd", "author": {"user": {"login": "breskeby", "name": "Rene Groeschke"}}, "url": "https://github.com/elastic/elasticsearch/commit/2a16102ced91dd3745d780841bbed4fc73aa87fd", "committedDate": "2020-09-30T08:33:38Z", "message": "Formatting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c19484aea04a9d7e5211013f0db8931d96f7fadf", "author": {"user": {"login": "breskeby", "name": "Rene Groeschke"}}, "url": "https://github.com/elastic/elasticsearch/commit/c19484aea04a9d7e5211013f0db8931d96f7fadf", "committedDate": "2020-09-30T08:33:38Z", "message": "Extract specific logic from plugin"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "584e2dc7c7787b8aa2a6d0f573f40abc61c06b62", "author": {"user": {"login": "breskeby", "name": "Rene Groeschke"}}, "url": "https://github.com/elastic/elasticsearch/commit/584e2dc7c7787b8aa2a6d0f573f40abc61c06b62", "committedDate": "2020-09-30T08:33:39Z", "message": "Fix expected artifact paths"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3411ae2e0778c7e7b7d346fdaa3d28b4e905d944", "author": {"user": {"login": "breskeby", "name": "Rene Groeschke"}}, "url": "https://github.com/elastic/elasticsearch/commit/3411ae2e0778c7e7b7d346fdaa3d28b4e905d944", "committedDate": "2020-09-30T08:33:39Z", "message": "fix bwc jdbc build"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e2f324d0b57c79e1791cfc43816e3f82f75ce73a", "author": {"user": {"login": "breskeby", "name": "Rene Groeschke"}}, "url": "https://github.com/elastic/elasticsearch/commit/e2f324d0b57c79e1791cfc43816e3f82f75ce73a", "committedDate": "2020-09-30T08:33:39Z", "message": "Add initial test coverage for general bwc setup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "20e5e8316b32ee089d3f51a31621d9bfcfdd0d32", "author": {"user": {"login": "breskeby", "name": "Rene Groeschke"}}, "url": "https://github.com/elastic/elasticsearch/commit/20e5e8316b32ee089d3f51a31621d9bfcfdd0d32", "committedDate": "2020-09-30T08:33:39Z", "message": "Tweak func tests for bwc build setup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4b274baebaf6f2eb908cc1998760ab731216dfee", "author": {"user": {"login": "breskeby", "name": "Rene Groeschke"}}, "url": "https://github.com/elastic/elasticsearch/commit/4b274baebaf6f2eb908cc1998760ab731216dfee", "committedDate": "2020-09-30T08:33:39Z", "message": "Add todo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fb6caff2525584d10577d8e164a008697673454b", "author": {"user": {"login": "breskeby", "name": "Rene Groeschke"}}, "url": "https://github.com/elastic/elasticsearch/commit/fb6caff2525584d10577d8e164a008697673454b", "committedDate": "2020-09-30T08:33:39Z", "message": "Minor refactoring of the plugin and fixing path calculations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5a5fb669575dea27c04bba1646bb9a5464b53814", "author": {"user": {"login": "breskeby", "name": "Rene Groeschke"}}, "url": "https://github.com/elastic/elasticsearch/commit/5a5fb669575dea27c04bba1646bb9a5464b53814", "committedDate": "2020-09-30T08:33:40Z", "message": "Expose exploded dists as artifacts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0f40234e245834e81d9da285999b3544c92f5f75", "author": {"user": {"login": "breskeby", "name": "Rene Groeschke"}}, "url": "https://github.com/elastic/elasticsearch/commit/0f40234e245834e81d9da285999b3544c92f5f75", "committedDate": "2020-09-30T08:33:40Z", "message": "Fix spotless"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9d523e134481093d3ebc0e0db3f85a8c38f288e7", "author": {"user": {"login": "breskeby", "name": "Rene Groeschke"}}, "url": "https://github.com/elastic/elasticsearch/commit/9d523e134481093d3ebc0e0db3f85a8c38f288e7", "committedDate": "2020-09-30T08:33:40Z", "message": "fix bwc setup plugin func test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fe55986f5fe630ad737f9f7cef806562abc68f59", "author": {"user": {"login": "breskeby", "name": "Rene Groeschke"}}, "url": "https://github.com/elastic/elasticsearch/commit/fe55986f5fe630ad737f9f7cef806562abc68f59", "committedDate": "2020-09-30T08:33:40Z", "message": "Resolve exploded dist for bwc versions > 7.10"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "32684c93f5c564fee3df1fbbd294b73d373e10d9", "author": {"user": {"login": "breskeby", "name": "Rene Groeschke"}}, "url": "https://github.com/elastic/elasticsearch/commit/32684c93f5c564fee3df1fbbd294b73d373e10d9", "committedDate": "2020-09-30T08:33:40Z", "message": "Fix bwc tests against current"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1be13123c054d2bb3d9d8499543b21343e94ae57", "author": {"user": {"login": "breskeby", "name": "Rene Groeschke"}}, "url": "https://github.com/elastic/elasticsearch/commit/1be13123c054d2bb3d9d8499543b21343e94ae57", "committedDate": "2020-09-30T08:33:40Z", "message": "Fix formatting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9a1b2278739ccd360262227cc3463987972dd970", "author": {"user": {"login": "breskeby", "name": "Rene Groeschke"}}, "url": "https://github.com/elastic/elasticsearch/commit/9a1b2278739ccd360262227cc3463987972dd970", "committedDate": "2020-09-30T08:33:41Z", "message": "Polishing\n\n- unify namings\n- use provider api"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4e2bdc7d57ecdf8fa1c7c82a11918c38da724afd", "author": {"user": {"login": "breskeby", "name": "Rene Groeschke"}}, "url": "https://github.com/elastic/elasticsearch/commit/4e2bdc7d57ecdf8fa1c7c82a11918c38da724afd", "committedDate": "2020-09-30T08:33:41Z", "message": "Fix jdbc driver bwc build"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a1ff0830d57b34a52aaeedf705def222c01f0d2c", "author": {"user": {"login": "breskeby", "name": "Rene Groeschke"}}, "url": "https://github.com/elastic/elasticsearch/commit/a1ff0830d57b34a52aaeedf705def222c01f0d2c", "committedDate": "2020-09-30T15:20:25Z", "message": "Apply review feedback"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9df3ee594a24c357bbf8028a317b7596f6e10c85", "author": {"user": {"login": "breskeby", "name": "Rene Groeschke"}}, "url": "https://github.com/elastic/elasticsearch/commit/9df3ee594a24c357bbf8028a317b7596f6e10c85", "committedDate": "2020-09-24T15:41:57Z", "message": "Fix jdbc driver bwc build"}, "afterCommit": {"oid": "a1ff0830d57b34a52aaeedf705def222c01f0d2c", "author": {"user": {"login": "breskeby", "name": "Rene Groeschke"}}, "url": "https://github.com/elastic/elasticsearch/commit/a1ff0830d57b34a52aaeedf705def222c01f0d2c", "committedDate": "2020-09-30T15:20:25Z", "message": "Apply review feedback"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4510, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}