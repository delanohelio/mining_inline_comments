{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM0NDM3MDU2", "number": 66022, "reviewThreads": {"totalCount": 57, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNDoxNzo1M1rOFCXcMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOFQxMzoyMjowOVrOFUDthA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MDI1NTIyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNDoxNzo1M1rOIBereA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQwOTozNzoxNlrOIFHr0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQyMjEzNg==", "bodyText": "Why do you identify multiplication with wildcard symbol and not with an instanceof?", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r538422136", "createdAt": "2020-12-08T14:17:53Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1141,49 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    public static final class SimplifyArithmeticsInBinaryComparisons extends OptimizerExpressionRule {\n+\n+        public SimplifyArithmeticsInBinaryComparisons() {\n+            super(TransformDirection.UP);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof BinaryComparison) {\n+                return reduce((BinaryComparison) e);\n+            }\n+            return e;\n+        }\n+\n+        private Expression reduce(BinaryComparison bc) {\n+            // optimize only once the expression looks like: AnyNode [ArithmOp] AnyNode [BiComp] Literal\n+            if (bc.right() instanceof Literal == false) {\n+                return bc;\n+            }\n+            Literal bcRight = (Literal) bc.right();\n+\n+            if (bc.left() instanceof ArithmeticOperation) {\n+                ArithmeticOperation opLeft = (ArithmeticOperation) bc.left();\n+                if (opLeft instanceof Mod) {\n+                    return bc; // can't optimise Mods\n+                }\n+\n+                if (opLeft.left() instanceof Literal || opLeft.right() instanceof Literal) { // 5 [op] a >= 4 || a [op] 5 >= 4\n+                    // force double division\n+                    if (opLeft.symbol().equals(\"*\")) { // use symbol comp for SQL's Mul", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0db90e4457b32e85954126ec5a565850661b0535"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjIzOTY5Nw==", "bodyText": "The SQL ops aren't available as deps in the QL package.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r542239697", "createdAt": "2020-12-14T09:37:16Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1141,49 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    public static final class SimplifyArithmeticsInBinaryComparisons extends OptimizerExpressionRule {\n+\n+        public SimplifyArithmeticsInBinaryComparisons() {\n+            super(TransformDirection.UP);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof BinaryComparison) {\n+                return reduce((BinaryComparison) e);\n+            }\n+            return e;\n+        }\n+\n+        private Expression reduce(BinaryComparison bc) {\n+            // optimize only once the expression looks like: AnyNode [ArithmOp] AnyNode [BiComp] Literal\n+            if (bc.right() instanceof Literal == false) {\n+                return bc;\n+            }\n+            Literal bcRight = (Literal) bc.right();\n+\n+            if (bc.left() instanceof ArithmeticOperation) {\n+                ArithmeticOperation opLeft = (ArithmeticOperation) bc.left();\n+                if (opLeft instanceof Mod) {\n+                    return bc; // can't optimise Mods\n+                }\n+\n+                if (opLeft.left() instanceof Literal || opLeft.right() instanceof Literal) { // 5 [op] a >= 4 || a [op] 5 >= 4\n+                    // force double division\n+                    if (opLeft.symbol().equals(\"*\")) { // use symbol comp for SQL's Mul", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQyMjEzNg=="}, "originalCommit": {"oid": "0db90e4457b32e85954126ec5a565850661b0535"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MDMxMDE1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/operator/comparison/BinaryComparison.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNDoyNjoyMlrOIBfNow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQwOTozNzoyMlrOIFHsHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQzMDg4Mw==", "bodyText": "Add javadoc regarding the purpose of the method.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r538430883", "createdAt": "2020-12-08T14:26:22Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/operator/comparison/BinaryComparison.java", "diffHunk": "@@ -49,4 +49,6 @@ protected Pipe makePipe() {\n     public static Integer compare(Object left, Object right) {\n         return Comparisons.compare(left, right);\n     }\n+\n+    public abstract BinaryComparison reverse();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0db90e4457b32e85954126ec5a565850661b0535"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjIzOTc3NQ==", "bodyText": "javadoc added.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r542239775", "createdAt": "2020-12-14T09:37:22Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/operator/comparison/BinaryComparison.java", "diffHunk": "@@ -49,4 +49,6 @@ protected Pipe makePipe() {\n     public static Integer compare(Object left, Object right) {\n         return Comparisons.compare(left, right);\n     }\n+\n+    public abstract BinaryComparison reverse();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQzMDg4Mw=="}, "originalCommit": {"oid": "0db90e4457b32e85954126ec5a565850661b0535"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MDMxMjU4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/operator/arithmetic/Mul.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNDoyNjo0N1rOIBfPIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQwOTozNzoyNVrOIFHsPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQzMTI2Ng==", "bodyText": "return Div instead of ArithmeticOperation.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r538431266", "createdAt": "2020-12-08T14:26:47Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/operator/arithmetic/Mul.java", "diffHunk": "@@ -52,4 +52,9 @@ protected Mul replaceChildren(Expression newLeft, Expression newRight) {\n     public Mul swapLeftAndRight() {\n         return new Mul(source(), right(), left());\n     }\n+\n+    @Override\n+    public ArithmeticOperation inverse(Source source, Expression left, Expression right) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0db90e4457b32e85954126ec5a565850661b0535"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjIzOTgwNw==", "bodyText": "Fixed.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r542239807", "createdAt": "2020-12-14T09:37:25Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/operator/arithmetic/Mul.java", "diffHunk": "@@ -52,4 +52,9 @@ protected Mul replaceChildren(Expression newLeft, Expression newRight) {\n     public Mul swapLeftAndRight() {\n         return new Mul(source(), right(), left());\n     }\n+\n+    @Override\n+    public ArithmeticOperation inverse(Source source, Expression left, Expression right) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQzMTI2Ng=="}, "originalCommit": {"oid": "0db90e4457b32e85954126ec5a565850661b0535"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MDMxMzQ0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/operator/arithmetic/Sub.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNDoyNjo1M1rOIBfPmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQwOTozNzoyN1rOIFHsVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQzMTM4Ng==", "bodyText": "return Add instead of ArithmeticOperation", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r538431386", "createdAt": "2020-12-08T14:26:53Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/operator/arithmetic/Sub.java", "diffHunk": "@@ -27,4 +27,9 @@ public Sub(Source source, Expression left, Expression right) {\n     protected Sub replaceChildren(Expression newLeft, Expression newRight) {\n         return new Sub(source(), newLeft, newRight);\n     }\n+\n+    @Override\n+    public ArithmeticOperation inverse(Source source, Expression left, Expression right) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0db90e4457b32e85954126ec5a565850661b0535"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjIzOTgzMQ==", "bodyText": "Fixed.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r542239831", "createdAt": "2020-12-14T09:37:27Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/operator/arithmetic/Sub.java", "diffHunk": "@@ -27,4 +27,9 @@ public Sub(Source source, Expression left, Expression right) {\n     protected Sub replaceChildren(Expression newLeft, Expression newRight) {\n         return new Sub(source(), newLeft, newRight);\n     }\n+\n+    @Override\n+    public ArithmeticOperation inverse(Source source, Expression left, Expression right) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQzMTM4Ng=="}, "originalCommit": {"oid": "0db90e4457b32e85954126ec5a565850661b0535"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MDMyMjM0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/operator/arithmetic/Mod.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNDoyODoxOVrOIBfVAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQwOTozNzozNlrOIFHswg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQzMjc3MA==", "bodyText": "The exception type is wrong. And we rarely thrown an exception on methods that are forced to be implemented - that indicates either the code is incomplete (as here) or that the contract is too broad.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r538432770", "createdAt": "2020-12-08T14:28:19Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/operator/arithmetic/Mod.java", "diffHunk": "@@ -30,4 +30,10 @@ public Mod(Source source, Expression left, Expression right) {\n     protected Mod replaceChildren(Expression newLeft, Expression newRight) {\n         return new Mod(source(), newLeft, newRight);\n     }\n+\n+    @Override\n+    public ArithmeticOperation inverse(Source source, Expression left, Expression right) {\n+        // TODO: Modular Multiplicative Inverse, if ever needed?\n+        throw new UnsupportedOperationException(\"inverting modulo operation is not supported\");\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0db90e4457b32e85954126ec5a565850661b0535"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjIzOTkzOA==", "bodyText": "Fixed, adopted the same strategy as ArithmeticOperation#swapLeftAndRight().", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r542239938", "createdAt": "2020-12-14T09:37:36Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/operator/arithmetic/Mod.java", "diffHunk": "@@ -30,4 +30,10 @@ public Mod(Source source, Expression left, Expression right) {\n     protected Mod replaceChildren(Expression newLeft, Expression newRight) {\n         return new Mod(source(), newLeft, newRight);\n     }\n+\n+    @Override\n+    public ArithmeticOperation inverse(Source source, Expression left, Expression right) {\n+        // TODO: Modular Multiplicative Inverse, if ever needed?\n+        throw new UnsupportedOperationException(\"inverting modulo operation is not supported\");\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQzMjc3MA=="}, "originalCommit": {"oid": "0db90e4457b32e85954126ec5a565850661b0535"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MDMyMzU5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/operator/arithmetic/Div.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNDoyODozMlrOIBfVyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQwOTozNzo0MFrOIFHs-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQzMjk2OQ==", "bodyText": "return Mul instead of ArithmeticOperation", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r538432969", "createdAt": "2020-12-08T14:28:32Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/operator/arithmetic/Div.java", "diffHunk": "@@ -34,4 +34,9 @@ protected Div replaceChildren(Expression newLeft, Expression newRight) {\n     public DataType dataType() {\n         return DataTypeConverter.commonType(left().dataType(), right().dataType());\n     }\n+\n+    @Override\n+    public ArithmeticOperation inverse(Source source, Expression left, Expression right) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0db90e4457b32e85954126ec5a565850661b0535"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjIzOTk5NA==", "bodyText": "Fixed.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r542239994", "createdAt": "2020-12-14T09:37:40Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/operator/arithmetic/Div.java", "diffHunk": "@@ -34,4 +34,9 @@ protected Div replaceChildren(Expression newLeft, Expression newRight) {\n     public DataType dataType() {\n         return DataTypeConverter.commonType(left().dataType(), right().dataType());\n     }\n+\n+    @Override\n+    public ArithmeticOperation inverse(Source source, Expression left, Expression right) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQzMjk2OQ=="}, "originalCommit": {"oid": "0db90e4457b32e85954126ec5a565850661b0535"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MDMyNDk1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/operator/arithmetic/ArithmeticOperation.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNDoyODo0N1rOIBfWrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQwOTozNzo0NFrOIFHtKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQzMzE5OA==", "bodyText": "Javadoc on what this does.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r538433198", "createdAt": "2020-12-08T14:28:47Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/operator/arithmetic/ArithmeticOperation.java", "diffHunk": "@@ -45,4 +45,6 @@ public DataType dataType() {\n     protected Pipe makePipe() {\n         return new BinaryArithmeticPipe(source(), this, Expressions.pipe(left()), Expressions.pipe(right()), function());\n     }\n+\n+    public abstract ArithmeticOperation inverse(Source source, Expression left, Expression right);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0db90e4457b32e85954126ec5a565850661b0535"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjI0MDA0MA==", "bodyText": "Added a description.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r542240040", "createdAt": "2020-12-14T09:37:44Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/operator/arithmetic/ArithmeticOperation.java", "diffHunk": "@@ -45,4 +45,6 @@ public DataType dataType() {\n     protected Pipe makePipe() {\n         return new BinaryArithmeticPipe(source(), this, Expressions.pipe(left()), Expressions.pipe(right()), function());\n     }\n+\n+    public abstract ArithmeticOperation inverse(Source source, Expression left, Expression right);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQzMzE5OA=="}, "originalCommit": {"oid": "0db90e4457b32e85954126ec5a565850661b0535"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MDMyNjIwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/operator/arithmetic/Add.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNDoyODo1OFrOIBfXeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQwOTozNzo0OVrOIFHtYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQzMzQwMg==", "bodyText": "return Sub instead of ArithmeticOperation", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r538433402", "createdAt": "2020-12-08T14:28:58Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/operator/arithmetic/Add.java", "diffHunk": "@@ -30,4 +30,9 @@ protected Add replaceChildren(Expression left, Expression right) {\n     public Add swapLeftAndRight() {\n         return new Add(source(), right(), left());\n     }\n+\n+    @Override\n+    public ArithmeticOperation inverse(Source source, Expression left, Expression right) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0db90e4457b32e85954126ec5a565850661b0535"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjI0MDA5OQ==", "bodyText": "Fixed.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r542240099", "createdAt": "2020-12-14T09:37:49Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/operator/arithmetic/Add.java", "diffHunk": "@@ -30,4 +30,9 @@ protected Add replaceChildren(Expression left, Expression right) {\n     public Add swapLeftAndRight() {\n         return new Add(source(), right(), left());\n     }\n+\n+    @Override\n+    public ArithmeticOperation inverse(Source source, Expression left, Expression right) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQzMzQwMg=="}, "originalCommit": {"oid": "0db90e4457b32e85954126ec5a565850661b0535"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MDM1MDI1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/optimizer/OptimizerRunTests.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNDozMjo0MVrOIBfmEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQwOTozNzo1N1rOIFHtrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQzNzEzNw==", "bodyText": "The test only cares about the expression so you can just use parser.createExpression (see tests inside ExpressionTests).", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r538437137", "createdAt": "2020-12-08T14:32:41Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/optimizer/OptimizerRunTests.java", "diffHunk": "@@ -48,4 +57,57 @@ public void testWhereClause() {\n         LogicalPlan p = plan(\"SELECT some.string l FROM test WHERE int IS NOT NULL AND int < 10005 ORDER BY int\");\n         assertNotNull(p);\n     }\n-}\n\\ No newline at end of file\n+\n+    public void testReducedBinaryComparisonGreaterThenOrEqual() {\n+        // i >= 12\n+        doTestBinaryComparisonReduction(\"((int + 1) / 2 - 3) * 4 >= 14\", GreaterThanOrEqual.class, 12d);\n+    }\n+\n+    public void testReducedBinaryComYparisonLessThen() {\n+        // i < -5/6\n+        doTestBinaryComparisonReduction(\"12 * (-int / 5) > (8 + 12) / 10\", LessThan.class, -5d / 6);\n+    }\n+\n+    public void testReducedBinaryComYparisonNotEquals() {\n+        // i != 7000\n+        doTestBinaryComparisonReduction(\"-3600 != (int - 200) / 2\", NotEquals.class, -7000);\n+    }\n+\n+    public void testReducedBinaryComparisonEquals() {\n+        // i = -12\n+        doTestBinaryComparisonReduction(\"2 * 3 / (4 / -int) = 18\", Equals.class, -12d);\n+    }\n+\n+    public void testReducedBinaryComparisonWithConjunction() {\n+        doTestBinaryComparisonReduction(\"2 * 3 / (4 / -int) = 18 AND int >= -12\", Equals.class, -12d);\n+    }\n+\n+    public void testReducedBinaryComparisonWithDisjunction() {\n+        doTestBinaryComparisonReduction(\"2 * 3 / (4 / -int) = 18 OR int > -12\", GreaterThanOrEqual.class, -12d);\n+    }\n+\n+    private void doTestBinaryComparisonReduction(String expression, Class<? extends BinaryComparison> binaryComparisonClass,\n+                                                 Number bound) {\n+        LogicalPlan plan = plan(\"SELECT some.string FROM test WHERE \" + expression);\n+\n+        assertTrue(plan instanceof UnaryPlan);\n+        UnaryPlan unaryPlan = (UnaryPlan) plan;\n+        assertTrue(unaryPlan.child() instanceof Filter);\n+        Filter filter = (Filter) unaryPlan.child();\n+        assertEquals(binaryComparisonClass, filter.condition().getClass());\n+        BinaryComparison bc = (BinaryComparison) filter.condition();\n+\n+        assertTrue(bc.left() instanceof FieldAttribute);\n+        FieldAttribute attribute = (FieldAttribute) bc.left();\n+        assertEquals(\"int\", attribute.name());\n+\n+        assertTrue(bc.right() instanceof Literal);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0db90e4457b32e85954126ec5a565850661b0535"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjI0MDE3Mg==", "bodyText": "I've employed parser.createExpression(), thanks.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r542240172", "createdAt": "2020-12-14T09:37:57Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/optimizer/OptimizerRunTests.java", "diffHunk": "@@ -48,4 +57,57 @@ public void testWhereClause() {\n         LogicalPlan p = plan(\"SELECT some.string l FROM test WHERE int IS NOT NULL AND int < 10005 ORDER BY int\");\n         assertNotNull(p);\n     }\n-}\n\\ No newline at end of file\n+\n+    public void testReducedBinaryComparisonGreaterThenOrEqual() {\n+        // i >= 12\n+        doTestBinaryComparisonReduction(\"((int + 1) / 2 - 3) * 4 >= 14\", GreaterThanOrEqual.class, 12d);\n+    }\n+\n+    public void testReducedBinaryComYparisonLessThen() {\n+        // i < -5/6\n+        doTestBinaryComparisonReduction(\"12 * (-int / 5) > (8 + 12) / 10\", LessThan.class, -5d / 6);\n+    }\n+\n+    public void testReducedBinaryComYparisonNotEquals() {\n+        // i != 7000\n+        doTestBinaryComparisonReduction(\"-3600 != (int - 200) / 2\", NotEquals.class, -7000);\n+    }\n+\n+    public void testReducedBinaryComparisonEquals() {\n+        // i = -12\n+        doTestBinaryComparisonReduction(\"2 * 3 / (4 / -int) = 18\", Equals.class, -12d);\n+    }\n+\n+    public void testReducedBinaryComparisonWithConjunction() {\n+        doTestBinaryComparisonReduction(\"2 * 3 / (4 / -int) = 18 AND int >= -12\", Equals.class, -12d);\n+    }\n+\n+    public void testReducedBinaryComparisonWithDisjunction() {\n+        doTestBinaryComparisonReduction(\"2 * 3 / (4 / -int) = 18 OR int > -12\", GreaterThanOrEqual.class, -12d);\n+    }\n+\n+    private void doTestBinaryComparisonReduction(String expression, Class<? extends BinaryComparison> binaryComparisonClass,\n+                                                 Number bound) {\n+        LogicalPlan plan = plan(\"SELECT some.string FROM test WHERE \" + expression);\n+\n+        assertTrue(plan instanceof UnaryPlan);\n+        UnaryPlan unaryPlan = (UnaryPlan) plan;\n+        assertTrue(unaryPlan.child() instanceof Filter);\n+        Filter filter = (Filter) unaryPlan.child();\n+        assertEquals(binaryComparisonClass, filter.condition().getClass());\n+        BinaryComparison bc = (BinaryComparison) filter.condition();\n+\n+        assertTrue(bc.left() instanceof FieldAttribute);\n+        FieldAttribute attribute = (FieldAttribute) bc.left();\n+        assertEquals(\"int\", attribute.name());\n+\n+        assertTrue(bc.right() instanceof Literal);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQzNzEzNw=="}, "originalCommit": {"oid": "0db90e4457b32e85954126ec5a565850661b0535"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MDM4MDk0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/optimizer/OptimizerRunTests.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNDozNzoxNFrOIBf5rA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQwOTozODowMVrOIFHt0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQ0MjE1Ng==", "bodyText": "I'd like to see more tests that the behavior regarding commutative vs non-commutative expressions:\na + 2 > 3\n2 + a > 3\na - 2 > 3\n2 - a > 3\na * 2 > 3\n2 * a > 3\na / 2 > 3\n2 / a > 3\n1 / (a - 2) > 3\n1 / (2 - a) > 3\n1 / (2 + (2 - a) > 3", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r538442156", "createdAt": "2020-12-08T14:37:14Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/optimizer/OptimizerRunTests.java", "diffHunk": "@@ -48,4 +57,57 @@ public void testWhereClause() {\n         LogicalPlan p = plan(\"SELECT some.string l FROM test WHERE int IS NOT NULL AND int < 10005 ORDER BY int\");\n         assertNotNull(p);\n     }\n-}\n\\ No newline at end of file\n+\n+    public void testReducedBinaryComparisonGreaterThenOrEqual() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0db90e4457b32e85954126ec5a565850661b0535"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjI0MDIwOQ==", "bodyText": "Added all these tests.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r542240209", "createdAt": "2020-12-14T09:38:01Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/optimizer/OptimizerRunTests.java", "diffHunk": "@@ -48,4 +57,57 @@ public void testWhereClause() {\n         LogicalPlan p = plan(\"SELECT some.string l FROM test WHERE int IS NOT NULL AND int < 10005 ORDER BY int\");\n         assertNotNull(p);\n     }\n-}\n\\ No newline at end of file\n+\n+    public void testReducedBinaryComparisonGreaterThenOrEqual() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQ0MjE1Ng=="}, "originalCommit": {"oid": "0db90e4457b32e85954126ec5a565850661b0535"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MDM5NzQ0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNDozOTozMlrOIBgD_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQwOTozODoxNFrOIFHubg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQ0NDc5Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (e instanceof BinaryComparison) {\n          \n          \n            \n                            return reduce((BinaryComparison) e);\n          \n          \n            \n                        }\n          \n          \n            \n                        return e;\n          \n          \n            \n                        if (e instanceof BinaryComparison) {\n          \n          \n            \n                            e = reduce((BinaryComparison) e);\n          \n          \n            \n                        }\n          \n          \n            \n                        return e;", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r538444797", "createdAt": "2020-12-08T14:39:32Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1141,49 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    public static final class SimplifyArithmeticsInBinaryComparisons extends OptimizerExpressionRule {\n+\n+        public SimplifyArithmeticsInBinaryComparisons() {\n+            super(TransformDirection.UP);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof BinaryComparison) {\n+                return reduce((BinaryComparison) e);\n+            }\n+            return e;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0db90e4457b32e85954126ec5a565850661b0535"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjI0MDM2Ng==", "bodyText": "Refactored.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r542240366", "createdAt": "2020-12-14T09:38:14Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1141,49 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    public static final class SimplifyArithmeticsInBinaryComparisons extends OptimizerExpressionRule {\n+\n+        public SimplifyArithmeticsInBinaryComparisons() {\n+            super(TransformDirection.UP);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof BinaryComparison) {\n+                return reduce((BinaryComparison) e);\n+            }\n+            return e;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQ0NDc5Nw=="}, "originalCommit": {"oid": "0db90e4457b32e85954126ec5a565850661b0535"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MDQwNDg2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNDo0MDo0M1rOIBgIsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQwOTozODoyN1rOIFHvIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQ0NjAwMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        // optimize only once the expression looks like: AnyNode [ArithmOp] AnyNode [BiComp] Literal\n          \n          \n            \n                        // optimize only once the expression looks like `Expression [ArithmeticOp] Expression [BinaryComp] Literal`", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r538446002", "createdAt": "2020-12-08T14:40:43Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1141,49 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    public static final class SimplifyArithmeticsInBinaryComparisons extends OptimizerExpressionRule {\n+\n+        public SimplifyArithmeticsInBinaryComparisons() {\n+            super(TransformDirection.UP);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof BinaryComparison) {\n+                return reduce((BinaryComparison) e);\n+            }\n+            return e;\n+        }\n+\n+        private Expression reduce(BinaryComparison bc) {\n+            // optimize only once the expression looks like: AnyNode [ArithmOp] AnyNode [BiComp] Literal", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0db90e4457b32e85954126ec5a565850661b0535"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjI0MDU0NA==", "bodyText": "Rephrased.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r542240544", "createdAt": "2020-12-14T09:38:27Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1141,49 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    public static final class SimplifyArithmeticsInBinaryComparisons extends OptimizerExpressionRule {\n+\n+        public SimplifyArithmeticsInBinaryComparisons() {\n+            super(TransformDirection.UP);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof BinaryComparison) {\n+                return reduce((BinaryComparison) e);\n+            }\n+            return e;\n+        }\n+\n+        private Expression reduce(BinaryComparison bc) {\n+            // optimize only once the expression looks like: AnyNode [ArithmOp] AnyNode [BiComp] Literal", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQ0NjAwMg=="}, "originalCommit": {"oid": "0db90e4457b32e85954126ec5a565850661b0535"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MDQ3ODA4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNDo1MTozMlrOIBg26Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQwOTozODo0MlrOIFHvzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQ1NzgzMw==", "bodyText": "Try to avoid using strings for type matching. Assuming there's no other either way move use a string reference to indicate its source, such as DefaultBinaryArithmeticOperation.MUL.symbol() instead of *.\nAlso please add some comments to explain what's going on - if the symbol is Mul, force double division by promoting the right literal to a double?", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r538457833", "createdAt": "2020-12-08T14:51:32Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1141,49 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    public static final class SimplifyArithmeticsInBinaryComparisons extends OptimizerExpressionRule {\n+\n+        public SimplifyArithmeticsInBinaryComparisons() {\n+            super(TransformDirection.UP);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof BinaryComparison) {\n+                return reduce((BinaryComparison) e);\n+            }\n+            return e;\n+        }\n+\n+        private Expression reduce(BinaryComparison bc) {\n+            // optimize only once the expression looks like: AnyNode [ArithmOp] AnyNode [BiComp] Literal\n+            if (bc.right() instanceof Literal == false) {\n+                return bc;\n+            }\n+            Literal bcRight = (Literal) bc.right();\n+\n+            if (bc.left() instanceof ArithmeticOperation) {\n+                ArithmeticOperation opLeft = (ArithmeticOperation) bc.left();\n+                if (opLeft instanceof Mod) {\n+                    return bc; // can't optimise Mods\n+                }\n+\n+                if (opLeft.left() instanceof Literal || opLeft.right() instanceof Literal) { // 5 [op] a >= 4 || a [op] 5 >= 4\n+                    // force double division\n+                    if (opLeft.symbol().equals(\"*\")) { // use symbol comp for SQL's Mul", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0db90e4457b32e85954126ec5a565850661b0535"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjI0MDcxNw==", "bodyText": "such as DefaultBinaryArithmeticOperation.MUL.symbol() instead of *.\n\nThanks, fixed.\n\nif the symbol is Mul, force double division by promoting the right literal to a double?\n\nYes, that was the logic. But this got now removed, as a potentially unsafe optimisation.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r542240717", "createdAt": "2020-12-14T09:38:42Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1141,49 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    public static final class SimplifyArithmeticsInBinaryComparisons extends OptimizerExpressionRule {\n+\n+        public SimplifyArithmeticsInBinaryComparisons() {\n+            super(TransformDirection.UP);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof BinaryComparison) {\n+                return reduce((BinaryComparison) e);\n+            }\n+            return e;\n+        }\n+\n+        private Expression reduce(BinaryComparison bc) {\n+            // optimize only once the expression looks like: AnyNode [ArithmOp] AnyNode [BiComp] Literal\n+            if (bc.right() instanceof Literal == false) {\n+                return bc;\n+            }\n+            Literal bcRight = (Literal) bc.right();\n+\n+            if (bc.left() instanceof ArithmeticOperation) {\n+                ArithmeticOperation opLeft = (ArithmeticOperation) bc.left();\n+                if (opLeft instanceof Mod) {\n+                    return bc; // can't optimise Mods\n+                }\n+\n+                if (opLeft.left() instanceof Literal || opLeft.right() instanceof Literal) { // 5 [op] a >= 4 || a [op] 5 >= 4\n+                    // force double division\n+                    if (opLeft.symbol().equals(\"*\")) { // use symbol comp for SQL's Mul", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQ1NzgzMw=="}, "originalCommit": {"oid": "0db90e4457b32e85954126ec5a565850661b0535"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MTM4NTA1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNzowMTozMVrOIBp3DQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQwOTozODo1MVrOIFHwJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODYwNTMyNQ==", "bodyText": "Precision loss might cause some issues here. a + b == c is mathematically the same as a == c - b, except when you take into account the potential precision loss.\nFor example:\na = 1.0E-15\nb = 1.0E15\nc = 1.0E15\n\na + b == c\n1.0E-15 + 1.0E15 == 1.0E15\n1.0E15 == 1.0E15\ntrue\n\na == c - b\n1.0E-15 == 1.0E15 - 1.0E15\n1.0E-15 == 0.0\nfalse\n\nSo even though the query before and after the optimization might be mathematically equivalent, it still won't return the same result after the optimization is applied. This might have unintended consequences after a version upgrade. I think we should discuss this before moving ahead with the PR.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r538605325", "createdAt": "2020-12-08T17:01:31Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1141,49 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    public static final class SimplifyArithmeticsInBinaryComparisons extends OptimizerExpressionRule {\n+\n+        public SimplifyArithmeticsInBinaryComparisons() {\n+            super(TransformDirection.UP);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof BinaryComparison) {\n+                return reduce((BinaryComparison) e);\n+            }\n+            return e;\n+        }\n+\n+        private Expression reduce(BinaryComparison bc) {\n+            // optimize only once the expression looks like: AnyNode [ArithmOp] AnyNode [BiComp] Literal\n+            if (bc.right() instanceof Literal == false) {\n+                return bc;\n+            }\n+            Literal bcRight = (Literal) bc.right();\n+\n+            if (bc.left() instanceof ArithmeticOperation) {\n+                ArithmeticOperation opLeft = (ArithmeticOperation) bc.left();\n+                if (opLeft instanceof Mod) {\n+                    return bc; // can't optimise Mods\n+                }\n+\n+                if (opLeft.left() instanceof Literal || opLeft.right() instanceof Literal) { // 5 [op] a >= 4 || a [op] 5 >= 4\n+                    // force double division\n+                    if (opLeft.symbol().equals(\"*\")) { // use symbol comp for SQL's Mul\n+                        bcRight = new Literal(bcRight.source(), ((Number) bcRight.value()).doubleValue(), DOUBLE);\n+                    }\n+                    return bc.replaceChildren(List.of(opLeft.left(), opLeft.inverse(bcRight.source(), bcRight, opLeft.right())));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0db90e4457b32e85954126ec5a565850661b0535"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjI0MDgwNA==", "bodyText": "Thanks, good point. Addressed, along with the similar DIV/MUL concern.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r542240804", "createdAt": "2020-12-14T09:38:51Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1141,49 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    public static final class SimplifyArithmeticsInBinaryComparisons extends OptimizerExpressionRule {\n+\n+        public SimplifyArithmeticsInBinaryComparisons() {\n+            super(TransformDirection.UP);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof BinaryComparison) {\n+                return reduce((BinaryComparison) e);\n+            }\n+            return e;\n+        }\n+\n+        private Expression reduce(BinaryComparison bc) {\n+            // optimize only once the expression looks like: AnyNode [ArithmOp] AnyNode [BiComp] Literal\n+            if (bc.right() instanceof Literal == false) {\n+                return bc;\n+            }\n+            Literal bcRight = (Literal) bc.right();\n+\n+            if (bc.left() instanceof ArithmeticOperation) {\n+                ArithmeticOperation opLeft = (ArithmeticOperation) bc.left();\n+                if (opLeft instanceof Mod) {\n+                    return bc; // can't optimise Mods\n+                }\n+\n+                if (opLeft.left() instanceof Literal || opLeft.right() instanceof Literal) { // 5 [op] a >= 4 || a [op] 5 >= 4\n+                    // force double division\n+                    if (opLeft.symbol().equals(\"*\")) { // use symbol comp for SQL's Mul\n+                        bcRight = new Literal(bcRight.source(), ((Number) bcRight.value()).doubleValue(), DOUBLE);\n+                    }\n+                    return bc.replaceChildren(List.of(opLeft.left(), opLeft.inverse(bcRight.source(), bcRight, opLeft.right())));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODYwNTMyNQ=="}, "originalCommit": {"oid": "0db90e4457b32e85954126ec5a565850661b0535"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MTQwMzUyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/optimizer/OptimizerRunTests.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNzowNDoxN1rOIBqDBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQwOTozODo1OVrOIFHweg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODYwODM4OA==", "bodyText": "I would add some tests for testing with numbers where overflow or precision loss can occur.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r538608388", "createdAt": "2020-12-08T17:04:17Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/optimizer/OptimizerRunTests.java", "diffHunk": "@@ -48,4 +57,57 @@ public void testWhereClause() {\n         LogicalPlan p = plan(\"SELECT some.string l FROM test WHERE int IS NOT NULL AND int < 10005 ORDER BY int\");\n         assertNotNull(p);\n     }\n-}\n\\ No newline at end of file\n+\n+    public void testReducedBinaryComparisonGreaterThenOrEqual() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0db90e4457b32e85954126ec5a565850661b0535"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjI0MDg5MA==", "bodyText": "I've added more tests.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r542240890", "createdAt": "2020-12-14T09:38:59Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/optimizer/OptimizerRunTests.java", "diffHunk": "@@ -48,4 +57,57 @@ public void testWhereClause() {\n         LogicalPlan p = plan(\"SELECT some.string l FROM test WHERE int IS NOT NULL AND int < 10005 ORDER BY int\");\n         assertNotNull(p);\n     }\n-}\n\\ No newline at end of file\n+\n+    public void testReducedBinaryComparisonGreaterThenOrEqual() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODYwODM4OA=="}, "originalCommit": {"oid": "0db90e4457b32e85954126ec5a565850661b0535"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMTg1OTcxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/operator/arithmetic/ArithmeticOperation.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxNzo1NzowMlrOIIs7VA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxNjo1MzowN1rOIP0DXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTk5NTYwNA==", "bodyText": "Why not mark it as abstract? In case we add a new operation, silently using this inverse might have unintended consequences, while with abstract the compiler will force you to think about it.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r545995604", "createdAt": "2020-12-18T17:57:02Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/operator/arithmetic/ArithmeticOperation.java", "diffHunk": "@@ -45,4 +45,11 @@ public DataType dataType() {\n     protected Pipe makePipe() {\n         return new BinaryArithmeticPipe(source(), this, Expressions.pipe(left()), Expressions.pipe(right()), function());\n     }\n+\n+    /**\n+     * Returns the opposite of this operation.\n+     */\n+    public ArithmeticOperation inverse(Source source, Expression left, Expression right) {\n+        return this;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ1MjM4Mg==", "bodyText": "This had been implemented as abstract initially (and have Mod throw an exception, as you were also proposing below), but got refactored not to throw an exception (see #66022 (comment)).\nAnd after #66022 (comment) it got a second refactoring, as that comment addresses the approach.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r553452382", "createdAt": "2021-01-07T16:53:07Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/operator/arithmetic/ArithmeticOperation.java", "diffHunk": "@@ -45,4 +45,11 @@ public DataType dataType() {\n     protected Pipe makePipe() {\n         return new BinaryArithmeticPipe(source(), this, Expressions.pipe(left()), Expressions.pipe(right()), function());\n     }\n+\n+    /**\n+     * Returns the opposite of this operation.\n+     */\n+    public ArithmeticOperation inverse(Source source, Expression left, Expression right) {\n+        return this;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTk5NTYwNA=="}, "originalCommit": {"oid": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMTkzNTgwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxODoxODoyNVrOIIto9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxNjo1MzoxMlrOIP0Djg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAwNzI4NQ==", "bodyText": "Extract symbol check into a separate function.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (child instanceof ArithmeticOperation) {\n          \n          \n            \n                                ArithmeticOperation operation = (ArithmeticOperation) child;\n          \n          \n            \n                                String opSymbol = operation.symbol();\n          \n          \n            \n                                if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n          \n          \n            \n                            if (isMulOrDiv(child)) {\n          \n          \n            \n                                ArithmeticOperation operation = (ArithmeticOperation) child;", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r546007285", "createdAt": "2020-12-18T18:18:25Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1148,235 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    public static final class BubbleUpNegations extends OptimizerExpressionRule {\n+\n+        public BubbleUpNegations() {\n+            super(TransformDirection.DOWN);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof Neg) { // cancels out NEG - MUL/DIV - NEG - x ==> MUL/DIV - x\n+                Expression child = e.children().get(0);\n+                if (child instanceof ArithmeticOperation) {\n+                    ArithmeticOperation operation = (ArithmeticOperation) child;\n+                    String opSymbol = operation.symbol();\n+                    if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ1MjQzMA==", "bodyText": "Extracted, thanks.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r553452430", "createdAt": "2021-01-07T16:53:12Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1148,235 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    public static final class BubbleUpNegations extends OptimizerExpressionRule {\n+\n+        public BubbleUpNegations() {\n+            super(TransformDirection.DOWN);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof Neg) { // cancels out NEG - MUL/DIV - NEG - x ==> MUL/DIV - x\n+                Expression child = e.children().get(0);\n+                if (child instanceof ArithmeticOperation) {\n+                    ArithmeticOperation operation = (ArithmeticOperation) child;\n+                    String opSymbol = operation.symbol();\n+                    if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAwNzI4NQ=="}, "originalCommit": {"oid": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMTk0MjE1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxODoyMDowNFrOIIts8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxNjo1MzoxNVrOIP0Dtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAwODMwNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        } else if (e instanceof ArithmeticOperation) { // pulls up MUL/DIV - NEG - x ==> NEG - MUL/DIV - x\n          \n          \n            \n                            ArithmeticOperation operation = (ArithmeticOperation) e;\n          \n          \n            \n                            String opSymbol = operation.symbol();\n          \n          \n            \n                            if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n          \n          \n            \n                        } else if (isMulOrDiv(e)) { // pulls up MUL/DIV - NEG - x ==> NEG - MUL/DIV - x\n          \n          \n            \n                            ArithmeticOperation operation = (ArithmeticOperation) e;", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r546008307", "createdAt": "2020-12-18T18:20:04Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1148,235 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    public static final class BubbleUpNegations extends OptimizerExpressionRule {\n+\n+        public BubbleUpNegations() {\n+            super(TransformDirection.DOWN);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof Neg) { // cancels out NEG - MUL/DIV - NEG - x ==> MUL/DIV - x\n+                Expression child = e.children().get(0);\n+                if (child instanceof ArithmeticOperation) {\n+                    ArithmeticOperation operation = (ArithmeticOperation) child;\n+                    String opSymbol = operation.symbol();\n+                    if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n+                        if (operation.left() instanceof Neg) {\n+                            return operation.replaceChildren(List.of(operation.left().children().get(0), operation.right()));\n+                        }\n+                        if (operation.right() instanceof Neg) {\n+                            return operation.replaceChildren(List.of(operation.left(), operation.right().children().get(0)));\n+                        }\n+                    }\n+                }\n+            } else if (e instanceof ArithmeticOperation) { // pulls up MUL/DIV - NEG - x ==> NEG - MUL/DIV - x\n+                ArithmeticOperation operation = (ArithmeticOperation) e;\n+                String opSymbol = operation.symbol();\n+                if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ1MjQ3MA==", "bodyText": "Fixed.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r553452470", "createdAt": "2021-01-07T16:53:15Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1148,235 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    public static final class BubbleUpNegations extends OptimizerExpressionRule {\n+\n+        public BubbleUpNegations() {\n+            super(TransformDirection.DOWN);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof Neg) { // cancels out NEG - MUL/DIV - NEG - x ==> MUL/DIV - x\n+                Expression child = e.children().get(0);\n+                if (child instanceof ArithmeticOperation) {\n+                    ArithmeticOperation operation = (ArithmeticOperation) child;\n+                    String opSymbol = operation.symbol();\n+                    if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n+                        if (operation.left() instanceof Neg) {\n+                            return operation.replaceChildren(List.of(operation.left().children().get(0), operation.right()));\n+                        }\n+                        if (operation.right() instanceof Neg) {\n+                            return operation.replaceChildren(List.of(operation.left(), operation.right().children().get(0)));\n+                        }\n+                    }\n+                }\n+            } else if (e instanceof ArithmeticOperation) { // pulls up MUL/DIV - NEG - x ==> NEG - MUL/DIV - x\n+                ArithmeticOperation operation = (ArithmeticOperation) e;\n+                String opSymbol = operation.symbol();\n+                if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAwODMwNw=="}, "originalCommit": {"oid": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMTk1ODA0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxODoyNDo0NVrOIIt2cQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxNjo1MzoyOFrOIP0EKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAxMDczNw==", "bodyText": "I would use the field() method that already abstracts out the children access.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        return operation.replaceChildren(List.of(operation.left().children().get(0), operation.right()));\n          \n          \n            \n                                        return operation.replaceChildren(List.of(((Neg)operation.left()).field(), operation.right()));", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r546010737", "createdAt": "2020-12-18T18:24:45Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1148,235 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    public static final class BubbleUpNegations extends OptimizerExpressionRule {\n+\n+        public BubbleUpNegations() {\n+            super(TransformDirection.DOWN);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof Neg) { // cancels out NEG - MUL/DIV - NEG - x ==> MUL/DIV - x\n+                Expression child = e.children().get(0);\n+                if (child instanceof ArithmeticOperation) {\n+                    ArithmeticOperation operation = (ArithmeticOperation) child;\n+                    String opSymbol = operation.symbol();\n+                    if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n+                        if (operation.left() instanceof Neg) {\n+                            return operation.replaceChildren(List.of(operation.left().children().get(0), operation.right()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ1MjU4NQ==", "bodyText": "Good point, thanks.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r553452585", "createdAt": "2021-01-07T16:53:28Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1148,235 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    public static final class BubbleUpNegations extends OptimizerExpressionRule {\n+\n+        public BubbleUpNegations() {\n+            super(TransformDirection.DOWN);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof Neg) { // cancels out NEG - MUL/DIV - NEG - x ==> MUL/DIV - x\n+                Expression child = e.children().get(0);\n+                if (child instanceof ArithmeticOperation) {\n+                    ArithmeticOperation operation = (ArithmeticOperation) child;\n+                    String opSymbol = operation.symbol();\n+                    if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n+                        if (operation.left() instanceof Neg) {\n+                            return operation.replaceChildren(List.of(operation.left().children().get(0), operation.right()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAxMDczNw=="}, "originalCommit": {"oid": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMTk2MTIzOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxODoyNTo0NFrOIIt4cA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxNjo1MzozMlrOIP0ETA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAxMTI0OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    if (operation.right() instanceof Neg) {\n          \n          \n            \n                                        return operation.replaceChildren(List.of(operation.left(), operation.right().children().get(0)));\n          \n          \n            \n                                    }\n          \n          \n            \n                                    if (operation.right() instanceof Neg) {\n          \n          \n            \n                                        return operation.replaceChildren(List.of(operation.left(), ((Neg)operation.right()).field()));\n          \n          \n            \n                                    }", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r546011248", "createdAt": "2020-12-18T18:25:44Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1148,235 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    public static final class BubbleUpNegations extends OptimizerExpressionRule {\n+\n+        public BubbleUpNegations() {\n+            super(TransformDirection.DOWN);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof Neg) { // cancels out NEG - MUL/DIV - NEG - x ==> MUL/DIV - x\n+                Expression child = e.children().get(0);\n+                if (child instanceof ArithmeticOperation) {\n+                    ArithmeticOperation operation = (ArithmeticOperation) child;\n+                    String opSymbol = operation.symbol();\n+                    if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n+                        if (operation.left() instanceof Neg) {\n+                            return operation.replaceChildren(List.of(operation.left().children().get(0), operation.right()));\n+                        }\n+                        if (operation.right() instanceof Neg) {\n+                            return operation.replaceChildren(List.of(operation.left(), operation.right().children().get(0)));\n+                        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ1MjYyMA==", "bodyText": "Fixed.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r553452620", "createdAt": "2021-01-07T16:53:32Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1148,235 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    public static final class BubbleUpNegations extends OptimizerExpressionRule {\n+\n+        public BubbleUpNegations() {\n+            super(TransformDirection.DOWN);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof Neg) { // cancels out NEG - MUL/DIV - NEG - x ==> MUL/DIV - x\n+                Expression child = e.children().get(0);\n+                if (child instanceof ArithmeticOperation) {\n+                    ArithmeticOperation operation = (ArithmeticOperation) child;\n+                    String opSymbol = operation.symbol();\n+                    if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n+                        if (operation.left() instanceof Neg) {\n+                            return operation.replaceChildren(List.of(operation.left().children().get(0), operation.right()));\n+                        }\n+                        if (operation.right() instanceof Neg) {\n+                            return operation.replaceChildren(List.of(operation.left(), operation.right().children().get(0)));\n+                        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAxMTI0OA=="}, "originalCommit": {"oid": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMTk3Mjc1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxODoyODo1M1rOIIt_KQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxNjo1MzozNVrOIP0Edw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAxMjk2OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    Neg neg = (Neg) operation.left();\n          \n          \n            \n                                    return new Neg(operation.source(), operation.replaceChildren(List.of(neg.children().get(0), operation.right())));\n          \n          \n            \n                                    Expression newLeft = ((Neg) operation.left()).field();\n          \n          \n            \n                                    return new Neg(operation.source(), operation.replaceChildren(List.of(newLeft, operation.right())));", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r546012969", "createdAt": "2020-12-18T18:28:53Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1148,235 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    public static final class BubbleUpNegations extends OptimizerExpressionRule {\n+\n+        public BubbleUpNegations() {\n+            super(TransformDirection.DOWN);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof Neg) { // cancels out NEG - MUL/DIV - NEG - x ==> MUL/DIV - x\n+                Expression child = e.children().get(0);\n+                if (child instanceof ArithmeticOperation) {\n+                    ArithmeticOperation operation = (ArithmeticOperation) child;\n+                    String opSymbol = operation.symbol();\n+                    if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n+                        if (operation.left() instanceof Neg) {\n+                            return operation.replaceChildren(List.of(operation.left().children().get(0), operation.right()));\n+                        }\n+                        if (operation.right() instanceof Neg) {\n+                            return operation.replaceChildren(List.of(operation.left(), operation.right().children().get(0)));\n+                        }\n+                    }\n+                }\n+            } else if (e instanceof ArithmeticOperation) { // pulls up MUL/DIV - NEG - x ==> NEG - MUL/DIV - x\n+                ArithmeticOperation operation = (ArithmeticOperation) e;\n+                String opSymbol = operation.symbol();\n+                if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n+                    if (operation.left() instanceof Neg) {\n+                        Neg neg = (Neg) operation.left();\n+                        return new Neg(operation.source(), operation.replaceChildren(List.of(neg.children().get(0), operation.right())));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ1MjY2Mw==", "bodyText": "Fixed.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r553452663", "createdAt": "2021-01-07T16:53:35Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1148,235 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    public static final class BubbleUpNegations extends OptimizerExpressionRule {\n+\n+        public BubbleUpNegations() {\n+            super(TransformDirection.DOWN);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof Neg) { // cancels out NEG - MUL/DIV - NEG - x ==> MUL/DIV - x\n+                Expression child = e.children().get(0);\n+                if (child instanceof ArithmeticOperation) {\n+                    ArithmeticOperation operation = (ArithmeticOperation) child;\n+                    String opSymbol = operation.symbol();\n+                    if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n+                        if (operation.left() instanceof Neg) {\n+                            return operation.replaceChildren(List.of(operation.left().children().get(0), operation.right()));\n+                        }\n+                        if (operation.right() instanceof Neg) {\n+                            return operation.replaceChildren(List.of(operation.left(), operation.right().children().get(0)));\n+                        }\n+                    }\n+                }\n+            } else if (e instanceof ArithmeticOperation) { // pulls up MUL/DIV - NEG - x ==> NEG - MUL/DIV - x\n+                ArithmeticOperation operation = (ArithmeticOperation) e;\n+                String opSymbol = operation.symbol();\n+                if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n+                    if (operation.left() instanceof Neg) {\n+                        Neg neg = (Neg) operation.left();\n+                        return new Neg(operation.source(), operation.replaceChildren(List.of(neg.children().get(0), operation.right())));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAxMjk2OQ=="}, "originalCommit": {"oid": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMTk4MTY4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxODozMTozOFrOIIuEjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxNjo1MzozOFrOIP0ElQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAxNDM0OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    Neg neg = (Neg) operation.right();\n          \n          \n            \n                                    return new Neg(operation.source(), operation.replaceChildren(List.of(operation.left(), neg.children().get(0))));\n          \n          \n            \n                                    Expression newRight = ((Neg) operation.right()).field();\n          \n          \n            \n                                    return new Neg(operation.source(), operation.replaceChildren(List.of(operation.left(), newRight)));", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r546014349", "createdAt": "2020-12-18T18:31:38Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1148,235 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    public static final class BubbleUpNegations extends OptimizerExpressionRule {\n+\n+        public BubbleUpNegations() {\n+            super(TransformDirection.DOWN);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof Neg) { // cancels out NEG - MUL/DIV - NEG - x ==> MUL/DIV - x\n+                Expression child = e.children().get(0);\n+                if (child instanceof ArithmeticOperation) {\n+                    ArithmeticOperation operation = (ArithmeticOperation) child;\n+                    String opSymbol = operation.symbol();\n+                    if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n+                        if (operation.left() instanceof Neg) {\n+                            return operation.replaceChildren(List.of(operation.left().children().get(0), operation.right()));\n+                        }\n+                        if (operation.right() instanceof Neg) {\n+                            return operation.replaceChildren(List.of(operation.left(), operation.right().children().get(0)));\n+                        }\n+                    }\n+                }\n+            } else if (e instanceof ArithmeticOperation) { // pulls up MUL/DIV - NEG - x ==> NEG - MUL/DIV - x\n+                ArithmeticOperation operation = (ArithmeticOperation) e;\n+                String opSymbol = operation.symbol();\n+                if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n+                    if (operation.left() instanceof Neg) {\n+                        Neg neg = (Neg) operation.left();\n+                        return new Neg(operation.source(), operation.replaceChildren(List.of(neg.children().get(0), operation.right())));\n+                    }\n+                    if (operation.right() instanceof Neg) {\n+                        Neg neg = (Neg) operation.right();\n+                        return new Neg(operation.source(), operation.replaceChildren(List.of(operation.left(), neg.children().get(0))));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ1MjY5Mw==", "bodyText": "Fixed.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r553452693", "createdAt": "2021-01-07T16:53:38Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1148,235 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    public static final class BubbleUpNegations extends OptimizerExpressionRule {\n+\n+        public BubbleUpNegations() {\n+            super(TransformDirection.DOWN);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof Neg) { // cancels out NEG - MUL/DIV - NEG - x ==> MUL/DIV - x\n+                Expression child = e.children().get(0);\n+                if (child instanceof ArithmeticOperation) {\n+                    ArithmeticOperation operation = (ArithmeticOperation) child;\n+                    String opSymbol = operation.symbol();\n+                    if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n+                        if (operation.left() instanceof Neg) {\n+                            return operation.replaceChildren(List.of(operation.left().children().get(0), operation.right()));\n+                        }\n+                        if (operation.right() instanceof Neg) {\n+                            return operation.replaceChildren(List.of(operation.left(), operation.right().children().get(0)));\n+                        }\n+                    }\n+                }\n+            } else if (e instanceof ArithmeticOperation) { // pulls up MUL/DIV - NEG - x ==> NEG - MUL/DIV - x\n+                ArithmeticOperation operation = (ArithmeticOperation) e;\n+                String opSymbol = operation.symbol();\n+                if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n+                    if (operation.left() instanceof Neg) {\n+                        Neg neg = (Neg) operation.left();\n+                        return new Neg(operation.source(), operation.replaceChildren(List.of(neg.children().get(0), operation.right())));\n+                    }\n+                    if (operation.right() instanceof Neg) {\n+                        Neg neg = (Neg) operation.right();\n+                        return new Neg(operation.source(), operation.replaceChildren(List.of(operation.left(), neg.children().get(0))));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAxNDM0OQ=="}, "originalCommit": {"oid": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMjAxMjg2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxODo0MToxNFrOIIuXbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxNjo1Mzo1MFrOIP0FPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAxOTE4Mw==", "bodyText": "What about double Neg? Do we already have a rule that changes NEG - NEG - x to x?", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r546019183", "createdAt": "2020-12-18T18:41:14Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1148,235 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    public static final class BubbleUpNegations extends OptimizerExpressionRule {\n+\n+        public BubbleUpNegations() {\n+            super(TransformDirection.DOWN);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ1Mjg2MA==", "bodyText": "Double negation is taken care of by SimplifyComparisonsArithmetics#reduceNegation() -- the point of this rule is really to surface the negations, not necessarily simplify them (which however happens as a by product).\nHowever, at Costin's suggestion I'll extract this rule in separate PR, which clearly warrants having this simplification part of the rule.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r553452860", "createdAt": "2021-01-07T16:53:50Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1148,235 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    public static final class BubbleUpNegations extends OptimizerExpressionRule {\n+\n+        public BubbleUpNegations() {\n+            super(TransformDirection.DOWN);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAxOTE4Mw=="}, "originalCommit": {"oid": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMjExMzk2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxOTowOToxMVrOIIvVSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxNjo1Mzo1NVrOIP0FZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAzNTAxNg==", "bodyText": "Some renaming and inlining would make this easier to read and reason about. The safeMaybeFold is just a really simple try-catch that you kind of mimic with the null check anyways.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    private static Expression reduceNegation(BinaryComparison bc) {\n          \n          \n            \n                        Literal bcLiteral = (Literal) bc.right();\n          \n          \n            \n                        Expression neg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n          \n          \n            \n                        return neg == null ? bc : bc.reverse().replaceChildren(List.of(bc.left().children().get(0), neg));\n          \n          \n            \n                    }\n          \n          \n            \n                    private static Expression reduceNegation(BinaryComparison bc) {\n          \n          \n            \n                        Literal oldRight = (Literal) bc.right();\n          \n          \n            \n                        Neg newRight = new Neg(oldRight.source(), oldRight);\n          \n          \n            \n                        Expression newLeft = ((Neg) bc.left()).field();\n          \n          \n            \n                        try {\n          \n          \n            \n                            newRight = new Literal(newRight.source(), newRight.fold(), newRight.dataType());\n          \n          \n            \n                        } catch (Exception e) {\n          \n          \n            \n                            // cannot optimize the negation, either ArithmeticException or DateTimeException\n          \n          \n            \n                            // but safe to just turn off the optmisation should any exception arise\n          \n          \n            \n                            return bc;\n          \n          \n            \n                        }\n          \n          \n            \n                        return bc.reverse().replaceChildren(List.of(newLeft, newRight));\n          \n          \n            \n                    }", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r546035016", "createdAt": "2020-12-18T19:09:11Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1148,235 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    public static final class BubbleUpNegations extends OptimizerExpressionRule {\n+\n+        public BubbleUpNegations() {\n+            super(TransformDirection.DOWN);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof Neg) { // cancels out NEG - MUL/DIV - NEG - x ==> MUL/DIV - x\n+                Expression child = e.children().get(0);\n+                if (child instanceof ArithmeticOperation) {\n+                    ArithmeticOperation operation = (ArithmeticOperation) child;\n+                    String opSymbol = operation.symbol();\n+                    if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n+                        if (operation.left() instanceof Neg) {\n+                            return operation.replaceChildren(List.of(operation.left().children().get(0), operation.right()));\n+                        }\n+                        if (operation.right() instanceof Neg) {\n+                            return operation.replaceChildren(List.of(operation.left(), operation.right().children().get(0)));\n+                        }\n+                    }\n+                }\n+            } else if (e instanceof ArithmeticOperation) { // pulls up MUL/DIV - NEG - x ==> NEG - MUL/DIV - x\n+                ArithmeticOperation operation = (ArithmeticOperation) e;\n+                String opSymbol = operation.symbol();\n+                if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n+                    if (operation.left() instanceof Neg) {\n+                        Neg neg = (Neg) operation.left();\n+                        return new Neg(operation.source(), operation.replaceChildren(List.of(neg.children().get(0), operation.right())));\n+                    }\n+                    if (operation.right() instanceof Neg) {\n+                        Neg neg = (Neg) operation.right();\n+                        return new Neg(operation.source(), operation.replaceChildren(List.of(operation.left(), neg.children().get(0))));\n+                    }\n+                }\n+            }\n+            return e;\n+        }\n+    }\n+\n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression neg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return neg == null ? bc : bc.reverse().replaceChildren(List.of(bc.left().children().get(0), neg));\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ1MjkwMw==", "bodyText": "safeMaybeFold performs an additional check too and is called from other places too, so I'd personally prefer the existing more compact and code reusing way.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r553452903", "createdAt": "2021-01-07T16:53:55Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1148,235 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    public static final class BubbleUpNegations extends OptimizerExpressionRule {\n+\n+        public BubbleUpNegations() {\n+            super(TransformDirection.DOWN);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof Neg) { // cancels out NEG - MUL/DIV - NEG - x ==> MUL/DIV - x\n+                Expression child = e.children().get(0);\n+                if (child instanceof ArithmeticOperation) {\n+                    ArithmeticOperation operation = (ArithmeticOperation) child;\n+                    String opSymbol = operation.symbol();\n+                    if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n+                        if (operation.left() instanceof Neg) {\n+                            return operation.replaceChildren(List.of(operation.left().children().get(0), operation.right()));\n+                        }\n+                        if (operation.right() instanceof Neg) {\n+                            return operation.replaceChildren(List.of(operation.left(), operation.right().children().get(0)));\n+                        }\n+                    }\n+                }\n+            } else if (e instanceof ArithmeticOperation) { // pulls up MUL/DIV - NEG - x ==> NEG - MUL/DIV - x\n+                ArithmeticOperation operation = (ArithmeticOperation) e;\n+                String opSymbol = operation.symbol();\n+                if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n+                    if (operation.left() instanceof Neg) {\n+                        Neg neg = (Neg) operation.left();\n+                        return new Neg(operation.source(), operation.replaceChildren(List.of(neg.children().get(0), operation.right())));\n+                    }\n+                    if (operation.right() instanceof Neg) {\n+                        Neg neg = (Neg) operation.right();\n+                        return new Neg(operation.source(), operation.replaceChildren(List.of(operation.left(), neg.children().get(0))));\n+                    }\n+                }\n+            }\n+            return e;\n+        }\n+    }\n+\n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression neg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return neg == null ? bc : bc.reverse().replaceChildren(List.of(bc.left().children().get(0), neg));\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAzNTAxNg=="}, "originalCommit": {"oid": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a"}, "originalPosition": 120}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMjIyMDQyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxOTozNzoyOVrOIIwYog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxNjo1NDoxNlrOIP0GJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA1MjI1OA==", "bodyText": "Remove the explicit check on the not handled cases (MUL), just to stay on the safe side in case we add any sort of magic Arithmetic operators (so any possible new operation won't be treated as Add/Sub by default).\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            ArithmeticOperation operation = (ArithmeticOperation) comparison.left();\n          \n          \n            \n                            // Use symbol comp: SQL operations aren't available in this package (as dependencies)\n          \n          \n            \n                            String opSymbol = operation.symbol();\n          \n          \n            \n                            // Modulo can't be simplified.\n          \n          \n            \n                            if (MOD.symbol().equals(opSymbol)) {\n          \n          \n            \n                                return comparison;\n          \n          \n            \n                            }\n          \n          \n            \n                            SimplifyOperation simplification = (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol))\n          \n          \n            \n                                ? new SimplifyMulDiv(comparison)\n          \n          \n            \n                                : new SimplifyAddSub(comparison);\n          \n          \n            \n                            SimplifyOperation simplification = null;\n          \n          \n            \n                            if (isMulOrDiv(comparison.left()) {\n          \n          \n            \n                                simplification = new SimplifyMulDiv(comparison);\n          \n          \n            \n                            } else if (isAddOrSub(comparison.left()) {\n          \n          \n            \n                                simplification = new SimpliAddSub(comparison);\n          \n          \n            \n                            }\n          \n          \n            \n                            if (simplification == null) {\n          \n          \n            \n                                return comparison;\n          \n          \n            \n                            }", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r546052258", "createdAt": "2020-12-18T19:37:29Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1148,235 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    public static final class BubbleUpNegations extends OptimizerExpressionRule {\n+\n+        public BubbleUpNegations() {\n+            super(TransformDirection.DOWN);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof Neg) { // cancels out NEG - MUL/DIV - NEG - x ==> MUL/DIV - x\n+                Expression child = e.children().get(0);\n+                if (child instanceof ArithmeticOperation) {\n+                    ArithmeticOperation operation = (ArithmeticOperation) child;\n+                    String opSymbol = operation.symbol();\n+                    if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n+                        if (operation.left() instanceof Neg) {\n+                            return operation.replaceChildren(List.of(operation.left().children().get(0), operation.right()));\n+                        }\n+                        if (operation.right() instanceof Neg) {\n+                            return operation.replaceChildren(List.of(operation.left(), operation.right().children().get(0)));\n+                        }\n+                    }\n+                }\n+            } else if (e instanceof ArithmeticOperation) { // pulls up MUL/DIV - NEG - x ==> NEG - MUL/DIV - x\n+                ArithmeticOperation operation = (ArithmeticOperation) e;\n+                String opSymbol = operation.symbol();\n+                if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n+                    if (operation.left() instanceof Neg) {\n+                        Neg neg = (Neg) operation.left();\n+                        return new Neg(operation.source(), operation.replaceChildren(List.of(neg.children().get(0), operation.right())));\n+                    }\n+                    if (operation.right() instanceof Neg) {\n+                        Neg neg = (Neg) operation.right();\n+                        return new Neg(operation.source(), operation.replaceChildren(List.of(operation.left(), neg.children().get(0))));\n+                    }\n+                }\n+            }\n+            return e;\n+        }\n+    }\n+\n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression neg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return neg == null ? bc : bc.reverse().replaceChildren(List.of(bc.left().children().get(0), neg));\n+        }\n+\n+        private static Expression safeMaybeFold(Expression expression) {\n+            if (expression.foldable()) {\n+                try {\n+                    expression = new Literal(expression.source(), expression.fold(), expression.dataType());\n+                } catch (Exception e) {\n+                    // could only catch (ArithmeticException | DateTimeException e), but safer to just turn off the optimisation\n+                    // should any exception arise.\n+                    expression = null;\n+                }\n+            }\n+            return expression;\n+        }\n+\n+        private static class SimplifyOperation {\n+            final BinaryComparison comparison;\n+            final Literal bcLiteral;\n+            final ArithmeticOperation operation;\n+            final Expression opLeft;\n+            final Expression opRight;\n+            final Literal opLiteral;\n+\n+            SimplifyOperation(BinaryComparison comparison) {\n+                this.comparison = comparison;\n+                operation = (ArithmeticOperation) comparison.left();\n+                bcLiteral = (Literal) comparison.right();\n+\n+                opLeft = operation.left();\n+                opRight = operation.right();\n+\n+                if (opLeft instanceof Literal) {\n+                    opLiteral = (Literal) opLeft;\n+                } else if (opRight instanceof Literal) {\n+                    opLiteral = (Literal) opRight;\n+                } else {\n+                    opLiteral = null;\n+                }\n+            }\n+\n+            // can it be quickly fast-tracked that the operation can't be reduced?\n+            boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                if (opLiteral == null) {\n+                    // one of the arithm. operands must be a literal, otherwise the operation wouldn't simplify anything\n+                    return true;\n+                }\n+\n+                // Only operations on fixed point literals are supported, since optimizing float point operations can also change the\n+                // outcome of the filtering:\n+                //    x + 1e18 > 1e18::long will yield different results with a field value in [-2^6, 2^6], optimised vs original;\n+                //    x * (1 + 1e-15d) > 1 : same with a field value of (1 - 1e-15d)\n+                // so consequently, int fields optimisation requiring FP arithmetic isn't possible either: (x - 1e-15) * (1 + 1e-15) > 1.\n+                if (opLiteral.dataType().isRational() || bcLiteral.dataType().isRational()) {\n+                    return true;\n+                }\n+\n+                // the Literal will be moved to the right of the comparison, but only if data-compatible with what's there\n+                return typesCompatible.apply(bcLiteral.dataType(), opLiteral.dataType()) == false;\n+            }\n+\n+            Expression doSimplify() {\n+                // force float point folding for FlP field\n+                Literal bcl = operation.dataType().isRational()\n+                    ? Literal.of(bcLiteral, ((Number) bcLiteral.value()).doubleValue())\n+                    : bcLiteral;\n+\n+                Expression bcRightExpression = safeMaybeFold(operation.inverse(bcl.source(), bcl, opRight));\n+                return bcRightExpression == null ? comparison : comparison.replaceChildren(List.of(opLeft, bcRightExpression));\n+            }\n+\n+            static Expression simplify(BinaryComparison comparison, BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                ArithmeticOperation operation = (ArithmeticOperation) comparison.left();\n+                // Use symbol comp: SQL operations aren't available in this package (as dependencies)\n+                String opSymbol = operation.symbol();\n+                // Modulo can't be simplified.\n+                if (MOD.symbol().equals(opSymbol)) {\n+                    return comparison;\n+                }\n+                SimplifyOperation simplification = (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol))\n+                    ? new SimplifyMulDiv(comparison)\n+                    : new SimplifyAddSub(comparison);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a"}, "originalPosition": 200}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ1MzA5NA==", "bodyText": "I was wrongly thinking mostly at SQL (and less at QL) and assuming we won't add operators (without at least breaking these tests), but sure, it absolutely makes sense to expand the check.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r553453094", "createdAt": "2021-01-07T16:54:16Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1148,235 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    public static final class BubbleUpNegations extends OptimizerExpressionRule {\n+\n+        public BubbleUpNegations() {\n+            super(TransformDirection.DOWN);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof Neg) { // cancels out NEG - MUL/DIV - NEG - x ==> MUL/DIV - x\n+                Expression child = e.children().get(0);\n+                if (child instanceof ArithmeticOperation) {\n+                    ArithmeticOperation operation = (ArithmeticOperation) child;\n+                    String opSymbol = operation.symbol();\n+                    if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n+                        if (operation.left() instanceof Neg) {\n+                            return operation.replaceChildren(List.of(operation.left().children().get(0), operation.right()));\n+                        }\n+                        if (operation.right() instanceof Neg) {\n+                            return operation.replaceChildren(List.of(operation.left(), operation.right().children().get(0)));\n+                        }\n+                    }\n+                }\n+            } else if (e instanceof ArithmeticOperation) { // pulls up MUL/DIV - NEG - x ==> NEG - MUL/DIV - x\n+                ArithmeticOperation operation = (ArithmeticOperation) e;\n+                String opSymbol = operation.symbol();\n+                if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n+                    if (operation.left() instanceof Neg) {\n+                        Neg neg = (Neg) operation.left();\n+                        return new Neg(operation.source(), operation.replaceChildren(List.of(neg.children().get(0), operation.right())));\n+                    }\n+                    if (operation.right() instanceof Neg) {\n+                        Neg neg = (Neg) operation.right();\n+                        return new Neg(operation.source(), operation.replaceChildren(List.of(operation.left(), neg.children().get(0))));\n+                    }\n+                }\n+            }\n+            return e;\n+        }\n+    }\n+\n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression neg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return neg == null ? bc : bc.reverse().replaceChildren(List.of(bc.left().children().get(0), neg));\n+        }\n+\n+        private static Expression safeMaybeFold(Expression expression) {\n+            if (expression.foldable()) {\n+                try {\n+                    expression = new Literal(expression.source(), expression.fold(), expression.dataType());\n+                } catch (Exception e) {\n+                    // could only catch (ArithmeticException | DateTimeException e), but safer to just turn off the optimisation\n+                    // should any exception arise.\n+                    expression = null;\n+                }\n+            }\n+            return expression;\n+        }\n+\n+        private static class SimplifyOperation {\n+            final BinaryComparison comparison;\n+            final Literal bcLiteral;\n+            final ArithmeticOperation operation;\n+            final Expression opLeft;\n+            final Expression opRight;\n+            final Literal opLiteral;\n+\n+            SimplifyOperation(BinaryComparison comparison) {\n+                this.comparison = comparison;\n+                operation = (ArithmeticOperation) comparison.left();\n+                bcLiteral = (Literal) comparison.right();\n+\n+                opLeft = operation.left();\n+                opRight = operation.right();\n+\n+                if (opLeft instanceof Literal) {\n+                    opLiteral = (Literal) opLeft;\n+                } else if (opRight instanceof Literal) {\n+                    opLiteral = (Literal) opRight;\n+                } else {\n+                    opLiteral = null;\n+                }\n+            }\n+\n+            // can it be quickly fast-tracked that the operation can't be reduced?\n+            boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                if (opLiteral == null) {\n+                    // one of the arithm. operands must be a literal, otherwise the operation wouldn't simplify anything\n+                    return true;\n+                }\n+\n+                // Only operations on fixed point literals are supported, since optimizing float point operations can also change the\n+                // outcome of the filtering:\n+                //    x + 1e18 > 1e18::long will yield different results with a field value in [-2^6, 2^6], optimised vs original;\n+                //    x * (1 + 1e-15d) > 1 : same with a field value of (1 - 1e-15d)\n+                // so consequently, int fields optimisation requiring FP arithmetic isn't possible either: (x - 1e-15) * (1 + 1e-15) > 1.\n+                if (opLiteral.dataType().isRational() || bcLiteral.dataType().isRational()) {\n+                    return true;\n+                }\n+\n+                // the Literal will be moved to the right of the comparison, but only if data-compatible with what's there\n+                return typesCompatible.apply(bcLiteral.dataType(), opLiteral.dataType()) == false;\n+            }\n+\n+            Expression doSimplify() {\n+                // force float point folding for FlP field\n+                Literal bcl = operation.dataType().isRational()\n+                    ? Literal.of(bcLiteral, ((Number) bcLiteral.value()).doubleValue())\n+                    : bcLiteral;\n+\n+                Expression bcRightExpression = safeMaybeFold(operation.inverse(bcl.source(), bcl, opRight));\n+                return bcRightExpression == null ? comparison : comparison.replaceChildren(List.of(opLeft, bcRightExpression));\n+            }\n+\n+            static Expression simplify(BinaryComparison comparison, BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                ArithmeticOperation operation = (ArithmeticOperation) comparison.left();\n+                // Use symbol comp: SQL operations aren't available in this package (as dependencies)\n+                String opSymbol = operation.symbol();\n+                // Modulo can't be simplified.\n+                if (MOD.symbol().equals(opSymbol)) {\n+                    return comparison;\n+                }\n+                SimplifyOperation simplification = (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol))\n+                    ? new SimplifyMulDiv(comparison)\n+                    : new SimplifyAddSub(comparison);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA1MjI1OA=="}, "originalCommit": {"oid": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a"}, "originalPosition": 200}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMjIzMTg5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/operator/arithmetic/Mod.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxOTo0MToxNVrOIIwffQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxNjo1NDoyNlrOIP0GoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA1NDAxMw==", "bodyText": "I think the inverse should throw an exception in this class.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r546054013", "createdAt": "2020-12-18T19:41:15Z", "author": {"login": "palesz"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/operator/arithmetic/Mod.java", "diffHunk": "@@ -12,7 +12,7 @@\n /**\n  * <a href=\"https://en.wikipedia.org/wiki/Modulo_operation\">Modulo</a>\n  * function ({@code a % b}).\n- * \n+ *\n  * Note this operator is also registered as a function (needed for ODBC/SQL) purposes.\n  */\n public class Mod extends ArithmeticOperation {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ1MzIxNg==", "bodyText": "See above comment.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r553453216", "createdAt": "2021-01-07T16:54:26Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/operator/arithmetic/Mod.java", "diffHunk": "@@ -12,7 +12,7 @@\n /**\n  * <a href=\"https://en.wikipedia.org/wiki/Modulo_operation\">Modulo</a>\n  * function ({@code a % b}).\n- * \n+ *\n  * Note this operator is also registered as a function (needed for ODBC/SQL) purposes.\n  */\n public class Mod extends ArithmeticOperation {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA1NDAxMw=="}, "originalCommit": {"oid": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NDIzNTg4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/test/resources/queryfolder_tests.txt", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNTozOTo1M1rOIOcGlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxNjo1NDozMlrOIP0G3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjAxMTQxMw==", "bodyText": "Why were these values changed? I assume it's about checking the limit however why not add new tests instead of modifying the existing ones?", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r552011413", "createdAt": "2021-01-05T15:39:53Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/test/resources/queryfolder_tests.txt", "diffHunk": "@@ -454,35 +454,35 @@ process where wildcard(process_path, \"*\\\\red_ttp\\\\wininit.*\", \"*\\\\abc\\\\*\", \"*def\n \n \n addOperator\n-process where serial_event_id + 2 == 41\n+process where serial_event_id + 2 == -2147483647", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ1MzI3OA==", "bodyText": "They were changed so that the arithmetics optimisation won't kick in and so that the scripted translation can still be verified by the test (the new values would cause an overflow if optimised).", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r553453278", "createdAt": "2021-01-07T16:54:32Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/eql/src/test/resources/queryfolder_tests.txt", "diffHunk": "@@ -454,35 +454,35 @@ process where wildcard(process_path, \"*\\\\red_ttp\\\\wininit.*\", \"*\\\\abc\\\\*\", \"*def\n \n \n addOperator\n-process where serial_event_id + 2 == 41\n+process where serial_event_id + 2 == -2147483647", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjAxMTQxMw=="}, "originalCommit": {"oid": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NDI0NTM5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/operator/arithmetic/ArithmeticOperation.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNTo0MjoxOFrOIOcMmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxNjo1NDo0MVrOIP0HMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjAxMjk1NA==", "bodyText": "What does opposite mean? And why is the opposite called inverse?\nFurther more is a bit of a stretch to define this method on the current instance - from what I can tell this method is about finding the method opposite operation for the given operation WITHOUT reusing its arguments. That is this is about Add not Add(3,1).\nThis can be better conveyed by returning a BiFunction and thus returning a Factory instead of the final product or moving somewhere else considering you pass a Source object as well.\nThe result also might not be an ArithmeticOperation, see Mod which is an integral operation and thus something we should strive to support.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r552012954", "createdAt": "2021-01-05T15:42:18Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/operator/arithmetic/ArithmeticOperation.java", "diffHunk": "@@ -45,4 +45,11 @@ public DataType dataType() {\n     protected Pipe makePipe() {\n         return new BinaryArithmeticPipe(source(), this, Expressions.pipe(left()), Expressions.pipe(right()), function());\n     }\n+\n+    /**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ1MzM2MA==", "bodyText": "Indeed, this makes sense, thanks.\nI've removed the inverse() method from the ArithmeticOperation class and added a clearer interface implemented only by those operations that are actually invertible in relation to the binary comparison.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r553453360", "createdAt": "2021-01-07T16:54:41Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/operator/arithmetic/ArithmeticOperation.java", "diffHunk": "@@ -45,4 +45,11 @@ public DataType dataType() {\n     protected Pipe makePipe() {\n         return new BinaryArithmeticPipe(source(), this, Expressions.pipe(left()), Expressions.pipe(right()), function());\n     }\n+\n+    /**", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjAxMjk1NA=="}, "originalCommit": {"oid": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NDI1MDcyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/operator/arithmetic/Add.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNTo0MzozMFrOIOcPyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxNjo1NDo0NFrOIP0HUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjAxMzc2OQ==", "bodyText": "I'm not sure this is correct. Add is a commutative operation but Sub is not. 3 + 1 is the same as 1 +3 but 1 -3 ! 3 - 1.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r552013769", "createdAt": "2021-01-05T15:43:30Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/operator/arithmetic/Add.java", "diffHunk": "@@ -30,4 +30,9 @@ protected Add replaceChildren(Expression left, Expression right) {\n     public Add swapLeftAndRight() {\n         return new Add(source(), right(), left());\n     }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ1MzM5Mg==", "bodyText": "Refactored.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r553453392", "createdAt": "2021-01-07T16:54:44Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/operator/arithmetic/Add.java", "diffHunk": "@@ -30,4 +30,9 @@ protected Add replaceChildren(Expression left, Expression right) {\n     public Add swapLeftAndRight() {\n         return new Add(source(), right(), left());\n     }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjAxMzc2OQ=="}, "originalCommit": {"oid": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NDI5MDM1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNTo1MjozOVrOIOcnqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxNjo1NDo0OFrOIP0HbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjAxOTg4Mg==", "bodyText": "Let's catch just those expections then - otherwise we might catch accidently and swallow other exceptions that we should not.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r552019882", "createdAt": "2021-01-05T15:52:39Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1148,235 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    public static final class BubbleUpNegations extends OptimizerExpressionRule {\n+\n+        public BubbleUpNegations() {\n+            super(TransformDirection.DOWN);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof Neg) { // cancels out NEG - MUL/DIV - NEG - x ==> MUL/DIV - x\n+                Expression child = e.children().get(0);\n+                if (child instanceof ArithmeticOperation) {\n+                    ArithmeticOperation operation = (ArithmeticOperation) child;\n+                    String opSymbol = operation.symbol();\n+                    if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n+                        if (operation.left() instanceof Neg) {\n+                            return operation.replaceChildren(List.of(operation.left().children().get(0), operation.right()));\n+                        }\n+                        if (operation.right() instanceof Neg) {\n+                            return operation.replaceChildren(List.of(operation.left(), operation.right().children().get(0)));\n+                        }\n+                    }\n+                }\n+            } else if (e instanceof ArithmeticOperation) { // pulls up MUL/DIV - NEG - x ==> NEG - MUL/DIV - x\n+                ArithmeticOperation operation = (ArithmeticOperation) e;\n+                String opSymbol = operation.symbol();\n+                if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n+                    if (operation.left() instanceof Neg) {\n+                        Neg neg = (Neg) operation.left();\n+                        return new Neg(operation.source(), operation.replaceChildren(List.of(neg.children().get(0), operation.right())));\n+                    }\n+                    if (operation.right() instanceof Neg) {\n+                        Neg neg = (Neg) operation.right();\n+                        return new Neg(operation.source(), operation.replaceChildren(List.of(operation.left(), neg.children().get(0))));\n+                    }\n+                }\n+            }\n+            return e;\n+        }\n+    }\n+\n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression neg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return neg == null ? bc : bc.reverse().replaceChildren(List.of(bc.left().children().get(0), neg));\n+        }\n+\n+        private static Expression safeMaybeFold(Expression expression) {\n+            if (expression.foldable()) {\n+                try {\n+                    expression = new Literal(expression.source(), expression.fold(), expression.dataType());\n+                } catch (Exception e) {\n+                    // could only catch (ArithmeticException | DateTimeException e), but safer to just turn off the optimisation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ1MzQyMQ==", "bodyText": "Fixed.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r553453421", "createdAt": "2021-01-07T16:54:48Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1148,235 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    public static final class BubbleUpNegations extends OptimizerExpressionRule {\n+\n+        public BubbleUpNegations() {\n+            super(TransformDirection.DOWN);\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            if (e instanceof Neg) { // cancels out NEG - MUL/DIV - NEG - x ==> MUL/DIV - x\n+                Expression child = e.children().get(0);\n+                if (child instanceof ArithmeticOperation) {\n+                    ArithmeticOperation operation = (ArithmeticOperation) child;\n+                    String opSymbol = operation.symbol();\n+                    if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n+                        if (operation.left() instanceof Neg) {\n+                            return operation.replaceChildren(List.of(operation.left().children().get(0), operation.right()));\n+                        }\n+                        if (operation.right() instanceof Neg) {\n+                            return operation.replaceChildren(List.of(operation.left(), operation.right().children().get(0)));\n+                        }\n+                    }\n+                }\n+            } else if (e instanceof ArithmeticOperation) { // pulls up MUL/DIV - NEG - x ==> NEG - MUL/DIV - x\n+                ArithmeticOperation operation = (ArithmeticOperation) e;\n+                String opSymbol = operation.symbol();\n+                if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n+                    if (operation.left() instanceof Neg) {\n+                        Neg neg = (Neg) operation.left();\n+                        return new Neg(operation.source(), operation.replaceChildren(List.of(neg.children().get(0), operation.right())));\n+                    }\n+                    if (operation.right() instanceof Neg) {\n+                        Neg neg = (Neg) operation.right();\n+                        return new Neg(operation.source(), operation.replaceChildren(List.of(operation.left(), neg.children().get(0))));\n+                    }\n+                }\n+            }\n+            return e;\n+        }\n+    }\n+\n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression neg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return neg == null ? bc : bc.reverse().replaceChildren(List.of(bc.left().children().get(0), neg));\n+        }\n+\n+        private static Expression safeMaybeFold(Expression expression) {\n+            if (expression.foldable()) {\n+                try {\n+                    expression = new Literal(expression.source(), expression.fold(), expression.dataType());\n+                } catch (Exception e) {\n+                    // could only catch (ArithmeticException | DateTimeException e), but safer to just turn off the optimisation", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjAxOTg4Mg=="}, "originalCommit": {"oid": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a"}, "originalPosition": 127}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NDMwNzA4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/qa/server/src/main/resources/arithmetic.sql-spec", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNTo1NjoyNFrOIOcxzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxNjo1NDo1MlrOIP0HlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjAyMjQ3Ng==", "bodyText": "Nice - please add test with double negations and checking the min/max value for both integer and longs and division by zero.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r552022476", "createdAt": "2021-01-05T15:56:24Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/qa/server/src/main/resources/arithmetic.sql-spec", "diffHunk": "@@ -87,3 +87,149 @@ orderByModulo\n SELECT emp_no FROM test_emp ORDER BY emp_no % 10000 LIMIT 10;\n orderByMul\n SELECT emp_no FROM test_emp ORDER BY emp_no * 2 LIMIT 10;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ1MzQ2MQ==", "bodyText": "All these tests are done in x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/optimizer/OptimizerRunTests.java, but I've added a few more here too (min/max long values and double negations were already present).", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r553453461", "createdAt": "2021-01-07T16:54:52Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/sql/qa/server/src/main/resources/arithmetic.sql-spec", "diffHunk": "@@ -87,3 +87,149 @@ orderByModulo\n SELECT emp_no FROM test_emp ORDER BY emp_no % 10000 LIMIT 10;\n orderByMul\n SELECT emp_no FROM test_emp ORDER BY emp_no * 2 LIMIT 10;\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjAyMjQ3Ng=="}, "originalCommit": {"oid": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NDMxNjY3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/planner/QueryTranslatorTests.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNTo1ODozN1rOIOc3xg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QxMTozNjo1N1rOIbDdtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjAyNDAwNg==", "bodyText": "Why is the script still used? there's no point in moving the interval to the right if it is not added to the given literal.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r552024006", "createdAt": "2021-01-05T15:58:37Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/planner/QueryTranslatorTests.java", "diffHunk": "@@ -2074,15 +2074,15 @@ public void testNoCountDoesNotTrackHits() {\n \n     public void testZonedDateTimeInScripts() {\n         PhysicalPlan p = optimizeAndPlan(\n-                \"SELECT date FROM test WHERE date + INTERVAL 1 YEAR > CAST('2019-03-11T12:34:56.000Z' AS DATETIME)\");\n+                \"SELECT date FROM test WHERE date - INTERVAL 999999999 YEAR > CAST('2019-03-11T12:34:56.000Z' AS DATETIME)\");\n         assertEquals(EsQueryExec.class, p.getClass());\n         EsQueryExec eqe = (EsQueryExec) p;\n         assertThat(eqe.queryContainer().toString().replaceAll(\"\\\\s+\", \"\"), containsString(\n                 \"\\\"script\\\":{\\\"script\\\":{\\\"source\\\":\\\"InternalQlScriptUtils.nullSafeFilter(\"\n-                        + \"InternalQlScriptUtils.gt(InternalSqlScriptUtils.add(InternalQlScriptUtils.docValue(doc,params.v0),\"\n+                        + \"InternalQlScriptUtils.gt(InternalSqlScriptUtils.sub(InternalQlScriptUtils.docValue(doc,params.v0),\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ1MzUzMA==", "bodyText": "I've changed the test from an addition to a subtraction, as well as used a max value, so that the optimisation is prevented. Consequently the translation had to be adjusted.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r553453530", "createdAt": "2021-01-07T16:54:59Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/planner/QueryTranslatorTests.java", "diffHunk": "@@ -2074,15 +2074,15 @@ public void testNoCountDoesNotTrackHits() {\n \n     public void testZonedDateTimeInScripts() {\n         PhysicalPlan p = optimizeAndPlan(\n-                \"SELECT date FROM test WHERE date + INTERVAL 1 YEAR > CAST('2019-03-11T12:34:56.000Z' AS DATETIME)\");\n+                \"SELECT date FROM test WHERE date - INTERVAL 999999999 YEAR > CAST('2019-03-11T12:34:56.000Z' AS DATETIME)\");\n         assertEquals(EsQueryExec.class, p.getClass());\n         EsQueryExec eqe = (EsQueryExec) p;\n         assertThat(eqe.queryContainer().toString().replaceAll(\"\\\\s+\", \"\"), containsString(\n                 \"\\\"script\\\":{\\\"script\\\":{\\\"source\\\":\\\"InternalQlScriptUtils.nullSafeFilter(\"\n-                        + \"InternalQlScriptUtils.gt(InternalSqlScriptUtils.add(InternalQlScriptUtils.docValue(doc,params.v0),\"\n+                        + \"InternalQlScriptUtils.gt(InternalSqlScriptUtils.sub(InternalQlScriptUtils.docValue(doc,params.v0),\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjAyNDAwNg=="}, "originalCommit": {"oid": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY5NzY0Mw==", "bodyText": "Could you then add a test where the optimization is applied? I'm confused since in this instance, I expect the PR to add tests not modify existing ones.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r557697643", "createdAt": "2021-01-14T21:04:18Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/planner/QueryTranslatorTests.java", "diffHunk": "@@ -2074,15 +2074,15 @@ public void testNoCountDoesNotTrackHits() {\n \n     public void testZonedDateTimeInScripts() {\n         PhysicalPlan p = optimizeAndPlan(\n-                \"SELECT date FROM test WHERE date + INTERVAL 1 YEAR > CAST('2019-03-11T12:34:56.000Z' AS DATETIME)\");\n+                \"SELECT date FROM test WHERE date - INTERVAL 999999999 YEAR > CAST('2019-03-11T12:34:56.000Z' AS DATETIME)\");\n         assertEquals(EsQueryExec.class, p.getClass());\n         EsQueryExec eqe = (EsQueryExec) p;\n         assertThat(eqe.queryContainer().toString().replaceAll(\"\\\\s+\", \"\"), containsString(\n                 \"\\\"script\\\":{\\\"script\\\":{\\\"source\\\":\\\"InternalQlScriptUtils.nullSafeFilter(\"\n-                        + \"InternalQlScriptUtils.gt(InternalSqlScriptUtils.add(InternalQlScriptUtils.docValue(doc,params.v0),\"\n+                        + \"InternalQlScriptUtils.gt(InternalSqlScriptUtils.sub(InternalQlScriptUtils.docValue(doc,params.v0),\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjAyNDAwNg=="}, "originalCommit": {"oid": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTIzOTIyMw==", "bodyText": ":-) Sure, tests have been added.\nThis test however still needs to be changed (as is now), as it meant to test testZonedDateTimeInScripts, not optimisations. What it did was the integer similar of x + 2  > 3 which the new optimisation rule would translate to x > 1; so it would simplify the test, reducing its testing value. My change only made sure the literals non-field values are such that the optimisation won't take place, so that the test retains its original intention (sort of x - MAX > 3, just like here).", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r565239223", "createdAt": "2021-01-27T11:36:57Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/planner/QueryTranslatorTests.java", "diffHunk": "@@ -2074,15 +2074,15 @@ public void testNoCountDoesNotTrackHits() {\n \n     public void testZonedDateTimeInScripts() {\n         PhysicalPlan p = optimizeAndPlan(\n-                \"SELECT date FROM test WHERE date + INTERVAL 1 YEAR > CAST('2019-03-11T12:34:56.000Z' AS DATETIME)\");\n+                \"SELECT date FROM test WHERE date - INTERVAL 999999999 YEAR > CAST('2019-03-11T12:34:56.000Z' AS DATETIME)\");\n         assertEquals(EsQueryExec.class, p.getClass());\n         EsQueryExec eqe = (EsQueryExec) p;\n         assertThat(eqe.queryContainer().toString().replaceAll(\"\\\\s+\", \"\"), containsString(\n                 \"\\\"script\\\":{\\\"script\\\":{\\\"source\\\":\\\"InternalQlScriptUtils.nullSafeFilter(\"\n-                        + \"InternalQlScriptUtils.gt(InternalSqlScriptUtils.add(InternalQlScriptUtils.docValue(doc,params.v0),\"\n+                        + \"InternalQlScriptUtils.gt(InternalSqlScriptUtils.sub(InternalQlScriptUtils.docValue(doc,params.v0),\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjAyNDAwNg=="}, "originalCommit": {"oid": "1a28179fd76bae83d23c56ef566ae006ff7a7a2a"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxMTAyODg4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/operator/arithmetic/Add.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQyMDoyMDoxOFrOIT1wwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QxMToyMzowMFrOIbC8vQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY3NDY5MA==", "bodyText": "Invertible is typically used in the context of matrices. How about inversion or inverse or inversible? Essentially use inverse instead of invert.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r557674690", "createdAt": "2021-01-14T20:20:18Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/operator/arithmetic/Add.java", "diffHunk": "@@ -12,7 +12,7 @@\n /**\n  * Addition function ({@code a + b}).\n  */\n-public class Add extends DateTimeArithmeticOperation {\n+public class Add extends DateTimeArithmeticOperation implements BinaryComparisonInvertible {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTIzMDc4MQ==", "bodyText": "I've changed it to Inversible..\nSince the interface is meant to convey the action intent, I find -ble needed. But FTR, invertible might still be more appropriate since \"inversible\" isn't really a word and a word already exists: that's why a matrix^-1 is \"inverted\" and so are also indexes/indices (\"inverted index\" not \"inversed index\").", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r565230781", "createdAt": "2021-01-27T11:23:00Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/operator/arithmetic/Add.java", "diffHunk": "@@ -12,7 +12,7 @@\n /**\n  * Addition function ({@code a + b}).\n  */\n-public class Add extends DateTimeArithmeticOperation {\n+public class Add extends DateTimeArithmeticOperation implements BinaryComparisonInvertible {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY3NDY5MA=="}, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxMTA0MjI0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQyMDoyNDoxOVrOIT14-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QxMToyMzoxNlrOIbC9Zg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY3Njc5NA==", "bodyText": "Why is this check required? Are there any doubts on what type of code is being received and if so, why not do the filtering before hand?\nI'm not a fan of this defensive programming since it promotes uncertainty to a degree. This is our own code, our own system, working in synch - no need to double check the code flow.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r557676794", "createdAt": "2021-01-14T20:24:19Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1284,7 +1246,12 @@ Expression doSimplify() {\n                     ? Literal.of(bcLiteral, ((Number) bcLiteral.value()).doubleValue())\n                     : bcLiteral;\n \n-                Expression bcRightExpression = safeMaybeFold(operation.inverse(bcl.source(), bcl, opRight));\n+                if (operation instanceof BinaryComparisonInvertible == false) { // should be an assertion?\n+                    throw new QlIllegalArgumentException(\"Unexpected [\" + operation.symbol() + \"] operation object\");\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTIzMDk1MA==", "bodyText": "I've removed the check.\nOfftopic:\n\nno need to double check the code flow\n\nExtensive testing should definitely help. I believe assertions exist still because code has a (life) cycle and effects of later changes can't always be exhaustively checked/predicted or coded in (see the many instanceofs or comment).", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r565230950", "createdAt": "2021-01-27T11:23:16Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1284,7 +1246,12 @@ Expression doSimplify() {\n                     ? Literal.of(bcLiteral, ((Number) bcLiteral.value()).doubleValue())\n                     : bcLiteral;\n \n-                Expression bcRightExpression = safeMaybeFold(operation.inverse(bcl.source(), bcl, opRight));\n+                if (operation instanceof BinaryComparisonInvertible == false) { // should be an assertion?\n+                    throw new QlIllegalArgumentException(\"Unexpected [\" + operation.symbol() + \"] operation object\");\n+                }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY3Njc5NA=="}, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxMTA1MDYxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQyMDoyNjo1N1rOIT1-Aw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QxMToyMzozMFrOIbC97w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY3ODA4Mw==", "bodyText": "The code is a bit messy and could use some comments on what are the cases the rules tries to optimize - some basic examples of input vs output are enough.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r557678083", "createdAt": "2021-01-14T20:26:57Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1148,46 +1152,6 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n-    public static final class BubbleUpNegations extends OptimizerExpressionRule {\n-\n-        public BubbleUpNegations() {\n-            super(TransformDirection.DOWN);\n-        }\n-\n-        @Override\n-        protected Expression rule(Expression e) {\n-            if (e instanceof Neg) { // cancels out NEG - MUL/DIV - NEG - x ==> MUL/DIV - x\n-                Expression child = e.children().get(0);\n-                if (child instanceof ArithmeticOperation) {\n-                    ArithmeticOperation operation = (ArithmeticOperation) child;\n-                    String opSymbol = operation.symbol();\n-                    if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n-                        if (operation.left() instanceof Neg) {\n-                            return operation.replaceChildren(List.of(operation.left().children().get(0), operation.right()));\n-                        }\n-                        if (operation.right() instanceof Neg) {\n-                            return operation.replaceChildren(List.of(operation.left(), operation.right().children().get(0)));\n-                        }\n-                    }\n-                }\n-            } else if (e instanceof ArithmeticOperation) { // pulls up MUL/DIV - NEG - x ==> NEG - MUL/DIV - x\n-                ArithmeticOperation operation = (ArithmeticOperation) e;\n-                String opSymbol = operation.symbol();\n-                if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n-                    if (operation.left() instanceof Neg) {\n-                        Neg neg = (Neg) operation.left();\n-                        return new Neg(operation.source(), operation.replaceChildren(List.of(neg.children().get(0), operation.right())));\n-                    }\n-                    if (operation.right() instanceof Neg) {\n-                        Neg neg = (Neg) operation.right();\n-                        return new Neg(operation.source(), operation.replaceChildren(List.of(operation.left(), neg.children().get(0))));\n-                    }\n-                }\n-            }\n-            return e;\n-        }\n-    }\n-\n     // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n     public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTIzMTA4Nw==", "bodyText": "Code refactored and comments added.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r565231087", "createdAt": "2021-01-27T11:23:30Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1148,46 +1152,6 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n-    public static final class BubbleUpNegations extends OptimizerExpressionRule {\n-\n-        public BubbleUpNegations() {\n-            super(TransformDirection.DOWN);\n-        }\n-\n-        @Override\n-        protected Expression rule(Expression e) {\n-            if (e instanceof Neg) { // cancels out NEG - MUL/DIV - NEG - x ==> MUL/DIV - x\n-                Expression child = e.children().get(0);\n-                if (child instanceof ArithmeticOperation) {\n-                    ArithmeticOperation operation = (ArithmeticOperation) child;\n-                    String opSymbol = operation.symbol();\n-                    if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n-                        if (operation.left() instanceof Neg) {\n-                            return operation.replaceChildren(List.of(operation.left().children().get(0), operation.right()));\n-                        }\n-                        if (operation.right() instanceof Neg) {\n-                            return operation.replaceChildren(List.of(operation.left(), operation.right().children().get(0)));\n-                        }\n-                    }\n-                }\n-            } else if (e instanceof ArithmeticOperation) { // pulls up MUL/DIV - NEG - x ==> NEG - MUL/DIV - x\n-                ArithmeticOperation operation = (ArithmeticOperation) e;\n-                String opSymbol = operation.symbol();\n-                if (MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol)) {\n-                    if (operation.left() instanceof Neg) {\n-                        Neg neg = (Neg) operation.left();\n-                        return new Neg(operation.source(), operation.replaceChildren(List.of(neg.children().get(0), operation.right())));\n-                    }\n-                    if (operation.right() instanceof Neg) {\n-                        Neg neg = (Neg) operation.right();\n-                        return new Neg(operation.source(), operation.replaceChildren(List.of(operation.left(), neg.children().get(0))));\n-                    }\n-                }\n-            }\n-            return e;\n-        }\n-    }\n-\n     // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n     public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY3ODA4Mw=="}, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxMTA4NTA3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQyMDozNzowNVrOIT2S-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QxMToyMzozNVrOIbC-DQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY4MzQ0OQ==", "bodyText": "tryFolding vs safeMaybeFold.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r557683449", "createdAt": "2021-01-14T20:37:05Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression literalNeg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return literalNeg == null ? bc : bc.reverse().replaceChildren(List.of(((Neg) bc.left()).field(), literalNeg));\n+        }\n+\n+        static Expression safeMaybeFold(Expression expression) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTIzMTExNw==", "bodyText": "Suggestion applied.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r565231117", "createdAt": "2021-01-27T11:23:35Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression literalNeg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return literalNeg == null ? bc : bc.reverse().replaceChildren(List.of(((Neg) bc.left()).field(), literalNeg));\n+        }\n+\n+        static Expression safeMaybeFold(Expression expression) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY4MzQ0OQ=="}, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxMTA5MzYyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQyMDozOToyNVrOIT2X_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QxMToyMzo0M1rOIbC-aw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY4NDczNQ==", "bodyText": "use asList for backporting. Also literalNeg should preserve the right origin so maybe rightNegated?", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r557684735", "createdAt": "2021-01-14T20:39:25Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression literalNeg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return literalNeg == null ? bc : bc.reverse().replaceChildren(List.of(((Neg) bc.left()).field(), literalNeg));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTIzMTIxMQ==", "bodyText": "Right, thanks.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r565231211", "createdAt": "2021-01-27T11:23:43Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression literalNeg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return literalNeg == null ? bc : bc.reverse().replaceChildren(List.of(((Neg) bc.left()).field(), literalNeg));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY4NDczNQ=="}, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxMTA5NDk3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQyMDozOTo1MFrOIT2Y0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QxMToyNDo1N1rOIbDBMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY4NDk0NA==", "bodyText": "foldNegation vs reduce (different terminology).", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r557684944", "createdAt": "2021-01-14T20:39:50Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTIzMTkyMg==", "bodyText": "Suggestion applied.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r565231922", "createdAt": "2021-01-27T11:24:57Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY4NDk0NA=="}, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxMTEwMDMwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQyMDo0MTozM1rOIT2cJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QxMToyNTowNVrOIbDBng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY4NTc5OQ==", "bodyText": "What's the use of this class? The name is fairly generic. Also can it be used by itself ? if not making abstract.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r557685799", "createdAt": "2021-01-14T20:41:33Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression literalNeg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return literalNeg == null ? bc : bc.reverse().replaceChildren(List.of(((Neg) bc.left()).field(), literalNeg));\n+        }\n+\n+        static Expression safeMaybeFold(Expression expression) {\n+            if (expression.foldable()) {\n+                try {\n+                    expression = new Literal(expression.source(), expression.fold(), expression.dataType());\n+                } catch (ArithmeticException | DateTimeException e) {\n+                    expression = null;\n+                }\n+            }\n+            return expression;\n+        }\n+\n+        private static class SimplifyOperation {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTIzMjAzMA==", "bodyText": "It's been made abstract.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r565232030", "createdAt": "2021-01-27T11:25:05Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression literalNeg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return literalNeg == null ? bc : bc.reverse().replaceChildren(List.of(((Neg) bc.left()).field(), literalNeg));\n+        }\n+\n+        static Expression safeMaybeFold(Expression expression) {\n+            if (expression.foldable()) {\n+                try {\n+                    expression = new Literal(expression.source(), expression.fold(), expression.dataType());\n+                } catch (ArithmeticException | DateTimeException e) {\n+                    expression = null;\n+                }\n+            }\n+            return expression;\n+        }\n+\n+        private static class SimplifyOperation {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY4NTc5OQ=="}, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxMTEwMjczOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQyMDo0MjoyMFrOIT2drA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QxMToyNToxNFrOIbDB-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY4NjE4OA==", "bodyText": "The constructor makes a lot of assumptions here, are these safe?", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r557686188", "createdAt": "2021-01-14T20:42:20Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression literalNeg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return literalNeg == null ? bc : bc.reverse().replaceChildren(List.of(((Neg) bc.left()).field(), literalNeg));\n+        }\n+\n+        static Expression safeMaybeFold(Expression expression) {\n+            if (expression.foldable()) {\n+                try {\n+                    expression = new Literal(expression.source(), expression.fold(), expression.dataType());\n+                } catch (ArithmeticException | DateTimeException e) {\n+                    expression = null;\n+                }\n+            }\n+            return expression;\n+        }\n+\n+        private static class SimplifyOperation {\n+            final BinaryComparison comparison;\n+            final Literal bcLiteral;\n+            final ArithmeticOperation operation;\n+            final Expression opLeft;\n+            final Expression opRight;\n+            final Literal opLiteral;\n+\n+            SimplifyOperation(BinaryComparison comparison) {\n+                this.comparison = comparison;\n+                operation = (ArithmeticOperation) comparison.left();\n+                bcLiteral = (Literal) comparison.right();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTIzMjEyMg==", "bodyText": "Yes, all are checked upstream.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r565232122", "createdAt": "2021-01-27T11:25:14Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression literalNeg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return literalNeg == null ? bc : bc.reverse().replaceChildren(List.of(((Neg) bc.left()).field(), literalNeg));\n+        }\n+\n+        static Expression safeMaybeFold(Expression expression) {\n+            if (expression.foldable()) {\n+                try {\n+                    expression = new Literal(expression.source(), expression.fold(), expression.dataType());\n+                } catch (ArithmeticException | DateTimeException e) {\n+                    expression = null;\n+                }\n+            }\n+            return expression;\n+        }\n+\n+        private static class SimplifyOperation {\n+            final BinaryComparison comparison;\n+            final Literal bcLiteral;\n+            final ArithmeticOperation operation;\n+            final Expression opLeft;\n+            final Expression opRight;\n+            final Literal opLiteral;\n+\n+            SimplifyOperation(BinaryComparison comparison) {\n+                this.comparison = comparison;\n+                operation = (ArithmeticOperation) comparison.left();\n+                bcLiteral = (Literal) comparison.right();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY4NjE4OA=="}, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxMTExNTMzOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQyMDo0NjoyNFrOIT2lyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QxMToyNjoxMVrOIbDEbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY4ODI2Ng==", "bodyText": "Why is this static method defined in this class? It's confusing to see the class Simplify being called both as an instance and its static method.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r557688266", "createdAt": "2021-01-14T20:46:24Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression literalNeg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return literalNeg == null ? bc : bc.reverse().replaceChildren(List.of(((Neg) bc.left()).field(), literalNeg));\n+        }\n+\n+        static Expression safeMaybeFold(Expression expression) {\n+            if (expression.foldable()) {\n+                try {\n+                    expression = new Literal(expression.source(), expression.fold(), expression.dataType());\n+                } catch (ArithmeticException | DateTimeException e) {\n+                    expression = null;\n+                }\n+            }\n+            return expression;\n+        }\n+\n+        private static class SimplifyOperation {\n+            final BinaryComparison comparison;\n+            final Literal bcLiteral;\n+            final ArithmeticOperation operation;\n+            final Expression opLeft;\n+            final Expression opRight;\n+            final Literal opLiteral;\n+\n+            SimplifyOperation(BinaryComparison comparison) {\n+                this.comparison = comparison;\n+                operation = (ArithmeticOperation) comparison.left();\n+                bcLiteral = (Literal) comparison.right();\n+\n+                opLeft = operation.left();\n+                opRight = operation.right();\n+\n+                if (opLeft instanceof Literal) {\n+                    opLiteral = (Literal) opLeft;\n+                } else if (opRight instanceof Literal) {\n+                    opLiteral = (Literal) opRight;\n+                } else {\n+                    opLiteral = null;\n+                }\n+            }\n+\n+            // can it be quickly fast-tracked that the operation can't be reduced?\n+            boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                if (opLiteral == null) {\n+                    // one of the arithm. operands must be a literal, otherwise the operation wouldn't simplify anything\n+                    return true;\n+                }\n+\n+                // Only operations on fixed point literals are supported, since optimizing float point operations can also change the\n+                // outcome of the filtering:\n+                //    x + 1e18 > 1e18::long will yield different results with a field value in [-2^6, 2^6], optimised vs original;\n+                //    x * (1 + 1e-15d) > 1 : same with a field value of (1 - 1e-15d)\n+                // so consequently, int fields optimisation requiring FP arithmetic isn't possible either: (x - 1e-15) * (1 + 1e-15) > 1.\n+                if (opLiteral.dataType().isRational() || bcLiteral.dataType().isRational()) {\n+                    return true;\n+                }\n+\n+                // the Literal will be moved to the right of the comparison, but only if data-compatible with what's there\n+                return typesCompatible.apply(bcLiteral.dataType(), opLiteral.dataType()) == false;\n+            }\n+\n+            Expression doSimplify() {\n+                // force float point folding for FlP field\n+                Literal bcl = operation.dataType().isRational()\n+                    ? Literal.of(bcLiteral, ((Number) bcLiteral.value()).doubleValue())\n+                    : bcLiteral;\n+\n+                if (operation instanceof BinaryComparisonInvertible == false) { // should be an assertion?\n+                    throw new QlIllegalArgumentException(\"Unexpected [\" + operation.symbol() + \"] operation object\");\n+                }\n+                Expression bcRightExpression = ((BinaryComparisonInvertible) operation).binaryComparisonInverse()\n+                    .create(bcl.source(), bcl, opRight);\n+                bcRightExpression = safeMaybeFold(bcRightExpression);\n+                return bcRightExpression == null ? comparison : comparison.replaceChildren(List.of(opLeft, bcRightExpression));\n+            }\n+\n+            static Expression simplify(BinaryComparison comparison, BiFunction<DataType, DataType, Boolean> typesCompatible) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTIzMjc0OA==", "bodyText": "The intention was to have the (previously called) SimplifyOperation be self-contained: deal with simplification operations entirely and not leak details into the outer class, that should not care if it's a AddSub or DivMul operation.\nAnyways, I've extracted it out.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r565232748", "createdAt": "2021-01-27T11:26:11Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression literalNeg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return literalNeg == null ? bc : bc.reverse().replaceChildren(List.of(((Neg) bc.left()).field(), literalNeg));\n+        }\n+\n+        static Expression safeMaybeFold(Expression expression) {\n+            if (expression.foldable()) {\n+                try {\n+                    expression = new Literal(expression.source(), expression.fold(), expression.dataType());\n+                } catch (ArithmeticException | DateTimeException e) {\n+                    expression = null;\n+                }\n+            }\n+            return expression;\n+        }\n+\n+        private static class SimplifyOperation {\n+            final BinaryComparison comparison;\n+            final Literal bcLiteral;\n+            final ArithmeticOperation operation;\n+            final Expression opLeft;\n+            final Expression opRight;\n+            final Literal opLiteral;\n+\n+            SimplifyOperation(BinaryComparison comparison) {\n+                this.comparison = comparison;\n+                operation = (ArithmeticOperation) comparison.left();\n+                bcLiteral = (Literal) comparison.right();\n+\n+                opLeft = operation.left();\n+                opRight = operation.right();\n+\n+                if (opLeft instanceof Literal) {\n+                    opLiteral = (Literal) opLeft;\n+                } else if (opRight instanceof Literal) {\n+                    opLiteral = (Literal) opRight;\n+                } else {\n+                    opLiteral = null;\n+                }\n+            }\n+\n+            // can it be quickly fast-tracked that the operation can't be reduced?\n+            boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                if (opLiteral == null) {\n+                    // one of the arithm. operands must be a literal, otherwise the operation wouldn't simplify anything\n+                    return true;\n+                }\n+\n+                // Only operations on fixed point literals are supported, since optimizing float point operations can also change the\n+                // outcome of the filtering:\n+                //    x + 1e18 > 1e18::long will yield different results with a field value in [-2^6, 2^6], optimised vs original;\n+                //    x * (1 + 1e-15d) > 1 : same with a field value of (1 - 1e-15d)\n+                // so consequently, int fields optimisation requiring FP arithmetic isn't possible either: (x - 1e-15) * (1 + 1e-15) > 1.\n+                if (opLiteral.dataType().isRational() || bcLiteral.dataType().isRational()) {\n+                    return true;\n+                }\n+\n+                // the Literal will be moved to the right of the comparison, but only if data-compatible with what's there\n+                return typesCompatible.apply(bcLiteral.dataType(), opLiteral.dataType()) == false;\n+            }\n+\n+            Expression doSimplify() {\n+                // force float point folding for FlP field\n+                Literal bcl = operation.dataType().isRational()\n+                    ? Literal.of(bcLiteral, ((Number) bcLiteral.value()).doubleValue())\n+                    : bcLiteral;\n+\n+                if (operation instanceof BinaryComparisonInvertible == false) { // should be an assertion?\n+                    throw new QlIllegalArgumentException(\"Unexpected [\" + operation.symbol() + \"] operation object\");\n+                }\n+                Expression bcRightExpression = ((BinaryComparisonInvertible) operation).binaryComparisonInverse()\n+                    .create(bcl.source(), bcl, opRight);\n+                bcRightExpression = safeMaybeFold(bcRightExpression);\n+                return bcRightExpression == null ? comparison : comparison.replaceChildren(List.of(opLeft, bcRightExpression));\n+            }\n+\n+            static Expression simplify(BinaryComparison comparison, BiFunction<DataType, DataType, Boolean> typesCompatible) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY4ODI2Ng=="}, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 167}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxMTExOTIxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQyMDo0NzozM1rOIT2oRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QxMToyNjoyOVrOIbDFDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY4ODkwMQ==", "bodyText": "It's better to do a switch on the operation enum as that will cover all cases.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r557688901", "createdAt": "2021-01-14T20:47:33Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression literalNeg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return literalNeg == null ? bc : bc.reverse().replaceChildren(List.of(((Neg) bc.left()).field(), literalNeg));\n+        }\n+\n+        static Expression safeMaybeFold(Expression expression) {\n+            if (expression.foldable()) {\n+                try {\n+                    expression = new Literal(expression.source(), expression.fold(), expression.dataType());\n+                } catch (ArithmeticException | DateTimeException e) {\n+                    expression = null;\n+                }\n+            }\n+            return expression;\n+        }\n+\n+        private static class SimplifyOperation {\n+            final BinaryComparison comparison;\n+            final Literal bcLiteral;\n+            final ArithmeticOperation operation;\n+            final Expression opLeft;\n+            final Expression opRight;\n+            final Literal opLiteral;\n+\n+            SimplifyOperation(BinaryComparison comparison) {\n+                this.comparison = comparison;\n+                operation = (ArithmeticOperation) comparison.left();\n+                bcLiteral = (Literal) comparison.right();\n+\n+                opLeft = operation.left();\n+                opRight = operation.right();\n+\n+                if (opLeft instanceof Literal) {\n+                    opLiteral = (Literal) opLeft;\n+                } else if (opRight instanceof Literal) {\n+                    opLiteral = (Literal) opRight;\n+                } else {\n+                    opLiteral = null;\n+                }\n+            }\n+\n+            // can it be quickly fast-tracked that the operation can't be reduced?\n+            boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                if (opLiteral == null) {\n+                    // one of the arithm. operands must be a literal, otherwise the operation wouldn't simplify anything\n+                    return true;\n+                }\n+\n+                // Only operations on fixed point literals are supported, since optimizing float point operations can also change the\n+                // outcome of the filtering:\n+                //    x + 1e18 > 1e18::long will yield different results with a field value in [-2^6, 2^6], optimised vs original;\n+                //    x * (1 + 1e-15d) > 1 : same with a field value of (1 - 1e-15d)\n+                // so consequently, int fields optimisation requiring FP arithmetic isn't possible either: (x - 1e-15) * (1 + 1e-15) > 1.\n+                if (opLiteral.dataType().isRational() || bcLiteral.dataType().isRational()) {\n+                    return true;\n+                }\n+\n+                // the Literal will be moved to the right of the comparison, but only if data-compatible with what's there\n+                return typesCompatible.apply(bcLiteral.dataType(), opLiteral.dataType()) == false;\n+            }\n+\n+            Expression doSimplify() {\n+                // force float point folding for FlP field\n+                Literal bcl = operation.dataType().isRational()\n+                    ? Literal.of(bcLiteral, ((Number) bcLiteral.value()).doubleValue())\n+                    : bcLiteral;\n+\n+                if (operation instanceof BinaryComparisonInvertible == false) { // should be an assertion?\n+                    throw new QlIllegalArgumentException(\"Unexpected [\" + operation.symbol() + \"] operation object\");\n+                }\n+                Expression bcRightExpression = ((BinaryComparisonInvertible) operation).binaryComparisonInverse()\n+                    .create(bcl.source(), bcl, opRight);\n+                bcRightExpression = safeMaybeFold(bcRightExpression);\n+                return bcRightExpression == null ? comparison : comparison.replaceChildren(List.of(opLeft, bcRightExpression));\n+            }\n+\n+            static Expression simplify(BinaryComparison comparison, BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                ArithmeticOperation operation = (ArithmeticOperation) comparison.left();\n+                // Use symbol comp: SQL operations aren't available in this package (as dependencies)\n+                String opSymbol = operation.symbol();\n+                // Modulo can't be simplified.\n+                if (MOD.symbol().equals(opSymbol)) {\n+                    return comparison;\n+                }\n+                SimplifyOperation simplify = null;\n+                if (isMulOrDiv(opSymbol)) {\n+                    simplify = new SimplifyMulDiv(comparison);\n+                } else if (ADD.symbol().equals(opSymbol) || SUB.symbol().equals(opSymbol)) {\n+                    simplify = new SimplifyAddSub(comparison);\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTIzMjkxMQ==", "bodyText": "The SQL operations that this code also acts on aren't available (in the current package) -- there's a comment on the line right before the first in the snippet above. So I don't know how else it can be done.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r565232911", "createdAt": "2021-01-27T11:26:29Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression literalNeg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return literalNeg == null ? bc : bc.reverse().replaceChildren(List.of(((Neg) bc.left()).field(), literalNeg));\n+        }\n+\n+        static Expression safeMaybeFold(Expression expression) {\n+            if (expression.foldable()) {\n+                try {\n+                    expression = new Literal(expression.source(), expression.fold(), expression.dataType());\n+                } catch (ArithmeticException | DateTimeException e) {\n+                    expression = null;\n+                }\n+            }\n+            return expression;\n+        }\n+\n+        private static class SimplifyOperation {\n+            final BinaryComparison comparison;\n+            final Literal bcLiteral;\n+            final ArithmeticOperation operation;\n+            final Expression opLeft;\n+            final Expression opRight;\n+            final Literal opLiteral;\n+\n+            SimplifyOperation(BinaryComparison comparison) {\n+                this.comparison = comparison;\n+                operation = (ArithmeticOperation) comparison.left();\n+                bcLiteral = (Literal) comparison.right();\n+\n+                opLeft = operation.left();\n+                opRight = operation.right();\n+\n+                if (opLeft instanceof Literal) {\n+                    opLiteral = (Literal) opLeft;\n+                } else if (opRight instanceof Literal) {\n+                    opLiteral = (Literal) opRight;\n+                } else {\n+                    opLiteral = null;\n+                }\n+            }\n+\n+            // can it be quickly fast-tracked that the operation can't be reduced?\n+            boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                if (opLiteral == null) {\n+                    // one of the arithm. operands must be a literal, otherwise the operation wouldn't simplify anything\n+                    return true;\n+                }\n+\n+                // Only operations on fixed point literals are supported, since optimizing float point operations can also change the\n+                // outcome of the filtering:\n+                //    x + 1e18 > 1e18::long will yield different results with a field value in [-2^6, 2^6], optimised vs original;\n+                //    x * (1 + 1e-15d) > 1 : same with a field value of (1 - 1e-15d)\n+                // so consequently, int fields optimisation requiring FP arithmetic isn't possible either: (x - 1e-15) * (1 + 1e-15) > 1.\n+                if (opLiteral.dataType().isRational() || bcLiteral.dataType().isRational()) {\n+                    return true;\n+                }\n+\n+                // the Literal will be moved to the right of the comparison, but only if data-compatible with what's there\n+                return typesCompatible.apply(bcLiteral.dataType(), opLiteral.dataType()) == false;\n+            }\n+\n+            Expression doSimplify() {\n+                // force float point folding for FlP field\n+                Literal bcl = operation.dataType().isRational()\n+                    ? Literal.of(bcLiteral, ((Number) bcLiteral.value()).doubleValue())\n+                    : bcLiteral;\n+\n+                if (operation instanceof BinaryComparisonInvertible == false) { // should be an assertion?\n+                    throw new QlIllegalArgumentException(\"Unexpected [\" + operation.symbol() + \"] operation object\");\n+                }\n+                Expression bcRightExpression = ((BinaryComparisonInvertible) operation).binaryComparisonInverse()\n+                    .create(bcl.source(), bcl, opRight);\n+                bcRightExpression = safeMaybeFold(bcRightExpression);\n+                return bcRightExpression == null ? comparison : comparison.replaceChildren(List.of(opLeft, bcRightExpression));\n+            }\n+\n+            static Expression simplify(BinaryComparison comparison, BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                ArithmeticOperation operation = (ArithmeticOperation) comparison.left();\n+                // Use symbol comp: SQL operations aren't available in this package (as dependencies)\n+                String opSymbol = operation.symbol();\n+                // Modulo can't be simplified.\n+                if (MOD.symbol().equals(opSymbol)) {\n+                    return comparison;\n+                }\n+                SimplifyOperation simplify = null;\n+                if (isMulOrDiv(opSymbol)) {\n+                    simplify = new SimplifyMulDiv(comparison);\n+                } else if (ADD.symbol().equals(opSymbol) || SUB.symbol().equals(opSymbol)) {\n+                    simplify = new SimplifyAddSub(comparison);\n+                }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY4ODkwMQ=="}, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 180}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxMTEzODMwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQyMDo1Mjo1NlrOIT20LA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QxMToyNjozM1rOIbDFPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY5MTk0OA==", "bodyText": "Why not Math.signum (see MathOperation.SIGN)?", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r557691948", "createdAt": "2021-01-14T20:52:56Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression literalNeg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return literalNeg == null ? bc : bc.reverse().replaceChildren(List.of(((Neg) bc.left()).field(), literalNeg));\n+        }\n+\n+        static Expression safeMaybeFold(Expression expression) {\n+            if (expression.foldable()) {\n+                try {\n+                    expression = new Literal(expression.source(), expression.fold(), expression.dataType());\n+                } catch (ArithmeticException | DateTimeException e) {\n+                    expression = null;\n+                }\n+            }\n+            return expression;\n+        }\n+\n+        private static class SimplifyOperation {\n+            final BinaryComparison comparison;\n+            final Literal bcLiteral;\n+            final ArithmeticOperation operation;\n+            final Expression opLeft;\n+            final Expression opRight;\n+            final Literal opLiteral;\n+\n+            SimplifyOperation(BinaryComparison comparison) {\n+                this.comparison = comparison;\n+                operation = (ArithmeticOperation) comparison.left();\n+                bcLiteral = (Literal) comparison.right();\n+\n+                opLeft = operation.left();\n+                opRight = operation.right();\n+\n+                if (opLeft instanceof Literal) {\n+                    opLiteral = (Literal) opLeft;\n+                } else if (opRight instanceof Literal) {\n+                    opLiteral = (Literal) opRight;\n+                } else {\n+                    opLiteral = null;\n+                }\n+            }\n+\n+            // can it be quickly fast-tracked that the operation can't be reduced?\n+            boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                if (opLiteral == null) {\n+                    // one of the arithm. operands must be a literal, otherwise the operation wouldn't simplify anything\n+                    return true;\n+                }\n+\n+                // Only operations on fixed point literals are supported, since optimizing float point operations can also change the\n+                // outcome of the filtering:\n+                //    x + 1e18 > 1e18::long will yield different results with a field value in [-2^6, 2^6], optimised vs original;\n+                //    x * (1 + 1e-15d) > 1 : same with a field value of (1 - 1e-15d)\n+                // so consequently, int fields optimisation requiring FP arithmetic isn't possible either: (x - 1e-15) * (1 + 1e-15) > 1.\n+                if (opLiteral.dataType().isRational() || bcLiteral.dataType().isRational()) {\n+                    return true;\n+                }\n+\n+                // the Literal will be moved to the right of the comparison, but only if data-compatible with what's there\n+                return typesCompatible.apply(bcLiteral.dataType(), opLiteral.dataType()) == false;\n+            }\n+\n+            Expression doSimplify() {\n+                // force float point folding for FlP field\n+                Literal bcl = operation.dataType().isRational()\n+                    ? Literal.of(bcLiteral, ((Number) bcLiteral.value()).doubleValue())\n+                    : bcLiteral;\n+\n+                if (operation instanceof BinaryComparisonInvertible == false) { // should be an assertion?\n+                    throw new QlIllegalArgumentException(\"Unexpected [\" + operation.symbol() + \"] operation object\");\n+                }\n+                Expression bcRightExpression = ((BinaryComparisonInvertible) operation).binaryComparisonInverse()\n+                    .create(bcl.source(), bcl, opRight);\n+                bcRightExpression = safeMaybeFold(bcRightExpression);\n+                return bcRightExpression == null ? comparison : comparison.replaceChildren(List.of(opLeft, bcRightExpression));\n+            }\n+\n+            static Expression simplify(BinaryComparison comparison, BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                ArithmeticOperation operation = (ArithmeticOperation) comparison.left();\n+                // Use symbol comp: SQL operations aren't available in this package (as dependencies)\n+                String opSymbol = operation.symbol();\n+                // Modulo can't be simplified.\n+                if (MOD.symbol().equals(opSymbol)) {\n+                    return comparison;\n+                }\n+                SimplifyOperation simplify = null;\n+                if (isMulOrDiv(opSymbol)) {\n+                    simplify = new SimplifyMulDiv(comparison);\n+                } else if (ADD.symbol().equals(opSymbol) || SUB.symbol().equals(opSymbol)) {\n+                    simplify = new SimplifyAddSub(comparison);\n+                }\n+\n+                return (simplify == null || simplify.cannotSimplify(typesCompatible)) ? comparison : simplify.doSimplify();\n+            }\n+\n+            static boolean isMulOrDiv(String opSymbol) {\n+                return MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol);\n+            }\n+        }\n+\n+        private static class SimplifyAddSub extends SimplifyOperation {\n+\n+            SimplifyAddSub(BinaryComparison comparison) {\n+                super(comparison);\n+            }\n+\n+            @Override\n+            boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                // no ADD/SUB with floating fields\n+                return operation.dataType().isRational() || super.cannotSimplify(typesCompatible);\n+            }\n+\n+            @Override\n+            Expression doSimplify() {\n+                if (SUB.symbol().equals(operation.symbol()) && opRight instanceof Literal == false) {\n+                    // if next simplification step would fail on overflow anyways, skip the optimisation already\n+                    if (safeMaybeFold(new Sub(EMPTY, opLeft, bcLiteral)) == null) {\n+                        return comparison;\n+                    }\n+                }\n+                return super.doSimplify();\n+            }\n+        }\n+\n+        private static class SimplifyMulDiv extends SimplifyOperation {\n+\n+            private final boolean isDiv; // and not MUL.\n+\n+            SimplifyMulDiv(BinaryComparison comparison) {\n+                super(comparison);\n+                isDiv = DIV.symbol().equals(operation.symbol());\n+            }\n+\n+            @Override\n+            boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                // Integer divisions are not safe to optimise: x / 5 > 1 <=/=> x > 5 for x in [6, 9]; same for the `==` comp\n+                return operation.dataType().isInteger() && isDiv || super.cannotSimplify(typesCompatible);\n+            }\n+\n+            @Override\n+            Expression doSimplify() {\n+                // If current operation is a multiplication, it's inverse will be a division: safe only if outcome is still integral.\n+                if (isDiv == false && opLeft.dataType().isInteger()) {\n+                    long opLiteralValue = ((Number) opLiteral.value()).longValue();\n+                    if (opLiteralValue == 0 || ((Number) bcLiteral.value()).longValue() % opLiteralValue != 0) {\n+                        return comparison;\n+                    }\n+                }\n+                // negative multiplication/division changes the direction of the comparison\n+                int sign = sign(opRight);\n+                if (sign == 0) {\n+                    return comparison;\n+                }\n+                BinaryComparison bc = (BinaryComparison) super.doSimplify();\n+                return sign < 0 ? bc.reverse() : bc;\n+            }\n+\n+            private int sign(Object obj) {\n+                int sign = 1;\n+                if (obj instanceof Number) {\n+                    double d = ((Number) obj).doubleValue();\n+                    sign = d == 0 ? 0 : (d < 0 ? -1 : 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 251}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTIzMjk1Nw==", "bodyText": "Thanks, fixed.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r565232957", "createdAt": "2021-01-27T11:26:33Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression literalNeg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return literalNeg == null ? bc : bc.reverse().replaceChildren(List.of(((Neg) bc.left()).field(), literalNeg));\n+        }\n+\n+        static Expression safeMaybeFold(Expression expression) {\n+            if (expression.foldable()) {\n+                try {\n+                    expression = new Literal(expression.source(), expression.fold(), expression.dataType());\n+                } catch (ArithmeticException | DateTimeException e) {\n+                    expression = null;\n+                }\n+            }\n+            return expression;\n+        }\n+\n+        private static class SimplifyOperation {\n+            final BinaryComparison comparison;\n+            final Literal bcLiteral;\n+            final ArithmeticOperation operation;\n+            final Expression opLeft;\n+            final Expression opRight;\n+            final Literal opLiteral;\n+\n+            SimplifyOperation(BinaryComparison comparison) {\n+                this.comparison = comparison;\n+                operation = (ArithmeticOperation) comparison.left();\n+                bcLiteral = (Literal) comparison.right();\n+\n+                opLeft = operation.left();\n+                opRight = operation.right();\n+\n+                if (opLeft instanceof Literal) {\n+                    opLiteral = (Literal) opLeft;\n+                } else if (opRight instanceof Literal) {\n+                    opLiteral = (Literal) opRight;\n+                } else {\n+                    opLiteral = null;\n+                }\n+            }\n+\n+            // can it be quickly fast-tracked that the operation can't be reduced?\n+            boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                if (opLiteral == null) {\n+                    // one of the arithm. operands must be a literal, otherwise the operation wouldn't simplify anything\n+                    return true;\n+                }\n+\n+                // Only operations on fixed point literals are supported, since optimizing float point operations can also change the\n+                // outcome of the filtering:\n+                //    x + 1e18 > 1e18::long will yield different results with a field value in [-2^6, 2^6], optimised vs original;\n+                //    x * (1 + 1e-15d) > 1 : same with a field value of (1 - 1e-15d)\n+                // so consequently, int fields optimisation requiring FP arithmetic isn't possible either: (x - 1e-15) * (1 + 1e-15) > 1.\n+                if (opLiteral.dataType().isRational() || bcLiteral.dataType().isRational()) {\n+                    return true;\n+                }\n+\n+                // the Literal will be moved to the right of the comparison, but only if data-compatible with what's there\n+                return typesCompatible.apply(bcLiteral.dataType(), opLiteral.dataType()) == false;\n+            }\n+\n+            Expression doSimplify() {\n+                // force float point folding for FlP field\n+                Literal bcl = operation.dataType().isRational()\n+                    ? Literal.of(bcLiteral, ((Number) bcLiteral.value()).doubleValue())\n+                    : bcLiteral;\n+\n+                if (operation instanceof BinaryComparisonInvertible == false) { // should be an assertion?\n+                    throw new QlIllegalArgumentException(\"Unexpected [\" + operation.symbol() + \"] operation object\");\n+                }\n+                Expression bcRightExpression = ((BinaryComparisonInvertible) operation).binaryComparisonInverse()\n+                    .create(bcl.source(), bcl, opRight);\n+                bcRightExpression = safeMaybeFold(bcRightExpression);\n+                return bcRightExpression == null ? comparison : comparison.replaceChildren(List.of(opLeft, bcRightExpression));\n+            }\n+\n+            static Expression simplify(BinaryComparison comparison, BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                ArithmeticOperation operation = (ArithmeticOperation) comparison.left();\n+                // Use symbol comp: SQL operations aren't available in this package (as dependencies)\n+                String opSymbol = operation.symbol();\n+                // Modulo can't be simplified.\n+                if (MOD.symbol().equals(opSymbol)) {\n+                    return comparison;\n+                }\n+                SimplifyOperation simplify = null;\n+                if (isMulOrDiv(opSymbol)) {\n+                    simplify = new SimplifyMulDiv(comparison);\n+                } else if (ADD.symbol().equals(opSymbol) || SUB.symbol().equals(opSymbol)) {\n+                    simplify = new SimplifyAddSub(comparison);\n+                }\n+\n+                return (simplify == null || simplify.cannotSimplify(typesCompatible)) ? comparison : simplify.doSimplify();\n+            }\n+\n+            static boolean isMulOrDiv(String opSymbol) {\n+                return MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol);\n+            }\n+        }\n+\n+        private static class SimplifyAddSub extends SimplifyOperation {\n+\n+            SimplifyAddSub(BinaryComparison comparison) {\n+                super(comparison);\n+            }\n+\n+            @Override\n+            boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                // no ADD/SUB with floating fields\n+                return operation.dataType().isRational() || super.cannotSimplify(typesCompatible);\n+            }\n+\n+            @Override\n+            Expression doSimplify() {\n+                if (SUB.symbol().equals(operation.symbol()) && opRight instanceof Literal == false) {\n+                    // if next simplification step would fail on overflow anyways, skip the optimisation already\n+                    if (safeMaybeFold(new Sub(EMPTY, opLeft, bcLiteral)) == null) {\n+                        return comparison;\n+                    }\n+                }\n+                return super.doSimplify();\n+            }\n+        }\n+\n+        private static class SimplifyMulDiv extends SimplifyOperation {\n+\n+            private final boolean isDiv; // and not MUL.\n+\n+            SimplifyMulDiv(BinaryComparison comparison) {\n+                super(comparison);\n+                isDiv = DIV.symbol().equals(operation.symbol());\n+            }\n+\n+            @Override\n+            boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                // Integer divisions are not safe to optimise: x / 5 > 1 <=/=> x > 5 for x in [6, 9]; same for the `==` comp\n+                return operation.dataType().isInteger() && isDiv || super.cannotSimplify(typesCompatible);\n+            }\n+\n+            @Override\n+            Expression doSimplify() {\n+                // If current operation is a multiplication, it's inverse will be a division: safe only if outcome is still integral.\n+                if (isDiv == false && opLeft.dataType().isInteger()) {\n+                    long opLiteralValue = ((Number) opLiteral.value()).longValue();\n+                    if (opLiteralValue == 0 || ((Number) bcLiteral.value()).longValue() % opLiteralValue != 0) {\n+                        return comparison;\n+                    }\n+                }\n+                // negative multiplication/division changes the direction of the comparison\n+                int sign = sign(opRight);\n+                if (sign == 0) {\n+                    return comparison;\n+                }\n+                BinaryComparison bc = (BinaryComparison) super.doSimplify();\n+                return sign < 0 ? bc.reverse() : bc;\n+            }\n+\n+            private int sign(Object obj) {\n+                int sign = 1;\n+                if (obj instanceof Number) {\n+                    double d = ((Number) obj).doubleValue();\n+                    sign = d == 0 ? 0 : (d < 0 ? -1 : 1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY5MTk0OA=="}, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 251}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxMTE1ODQ1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQyMDo1OTowMlrOIT3Agg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QxMToyNjo1OVrOIbDGPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY5NTEwNg==", "bodyText": "Since submethods keep calling the super method, instead of overriding it declare a separate method that is empty in the base class which subclasses can call:\ncheckSimplification() {\n  ...code...\n  extraChecks()\n}\n\nprotected extraChecks() {}\n\nNaming could be improved though.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r557695106", "createdAt": "2021-01-14T20:59:02Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression literalNeg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return literalNeg == null ? bc : bc.reverse().replaceChildren(List.of(((Neg) bc.left()).field(), literalNeg));\n+        }\n+\n+        static Expression safeMaybeFold(Expression expression) {\n+            if (expression.foldable()) {\n+                try {\n+                    expression = new Literal(expression.source(), expression.fold(), expression.dataType());\n+                } catch (ArithmeticException | DateTimeException e) {\n+                    expression = null;\n+                }\n+            }\n+            return expression;\n+        }\n+\n+        private static class SimplifyOperation {\n+            final BinaryComparison comparison;\n+            final Literal bcLiteral;\n+            final ArithmeticOperation operation;\n+            final Expression opLeft;\n+            final Expression opRight;\n+            final Literal opLiteral;\n+\n+            SimplifyOperation(BinaryComparison comparison) {\n+                this.comparison = comparison;\n+                operation = (ArithmeticOperation) comparison.left();\n+                bcLiteral = (Literal) comparison.right();\n+\n+                opLeft = operation.left();\n+                opRight = operation.right();\n+\n+                if (opLeft instanceof Literal) {\n+                    opLiteral = (Literal) opLeft;\n+                } else if (opRight instanceof Literal) {\n+                    opLiteral = (Literal) opRight;\n+                } else {\n+                    opLiteral = null;\n+                }\n+            }\n+\n+            // can it be quickly fast-tracked that the operation can't be reduced?\n+            boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                if (opLiteral == null) {\n+                    // one of the arithm. operands must be a literal, otherwise the operation wouldn't simplify anything\n+                    return true;\n+                }\n+\n+                // Only operations on fixed point literals are supported, since optimizing float point operations can also change the\n+                // outcome of the filtering:\n+                //    x + 1e18 > 1e18::long will yield different results with a field value in [-2^6, 2^6], optimised vs original;\n+                //    x * (1 + 1e-15d) > 1 : same with a field value of (1 - 1e-15d)\n+                // so consequently, int fields optimisation requiring FP arithmetic isn't possible either: (x - 1e-15) * (1 + 1e-15) > 1.\n+                if (opLiteral.dataType().isRational() || bcLiteral.dataType().isRational()) {\n+                    return true;\n+                }\n+\n+                // the Literal will be moved to the right of the comparison, but only if data-compatible with what's there\n+                return typesCompatible.apply(bcLiteral.dataType(), opLiteral.dataType()) == false;\n+            }\n+\n+            Expression doSimplify() {\n+                // force float point folding for FlP field\n+                Literal bcl = operation.dataType().isRational()\n+                    ? Literal.of(bcLiteral, ((Number) bcLiteral.value()).doubleValue())\n+                    : bcLiteral;\n+\n+                if (operation instanceof BinaryComparisonInvertible == false) { // should be an assertion?\n+                    throw new QlIllegalArgumentException(\"Unexpected [\" + operation.symbol() + \"] operation object\");\n+                }\n+                Expression bcRightExpression = ((BinaryComparisonInvertible) operation).binaryComparisonInverse()\n+                    .create(bcl.source(), bcl, opRight);\n+                bcRightExpression = safeMaybeFold(bcRightExpression);\n+                return bcRightExpression == null ? comparison : comparison.replaceChildren(List.of(opLeft, bcRightExpression));\n+            }\n+\n+            static Expression simplify(BinaryComparison comparison, BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                ArithmeticOperation operation = (ArithmeticOperation) comparison.left();\n+                // Use symbol comp: SQL operations aren't available in this package (as dependencies)\n+                String opSymbol = operation.symbol();\n+                // Modulo can't be simplified.\n+                if (MOD.symbol().equals(opSymbol)) {\n+                    return comparison;\n+                }\n+                SimplifyOperation simplify = null;\n+                if (isMulOrDiv(opSymbol)) {\n+                    simplify = new SimplifyMulDiv(comparison);\n+                } else if (ADD.symbol().equals(opSymbol) || SUB.symbol().equals(opSymbol)) {\n+                    simplify = new SimplifyAddSub(comparison);\n+                }\n+\n+                return (simplify == null || simplify.cannotSimplify(typesCompatible)) ? comparison : simplify.doSimplify();\n+            }\n+\n+            static boolean isMulOrDiv(String opSymbol) {\n+                return MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol);\n+            }\n+        }\n+\n+        private static class SimplifyAddSub extends SimplifyOperation {\n+\n+            SimplifyAddSub(BinaryComparison comparison) {\n+                super(comparison);\n+            }\n+\n+            @Override\n+            boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                // no ADD/SUB with floating fields\n+                return operation.dataType().isRational() || super.cannotSimplify(typesCompatible);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 199}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTIzMzIxNQ==", "bodyText": "Separate methods declared.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r565233215", "createdAt": "2021-01-27T11:26:59Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression literalNeg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return literalNeg == null ? bc : bc.reverse().replaceChildren(List.of(((Neg) bc.left()).field(), literalNeg));\n+        }\n+\n+        static Expression safeMaybeFold(Expression expression) {\n+            if (expression.foldable()) {\n+                try {\n+                    expression = new Literal(expression.source(), expression.fold(), expression.dataType());\n+                } catch (ArithmeticException | DateTimeException e) {\n+                    expression = null;\n+                }\n+            }\n+            return expression;\n+        }\n+\n+        private static class SimplifyOperation {\n+            final BinaryComparison comparison;\n+            final Literal bcLiteral;\n+            final ArithmeticOperation operation;\n+            final Expression opLeft;\n+            final Expression opRight;\n+            final Literal opLiteral;\n+\n+            SimplifyOperation(BinaryComparison comparison) {\n+                this.comparison = comparison;\n+                operation = (ArithmeticOperation) comparison.left();\n+                bcLiteral = (Literal) comparison.right();\n+\n+                opLeft = operation.left();\n+                opRight = operation.right();\n+\n+                if (opLeft instanceof Literal) {\n+                    opLiteral = (Literal) opLeft;\n+                } else if (opRight instanceof Literal) {\n+                    opLiteral = (Literal) opRight;\n+                } else {\n+                    opLiteral = null;\n+                }\n+            }\n+\n+            // can it be quickly fast-tracked that the operation can't be reduced?\n+            boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                if (opLiteral == null) {\n+                    // one of the arithm. operands must be a literal, otherwise the operation wouldn't simplify anything\n+                    return true;\n+                }\n+\n+                // Only operations on fixed point literals are supported, since optimizing float point operations can also change the\n+                // outcome of the filtering:\n+                //    x + 1e18 > 1e18::long will yield different results with a field value in [-2^6, 2^6], optimised vs original;\n+                //    x * (1 + 1e-15d) > 1 : same with a field value of (1 - 1e-15d)\n+                // so consequently, int fields optimisation requiring FP arithmetic isn't possible either: (x - 1e-15) * (1 + 1e-15) > 1.\n+                if (opLiteral.dataType().isRational() || bcLiteral.dataType().isRational()) {\n+                    return true;\n+                }\n+\n+                // the Literal will be moved to the right of the comparison, but only if data-compatible with what's there\n+                return typesCompatible.apply(bcLiteral.dataType(), opLiteral.dataType()) == false;\n+            }\n+\n+            Expression doSimplify() {\n+                // force float point folding for FlP field\n+                Literal bcl = operation.dataType().isRational()\n+                    ? Literal.of(bcLiteral, ((Number) bcLiteral.value()).doubleValue())\n+                    : bcLiteral;\n+\n+                if (operation instanceof BinaryComparisonInvertible == false) { // should be an assertion?\n+                    throw new QlIllegalArgumentException(\"Unexpected [\" + operation.symbol() + \"] operation object\");\n+                }\n+                Expression bcRightExpression = ((BinaryComparisonInvertible) operation).binaryComparisonInverse()\n+                    .create(bcl.source(), bcl, opRight);\n+                bcRightExpression = safeMaybeFold(bcRightExpression);\n+                return bcRightExpression == null ? comparison : comparison.replaceChildren(List.of(opLeft, bcRightExpression));\n+            }\n+\n+            static Expression simplify(BinaryComparison comparison, BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                ArithmeticOperation operation = (ArithmeticOperation) comparison.left();\n+                // Use symbol comp: SQL operations aren't available in this package (as dependencies)\n+                String opSymbol = operation.symbol();\n+                // Modulo can't be simplified.\n+                if (MOD.symbol().equals(opSymbol)) {\n+                    return comparison;\n+                }\n+                SimplifyOperation simplify = null;\n+                if (isMulOrDiv(opSymbol)) {\n+                    simplify = new SimplifyMulDiv(comparison);\n+                } else if (ADD.symbol().equals(opSymbol) || SUB.symbol().equals(opSymbol)) {\n+                    simplify = new SimplifyAddSub(comparison);\n+                }\n+\n+                return (simplify == null || simplify.cannotSimplify(typesCompatible)) ? comparison : simplify.doSimplify();\n+            }\n+\n+            static boolean isMulOrDiv(String opSymbol) {\n+                return MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol);\n+            }\n+        }\n+\n+        private static class SimplifyAddSub extends SimplifyOperation {\n+\n+            SimplifyAddSub(BinaryComparison comparison) {\n+                super(comparison);\n+            }\n+\n+            @Override\n+            boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                // no ADD/SUB with floating fields\n+                return operation.dataType().isRational() || super.cannotSimplify(typesCompatible);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY5NTEwNg=="}, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 199}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxMTE2MjYyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQyMTowMDoxNFrOIT3C-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QxMToyNzozMlrOIbDHtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY5NTczNw==", "bodyText": "Check the enums directly, don't use their names.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r557695737", "createdAt": "2021-01-14T21:00:14Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression literalNeg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return literalNeg == null ? bc : bc.reverse().replaceChildren(List.of(((Neg) bc.left()).field(), literalNeg));\n+        }\n+\n+        static Expression safeMaybeFold(Expression expression) {\n+            if (expression.foldable()) {\n+                try {\n+                    expression = new Literal(expression.source(), expression.fold(), expression.dataType());\n+                } catch (ArithmeticException | DateTimeException e) {\n+                    expression = null;\n+                }\n+            }\n+            return expression;\n+        }\n+\n+        private static class SimplifyOperation {\n+            final BinaryComparison comparison;\n+            final Literal bcLiteral;\n+            final ArithmeticOperation operation;\n+            final Expression opLeft;\n+            final Expression opRight;\n+            final Literal opLiteral;\n+\n+            SimplifyOperation(BinaryComparison comparison) {\n+                this.comparison = comparison;\n+                operation = (ArithmeticOperation) comparison.left();\n+                bcLiteral = (Literal) comparison.right();\n+\n+                opLeft = operation.left();\n+                opRight = operation.right();\n+\n+                if (opLeft instanceof Literal) {\n+                    opLiteral = (Literal) opLeft;\n+                } else if (opRight instanceof Literal) {\n+                    opLiteral = (Literal) opRight;\n+                } else {\n+                    opLiteral = null;\n+                }\n+            }\n+\n+            // can it be quickly fast-tracked that the operation can't be reduced?\n+            boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                if (opLiteral == null) {\n+                    // one of the arithm. operands must be a literal, otherwise the operation wouldn't simplify anything\n+                    return true;\n+                }\n+\n+                // Only operations on fixed point literals are supported, since optimizing float point operations can also change the\n+                // outcome of the filtering:\n+                //    x + 1e18 > 1e18::long will yield different results with a field value in [-2^6, 2^6], optimised vs original;\n+                //    x * (1 + 1e-15d) > 1 : same with a field value of (1 - 1e-15d)\n+                // so consequently, int fields optimisation requiring FP arithmetic isn't possible either: (x - 1e-15) * (1 + 1e-15) > 1.\n+                if (opLiteral.dataType().isRational() || bcLiteral.dataType().isRational()) {\n+                    return true;\n+                }\n+\n+                // the Literal will be moved to the right of the comparison, but only if data-compatible with what's there\n+                return typesCompatible.apply(bcLiteral.dataType(), opLiteral.dataType()) == false;\n+            }\n+\n+            Expression doSimplify() {\n+                // force float point folding for FlP field\n+                Literal bcl = operation.dataType().isRational()\n+                    ? Literal.of(bcLiteral, ((Number) bcLiteral.value()).doubleValue())\n+                    : bcLiteral;\n+\n+                if (operation instanceof BinaryComparisonInvertible == false) { // should be an assertion?\n+                    throw new QlIllegalArgumentException(\"Unexpected [\" + operation.symbol() + \"] operation object\");\n+                }\n+                Expression bcRightExpression = ((BinaryComparisonInvertible) operation).binaryComparisonInverse()\n+                    .create(bcl.source(), bcl, opRight);\n+                bcRightExpression = safeMaybeFold(bcRightExpression);\n+                return bcRightExpression == null ? comparison : comparison.replaceChildren(List.of(opLeft, bcRightExpression));\n+            }\n+\n+            static Expression simplify(BinaryComparison comparison, BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                ArithmeticOperation operation = (ArithmeticOperation) comparison.left();\n+                // Use symbol comp: SQL operations aren't available in this package (as dependencies)\n+                String opSymbol = operation.symbol();\n+                // Modulo can't be simplified.\n+                if (MOD.symbol().equals(opSymbol)) {\n+                    return comparison;\n+                }\n+                SimplifyOperation simplify = null;\n+                if (isMulOrDiv(opSymbol)) {\n+                    simplify = new SimplifyMulDiv(comparison);\n+                } else if (ADD.symbol().equals(opSymbol) || SUB.symbol().equals(opSymbol)) {\n+                    simplify = new SimplifyAddSub(comparison);\n+                }\n+\n+                return (simplify == null || simplify.cannotSimplify(typesCompatible)) ? comparison : simplify.doSimplify();\n+            }\n+\n+            static boolean isMulOrDiv(String opSymbol) {\n+                return MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol);\n+            }\n+        }\n+\n+        private static class SimplifyAddSub extends SimplifyOperation {\n+\n+            SimplifyAddSub(BinaryComparison comparison) {\n+                super(comparison);\n+            }\n+\n+            @Override\n+            boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                // no ADD/SUB with floating fields\n+                return operation.dataType().isRational() || super.cannotSimplify(typesCompatible);\n+            }\n+\n+            @Override\n+            Expression doSimplify() {\n+                if (SUB.symbol().equals(operation.symbol()) && opRight instanceof Literal == false) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 204}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY5NjA2OA==", "bodyText": "Also is this condition correct? the else (parent doSimplify) is picked if it is a sub but the opRight is a literal", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r557696068", "createdAt": "2021-01-14T21:00:59Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression literalNeg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return literalNeg == null ? bc : bc.reverse().replaceChildren(List.of(((Neg) bc.left()).field(), literalNeg));\n+        }\n+\n+        static Expression safeMaybeFold(Expression expression) {\n+            if (expression.foldable()) {\n+                try {\n+                    expression = new Literal(expression.source(), expression.fold(), expression.dataType());\n+                } catch (ArithmeticException | DateTimeException e) {\n+                    expression = null;\n+                }\n+            }\n+            return expression;\n+        }\n+\n+        private static class SimplifyOperation {\n+            final BinaryComparison comparison;\n+            final Literal bcLiteral;\n+            final ArithmeticOperation operation;\n+            final Expression opLeft;\n+            final Expression opRight;\n+            final Literal opLiteral;\n+\n+            SimplifyOperation(BinaryComparison comparison) {\n+                this.comparison = comparison;\n+                operation = (ArithmeticOperation) comparison.left();\n+                bcLiteral = (Literal) comparison.right();\n+\n+                opLeft = operation.left();\n+                opRight = operation.right();\n+\n+                if (opLeft instanceof Literal) {\n+                    opLiteral = (Literal) opLeft;\n+                } else if (opRight instanceof Literal) {\n+                    opLiteral = (Literal) opRight;\n+                } else {\n+                    opLiteral = null;\n+                }\n+            }\n+\n+            // can it be quickly fast-tracked that the operation can't be reduced?\n+            boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                if (opLiteral == null) {\n+                    // one of the arithm. operands must be a literal, otherwise the operation wouldn't simplify anything\n+                    return true;\n+                }\n+\n+                // Only operations on fixed point literals are supported, since optimizing float point operations can also change the\n+                // outcome of the filtering:\n+                //    x + 1e18 > 1e18::long will yield different results with a field value in [-2^6, 2^6], optimised vs original;\n+                //    x * (1 + 1e-15d) > 1 : same with a field value of (1 - 1e-15d)\n+                // so consequently, int fields optimisation requiring FP arithmetic isn't possible either: (x - 1e-15) * (1 + 1e-15) > 1.\n+                if (opLiteral.dataType().isRational() || bcLiteral.dataType().isRational()) {\n+                    return true;\n+                }\n+\n+                // the Literal will be moved to the right of the comparison, but only if data-compatible with what's there\n+                return typesCompatible.apply(bcLiteral.dataType(), opLiteral.dataType()) == false;\n+            }\n+\n+            Expression doSimplify() {\n+                // force float point folding for FlP field\n+                Literal bcl = operation.dataType().isRational()\n+                    ? Literal.of(bcLiteral, ((Number) bcLiteral.value()).doubleValue())\n+                    : bcLiteral;\n+\n+                if (operation instanceof BinaryComparisonInvertible == false) { // should be an assertion?\n+                    throw new QlIllegalArgumentException(\"Unexpected [\" + operation.symbol() + \"] operation object\");\n+                }\n+                Expression bcRightExpression = ((BinaryComparisonInvertible) operation).binaryComparisonInverse()\n+                    .create(bcl.source(), bcl, opRight);\n+                bcRightExpression = safeMaybeFold(bcRightExpression);\n+                return bcRightExpression == null ? comparison : comparison.replaceChildren(List.of(opLeft, bcRightExpression));\n+            }\n+\n+            static Expression simplify(BinaryComparison comparison, BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                ArithmeticOperation operation = (ArithmeticOperation) comparison.left();\n+                // Use symbol comp: SQL operations aren't available in this package (as dependencies)\n+                String opSymbol = operation.symbol();\n+                // Modulo can't be simplified.\n+                if (MOD.symbol().equals(opSymbol)) {\n+                    return comparison;\n+                }\n+                SimplifyOperation simplify = null;\n+                if (isMulOrDiv(opSymbol)) {\n+                    simplify = new SimplifyMulDiv(comparison);\n+                } else if (ADD.symbol().equals(opSymbol) || SUB.symbol().equals(opSymbol)) {\n+                    simplify = new SimplifyAddSub(comparison);\n+                }\n+\n+                return (simplify == null || simplify.cannotSimplify(typesCompatible)) ? comparison : simplify.doSimplify();\n+            }\n+\n+            static boolean isMulOrDiv(String opSymbol) {\n+                return MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol);\n+            }\n+        }\n+\n+        private static class SimplifyAddSub extends SimplifyOperation {\n+\n+            SimplifyAddSub(BinaryComparison comparison) {\n+                super(comparison);\n+            }\n+\n+            @Override\n+            boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                // no ADD/SUB with floating fields\n+                return operation.dataType().isRational() || super.cannotSimplify(typesCompatible);\n+            }\n+\n+            @Override\n+            Expression doSimplify() {\n+                if (SUB.symbol().equals(operation.symbol()) && opRight instanceof Literal == false) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY5NTczNw=="}, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 204}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTIzMzU5MA==", "bodyText": "Check the enums directly, don't use their names.\n\nSee above.\n\nAlso is this condition correct? the else (parent doSimplify) is picked if it is a sub but the opRight is a literal\n\nIt is correct: in the else-case the literal has simply been \"normalised\" to the right and the simplification can be attempted.\nThe check you're referring to (in the child SimplifyAddSub) is there to avoid transforming the expression that ultimately still can't be simplified; ex.: for 1 - x > -MAX, w/o the check, the next transformation would be x - MAX < 1 and then it would stop there, since MAX + 1 would overflow. That's what the comment on the first line below the last in the snippet above indicates.\nBut if the literal is on the right already (x - 1 ...), the optimisation can be attempted in the parent doSimplify (as per previous naming).", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r565233590", "createdAt": "2021-01-27T11:27:32Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression literalNeg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return literalNeg == null ? bc : bc.reverse().replaceChildren(List.of(((Neg) bc.left()).field(), literalNeg));\n+        }\n+\n+        static Expression safeMaybeFold(Expression expression) {\n+            if (expression.foldable()) {\n+                try {\n+                    expression = new Literal(expression.source(), expression.fold(), expression.dataType());\n+                } catch (ArithmeticException | DateTimeException e) {\n+                    expression = null;\n+                }\n+            }\n+            return expression;\n+        }\n+\n+        private static class SimplifyOperation {\n+            final BinaryComparison comparison;\n+            final Literal bcLiteral;\n+            final ArithmeticOperation operation;\n+            final Expression opLeft;\n+            final Expression opRight;\n+            final Literal opLiteral;\n+\n+            SimplifyOperation(BinaryComparison comparison) {\n+                this.comparison = comparison;\n+                operation = (ArithmeticOperation) comparison.left();\n+                bcLiteral = (Literal) comparison.right();\n+\n+                opLeft = operation.left();\n+                opRight = operation.right();\n+\n+                if (opLeft instanceof Literal) {\n+                    opLiteral = (Literal) opLeft;\n+                } else if (opRight instanceof Literal) {\n+                    opLiteral = (Literal) opRight;\n+                } else {\n+                    opLiteral = null;\n+                }\n+            }\n+\n+            // can it be quickly fast-tracked that the operation can't be reduced?\n+            boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                if (opLiteral == null) {\n+                    // one of the arithm. operands must be a literal, otherwise the operation wouldn't simplify anything\n+                    return true;\n+                }\n+\n+                // Only operations on fixed point literals are supported, since optimizing float point operations can also change the\n+                // outcome of the filtering:\n+                //    x + 1e18 > 1e18::long will yield different results with a field value in [-2^6, 2^6], optimised vs original;\n+                //    x * (1 + 1e-15d) > 1 : same with a field value of (1 - 1e-15d)\n+                // so consequently, int fields optimisation requiring FP arithmetic isn't possible either: (x - 1e-15) * (1 + 1e-15) > 1.\n+                if (opLiteral.dataType().isRational() || bcLiteral.dataType().isRational()) {\n+                    return true;\n+                }\n+\n+                // the Literal will be moved to the right of the comparison, but only if data-compatible with what's there\n+                return typesCompatible.apply(bcLiteral.dataType(), opLiteral.dataType()) == false;\n+            }\n+\n+            Expression doSimplify() {\n+                // force float point folding for FlP field\n+                Literal bcl = operation.dataType().isRational()\n+                    ? Literal.of(bcLiteral, ((Number) bcLiteral.value()).doubleValue())\n+                    : bcLiteral;\n+\n+                if (operation instanceof BinaryComparisonInvertible == false) { // should be an assertion?\n+                    throw new QlIllegalArgumentException(\"Unexpected [\" + operation.symbol() + \"] operation object\");\n+                }\n+                Expression bcRightExpression = ((BinaryComparisonInvertible) operation).binaryComparisonInverse()\n+                    .create(bcl.source(), bcl, opRight);\n+                bcRightExpression = safeMaybeFold(bcRightExpression);\n+                return bcRightExpression == null ? comparison : comparison.replaceChildren(List.of(opLeft, bcRightExpression));\n+            }\n+\n+            static Expression simplify(BinaryComparison comparison, BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                ArithmeticOperation operation = (ArithmeticOperation) comparison.left();\n+                // Use symbol comp: SQL operations aren't available in this package (as dependencies)\n+                String opSymbol = operation.symbol();\n+                // Modulo can't be simplified.\n+                if (MOD.symbol().equals(opSymbol)) {\n+                    return comparison;\n+                }\n+                SimplifyOperation simplify = null;\n+                if (isMulOrDiv(opSymbol)) {\n+                    simplify = new SimplifyMulDiv(comparison);\n+                } else if (ADD.symbol().equals(opSymbol) || SUB.symbol().equals(opSymbol)) {\n+                    simplify = new SimplifyAddSub(comparison);\n+                }\n+\n+                return (simplify == null || simplify.cannotSimplify(typesCompatible)) ? comparison : simplify.doSimplify();\n+            }\n+\n+            static boolean isMulOrDiv(String opSymbol) {\n+                return MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol);\n+            }\n+        }\n+\n+        private static class SimplifyAddSub extends SimplifyOperation {\n+\n+            SimplifyAddSub(BinaryComparison comparison) {\n+                super(comparison);\n+            }\n+\n+            @Override\n+            boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                // no ADD/SUB with floating fields\n+                return operation.dataType().isRational() || super.cannotSimplify(typesCompatible);\n+            }\n+\n+            @Override\n+            Expression doSimplify() {\n+                if (SUB.symbol().equals(operation.symbol()) && opRight instanceof Literal == false) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY5NTczNw=="}, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 204}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxMTE2ODYzOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQyMTowMjoyN1rOIT3G6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QxMToyODoxOFrOIbDJuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY5Njc0Nw==", "bodyText": "Looks like this method is never called in this form, subclasses always override it and enhance it. If that's the case, simply declare the method as is and declare a separate one as abstract which subclasses are forced to override and in where they can call this method.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r557696747", "createdAt": "2021-01-14T21:02:27Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression literalNeg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return literalNeg == null ? bc : bc.reverse().replaceChildren(List.of(((Neg) bc.left()).field(), literalNeg));\n+        }\n+\n+        static Expression safeMaybeFold(Expression expression) {\n+            if (expression.foldable()) {\n+                try {\n+                    expression = new Literal(expression.source(), expression.fold(), expression.dataType());\n+                } catch (ArithmeticException | DateTimeException e) {\n+                    expression = null;\n+                }\n+            }\n+            return expression;\n+        }\n+\n+        private static class SimplifyOperation {\n+            final BinaryComparison comparison;\n+            final Literal bcLiteral;\n+            final ArithmeticOperation operation;\n+            final Expression opLeft;\n+            final Expression opRight;\n+            final Literal opLiteral;\n+\n+            SimplifyOperation(BinaryComparison comparison) {\n+                this.comparison = comparison;\n+                operation = (ArithmeticOperation) comparison.left();\n+                bcLiteral = (Literal) comparison.right();\n+\n+                opLeft = operation.left();\n+                opRight = operation.right();\n+\n+                if (opLeft instanceof Literal) {\n+                    opLiteral = (Literal) opLeft;\n+                } else if (opRight instanceof Literal) {\n+                    opLiteral = (Literal) opRight;\n+                } else {\n+                    opLiteral = null;\n+                }\n+            }\n+\n+            // can it be quickly fast-tracked that the operation can't be reduced?\n+            boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                if (opLiteral == null) {\n+                    // one of the arithm. operands must be a literal, otherwise the operation wouldn't simplify anything\n+                    return true;\n+                }\n+\n+                // Only operations on fixed point literals are supported, since optimizing float point operations can also change the\n+                // outcome of the filtering:\n+                //    x + 1e18 > 1e18::long will yield different results with a field value in [-2^6, 2^6], optimised vs original;\n+                //    x * (1 + 1e-15d) > 1 : same with a field value of (1 - 1e-15d)\n+                // so consequently, int fields optimisation requiring FP arithmetic isn't possible either: (x - 1e-15) * (1 + 1e-15) > 1.\n+                if (opLiteral.dataType().isRational() || bcLiteral.dataType().isRational()) {\n+                    return true;\n+                }\n+\n+                // the Literal will be moved to the right of the comparison, but only if data-compatible with what's there\n+                return typesCompatible.apply(bcLiteral.dataType(), opLiteral.dataType()) == false;\n+            }\n+\n+            Expression doSimplify() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTIzNDEwNA==", "bodyText": "The method was called in that form, but anyways, code got refactored as per the feedback.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r565234104", "createdAt": "2021-01-27T11:28:18Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression literalNeg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return literalNeg == null ? bc : bc.reverse().replaceChildren(List.of(((Neg) bc.left()).field(), literalNeg));\n+        }\n+\n+        static Expression safeMaybeFold(Expression expression) {\n+            if (expression.foldable()) {\n+                try {\n+                    expression = new Literal(expression.source(), expression.fold(), expression.dataType());\n+                } catch (ArithmeticException | DateTimeException e) {\n+                    expression = null;\n+                }\n+            }\n+            return expression;\n+        }\n+\n+        private static class SimplifyOperation {\n+            final BinaryComparison comparison;\n+            final Literal bcLiteral;\n+            final ArithmeticOperation operation;\n+            final Expression opLeft;\n+            final Expression opRight;\n+            final Literal opLiteral;\n+\n+            SimplifyOperation(BinaryComparison comparison) {\n+                this.comparison = comparison;\n+                operation = (ArithmeticOperation) comparison.left();\n+                bcLiteral = (Literal) comparison.right();\n+\n+                opLeft = operation.left();\n+                opRight = operation.right();\n+\n+                if (opLeft instanceof Literal) {\n+                    opLiteral = (Literal) opLeft;\n+                } else if (opRight instanceof Literal) {\n+                    opLiteral = (Literal) opRight;\n+                } else {\n+                    opLiteral = null;\n+                }\n+            }\n+\n+            // can it be quickly fast-tracked that the operation can't be reduced?\n+            boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                if (opLiteral == null) {\n+                    // one of the arithm. operands must be a literal, otherwise the operation wouldn't simplify anything\n+                    return true;\n+                }\n+\n+                // Only operations on fixed point literals are supported, since optimizing float point operations can also change the\n+                // outcome of the filtering:\n+                //    x + 1e18 > 1e18::long will yield different results with a field value in [-2^6, 2^6], optimised vs original;\n+                //    x * (1 + 1e-15d) > 1 : same with a field value of (1 - 1e-15d)\n+                // so consequently, int fields optimisation requiring FP arithmetic isn't possible either: (x - 1e-15) * (1 + 1e-15) > 1.\n+                if (opLiteral.dataType().isRational() || bcLiteral.dataType().isRational()) {\n+                    return true;\n+                }\n+\n+                // the Literal will be moved to the right of the comparison, but only if data-compatible with what's there\n+                return typesCompatible.apply(bcLiteral.dataType(), opLiteral.dataType()) == false;\n+            }\n+\n+            Expression doSimplify() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY5Njc0Nw=="}, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 152}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxMTIxMjIxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQyMToxNTozN1rOIT3hUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QxMToyODozNlrOIbDKcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzcwMzUwNg==", "bodyText": "typesCompatible -> typeCheck", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r557703506", "createdAt": "2021-01-14T21:15:37Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTIzNDI4OQ==", "bodyText": "Before I change it, just to 2x check: the passed arguments are DataTypes::areCompatible and SqlDataTypes::areCompatible.\nThe code using the var also looks like return typesCompatible.apply([type1], [type2]) == false;.\nNot sure if the change would bring more clarity (\"what's checked?\"), so asking.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r565234289", "createdAt": "2021-01-27T11:28:36Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzcwMzUwNg=="}, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyNjA3ODA3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwODowMDo0NlrOIWCSXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOFQwODo0MjoyMFrOIbsbuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTk3NzA1NA==", "bodyText": "I don't particularly like this method and, imo, it doesn't help much understanding the code. I think the return null inside the catch block bothers me.\nI would have kept the original (no separate method used) block of code, as I find it easier to read.\n        private static Expression reduceNegation(BinaryComparison bc) {\n            Literal bcLiteral = (Literal) bc.right();\n            Expression expression = new Neg(bcLiteral.source(), bcLiteral);\n            if (expression.foldable()) {\n                try {\n                    expression = new Literal(expression.source(), expression.fold(), expression.dataType());\n                    return bc.reverse().replaceChildren(List.of(((Neg) bc.left()).field(), expression));\n                } catch (ArithmeticException | DateTimeException e) {\n                    // implicitly return the original BinaryComparison in case the folding results in scenarios where,\n                    // for example, we have Long.MAX_VALUE+1 to fold. In this case, we skip the optimization.\n                }\n            }\n            return bc;\n        }", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r559977054", "createdAt": "2021-01-19T08:00:46Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression literalNeg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return literalNeg == null ? bc : bc.reverse().replaceChildren(List.of(((Neg) bc.left()).field(), literalNeg));\n+        }\n+\n+        static Expression safeMaybeFold(Expression expression) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTIzNTEwOQ==", "bodyText": "I think the return null inside the catch block bothers me.\n\nThe null isn't returned from the catch block, it's just assigned to the var to return.\nBut this still being a detail, would you mind expanding what's troubling / how it could be improved?\n\nI would have kept the original (no separate method used)\n\nThe code is extracted as a method since it's reused. It should be acceptably concise too: \"if the expression is foldable, attempt to do so. Return either folded outcome, original (if not foldable) or null (if foldable, but unsafely; i.e. exception wud be thrown)\".\nAn alternative could be for the caller to save the input expression (as in your example), the function to return the original input, if folding is unsafe, and for caller to check returned value against the original input. But this would be more verbose (as in your example) and this pattern to be applied multiple times.\nFor now I've taken Costin's suggestion, but still open for change if needed.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r565235109", "createdAt": "2021-01-27T11:30:01Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression literalNeg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return literalNeg == null ? bc : bc.reverse().replaceChildren(List.of(((Neg) bc.left()).field(), literalNeg));\n+        }\n+\n+        static Expression safeMaybeFold(Expression expression) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTk3NzA1NA=="}, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTkxMDQ1Nw==", "bodyText": "Can be left as is I guess. My initial suggestion seems to be just a personal preference. If there will be other changes to this PR, I'd add a comment similar to the one I made in the catch (ArithmeticException | DateTimeException e) { to explain the catch block \"ignoring\" the math failure.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r565910457", "createdAt": "2021-01-28T08:42:20Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression literalNeg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return literalNeg == null ? bc : bc.reverse().replaceChildren(List.of(((Neg) bc.left()).field(), literalNeg));\n+        }\n+\n+        static Expression safeMaybeFold(Expression expression) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTk3NzA1NA=="}, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyNjA5NDA1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwODowNTo1MlrOIWCcQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QxMTozMzo0M1rOIbDWAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTk3OTU4NA==", "bodyText": "I think only if (bc.left().... is enough. else if doesn't necessarily help here.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r559979584", "createdAt": "2021-01-19T08:05:52Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTIzNzI0OQ==", "bodyText": "I've changed it.\n(Particularly here, the if[-else] is practically a switch, on a type that's not switchable in Java, so the change makes sense.\nGenerally I'm in favour of the if-else format when:\n\na return is involved, whose later replacement by a non-jumping statement, could make the next if branch eligible; i.e. less error-prone.\nis more compact.)", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r565237249", "createdAt": "2021-01-27T11:33:43Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTk3OTU4NA=="}, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyNjIxMDM3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwODozNjoyNlrOIWDgzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QxMTozMzo1MlrOIbDWSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTk5NzEzNQ==", "bodyText": "I think here equals is not needed for this String comparison. == should be enough. There are other similar uses in this class as well.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r559997135", "createdAt": "2021-01-19T08:36:26Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression literalNeg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return literalNeg == null ? bc : bc.reverse().replaceChildren(List.of(((Neg) bc.left()).field(), literalNeg));\n+        }\n+\n+        static Expression safeMaybeFold(Expression expression) {\n+            if (expression.foldable()) {\n+                try {\n+                    expression = new Literal(expression.source(), expression.fold(), expression.dataType());\n+                } catch (ArithmeticException | DateTimeException e) {\n+                    expression = null;\n+                }\n+            }\n+            return expression;\n+        }\n+\n+        private static class SimplifyOperation {\n+            final BinaryComparison comparison;\n+            final Literal bcLiteral;\n+            final ArithmeticOperation operation;\n+            final Expression opLeft;\n+            final Expression opRight;\n+            final Literal opLiteral;\n+\n+            SimplifyOperation(BinaryComparison comparison) {\n+                this.comparison = comparison;\n+                operation = (ArithmeticOperation) comparison.left();\n+                bcLiteral = (Literal) comparison.right();\n+\n+                opLeft = operation.left();\n+                opRight = operation.right();\n+\n+                if (opLeft instanceof Literal) {\n+                    opLiteral = (Literal) opLeft;\n+                } else if (opRight instanceof Literal) {\n+                    opLiteral = (Literal) opRight;\n+                } else {\n+                    opLiteral = null;\n+                }\n+            }\n+\n+            // can it be quickly fast-tracked that the operation can't be reduced?\n+            boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                if (opLiteral == null) {\n+                    // one of the arithm. operands must be a literal, otherwise the operation wouldn't simplify anything\n+                    return true;\n+                }\n+\n+                // Only operations on fixed point literals are supported, since optimizing float point operations can also change the\n+                // outcome of the filtering:\n+                //    x + 1e18 > 1e18::long will yield different results with a field value in [-2^6, 2^6], optimised vs original;\n+                //    x * (1 + 1e-15d) > 1 : same with a field value of (1 - 1e-15d)\n+                // so consequently, int fields optimisation requiring FP arithmetic isn't possible either: (x - 1e-15) * (1 + 1e-15) > 1.\n+                if (opLiteral.dataType().isRational() || bcLiteral.dataType().isRational()) {\n+                    return true;\n+                }\n+\n+                // the Literal will be moved to the right of the comparison, but only if data-compatible with what's there\n+                return typesCompatible.apply(bcLiteral.dataType(), opLiteral.dataType()) == false;\n+            }\n+\n+            Expression doSimplify() {\n+                // force float point folding for FlP field\n+                Literal bcl = operation.dataType().isRational()\n+                    ? Literal.of(bcLiteral, ((Number) bcLiteral.value()).doubleValue())\n+                    : bcLiteral;\n+\n+                if (operation instanceof BinaryComparisonInvertible == false) { // should be an assertion?\n+                    throw new QlIllegalArgumentException(\"Unexpected [\" + operation.symbol() + \"] operation object\");\n+                }\n+                Expression bcRightExpression = ((BinaryComparisonInvertible) operation).binaryComparisonInverse()\n+                    .create(bcl.source(), bcl, opRight);\n+                bcRightExpression = safeMaybeFold(bcRightExpression);\n+                return bcRightExpression == null ? comparison : comparison.replaceChildren(List.of(opLeft, bcRightExpression));\n+            }\n+\n+            static Expression simplify(BinaryComparison comparison, BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                ArithmeticOperation operation = (ArithmeticOperation) comparison.left();\n+                // Use symbol comp: SQL operations aren't available in this package (as dependencies)\n+                String opSymbol = operation.symbol();\n+                // Modulo can't be simplified.\n+                if (MOD.symbol().equals(opSymbol)) {\n+                    return comparison;\n+                }\n+                SimplifyOperation simplify = null;\n+                if (isMulOrDiv(opSymbol)) {\n+                    simplify = new SimplifyMulDiv(comparison);\n+                } else if (ADD.symbol().equals(opSymbol) || SUB.symbol().equals(opSymbol)) {\n+                    simplify = new SimplifyAddSub(comparison);\n+                }\n+\n+                return (simplify == null || simplify.cannotSimplify(typesCompatible)) ? comparison : simplify.doSimplify();\n+            }\n+\n+            static boolean isMulOrDiv(String opSymbol) {\n+                return MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol);\n+            }\n+        }\n+\n+        private static class SimplifyAddSub extends SimplifyOperation {\n+\n+            SimplifyAddSub(BinaryComparison comparison) {\n+                super(comparison);\n+            }\n+\n+            @Override\n+            boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                // no ADD/SUB with floating fields\n+                return operation.dataType().isRational() || super.cannotSimplify(typesCompatible);\n+            }\n+\n+            @Override\n+            Expression doSimplify() {\n+                if (SUB.symbol().equals(operation.symbol()) && opRight instanceof Literal == false) {\n+                    // if next simplification step would fail on overflow anyways, skip the optimisation already\n+                    if (safeMaybeFold(new Sub(EMPTY, opLeft, bcLiteral)) == null) {\n+                        return comparison;\n+                    }\n+                }\n+                return super.doSimplify();\n+            }\n+        }\n+\n+        private static class SimplifyMulDiv extends SimplifyOperation {\n+\n+            private final boolean isDiv; // and not MUL.\n+\n+            SimplifyMulDiv(BinaryComparison comparison) {\n+                super(comparison);\n+                isDiv = DIV.symbol().equals(operation.symbol());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 220}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTIzNzMyMw==", "bodyText": "Indeed, == should be safe for as long as we don't assign dynamic values to operations' symbols. I've changed them.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r565237323", "createdAt": "2021-01-27T11:33:52Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1137,6 +1152,209 @@ protected Expression rule(Expression e) {\n         }\n     }\n \n+    // Simplifies arithmetic expressions with fixed point fields in BinaryComparisons.\n+    public static final class SimplifyComparisonsArithmetics extends OptimizerExpressionRule {\n+        BiFunction<DataType, DataType, Boolean> typesCompatible;\n+\n+        public SimplifyComparisonsArithmetics(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            super(TransformDirection.UP);\n+            this.typesCompatible = typesCompatible;\n+        }\n+\n+        @Override\n+        protected Expression rule(Expression e) {\n+            return (e instanceof BinaryComparison) ? simplify((BinaryComparison) e) : e;\n+        }\n+\n+        private Expression simplify(BinaryComparison bc) {\n+            // optimize only once the expression has a literal on the right side of the binary comparison\n+            if (bc.right() instanceof Literal) {\n+                if (bc.left() instanceof ArithmeticOperation) {\n+                    return SimplifyOperation.simplify(bc, typesCompatible);\n+                } else if (bc.left() instanceof Neg) {\n+                    return reduceNegation(bc);\n+                }\n+            }\n+            return bc;\n+        }\n+\n+        private static Expression reduceNegation(BinaryComparison bc) {\n+            Literal bcLiteral = (Literal) bc.right();\n+            Expression literalNeg = safeMaybeFold(new Neg(bcLiteral.source(), bcLiteral));\n+            return literalNeg == null ? bc : bc.reverse().replaceChildren(List.of(((Neg) bc.left()).field(), literalNeg));\n+        }\n+\n+        static Expression safeMaybeFold(Expression expression) {\n+            if (expression.foldable()) {\n+                try {\n+                    expression = new Literal(expression.source(), expression.fold(), expression.dataType());\n+                } catch (ArithmeticException | DateTimeException e) {\n+                    expression = null;\n+                }\n+            }\n+            return expression;\n+        }\n+\n+        private static class SimplifyOperation {\n+            final BinaryComparison comparison;\n+            final Literal bcLiteral;\n+            final ArithmeticOperation operation;\n+            final Expression opLeft;\n+            final Expression opRight;\n+            final Literal opLiteral;\n+\n+            SimplifyOperation(BinaryComparison comparison) {\n+                this.comparison = comparison;\n+                operation = (ArithmeticOperation) comparison.left();\n+                bcLiteral = (Literal) comparison.right();\n+\n+                opLeft = operation.left();\n+                opRight = operation.right();\n+\n+                if (opLeft instanceof Literal) {\n+                    opLiteral = (Literal) opLeft;\n+                } else if (opRight instanceof Literal) {\n+                    opLiteral = (Literal) opRight;\n+                } else {\n+                    opLiteral = null;\n+                }\n+            }\n+\n+            // can it be quickly fast-tracked that the operation can't be reduced?\n+            boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                if (opLiteral == null) {\n+                    // one of the arithm. operands must be a literal, otherwise the operation wouldn't simplify anything\n+                    return true;\n+                }\n+\n+                // Only operations on fixed point literals are supported, since optimizing float point operations can also change the\n+                // outcome of the filtering:\n+                //    x + 1e18 > 1e18::long will yield different results with a field value in [-2^6, 2^6], optimised vs original;\n+                //    x * (1 + 1e-15d) > 1 : same with a field value of (1 - 1e-15d)\n+                // so consequently, int fields optimisation requiring FP arithmetic isn't possible either: (x - 1e-15) * (1 + 1e-15) > 1.\n+                if (opLiteral.dataType().isRational() || bcLiteral.dataType().isRational()) {\n+                    return true;\n+                }\n+\n+                // the Literal will be moved to the right of the comparison, but only if data-compatible with what's there\n+                return typesCompatible.apply(bcLiteral.dataType(), opLiteral.dataType()) == false;\n+            }\n+\n+            Expression doSimplify() {\n+                // force float point folding for FlP field\n+                Literal bcl = operation.dataType().isRational()\n+                    ? Literal.of(bcLiteral, ((Number) bcLiteral.value()).doubleValue())\n+                    : bcLiteral;\n+\n+                if (operation instanceof BinaryComparisonInvertible == false) { // should be an assertion?\n+                    throw new QlIllegalArgumentException(\"Unexpected [\" + operation.symbol() + \"] operation object\");\n+                }\n+                Expression bcRightExpression = ((BinaryComparisonInvertible) operation).binaryComparisonInverse()\n+                    .create(bcl.source(), bcl, opRight);\n+                bcRightExpression = safeMaybeFold(bcRightExpression);\n+                return bcRightExpression == null ? comparison : comparison.replaceChildren(List.of(opLeft, bcRightExpression));\n+            }\n+\n+            static Expression simplify(BinaryComparison comparison, BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                ArithmeticOperation operation = (ArithmeticOperation) comparison.left();\n+                // Use symbol comp: SQL operations aren't available in this package (as dependencies)\n+                String opSymbol = operation.symbol();\n+                // Modulo can't be simplified.\n+                if (MOD.symbol().equals(opSymbol)) {\n+                    return comparison;\n+                }\n+                SimplifyOperation simplify = null;\n+                if (isMulOrDiv(opSymbol)) {\n+                    simplify = new SimplifyMulDiv(comparison);\n+                } else if (ADD.symbol().equals(opSymbol) || SUB.symbol().equals(opSymbol)) {\n+                    simplify = new SimplifyAddSub(comparison);\n+                }\n+\n+                return (simplify == null || simplify.cannotSimplify(typesCompatible)) ? comparison : simplify.doSimplify();\n+            }\n+\n+            static boolean isMulOrDiv(String opSymbol) {\n+                return MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol);\n+            }\n+        }\n+\n+        private static class SimplifyAddSub extends SimplifyOperation {\n+\n+            SimplifyAddSub(BinaryComparison comparison) {\n+                super(comparison);\n+            }\n+\n+            @Override\n+            boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+                // no ADD/SUB with floating fields\n+                return operation.dataType().isRational() || super.cannotSimplify(typesCompatible);\n+            }\n+\n+            @Override\n+            Expression doSimplify() {\n+                if (SUB.symbol().equals(operation.symbol()) && opRight instanceof Literal == false) {\n+                    // if next simplification step would fail on overflow anyways, skip the optimisation already\n+                    if (safeMaybeFold(new Sub(EMPTY, opLeft, bcLiteral)) == null) {\n+                        return comparison;\n+                    }\n+                }\n+                return super.doSimplify();\n+            }\n+        }\n+\n+        private static class SimplifyMulDiv extends SimplifyOperation {\n+\n+            private final boolean isDiv; // and not MUL.\n+\n+            SimplifyMulDiv(BinaryComparison comparison) {\n+                super(comparison);\n+                isDiv = DIV.symbol().equals(operation.symbol());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTk5NzEzNQ=="}, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 220}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyNjI2ODU2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/qa/server/src/main/resources/arithmetic.csv-spec", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwODo1MDoyNFrOIWEC8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QxMTozMzo1N1rOIbDWdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDAwNTg3Mw==", "bodyText": "Can you return here hire_date as well, please? As the results are at the moment, I cannot tell if the filter in the WHERE clause is correctly applied or not.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r560005873", "createdAt": "2021-01-19T08:50:24Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/qa/server/src/main/resources/arithmetic.csv-spec", "diffHunk": "@@ -23,7 +23,51 @@ nullArithmetics\n schema::a:i|b:d|c:s|d:s|e:l|f:i|g:i|h:i|i:i|j:i|k:d\n SELECT null + 2 AS a, null * 1.5 AS b, null + null AS c, null - null AS d, null - 1234567890123 AS e, 123 - null AS f, null / 5 AS g, 5 / null AS h, null % 5 AS i, 5 % null AS j, null + 5.5 - (null * (null * 3)) AS k;\n \n-       a       |       b       |       c       |       d       |       e       |       f       |       g       |       h       |       i       |       j       |       k       \n+       a       |       b       |       c       |       d       |       e       |       f       |       g       |       h       |       i       |       j       |       k\n ---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------\n-null           |null           |null           |null           |null           |null           |null           |null           |null           |null           |null           \n+null           |null           |null           |null           |null           |null           |null           |null           |null           |null           |null\n+;\n+\n+optimizedIntervalFilterPlus\n+SELECT emp_no x FROM test_emp WHERE hire_date + INTERVAL 20 YEAR > CAST('2010-01-01T00:00:00' AS TIMESTAMP) LIMIT 10;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTIzNzM2NA==", "bodyText": "Makes sense, added.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r565237364", "createdAt": "2021-01-27T11:33:57Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/sql/qa/server/src/main/resources/arithmetic.csv-spec", "diffHunk": "@@ -23,7 +23,51 @@ nullArithmetics\n schema::a:i|b:d|c:s|d:s|e:l|f:i|g:i|h:i|i:i|j:i|k:d\n SELECT null + 2 AS a, null * 1.5 AS b, null + null AS c, null - null AS d, null - 1234567890123 AS e, 123 - null AS f, null / 5 AS g, 5 / null AS h, null % 5 AS i, 5 % null AS j, null + 5.5 - (null * (null * 3)) AS k;\n \n-       a       |       b       |       c       |       d       |       e       |       f       |       g       |       h       |       i       |       j       |       k       \n+       a       |       b       |       c       |       d       |       e       |       f       |       g       |       h       |       i       |       j       |       k\n ---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------\n-null           |null           |null           |null           |null           |null           |null           |null           |null           |null           |null           \n+null           |null           |null           |null           |null           |null           |null           |null           |null           |null           |null\n+;\n+\n+optimizedIntervalFilterPlus\n+SELECT emp_no x FROM test_emp WHERE hire_date + INTERVAL 20 YEAR > CAST('2010-01-01T00:00:00' AS TIMESTAMP) LIMIT 10;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDAwNTg3Mw=="}, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyNjI2OTk1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/qa/server/src/main/resources/arithmetic.csv-spec", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwODo1MDo0NFrOIWEDwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QxMTozNDowMFrOIbDWlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDAwNjA4Mg==", "bodyText": "Same comment as above, here as well.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r560006082", "createdAt": "2021-01-19T08:50:44Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/qa/server/src/main/resources/arithmetic.csv-spec", "diffHunk": "@@ -23,7 +23,51 @@ nullArithmetics\n schema::a:i|b:d|c:s|d:s|e:l|f:i|g:i|h:i|i:i|j:i|k:d\n SELECT null + 2 AS a, null * 1.5 AS b, null + null AS c, null - null AS d, null - 1234567890123 AS e, 123 - null AS f, null / 5 AS g, 5 / null AS h, null % 5 AS i, 5 % null AS j, null + 5.5 - (null * (null * 3)) AS k;\n \n-       a       |       b       |       c       |       d       |       e       |       f       |       g       |       h       |       i       |       j       |       k       \n+       a       |       b       |       c       |       d       |       e       |       f       |       g       |       h       |       i       |       j       |       k\n ---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------\n-null           |null           |null           |null           |null           |null           |null           |null           |null           |null           |null           \n+null           |null           |null           |null           |null           |null           |null           |null           |null           |null           |null\n+;\n+\n+optimizedIntervalFilterPlus\n+SELECT emp_no x FROM test_emp WHERE hire_date + INTERVAL 20 YEAR > CAST('2010-01-01T00:00:00' AS TIMESTAMP) LIMIT 10;\n+\n+       x:i\n+---------------\n+10008\n+10011\n+10012\n+10016\n+10017\n+10019\n+10020\n+10022\n+10024\n+10026\n+;\n+\n+optimizedIntervalFilterMinus\n+SELECT emp_no x FROM test_emp WHERE hire_date - INTERVAL 10 YEAR > CAST('1980-01-01T00:00:00' AS TIMESTAMP) LIMIT 10;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTIzNzM5Ng==", "bodyText": "Added.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r565237396", "createdAt": "2021-01-27T11:34:00Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/sql/qa/server/src/main/resources/arithmetic.csv-spec", "diffHunk": "@@ -23,7 +23,51 @@ nullArithmetics\n schema::a:i|b:d|c:s|d:s|e:l|f:i|g:i|h:i|i:i|j:i|k:d\n SELECT null + 2 AS a, null * 1.5 AS b, null + null AS c, null - null AS d, null - 1234567890123 AS e, 123 - null AS f, null / 5 AS g, 5 / null AS h, null % 5 AS i, 5 % null AS j, null + 5.5 - (null * (null * 3)) AS k;\n \n-       a       |       b       |       c       |       d       |       e       |       f       |       g       |       h       |       i       |       j       |       k       \n+       a       |       b       |       c       |       d       |       e       |       f       |       g       |       h       |       i       |       j       |       k\n ---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------\n-null           |null           |null           |null           |null           |null           |null           |null           |null           |null           |null           \n+null           |null           |null           |null           |null           |null           |null           |null           |null           |null           |null\n+;\n+\n+optimizedIntervalFilterPlus\n+SELECT emp_no x FROM test_emp WHERE hire_date + INTERVAL 20 YEAR > CAST('2010-01-01T00:00:00' AS TIMESTAMP) LIMIT 10;\n+\n+       x:i\n+---------------\n+10008\n+10011\n+10012\n+10016\n+10017\n+10019\n+10020\n+10022\n+10024\n+10026\n+;\n+\n+optimizedIntervalFilterMinus\n+SELECT emp_no x FROM test_emp WHERE hire_date - INTERVAL 10 YEAR > CAST('1980-01-01T00:00:00' AS TIMESTAMP) LIMIT 10;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDAwNjA4Mg=="}, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyNjI4NTgzOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/predicate/operator/arithmetic/SqlBinaryArithmeticOperation.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwODo1NDowM1rOIWEMzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwODo1NDowM1rOIWEMzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDAwODM5Ng==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r560008396", "createdAt": "2021-01-19T08:54:03Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/predicate/operator/arithmetic/SqlBinaryArithmeticOperation.java", "diffHunk": "@@ -52,7 +52,7 @@\n             return IntervalArithmetics.add((Temporal) r, ((IntervalDayTime) l).interval());\n         }\n \n-        throw new QlIllegalArgumentException(\"Cannot compute [+] between [{}] [{}]\", l.getClass().getSimpleName(),\n+        throw new QlIllegalArgumentException(\"Cannot compute [+] between [{}] and [{}]\", l.getClass().getSimpleName(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9eba1c3ccc1ec277bd584997163ff1e6e60b20a9"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU2NTc0NjEzOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOFQxMzoxNzowNlrOIb3Gsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOFQxOToyOToxMFrOIcHcww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjA4NTI5OQ==", "bodyText": "If this method necessary? I only see it used in one place and the check can check can be directly just life for ADD and SUB.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r566085299", "createdAt": "2021-01-28T13:17:06Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1170,21 +1171,44 @@ private Expression simplify(BinaryComparison bc) {\n             // optimize only once the expression has a literal on the right side of the binary comparison\n             if (bc.right() instanceof Literal) {\n                 if (bc.left() instanceof ArithmeticOperation) {\n-                    return SimplifyOperation.simplify(bc, typesCompatible);\n-                } else if (bc.left() instanceof Neg) {\n-                    return reduceNegation(bc);\n+                    return simplifyBinaryComparison(bc);\n+                }\n+                if (bc.left() instanceof Neg) {\n+                    return foldNegation(bc);\n                 }\n             }\n             return bc;\n         }\n \n-        private static Expression reduceNegation(BinaryComparison bc) {\n+        private Expression simplifyBinaryComparison(BinaryComparison comparison) {\n+            ArithmeticOperation operation = (ArithmeticOperation) comparison.left();\n+            // Use symbol comp: SQL operations aren't available in this package (as dependencies)\n+            String opSymbol = operation.symbol();\n+            // Modulo can't be simplified.\n+            if (opSymbol == MOD.symbol()) {\n+                return comparison;\n+            }\n+            OperationSimplifier simplification = null;\n+            if (isMulOrDiv(opSymbol)) {\n+                simplification = new MulDivSimplifier(comparison);\n+            } else if (opSymbol == ADD.symbol() || opSymbol == SUB.symbol()) {\n+                simplification = new AddSubSimplifier(comparison);\n+            }\n+\n+            return (simplification == null || simplification.isUnsafe(typesCompatible)) ? comparison : simplification.apply();\n+        }\n+\n+        private static boolean isMulOrDiv(String opSymbol) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3b66c85e72e691520e1ef01a02425165a4c04ed"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjM1MzA5MQ==", "bodyText": "It's being used twice. I'm on the fence tbh - it makes things easier to read in sign(), but looks unbalanced in the if-else explicit ADD/SUB check - but would leave it as is now.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r566353091", "createdAt": "2021-01-28T19:29:10Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1170,21 +1171,44 @@ private Expression simplify(BinaryComparison bc) {\n             // optimize only once the expression has a literal on the right side of the binary comparison\n             if (bc.right() instanceof Literal) {\n                 if (bc.left() instanceof ArithmeticOperation) {\n-                    return SimplifyOperation.simplify(bc, typesCompatible);\n-                } else if (bc.left() instanceof Neg) {\n-                    return reduceNegation(bc);\n+                    return simplifyBinaryComparison(bc);\n+                }\n+                if (bc.left() instanceof Neg) {\n+                    return foldNegation(bc);\n                 }\n             }\n             return bc;\n         }\n \n-        private static Expression reduceNegation(BinaryComparison bc) {\n+        private Expression simplifyBinaryComparison(BinaryComparison comparison) {\n+            ArithmeticOperation operation = (ArithmeticOperation) comparison.left();\n+            // Use symbol comp: SQL operations aren't available in this package (as dependencies)\n+            String opSymbol = operation.symbol();\n+            // Modulo can't be simplified.\n+            if (opSymbol == MOD.symbol()) {\n+                return comparison;\n+            }\n+            OperationSimplifier simplification = null;\n+            if (isMulOrDiv(opSymbol)) {\n+                simplification = new MulDivSimplifier(comparison);\n+            } else if (opSymbol == ADD.symbol() || opSymbol == SUB.symbol()) {\n+                simplification = new AddSubSimplifier(comparison);\n+            }\n+\n+            return (simplification == null || simplification.isUnsafe(typesCompatible)) ? comparison : simplification.apply();\n+        }\n+\n+        private static boolean isMulOrDiv(String opSymbol) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjA4NTI5OQ=="}, "originalCommit": {"oid": "a3b66c85e72e691520e1ef01a02425165a4c04ed"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU2NTc1NzAxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOFQxMzoxOTo0NlrOIb3NQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOFQxOToyOTowN1rOIcHcoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjA4Njk3OQ==", "bodyText": "postApply or postProcess. opSpecific is somewhat meaningless.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r566086979", "createdAt": "2021-01-28T13:19:46Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1237,109 +1261,97 @@ boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible)\n                 }\n \n                 // the Literal will be moved to the right of the comparison, but only if data-compatible with what's there\n-                return typesCompatible.apply(bcLiteral.dataType(), opLiteral.dataType()) == false;\n+                if (typesCompatible.apply(bcLiteral.dataType(), opLiteral.dataType()) == false) {\n+                    return true;\n+                }\n+\n+                return opSpecificIsUnsafe();\n             }\n \n-            Expression doSimplify() {\n+            Expression apply() {\n                 // force float point folding for FlP field\n                 Literal bcl = operation.dataType().isRational()\n                     ? Literal.of(bcLiteral, ((Number) bcLiteral.value()).doubleValue())\n                     : bcLiteral;\n \n-                if (operation instanceof BinaryComparisonInvertible == false) { // should be an assertion?\n-                    throw new QlIllegalArgumentException(\"Unexpected [\" + operation.symbol() + \"] operation object\");\n-                }\n-                Expression bcRightExpression = ((BinaryComparisonInvertible) operation).binaryComparisonInverse()\n+                Expression bcRightExpression = ((BinaryComparisonInversible) operation).binaryComparisonInverse()\n                     .create(bcl.source(), bcl, opRight);\n-                bcRightExpression = safeMaybeFold(bcRightExpression);\n-                return bcRightExpression == null ? comparison : comparison.replaceChildren(List.of(opLeft, bcRightExpression));\n+                bcRightExpression = tryFolding(bcRightExpression);\n+                return bcRightExpression != null\n+                    ? opSpecificPostApply((BinaryComparison) comparison.replaceChildren(List.of(opLeft, bcRightExpression)))\n+                    : comparison;\n             }\n \n-            static Expression simplify(BinaryComparison comparison, BiFunction<DataType, DataType, Boolean> typesCompatible) {\n-                ArithmeticOperation operation = (ArithmeticOperation) comparison.left();\n-                // Use symbol comp: SQL operations aren't available in this package (as dependencies)\n-                String opSymbol = operation.symbol();\n-                // Modulo can't be simplified.\n-                if (MOD.symbol().equals(opSymbol)) {\n-                    return comparison;\n-                }\n-                SimplifyOperation simplify = null;\n-                if (isMulOrDiv(opSymbol)) {\n-                    simplify = new SimplifyMulDiv(comparison);\n-                } else if (ADD.symbol().equals(opSymbol) || SUB.symbol().equals(opSymbol)) {\n-                    simplify = new SimplifyAddSub(comparison);\n-                }\n-\n-                return (simplify == null || simplify.cannotSimplify(typesCompatible)) ? comparison : simplify.doSimplify();\n-            }\n+            // operation-specific operations:\n+            //  - fast-tracking of simplification unsafety\n+            abstract boolean opSpecificIsUnsafe();\n \n-            static boolean isMulOrDiv(String opSymbol) {\n-                return MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol);\n+            //  - post adjustments\n+            Expression opSpecificPostApply(BinaryComparison binaryComparison) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3b66c85e72e691520e1ef01a02425165a4c04ed"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjM1MzA1Nw==", "bodyText": "I went for postProcess.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r566353057", "createdAt": "2021-01-28T19:29:07Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1237,109 +1261,97 @@ boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible)\n                 }\n \n                 // the Literal will be moved to the right of the comparison, but only if data-compatible with what's there\n-                return typesCompatible.apply(bcLiteral.dataType(), opLiteral.dataType()) == false;\n+                if (typesCompatible.apply(bcLiteral.dataType(), opLiteral.dataType()) == false) {\n+                    return true;\n+                }\n+\n+                return opSpecificIsUnsafe();\n             }\n \n-            Expression doSimplify() {\n+            Expression apply() {\n                 // force float point folding for FlP field\n                 Literal bcl = operation.dataType().isRational()\n                     ? Literal.of(bcLiteral, ((Number) bcLiteral.value()).doubleValue())\n                     : bcLiteral;\n \n-                if (operation instanceof BinaryComparisonInvertible == false) { // should be an assertion?\n-                    throw new QlIllegalArgumentException(\"Unexpected [\" + operation.symbol() + \"] operation object\");\n-                }\n-                Expression bcRightExpression = ((BinaryComparisonInvertible) operation).binaryComparisonInverse()\n+                Expression bcRightExpression = ((BinaryComparisonInversible) operation).binaryComparisonInverse()\n                     .create(bcl.source(), bcl, opRight);\n-                bcRightExpression = safeMaybeFold(bcRightExpression);\n-                return bcRightExpression == null ? comparison : comparison.replaceChildren(List.of(opLeft, bcRightExpression));\n+                bcRightExpression = tryFolding(bcRightExpression);\n+                return bcRightExpression != null\n+                    ? opSpecificPostApply((BinaryComparison) comparison.replaceChildren(List.of(opLeft, bcRightExpression)))\n+                    : comparison;\n             }\n \n-            static Expression simplify(BinaryComparison comparison, BiFunction<DataType, DataType, Boolean> typesCompatible) {\n-                ArithmeticOperation operation = (ArithmeticOperation) comparison.left();\n-                // Use symbol comp: SQL operations aren't available in this package (as dependencies)\n-                String opSymbol = operation.symbol();\n-                // Modulo can't be simplified.\n-                if (MOD.symbol().equals(opSymbol)) {\n-                    return comparison;\n-                }\n-                SimplifyOperation simplify = null;\n-                if (isMulOrDiv(opSymbol)) {\n-                    simplify = new SimplifyMulDiv(comparison);\n-                } else if (ADD.symbol().equals(opSymbol) || SUB.symbol().equals(opSymbol)) {\n-                    simplify = new SimplifyAddSub(comparison);\n-                }\n-\n-                return (simplify == null || simplify.cannotSimplify(typesCompatible)) ? comparison : simplify.doSimplify();\n-            }\n+            // operation-specific operations:\n+            //  - fast-tracking of simplification unsafety\n+            abstract boolean opSpecificIsUnsafe();\n \n-            static boolean isMulOrDiv(String opSymbol) {\n-                return MUL.symbol().equals(opSymbol) || DIV.symbol().equals(opSymbol);\n+            //  - post adjustments\n+            Expression opSpecificPostApply(BinaryComparison binaryComparison) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjA4Njk3OQ=="}, "originalCommit": {"oid": "a3b66c85e72e691520e1ef01a02425165a4c04ed"}, "originalPosition": 171}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU2NTc2MDk3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOFQxMzoyMDo0M1rOIb3Pog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOFQxOToyOTowMFrOIcHcXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjA4NzU4Ng==", "bodyText": "If you don't this to be subclass because of the dedicated method, consider making it final.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r566087586", "createdAt": "2021-01-28T13:20:43Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1221,7 +1245,7 @@ static Expression safeMaybeFold(Expression expression) {\n             }\n \n             // can it be quickly fast-tracked that the operation can't be reduced?\n-            boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            boolean isUnsafe(BiFunction<DataType, DataType, Boolean> typesCompatible) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3b66c85e72e691520e1ef01a02425165a4c04ed"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjM1Mjk4OA==", "bodyText": "Right, thanks, applied! Applicable to both class' main methods.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r566352988", "createdAt": "2021-01-28T19:29:00Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1221,7 +1245,7 @@ static Expression safeMaybeFold(Expression expression) {\n             }\n \n             // can it be quickly fast-tracked that the operation can't be reduced?\n-            boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible) {\n+            boolean isUnsafe(BiFunction<DataType, DataType, Boolean> typesCompatible) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjA4NzU4Ng=="}, "originalCommit": {"oid": "a3b66c85e72e691520e1ef01a02425165a4c04ed"}, "originalPosition": 110}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU2NTc2NjQ0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOFQxMzoyMjowOVrOIb3S-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOFQxOToyOTowMlrOIcHcfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjA4ODQ0MA==", "bodyText": "how about check, doCheck without opSpecific?", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r566088440", "createdAt": "2021-01-28T13:22:09Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1237,109 +1261,97 @@ boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible)\n                 }\n \n                 // the Literal will be moved to the right of the comparison, but only if data-compatible with what's there\n-                return typesCompatible.apply(bcLiteral.dataType(), opLiteral.dataType()) == false;\n+                if (typesCompatible.apply(bcLiteral.dataType(), opLiteral.dataType()) == false) {\n+                    return true;\n+                }\n+\n+                return opSpecificIsUnsafe();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3b66c85e72e691520e1ef01a02425165a4c04ed"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjM1MzAyMg==", "bodyText": "Updated.", "url": "https://github.com/elastic/elasticsearch/pull/66022#discussion_r566353022", "createdAt": "2021-01-28T19:29:02Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/optimizer/OptimizerRules.java", "diffHunk": "@@ -1237,109 +1261,97 @@ boolean cannotSimplify(BiFunction<DataType, DataType, Boolean> typesCompatible)\n                 }\n \n                 // the Literal will be moved to the right of the comparison, but only if data-compatible with what's there\n-                return typesCompatible.apply(bcLiteral.dataType(), opLiteral.dataType()) == false;\n+                if (typesCompatible.apply(bcLiteral.dataType(), opLiteral.dataType()) == false) {\n+                    return true;\n+                }\n+\n+                return opSpecificIsUnsafe();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjA4ODQ0MA=="}, "originalCommit": {"oid": "a3b66c85e72e691520e1ef01a02425165a4c04ed"}, "originalPosition": 123}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4762, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}