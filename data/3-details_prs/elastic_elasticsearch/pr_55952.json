{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEwNzk0ODk4", "number": 55952, "title": "Searchable Snapshots should respect max_restore_bytes_per_sec", "bodyText": "This pull request changes searchable snapshots so that it now respects the repository's max_restore_bytes_per_sec setting when it downloads blobs.", "createdAt": "2020-04-29T15:43:15Z", "url": "https://github.com/elastic/elasticsearch/pull/55952", "merged": true, "mergeCommit": {"oid": "c00c54802f4ddad91ea3a3f0e67daa7fd70c6acb"}, "closed": true, "closedAt": "2020-05-05T12:40:39Z", "author": {"login": "tlrx"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABccaVjTAH2gAyNDEwNzk0ODk4OjA2ZWM5NDI0YjY1OWFjZmMxODVjYzU4ZjJiYTM4ODMzMTA2MWQ3NjI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABceSpIvAH2gAyNDEwNzk0ODk4OjBlOWEyOGRiYjliMDcxNjEyMDgyMDVlYjc2YmRiZjg0NDI4Nzg1MjU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "06ec9424b659acfc185cc58f2ba388331061d762", "author": {"user": {"login": "tlrx", "name": "Tanguy Leroux"}}, "url": "https://github.com/elastic/elasticsearch/commit/06ec9424b659acfc185cc58f2ba388331061d762", "committedDate": "2020-04-29T15:37:02Z", "message": "Searchable Snapshots should respect repository's max_restore_bytes_per_sec"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1NjA3MjA1", "url": "https://github.com/elastic/elasticsearch/pull/55952#pullrequestreview-405607205", "createdAt": "2020-05-05T08:59:44Z", "commit": {"oid": "06ec9424b659acfc185cc58f2ba388331061d762"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwODo1OTo0NFrOGQgbIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwOTowNTozMlrOGQgnfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk2MTYzMg==", "bodyText": "I was slightly concerned that this may not be robust if CI is having a particularly slow day, but I see that we make similar assertions in other places without issues.", "url": "https://github.com/elastic/elasticsearch/pull/55952#discussion_r419961632", "createdAt": "2020-05-05T08:59:44Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/xpack/searchablesnapshots/SearchableSnapshotsIntegTests.java", "diffHunk": "@@ -292,6 +299,82 @@ public void testCanMountSnapshotTakenWhileConcurrentlyIndexing() throws Exceptio\n         ensureGreen(restoredIndexName);\n     }\n \n+    public void testMaxRestoreBytesPerSecIsUsed() throws Exception {\n+        final String repositoryName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        final Settings.Builder repositorySettings = Settings.builder().put(\"location\", randomRepoPath());\n+        final boolean useRateLimits = randomBoolean();\n+        if (useRateLimits) {\n+            repositorySettings.put(\"max_restore_bytes_per_sec\", new ByteSizeValue(10, ByteSizeUnit.KB));\n+        } else {\n+            repositorySettings.put(\"max_restore_bytes_per_sec\", ByteSizeValue.ZERO);\n+        }\n+        assertAcked(\n+            client().admin().cluster().preparePutRepository(repositoryName).setType(FsRepository.TYPE).setSettings(repositorySettings)\n+        );\n+\n+        final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        assertAcked(\n+            prepareCreate(\n+                indexName,\n+                Settings.builder()\n+                    .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, between(1, 3))\n+                    .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)\n+                    .put(INDEX_SOFT_DELETES_SETTING.getKey(), true)\n+            )\n+        );\n+        final int nbDocs = between(10, 50);\n+        indexRandom(\n+            true,\n+            false,\n+            IntStream.range(0, nbDocs)\n+                .mapToObj(i -> client().prepareIndex(indexName).setSource(\"foo\", randomBoolean() ? \"bar\" : \"baz\"))\n+                .collect(Collectors.toList())\n+        );\n+        refresh(indexName);\n+\n+        final String restoredIndexName = randomBoolean() ? indexName : randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        final String snapshotName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        CreateSnapshotResponse createSnapshotResponse = client().admin()\n+            .cluster()\n+            .prepareCreateSnapshot(repositoryName, snapshotName)\n+            .setWaitForCompletion(true)\n+            .get();\n+        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo();\n+        assertThat(snapshotInfo.successfulShards(), greaterThan(0));\n+        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()));\n+\n+        assertAcked(client().admin().indices().prepareDelete(indexName));\n+\n+        logger.info(\"--> restoring index [{}] using rate limits [{}]\", restoredIndexName, useRateLimits);\n+        final MountSearchableSnapshotRequest mount = new MountSearchableSnapshotRequest(\n+            restoredIndexName,\n+            repositoryName,\n+            snapshotName,\n+            indexName,\n+            Settings.builder().put(IndexSettings.INDEX_CHECK_ON_STARTUP.getKey(), Boolean.FALSE.toString()).build(),\n+            Strings.EMPTY_ARRAY,\n+            true\n+        );\n+\n+        final RestoreSnapshotResponse restore = client().execute(MountSearchableSnapshotAction.INSTANCE, mount).get();\n+        assertThat(restore.getRestoreInfo().failedShards(), equalTo(0));\n+        ensureGreen(restoredIndexName);\n+\n+        assertHitCount(client().prepareSearch(restoredIndexName).setSize(0).get(), nbDocs);\n+\n+        final Index restoredIndex = resolveIndex(restoredIndexName);\n+        for (String node : internalCluster().getNodeNames()) {\n+            final IndicesService service = internalCluster().getInstance(IndicesService.class, node);\n+            if (service != null && service.hasIndex(restoredIndex)) {\n+                final RepositoriesService repositoriesService = internalCluster().getInstance(RepositoriesService.class, node);\n+                assertThat(\n+                    repositoriesService.repository(repositoryName).getRestoreThrottleTimeInNanos(),\n+                    useRateLimits ? greaterThan(0L) : equalTo(0L)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06ec9424b659acfc185cc58f2ba388331061d762"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk2Mjc1Ng==", "bodyText": "It's a bit strange to require callers to make sure to apply this rate limiting, rather than having the repository create a blob container that already includes this. But I don't see an easy way to push this down to the blob container level either, so I'm not asking for any changes here.", "url": "https://github.com/elastic/elasticsearch/pull/55952#discussion_r419962756", "createdAt": "2020-05-05T09:01:43Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/SearchableSnapshotDirectory.java", "diffHunk": "@@ -444,7 +446,17 @@ public static Directory create(\n         );\n \n         final LazyInitializable<BlobContainer, RuntimeException> lazyBlobContainer = new LazyInitializable<>(\n-            () -> blobStoreRepository.shardContainer(indexId, shardPath.getShardId().id())\n+            () -> new FilterBlobContainer(blobStoreRepository.shardContainer(indexId, shardPath.getShardId().id())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06ec9424b659acfc185cc58f2ba388331061d762"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk2NDc5Ng==", "bodyText": "Does this mean that child blob containers will not be rate-limited? I think we need that too?", "url": "https://github.com/elastic/elasticsearch/pull/55952#discussion_r419964796", "createdAt": "2020-05-05T09:05:32Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/common/blobstore/support/FilterBlobContainer.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.blobstore.support;\n+\n+import org.elasticsearch.common.blobstore.BlobContainer;\n+import org.elasticsearch.common.blobstore.BlobMetadata;\n+import org.elasticsearch.common.blobstore.BlobPath;\n+import org.elasticsearch.common.blobstore.DeleteResult;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+public class FilterBlobContainer implements BlobContainer {\n+\n+    private final BlobContainer delegate;\n+\n+    public FilterBlobContainer(BlobContainer delegate) {\n+        this.delegate = Objects.requireNonNull(delegate);\n+    }\n+\n+    @Override\n+    public BlobPath path() {\n+        return delegate.path();\n+    }\n+\n+    @Override\n+    public InputStream readBlob(String blobName) throws IOException {\n+        return delegate.readBlob(blobName);\n+    }\n+\n+    @Override\n+    public InputStream readBlob(String blobName, long position, long length) throws IOException {\n+        return delegate.readBlob(blobName, position, length);\n+    }\n+\n+    @Override\n+    public long readBlobPreferredLength() {\n+        return delegate.readBlobPreferredLength();\n+    }\n+\n+    @Override\n+    public void writeBlob(String blobName, InputStream inputStream, long blobSize, boolean failIfAlreadyExists) throws IOException {\n+        delegate.writeBlob(blobName, inputStream, blobSize, failIfAlreadyExists);\n+    }\n+\n+    @Override\n+    public void writeBlobAtomic(String blobName, InputStream inputStream, long blobSize, boolean failIfAlreadyExists) throws IOException {\n+        delegate.writeBlobAtomic(blobName, inputStream, blobSize, failIfAlreadyExists);\n+    }\n+\n+    @Override\n+    public DeleteResult delete() throws IOException {\n+        return delegate.delete();\n+    }\n+\n+    @Override\n+    public void deleteBlobsIgnoringIfNotExists(List<String> blobNames) throws IOException {\n+        delegate.deleteBlobsIgnoringIfNotExists(blobNames);\n+    }\n+\n+    @Override\n+    public Map<String, BlobMetadata> listBlobs() throws IOException {\n+        return delegate.listBlobs();\n+    }\n+\n+    @Override\n+    public Map<String, BlobContainer> children() throws IOException {\n+        return delegate.children();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06ec9424b659acfc185cc58f2ba388331061d762"}, "originalPosition": 88}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "004848579944d1b615719e985e45db48f9687970", "author": {"user": {"login": "tlrx", "name": "Tanguy Leroux"}}, "url": "https://github.com/elastic/elasticsearch/commit/004848579944d1b615719e985e45db48f9687970", "committedDate": "2020-05-05T10:34:41Z", "message": "also wrap children"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1Njc1NDUy", "url": "https://github.com/elastic/elasticsearch/pull/55952#pullrequestreview-405675452", "createdAt": "2020-05-05T10:46:00Z", "commit": {"oid": "004848579944d1b615719e985e45db48f9687970"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxMDo0NjowMFrOGQj5TQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxMDo1MTo1N1rOGQkFMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAxODUwOQ==", "bodyText": "I meant the other case - if rate limiting is requested but CI runs so slowly that it's never throttled \ud83d\ude04 But yes, looks to be fine in practice.", "url": "https://github.com/elastic/elasticsearch/pull/55952#discussion_r420018509", "createdAt": "2020-05-05T10:46:00Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/xpack/searchablesnapshots/SearchableSnapshotsIntegTests.java", "diffHunk": "@@ -292,6 +299,82 @@ public void testCanMountSnapshotTakenWhileConcurrentlyIndexing() throws Exceptio\n         ensureGreen(restoredIndexName);\n     }\n \n+    public void testMaxRestoreBytesPerSecIsUsed() throws Exception {\n+        final String repositoryName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        final Settings.Builder repositorySettings = Settings.builder().put(\"location\", randomRepoPath());\n+        final boolean useRateLimits = randomBoolean();\n+        if (useRateLimits) {\n+            repositorySettings.put(\"max_restore_bytes_per_sec\", new ByteSizeValue(10, ByteSizeUnit.KB));\n+        } else {\n+            repositorySettings.put(\"max_restore_bytes_per_sec\", ByteSizeValue.ZERO);\n+        }\n+        assertAcked(\n+            client().admin().cluster().preparePutRepository(repositoryName).setType(FsRepository.TYPE).setSettings(repositorySettings)\n+        );\n+\n+        final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        assertAcked(\n+            prepareCreate(\n+                indexName,\n+                Settings.builder()\n+                    .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, between(1, 3))\n+                    .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)\n+                    .put(INDEX_SOFT_DELETES_SETTING.getKey(), true)\n+            )\n+        );\n+        final int nbDocs = between(10, 50);\n+        indexRandom(\n+            true,\n+            false,\n+            IntStream.range(0, nbDocs)\n+                .mapToObj(i -> client().prepareIndex(indexName).setSource(\"foo\", randomBoolean() ? \"bar\" : \"baz\"))\n+                .collect(Collectors.toList())\n+        );\n+        refresh(indexName);\n+\n+        final String restoredIndexName = randomBoolean() ? indexName : randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        final String snapshotName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        CreateSnapshotResponse createSnapshotResponse = client().admin()\n+            .cluster()\n+            .prepareCreateSnapshot(repositoryName, snapshotName)\n+            .setWaitForCompletion(true)\n+            .get();\n+        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo();\n+        assertThat(snapshotInfo.successfulShards(), greaterThan(0));\n+        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()));\n+\n+        assertAcked(client().admin().indices().prepareDelete(indexName));\n+\n+        logger.info(\"--> restoring index [{}] using rate limits [{}]\", restoredIndexName, useRateLimits);\n+        final MountSearchableSnapshotRequest mount = new MountSearchableSnapshotRequest(\n+            restoredIndexName,\n+            repositoryName,\n+            snapshotName,\n+            indexName,\n+            Settings.builder().put(IndexSettings.INDEX_CHECK_ON_STARTUP.getKey(), Boolean.FALSE.toString()).build(),\n+            Strings.EMPTY_ARRAY,\n+            true\n+        );\n+\n+        final RestoreSnapshotResponse restore = client().execute(MountSearchableSnapshotAction.INSTANCE, mount).get();\n+        assertThat(restore.getRestoreInfo().failedShards(), equalTo(0));\n+        ensureGreen(restoredIndexName);\n+\n+        assertHitCount(client().prepareSearch(restoredIndexName).setSize(0).get(), nbDocs);\n+\n+        final Index restoredIndex = resolveIndex(restoredIndexName);\n+        for (String node : internalCluster().getNodeNames()) {\n+            final IndicesService service = internalCluster().getInstance(IndicesService.class, node);\n+            if (service != null && service.hasIndex(restoredIndex)) {\n+                final RepositoriesService repositoriesService = internalCluster().getInstance(RepositoriesService.class, node);\n+                assertThat(\n+                    repositoriesService.repository(repositoryName).getRestoreThrottleTimeInNanos(),\n+                    useRateLimits ? greaterThan(0L) : equalTo(0L)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk2MTYzMg=="}, "originalCommit": {"oid": "06ec9424b659acfc185cc58f2ba388331061d762"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAxOTIyMg==", "bodyText": "Suggest alternative name and renaming the parameter too:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                protected abstract BlobContainer delegateChildren(BlobContainer children);\n          \n          \n            \n                protected abstract BlobContainer wrapChild(BlobContainer child);", "url": "https://github.com/elastic/elasticsearch/pull/55952#discussion_r420019222", "createdAt": "2020-05-05T10:47:20Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/common/blobstore/support/FilterBlobContainer.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.blobstore.support;\n+\n+import org.elasticsearch.common.blobstore.BlobContainer;\n+import org.elasticsearch.common.blobstore.BlobMetadata;\n+import org.elasticsearch.common.blobstore.BlobPath;\n+import org.elasticsearch.common.blobstore.DeleteResult;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+public abstract class FilterBlobContainer implements BlobContainer {\n+\n+    private final BlobContainer delegate;\n+\n+    public FilterBlobContainer(BlobContainer delegate) {\n+        this.delegate = Objects.requireNonNull(delegate);\n+    }\n+\n+    protected abstract BlobContainer delegateChildren(BlobContainer children);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "004848579944d1b615719e985e45db48f9687970"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAyMTU1Mw==", "bodyText": "Oh yes you're absolutely right, TIL.", "url": "https://github.com/elastic/elasticsearch/pull/55952#discussion_r420021553", "createdAt": "2020-05-05T10:51:57Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/common/blobstore/support/FilterBlobContainer.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.blobstore.support;\n+\n+import org.elasticsearch.common.blobstore.BlobContainer;\n+import org.elasticsearch.common.blobstore.BlobMetadata;\n+import org.elasticsearch.common.blobstore.BlobPath;\n+import org.elasticsearch.common.blobstore.DeleteResult;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+public class FilterBlobContainer implements BlobContainer {\n+\n+    private final BlobContainer delegate;\n+\n+    public FilterBlobContainer(BlobContainer delegate) {\n+        this.delegate = Objects.requireNonNull(delegate);\n+    }\n+\n+    @Override\n+    public BlobPath path() {\n+        return delegate.path();\n+    }\n+\n+    @Override\n+    public InputStream readBlob(String blobName) throws IOException {\n+        return delegate.readBlob(blobName);\n+    }\n+\n+    @Override\n+    public InputStream readBlob(String blobName, long position, long length) throws IOException {\n+        return delegate.readBlob(blobName, position, length);\n+    }\n+\n+    @Override\n+    public long readBlobPreferredLength() {\n+        return delegate.readBlobPreferredLength();\n+    }\n+\n+    @Override\n+    public void writeBlob(String blobName, InputStream inputStream, long blobSize, boolean failIfAlreadyExists) throws IOException {\n+        delegate.writeBlob(blobName, inputStream, blobSize, failIfAlreadyExists);\n+    }\n+\n+    @Override\n+    public void writeBlobAtomic(String blobName, InputStream inputStream, long blobSize, boolean failIfAlreadyExists) throws IOException {\n+        delegate.writeBlobAtomic(blobName, inputStream, blobSize, failIfAlreadyExists);\n+    }\n+\n+    @Override\n+    public DeleteResult delete() throws IOException {\n+        return delegate.delete();\n+    }\n+\n+    @Override\n+    public void deleteBlobsIgnoringIfNotExists(List<String> blobNames) throws IOException {\n+        delegate.deleteBlobsIgnoringIfNotExists(blobNames);\n+    }\n+\n+    @Override\n+    public Map<String, BlobMetadata> listBlobs() throws IOException {\n+        return delegate.listBlobs();\n+    }\n+\n+    @Override\n+    public Map<String, BlobContainer> children() throws IOException {\n+        return delegate.children();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk2NDc5Ng=="}, "originalCommit": {"oid": "06ec9424b659acfc185cc58f2ba388331061d762"}, "originalPosition": 88}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1Njc5NDU2", "url": "https://github.com/elastic/elasticsearch/pull/55952#pullrequestreview-405679456", "createdAt": "2020-05-05T10:52:54Z", "commit": {"oid": "004848579944d1b615719e985e45db48f9687970"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "84904de5e6e81fee196180fd67e12270f884e36c", "author": {"user": {"login": "tlrx", "name": "Tanguy Leroux"}}, "url": "https://github.com/elastic/elasticsearch/commit/84904de5e6e81fee196180fd67e12270f884e36c", "committedDate": "2020-05-05T11:22:53Z", "message": "rename"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4ba36eba8fddf699ea9b66054789be9d65488971", "author": {"user": {"login": "tlrx", "name": "Tanguy Leroux"}}, "url": "https://github.com/elastic/elasticsearch/commit/4ba36eba8fddf699ea9b66054789be9d65488971", "committedDate": "2020-05-05T11:24:55Z", "message": "Merge branch 'master' into respect-max-restore-bytes-per-sec"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0e9a28dbb9b07161208205eb76bdbf8442878525", "author": {"user": {"login": "tlrx", "name": "Tanguy Leroux"}}, "url": "https://github.com/elastic/elasticsearch/commit/0e9a28dbb9b07161208205eb76bdbf8442878525", "committedDate": "2020-05-05T11:47:02Z", "message": "fix checkstyle"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 303, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}