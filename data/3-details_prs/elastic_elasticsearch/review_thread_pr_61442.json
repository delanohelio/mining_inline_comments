{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcyMDI0NDk0", "number": 61442, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QwNzozOTo0NVrOEbSqRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQyMDo0Mjo0M1rOEcvaeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MDUyNzQwOnYy", "diffSide": "RIGHT", "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/support/AbstractXContentParser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QwNzozOTo0NVrOHFLAxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QwNzozOTo0NVrOHFLAxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTE4NTM1MA==", "bodyText": "Duplicating this loop here since there's not efficient way of not having either a capturing lambda (and even a non-capturing one might not inline so great) or a strange API here.", "url": "https://github.com/elastic/elasticsearch/pull/61442#discussion_r475185350", "createdAt": "2020-08-23T07:39:45Z", "author": {"login": "original-brownbear"}, "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/support/AbstractXContentParser.java", "diffHunk": "@@ -263,117 +263,141 @@ public CharBuffer charBufferOrNull() throws IOException {\n \n     @Override\n     public Map<String, Object> map() throws IOException {\n-        return readMap(this);\n+        return readMapSafe(this, SIMPLE_MAP_FACTORY);\n     }\n \n     @Override\n     public Map<String, Object> mapOrdered() throws IOException {\n-        return readOrderedMap(this);\n+        return readMapSafe(this, ORDERED_MAP_FACTORY);\n     }\n \n     @Override\n     public Map<String, String> mapStrings() throws IOException {\n-        return readMapStrings(this);\n+        return map(HashMap::new, XContentParser::text);\n     }\n \n     @Override\n     public <T> Map<String, T> map(\n             Supplier<Map<String, T>> mapFactory, CheckedFunction<XContentParser, T, IOException> mapValueParser) throws IOException {\n-        return readGenericMap(this, mapFactory, mapValueParser);\n+        final Map<String, T> map = mapFactory.get();\n+        if (findNonEmptyMapStart(this) == false) {\n+            return map;\n+        }\n+        assert currentToken() == Token.FIELD_NAME : \"Expected field name but saw [\" + currentToken() + \"]\";\n+        do {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3d50cd642c724afda9a4f4d4de6e37f2af2cc02"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4NTcyNDA4OnYy", "diffSide": "RIGHT", "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/support/AbstractXContentParser.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQyMDo0Mjo0M1rOHHdAAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwNzoyMDo1OVrOHIDk6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU3NzIxNw==", "bodyText": "If I am not mistaken, this will return true when the parser is already at a field name and I'm not sure that's what we want?\nMaybe the last few lines of this method should be:\n        if (token == XContentParser.Token.START_OBJECT) {\n            return parser.nextToken() == Token.FIELD_NAME;\n        } else {\n            return false;\n        }", "url": "https://github.com/elastic/elasticsearch/pull/61442#discussion_r477577217", "createdAt": "2020-08-26T20:42:43Z", "author": {"login": "jaymode"}, "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/support/AbstractXContentParser.java", "diffHunk": "@@ -263,117 +263,141 @@ public CharBuffer charBufferOrNull() throws IOException {\n \n     @Override\n     public Map<String, Object> map() throws IOException {\n-        return readMap(this);\n+        return readMapSafe(this, SIMPLE_MAP_FACTORY);\n     }\n \n     @Override\n     public Map<String, Object> mapOrdered() throws IOException {\n-        return readOrderedMap(this);\n+        return readMapSafe(this, ORDERED_MAP_FACTORY);\n     }\n \n     @Override\n     public Map<String, String> mapStrings() throws IOException {\n-        return readMapStrings(this);\n+        return map(HashMap::new, XContentParser::text);\n     }\n \n     @Override\n     public <T> Map<String, T> map(\n             Supplier<Map<String, T>> mapFactory, CheckedFunction<XContentParser, T, IOException> mapValueParser) throws IOException {\n-        return readGenericMap(this, mapFactory, mapValueParser);\n+        final Map<String, T> map = mapFactory.get();\n+        if (findNonEmptyMapStart(this) == false) {\n+            return map;\n+        }\n+        assert currentToken() == Token.FIELD_NAME : \"Expected field name but saw [\" + currentToken() + \"]\";\n+        do {\n+            // Must point to field name\n+            String fieldName = currentName();\n+            // And then the value...\n+            nextToken();\n+            T value = mapValueParser.apply(this);\n+            map.put(fieldName, value);\n+        } while (nextToken() == XContentParser.Token.FIELD_NAME);\n+        return map;\n     }\n \n     @Override\n     public List<Object> list() throws IOException {\n-        return readList(this);\n+        skipToListStart(this);\n+        return readListUnsafe(this, SIMPLE_MAP_FACTORY);\n     }\n \n     @Override\n     public List<Object> listOrderedMap() throws IOException {\n-        return readListOrderedMap(this);\n-    }\n-\n-    static final Supplier<Map<String, Object>> SIMPLE_MAP_FACTORY = HashMap::new;\n-\n-    static final Supplier<Map<String, Object>> ORDERED_MAP_FACTORY = LinkedHashMap::new;\n-\n-    static final Supplier<Map<String, String>> SIMPLE_MAP_STRINGS_FACTORY = HashMap::new;\n-\n-    static Map<String, Object> readMap(XContentParser parser) throws IOException {\n-        return readMap(parser, SIMPLE_MAP_FACTORY);\n+        skipToListStart(this);\n+        return readListUnsafe(this, ORDERED_MAP_FACTORY);\n     }\n \n-    static Map<String, Object> readOrderedMap(XContentParser parser) throws IOException {\n-        return readMap(parser, ORDERED_MAP_FACTORY);\n-    }\n+    private static final Supplier<Map<String, Object>> SIMPLE_MAP_FACTORY = HashMap::new;\n \n-    static Map<String, String> readMapStrings(XContentParser parser) throws IOException {\n-        return readGenericMap(parser, SIMPLE_MAP_STRINGS_FACTORY, XContentParser::text);\n-    }\n-\n-    static List<Object> readList(XContentParser parser) throws IOException {\n-        return readList(parser, SIMPLE_MAP_FACTORY);\n-    }\n+    private static final Supplier<Map<String, Object>> ORDERED_MAP_FACTORY = LinkedHashMap::new;\n \n-    static List<Object> readListOrderedMap(XContentParser parser) throws IOException {\n-        return readList(parser, ORDERED_MAP_FACTORY);\n+    private static Map<String, Object> readMapSafe(XContentParser parser, Supplier<Map<String, Object>> mapFactory) throws IOException {\n+        final Map<String, Object> map = mapFactory.get();\n+        return findNonEmptyMapStart(parser) ? readMapEntries(parser, mapFactory, map) : map;\n     }\n \n-    static Map<String, Object> readMap(XContentParser parser, Supplier<Map<String, Object>> mapFactory) throws IOException {\n-        return readGenericMap(parser, mapFactory, p -> readValue(p, mapFactory));\n+    // Read a map without bounds checks from a parser that is assumed to be at the map's first field's name token\n+    private static Map<String, Object> readMapEntries(XContentParser parser, Supplier<Map<String, Object>> mapFactory,\n+                                                      Map<String, Object> map) throws IOException {\n+        assert parser.currentToken() == Token.FIELD_NAME : \"Expected field name but saw [\" + parser.currentToken() + \"]\";\n+        do {\n+            // Must point to field name\n+            String fieldName = parser.currentName();\n+            // And then the value...\n+            Object value = readValueUnsafe(parser.nextToken(), parser, mapFactory);\n+            map.put(fieldName, value);\n+        } while (parser.nextToken() == Token.FIELD_NAME);\n+        return map;\n     }\n \n-    static <T> Map<String, T> readGenericMap(\n-            XContentParser parser,\n-            Supplier<Map<String, T>> mapFactory,\n-            CheckedFunction<XContentParser, T, IOException> mapValueParser) throws IOException {\n-        Map<String, T> map = mapFactory.get();\n-        XContentParser.Token token = parser.currentToken();\n+    /**\n+     * Checks if the next current token in the supplied parser is a map start for a non-empty map.\n+     * Skips to the next token if the parser does not yet have a current token (i.e. {@link #currentToken()} returns {@code null}) and then\n+     * checks it.\n+     *\n+     * @return true if a map start for a non-empty map is found\n+     */\n+    private static boolean findNonEmptyMapStart(XContentParser parser) throws IOException {\n+        Token token = parser.currentToken();\n         if (token == null) {\n             token = parser.nextToken();\n         }\n         if (token == XContentParser.Token.START_OBJECT) {\n             token = parser.nextToken();\n         }\n-        for (; token == XContentParser.Token.FIELD_NAME; token = parser.nextToken()) {\n-            // Must point to field name\n-            String fieldName = parser.currentName();\n-            // And then the value...\n-            parser.nextToken();\n-            T value = mapValueParser.apply(parser);\n-            map.put(fieldName, value);\n-        }\n-        return map;\n+        return token == Token.FIELD_NAME;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3d50cd642c724afda9a4f4d4de6e37f2af2cc02"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU4NDM3Mw==", "bodyText": "The behavior was already that way, so no need for you to change it.", "url": "https://github.com/elastic/elasticsearch/pull/61442#discussion_r477584373", "createdAt": "2020-08-26T20:57:02Z", "author": {"login": "jaymode"}, "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/support/AbstractXContentParser.java", "diffHunk": "@@ -263,117 +263,141 @@ public CharBuffer charBufferOrNull() throws IOException {\n \n     @Override\n     public Map<String, Object> map() throws IOException {\n-        return readMap(this);\n+        return readMapSafe(this, SIMPLE_MAP_FACTORY);\n     }\n \n     @Override\n     public Map<String, Object> mapOrdered() throws IOException {\n-        return readOrderedMap(this);\n+        return readMapSafe(this, ORDERED_MAP_FACTORY);\n     }\n \n     @Override\n     public Map<String, String> mapStrings() throws IOException {\n-        return readMapStrings(this);\n+        return map(HashMap::new, XContentParser::text);\n     }\n \n     @Override\n     public <T> Map<String, T> map(\n             Supplier<Map<String, T>> mapFactory, CheckedFunction<XContentParser, T, IOException> mapValueParser) throws IOException {\n-        return readGenericMap(this, mapFactory, mapValueParser);\n+        final Map<String, T> map = mapFactory.get();\n+        if (findNonEmptyMapStart(this) == false) {\n+            return map;\n+        }\n+        assert currentToken() == Token.FIELD_NAME : \"Expected field name but saw [\" + currentToken() + \"]\";\n+        do {\n+            // Must point to field name\n+            String fieldName = currentName();\n+            // And then the value...\n+            nextToken();\n+            T value = mapValueParser.apply(this);\n+            map.put(fieldName, value);\n+        } while (nextToken() == XContentParser.Token.FIELD_NAME);\n+        return map;\n     }\n \n     @Override\n     public List<Object> list() throws IOException {\n-        return readList(this);\n+        skipToListStart(this);\n+        return readListUnsafe(this, SIMPLE_MAP_FACTORY);\n     }\n \n     @Override\n     public List<Object> listOrderedMap() throws IOException {\n-        return readListOrderedMap(this);\n-    }\n-\n-    static final Supplier<Map<String, Object>> SIMPLE_MAP_FACTORY = HashMap::new;\n-\n-    static final Supplier<Map<String, Object>> ORDERED_MAP_FACTORY = LinkedHashMap::new;\n-\n-    static final Supplier<Map<String, String>> SIMPLE_MAP_STRINGS_FACTORY = HashMap::new;\n-\n-    static Map<String, Object> readMap(XContentParser parser) throws IOException {\n-        return readMap(parser, SIMPLE_MAP_FACTORY);\n+        skipToListStart(this);\n+        return readListUnsafe(this, ORDERED_MAP_FACTORY);\n     }\n \n-    static Map<String, Object> readOrderedMap(XContentParser parser) throws IOException {\n-        return readMap(parser, ORDERED_MAP_FACTORY);\n-    }\n+    private static final Supplier<Map<String, Object>> SIMPLE_MAP_FACTORY = HashMap::new;\n \n-    static Map<String, String> readMapStrings(XContentParser parser) throws IOException {\n-        return readGenericMap(parser, SIMPLE_MAP_STRINGS_FACTORY, XContentParser::text);\n-    }\n-\n-    static List<Object> readList(XContentParser parser) throws IOException {\n-        return readList(parser, SIMPLE_MAP_FACTORY);\n-    }\n+    private static final Supplier<Map<String, Object>> ORDERED_MAP_FACTORY = LinkedHashMap::new;\n \n-    static List<Object> readListOrderedMap(XContentParser parser) throws IOException {\n-        return readList(parser, ORDERED_MAP_FACTORY);\n+    private static Map<String, Object> readMapSafe(XContentParser parser, Supplier<Map<String, Object>> mapFactory) throws IOException {\n+        final Map<String, Object> map = mapFactory.get();\n+        return findNonEmptyMapStart(parser) ? readMapEntries(parser, mapFactory, map) : map;\n     }\n \n-    static Map<String, Object> readMap(XContentParser parser, Supplier<Map<String, Object>> mapFactory) throws IOException {\n-        return readGenericMap(parser, mapFactory, p -> readValue(p, mapFactory));\n+    // Read a map without bounds checks from a parser that is assumed to be at the map's first field's name token\n+    private static Map<String, Object> readMapEntries(XContentParser parser, Supplier<Map<String, Object>> mapFactory,\n+                                                      Map<String, Object> map) throws IOException {\n+        assert parser.currentToken() == Token.FIELD_NAME : \"Expected field name but saw [\" + parser.currentToken() + \"]\";\n+        do {\n+            // Must point to field name\n+            String fieldName = parser.currentName();\n+            // And then the value...\n+            Object value = readValueUnsafe(parser.nextToken(), parser, mapFactory);\n+            map.put(fieldName, value);\n+        } while (parser.nextToken() == Token.FIELD_NAME);\n+        return map;\n     }\n \n-    static <T> Map<String, T> readGenericMap(\n-            XContentParser parser,\n-            Supplier<Map<String, T>> mapFactory,\n-            CheckedFunction<XContentParser, T, IOException> mapValueParser) throws IOException {\n-        Map<String, T> map = mapFactory.get();\n-        XContentParser.Token token = parser.currentToken();\n+    /**\n+     * Checks if the next current token in the supplied parser is a map start for a non-empty map.\n+     * Skips to the next token if the parser does not yet have a current token (i.e. {@link #currentToken()} returns {@code null}) and then\n+     * checks it.\n+     *\n+     * @return true if a map start for a non-empty map is found\n+     */\n+    private static boolean findNonEmptyMapStart(XContentParser parser) throws IOException {\n+        Token token = parser.currentToken();\n         if (token == null) {\n             token = parser.nextToken();\n         }\n         if (token == XContentParser.Token.START_OBJECT) {\n             token = parser.nextToken();\n         }\n-        for (; token == XContentParser.Token.FIELD_NAME; token = parser.nextToken()) {\n-            // Must point to field name\n-            String fieldName = parser.currentName();\n-            // And then the value...\n-            parser.nextToken();\n-            T value = mapValueParser.apply(parser);\n-            map.put(fieldName, value);\n-        }\n-        return map;\n+        return token == Token.FIELD_NAME;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU3NzIxNw=="}, "originalCommit": {"oid": "d3d50cd642c724afda9a4f4d4de6e37f2af2cc02"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIwOTI1OA==", "bodyText": "The behavior was already that way, so no need for you to change it.\n\nYea this is+was really weird. I actually tried changing it here initially but we made use of this behaviour in a bunch of places (tests mostly) and it was not trivial to adjust those (would've blown up the PR size a lot) so I kept it for now.", "url": "https://github.com/elastic/elasticsearch/pull/61442#discussion_r478209258", "createdAt": "2020-08-27T07:20:59Z", "author": {"login": "original-brownbear"}, "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/support/AbstractXContentParser.java", "diffHunk": "@@ -263,117 +263,141 @@ public CharBuffer charBufferOrNull() throws IOException {\n \n     @Override\n     public Map<String, Object> map() throws IOException {\n-        return readMap(this);\n+        return readMapSafe(this, SIMPLE_MAP_FACTORY);\n     }\n \n     @Override\n     public Map<String, Object> mapOrdered() throws IOException {\n-        return readOrderedMap(this);\n+        return readMapSafe(this, ORDERED_MAP_FACTORY);\n     }\n \n     @Override\n     public Map<String, String> mapStrings() throws IOException {\n-        return readMapStrings(this);\n+        return map(HashMap::new, XContentParser::text);\n     }\n \n     @Override\n     public <T> Map<String, T> map(\n             Supplier<Map<String, T>> mapFactory, CheckedFunction<XContentParser, T, IOException> mapValueParser) throws IOException {\n-        return readGenericMap(this, mapFactory, mapValueParser);\n+        final Map<String, T> map = mapFactory.get();\n+        if (findNonEmptyMapStart(this) == false) {\n+            return map;\n+        }\n+        assert currentToken() == Token.FIELD_NAME : \"Expected field name but saw [\" + currentToken() + \"]\";\n+        do {\n+            // Must point to field name\n+            String fieldName = currentName();\n+            // And then the value...\n+            nextToken();\n+            T value = mapValueParser.apply(this);\n+            map.put(fieldName, value);\n+        } while (nextToken() == XContentParser.Token.FIELD_NAME);\n+        return map;\n     }\n \n     @Override\n     public List<Object> list() throws IOException {\n-        return readList(this);\n+        skipToListStart(this);\n+        return readListUnsafe(this, SIMPLE_MAP_FACTORY);\n     }\n \n     @Override\n     public List<Object> listOrderedMap() throws IOException {\n-        return readListOrderedMap(this);\n-    }\n-\n-    static final Supplier<Map<String, Object>> SIMPLE_MAP_FACTORY = HashMap::new;\n-\n-    static final Supplier<Map<String, Object>> ORDERED_MAP_FACTORY = LinkedHashMap::new;\n-\n-    static final Supplier<Map<String, String>> SIMPLE_MAP_STRINGS_FACTORY = HashMap::new;\n-\n-    static Map<String, Object> readMap(XContentParser parser) throws IOException {\n-        return readMap(parser, SIMPLE_MAP_FACTORY);\n+        skipToListStart(this);\n+        return readListUnsafe(this, ORDERED_MAP_FACTORY);\n     }\n \n-    static Map<String, Object> readOrderedMap(XContentParser parser) throws IOException {\n-        return readMap(parser, ORDERED_MAP_FACTORY);\n-    }\n+    private static final Supplier<Map<String, Object>> SIMPLE_MAP_FACTORY = HashMap::new;\n \n-    static Map<String, String> readMapStrings(XContentParser parser) throws IOException {\n-        return readGenericMap(parser, SIMPLE_MAP_STRINGS_FACTORY, XContentParser::text);\n-    }\n-\n-    static List<Object> readList(XContentParser parser) throws IOException {\n-        return readList(parser, SIMPLE_MAP_FACTORY);\n-    }\n+    private static final Supplier<Map<String, Object>> ORDERED_MAP_FACTORY = LinkedHashMap::new;\n \n-    static List<Object> readListOrderedMap(XContentParser parser) throws IOException {\n-        return readList(parser, ORDERED_MAP_FACTORY);\n+    private static Map<String, Object> readMapSafe(XContentParser parser, Supplier<Map<String, Object>> mapFactory) throws IOException {\n+        final Map<String, Object> map = mapFactory.get();\n+        return findNonEmptyMapStart(parser) ? readMapEntries(parser, mapFactory, map) : map;\n     }\n \n-    static Map<String, Object> readMap(XContentParser parser, Supplier<Map<String, Object>> mapFactory) throws IOException {\n-        return readGenericMap(parser, mapFactory, p -> readValue(p, mapFactory));\n+    // Read a map without bounds checks from a parser that is assumed to be at the map's first field's name token\n+    private static Map<String, Object> readMapEntries(XContentParser parser, Supplier<Map<String, Object>> mapFactory,\n+                                                      Map<String, Object> map) throws IOException {\n+        assert parser.currentToken() == Token.FIELD_NAME : \"Expected field name but saw [\" + parser.currentToken() + \"]\";\n+        do {\n+            // Must point to field name\n+            String fieldName = parser.currentName();\n+            // And then the value...\n+            Object value = readValueUnsafe(parser.nextToken(), parser, mapFactory);\n+            map.put(fieldName, value);\n+        } while (parser.nextToken() == Token.FIELD_NAME);\n+        return map;\n     }\n \n-    static <T> Map<String, T> readGenericMap(\n-            XContentParser parser,\n-            Supplier<Map<String, T>> mapFactory,\n-            CheckedFunction<XContentParser, T, IOException> mapValueParser) throws IOException {\n-        Map<String, T> map = mapFactory.get();\n-        XContentParser.Token token = parser.currentToken();\n+    /**\n+     * Checks if the next current token in the supplied parser is a map start for a non-empty map.\n+     * Skips to the next token if the parser does not yet have a current token (i.e. {@link #currentToken()} returns {@code null}) and then\n+     * checks it.\n+     *\n+     * @return true if a map start for a non-empty map is found\n+     */\n+    private static boolean findNonEmptyMapStart(XContentParser parser) throws IOException {\n+        Token token = parser.currentToken();\n         if (token == null) {\n             token = parser.nextToken();\n         }\n         if (token == XContentParser.Token.START_OBJECT) {\n             token = parser.nextToken();\n         }\n-        for (; token == XContentParser.Token.FIELD_NAME; token = parser.nextToken()) {\n-            // Must point to field name\n-            String fieldName = parser.currentName();\n-            // And then the value...\n-            parser.nextToken();\n-            T value = mapValueParser.apply(parser);\n-            map.put(fieldName, value);\n-        }\n-        return map;\n+        return token == Token.FIELD_NAME;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU3NzIxNw=="}, "originalCommit": {"oid": "d3d50cd642c724afda9a4f4d4de6e37f2af2cc02"}, "originalPosition": 131}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 792, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}