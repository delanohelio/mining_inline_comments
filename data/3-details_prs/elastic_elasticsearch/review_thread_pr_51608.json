{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY4NTQ0Mjc1", "number": 51608, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMzo0OTozMVrODbk71A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQwOTo1MjozOVrODb2tsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMjQzMjg0OnYy", "diffSide": "LEFT", "path": "server/src/test/java/org/elasticsearch/snapshots/MinThreadsSnapshotRestoreIT.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMzo0OTozMVrOFjI-Vw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMzo0OTozMVrOFjI-Vw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM5MTUxMQ==", "bodyText": "Removing this one instead of adjusting it, it's totally redundant to the new resiliency test I added, that proves we don't get a dead-lock in this code either and it's much more useful for debugging.", "url": "https://github.com/elastic/elasticsearch/pull/51608#discussion_r372391511", "createdAt": "2020-01-29T13:49:31Z", "author": {"login": "original-brownbear"}, "path": "server/src/test/java/org/elasticsearch/snapshots/MinThreadsSnapshotRestoreIT.java", "diffHunk": "@@ -152,58 +152,4 @@ public void testSnapshottingWithInProgressDeletionNotAllowed() throws Exception\n         client().admin().cluster().prepareCreateSnapshot(repo, snapshot2).setWaitForCompletion(true).get();\n         assertEquals(1, client().admin().cluster().prepareGetSnapshots(repo).setSnapshots(\"_all\").get().getSnapshots(repo).size());\n     }\n-\n-    public void testRestoreWithInProgressDeletionsNotAllowed() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52bbaf4308e07725e36da688edcc0c4ecd875406"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwNTI3MDA1OnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/elasticsearch/snapshots/SnapshotResiliencyTests.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQwOToyODozMVrOFjkTNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQwOTo1MTowMlrOFjk-ow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjgzOTIyMQ==", "bodyText": "Just to be sure, the execution order will be randomized by the deterministicTaskQueue?", "url": "https://github.com/elastic/elasticsearch/pull/51608#discussion_r372839221", "createdAt": "2020-01-30T09:28:31Z", "author": {"login": "tlrx"}, "path": "server/src/test/java/org/elasticsearch/snapshots/SnapshotResiliencyTests.java", "diffHunk": "@@ -517,6 +517,63 @@ public void testConcurrentSnapshotCreateAndDeleteOther() {\n         }\n     }\n \n+    public void testConcurrentSnapshotRestoreAndDeleteOther() {\n+        setupTestCluster(randomFrom(1, 3, 5), randomIntBetween(2, 10));\n+\n+        String repoName = \"repo\";\n+        String snapshotName = \"snapshot\";\n+        final String index = \"test\";\n+        final int shards = randomIntBetween(1, 10);\n+\n+        TestClusterNodes.TestClusterNode masterNode =\n+            testClusterNodes.currentMaster(testClusterNodes.nodes.values().iterator().next().clusterService.state());\n+\n+        final StepListener<CreateSnapshotResponse> createSnapshotResponseStepListener = new StepListener<>();\n+\n+        continueOrDie(createRepoAndIndex(repoName, index, shards),\n+            createIndexResponse -> client().admin().cluster().prepareCreateSnapshot(repoName, snapshotName)\n+                .setWaitForCompletion(true).execute(createSnapshotResponseStepListener));\n+\n+        final StepListener<CreateSnapshotResponse> createOtherSnapshotResponseStepListener = new StepListener<>();\n+\n+        continueOrDie(createSnapshotResponseStepListener,\n+            createSnapshotResponse -> client().admin().cluster().prepareCreateSnapshot(repoName, \"snapshot-2\")\n+                .setWaitForCompletion(true)\n+                .execute(createOtherSnapshotResponseStepListener));\n+\n+        final StepListener<AcknowledgedResponse> deleteSnapshotStepListener = new StepListener<>();\n+        final StepListener<RestoreSnapshotResponse> restoreSnapshotResponseListener = new StepListener<>();\n+\n+        continueOrDie(createOtherSnapshotResponseStepListener,\n+            createSnapshotResponse -> {\n+                scheduleNow(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52bbaf4308e07725e36da688edcc0c4ecd875406"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg0NjI1MQ==", "bodyText": "Yes exactly, sometimes the restore will run first, sometimes the delete will run first :)", "url": "https://github.com/elastic/elasticsearch/pull/51608#discussion_r372846251", "createdAt": "2020-01-30T09:43:02Z", "author": {"login": "original-brownbear"}, "path": "server/src/test/java/org/elasticsearch/snapshots/SnapshotResiliencyTests.java", "diffHunk": "@@ -517,6 +517,63 @@ public void testConcurrentSnapshotCreateAndDeleteOther() {\n         }\n     }\n \n+    public void testConcurrentSnapshotRestoreAndDeleteOther() {\n+        setupTestCluster(randomFrom(1, 3, 5), randomIntBetween(2, 10));\n+\n+        String repoName = \"repo\";\n+        String snapshotName = \"snapshot\";\n+        final String index = \"test\";\n+        final int shards = randomIntBetween(1, 10);\n+\n+        TestClusterNodes.TestClusterNode masterNode =\n+            testClusterNodes.currentMaster(testClusterNodes.nodes.values().iterator().next().clusterService.state());\n+\n+        final StepListener<CreateSnapshotResponse> createSnapshotResponseStepListener = new StepListener<>();\n+\n+        continueOrDie(createRepoAndIndex(repoName, index, shards),\n+            createIndexResponse -> client().admin().cluster().prepareCreateSnapshot(repoName, snapshotName)\n+                .setWaitForCompletion(true).execute(createSnapshotResponseStepListener));\n+\n+        final StepListener<CreateSnapshotResponse> createOtherSnapshotResponseStepListener = new StepListener<>();\n+\n+        continueOrDie(createSnapshotResponseStepListener,\n+            createSnapshotResponse -> client().admin().cluster().prepareCreateSnapshot(repoName, \"snapshot-2\")\n+                .setWaitForCompletion(true)\n+                .execute(createOtherSnapshotResponseStepListener));\n+\n+        final StepListener<AcknowledgedResponse> deleteSnapshotStepListener = new StepListener<>();\n+        final StepListener<RestoreSnapshotResponse> restoreSnapshotResponseListener = new StepListener<>();\n+\n+        continueOrDie(createOtherSnapshotResponseStepListener,\n+            createSnapshotResponse -> {\n+                scheduleNow(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjgzOTIyMQ=="}, "originalCommit": {"oid": "52bbaf4308e07725e36da688edcc0c4ecd875406"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg1MDMzOQ==", "bodyText": "Thanks!", "url": "https://github.com/elastic/elasticsearch/pull/51608#discussion_r372850339", "createdAt": "2020-01-30T09:51:02Z", "author": {"login": "tlrx"}, "path": "server/src/test/java/org/elasticsearch/snapshots/SnapshotResiliencyTests.java", "diffHunk": "@@ -517,6 +517,63 @@ public void testConcurrentSnapshotCreateAndDeleteOther() {\n         }\n     }\n \n+    public void testConcurrentSnapshotRestoreAndDeleteOther() {\n+        setupTestCluster(randomFrom(1, 3, 5), randomIntBetween(2, 10));\n+\n+        String repoName = \"repo\";\n+        String snapshotName = \"snapshot\";\n+        final String index = \"test\";\n+        final int shards = randomIntBetween(1, 10);\n+\n+        TestClusterNodes.TestClusterNode masterNode =\n+            testClusterNodes.currentMaster(testClusterNodes.nodes.values().iterator().next().clusterService.state());\n+\n+        final StepListener<CreateSnapshotResponse> createSnapshotResponseStepListener = new StepListener<>();\n+\n+        continueOrDie(createRepoAndIndex(repoName, index, shards),\n+            createIndexResponse -> client().admin().cluster().prepareCreateSnapshot(repoName, snapshotName)\n+                .setWaitForCompletion(true).execute(createSnapshotResponseStepListener));\n+\n+        final StepListener<CreateSnapshotResponse> createOtherSnapshotResponseStepListener = new StepListener<>();\n+\n+        continueOrDie(createSnapshotResponseStepListener,\n+            createSnapshotResponse -> client().admin().cluster().prepareCreateSnapshot(repoName, \"snapshot-2\")\n+                .setWaitForCompletion(true)\n+                .execute(createOtherSnapshotResponseStepListener));\n+\n+        final StepListener<AcknowledgedResponse> deleteSnapshotStepListener = new StepListener<>();\n+        final StepListener<RestoreSnapshotResponse> restoreSnapshotResponseListener = new StepListener<>();\n+\n+        continueOrDie(createOtherSnapshotResponseStepListener,\n+            createSnapshotResponse -> {\n+                scheduleNow(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjgzOTIyMQ=="}, "originalCommit": {"oid": "52bbaf4308e07725e36da688edcc0c4ecd875406"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwNTI5MDA0OnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/elasticsearch/snapshots/SnapshotResiliencyTests.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQwOTozNDo1N1rOFjkfWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQwOTo0MzoxOVrOFjkvSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg0MjMzMA==", "bodyText": "Is there a specific reason to add this check?", "url": "https://github.com/elastic/elasticsearch/pull/51608#discussion_r372842330", "createdAt": "2020-01-30T09:34:57Z", "author": {"login": "tlrx"}, "path": "server/src/test/java/org/elasticsearch/snapshots/SnapshotResiliencyTests.java", "diffHunk": "@@ -517,6 +517,63 @@ public void testConcurrentSnapshotCreateAndDeleteOther() {\n         }\n     }\n \n+    public void testConcurrentSnapshotRestoreAndDeleteOther() {\n+        setupTestCluster(randomFrom(1, 3, 5), randomIntBetween(2, 10));\n+\n+        String repoName = \"repo\";\n+        String snapshotName = \"snapshot\";\n+        final String index = \"test\";\n+        final int shards = randomIntBetween(1, 10);\n+\n+        TestClusterNodes.TestClusterNode masterNode =\n+            testClusterNodes.currentMaster(testClusterNodes.nodes.values().iterator().next().clusterService.state());\n+\n+        final StepListener<CreateSnapshotResponse> createSnapshotResponseStepListener = new StepListener<>();\n+\n+        continueOrDie(createRepoAndIndex(repoName, index, shards),\n+            createIndexResponse -> client().admin().cluster().prepareCreateSnapshot(repoName, snapshotName)\n+                .setWaitForCompletion(true).execute(createSnapshotResponseStepListener));\n+\n+        final StepListener<CreateSnapshotResponse> createOtherSnapshotResponseStepListener = new StepListener<>();\n+\n+        continueOrDie(createSnapshotResponseStepListener,\n+            createSnapshotResponse -> client().admin().cluster().prepareCreateSnapshot(repoName, \"snapshot-2\")\n+                .setWaitForCompletion(true)\n+                .execute(createOtherSnapshotResponseStepListener));\n+\n+        final StepListener<AcknowledgedResponse> deleteSnapshotStepListener = new StepListener<>();\n+        final StepListener<RestoreSnapshotResponse> restoreSnapshotResponseListener = new StepListener<>();\n+\n+        continueOrDie(createOtherSnapshotResponseStepListener,\n+            createSnapshotResponse -> {\n+                scheduleNow(\n+                    () -> client().admin().cluster().prepareDeleteSnapshot(repoName, snapshotName).execute(deleteSnapshotStepListener));\n+                scheduleNow(() -> client().admin().cluster().restoreSnapshot(\n+                    new RestoreSnapshotRequest(repoName, \"snapshot-2\").waitForCompletion(true)\n+                        .renamePattern(\"(.+)\").renameReplacement(\"restored_$1\"),\n+                    restoreSnapshotResponseListener));\n+            });\n+\n+        deterministicTaskQueue.runAllRunnableTasks();\n+\n+        assertThat(deleteSnapshotStepListener.result().isAcknowledged(), is(true));\n+        assertThat(restoreSnapshotResponseListener.result().getRestoreInfo().failedShards(), is(0));\n+\n+        SnapshotsInProgress finalSnapshotsInProgress = masterNode.clusterService.state().custom(SnapshotsInProgress.TYPE);\n+        assertFalse(finalSnapshotsInProgress.entries().stream().anyMatch(entry -> entry.state().completed() == false));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52bbaf4308e07725e36da688edcc0c4ecd875406"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg0NjQwOA==", "bodyText": "Nah, that was just stupid c&p :) dropped it, sorry for the noise.", "url": "https://github.com/elastic/elasticsearch/pull/51608#discussion_r372846408", "createdAt": "2020-01-30T09:43:19Z", "author": {"login": "original-brownbear"}, "path": "server/src/test/java/org/elasticsearch/snapshots/SnapshotResiliencyTests.java", "diffHunk": "@@ -517,6 +517,63 @@ public void testConcurrentSnapshotCreateAndDeleteOther() {\n         }\n     }\n \n+    public void testConcurrentSnapshotRestoreAndDeleteOther() {\n+        setupTestCluster(randomFrom(1, 3, 5), randomIntBetween(2, 10));\n+\n+        String repoName = \"repo\";\n+        String snapshotName = \"snapshot\";\n+        final String index = \"test\";\n+        final int shards = randomIntBetween(1, 10);\n+\n+        TestClusterNodes.TestClusterNode masterNode =\n+            testClusterNodes.currentMaster(testClusterNodes.nodes.values().iterator().next().clusterService.state());\n+\n+        final StepListener<CreateSnapshotResponse> createSnapshotResponseStepListener = new StepListener<>();\n+\n+        continueOrDie(createRepoAndIndex(repoName, index, shards),\n+            createIndexResponse -> client().admin().cluster().prepareCreateSnapshot(repoName, snapshotName)\n+                .setWaitForCompletion(true).execute(createSnapshotResponseStepListener));\n+\n+        final StepListener<CreateSnapshotResponse> createOtherSnapshotResponseStepListener = new StepListener<>();\n+\n+        continueOrDie(createSnapshotResponseStepListener,\n+            createSnapshotResponse -> client().admin().cluster().prepareCreateSnapshot(repoName, \"snapshot-2\")\n+                .setWaitForCompletion(true)\n+                .execute(createOtherSnapshotResponseStepListener));\n+\n+        final StepListener<AcknowledgedResponse> deleteSnapshotStepListener = new StepListener<>();\n+        final StepListener<RestoreSnapshotResponse> restoreSnapshotResponseListener = new StepListener<>();\n+\n+        continueOrDie(createOtherSnapshotResponseStepListener,\n+            createSnapshotResponse -> {\n+                scheduleNow(\n+                    () -> client().admin().cluster().prepareDeleteSnapshot(repoName, snapshotName).execute(deleteSnapshotStepListener));\n+                scheduleNow(() -> client().admin().cluster().restoreSnapshot(\n+                    new RestoreSnapshotRequest(repoName, \"snapshot-2\").waitForCompletion(true)\n+                        .renamePattern(\"(.+)\").renameReplacement(\"restored_$1\"),\n+                    restoreSnapshotResponseListener));\n+            });\n+\n+        deterministicTaskQueue.runAllRunnableTasks();\n+\n+        assertThat(deleteSnapshotStepListener.result().isAcknowledged(), is(true));\n+        assertThat(restoreSnapshotResponseListener.result().getRestoreInfo().failedShards(), is(0));\n+\n+        SnapshotsInProgress finalSnapshotsInProgress = masterNode.clusterService.state().custom(SnapshotsInProgress.TYPE);\n+        assertFalse(finalSnapshotsInProgress.entries().stream().anyMatch(entry -> entry.state().completed() == false));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg0MjMzMA=="}, "originalCommit": {"oid": "52bbaf4308e07725e36da688edcc0c4ecd875406"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwNTI5MzM1OnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/elasticsearch/snapshots/SnapshotResiliencyTests.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQwOTozNjowNVrOFjkhbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQwOTo0MzozMFrOFjkvtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg0Mjg2MQ==", "bodyText": "Maybe also check that the expected snapshot is here?", "url": "https://github.com/elastic/elasticsearch/pull/51608#discussion_r372842861", "createdAt": "2020-01-30T09:36:05Z", "author": {"login": "tlrx"}, "path": "server/src/test/java/org/elasticsearch/snapshots/SnapshotResiliencyTests.java", "diffHunk": "@@ -517,6 +517,63 @@ public void testConcurrentSnapshotCreateAndDeleteOther() {\n         }\n     }\n \n+    public void testConcurrentSnapshotRestoreAndDeleteOther() {\n+        setupTestCluster(randomFrom(1, 3, 5), randomIntBetween(2, 10));\n+\n+        String repoName = \"repo\";\n+        String snapshotName = \"snapshot\";\n+        final String index = \"test\";\n+        final int shards = randomIntBetween(1, 10);\n+\n+        TestClusterNodes.TestClusterNode masterNode =\n+            testClusterNodes.currentMaster(testClusterNodes.nodes.values().iterator().next().clusterService.state());\n+\n+        final StepListener<CreateSnapshotResponse> createSnapshotResponseStepListener = new StepListener<>();\n+\n+        continueOrDie(createRepoAndIndex(repoName, index, shards),\n+            createIndexResponse -> client().admin().cluster().prepareCreateSnapshot(repoName, snapshotName)\n+                .setWaitForCompletion(true).execute(createSnapshotResponseStepListener));\n+\n+        final StepListener<CreateSnapshotResponse> createOtherSnapshotResponseStepListener = new StepListener<>();\n+\n+        continueOrDie(createSnapshotResponseStepListener,\n+            createSnapshotResponse -> client().admin().cluster().prepareCreateSnapshot(repoName, \"snapshot-2\")\n+                .setWaitForCompletion(true)\n+                .execute(createOtherSnapshotResponseStepListener));\n+\n+        final StepListener<AcknowledgedResponse> deleteSnapshotStepListener = new StepListener<>();\n+        final StepListener<RestoreSnapshotResponse> restoreSnapshotResponseListener = new StepListener<>();\n+\n+        continueOrDie(createOtherSnapshotResponseStepListener,\n+            createSnapshotResponse -> {\n+                scheduleNow(\n+                    () -> client().admin().cluster().prepareDeleteSnapshot(repoName, snapshotName).execute(deleteSnapshotStepListener));\n+                scheduleNow(() -> client().admin().cluster().restoreSnapshot(\n+                    new RestoreSnapshotRequest(repoName, \"snapshot-2\").waitForCompletion(true)\n+                        .renamePattern(\"(.+)\").renameReplacement(\"restored_$1\"),\n+                    restoreSnapshotResponseListener));\n+            });\n+\n+        deterministicTaskQueue.runAllRunnableTasks();\n+\n+        assertThat(deleteSnapshotStepListener.result().isAcknowledged(), is(true));\n+        assertThat(restoreSnapshotResponseListener.result().getRestoreInfo().failedShards(), is(0));\n+\n+        SnapshotsInProgress finalSnapshotsInProgress = masterNode.clusterService.state().custom(SnapshotsInProgress.TYPE);\n+        assertFalse(finalSnapshotsInProgress.entries().stream().anyMatch(entry -> entry.state().completed() == false));\n+        final Repository repository = masterNode.repositoriesService.repository(repoName);\n+        Collection<SnapshotId> snapshotIds = getRepositoryData(repository).getSnapshotIds();\n+        assertThat(snapshotIds, hasSize(1));\n+\n+        for (SnapshotId snapshotId : snapshotIds) {\n+            final SnapshotInfo snapshotInfo = repository.getSnapshotInfo(snapshotId);\n+            assertEquals(SnapshotState.SUCCESS, snapshotInfo.state());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52bbaf4308e07725e36da688edcc0c4ecd875406"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg0NjUxNg==", "bodyText": "Sure I made the check more exact in ece5a80", "url": "https://github.com/elastic/elasticsearch/pull/51608#discussion_r372846516", "createdAt": "2020-01-30T09:43:30Z", "author": {"login": "original-brownbear"}, "path": "server/src/test/java/org/elasticsearch/snapshots/SnapshotResiliencyTests.java", "diffHunk": "@@ -517,6 +517,63 @@ public void testConcurrentSnapshotCreateAndDeleteOther() {\n         }\n     }\n \n+    public void testConcurrentSnapshotRestoreAndDeleteOther() {\n+        setupTestCluster(randomFrom(1, 3, 5), randomIntBetween(2, 10));\n+\n+        String repoName = \"repo\";\n+        String snapshotName = \"snapshot\";\n+        final String index = \"test\";\n+        final int shards = randomIntBetween(1, 10);\n+\n+        TestClusterNodes.TestClusterNode masterNode =\n+            testClusterNodes.currentMaster(testClusterNodes.nodes.values().iterator().next().clusterService.state());\n+\n+        final StepListener<CreateSnapshotResponse> createSnapshotResponseStepListener = new StepListener<>();\n+\n+        continueOrDie(createRepoAndIndex(repoName, index, shards),\n+            createIndexResponse -> client().admin().cluster().prepareCreateSnapshot(repoName, snapshotName)\n+                .setWaitForCompletion(true).execute(createSnapshotResponseStepListener));\n+\n+        final StepListener<CreateSnapshotResponse> createOtherSnapshotResponseStepListener = new StepListener<>();\n+\n+        continueOrDie(createSnapshotResponseStepListener,\n+            createSnapshotResponse -> client().admin().cluster().prepareCreateSnapshot(repoName, \"snapshot-2\")\n+                .setWaitForCompletion(true)\n+                .execute(createOtherSnapshotResponseStepListener));\n+\n+        final StepListener<AcknowledgedResponse> deleteSnapshotStepListener = new StepListener<>();\n+        final StepListener<RestoreSnapshotResponse> restoreSnapshotResponseListener = new StepListener<>();\n+\n+        continueOrDie(createOtherSnapshotResponseStepListener,\n+            createSnapshotResponse -> {\n+                scheduleNow(\n+                    () -> client().admin().cluster().prepareDeleteSnapshot(repoName, snapshotName).execute(deleteSnapshotStepListener));\n+                scheduleNow(() -> client().admin().cluster().restoreSnapshot(\n+                    new RestoreSnapshotRequest(repoName, \"snapshot-2\").waitForCompletion(true)\n+                        .renamePattern(\"(.+)\").renameReplacement(\"restored_$1\"),\n+                    restoreSnapshotResponseListener));\n+            });\n+\n+        deterministicTaskQueue.runAllRunnableTasks();\n+\n+        assertThat(deleteSnapshotStepListener.result().isAcknowledged(), is(true));\n+        assertThat(restoreSnapshotResponseListener.result().getRestoreInfo().failedShards(), is(0));\n+\n+        SnapshotsInProgress finalSnapshotsInProgress = masterNode.clusterService.state().custom(SnapshotsInProgress.TYPE);\n+        assertFalse(finalSnapshotsInProgress.entries().stream().anyMatch(entry -> entry.state().completed() == false));\n+        final Repository repository = masterNode.repositoriesService.repository(repoName);\n+        Collection<SnapshotId> snapshotIds = getRepositoryData(repository).getSnapshotIds();\n+        assertThat(snapshotIds, hasSize(1));\n+\n+        for (SnapshotId snapshotId : snapshotIds) {\n+            final SnapshotInfo snapshotInfo = repository.getSnapshotInfo(snapshotId);\n+            assertEquals(SnapshotState.SUCCESS, snapshotInfo.state());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg0Mjg2MQ=="}, "originalCommit": {"oid": "52bbaf4308e07725e36da688edcc0c4ecd875406"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwNTM0NTc5OnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/elasticsearch/snapshots/SnapshotResiliencyTests.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQwOTo1MjozOVrOFjlB_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxMDozMDozOVrOFjmNSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg1MTE5Ng==", "bodyText": "Should we also index some docs (mostly to generate more snapshot files) before and in-between snapshots, and then run a query?", "url": "https://github.com/elastic/elasticsearch/pull/51608#discussion_r372851196", "createdAt": "2020-01-30T09:52:39Z", "author": {"login": "tlrx"}, "path": "server/src/test/java/org/elasticsearch/snapshots/SnapshotResiliencyTests.java", "diffHunk": "@@ -517,6 +518,61 @@ public void testConcurrentSnapshotCreateAndDeleteOther() {\n         }\n     }\n \n+    public void testConcurrentSnapshotRestoreAndDeleteOther() {\n+        setupTestCluster(randomFrom(1, 3, 5), randomIntBetween(2, 10));\n+\n+        String repoName = \"repo\";\n+        String snapshotName = \"snapshot\";\n+        final String index = \"test\";\n+        final int shards = randomIntBetween(1, 10);\n+\n+        TestClusterNodes.TestClusterNode masterNode =\n+            testClusterNodes.currentMaster(testClusterNodes.nodes.values().iterator().next().clusterService.state());\n+\n+        final StepListener<CreateSnapshotResponse> createSnapshotResponseStepListener = new StepListener<>();\n+\n+        continueOrDie(createRepoAndIndex(repoName, index, shards),\n+            createIndexResponse -> client().admin().cluster().prepareCreateSnapshot(repoName, snapshotName)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ece5a807f3ec17b1667ce8fad0a5bceb95e858fb"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg2ODY1OA==", "bodyText": "Good idea, right now I don't expect it to make a difference but good to have some checks on this :) I pushed e8fe17e", "url": "https://github.com/elastic/elasticsearch/pull/51608#discussion_r372868658", "createdAt": "2020-01-30T10:26:53Z", "author": {"login": "original-brownbear"}, "path": "server/src/test/java/org/elasticsearch/snapshots/SnapshotResiliencyTests.java", "diffHunk": "@@ -517,6 +518,61 @@ public void testConcurrentSnapshotCreateAndDeleteOther() {\n         }\n     }\n \n+    public void testConcurrentSnapshotRestoreAndDeleteOther() {\n+        setupTestCluster(randomFrom(1, 3, 5), randomIntBetween(2, 10));\n+\n+        String repoName = \"repo\";\n+        String snapshotName = \"snapshot\";\n+        final String index = \"test\";\n+        final int shards = randomIntBetween(1, 10);\n+\n+        TestClusterNodes.TestClusterNode masterNode =\n+            testClusterNodes.currentMaster(testClusterNodes.nodes.values().iterator().next().clusterService.state());\n+\n+        final StepListener<CreateSnapshotResponse> createSnapshotResponseStepListener = new StepListener<>();\n+\n+        continueOrDie(createRepoAndIndex(repoName, index, shards),\n+            createIndexResponse -> client().admin().cluster().prepareCreateSnapshot(repoName, snapshotName)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg1MTE5Ng=="}, "originalCommit": {"oid": "ece5a807f3ec17b1667ce8fad0a5bceb95e858fb"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg3MDQ3NQ==", "bodyText": "I don't expect it either but I prefer to have some shard files around :) Thanks", "url": "https://github.com/elastic/elasticsearch/pull/51608#discussion_r372870475", "createdAt": "2020-01-30T10:30:39Z", "author": {"login": "tlrx"}, "path": "server/src/test/java/org/elasticsearch/snapshots/SnapshotResiliencyTests.java", "diffHunk": "@@ -517,6 +518,61 @@ public void testConcurrentSnapshotCreateAndDeleteOther() {\n         }\n     }\n \n+    public void testConcurrentSnapshotRestoreAndDeleteOther() {\n+        setupTestCluster(randomFrom(1, 3, 5), randomIntBetween(2, 10));\n+\n+        String repoName = \"repo\";\n+        String snapshotName = \"snapshot\";\n+        final String index = \"test\";\n+        final int shards = randomIntBetween(1, 10);\n+\n+        TestClusterNodes.TestClusterNode masterNode =\n+            testClusterNodes.currentMaster(testClusterNodes.nodes.values().iterator().next().clusterService.state());\n+\n+        final StepListener<CreateSnapshotResponse> createSnapshotResponseStepListener = new StepListener<>();\n+\n+        continueOrDie(createRepoAndIndex(repoName, index, shards),\n+            createIndexResponse -> client().admin().cluster().prepareCreateSnapshot(repoName, snapshotName)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg1MTE5Ng=="}, "originalCommit": {"oid": "ece5a807f3ec17b1667ce8fad0a5bceb95e858fb"}, "originalPosition": 26}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 97, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}