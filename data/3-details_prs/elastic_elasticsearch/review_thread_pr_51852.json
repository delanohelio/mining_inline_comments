{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcwNzQ4MDUy", "number": 51852, "reviewThreads": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxNTozODoxNlrODegAwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQwODoyODoyMVrODmlTbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMzA4MzU0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/search/SearchQueryThenFetchAsyncAction.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxNTozODoxNlrOFnqvwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwODoyMzozNVrOFvI4RQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzEzOTEzNg==", "bodyText": "Not relevant to this PR, but In future, do we want to rewrite  also requests without sort ( e.g. a keyword search) that can be shortcut?", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r377139136", "createdAt": "2020-02-10T15:38:16Z", "author": {"login": "mayya-sharipova"}, "path": "server/src/main/java/org/elasticsearch/action/search/SearchQueryThenFetchAsyncAction.java", "diffHunk": "@@ -72,4 +85,38 @@ protected void onShardGroupFailure(int shardIndex, Exception exc) {\n     protected SearchPhase getNextPhase(final SearchPhaseResults<SearchPhaseResult> results, final SearchPhaseContext context) {\n         return new FetchSearchPhase(results, searchPhaseController, context);\n     }\n+\n+    ShardSearchRequest rewriteShardRequest(ShardSearchRequest request) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71876e4253d3bac8f2acab736aaa74ba35edf310"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk3Mjg2OQ==", "bodyText": "I am not sure I follow. Are you talking of handling queries sorted by _score ? We can probably propagate the global min competitive score up to the query collector so that wouldn't require any rewrite.", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r384972869", "createdAt": "2020-02-27T08:23:35Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/action/search/SearchQueryThenFetchAsyncAction.java", "diffHunk": "@@ -72,4 +85,38 @@ protected void onShardGroupFailure(int shardIndex, Exception exc) {\n     protected SearchPhase getNextPhase(final SearchPhaseResults<SearchPhaseResult> results, final SearchPhaseContext context) {\n         return new FetchSearchPhase(results, searchPhaseController, context);\n     }\n+\n+    ShardSearchRequest rewriteShardRequest(ShardSearchRequest request) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzEzOTEzNg=="}, "originalCommit": {"oid": "71876e4253d3bac8f2acab736aaa74ba35edf310"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMzEwMTI2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/search/SearchQueryThenFetchAsyncAction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxNTo0MjoyMVrOFnq67Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxNTo0MjoyMVrOFnq67Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzE0MTk5Nw==", "bodyText": "we can use this.topDocsSize  that we have already pre-calculated.", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r377141997", "createdAt": "2020-02-10T15:42:21Z", "author": {"login": "mayya-sharipova"}, "path": "server/src/main/java/org/elasticsearch/action/search/SearchQueryThenFetchAsyncAction.java", "diffHunk": "@@ -72,4 +85,38 @@ protected void onShardGroupFailure(int shardIndex, Exception exc) {\n     protected SearchPhase getNextPhase(final SearchPhaseResults<SearchPhaseResult> results, final SearchPhaseContext context) {\n         return new FetchSearchPhase(results, searchPhaseController, context);\n     }\n+\n+    ShardSearchRequest rewriteShardRequest(ShardSearchRequest request) {\n+        TopDocs topDocs = topDocsSupplier.get();\n+        if (topDocs != null && topDocs instanceof TopFieldDocs) {\n+            SearchSourceBuilder source = request.source();\n+            int trackTotalHits = source.trackTotalHitsUpTo() == null ? DEFAULT_TRACK_TOTAL_HITS_UP_TO :\n+                source.trackTotalHitsUpTo();\n+            if (topDocs.totalHits.value >= trackTotalHits) {\n+                SearchSourceBuilder newSource = source.shallowCopy();\n+                newSource.trackTotalHits(false);\n+                if (topDocs.scoreDocs.length >= topDocsSize) {\n+                    FieldDoc bottomDoc = (FieldDoc) topDocs.scoreDocs[topDocs.scoreDocs.length-1];\n+                    request.setRawBottomSortValues(bottomDoc.fields);\n+                }\n+                request.source(newSource);\n+            }\n+        }\n+        return request;\n+    }\n+\n+    private Supplier<TopDocs> getBufferTopDocsSupplier(SearchRequest request,\n+                                                       SearchPhaseResults<SearchPhaseResult> searchPhaseResults) {\n+        if (searchPhaseResults instanceof SearchPhaseController.QueryPhaseResultConsumer == false) {\n+            return () -> null;\n+        }\n+        int size = getTopDocsSize(request);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71876e4253d3bac8f2acab736aaa74ba35edf310"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMzYzNzE0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/search/SearchPhaseController.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxODowNTo0OVrOFnwG9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNDo1OTozM1rOFv3zkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzIyNjk5Nw==", "bodyText": "I wondering about the case where there was not a reduction, and topDocsBuffer[0] contains a result of any of the first X shards (X is currently 512 by default).   In this case the bottom doc of this shard may not be the best competitive doc.  If we have several topDocs available, should we inspect all of them to find the most competitive doc?", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r377226997", "createdAt": "2020-02-10T18:05:49Z", "author": {"login": "mayya-sharipova"}, "path": "server/src/main/java/org/elasticsearch/action/search/SearchPhaseController.java", "diffHunk": "@@ -683,6 +683,15 @@ private synchronized void consumeInternal(QuerySearchResult querySearchResult) {\n             processedShards[querySearchResult.getShardIndex()] = querySearchResult.getSearchShardTarget();\n         }\n \n+        public TopDocs getBufferTopDocs() {\n+            if (hasTopDocs) {\n+                synchronized (this) {\n+                    return topDocsBuffer[0];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71876e4253d3bac8f2acab736aaa74ba35edf310"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTExMDk4OQ==", "bodyText": "It's correct since any top hits that contains the requested size can be used but I agree that checking all top hits no matter what the buffer size could yield significant improvements. I was expecting to lower the batched_reduce_size by default in # so that this won't make a big difference but there are some discussions regarding the impact of setting this to a low value so making the change that you propose would make this decision less important for this optim. We also expect that this optimization will be really effective when the sort values are not randomly distributed so we could just check the worst hit of each shard and keep the minimum one which can be done linearly. I'll work on the change.", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r385110989", "createdAt": "2020-02-27T13:01:44Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/action/search/SearchPhaseController.java", "diffHunk": "@@ -683,6 +683,15 @@ private synchronized void consumeInternal(QuerySearchResult querySearchResult) {\n             processedShards[querySearchResult.getShardIndex()] = querySearchResult.getSearchShardTarget();\n         }\n \n+        public TopDocs getBufferTopDocs() {\n+            if (hasTopDocs) {\n+                synchronized (this) {\n+                    return topDocsBuffer[0];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzIyNjk5Nw=="}, "originalCommit": {"oid": "71876e4253d3bac8f2acab736aaa74ba35edf310"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc0MTcxMw==", "bodyText": "I pushed bf8ebde", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r385741713", "createdAt": "2020-02-28T14:59:33Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/action/search/SearchPhaseController.java", "diffHunk": "@@ -683,6 +683,15 @@ private synchronized void consumeInternal(QuerySearchResult querySearchResult) {\n             processedShards[querySearchResult.getShardIndex()] = querySearchResult.getSearchShardTarget();\n         }\n \n+        public TopDocs getBufferTopDocs() {\n+            if (hasTopDocs) {\n+                synchronized (this) {\n+                    return topDocsBuffer[0];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzIyNjk5Nw=="}, "originalCommit": {"oid": "71876e4253d3bac8f2acab736aaa74ba35edf310"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMzczNDAwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/search/SearchQueryThenFetchAsyncAction.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxODozNzozMVrOFnxElg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNDo1OTozOVrOFv3zww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI0Mjc3NA==", "bodyText": "should we instead sum all values from totalHits.value from all topDocs in QueryPhaseResultConsumer#topDocsBuffer?", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r377242774", "createdAt": "2020-02-10T18:37:31Z", "author": {"login": "mayya-sharipova"}, "path": "server/src/main/java/org/elasticsearch/action/search/SearchQueryThenFetchAsyncAction.java", "diffHunk": "@@ -72,4 +85,38 @@ protected void onShardGroupFailure(int shardIndex, Exception exc) {\n     protected SearchPhase getNextPhase(final SearchPhaseResults<SearchPhaseResult> results, final SearchPhaseContext context) {\n         return new FetchSearchPhase(results, searchPhaseController, context);\n     }\n+\n+    ShardSearchRequest rewriteShardRequest(ShardSearchRequest request) {\n+        TopDocs topDocs = topDocsSupplier.get();\n+        if (topDocs != null && topDocs instanceof TopFieldDocs) {\n+            SearchSourceBuilder source = request.source();\n+            int trackTotalHits = source.trackTotalHitsUpTo() == null ? DEFAULT_TRACK_TOTAL_HITS_UP_TO :\n+                source.trackTotalHitsUpTo();\n+            if (topDocs.totalHits.value >= trackTotalHits) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71876e4253d3bac8f2acab736aaa74ba35edf310"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTExMTAzNQ==", "bodyText": "++, that will converge more quickly to the provided trackTotalHits.", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r385111035", "createdAt": "2020-02-27T13:01:49Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/action/search/SearchQueryThenFetchAsyncAction.java", "diffHunk": "@@ -72,4 +85,38 @@ protected void onShardGroupFailure(int shardIndex, Exception exc) {\n     protected SearchPhase getNextPhase(final SearchPhaseResults<SearchPhaseResult> results, final SearchPhaseContext context) {\n         return new FetchSearchPhase(results, searchPhaseController, context);\n     }\n+\n+    ShardSearchRequest rewriteShardRequest(ShardSearchRequest request) {\n+        TopDocs topDocs = topDocsSupplier.get();\n+        if (topDocs != null && topDocs instanceof TopFieldDocs) {\n+            SearchSourceBuilder source = request.source();\n+            int trackTotalHits = source.trackTotalHitsUpTo() == null ? DEFAULT_TRACK_TOTAL_HITS_UP_TO :\n+                source.trackTotalHitsUpTo();\n+            if (topDocs.totalHits.value >= trackTotalHits) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI0Mjc3NA=="}, "originalCommit": {"oid": "71876e4253d3bac8f2acab736aaa74ba35edf310"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc0MTc2Mw==", "bodyText": "I pushed bf8ebde", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r385741763", "createdAt": "2020-02-28T14:59:39Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/action/search/SearchQueryThenFetchAsyncAction.java", "diffHunk": "@@ -72,4 +85,38 @@ protected void onShardGroupFailure(int shardIndex, Exception exc) {\n     protected SearchPhase getNextPhase(final SearchPhaseResults<SearchPhaseResult> results, final SearchPhaseContext context) {\n         return new FetchSearchPhase(results, searchPhaseController, context);\n     }\n+\n+    ShardSearchRequest rewriteShardRequest(ShardSearchRequest request) {\n+        TopDocs topDocs = topDocsSupplier.get();\n+        if (topDocs != null && topDocs instanceof TopFieldDocs) {\n+            SearchSourceBuilder source = request.source();\n+            int trackTotalHits = source.trackTotalHitsUpTo() == null ? DEFAULT_TRACK_TOTAL_HITS_UP_TO :\n+                source.trackTotalHitsUpTo();\n+            if (topDocs.totalHits.value >= trackTotalHits) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI0Mjc3NA=="}, "originalCommit": {"oid": "71876e4253d3bac8f2acab736aaa74ba35edf310"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMzc0NTMxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/internal/ShardSearchRequest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxODo0MTowNVrOFnxLpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNzoxNzowN1rOFv8jZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI0NDU4MA==", "bodyText": "I am wondering if instead TRACK_TOTAL_HITS_DISABLED we can instead have a condition describing that we have already collected enough total hits?", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r377244580", "createdAt": "2020-02-10T18:41:05Z", "author": {"login": "mayya-sharipova"}, "path": "server/src/main/java/org/elasticsearch/search/internal/ShardSearchRequest.java", "diffHunk": "@@ -343,6 +367,25 @@ public String getDescription() {\n         public Rewriteable rewrite(QueryRewriteContext ctx) throws IOException {\n             SearchSourceBuilder newSource = request.source() == null ? null : Rewriteable.rewrite(request.source(), ctx);\n             AliasFilter newAliasFilter = Rewriteable.rewrite(request.getAliasFilter(), ctx);\n+\n+            QueryShardContext shardContext = ctx.convertToShardContext();\n+            FieldSortBuilder primarySort = FieldSortBuilder.getPrimaryFieldSortOrNull(newSource);\n+            // checks if the bottom sort values are guaranteed to be more competitive than all the documents\n+            // contained in the shard\n+            if (shardContext != null\n+                    && primarySort != null\n+                    && primarySort.isBottomSortWithinShard(shardContext, request.getRawBottomSortValues()) == false) {\n+                newSource = newSource.shallowCopy();\n+                if (newSource.trackTotalHitsUpTo() == TRACK_TOTAL_HITS_DISABLED", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71876e4253d3bac8f2acab736aaa74ba35edf310"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTExMTY0NA==", "bodyText": "Sorry I am not following. Are you suggesting that we need another boolean ?", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r385111644", "createdAt": "2020-02-27T13:02:54Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/search/internal/ShardSearchRequest.java", "diffHunk": "@@ -343,6 +367,25 @@ public String getDescription() {\n         public Rewriteable rewrite(QueryRewriteContext ctx) throws IOException {\n             SearchSourceBuilder newSource = request.source() == null ? null : Rewriteable.rewrite(request.source(), ctx);\n             AliasFilter newAliasFilter = Rewriteable.rewrite(request.getAliasFilter(), ctx);\n+\n+            QueryShardContext shardContext = ctx.convertToShardContext();\n+            FieldSortBuilder primarySort = FieldSortBuilder.getPrimaryFieldSortOrNull(newSource);\n+            // checks if the bottom sort values are guaranteed to be more competitive than all the documents\n+            // contained in the shard\n+            if (shardContext != null\n+                    && primarySort != null\n+                    && primarySort.isBottomSortWithinShard(shardContext, request.getRawBottomSortValues()) == false) {\n+                newSource = newSource.shallowCopy();\n+                if (newSource.trackTotalHitsUpTo() == TRACK_TOTAL_HITS_DISABLED", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI0NDU4MA=="}, "originalCommit": {"oid": "71876e4253d3bac8f2acab736aaa74ba35edf310"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgxOTQ5NA==", "bodyText": "Sorry, you are already doing that in SearchQueryThenFetchAsyncAction", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r385819494", "createdAt": "2020-02-28T17:17:07Z", "author": {"login": "mayya-sharipova"}, "path": "server/src/main/java/org/elasticsearch/search/internal/ShardSearchRequest.java", "diffHunk": "@@ -343,6 +367,25 @@ public String getDescription() {\n         public Rewriteable rewrite(QueryRewriteContext ctx) throws IOException {\n             SearchSourceBuilder newSource = request.source() == null ? null : Rewriteable.rewrite(request.source(), ctx);\n             AliasFilter newAliasFilter = Rewriteable.rewrite(request.getAliasFilter(), ctx);\n+\n+            QueryShardContext shardContext = ctx.convertToShardContext();\n+            FieldSortBuilder primarySort = FieldSortBuilder.getPrimaryFieldSortOrNull(newSource);\n+            // checks if the bottom sort values are guaranteed to be more competitive than all the documents\n+            // contained in the shard\n+            if (shardContext != null\n+                    && primarySort != null\n+                    && primarySort.isBottomSortWithinShard(shardContext, request.getRawBottomSortValues()) == false) {\n+                newSource = newSource.shallowCopy();\n+                if (newSource.trackTotalHitsUpTo() == TRACK_TOTAL_HITS_DISABLED", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI0NDU4MA=="}, "originalCommit": {"oid": "71876e4253d3bac8f2acab736aaa74ba35edf310"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMzgzNTkwOnYy", "diffSide": "RIGHT", "path": "rest-api-spec/src/main/resources/rest-api-spec/test/search/140_pre_filter_search_shards.yml", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxOTowODo0M1rOFnyE-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxMTo1NToyNVrOFvyluw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI1OTI1Ng==", "bodyText": "I am wondering if we send MatchNoneQueryBuilder() request to a shard, or size =0 for a request containing query part, can we say that we skipped this shard?", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r377259256", "createdAt": "2020-02-10T19:08:43Z", "author": {"login": "mayya-sharipova"}, "path": "rest-api-spec/src/main/resources/rest-api-spec/test/search/140_pre_filter_search_shards.yml", "diffHunk": "@@ -180,5 +178,47 @@ setup:\n   - match: { _shards.successful: 3 }\n   - match: { _shards.skipped : 0 }\n   - match: { _shards.failed: 0 }\n-  - match: { hits.total: 0 }\n+  - match: { hits.total.value: 0 }\n   - length: { aggregations.idx_terms.buckets: 0 }\n+\n+  # check field sort is correct when skipping query phase\n+  - do:\n+      search:\n+        # ensure that one shard can return empty response\n+        max_concurrent_shard_requests: 1\n+        pre_filter_shard_size: 1\n+        body:\n+          \"size\": 1\n+          \"track_total_hits\": 1\n+          \"sort\": [{ \"created_at\": \"desc\"}]\n+\n+  - match: { _shards.total: 3 }\n+  - match: { _shards.successful: 3 }\n+  - match: { _shards.skipped: 0 }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71876e4253d3bac8f2acab736aaa74ba35edf310"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTExMjczMQ==", "bodyText": "I have mixed feelings about this one. It would provide a valuable feedback for users since rewriting to MatchNoneQueryBuilder means that we can avoid the search threadpool but that information should be materialized for users with fast response time too. It will also make the counter non-deterministic so I wonder how much confusion this would bring.", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r385112731", "createdAt": "2020-02-27T13:05:12Z", "author": {"login": "jimczi"}, "path": "rest-api-spec/src/main/resources/rest-api-spec/test/search/140_pre_filter_search_shards.yml", "diffHunk": "@@ -180,5 +178,47 @@ setup:\n   - match: { _shards.successful: 3 }\n   - match: { _shards.skipped : 0 }\n   - match: { _shards.failed: 0 }\n-  - match: { hits.total: 0 }\n+  - match: { hits.total.value: 0 }\n   - length: { aggregations.idx_terms.buckets: 0 }\n+\n+  # check field sort is correct when skipping query phase\n+  - do:\n+      search:\n+        # ensure that one shard can return empty response\n+        max_concurrent_shard_requests: 1\n+        pre_filter_shard_size: 1\n+        body:\n+          \"size\": 1\n+          \"track_total_hits\": 1\n+          \"sort\": [{ \"created_at\": \"desc\"}]\n+\n+  - match: { _shards.total: 3 }\n+  - match: { _shards.successful: 3 }\n+  - match: { _shards.skipped: 0 }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI1OTI1Ng=="}, "originalCommit": {"oid": "71876e4253d3bac8f2acab736aaa74ba35edf310"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY1NjI1MQ==", "bodyText": "I see, makes sense to keep it as it now.", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r385656251", "createdAt": "2020-02-28T11:55:25Z", "author": {"login": "mayya-sharipova"}, "path": "rest-api-spec/src/main/resources/rest-api-spec/test/search/140_pre_filter_search_shards.yml", "diffHunk": "@@ -180,5 +178,47 @@ setup:\n   - match: { _shards.successful: 3 }\n   - match: { _shards.skipped : 0 }\n   - match: { _shards.failed: 0 }\n-  - match: { hits.total: 0 }\n+  - match: { hits.total.value: 0 }\n   - length: { aggregations.idx_terms.buckets: 0 }\n+\n+  # check field sort is correct when skipping query phase\n+  - do:\n+      search:\n+        # ensure that one shard can return empty response\n+        max_concurrent_shard_requests: 1\n+        pre_filter_shard_size: 1\n+        body:\n+          \"size\": 1\n+          \"track_total_hits\": 1\n+          \"sort\": [{ \"created_at\": \"desc\"}]\n+\n+  - match: { _shards.total: 3 }\n+  - match: { _shards.successful: 3 }\n+  - match: { _shards.skipped: 0 }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI1OTI1Ng=="}, "originalCommit": {"oid": "71876e4253d3bac8f2acab736aaa74ba35edf310"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4OTMzODA0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/search/SearchQueryThenFetchAsyncAction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNjowNDowMFrOFv6JLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNjoxNjoyNFrOFv6jLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc4MDAxNQ==", "bodyText": "should it be fieldComparator.compareValues(bestBottom, cand.fields[0]).... ?", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r385780015", "createdAt": "2020-02-28T16:04:00Z", "author": {"login": "mayya-sharipova"}, "path": "server/src/main/java/org/elasticsearch/action/search/SearchQueryThenFetchAsyncAction.java", "diffHunk": "@@ -72,4 +89,67 @@ protected void onShardGroupFailure(int shardIndex, Exception exc) {\n     protected SearchPhase getNextPhase(final SearchPhaseResults<SearchPhaseResult> results, final SearchPhaseContext context) {\n         return new FetchSearchPhase(results, searchPhaseController, context);\n     }\n+\n+    ShardSearchRequest buildShardSearchRequestInternal(SearchShardIterator shardIt) {\n+        ShardSearchRequest request = super.buildShardSearchRequest(shardIt);\n+        if (resultConsumer == null) {\n+            return request;\n+        }\n+        List<TopFieldDocs> topDocsList = resultConsumer.getRemainingTopDocs().stream()\n+            .filter(obj -> obj instanceof TopFieldDocs)\n+            .map(obj -> (TopFieldDocs) obj)\n+            .collect(Collectors.toList());\n+        if (topDocsList.isEmpty()) {\n+            return request;\n+        }\n+        SearchSourceBuilder source = request.source();\n+        int trackTotalHits = source.trackTotalHitsUpTo() == null ? DEFAULT_TRACK_TOTAL_HITS_UP_TO : source.trackTotalHitsUpTo();\n+        long totalHits = -1;\n+        FieldDoc bestBottom = null;\n+        SortField primarySort = topDocsList.get(0).fields[0];\n+        FieldComparator fieldComparator = primarySort.getComparator(1, 0);\n+        int reverseMul = primarySort.getReverse() ? -1 : 1;\n+        // we don't want to perform a costly merge to find the best bottom field doc so\n+        // we just check pick the best bottom document among the available buffer. This\n+        // means that we don't have the true-best bottom but this avoids running a partial\n+        // merge too often.\n+        for (TopFieldDocs topDocs : topDocsList) {\n+            totalHits += topDocs.totalHits.value;\n+            if (topDocs.scoreDocs.length == topDocsSize) {\n+                FieldDoc cand = (FieldDoc) topDocs.scoreDocs[topDocsSize-1];\n+                if (bestBottom == null ||\n+                        fieldComparator.compareValues(cand.fields[0], cand.fields[0]) * reverseMul > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "30173b6b6adea46e899b29099f8cc15136739abe"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc4NjY2OA==", "bodyText": "Gloups, thanks. I renamed before pushing, this should be correct now.", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r385786668", "createdAt": "2020-02-28T16:16:24Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/action/search/SearchQueryThenFetchAsyncAction.java", "diffHunk": "@@ -72,4 +89,67 @@ protected void onShardGroupFailure(int shardIndex, Exception exc) {\n     protected SearchPhase getNextPhase(final SearchPhaseResults<SearchPhaseResult> results, final SearchPhaseContext context) {\n         return new FetchSearchPhase(results, searchPhaseController, context);\n     }\n+\n+    ShardSearchRequest buildShardSearchRequestInternal(SearchShardIterator shardIt) {\n+        ShardSearchRequest request = super.buildShardSearchRequest(shardIt);\n+        if (resultConsumer == null) {\n+            return request;\n+        }\n+        List<TopFieldDocs> topDocsList = resultConsumer.getRemainingTopDocs().stream()\n+            .filter(obj -> obj instanceof TopFieldDocs)\n+            .map(obj -> (TopFieldDocs) obj)\n+            .collect(Collectors.toList());\n+        if (topDocsList.isEmpty()) {\n+            return request;\n+        }\n+        SearchSourceBuilder source = request.source();\n+        int trackTotalHits = source.trackTotalHitsUpTo() == null ? DEFAULT_TRACK_TOTAL_HITS_UP_TO : source.trackTotalHitsUpTo();\n+        long totalHits = -1;\n+        FieldDoc bestBottom = null;\n+        SortField primarySort = topDocsList.get(0).fields[0];\n+        FieldComparator fieldComparator = primarySort.getComparator(1, 0);\n+        int reverseMul = primarySort.getReverse() ? -1 : 1;\n+        // we don't want to perform a costly merge to find the best bottom field doc so\n+        // we just check pick the best bottom document among the available buffer. This\n+        // means that we don't have the true-best bottom but this avoids running a partial\n+        // merge too often.\n+        for (TopFieldDocs topDocs : topDocsList) {\n+            totalHits += topDocs.totalHits.value;\n+            if (topDocs.scoreDocs.length == topDocsSize) {\n+                FieldDoc cand = (FieldDoc) topDocs.scoreDocs[topDocsSize-1];\n+                if (bestBottom == null ||\n+                        fieldComparator.compareValues(cand.fields[0], cand.fields[0]) * reverseMul > 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc4MDAxNQ=="}, "originalCommit": {"oid": "30173b6b6adea46e899b29099f8cc15136739abe"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4OTM3MTAwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/search/SearchQueryThenFetchAsyncAction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNjoxMzo0MVrOFv6dhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNjoxNjozOVrOFv6jzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc4NTIyMQ==", "bodyText": "It is not clear for me why a default value for totalHits  is -1?", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r385785221", "createdAt": "2020-02-28T16:13:41Z", "author": {"login": "mayya-sharipova"}, "path": "server/src/main/java/org/elasticsearch/action/search/SearchQueryThenFetchAsyncAction.java", "diffHunk": "@@ -72,4 +89,67 @@ protected void onShardGroupFailure(int shardIndex, Exception exc) {\n     protected SearchPhase getNextPhase(final SearchPhaseResults<SearchPhaseResult> results, final SearchPhaseContext context) {\n         return new FetchSearchPhase(results, searchPhaseController, context);\n     }\n+\n+    ShardSearchRequest buildShardSearchRequestInternal(SearchShardIterator shardIt) {\n+        ShardSearchRequest request = super.buildShardSearchRequest(shardIt);\n+        if (resultConsumer == null) {\n+            return request;\n+        }\n+        List<TopFieldDocs> topDocsList = resultConsumer.getRemainingTopDocs().stream()\n+            .filter(obj -> obj instanceof TopFieldDocs)\n+            .map(obj -> (TopFieldDocs) obj)\n+            .collect(Collectors.toList());\n+        if (topDocsList.isEmpty()) {\n+            return request;\n+        }\n+        SearchSourceBuilder source = request.source();\n+        int trackTotalHits = source.trackTotalHitsUpTo() == null ? DEFAULT_TRACK_TOTAL_HITS_UP_TO : source.trackTotalHitsUpTo();\n+        long totalHits = -1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "30173b6b6adea46e899b29099f8cc15136739abe"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc4NjgzMQ==", "bodyText": "It should be 0, thanks. I pushed 8eae737", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r385786831", "createdAt": "2020-02-28T16:16:39Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/action/search/SearchQueryThenFetchAsyncAction.java", "diffHunk": "@@ -72,4 +89,67 @@ protected void onShardGroupFailure(int shardIndex, Exception exc) {\n     protected SearchPhase getNextPhase(final SearchPhaseResults<SearchPhaseResult> results, final SearchPhaseContext context) {\n         return new FetchSearchPhase(results, searchPhaseController, context);\n     }\n+\n+    ShardSearchRequest buildShardSearchRequestInternal(SearchShardIterator shardIt) {\n+        ShardSearchRequest request = super.buildShardSearchRequest(shardIt);\n+        if (resultConsumer == null) {\n+            return request;\n+        }\n+        List<TopFieldDocs> topDocsList = resultConsumer.getRemainingTopDocs().stream()\n+            .filter(obj -> obj instanceof TopFieldDocs)\n+            .map(obj -> (TopFieldDocs) obj)\n+            .collect(Collectors.toList());\n+        if (topDocsList.isEmpty()) {\n+            return request;\n+        }\n+        SearchSourceBuilder source = request.source();\n+        int trackTotalHits = source.trackTotalHitsUpTo() == null ? DEFAULT_TRACK_TOTAL_HITS_UP_TO : source.trackTotalHitsUpTo();\n+        long totalHits = -1;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc4NTIyMQ=="}, "originalCommit": {"oid": "30173b6b6adea46e899b29099f8cc15136739abe"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4OTczNzI0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/sort/FieldSortBuilder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxODowMzo0NFrOFv96Gg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxODowMzo0NFrOFv96Gg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg0MTY5MA==", "bodyText": "Is there a reason why we pass have pass an array of bottom sort values, but we use only 1st element? Should we pass only the 1st element  \u2013 Object[] rawBottomSortValue?", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r385841690", "createdAt": "2020-02-28T18:03:44Z", "author": {"login": "mayya-sharipova"}, "path": "server/src/main/java/org/elasticsearch/search/sort/FieldSortBuilder.java", "diffHunk": "@@ -351,6 +352,41 @@ public SortFieldAndFormat build(QueryShardContext context) throws IOException {\n         return new SortFieldAndFormat(field, fieldType.docValueFormat(null, null));\n     }\n \n+    public boolean canRewriteToMatchNone() {\n+        return nestedSort == null && (missing == null || \"_last\".equals(missing));\n+    }\n+\n+    /**\n+     * Returns whether all values of the given {@link QueryShardContext#getIndexReader()} are within the\n+     * primary sort value provided in the <code>rawBottomSortValues</code>.\n+     */\n+    public boolean isBottomSortWithinShard(QueryShardContext context, Object[] rawBottomSortValues) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8eae737035abbf59b39194d364d68cb7a33d9fae"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMTkzOTU3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/search/SearchQueryThenFetchAsyncAction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNDozMjo1NlrOFxvkDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNDozMjo1NlrOFxvkDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzcwMzgyMg==", "bodyText": "Previously using fieldComparator.compareValues looks to be faster than using TopFieldDocs.merge (as TopFieldDocs.merge doing a lot of stuff that we don't really need),  especially considering that mergeTopDocs is a synchronized function, and we want to be quite fast.", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r387703822", "createdAt": "2020-03-04T14:32:56Z", "author": {"login": "mayya-sharipova"}, "path": "server/src/main/java/org/elasticsearch/action/search/SearchQueryThenFetchAsyncAction.java", "diffHunk": "@@ -85,71 +88,59 @@ protected void onShardGroupFailure(int shardIndex, Exception exc) {\n         progressListener.notifyQueryFailure(shardIndex, exc);\n     }\n \n+    @Override\n+    protected void onShardResult(SearchPhaseResult result, SearchShardIterator shardIt) {\n+        mergeTopDocs(result.queryResult());\n+        super.onShardResult(result, shardIt);\n+    }\n+\n     @Override\n     protected SearchPhase getNextPhase(final SearchPhaseResults<SearchPhaseResult> results, final SearchPhaseContext context) {\n         return new FetchSearchPhase(results, searchPhaseController, context);\n     }\n \n-    ShardSearchRequest buildShardSearchRequestInternal(SearchShardIterator shardIt) {\n-        ShardSearchRequest request = super.buildShardSearchRequest(shardIt);\n-        if (resultConsumer == null) {\n-            return request;\n+    private synchronized void mergeTopDocs(QuerySearchResult result) {\n+        if (result.isNull()\n+                || hasPrimaryFieldSort == false\n+                || result.topDocs().topDocs instanceof TopFieldDocs == false) {\n+            return;\n         }\n-        List<TopFieldDocs> topDocsList = resultConsumer.getRemainingTopDocs().stream()\n-            .filter(obj -> obj instanceof TopFieldDocs)\n-            .map(obj -> (TopFieldDocs) obj)\n-            .collect(Collectors.toList());\n-        if (topDocsList.isEmpty()) {\n-            return request;\n+        // merge the current best bottom field doc with the new query result\n+        TopFieldDocs topDocs = (TopFieldDocs) result.topDocs().topDocs;\n+        final ScoreDoc[] bottomDocs;\n+        if (topDocs.scoreDocs.length == topDocsSize) {\n+            FieldDoc bottom = (FieldDoc) topDocs.scoreDocs[topDocsSize - 1];\n+            bottomDocs = new FieldDoc[] { new FieldDoc(bottom.doc, bottom.score, bottom.fields, result.getShardIndex()) };\n+            bottomDocs[0].shardIndex = result.getShardIndex();\n+        } else {\n+            bottomDocs = new ScoreDoc[0];\n         }\n-        SearchSourceBuilder source = request.source();\n-        int trackTotalHits = source.trackTotalHitsUpTo() == null ? DEFAULT_TRACK_TOTAL_HITS_UP_TO : source.trackTotalHitsUpTo();\n-        long totalHits = 0;\n-        FieldDoc bestBottom = null;\n-        SortField primarySort = topDocsList.get(0).fields[0];\n-        FieldComparator fieldComparator = primarySort.getComparator(1, 0);\n-        int reverseMul = primarySort.getReverse() ? -1 : 1;\n-        // we don't want to perform a costly merge to find the best bottom field doc so\n-        // we just check pick the best bottom document among the available buffer. This\n-        // means that we don't have the true-best bottom but this avoids running a partial\n-        // merge too often.\n-        for (TopFieldDocs topDocs : topDocsList) {\n-            totalHits += topDocs.totalHits.value;\n-            if (topDocs.scoreDocs.length == topDocsSize) {\n-                FieldDoc cand = (FieldDoc) topDocs.scoreDocs[topDocsSize-1];\n-                if (bestBottom == null ||\n-                        fieldComparator.compareValues(cand.fields[0], bestBottom.fields[0]) * reverseMul < 0) {\n-                    bestBottom = cand;\n-                }\n-            }\n+        TopFieldDocs toMerge = new TopFieldDocs(topDocs.totalHits, bottomDocs, topDocs.fields);\n+        if (bottomTopDocs == null) {\n+            bottomTopDocs = toMerge;\n+        } else {\n+            final Sort sort = new Sort(bottomTopDocs.fields);\n+            bottomTopDocs = TopFieldDocs.merge(sort, 0, 1, new TopFieldDocs[]{bottomTopDocs, toMerge}, false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f50ec90eaf3e66fbdc20c028190c7e20df1cdd8f"}, "originalPosition": 134}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwOTIyMzgyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/search/SearchQueryThenFetchAsyncAction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxMToxMzoyMlrOFy1Sxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNTo1MTo0NVrOFzuc4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg0NjI3OA==", "bodyText": "I don't think we should ignore errors here, what if this left bottomTopDocs in an inconsistent state?", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r388846278", "createdAt": "2020-03-06T11:13:22Z", "author": {"login": "jpountz"}, "path": "server/src/main/java/org/elasticsearch/action/search/SearchQueryThenFetchAsyncAction.java", "diffHunk": "@@ -49,27 +66,85 @@\n                 executor, request, listener, shardsIts, timeProvider, clusterStateVersion, task,\n                 searchPhaseController.newSearchPhaseResults(task.getProgressListener(), request, shardsIts.size()),\n                 request.getMaxConcurrentShardRequests(), clusters);\n+        this.topDocsSize = getTopDocsSize(request);\n+        this.trackTotalHitsUpTo = request.resolveTrackTotalHitsUpTo();\n+        this.hasPrimaryFieldSort = FieldSortBuilder.hasPrimaryFieldSort(request.source());\n         this.searchPhaseController = searchPhaseController;\n         this.progressListener = task.getProgressListener();\n-        final SearchProgressListener progressListener = task.getProgressListener();\n         final SearchSourceBuilder sourceBuilder = request.source();\n         progressListener.notifyListShards(progressListener.searchShards(this.shardsIts),\n             sourceBuilder == null || sourceBuilder.size() != 0);\n     }\n \n     protected void executePhaseOnShard(final SearchShardIterator shardIt, final ShardRouting shard,\n                                        final SearchActionListener<SearchPhaseResult> listener) {\n+\n+        ShardSearchRequest request = rewriteShardSearchRequest(super.buildShardSearchRequest(shardIt));\n         getSearchTransport().sendExecuteQuery(getConnection(shardIt.getClusterAlias(), shard.currentNodeId()),\n-            buildShardSearchRequest(shardIt), getTask(), listener);\n+            request, getTask(), listener);\n     }\n \n     @Override\n     protected void onShardGroupFailure(int shardIndex, Exception exc) {\n         progressListener.notifyQueryFailure(shardIndex, exc);\n     }\n \n+    @Override\n+    protected void onShardResult(SearchPhaseResult result, SearchShardIterator shardIt) {\n+        try {\n+            QuerySearchResult queryResult = result.queryResult();\n+            if (queryResult.isNull() == false\n+                    && hasPrimaryFieldSort\n+                    && queryResult.topDocs().topDocs instanceof TopFieldDocs) {\n+                mergeTopDocs((TopFieldDocs) result.queryResult().topDocs().topDocs, result.getShardIndex());\n+            }\n+        } catch (Exception exc) {\n+            getLogger().error(\"Failed to merge response\", exc);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2307e73ce5c4500609a22c9bbba6162a9028407b"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc4Mjc1Mw==", "bodyText": "Agreed, this was a leftover from a debug session ;).", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r389782753", "createdAt": "2020-03-09T15:51:45Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/action/search/SearchQueryThenFetchAsyncAction.java", "diffHunk": "@@ -49,27 +66,85 @@\n                 executor, request, listener, shardsIts, timeProvider, clusterStateVersion, task,\n                 searchPhaseController.newSearchPhaseResults(task.getProgressListener(), request, shardsIts.size()),\n                 request.getMaxConcurrentShardRequests(), clusters);\n+        this.topDocsSize = getTopDocsSize(request);\n+        this.trackTotalHitsUpTo = request.resolveTrackTotalHitsUpTo();\n+        this.hasPrimaryFieldSort = FieldSortBuilder.hasPrimaryFieldSort(request.source());\n         this.searchPhaseController = searchPhaseController;\n         this.progressListener = task.getProgressListener();\n-        final SearchProgressListener progressListener = task.getProgressListener();\n         final SearchSourceBuilder sourceBuilder = request.source();\n         progressListener.notifyListShards(progressListener.searchShards(this.shardsIts),\n             sourceBuilder == null || sourceBuilder.size() != 0);\n     }\n \n     protected void executePhaseOnShard(final SearchShardIterator shardIt, final ShardRouting shard,\n                                        final SearchActionListener<SearchPhaseResult> listener) {\n+\n+        ShardSearchRequest request = rewriteShardSearchRequest(super.buildShardSearchRequest(shardIt));\n         getSearchTransport().sendExecuteQuery(getConnection(shardIt.getClusterAlias(), shard.currentNodeId()),\n-            buildShardSearchRequest(shardIt), getTask(), listener);\n+            request, getTask(), listener);\n     }\n \n     @Override\n     protected void onShardGroupFailure(int shardIndex, Exception exc) {\n         progressListener.notifyQueryFailure(shardIndex, exc);\n     }\n \n+    @Override\n+    protected void onShardResult(SearchPhaseResult result, SearchShardIterator shardIt) {\n+        try {\n+            QuerySearchResult queryResult = result.queryResult();\n+            if (queryResult.isNull() == false\n+                    && hasPrimaryFieldSort\n+                    && queryResult.topDocs().topDocs instanceof TopFieldDocs) {\n+                mergeTopDocs((TopFieldDocs) result.queryResult().topDocs().topDocs, result.getShardIndex());\n+            }\n+        } catch (Exception exc) {\n+            getLogger().error(\"Failed to merge response\", exc);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg0NjI3OA=="}, "originalCommit": {"oid": "2307e73ce5c4500609a22c9bbba6162a9028407b"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwOTIyOTg5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/search/SearchQueryThenFetchAsyncAction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxMToxNTo1MFrOFy1Wfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxMToxNTo1MFrOFy1Wfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg0NzIzMQ==", "bodyText": "is this assertion right? I'm not seeing where we make sure to only call this method on sorted requests.", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r388847231", "createdAt": "2020-03-06T11:15:50Z", "author": {"login": "jpountz"}, "path": "server/src/main/java/org/elasticsearch/action/search/SearchQueryThenFetchAsyncAction.java", "diffHunk": "@@ -49,27 +66,85 @@\n                 executor, request, listener, shardsIts, timeProvider, clusterStateVersion, task,\n                 searchPhaseController.newSearchPhaseResults(task.getProgressListener(), request, shardsIts.size()),\n                 request.getMaxConcurrentShardRequests(), clusters);\n+        this.topDocsSize = getTopDocsSize(request);\n+        this.trackTotalHitsUpTo = request.resolveTrackTotalHitsUpTo();\n+        this.hasPrimaryFieldSort = FieldSortBuilder.hasPrimaryFieldSort(request.source());\n         this.searchPhaseController = searchPhaseController;\n         this.progressListener = task.getProgressListener();\n-        final SearchProgressListener progressListener = task.getProgressListener();\n         final SearchSourceBuilder sourceBuilder = request.source();\n         progressListener.notifyListShards(progressListener.searchShards(this.shardsIts),\n             sourceBuilder == null || sourceBuilder.size() != 0);\n     }\n \n     protected void executePhaseOnShard(final SearchShardIterator shardIt, final ShardRouting shard,\n                                        final SearchActionListener<SearchPhaseResult> listener) {\n+\n+        ShardSearchRequest request = rewriteShardSearchRequest(super.buildShardSearchRequest(shardIt));\n         getSearchTransport().sendExecuteQuery(getConnection(shardIt.getClusterAlias(), shard.currentNodeId()),\n-            buildShardSearchRequest(shardIt), getTask(), listener);\n+            request, getTask(), listener);\n     }\n \n     @Override\n     protected void onShardGroupFailure(int shardIndex, Exception exc) {\n         progressListener.notifyQueryFailure(shardIndex, exc);\n     }\n \n+    @Override\n+    protected void onShardResult(SearchPhaseResult result, SearchShardIterator shardIt) {\n+        try {\n+            QuerySearchResult queryResult = result.queryResult();\n+            if (queryResult.isNull() == false\n+                    && hasPrimaryFieldSort\n+                    && queryResult.topDocs().topDocs instanceof TopFieldDocs) {\n+                mergeTopDocs((TopFieldDocs) result.queryResult().topDocs().topDocs, result.getShardIndex());\n+            }\n+        } catch (Exception exc) {\n+            getLogger().error(\"Failed to merge response\", exc);\n+        }\n+        super.onShardResult(result, shardIt);\n+    }\n+\n     @Override\n     protected SearchPhase getNextPhase(final SearchPhaseResults<SearchPhaseResult> results, final SearchPhaseContext context) {\n         return new FetchSearchPhase(results, searchPhaseController, context);\n     }\n+\n+    // merge the current best bottom field doc with the new query result\n+    private synchronized void mergeTopDocs(TopFieldDocs topDocs, int shardIndex) {\n+        final ScoreDoc[] bottomDocs;\n+        if (topDocs.scoreDocs.length == topDocsSize) {\n+            FieldDoc bottom = (FieldDoc) topDocs.scoreDocs[topDocsSize - 1];\n+            bottomDocs = new FieldDoc[] { new FieldDoc(bottom.doc, bottom.score, bottom.fields, shardIndex) };\n+        } else {\n+            bottomDocs = new ScoreDoc[0];\n+        }\n+        TopFieldDocs toMerge = new TopFieldDocs(topDocs.totalHits, bottomDocs, topDocs.fields);\n+        if (bottomTopDocs == null) {\n+            bottomTopDocs = toMerge;\n+        } else {\n+            final Sort sort = new Sort(bottomTopDocs.fields);\n+            bottomTopDocs = TopFieldDocs.merge(sort, 0, 1, new TopFieldDocs[]{ bottomTopDocs, toMerge }, false);\n+        }\n+    }\n+\n+    ShardSearchRequest rewriteShardSearchRequest(ShardSearchRequest request) {\n+        final TopFieldDocs current = bottomTopDocs;\n+        if (current == null) {\n+            return request;\n+        }\n+\n+        // disable tracking total hits if we already reached the required estimation.\n+        if (trackTotalHitsUpTo != SearchContext.TRACK_TOTAL_HITS_ACCURATE\n+                && current.totalHits.value >= trackTotalHitsUpTo\n+                && current.totalHits.relation == GREATER_THAN_OR_EQUAL_TO) {\n+            assert request.source() != null : \"source should contain a primary sort field\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2307e73ce5c4500609a22c9bbba6162a9028407b"}, "originalPosition": 120}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwOTIzMzg4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/search/SearchQueryThenFetchAsyncAction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxMToxNzoyNFrOFy1Y6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxMToxNzoyNFrOFy1Y6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg0Nzg0OA==", "bodyText": "maybe rename to currentBottomTopDocs to make the below logic easier to read?", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r388847848", "createdAt": "2020-03-06T11:17:24Z", "author": {"login": "jpountz"}, "path": "server/src/main/java/org/elasticsearch/action/search/SearchQueryThenFetchAsyncAction.java", "diffHunk": "@@ -49,27 +66,85 @@\n                 executor, request, listener, shardsIts, timeProvider, clusterStateVersion, task,\n                 searchPhaseController.newSearchPhaseResults(task.getProgressListener(), request, shardsIts.size()),\n                 request.getMaxConcurrentShardRequests(), clusters);\n+        this.topDocsSize = getTopDocsSize(request);\n+        this.trackTotalHitsUpTo = request.resolveTrackTotalHitsUpTo();\n+        this.hasPrimaryFieldSort = FieldSortBuilder.hasPrimaryFieldSort(request.source());\n         this.searchPhaseController = searchPhaseController;\n         this.progressListener = task.getProgressListener();\n-        final SearchProgressListener progressListener = task.getProgressListener();\n         final SearchSourceBuilder sourceBuilder = request.source();\n         progressListener.notifyListShards(progressListener.searchShards(this.shardsIts),\n             sourceBuilder == null || sourceBuilder.size() != 0);\n     }\n \n     protected void executePhaseOnShard(final SearchShardIterator shardIt, final ShardRouting shard,\n                                        final SearchActionListener<SearchPhaseResult> listener) {\n+\n+        ShardSearchRequest request = rewriteShardSearchRequest(super.buildShardSearchRequest(shardIt));\n         getSearchTransport().sendExecuteQuery(getConnection(shardIt.getClusterAlias(), shard.currentNodeId()),\n-            buildShardSearchRequest(shardIt), getTask(), listener);\n+            request, getTask(), listener);\n     }\n \n     @Override\n     protected void onShardGroupFailure(int shardIndex, Exception exc) {\n         progressListener.notifyQueryFailure(shardIndex, exc);\n     }\n \n+    @Override\n+    protected void onShardResult(SearchPhaseResult result, SearchShardIterator shardIt) {\n+        try {\n+            QuerySearchResult queryResult = result.queryResult();\n+            if (queryResult.isNull() == false\n+                    && hasPrimaryFieldSort\n+                    && queryResult.topDocs().topDocs instanceof TopFieldDocs) {\n+                mergeTopDocs((TopFieldDocs) result.queryResult().topDocs().topDocs, result.getShardIndex());\n+            }\n+        } catch (Exception exc) {\n+            getLogger().error(\"Failed to merge response\", exc);\n+        }\n+        super.onShardResult(result, shardIt);\n+    }\n+\n     @Override\n     protected SearchPhase getNextPhase(final SearchPhaseResults<SearchPhaseResult> results, final SearchPhaseContext context) {\n         return new FetchSearchPhase(results, searchPhaseController, context);\n     }\n+\n+    // merge the current best bottom field doc with the new query result\n+    private synchronized void mergeTopDocs(TopFieldDocs topDocs, int shardIndex) {\n+        final ScoreDoc[] bottomDocs;\n+        if (topDocs.scoreDocs.length == topDocsSize) {\n+            FieldDoc bottom = (FieldDoc) topDocs.scoreDocs[topDocsSize - 1];\n+            bottomDocs = new FieldDoc[] { new FieldDoc(bottom.doc, bottom.score, bottom.fields, shardIndex) };\n+        } else {\n+            bottomDocs = new ScoreDoc[0];\n+        }\n+        TopFieldDocs toMerge = new TopFieldDocs(topDocs.totalHits, bottomDocs, topDocs.fields);\n+        if (bottomTopDocs == null) {\n+            bottomTopDocs = toMerge;\n+        } else {\n+            final Sort sort = new Sort(bottomTopDocs.fields);\n+            bottomTopDocs = TopFieldDocs.merge(sort, 0, 1, new TopFieldDocs[]{ bottomTopDocs, toMerge }, false);\n+        }\n+    }\n+\n+    ShardSearchRequest rewriteShardSearchRequest(ShardSearchRequest request) {\n+        final TopFieldDocs current = bottomTopDocs;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2307e73ce5c4500609a22c9bbba6162a9028407b"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwOTI2NjU5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/sort/FieldSortBuilder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxMToyOTozMFrOFy1sjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNTo1NDowMVrOFzujGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg1Mjg3Ng==", "bodyText": "rawBottomSortValues stores the implementation-specific values while isFieldWithinQuery expects high-level representations of the values. For instance, I believe that this implementation as-is is incorrect for date_nanos, which would return a number of nanos since Epoch in rawBottomSortValues and then parse a number of millis in isFieldWithinQuery. So we should call DocValueFormat#format on the min/max values before passing them to isFieldWithinQuery.", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r388852876", "createdAt": "2020-03-06T11:29:30Z", "author": {"login": "jpountz"}, "path": "server/src/main/java/org/elasticsearch/search/sort/FieldSortBuilder.java", "diffHunk": "@@ -351,6 +352,41 @@ public SortFieldAndFormat build(QueryShardContext context) throws IOException {\n         return new SortFieldAndFormat(field, fieldType.docValueFormat(null, null));\n     }\n \n+    public boolean canRewriteToMatchNone() {\n+        return nestedSort == null && (missing == null || \"_last\".equals(missing));\n+    }\n+\n+    /**\n+     * Returns whether some values of the given {@link QueryShardContext#getIndexReader()} are within the\n+     * primary sort value provided in the <code>rawBottomSortValues</code>.\n+     */\n+    public boolean isBottomSortShardDisjoint(QueryShardContext context, Object[] rawBottomSortValues) {\n+        if (rawBottomSortValues == null || rawBottomSortValues.length == 0) {\n+            return false;\n+        }\n+\n+        if (canRewriteToMatchNone() == false) {\n+            return false;\n+        }\n+        MappedFieldType fieldType = context.fieldMapper(fieldName);\n+        if (fieldType == null) {\n+            // unmapped\n+            return false;\n+        }\n+        if (fieldType.indexOptions() == IndexOptions.NONE) {\n+            return false;\n+        }\n+        Object minValue = order() == SortOrder.DESC ? rawBottomSortValues[0] : null;\n+        Object maxValue = order() == SortOrder.DESC ? null : rawBottomSortValues[0];\n+        try {\n+            MappedFieldType.Relation relation = fieldType.isFieldWithinQuery(context.getIndexReader(), minValue, maxValue,\n+                true, true, null, DEFAULT_DATE_TIME_FORMATTER.toDateMathParser(), context);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2307e73ce5c4500609a22c9bbba6162a9028407b"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc4NDM0NQ==", "bodyText": "Good catch, I pushed a change to handle this correctly. I had to pass the original docvalues format in the shard search request in order to use the correct date math parser.", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r389784345", "createdAt": "2020-03-09T15:54:01Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/search/sort/FieldSortBuilder.java", "diffHunk": "@@ -351,6 +352,41 @@ public SortFieldAndFormat build(QueryShardContext context) throws IOException {\n         return new SortFieldAndFormat(field, fieldType.docValueFormat(null, null));\n     }\n \n+    public boolean canRewriteToMatchNone() {\n+        return nestedSort == null && (missing == null || \"_last\".equals(missing));\n+    }\n+\n+    /**\n+     * Returns whether some values of the given {@link QueryShardContext#getIndexReader()} are within the\n+     * primary sort value provided in the <code>rawBottomSortValues</code>.\n+     */\n+    public boolean isBottomSortShardDisjoint(QueryShardContext context, Object[] rawBottomSortValues) {\n+        if (rawBottomSortValues == null || rawBottomSortValues.length == 0) {\n+            return false;\n+        }\n+\n+        if (canRewriteToMatchNone() == false) {\n+            return false;\n+        }\n+        MappedFieldType fieldType = context.fieldMapper(fieldName);\n+        if (fieldType == null) {\n+            // unmapped\n+            return false;\n+        }\n+        if (fieldType.indexOptions() == IndexOptions.NONE) {\n+            return false;\n+        }\n+        Object minValue = order() == SortOrder.DESC ? rawBottomSortValues[0] : null;\n+        Object maxValue = order() == SortOrder.DESC ? null : rawBottomSortValues[0];\n+        try {\n+            MappedFieldType.Relation relation = fieldType.isFieldWithinQuery(context.getIndexReader(), minValue, maxValue,\n+                true, true, null, DEFAULT_DATE_TIME_FORMATTER.toDateMathParser(), context);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg1Mjg3Ng=="}, "originalCommit": {"oid": "2307e73ce5c4500609a22c9bbba6162a9028407b"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwOTI2ODAyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/sort/FieldSortBuilder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxMTozMDowOVrOFy1teQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNTo1NTowN1rOFzul7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg1MzExMw==", "bodyText": "I don't like silently ignoring exceptions here, can we narrow down the exception type or remove the catch block entirely? I worry that this might hide bugs.", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r388853113", "createdAt": "2020-03-06T11:30:09Z", "author": {"login": "jpountz"}, "path": "server/src/main/java/org/elasticsearch/search/sort/FieldSortBuilder.java", "diffHunk": "@@ -351,6 +352,41 @@ public SortFieldAndFormat build(QueryShardContext context) throws IOException {\n         return new SortFieldAndFormat(field, fieldType.docValueFormat(null, null));\n     }\n \n+    public boolean canRewriteToMatchNone() {\n+        return nestedSort == null && (missing == null || \"_last\".equals(missing));\n+    }\n+\n+    /**\n+     * Returns whether some values of the given {@link QueryShardContext#getIndexReader()} are within the\n+     * primary sort value provided in the <code>rawBottomSortValues</code>.\n+     */\n+    public boolean isBottomSortShardDisjoint(QueryShardContext context, Object[] rawBottomSortValues) {\n+        if (rawBottomSortValues == null || rawBottomSortValues.length == 0) {\n+            return false;\n+        }\n+\n+        if (canRewriteToMatchNone() == false) {\n+            return false;\n+        }\n+        MappedFieldType fieldType = context.fieldMapper(fieldName);\n+        if (fieldType == null) {\n+            // unmapped\n+            return false;\n+        }\n+        if (fieldType.indexOptions() == IndexOptions.NONE) {\n+            return false;\n+        }\n+        Object minValue = order() == SortOrder.DESC ? rawBottomSortValues[0] : null;\n+        Object maxValue = order() == SortOrder.DESC ? null : rawBottomSortValues[0];\n+        try {\n+            MappedFieldType.Relation relation = fieldType.isFieldWithinQuery(context.getIndexReader(), minValue, maxValue,\n+                true, true, null, DEFAULT_DATE_TIME_FORMATTER.toDateMathParser(), context);\n+            return relation == MappedFieldType.Relation.DISJOINT;\n+        } catch (Exception exc) {\n+            return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2307e73ce5c4500609a22c9bbba6162a9028407b"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc4NTA3MQ==", "bodyText": "++, this should not be needed with the new logic that send the original date math parser. I removed it.", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r389785071", "createdAt": "2020-03-09T15:55:07Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/search/sort/FieldSortBuilder.java", "diffHunk": "@@ -351,6 +352,41 @@ public SortFieldAndFormat build(QueryShardContext context) throws IOException {\n         return new SortFieldAndFormat(field, fieldType.docValueFormat(null, null));\n     }\n \n+    public boolean canRewriteToMatchNone() {\n+        return nestedSort == null && (missing == null || \"_last\".equals(missing));\n+    }\n+\n+    /**\n+     * Returns whether some values of the given {@link QueryShardContext#getIndexReader()} are within the\n+     * primary sort value provided in the <code>rawBottomSortValues</code>.\n+     */\n+    public boolean isBottomSortShardDisjoint(QueryShardContext context, Object[] rawBottomSortValues) {\n+        if (rawBottomSortValues == null || rawBottomSortValues.length == 0) {\n+            return false;\n+        }\n+\n+        if (canRewriteToMatchNone() == false) {\n+            return false;\n+        }\n+        MappedFieldType fieldType = context.fieldMapper(fieldName);\n+        if (fieldType == null) {\n+            // unmapped\n+            return false;\n+        }\n+        if (fieldType.indexOptions() == IndexOptions.NONE) {\n+            return false;\n+        }\n+        Object minValue = order() == SortOrder.DESC ? rawBottomSortValues[0] : null;\n+        Object maxValue = order() == SortOrder.DESC ? null : rawBottomSortValues[0];\n+        try {\n+            MappedFieldType.Relation relation = fieldType.isFieldWithinQuery(context.getIndexReader(), minValue, maxValue,\n+                true, true, null, DEFAULT_DATE_TIME_FORMATTER.toDateMathParser(), context);\n+            return relation == MappedFieldType.Relation.DISJOINT;\n+        } catch (Exception exc) {\n+            return false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg1MzExMw=="}, "originalCommit": {"oid": "2307e73ce5c4500609a22c9bbba6162a9028407b"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwOTI2OTg0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/common/lucene/Lucene.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxMTozMDo1NVrOFy1uhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNTo1NTozMVrOFzum4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg1MzM4MQ==", "bodyText": "why do we need both?", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r388853381", "createdAt": "2020-03-06T11:30:55Z", "author": {"login": "jpountz"}, "path": "server/src/main/java/org/elasticsearch/common/lucene/Lucene.java", "diffHunk": "@@ -111,6 +111,7 @@\n     public static final NamedAnalyzer KEYWORD_ANALYZER = new NamedAnalyzer(\"_keyword\", AnalyzerScope.GLOBAL, new KeywordAnalyzer());\n \n     public static final ScoreDoc[] EMPTY_SCORE_DOCS = new ScoreDoc[0];\n+    public static final ScoreDoc[] EMPTY_FIELD_DOCS = new ScoreDoc[0];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2307e73ce5c4500609a22c9bbba6162a9028407b"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc4NTMxMw==", "bodyText": "we don't, I removed it.", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r389785313", "createdAt": "2020-03-09T15:55:31Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/common/lucene/Lucene.java", "diffHunk": "@@ -111,6 +111,7 @@\n     public static final NamedAnalyzer KEYWORD_ANALYZER = new NamedAnalyzer(\"_keyword\", AnalyzerScope.GLOBAL, new KeywordAnalyzer());\n \n     public static final ScoreDoc[] EMPTY_SCORE_DOCS = new ScoreDoc[0];\n+    public static final ScoreDoc[] EMPTY_FIELD_DOCS = new ScoreDoc[0];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg1MzM4MQ=="}, "originalCommit": {"oid": "2307e73ce5c4500609a22c9bbba6162a9028407b"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNzc5MTIxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/SearchSortValuesAndFormats.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQwODoxMjowNVrOF0EuXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQwODoxMjowNVrOF0EuXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE0NzY3OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            this.formattedSortValues[i] = sortValue;\n          \n          \n            \n                            assert sortValue == null : \"Sort values must be a BytesRef, Long or Double, but got \" + sortValue.getClass() + \": \" + sortValue;\n          \n          \n            \n                            this.formattedSortValues[i] = sortValue;", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r390147679", "createdAt": "2020-03-10T08:12:05Z", "author": {"login": "jpountz"}, "path": "server/src/main/java/org/elasticsearch/search/SearchSortValuesAndFormats.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.search;\n+\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.lucene.Lucene;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+public class SearchSortValuesAndFormats implements Writeable {\n+    private final Object[] rawSortValues;\n+    private final Object[] formattedSortValues;\n+    private final DocValueFormat[] sortValueFormats;\n+\n+    public SearchSortValuesAndFormats(Object[] rawSortValues, DocValueFormat[] sortValueFormats) {\n+        assert rawSortValues.length == sortValueFormats.length;\n+        this.rawSortValues = rawSortValues;\n+        this.sortValueFormats = sortValueFormats;\n+        this.formattedSortValues = Arrays.copyOf(rawSortValues, rawSortValues.length);\n+        for (int i = 0; i < rawSortValues.length; ++i) {\n+            Object sortValue = rawSortValues[i];\n+            if (sortValue instanceof BytesRef) {\n+                this.formattedSortValues[i] = sortValueFormats[i].format((BytesRef) sortValue);\n+            } else if (sortValue instanceof Long) {\n+                this.formattedSortValues[i] = sortValueFormats[i].format((long) sortValue);\n+            } else if (sortValue instanceof Double) {\n+                this.formattedSortValues[i] = sortValueFormats[i].format((double) sortValue);\n+            } else {\n+                this.formattedSortValues[i] = sortValue;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2504e6afb995ebaa428f3d3ebf60b6096b5b241"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNzgzNjYwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/sort/FieldSortBuilder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQwODoyODoyMVrOF0FKGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQwODozOTowMVrOF0FdmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE1NDc3OA==", "bodyText": "is my understanding correct that we need this for the case when a shard is mapped as a date_nanos field while other fields are mapped as date fields?", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r390154778", "createdAt": "2020-03-10T08:28:21Z", "author": {"login": "jpountz"}, "path": "server/src/main/java/org/elasticsearch/search/sort/FieldSortBuilder.java", "diffHunk": "@@ -351,6 +353,49 @@ public SortFieldAndFormat build(QueryShardContext context) throws IOException {\n         return new SortFieldAndFormat(field, fieldType.docValueFormat(null, null));\n     }\n \n+    public boolean canRewriteToMatchNone() {\n+        return nestedSort == null && (missing == null || \"_last\".equals(missing));\n+    }\n+\n+    /**\n+     * Returns whether some values of the given {@link QueryShardContext#getIndexReader()} are within the\n+     * primary sort value provided in the <code>bottomSortValues</code>.\n+     */\n+    public boolean isBottomSortShardDisjoint(QueryShardContext context, SearchSortValuesAndFormats bottomSortValues) throws IOException {\n+        if (bottomSortValues == null || bottomSortValues.getRawSortValues().length == 0) {\n+            return false;\n+        }\n+\n+        if (canRewriteToMatchNone() == false) {\n+            return false;\n+        }\n+        MappedFieldType fieldType = context.fieldMapper(fieldName);\n+        if (fieldType == null) {\n+            // unmapped\n+            return false;\n+        }\n+        if (fieldType.indexOptions() == IndexOptions.NONE) {\n+            return false;\n+        }\n+        DocValueFormat docValueFormat = bottomSortValues.getSortValueFormats()[0];\n+        final DateMathParser dateMathParser;\n+        if (docValueFormat instanceof DocValueFormat.DateTime) {\n+            if (fieldType instanceof DateFieldType && ((DateFieldType) fieldType).resolution() == NANOSECONDS) {\n+                // no matter what\n+                docValueFormat = DocValueFormat.withNanosecondResolution(docValueFormat);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2504e6afb995ebaa428f3d3ebf60b6096b5b241"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE1OTc2OA==", "bodyText": "correct, I fixed the comment ;)", "url": "https://github.com/elastic/elasticsearch/pull/51852#discussion_r390159768", "createdAt": "2020-03-10T08:39:01Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/search/sort/FieldSortBuilder.java", "diffHunk": "@@ -351,6 +353,49 @@ public SortFieldAndFormat build(QueryShardContext context) throws IOException {\n         return new SortFieldAndFormat(field, fieldType.docValueFormat(null, null));\n     }\n \n+    public boolean canRewriteToMatchNone() {\n+        return nestedSort == null && (missing == null || \"_last\".equals(missing));\n+    }\n+\n+    /**\n+     * Returns whether some values of the given {@link QueryShardContext#getIndexReader()} are within the\n+     * primary sort value provided in the <code>bottomSortValues</code>.\n+     */\n+    public boolean isBottomSortShardDisjoint(QueryShardContext context, SearchSortValuesAndFormats bottomSortValues) throws IOException {\n+        if (bottomSortValues == null || bottomSortValues.getRawSortValues().length == 0) {\n+            return false;\n+        }\n+\n+        if (canRewriteToMatchNone() == false) {\n+            return false;\n+        }\n+        MappedFieldType fieldType = context.fieldMapper(fieldName);\n+        if (fieldType == null) {\n+            // unmapped\n+            return false;\n+        }\n+        if (fieldType.indexOptions() == IndexOptions.NONE) {\n+            return false;\n+        }\n+        DocValueFormat docValueFormat = bottomSortValues.getSortValueFormats()[0];\n+        final DateMathParser dateMathParser;\n+        if (docValueFormat instanceof DocValueFormat.DateTime) {\n+            if (fieldType instanceof DateFieldType && ((DateFieldType) fieldType).resolution() == NANOSECONDS) {\n+                // no matter what\n+                docValueFormat = DocValueFormat.withNanosecondResolution(docValueFormat);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE1NDc3OA=="}, "originalCommit": {"oid": "b2504e6afb995ebaa428f3d3ebf60b6096b5b241"}, "originalPosition": 49}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 64, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}