{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkxMDUxNjc2", "number": 53804, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxOToxMzo0MlrODq7xfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwNjoxMzo1N1rOECA4VA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MzQ2MTA5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/mapper/CartesianPoint.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxOToxMzo0M1rOF6_Vig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxOToxMzo0M1rOF6_Vig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM5OTQzNA==", "bodyText": "We should probably make x and y a static ParseField type that can be reused?", "url": "https://github.com/elastic/elasticsearch/pull/53804#discussion_r397399434", "createdAt": "2020-03-24T19:13:43Z", "author": {"login": "nknize"}, "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/mapper/CartesianPoint.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.spatial.index.mapper;\n+\n+import org.elasticsearch.ElasticsearchParseException;\n+import org.elasticsearch.common.xcontent.LoggingDeprecationHandler;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.ToXContentFragment;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentSubParser;\n+import org.elasticsearch.common.xcontent.support.MapXContentParser;\n+import org.elasticsearch.geometry.Geometry;\n+import org.elasticsearch.geometry.ShapeType;\n+import org.elasticsearch.geometry.utils.StandardValidator;\n+import org.elasticsearch.geometry.utils.WellKnownText;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Locale;\n+\n+/**\n+ * Represents a point in the cartesian space.\n+ */\n+public final class CartesianPoint implements ToXContentFragment {\n+\n+    private float x;\n+    private float y;\n+\n+    public CartesianPoint() {\n+    }\n+\n+    public CartesianPoint(float x, float y) {\n+        this.x = x;\n+        this.y = y;\n+    }\n+\n+    public CartesianPoint reset(float x, float y) {\n+        this.x = x;\n+        this.y = y;\n+        return this;\n+    }\n+\n+    public CartesianPoint resetFromString(String value) {\n+        if (value.toLowerCase(Locale.ROOT).contains(\"point\")) {\n+            return resetFromWKT(value);\n+        } else {\n+            return resetFromCoordinates(value);\n+        }\n+    }\n+\n+\n+    public CartesianPoint resetFromCoordinates(String value) {\n+        String[] vals = value.split(\",\");\n+        if (vals.length != 2) {\n+            throw new ElasticsearchParseException(\"failed to parse [{}], expected 2 coordinates \"\n+                + \"but found: [{}]\", vals.length);\n+        }\n+        final float x;\n+        final float y;\n+        try {\n+            x = Float.parseFloat(vals[0].trim());\n+            if (Float.isFinite(x) == false) {\n+                throw new ElasticsearchParseException(\"invalid x value [{}]; \" +\n+                    \"must be between -3.4028234663852886E38 and 3.4028234663852886E38\", x);\n+            }\n+         } catch (NumberFormatException ex) {\n+            throw new ElasticsearchParseException(\"x must be a number\");\n+        }\n+        try {\n+            y = Float.parseFloat(vals[1].trim());\n+            if (Float.isFinite(y) == false) {\n+                throw new ElasticsearchParseException(\"invalid y value [{}]; \" +\n+                    \"must be between -3.4028234663852886E38 and 3.4028234663852886E38\", y);\n+            }\n+        } catch (NumberFormatException ex) {\n+            throw new ElasticsearchParseException(\"y must be a number\");\n+        }\n+        return reset(x, y);\n+    }\n+\n+    private CartesianPoint resetFromWKT(String value) {\n+        Geometry geometry;\n+        try {\n+            geometry = new WellKnownText(false, new StandardValidator(true))\n+                .fromWKT(value);\n+        } catch (Exception e) {\n+            throw new ElasticsearchParseException(\"Invalid WKT format\", e);\n+        }\n+        if (geometry.type() != ShapeType.POINT) {\n+            throw new ElasticsearchParseException(\"[geo_point] supports only POINT among WKT primitives, \" +\n+                \"but found \" + geometry.type());\n+        }\n+        org.elasticsearch.geometry.Point point = (org.elasticsearch.geometry.Point) geometry;\n+        return reset((float) point.getX(), (float) point.getY());\n+    }\n+\n+    public float getX() {\n+        return this.x;\n+    }\n+\n+    public float getY() {\n+        return this.y;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+\n+        CartesianPoint point = (CartesianPoint) o;\n+\n+        if (Float.compare(point.x, x) != 0) return false;\n+        if (Float.compare(point.y, y) != 0) return false;\n+\n+        return true;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int result;\n+        int temp;\n+        temp = x != +0.0f ? Float.floatToIntBits(x) : 0;\n+        result = Integer.hashCode(temp);\n+        temp = y != +0.0f ? Float.floatToIntBits(y) : 0;\n+        result = 31 * result + Integer.hashCode(temp);\n+        return result;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return x + \", \" + y;\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        return builder.startObject().field(\"x\", x).field(\"y\", y).endObject();\n+    }\n+\n+    public static CartesianPoint parsePoint(XContentParser parser, CartesianPoint point)\n+        throws IOException, ElasticsearchParseException {\n+        float x = Float.NaN;\n+        float y = Float.NaN;\n+        NumberFormatException numberFormatException = null;\n+\n+        if(parser.currentToken() == XContentParser.Token.START_OBJECT) {\n+            try (XContentSubParser subParser = new XContentSubParser(parser)) {\n+                while (subParser.nextToken() != XContentParser.Token.END_OBJECT) {\n+                    if (subParser.currentToken() == XContentParser.Token.FIELD_NAME) {\n+                        String field = subParser.currentName();\n+                        if (\"x\".equals(field)) {\n+                            subParser.nextToken();\n+                            switch (subParser.currentToken()) {\n+                                case VALUE_NUMBER:\n+                                case VALUE_STRING:\n+                                    try {\n+                                        x = subParser.floatValue(true);\n+                                    } catch (NumberFormatException e) {\n+                                        numberFormatException = e;\n+                                    }\n+                                    break;\n+                                default:\n+                                    throw new ElasticsearchParseException(\"x must be a number\");\n+                            }\n+                        } else if (\"y\".equals(field)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4d2e0a5a386311fcad8c65016b799f499da343a"}, "originalPosition": 169}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MzQ2NzcyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/mapper/CartesianPoint.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxOToxNTozMlrOF6_Znw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxOToxNTozMlrOF6_Znw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQwMDQ3OQ==", "bodyText": "I know this is largely a mirror of GeoPoint but I'm wondering if we can achieve this using ObjectParser or ConstructingObjectParser? (something we've been meaning to address w/ GeoPoint as well). I'm not sure how that works with the parsing leniency we have on Point and GeoPoint (e.g., array vs comma delimited string).  Curious if @nik9000 or @talevy have some ideas. Maybe that can be done in a followup PR.", "url": "https://github.com/elastic/elasticsearch/pull/53804#discussion_r397400479", "createdAt": "2020-03-24T19:15:32Z", "author": {"login": "nknize"}, "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/mapper/CartesianPoint.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.spatial.index.mapper;\n+\n+import org.elasticsearch.ElasticsearchParseException;\n+import org.elasticsearch.common.xcontent.LoggingDeprecationHandler;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.ToXContentFragment;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentSubParser;\n+import org.elasticsearch.common.xcontent.support.MapXContentParser;\n+import org.elasticsearch.geometry.Geometry;\n+import org.elasticsearch.geometry.ShapeType;\n+import org.elasticsearch.geometry.utils.StandardValidator;\n+import org.elasticsearch.geometry.utils.WellKnownText;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Locale;\n+\n+/**\n+ * Represents a point in the cartesian space.\n+ */\n+public final class CartesianPoint implements ToXContentFragment {\n+\n+    private float x;\n+    private float y;\n+\n+    public CartesianPoint() {\n+    }\n+\n+    public CartesianPoint(float x, float y) {\n+        this.x = x;\n+        this.y = y;\n+    }\n+\n+    public CartesianPoint reset(float x, float y) {\n+        this.x = x;\n+        this.y = y;\n+        return this;\n+    }\n+\n+    public CartesianPoint resetFromString(String value) {\n+        if (value.toLowerCase(Locale.ROOT).contains(\"point\")) {\n+            return resetFromWKT(value);\n+        } else {\n+            return resetFromCoordinates(value);\n+        }\n+    }\n+\n+\n+    public CartesianPoint resetFromCoordinates(String value) {\n+        String[] vals = value.split(\",\");\n+        if (vals.length != 2) {\n+            throw new ElasticsearchParseException(\"failed to parse [{}], expected 2 coordinates \"\n+                + \"but found: [{}]\", vals.length);\n+        }\n+        final float x;\n+        final float y;\n+        try {\n+            x = Float.parseFloat(vals[0].trim());\n+            if (Float.isFinite(x) == false) {\n+                throw new ElasticsearchParseException(\"invalid x value [{}]; \" +\n+                    \"must be between -3.4028234663852886E38 and 3.4028234663852886E38\", x);\n+            }\n+         } catch (NumberFormatException ex) {\n+            throw new ElasticsearchParseException(\"x must be a number\");\n+        }\n+        try {\n+            y = Float.parseFloat(vals[1].trim());\n+            if (Float.isFinite(y) == false) {\n+                throw new ElasticsearchParseException(\"invalid y value [{}]; \" +\n+                    \"must be between -3.4028234663852886E38 and 3.4028234663852886E38\", y);\n+            }\n+        } catch (NumberFormatException ex) {\n+            throw new ElasticsearchParseException(\"y must be a number\");\n+        }\n+        return reset(x, y);\n+    }\n+\n+    private CartesianPoint resetFromWKT(String value) {\n+        Geometry geometry;\n+        try {\n+            geometry = new WellKnownText(false, new StandardValidator(true))\n+                .fromWKT(value);\n+        } catch (Exception e) {\n+            throw new ElasticsearchParseException(\"Invalid WKT format\", e);\n+        }\n+        if (geometry.type() != ShapeType.POINT) {\n+            throw new ElasticsearchParseException(\"[geo_point] supports only POINT among WKT primitives, \" +\n+                \"but found \" + geometry.type());\n+        }\n+        org.elasticsearch.geometry.Point point = (org.elasticsearch.geometry.Point) geometry;\n+        return reset((float) point.getX(), (float) point.getY());\n+    }\n+\n+    public float getX() {\n+        return this.x;\n+    }\n+\n+    public float getY() {\n+        return this.y;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+\n+        CartesianPoint point = (CartesianPoint) o;\n+\n+        if (Float.compare(point.x, x) != 0) return false;\n+        if (Float.compare(point.y, y) != 0) return false;\n+\n+        return true;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int result;\n+        int temp;\n+        temp = x != +0.0f ? Float.floatToIntBits(x) : 0;\n+        result = Integer.hashCode(temp);\n+        temp = y != +0.0f ? Float.floatToIntBits(y) : 0;\n+        result = 31 * result + Integer.hashCode(temp);\n+        return result;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return x + \", \" + y;\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        return builder.startObject().field(\"x\", x).field(\"y\", y).endObject();\n+    }\n+\n+    public static CartesianPoint parsePoint(XContentParser parser, CartesianPoint point)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4d2e0a5a386311fcad8c65016b799f499da343a"}, "originalPosition": 144}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MzQ5NjQ2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/mapper/PointFieldMapper.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxOToyMzo1NFrOF6_rpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxMDo0MDoyOVrOF9ju6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQwNTA5NA==", "bodyText": "I'm good with this as is for this PR, but we will likely want to consider adding Z values to points like we do for GeoPoint. This way users can add a third dimension to source only. Future PR is fine; at which time we may want to consider sharing code by deriving from GeoPointFieldMapper.TypeParser.", "url": "https://github.com/elastic/elasticsearch/pull/53804#discussion_r397405094", "createdAt": "2020-03-24T19:23:54Z", "author": {"login": "nknize"}, "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/mapper/PointFieldMapper.java", "diffHunk": "@@ -0,0 +1,323 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.spatial.index.mapper;\n+\n+import org.apache.lucene.document.StoredField;\n+import org.apache.lucene.document.XYDocValuesField;\n+import org.apache.lucene.document.XYPointField;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.DocValuesFieldExistsQuery;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.TermQuery;\n+import org.elasticsearch.ElasticsearchParseException;\n+import org.elasticsearch.common.Explicit;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.support.XContentMapValues;\n+import org.elasticsearch.index.mapper.AbstractSearchableGeometryFieldType;\n+import org.elasticsearch.index.mapper.ArrayValueMapperParser;\n+import org.elasticsearch.index.mapper.FieldMapper;\n+import org.elasticsearch.index.mapper.FieldNamesFieldMapper;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+import org.elasticsearch.index.mapper.Mapper;\n+import org.elasticsearch.index.mapper.MapperParsingException;\n+import org.elasticsearch.index.mapper.ParseContext;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.index.query.QueryShardException;\n+import org.elasticsearch.search.aggregations.support.CoreValuesSourceType;\n+import org.elasticsearch.search.aggregations.support.ValuesSourceType;\n+import org.elasticsearch.xpack.spatial.index.query.ShapeQueryPointProcessor;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.elasticsearch.index.mapper.TypeParsers.parseField;\n+\n+\n+/**\n+ * Field Mapper for point type.\n+ *\n+ * Uses lucene 8 XYPoint encoding\n+ */\n+public class PointFieldMapper extends FieldMapper implements ArrayValueMapperParser {\n+    public static final String CONTENT_TYPE = \"point\";\n+\n+    public static class Names {\n+        public static final String IGNORE_MALFORMED = \"ignore_malformed\";\n+        public static final String NULL_VALUE = \"null_value\";\n+    }\n+\n+    public static class Defaults {\n+        public static final Explicit<Boolean> IGNORE_MALFORMED = new Explicit<>(false, false);\n+        public static final PointFieldType FIELD_TYPE = new PointFieldType();\n+\n+        static {\n+            FIELD_TYPE.setTokenized(false);\n+            FIELD_TYPE.setHasDocValues(true);\n+            FIELD_TYPE.setDimensions(2, Integer.BYTES);\n+            FIELD_TYPE.freeze();\n+        }\n+    }\n+\n+    public static class Builder extends FieldMapper.Builder<Builder, PointFieldMapper> {\n+        protected Boolean ignoreMalformed;\n+\n+        public Builder(String name) {\n+            super(name, Defaults.FIELD_TYPE, Defaults.FIELD_TYPE);\n+            builder = this;\n+        }\n+\n+        public Builder ignoreMalformed(boolean ignoreMalformed) {\n+            this.ignoreMalformed = ignoreMalformed;\n+            return builder;\n+        }\n+\n+        protected Explicit<Boolean> ignoreMalformed(BuilderContext context) {\n+            if (ignoreMalformed != null) {\n+                return new Explicit<>(ignoreMalformed, true);\n+            }\n+            if (context.indexSettings() != null) {\n+                return new Explicit<>(IGNORE_MALFORMED_SETTING.get(context.indexSettings()), false);\n+            }\n+            return PointFieldMapper.Defaults.IGNORE_MALFORMED;\n+        }\n+\n+        public PointFieldMapper build(BuilderContext context, String simpleName, MappedFieldType fieldType,\n+                                      MappedFieldType defaultFieldType, Settings indexSettings,\n+                                      MultiFields multiFields, Explicit<Boolean> ignoreMalformed,\n+                                      CopyTo copyTo) {\n+            setupFieldType(context);\n+            return new PointFieldMapper(simpleName, fieldType, defaultFieldType, indexSettings, multiFields,\n+                ignoreMalformed, copyTo);\n+        }\n+\n+        @Override\n+        public PointFieldType fieldType() {\n+            return (PointFieldType)fieldType;\n+        }\n+\n+        @Override\n+        public PointFieldMapper build(BuilderContext context) {\n+            return build(context, name, fieldType, defaultFieldType, context.indexSettings(),\n+                multiFieldsBuilder.build(this, context), ignoreMalformed(context), copyTo);\n+        }\n+\n+        @Override\n+        protected void setupFieldType(BuilderContext context) {\n+            super.setupFieldType(context);\n+\n+            fieldType().setGeometryQueryBuilder(new ShapeQueryPointProcessor());\n+        }\n+    }\n+\n+    public static class TypeParser implements Mapper.TypeParser {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4d2e0a5a386311fcad8c65016b799f499da343a"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDA5MjkwNQ==", "bodyText": "I agree to keep consistent with Shape field", "url": "https://github.com/elastic/elasticsearch/pull/53804#discussion_r400092905", "createdAt": "2020-03-30T10:40:29Z", "author": {"login": "iverase"}, "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/mapper/PointFieldMapper.java", "diffHunk": "@@ -0,0 +1,323 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.spatial.index.mapper;\n+\n+import org.apache.lucene.document.StoredField;\n+import org.apache.lucene.document.XYDocValuesField;\n+import org.apache.lucene.document.XYPointField;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.DocValuesFieldExistsQuery;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.TermQuery;\n+import org.elasticsearch.ElasticsearchParseException;\n+import org.elasticsearch.common.Explicit;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.support.XContentMapValues;\n+import org.elasticsearch.index.mapper.AbstractSearchableGeometryFieldType;\n+import org.elasticsearch.index.mapper.ArrayValueMapperParser;\n+import org.elasticsearch.index.mapper.FieldMapper;\n+import org.elasticsearch.index.mapper.FieldNamesFieldMapper;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+import org.elasticsearch.index.mapper.Mapper;\n+import org.elasticsearch.index.mapper.MapperParsingException;\n+import org.elasticsearch.index.mapper.ParseContext;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.index.query.QueryShardException;\n+import org.elasticsearch.search.aggregations.support.CoreValuesSourceType;\n+import org.elasticsearch.search.aggregations.support.ValuesSourceType;\n+import org.elasticsearch.xpack.spatial.index.query.ShapeQueryPointProcessor;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.elasticsearch.index.mapper.TypeParsers.parseField;\n+\n+\n+/**\n+ * Field Mapper for point type.\n+ *\n+ * Uses lucene 8 XYPoint encoding\n+ */\n+public class PointFieldMapper extends FieldMapper implements ArrayValueMapperParser {\n+    public static final String CONTENT_TYPE = \"point\";\n+\n+    public static class Names {\n+        public static final String IGNORE_MALFORMED = \"ignore_malformed\";\n+        public static final String NULL_VALUE = \"null_value\";\n+    }\n+\n+    public static class Defaults {\n+        public static final Explicit<Boolean> IGNORE_MALFORMED = new Explicit<>(false, false);\n+        public static final PointFieldType FIELD_TYPE = new PointFieldType();\n+\n+        static {\n+            FIELD_TYPE.setTokenized(false);\n+            FIELD_TYPE.setHasDocValues(true);\n+            FIELD_TYPE.setDimensions(2, Integer.BYTES);\n+            FIELD_TYPE.freeze();\n+        }\n+    }\n+\n+    public static class Builder extends FieldMapper.Builder<Builder, PointFieldMapper> {\n+        protected Boolean ignoreMalformed;\n+\n+        public Builder(String name) {\n+            super(name, Defaults.FIELD_TYPE, Defaults.FIELD_TYPE);\n+            builder = this;\n+        }\n+\n+        public Builder ignoreMalformed(boolean ignoreMalformed) {\n+            this.ignoreMalformed = ignoreMalformed;\n+            return builder;\n+        }\n+\n+        protected Explicit<Boolean> ignoreMalformed(BuilderContext context) {\n+            if (ignoreMalformed != null) {\n+                return new Explicit<>(ignoreMalformed, true);\n+            }\n+            if (context.indexSettings() != null) {\n+                return new Explicit<>(IGNORE_MALFORMED_SETTING.get(context.indexSettings()), false);\n+            }\n+            return PointFieldMapper.Defaults.IGNORE_MALFORMED;\n+        }\n+\n+        public PointFieldMapper build(BuilderContext context, String simpleName, MappedFieldType fieldType,\n+                                      MappedFieldType defaultFieldType, Settings indexSettings,\n+                                      MultiFields multiFields, Explicit<Boolean> ignoreMalformed,\n+                                      CopyTo copyTo) {\n+            setupFieldType(context);\n+            return new PointFieldMapper(simpleName, fieldType, defaultFieldType, indexSettings, multiFields,\n+                ignoreMalformed, copyTo);\n+        }\n+\n+        @Override\n+        public PointFieldType fieldType() {\n+            return (PointFieldType)fieldType;\n+        }\n+\n+        @Override\n+        public PointFieldMapper build(BuilderContext context) {\n+            return build(context, name, fieldType, defaultFieldType, context.indexSettings(),\n+                multiFieldsBuilder.build(this, context), ignoreMalformed(context), copyTo);\n+        }\n+\n+        @Override\n+        protected void setupFieldType(BuilderContext context) {\n+            super.setupFieldType(context);\n+\n+            fieldType().setGeometryQueryBuilder(new ShapeQueryPointProcessor());\n+        }\n+    }\n+\n+    public static class TypeParser implements Mapper.TypeParser {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQwNTA5NA=="}, "originalCommit": {"oid": "d4d2e0a5a386311fcad8c65016b799f499da343a"}, "originalPosition": 122}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MzUwMDIyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/mapper/PointFieldMapper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxOToyNTowM1rOF6_uGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxOToyNTowM1rOF6_uGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQwNTcyMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Parses point represented as an object or an array, ignores malformed geopoints if needed\n          \n          \n            \n                 * Parses point represented as an object or an array, ignores malformed points if needed", "url": "https://github.com/elastic/elasticsearch/pull/53804#discussion_r397405720", "createdAt": "2020-03-24T19:25:03Z", "author": {"login": "nknize"}, "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/mapper/PointFieldMapper.java", "diffHunk": "@@ -0,0 +1,323 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.spatial.index.mapper;\n+\n+import org.apache.lucene.document.StoredField;\n+import org.apache.lucene.document.XYDocValuesField;\n+import org.apache.lucene.document.XYPointField;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.DocValuesFieldExistsQuery;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.TermQuery;\n+import org.elasticsearch.ElasticsearchParseException;\n+import org.elasticsearch.common.Explicit;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.support.XContentMapValues;\n+import org.elasticsearch.index.mapper.AbstractSearchableGeometryFieldType;\n+import org.elasticsearch.index.mapper.ArrayValueMapperParser;\n+import org.elasticsearch.index.mapper.FieldMapper;\n+import org.elasticsearch.index.mapper.FieldNamesFieldMapper;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+import org.elasticsearch.index.mapper.Mapper;\n+import org.elasticsearch.index.mapper.MapperParsingException;\n+import org.elasticsearch.index.mapper.ParseContext;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.index.query.QueryShardException;\n+import org.elasticsearch.search.aggregations.support.CoreValuesSourceType;\n+import org.elasticsearch.search.aggregations.support.ValuesSourceType;\n+import org.elasticsearch.xpack.spatial.index.query.ShapeQueryPointProcessor;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.elasticsearch.index.mapper.TypeParsers.parseField;\n+\n+\n+/**\n+ * Field Mapper for point type.\n+ *\n+ * Uses lucene 8 XYPoint encoding\n+ */\n+public class PointFieldMapper extends FieldMapper implements ArrayValueMapperParser {\n+    public static final String CONTENT_TYPE = \"point\";\n+\n+    public static class Names {\n+        public static final String IGNORE_MALFORMED = \"ignore_malformed\";\n+        public static final String NULL_VALUE = \"null_value\";\n+    }\n+\n+    public static class Defaults {\n+        public static final Explicit<Boolean> IGNORE_MALFORMED = new Explicit<>(false, false);\n+        public static final PointFieldType FIELD_TYPE = new PointFieldType();\n+\n+        static {\n+            FIELD_TYPE.setTokenized(false);\n+            FIELD_TYPE.setHasDocValues(true);\n+            FIELD_TYPE.setDimensions(2, Integer.BYTES);\n+            FIELD_TYPE.freeze();\n+        }\n+    }\n+\n+    public static class Builder extends FieldMapper.Builder<Builder, PointFieldMapper> {\n+        protected Boolean ignoreMalformed;\n+\n+        public Builder(String name) {\n+            super(name, Defaults.FIELD_TYPE, Defaults.FIELD_TYPE);\n+            builder = this;\n+        }\n+\n+        public Builder ignoreMalformed(boolean ignoreMalformed) {\n+            this.ignoreMalformed = ignoreMalformed;\n+            return builder;\n+        }\n+\n+        protected Explicit<Boolean> ignoreMalformed(BuilderContext context) {\n+            if (ignoreMalformed != null) {\n+                return new Explicit<>(ignoreMalformed, true);\n+            }\n+            if (context.indexSettings() != null) {\n+                return new Explicit<>(IGNORE_MALFORMED_SETTING.get(context.indexSettings()), false);\n+            }\n+            return PointFieldMapper.Defaults.IGNORE_MALFORMED;\n+        }\n+\n+        public PointFieldMapper build(BuilderContext context, String simpleName, MappedFieldType fieldType,\n+                                      MappedFieldType defaultFieldType, Settings indexSettings,\n+                                      MultiFields multiFields, Explicit<Boolean> ignoreMalformed,\n+                                      CopyTo copyTo) {\n+            setupFieldType(context);\n+            return new PointFieldMapper(simpleName, fieldType, defaultFieldType, indexSettings, multiFields,\n+                ignoreMalformed, copyTo);\n+        }\n+\n+        @Override\n+        public PointFieldType fieldType() {\n+            return (PointFieldType)fieldType;\n+        }\n+\n+        @Override\n+        public PointFieldMapper build(BuilderContext context) {\n+            return build(context, name, fieldType, defaultFieldType, context.indexSettings(),\n+                multiFieldsBuilder.build(this, context), ignoreMalformed(context), copyTo);\n+        }\n+\n+        @Override\n+        protected void setupFieldType(BuilderContext context) {\n+            super.setupFieldType(context);\n+\n+            fieldType().setGeometryQueryBuilder(new ShapeQueryPointProcessor());\n+        }\n+    }\n+\n+    public static class TypeParser implements Mapper.TypeParser {\n+        @Override\n+        @SuppressWarnings(\"rawtypes\")\n+        public Mapper.Builder parse(String name, Map<String, Object> node, ParserContext parserContext)\n+                throws MapperParsingException {\n+            Builder builder = new PointFieldMapper.Builder(name);\n+            parseField(builder, name, node, parserContext);\n+            Object nullValue = null;\n+            for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(); iterator.hasNext();) {\n+                Map.Entry<String, Object> entry = iterator.next();\n+                String propName = entry.getKey();\n+                Object propNode = entry.getValue();\n+\n+                if (propName.equals(Names.IGNORE_MALFORMED)) {\n+                    builder.ignoreMalformed(XContentMapValues.nodeBooleanValue(propNode, name + \".\" + Names.IGNORE_MALFORMED));\n+                    iterator.remove();\n+                } else if (propName.equals(Names.NULL_VALUE)) {\n+                    if (propNode == null) {\n+                        throw new MapperParsingException(\"Property [null_value] cannot be null.\");\n+                    }\n+                    nullValue = propNode;\n+                    iterator.remove();\n+                }\n+            }\n+\n+            if (nullValue != null) {\n+                boolean ignoreMalformed = builder.ignoreMalformed == null ? Defaults.IGNORE_MALFORMED.value() : builder.ignoreMalformed;\n+                CartesianPoint point = CartesianPoint.parsePoint(nullValue);\n+                if (ignoreMalformed == false) {\n+                    if (Float.isFinite(point.getX()) == false) {\n+                        throw new IllegalArgumentException(\"illegal x value [\" + point.getX() + \"]\");\n+                    }\n+                    if (Float.isFinite(point.getY()) == false) {\n+                        throw new IllegalArgumentException(\"illegal y value [\" + point.getY() + \"]\");\n+                    }\n+                }\n+                builder.nullValue(point);\n+            }\n+            return builder;\n+        }\n+    }\n+\n+    protected Explicit<Boolean> ignoreMalformed;\n+\n+    public PointFieldMapper(String simpleName, MappedFieldType fieldType, MappedFieldType defaultFieldType,\n+                            Settings indexSettings, MultiFields multiFields, Explicit<Boolean> ignoreMalformed,\n+                            CopyTo copyTo) {\n+        super(simpleName, fieldType, defaultFieldType, indexSettings, multiFields, copyTo);\n+        this.ignoreMalformed = ignoreMalformed;\n+    }\n+\n+    @Override\n+    protected void doMerge(Mapper mergeWith) {\n+        super.doMerge(mergeWith);\n+        PointFieldMapper gpfmMergeWith = (PointFieldMapper) mergeWith;\n+        if (gpfmMergeWith.ignoreMalformed.explicit()) {\n+            this.ignoreMalformed = gpfmMergeWith.ignoreMalformed;\n+        }\n+    }\n+\n+    @Override\n+    protected String contentType() {\n+        return CONTENT_TYPE;\n+    }\n+\n+    @Override\n+    protected void parseCreateField(ParseContext context, List<IndexableField> fields) throws IOException {\n+        throw new UnsupportedOperationException(\"Parsing is implemented in parse(), this method should NEVER be called\");\n+    }\n+\n+    public static class PointFieldType extends AbstractSearchableGeometryFieldType {\n+        public PointFieldType() {\n+        }\n+\n+        PointFieldType(PointFieldType ref) {\n+            super(ref);\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return CONTENT_TYPE;\n+        }\n+\n+        @Override\n+        public MappedFieldType clone() {\n+            return new PointFieldType(this);\n+        }\n+\n+        @Override\n+        public ValuesSourceType getValuesSourceType() {\n+            return CoreValuesSourceType.GEOPOINT;\n+        }\n+\n+        @Override\n+        public Query existsQuery(QueryShardContext context) {\n+            if (hasDocValues()) {\n+                return new DocValuesFieldExistsQuery(name());\n+            } else {\n+                return new TermQuery(new Term(FieldNamesFieldMapper.NAME, name()));\n+            }\n+        }\n+\n+        @Override\n+        public Query termQuery(Object value, QueryShardContext context) {\n+            throw new QueryShardException(context, \"Geo fields do not support exact searching, use dedicated geo queries instead: [\"\n+                + name() + \"]\");\n+        }\n+    }\n+\n+    protected void parse(ParseContext context, CartesianPoint point) throws IOException {\n+\n+        if (fieldType().indexOptions() != IndexOptions.NONE) {\n+            context.doc().add(new XYPointField(fieldType().name(), point.getX(), point.getY()));\n+        }\n+        if (fieldType().stored()) {\n+            context.doc().add(new StoredField(fieldType().name(), point.toString()));\n+        }\n+        if (fieldType.hasDocValues()) {\n+            context.doc().add(new XYDocValuesField(fieldType().name(), point.getX(), point.getY()));\n+        } else if (fieldType().stored() || fieldType().indexOptions() != IndexOptions.NONE) {\n+            List<IndexableField> fields = new ArrayList<>(1);\n+            createFieldNamesField(context, fields);\n+            for (IndexableField field : fields) {\n+                context.doc().add(field);\n+            }\n+        }\n+        // if the mapping contains multi-fields then throw an error?\n+        if (multiFields.iterator().hasNext()) {\n+            throw new ElasticsearchParseException(\"[{}] field type does not accept multi-fields\", CONTENT_TYPE);\n+        }\n+    }\n+\n+    @Override\n+    public void parse(ParseContext context) throws IOException {\n+        context.path().add(simpleName());\n+\n+        try {\n+            CartesianPoint sparse = context.parseExternalValue(CartesianPoint.class);\n+\n+            if (sparse != null) {\n+                parse(context, sparse);\n+            } else {\n+                sparse = new CartesianPoint();\n+                XContentParser.Token token = context.parser().currentToken();\n+                if (token == XContentParser.Token.START_ARRAY) {\n+                    token = context.parser().nextToken();\n+                    if (token == XContentParser.Token.VALUE_NUMBER) {\n+                        float x = context.parser().floatValue();\n+                        context.parser().nextToken();\n+                        float y = context.parser().floatValue();\n+                        token = context.parser().nextToken();\n+                        if (token != XContentParser.Token.END_ARRAY) {\n+                            throw new ElasticsearchParseException(\"[{}] field type does not accept > 2 dimensions\", CONTENT_TYPE);\n+                        }\n+                        parse(context, sparse.reset(x, y));\n+                    } else {\n+                        while (token != XContentParser.Token.END_ARRAY) {\n+                            parsePointIgnoringMalformed(context, sparse);\n+                            token = context.parser().nextToken();\n+                        }\n+                    }\n+                } else if (token == XContentParser.Token.VALUE_NULL) {\n+                    if (fieldType.nullValue() != null) {\n+                        parse(context, (CartesianPoint) fieldType.nullValue());\n+                    }\n+                } else {\n+                    parsePointIgnoringMalformed(context, sparse);\n+                }\n+            }\n+        } catch (Exception ex) {\n+            throw new MapperParsingException(\"failed to parse field [{}] of type [{}]\", ex, fieldType().name(), fieldType().typeName());\n+        }\n+\n+        context.path().remove();\n+    }\n+\n+    /**\n+     * Parses point represented as an object or an array, ignores malformed geopoints if needed", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4d2e0a5a386311fcad8c65016b799f499da343a"}, "originalPosition": 299}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MzUwOTgzOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/mapper/PointFieldMapper.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxOToyNzo1N1rOF6_z8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxMDo0MDoxNVrOF7VJZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQwNzIxOQ==", "bodyText": "This feels trappy. I think we need to add a new ValuesSourceType.POINT so users can't run geo_ aggregations on cartesian types? /cc @not-napoleon  Probably best to remove doc value support from this PR and add it as a separate feature PR.", "url": "https://github.com/elastic/elasticsearch/pull/53804#discussion_r397407219", "createdAt": "2020-03-24T19:27:57Z", "author": {"login": "nknize"}, "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/mapper/PointFieldMapper.java", "diffHunk": "@@ -0,0 +1,323 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.spatial.index.mapper;\n+\n+import org.apache.lucene.document.StoredField;\n+import org.apache.lucene.document.XYDocValuesField;\n+import org.apache.lucene.document.XYPointField;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.DocValuesFieldExistsQuery;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.TermQuery;\n+import org.elasticsearch.ElasticsearchParseException;\n+import org.elasticsearch.common.Explicit;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.support.XContentMapValues;\n+import org.elasticsearch.index.mapper.AbstractSearchableGeometryFieldType;\n+import org.elasticsearch.index.mapper.ArrayValueMapperParser;\n+import org.elasticsearch.index.mapper.FieldMapper;\n+import org.elasticsearch.index.mapper.FieldNamesFieldMapper;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+import org.elasticsearch.index.mapper.Mapper;\n+import org.elasticsearch.index.mapper.MapperParsingException;\n+import org.elasticsearch.index.mapper.ParseContext;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.index.query.QueryShardException;\n+import org.elasticsearch.search.aggregations.support.CoreValuesSourceType;\n+import org.elasticsearch.search.aggregations.support.ValuesSourceType;\n+import org.elasticsearch.xpack.spatial.index.query.ShapeQueryPointProcessor;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.elasticsearch.index.mapper.TypeParsers.parseField;\n+\n+\n+/**\n+ * Field Mapper for point type.\n+ *\n+ * Uses lucene 8 XYPoint encoding\n+ */\n+public class PointFieldMapper extends FieldMapper implements ArrayValueMapperParser {\n+    public static final String CONTENT_TYPE = \"point\";\n+\n+    public static class Names {\n+        public static final String IGNORE_MALFORMED = \"ignore_malformed\";\n+        public static final String NULL_VALUE = \"null_value\";\n+    }\n+\n+    public static class Defaults {\n+        public static final Explicit<Boolean> IGNORE_MALFORMED = new Explicit<>(false, false);\n+        public static final PointFieldType FIELD_TYPE = new PointFieldType();\n+\n+        static {\n+            FIELD_TYPE.setTokenized(false);\n+            FIELD_TYPE.setHasDocValues(true);\n+            FIELD_TYPE.setDimensions(2, Integer.BYTES);\n+            FIELD_TYPE.freeze();\n+        }\n+    }\n+\n+    public static class Builder extends FieldMapper.Builder<Builder, PointFieldMapper> {\n+        protected Boolean ignoreMalformed;\n+\n+        public Builder(String name) {\n+            super(name, Defaults.FIELD_TYPE, Defaults.FIELD_TYPE);\n+            builder = this;\n+        }\n+\n+        public Builder ignoreMalformed(boolean ignoreMalformed) {\n+            this.ignoreMalformed = ignoreMalformed;\n+            return builder;\n+        }\n+\n+        protected Explicit<Boolean> ignoreMalformed(BuilderContext context) {\n+            if (ignoreMalformed != null) {\n+                return new Explicit<>(ignoreMalformed, true);\n+            }\n+            if (context.indexSettings() != null) {\n+                return new Explicit<>(IGNORE_MALFORMED_SETTING.get(context.indexSettings()), false);\n+            }\n+            return PointFieldMapper.Defaults.IGNORE_MALFORMED;\n+        }\n+\n+        public PointFieldMapper build(BuilderContext context, String simpleName, MappedFieldType fieldType,\n+                                      MappedFieldType defaultFieldType, Settings indexSettings,\n+                                      MultiFields multiFields, Explicit<Boolean> ignoreMalformed,\n+                                      CopyTo copyTo) {\n+            setupFieldType(context);\n+            return new PointFieldMapper(simpleName, fieldType, defaultFieldType, indexSettings, multiFields,\n+                ignoreMalformed, copyTo);\n+        }\n+\n+        @Override\n+        public PointFieldType fieldType() {\n+            return (PointFieldType)fieldType;\n+        }\n+\n+        @Override\n+        public PointFieldMapper build(BuilderContext context) {\n+            return build(context, name, fieldType, defaultFieldType, context.indexSettings(),\n+                multiFieldsBuilder.build(this, context), ignoreMalformed(context), copyTo);\n+        }\n+\n+        @Override\n+        protected void setupFieldType(BuilderContext context) {\n+            super.setupFieldType(context);\n+\n+            fieldType().setGeometryQueryBuilder(new ShapeQueryPointProcessor());\n+        }\n+    }\n+\n+    public static class TypeParser implements Mapper.TypeParser {\n+        @Override\n+        @SuppressWarnings(\"rawtypes\")\n+        public Mapper.Builder parse(String name, Map<String, Object> node, ParserContext parserContext)\n+                throws MapperParsingException {\n+            Builder builder = new PointFieldMapper.Builder(name);\n+            parseField(builder, name, node, parserContext);\n+            Object nullValue = null;\n+            for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(); iterator.hasNext();) {\n+                Map.Entry<String, Object> entry = iterator.next();\n+                String propName = entry.getKey();\n+                Object propNode = entry.getValue();\n+\n+                if (propName.equals(Names.IGNORE_MALFORMED)) {\n+                    builder.ignoreMalformed(XContentMapValues.nodeBooleanValue(propNode, name + \".\" + Names.IGNORE_MALFORMED));\n+                    iterator.remove();\n+                } else if (propName.equals(Names.NULL_VALUE)) {\n+                    if (propNode == null) {\n+                        throw new MapperParsingException(\"Property [null_value] cannot be null.\");\n+                    }\n+                    nullValue = propNode;\n+                    iterator.remove();\n+                }\n+            }\n+\n+            if (nullValue != null) {\n+                boolean ignoreMalformed = builder.ignoreMalformed == null ? Defaults.IGNORE_MALFORMED.value() : builder.ignoreMalformed;\n+                CartesianPoint point = CartesianPoint.parsePoint(nullValue);\n+                if (ignoreMalformed == false) {\n+                    if (Float.isFinite(point.getX()) == false) {\n+                        throw new IllegalArgumentException(\"illegal x value [\" + point.getX() + \"]\");\n+                    }\n+                    if (Float.isFinite(point.getY()) == false) {\n+                        throw new IllegalArgumentException(\"illegal y value [\" + point.getY() + \"]\");\n+                    }\n+                }\n+                builder.nullValue(point);\n+            }\n+            return builder;\n+        }\n+    }\n+\n+    protected Explicit<Boolean> ignoreMalformed;\n+\n+    public PointFieldMapper(String simpleName, MappedFieldType fieldType, MappedFieldType defaultFieldType,\n+                            Settings indexSettings, MultiFields multiFields, Explicit<Boolean> ignoreMalformed,\n+                            CopyTo copyTo) {\n+        super(simpleName, fieldType, defaultFieldType, indexSettings, multiFields, copyTo);\n+        this.ignoreMalformed = ignoreMalformed;\n+    }\n+\n+    @Override\n+    protected void doMerge(Mapper mergeWith) {\n+        super.doMerge(mergeWith);\n+        PointFieldMapper gpfmMergeWith = (PointFieldMapper) mergeWith;\n+        if (gpfmMergeWith.ignoreMalformed.explicit()) {\n+            this.ignoreMalformed = gpfmMergeWith.ignoreMalformed;\n+        }\n+    }\n+\n+    @Override\n+    protected String contentType() {\n+        return CONTENT_TYPE;\n+    }\n+\n+    @Override\n+    protected void parseCreateField(ParseContext context, List<IndexableField> fields) throws IOException {\n+        throw new UnsupportedOperationException(\"Parsing is implemented in parse(), this method should NEVER be called\");\n+    }\n+\n+    public static class PointFieldType extends AbstractSearchableGeometryFieldType {\n+        public PointFieldType() {\n+        }\n+\n+        PointFieldType(PointFieldType ref) {\n+            super(ref);\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return CONTENT_TYPE;\n+        }\n+\n+        @Override\n+        public MappedFieldType clone() {\n+            return new PointFieldType(this);\n+        }\n+\n+        @Override\n+        public ValuesSourceType getValuesSourceType() {\n+            return CoreValuesSourceType.GEOPOINT;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4d2e0a5a386311fcad8c65016b799f499da343a"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzc1Njc3Mw==", "bodyText": "That should not be there. I have removed the method so it fall back to the default implementation that throws a meaningful error.", "url": "https://github.com/elastic/elasticsearch/pull/53804#discussion_r397756773", "createdAt": "2020-03-25T10:40:15Z", "author": {"login": "iverase"}, "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/mapper/PointFieldMapper.java", "diffHunk": "@@ -0,0 +1,323 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.spatial.index.mapper;\n+\n+import org.apache.lucene.document.StoredField;\n+import org.apache.lucene.document.XYDocValuesField;\n+import org.apache.lucene.document.XYPointField;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.DocValuesFieldExistsQuery;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.TermQuery;\n+import org.elasticsearch.ElasticsearchParseException;\n+import org.elasticsearch.common.Explicit;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.support.XContentMapValues;\n+import org.elasticsearch.index.mapper.AbstractSearchableGeometryFieldType;\n+import org.elasticsearch.index.mapper.ArrayValueMapperParser;\n+import org.elasticsearch.index.mapper.FieldMapper;\n+import org.elasticsearch.index.mapper.FieldNamesFieldMapper;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+import org.elasticsearch.index.mapper.Mapper;\n+import org.elasticsearch.index.mapper.MapperParsingException;\n+import org.elasticsearch.index.mapper.ParseContext;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.index.query.QueryShardException;\n+import org.elasticsearch.search.aggregations.support.CoreValuesSourceType;\n+import org.elasticsearch.search.aggregations.support.ValuesSourceType;\n+import org.elasticsearch.xpack.spatial.index.query.ShapeQueryPointProcessor;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.elasticsearch.index.mapper.TypeParsers.parseField;\n+\n+\n+/**\n+ * Field Mapper for point type.\n+ *\n+ * Uses lucene 8 XYPoint encoding\n+ */\n+public class PointFieldMapper extends FieldMapper implements ArrayValueMapperParser {\n+    public static final String CONTENT_TYPE = \"point\";\n+\n+    public static class Names {\n+        public static final String IGNORE_MALFORMED = \"ignore_malformed\";\n+        public static final String NULL_VALUE = \"null_value\";\n+    }\n+\n+    public static class Defaults {\n+        public static final Explicit<Boolean> IGNORE_MALFORMED = new Explicit<>(false, false);\n+        public static final PointFieldType FIELD_TYPE = new PointFieldType();\n+\n+        static {\n+            FIELD_TYPE.setTokenized(false);\n+            FIELD_TYPE.setHasDocValues(true);\n+            FIELD_TYPE.setDimensions(2, Integer.BYTES);\n+            FIELD_TYPE.freeze();\n+        }\n+    }\n+\n+    public static class Builder extends FieldMapper.Builder<Builder, PointFieldMapper> {\n+        protected Boolean ignoreMalformed;\n+\n+        public Builder(String name) {\n+            super(name, Defaults.FIELD_TYPE, Defaults.FIELD_TYPE);\n+            builder = this;\n+        }\n+\n+        public Builder ignoreMalformed(boolean ignoreMalformed) {\n+            this.ignoreMalformed = ignoreMalformed;\n+            return builder;\n+        }\n+\n+        protected Explicit<Boolean> ignoreMalformed(BuilderContext context) {\n+            if (ignoreMalformed != null) {\n+                return new Explicit<>(ignoreMalformed, true);\n+            }\n+            if (context.indexSettings() != null) {\n+                return new Explicit<>(IGNORE_MALFORMED_SETTING.get(context.indexSettings()), false);\n+            }\n+            return PointFieldMapper.Defaults.IGNORE_MALFORMED;\n+        }\n+\n+        public PointFieldMapper build(BuilderContext context, String simpleName, MappedFieldType fieldType,\n+                                      MappedFieldType defaultFieldType, Settings indexSettings,\n+                                      MultiFields multiFields, Explicit<Boolean> ignoreMalformed,\n+                                      CopyTo copyTo) {\n+            setupFieldType(context);\n+            return new PointFieldMapper(simpleName, fieldType, defaultFieldType, indexSettings, multiFields,\n+                ignoreMalformed, copyTo);\n+        }\n+\n+        @Override\n+        public PointFieldType fieldType() {\n+            return (PointFieldType)fieldType;\n+        }\n+\n+        @Override\n+        public PointFieldMapper build(BuilderContext context) {\n+            return build(context, name, fieldType, defaultFieldType, context.indexSettings(),\n+                multiFieldsBuilder.build(this, context), ignoreMalformed(context), copyTo);\n+        }\n+\n+        @Override\n+        protected void setupFieldType(BuilderContext context) {\n+            super.setupFieldType(context);\n+\n+            fieldType().setGeometryQueryBuilder(new ShapeQueryPointProcessor());\n+        }\n+    }\n+\n+    public static class TypeParser implements Mapper.TypeParser {\n+        @Override\n+        @SuppressWarnings(\"rawtypes\")\n+        public Mapper.Builder parse(String name, Map<String, Object> node, ParserContext parserContext)\n+                throws MapperParsingException {\n+            Builder builder = new PointFieldMapper.Builder(name);\n+            parseField(builder, name, node, parserContext);\n+            Object nullValue = null;\n+            for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(); iterator.hasNext();) {\n+                Map.Entry<String, Object> entry = iterator.next();\n+                String propName = entry.getKey();\n+                Object propNode = entry.getValue();\n+\n+                if (propName.equals(Names.IGNORE_MALFORMED)) {\n+                    builder.ignoreMalformed(XContentMapValues.nodeBooleanValue(propNode, name + \".\" + Names.IGNORE_MALFORMED));\n+                    iterator.remove();\n+                } else if (propName.equals(Names.NULL_VALUE)) {\n+                    if (propNode == null) {\n+                        throw new MapperParsingException(\"Property [null_value] cannot be null.\");\n+                    }\n+                    nullValue = propNode;\n+                    iterator.remove();\n+                }\n+            }\n+\n+            if (nullValue != null) {\n+                boolean ignoreMalformed = builder.ignoreMalformed == null ? Defaults.IGNORE_MALFORMED.value() : builder.ignoreMalformed;\n+                CartesianPoint point = CartesianPoint.parsePoint(nullValue);\n+                if (ignoreMalformed == false) {\n+                    if (Float.isFinite(point.getX()) == false) {\n+                        throw new IllegalArgumentException(\"illegal x value [\" + point.getX() + \"]\");\n+                    }\n+                    if (Float.isFinite(point.getY()) == false) {\n+                        throw new IllegalArgumentException(\"illegal y value [\" + point.getY() + \"]\");\n+                    }\n+                }\n+                builder.nullValue(point);\n+            }\n+            return builder;\n+        }\n+    }\n+\n+    protected Explicit<Boolean> ignoreMalformed;\n+\n+    public PointFieldMapper(String simpleName, MappedFieldType fieldType, MappedFieldType defaultFieldType,\n+                            Settings indexSettings, MultiFields multiFields, Explicit<Boolean> ignoreMalformed,\n+                            CopyTo copyTo) {\n+        super(simpleName, fieldType, defaultFieldType, indexSettings, multiFields, copyTo);\n+        this.ignoreMalformed = ignoreMalformed;\n+    }\n+\n+    @Override\n+    protected void doMerge(Mapper mergeWith) {\n+        super.doMerge(mergeWith);\n+        PointFieldMapper gpfmMergeWith = (PointFieldMapper) mergeWith;\n+        if (gpfmMergeWith.ignoreMalformed.explicit()) {\n+            this.ignoreMalformed = gpfmMergeWith.ignoreMalformed;\n+        }\n+    }\n+\n+    @Override\n+    protected String contentType() {\n+        return CONTENT_TYPE;\n+    }\n+\n+    @Override\n+    protected void parseCreateField(ParseContext context, List<IndexableField> fields) throws IOException {\n+        throw new UnsupportedOperationException(\"Parsing is implemented in parse(), this method should NEVER be called\");\n+    }\n+\n+    public static class PointFieldType extends AbstractSearchableGeometryFieldType {\n+        public PointFieldType() {\n+        }\n+\n+        PointFieldType(PointFieldType ref) {\n+            super(ref);\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return CONTENT_TYPE;\n+        }\n+\n+        @Override\n+        public MappedFieldType clone() {\n+            return new PointFieldType(this);\n+        }\n+\n+        @Override\n+        public ValuesSourceType getValuesSourceType() {\n+            return CoreValuesSourceType.GEOPOINT;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQwNzIxOQ=="}, "originalCommit": {"oid": "d4d2e0a5a386311fcad8c65016b799f499da343a"}, "originalPosition": 212}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MzUxMzMzOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/mapper/PointFieldMapper.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxOToyODo1NVrOF6_2Hw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwOToxNDo1NFrOF9glGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQwNzc3NQ==", "bodyText": "The more I think about this the more I think it's best we disable doc values for this PR and give it some more thought in a future PR. That's fine considering we weren't planning to add cartesian aggregation support until a future version anyway.", "url": "https://github.com/elastic/elasticsearch/pull/53804#discussion_r397407775", "createdAt": "2020-03-24T19:28:55Z", "author": {"login": "nknize"}, "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/mapper/PointFieldMapper.java", "diffHunk": "@@ -0,0 +1,323 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.spatial.index.mapper;\n+\n+import org.apache.lucene.document.StoredField;\n+import org.apache.lucene.document.XYDocValuesField;\n+import org.apache.lucene.document.XYPointField;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.DocValuesFieldExistsQuery;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.TermQuery;\n+import org.elasticsearch.ElasticsearchParseException;\n+import org.elasticsearch.common.Explicit;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.support.XContentMapValues;\n+import org.elasticsearch.index.mapper.AbstractSearchableGeometryFieldType;\n+import org.elasticsearch.index.mapper.ArrayValueMapperParser;\n+import org.elasticsearch.index.mapper.FieldMapper;\n+import org.elasticsearch.index.mapper.FieldNamesFieldMapper;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+import org.elasticsearch.index.mapper.Mapper;\n+import org.elasticsearch.index.mapper.MapperParsingException;\n+import org.elasticsearch.index.mapper.ParseContext;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.index.query.QueryShardException;\n+import org.elasticsearch.search.aggregations.support.CoreValuesSourceType;\n+import org.elasticsearch.search.aggregations.support.ValuesSourceType;\n+import org.elasticsearch.xpack.spatial.index.query.ShapeQueryPointProcessor;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.elasticsearch.index.mapper.TypeParsers.parseField;\n+\n+\n+/**\n+ * Field Mapper for point type.\n+ *\n+ * Uses lucene 8 XYPoint encoding\n+ */\n+public class PointFieldMapper extends FieldMapper implements ArrayValueMapperParser {\n+    public static final String CONTENT_TYPE = \"point\";\n+\n+    public static class Names {\n+        public static final String IGNORE_MALFORMED = \"ignore_malformed\";\n+        public static final String NULL_VALUE = \"null_value\";\n+    }\n+\n+    public static class Defaults {\n+        public static final Explicit<Boolean> IGNORE_MALFORMED = new Explicit<>(false, false);\n+        public static final PointFieldType FIELD_TYPE = new PointFieldType();\n+\n+        static {\n+            FIELD_TYPE.setTokenized(false);\n+            FIELD_TYPE.setHasDocValues(true);\n+            FIELD_TYPE.setDimensions(2, Integer.BYTES);\n+            FIELD_TYPE.freeze();\n+        }\n+    }\n+\n+    public static class Builder extends FieldMapper.Builder<Builder, PointFieldMapper> {\n+        protected Boolean ignoreMalformed;\n+\n+        public Builder(String name) {\n+            super(name, Defaults.FIELD_TYPE, Defaults.FIELD_TYPE);\n+            builder = this;\n+        }\n+\n+        public Builder ignoreMalformed(boolean ignoreMalformed) {\n+            this.ignoreMalformed = ignoreMalformed;\n+            return builder;\n+        }\n+\n+        protected Explicit<Boolean> ignoreMalformed(BuilderContext context) {\n+            if (ignoreMalformed != null) {\n+                return new Explicit<>(ignoreMalformed, true);\n+            }\n+            if (context.indexSettings() != null) {\n+                return new Explicit<>(IGNORE_MALFORMED_SETTING.get(context.indexSettings()), false);\n+            }\n+            return PointFieldMapper.Defaults.IGNORE_MALFORMED;\n+        }\n+\n+        public PointFieldMapper build(BuilderContext context, String simpleName, MappedFieldType fieldType,\n+                                      MappedFieldType defaultFieldType, Settings indexSettings,\n+                                      MultiFields multiFields, Explicit<Boolean> ignoreMalformed,\n+                                      CopyTo copyTo) {\n+            setupFieldType(context);\n+            return new PointFieldMapper(simpleName, fieldType, defaultFieldType, indexSettings, multiFields,\n+                ignoreMalformed, copyTo);\n+        }\n+\n+        @Override\n+        public PointFieldType fieldType() {\n+            return (PointFieldType)fieldType;\n+        }\n+\n+        @Override\n+        public PointFieldMapper build(BuilderContext context) {\n+            return build(context, name, fieldType, defaultFieldType, context.indexSettings(),\n+                multiFieldsBuilder.build(this, context), ignoreMalformed(context), copyTo);\n+        }\n+\n+        @Override\n+        protected void setupFieldType(BuilderContext context) {\n+            super.setupFieldType(context);\n+\n+            fieldType().setGeometryQueryBuilder(new ShapeQueryPointProcessor());\n+        }\n+    }\n+\n+    public static class TypeParser implements Mapper.TypeParser {\n+        @Override\n+        @SuppressWarnings(\"rawtypes\")\n+        public Mapper.Builder parse(String name, Map<String, Object> node, ParserContext parserContext)\n+                throws MapperParsingException {\n+            Builder builder = new PointFieldMapper.Builder(name);\n+            parseField(builder, name, node, parserContext);\n+            Object nullValue = null;\n+            for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(); iterator.hasNext();) {\n+                Map.Entry<String, Object> entry = iterator.next();\n+                String propName = entry.getKey();\n+                Object propNode = entry.getValue();\n+\n+                if (propName.equals(Names.IGNORE_MALFORMED)) {\n+                    builder.ignoreMalformed(XContentMapValues.nodeBooleanValue(propNode, name + \".\" + Names.IGNORE_MALFORMED));\n+                    iterator.remove();\n+                } else if (propName.equals(Names.NULL_VALUE)) {\n+                    if (propNode == null) {\n+                        throw new MapperParsingException(\"Property [null_value] cannot be null.\");\n+                    }\n+                    nullValue = propNode;\n+                    iterator.remove();\n+                }\n+            }\n+\n+            if (nullValue != null) {\n+                boolean ignoreMalformed = builder.ignoreMalformed == null ? Defaults.IGNORE_MALFORMED.value() : builder.ignoreMalformed;\n+                CartesianPoint point = CartesianPoint.parsePoint(nullValue);\n+                if (ignoreMalformed == false) {\n+                    if (Float.isFinite(point.getX()) == false) {\n+                        throw new IllegalArgumentException(\"illegal x value [\" + point.getX() + \"]\");\n+                    }\n+                    if (Float.isFinite(point.getY()) == false) {\n+                        throw new IllegalArgumentException(\"illegal y value [\" + point.getY() + \"]\");\n+                    }\n+                }\n+                builder.nullValue(point);\n+            }\n+            return builder;\n+        }\n+    }\n+\n+    protected Explicit<Boolean> ignoreMalformed;\n+\n+    public PointFieldMapper(String simpleName, MappedFieldType fieldType, MappedFieldType defaultFieldType,\n+                            Settings indexSettings, MultiFields multiFields, Explicit<Boolean> ignoreMalformed,\n+                            CopyTo copyTo) {\n+        super(simpleName, fieldType, defaultFieldType, indexSettings, multiFields, copyTo);\n+        this.ignoreMalformed = ignoreMalformed;\n+    }\n+\n+    @Override\n+    protected void doMerge(Mapper mergeWith) {\n+        super.doMerge(mergeWith);\n+        PointFieldMapper gpfmMergeWith = (PointFieldMapper) mergeWith;\n+        if (gpfmMergeWith.ignoreMalformed.explicit()) {\n+            this.ignoreMalformed = gpfmMergeWith.ignoreMalformed;\n+        }\n+    }\n+\n+    @Override\n+    protected String contentType() {\n+        return CONTENT_TYPE;\n+    }\n+\n+    @Override\n+    protected void parseCreateField(ParseContext context, List<IndexableField> fields) throws IOException {\n+        throw new UnsupportedOperationException(\"Parsing is implemented in parse(), this method should NEVER be called\");\n+    }\n+\n+    public static class PointFieldType extends AbstractSearchableGeometryFieldType {\n+        public PointFieldType() {\n+        }\n+\n+        PointFieldType(PointFieldType ref) {\n+            super(ref);\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return CONTENT_TYPE;\n+        }\n+\n+        @Override\n+        public MappedFieldType clone() {\n+            return new PointFieldType(this);\n+        }\n+\n+        @Override\n+        public ValuesSourceType getValuesSourceType() {\n+            return CoreValuesSourceType.GEOPOINT;\n+        }\n+\n+        @Override\n+        public Query existsQuery(QueryShardContext context) {\n+            if (hasDocValues()) {\n+                return new DocValuesFieldExistsQuery(name());\n+            } else {\n+                return new TermQuery(new Term(FieldNamesFieldMapper.NAME, name()));\n+            }\n+        }\n+\n+        @Override\n+        public Query termQuery(Object value, QueryShardContext context) {\n+            throw new QueryShardException(context, \"Geo fields do not support exact searching, use dedicated geo queries instead: [\"\n+                + name() + \"]\");\n+        }\n+    }\n+\n+    protected void parse(ParseContext context, CartesianPoint point) throws IOException {\n+\n+        if (fieldType().indexOptions() != IndexOptions.NONE) {\n+            context.doc().add(new XYPointField(fieldType().name(), point.getX(), point.getY()));\n+        }\n+        if (fieldType().stored()) {\n+            context.doc().add(new StoredField(fieldType().name(), point.toString()));\n+        }\n+        if (fieldType.hasDocValues()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4d2e0a5a386311fcad8c65016b799f499da343a"}, "originalPosition": 239}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDA0MTI0Mw==", "bodyText": "The reason I added doc values was to be able to execute IndexOrDocValuesQueries. This doc values are generated at Lucene level and my feeling is that it should not be a problem for backwards compatibility as they are already part of Lucene distribution.", "url": "https://github.com/elastic/elasticsearch/pull/53804#discussion_r400041243", "createdAt": "2020-03-30T09:14:54Z", "author": {"login": "iverase"}, "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/mapper/PointFieldMapper.java", "diffHunk": "@@ -0,0 +1,323 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.spatial.index.mapper;\n+\n+import org.apache.lucene.document.StoredField;\n+import org.apache.lucene.document.XYDocValuesField;\n+import org.apache.lucene.document.XYPointField;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.DocValuesFieldExistsQuery;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.TermQuery;\n+import org.elasticsearch.ElasticsearchParseException;\n+import org.elasticsearch.common.Explicit;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.support.XContentMapValues;\n+import org.elasticsearch.index.mapper.AbstractSearchableGeometryFieldType;\n+import org.elasticsearch.index.mapper.ArrayValueMapperParser;\n+import org.elasticsearch.index.mapper.FieldMapper;\n+import org.elasticsearch.index.mapper.FieldNamesFieldMapper;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+import org.elasticsearch.index.mapper.Mapper;\n+import org.elasticsearch.index.mapper.MapperParsingException;\n+import org.elasticsearch.index.mapper.ParseContext;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.index.query.QueryShardException;\n+import org.elasticsearch.search.aggregations.support.CoreValuesSourceType;\n+import org.elasticsearch.search.aggregations.support.ValuesSourceType;\n+import org.elasticsearch.xpack.spatial.index.query.ShapeQueryPointProcessor;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.elasticsearch.index.mapper.TypeParsers.parseField;\n+\n+\n+/**\n+ * Field Mapper for point type.\n+ *\n+ * Uses lucene 8 XYPoint encoding\n+ */\n+public class PointFieldMapper extends FieldMapper implements ArrayValueMapperParser {\n+    public static final String CONTENT_TYPE = \"point\";\n+\n+    public static class Names {\n+        public static final String IGNORE_MALFORMED = \"ignore_malformed\";\n+        public static final String NULL_VALUE = \"null_value\";\n+    }\n+\n+    public static class Defaults {\n+        public static final Explicit<Boolean> IGNORE_MALFORMED = new Explicit<>(false, false);\n+        public static final PointFieldType FIELD_TYPE = new PointFieldType();\n+\n+        static {\n+            FIELD_TYPE.setTokenized(false);\n+            FIELD_TYPE.setHasDocValues(true);\n+            FIELD_TYPE.setDimensions(2, Integer.BYTES);\n+            FIELD_TYPE.freeze();\n+        }\n+    }\n+\n+    public static class Builder extends FieldMapper.Builder<Builder, PointFieldMapper> {\n+        protected Boolean ignoreMalformed;\n+\n+        public Builder(String name) {\n+            super(name, Defaults.FIELD_TYPE, Defaults.FIELD_TYPE);\n+            builder = this;\n+        }\n+\n+        public Builder ignoreMalformed(boolean ignoreMalformed) {\n+            this.ignoreMalformed = ignoreMalformed;\n+            return builder;\n+        }\n+\n+        protected Explicit<Boolean> ignoreMalformed(BuilderContext context) {\n+            if (ignoreMalformed != null) {\n+                return new Explicit<>(ignoreMalformed, true);\n+            }\n+            if (context.indexSettings() != null) {\n+                return new Explicit<>(IGNORE_MALFORMED_SETTING.get(context.indexSettings()), false);\n+            }\n+            return PointFieldMapper.Defaults.IGNORE_MALFORMED;\n+        }\n+\n+        public PointFieldMapper build(BuilderContext context, String simpleName, MappedFieldType fieldType,\n+                                      MappedFieldType defaultFieldType, Settings indexSettings,\n+                                      MultiFields multiFields, Explicit<Boolean> ignoreMalformed,\n+                                      CopyTo copyTo) {\n+            setupFieldType(context);\n+            return new PointFieldMapper(simpleName, fieldType, defaultFieldType, indexSettings, multiFields,\n+                ignoreMalformed, copyTo);\n+        }\n+\n+        @Override\n+        public PointFieldType fieldType() {\n+            return (PointFieldType)fieldType;\n+        }\n+\n+        @Override\n+        public PointFieldMapper build(BuilderContext context) {\n+            return build(context, name, fieldType, defaultFieldType, context.indexSettings(),\n+                multiFieldsBuilder.build(this, context), ignoreMalformed(context), copyTo);\n+        }\n+\n+        @Override\n+        protected void setupFieldType(BuilderContext context) {\n+            super.setupFieldType(context);\n+\n+            fieldType().setGeometryQueryBuilder(new ShapeQueryPointProcessor());\n+        }\n+    }\n+\n+    public static class TypeParser implements Mapper.TypeParser {\n+        @Override\n+        @SuppressWarnings(\"rawtypes\")\n+        public Mapper.Builder parse(String name, Map<String, Object> node, ParserContext parserContext)\n+                throws MapperParsingException {\n+            Builder builder = new PointFieldMapper.Builder(name);\n+            parseField(builder, name, node, parserContext);\n+            Object nullValue = null;\n+            for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(); iterator.hasNext();) {\n+                Map.Entry<String, Object> entry = iterator.next();\n+                String propName = entry.getKey();\n+                Object propNode = entry.getValue();\n+\n+                if (propName.equals(Names.IGNORE_MALFORMED)) {\n+                    builder.ignoreMalformed(XContentMapValues.nodeBooleanValue(propNode, name + \".\" + Names.IGNORE_MALFORMED));\n+                    iterator.remove();\n+                } else if (propName.equals(Names.NULL_VALUE)) {\n+                    if (propNode == null) {\n+                        throw new MapperParsingException(\"Property [null_value] cannot be null.\");\n+                    }\n+                    nullValue = propNode;\n+                    iterator.remove();\n+                }\n+            }\n+\n+            if (nullValue != null) {\n+                boolean ignoreMalformed = builder.ignoreMalformed == null ? Defaults.IGNORE_MALFORMED.value() : builder.ignoreMalformed;\n+                CartesianPoint point = CartesianPoint.parsePoint(nullValue);\n+                if (ignoreMalformed == false) {\n+                    if (Float.isFinite(point.getX()) == false) {\n+                        throw new IllegalArgumentException(\"illegal x value [\" + point.getX() + \"]\");\n+                    }\n+                    if (Float.isFinite(point.getY()) == false) {\n+                        throw new IllegalArgumentException(\"illegal y value [\" + point.getY() + \"]\");\n+                    }\n+                }\n+                builder.nullValue(point);\n+            }\n+            return builder;\n+        }\n+    }\n+\n+    protected Explicit<Boolean> ignoreMalformed;\n+\n+    public PointFieldMapper(String simpleName, MappedFieldType fieldType, MappedFieldType defaultFieldType,\n+                            Settings indexSettings, MultiFields multiFields, Explicit<Boolean> ignoreMalformed,\n+                            CopyTo copyTo) {\n+        super(simpleName, fieldType, defaultFieldType, indexSettings, multiFields, copyTo);\n+        this.ignoreMalformed = ignoreMalformed;\n+    }\n+\n+    @Override\n+    protected void doMerge(Mapper mergeWith) {\n+        super.doMerge(mergeWith);\n+        PointFieldMapper gpfmMergeWith = (PointFieldMapper) mergeWith;\n+        if (gpfmMergeWith.ignoreMalformed.explicit()) {\n+            this.ignoreMalformed = gpfmMergeWith.ignoreMalformed;\n+        }\n+    }\n+\n+    @Override\n+    protected String contentType() {\n+        return CONTENT_TYPE;\n+    }\n+\n+    @Override\n+    protected void parseCreateField(ParseContext context, List<IndexableField> fields) throws IOException {\n+        throw new UnsupportedOperationException(\"Parsing is implemented in parse(), this method should NEVER be called\");\n+    }\n+\n+    public static class PointFieldType extends AbstractSearchableGeometryFieldType {\n+        public PointFieldType() {\n+        }\n+\n+        PointFieldType(PointFieldType ref) {\n+            super(ref);\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return CONTENT_TYPE;\n+        }\n+\n+        @Override\n+        public MappedFieldType clone() {\n+            return new PointFieldType(this);\n+        }\n+\n+        @Override\n+        public ValuesSourceType getValuesSourceType() {\n+            return CoreValuesSourceType.GEOPOINT;\n+        }\n+\n+        @Override\n+        public Query existsQuery(QueryShardContext context) {\n+            if (hasDocValues()) {\n+                return new DocValuesFieldExistsQuery(name());\n+            } else {\n+                return new TermQuery(new Term(FieldNamesFieldMapper.NAME, name()));\n+            }\n+        }\n+\n+        @Override\n+        public Query termQuery(Object value, QueryShardContext context) {\n+            throw new QueryShardException(context, \"Geo fields do not support exact searching, use dedicated geo queries instead: [\"\n+                + name() + \"]\");\n+        }\n+    }\n+\n+    protected void parse(ParseContext context, CartesianPoint point) throws IOException {\n+\n+        if (fieldType().indexOptions() != IndexOptions.NONE) {\n+            context.doc().add(new XYPointField(fieldType().name(), point.getX(), point.getY()));\n+        }\n+        if (fieldType().stored()) {\n+            context.doc().add(new StoredField(fieldType().name(), point.toString()));\n+        }\n+        if (fieldType.hasDocValues()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQwNzc3NQ=="}, "originalCommit": {"oid": "d4d2e0a5a386311fcad8c65016b799f499da343a"}, "originalPosition": 239}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MzUyNjgxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/query/ShapeQueryPointProcessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxOTozMjo0MVrOF6_-rw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxOTozMjo0MVrOF6_-rw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQwOTk2Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // wrap geoQuery as a ConstantScoreQuery\n          \n          \n            \n                    // wrap XYPoint query as a ConstantScoreQuery", "url": "https://github.com/elastic/elasticsearch/pull/53804#discussion_r397409967", "createdAt": "2020-03-24T19:32:41Z", "author": {"login": "nknize"}, "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/query/ShapeQueryPointProcessor.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.spatial.index.query;\n+\n+import org.apache.lucene.document.XYDocValuesField;\n+import org.apache.lucene.document.XYPointField;\n+import org.apache.lucene.geo.XYCircle;\n+import org.apache.lucene.geo.XYRectangle;\n+import org.apache.lucene.search.BooleanClause;\n+import org.apache.lucene.search.BooleanQuery;\n+import org.apache.lucene.search.IndexOrDocValuesQuery;\n+import org.apache.lucene.search.Query;\n+import org.elasticsearch.common.geo.ShapeRelation;\n+import org.elasticsearch.geometry.Circle;\n+import org.elasticsearch.geometry.Geometry;\n+import org.elasticsearch.geometry.GeometryCollection;\n+import org.elasticsearch.geometry.GeometryVisitor;\n+import org.elasticsearch.geometry.LinearRing;\n+import org.elasticsearch.geometry.MultiLine;\n+import org.elasticsearch.geometry.MultiPoint;\n+import org.elasticsearch.geometry.MultiPolygon;\n+import org.elasticsearch.geometry.Point;\n+import org.elasticsearch.geometry.Polygon;\n+import org.elasticsearch.geometry.Rectangle;\n+import org.elasticsearch.geometry.ShapeType;\n+import org.elasticsearch.index.mapper.AbstractSearchableGeometryFieldType;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.index.query.QueryShardException;\n+import org.elasticsearch.xpack.spatial.index.mapper.PointFieldMapper;\n+import org.elasticsearch.xpack.spatial.index.mapper.ShapeUtils;\n+\n+\n+public class ShapeQueryPointProcessor implements AbstractSearchableGeometryFieldType.QueryProcessor {\n+\n+    @Override\n+    public Query process(Geometry shape, String fieldName, ShapeRelation relation, QueryShardContext context) {\n+        validateIsPointFieldType(fieldName, context);\n+        // geo points only support intersects\n+        if (relation != ShapeRelation.INTERSECTS) {\n+            throw new QueryShardException(context,\n+                relation+ \" query relation not supported for Field [\" + fieldName + \"].\");\n+        }\n+        // wrap geoQuery as a ConstantScoreQuery", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4d2e0a5a386311fcad8c65016b799f499da343a"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MzUyOTYwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/query/ShapeQueryPointProcessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxOTozMzoyOVrOF7AAaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxOTozMzoyOVrOF7AAaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQxMDQwOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // geo points only support intersects\n          \n          \n            \n                    // only the intersects relation is supported for indexed cartesian point types", "url": "https://github.com/elastic/elasticsearch/pull/53804#discussion_r397410408", "createdAt": "2020-03-24T19:33:29Z", "author": {"login": "nknize"}, "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/query/ShapeQueryPointProcessor.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.spatial.index.query;\n+\n+import org.apache.lucene.document.XYDocValuesField;\n+import org.apache.lucene.document.XYPointField;\n+import org.apache.lucene.geo.XYCircle;\n+import org.apache.lucene.geo.XYRectangle;\n+import org.apache.lucene.search.BooleanClause;\n+import org.apache.lucene.search.BooleanQuery;\n+import org.apache.lucene.search.IndexOrDocValuesQuery;\n+import org.apache.lucene.search.Query;\n+import org.elasticsearch.common.geo.ShapeRelation;\n+import org.elasticsearch.geometry.Circle;\n+import org.elasticsearch.geometry.Geometry;\n+import org.elasticsearch.geometry.GeometryCollection;\n+import org.elasticsearch.geometry.GeometryVisitor;\n+import org.elasticsearch.geometry.LinearRing;\n+import org.elasticsearch.geometry.MultiLine;\n+import org.elasticsearch.geometry.MultiPoint;\n+import org.elasticsearch.geometry.MultiPolygon;\n+import org.elasticsearch.geometry.Point;\n+import org.elasticsearch.geometry.Polygon;\n+import org.elasticsearch.geometry.Rectangle;\n+import org.elasticsearch.geometry.ShapeType;\n+import org.elasticsearch.index.mapper.AbstractSearchableGeometryFieldType;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.index.query.QueryShardException;\n+import org.elasticsearch.xpack.spatial.index.mapper.PointFieldMapper;\n+import org.elasticsearch.xpack.spatial.index.mapper.ShapeUtils;\n+\n+\n+public class ShapeQueryPointProcessor implements AbstractSearchableGeometryFieldType.QueryProcessor {\n+\n+    @Override\n+    public Query process(Geometry shape, String fieldName, ShapeRelation relation, QueryShardContext context) {\n+        validateIsPointFieldType(fieldName, context);\n+        // geo points only support intersects", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4d2e0a5a386311fcad8c65016b799f499da343a"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MzUzOTQxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/spatial/src/test/java/org/elasticsearch/xpack/spatial/index/mapper/PointFieldMapperTests.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxOTozNjo0MlrOF7AGsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxOTozNjo0MlrOF7AGsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQxMjAxNw==", "bodyText": "Can we create a public abstract class CartesianFieldMapperTests (or XYFieldMapperTests) that serves as the foundation for XYPointandXYShape`? I'm okay with doing that in a separate PR as well. I think it will make for better test management?", "url": "https://github.com/elastic/elasticsearch/pull/53804#discussion_r397412017", "createdAt": "2020-03-24T19:36:42Z", "author": {"login": "nknize"}, "path": "x-pack/plugin/spatial/src/test/java/org/elasticsearch/xpack/spatial/index/mapper/PointFieldMapperTests.java", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.spatial.index.mapper;\n+\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.compress.CompressedXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.index.mapper.DocumentMapper;\n+import org.elasticsearch.index.mapper.DocumentMapperParser;\n+import org.elasticsearch.index.mapper.Mapper;\n+import org.elasticsearch.index.mapper.ParsedDocument;\n+import org.elasticsearch.index.mapper.SourceToParse;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.test.ESSingleNodeTestCase;\n+import org.elasticsearch.test.InternalSettingsPlugin;\n+import org.elasticsearch.xpack.core.LocalStateCompositeXPackPlugin;\n+import org.elasticsearch.xpack.spatial.SpatialPlugin;\n+import org.hamcrest.CoreMatchers;\n+\n+import java.util.Collection;\n+\n+import static org.elasticsearch.xpack.spatial.index.mapper.PointFieldMapper.Names.NULL_VALUE;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.not;\n+import static org.hamcrest.Matchers.notNullValue;\n+import static org.hamcrest.Matchers.nullValue;\n+\n+public class PointFieldMapperTests extends ESSingleNodeTestCase {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4d2e0a5a386311fcad8c65016b799f499da343a"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MzU0MzU5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/spatial/src/test/java/org/elasticsearch/xpack/spatial/index/query/ShapeQueryBuilderTests.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxOTozNzo1OVrOF7AJdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxOTozNzo1OVrOF7AJdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQxMjcyNw==", "bodyText": "\ud83d\udc4d   Excellent reuse", "url": "https://github.com/elastic/elasticsearch/pull/53804#discussion_r397412727", "createdAt": "2020-03-24T19:37:59Z", "author": {"login": "nknize"}, "path": "x-pack/plugin/spatial/src/test/java/org/elasticsearch/xpack/spatial/index/query/ShapeQueryBuilderTests.java", "diffHunk": "@@ -49,28 +44,27 @@\n import static org.hamcrest.Matchers.anyOf;\n import static org.hamcrest.Matchers.equalTo;\n \n-public class ShapeQueryBuilderTests extends AbstractQueryTestCase<ShapeQueryBuilder> {\n+public abstract class ShapeQueryBuilderTests extends AbstractQueryTestCase<ShapeQueryBuilder> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4d2e0a5a386311fcad8c65016b799f499da343a"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNTQ3MDI4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/mapper/CartesianPoint.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwNjoxMzo1N1rOGeNZPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwNjoxMzo1N1rOGeNZPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMyOTkxOQ==", "bodyText": "@iverase, Y_FIELD.getPreferredName() should be Z_FIELD.getPreferredName()?", "url": "https://github.com/elastic/elasticsearch/pull/53804#discussion_r434329919", "createdAt": "2020-06-03T06:13:57Z", "author": {"login": "russcam"}, "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/mapper/CartesianPoint.java", "diffHunk": "@@ -0,0 +1,293 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.spatial.index.mapper;\n+\n+import org.elasticsearch.ElasticsearchParseException;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.xcontent.LoggingDeprecationHandler;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.ToXContentFragment;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentSubParser;\n+import org.elasticsearch.common.xcontent.support.MapXContentParser;\n+import org.elasticsearch.geometry.Geometry;\n+import org.elasticsearch.geometry.ShapeType;\n+import org.elasticsearch.geometry.utils.StandardValidator;\n+import org.elasticsearch.geometry.utils.WellKnownText;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Locale;\n+\n+import static org.elasticsearch.index.mapper.GeoPointFieldMapper.Names.IGNORE_Z_VALUE;\n+\n+/**\n+ * Represents a point in the cartesian space.\n+ */\n+public final class CartesianPoint implements ToXContentFragment {\n+\n+    private static final ParseField X_FIELD = new ParseField(\"x\");\n+    private static final ParseField Y_FIELD = new ParseField(\"y\");\n+    private static final ParseField Z_FIELD = new ParseField(\"z\");\n+\n+    private float x;\n+    private float y;\n+\n+    public CartesianPoint() {\n+    }\n+\n+    public CartesianPoint(float x, float y) {\n+        this.x = x;\n+        this.y = y;\n+    }\n+\n+    public CartesianPoint reset(float x, float y) {\n+        this.x = x;\n+        this.y = y;\n+        return this;\n+    }\n+\n+    public CartesianPoint resetFromString(String value, final boolean ignoreZValue) {\n+        if (value.toLowerCase(Locale.ROOT).contains(\"point\")) {\n+            return resetFromWKT(value, ignoreZValue);\n+        } else {\n+            return resetFromCoordinates(value, ignoreZValue);\n+        }\n+    }\n+\n+\n+    public CartesianPoint resetFromCoordinates(String value, final boolean ignoreZValue) {\n+        String[] vals = value.split(\",\");\n+        if (vals.length > 3 || vals.length < 2) {\n+            throw new ElasticsearchParseException(\"failed to parse [{}], expected 2 or 3 coordinates \"\n+                + \"but found: [{}]\", vals, vals.length);\n+        }\n+        final float x;\n+        final float y;\n+        try {\n+            x = Float.parseFloat(vals[0].trim());\n+            if (Float.isFinite(x) == false) {\n+                throw new ElasticsearchParseException(\"invalid [{}] value [{}]; \" +\n+                    \"must be between -3.4028234663852886E38 and 3.4028234663852886E38\",\n+                    X_FIELD.getPreferredName(),\n+                    x);\n+            }\n+         } catch (NumberFormatException ex) {\n+            throw new ElasticsearchParseException(\"[{}]] must be a number\", X_FIELD.getPreferredName());\n+        }\n+        try {\n+            y = Float.parseFloat(vals[1].trim());\n+            if (Float.isFinite(y) == false) {\n+                throw new ElasticsearchParseException(\"invalid [{}] value [{}]; \" +\n+                    \"must be between -3.4028234663852886E38 and 3.4028234663852886E38\",\n+                    Y_FIELD.getPreferredName(),\n+                    y);\n+            }\n+        } catch (NumberFormatException ex) {\n+            throw new ElasticsearchParseException(\"[{}]] must be a number\", Y_FIELD.getPreferredName());\n+        }\n+        if (vals.length > 2) {\n+            try {\n+                CartesianPoint.assertZValue(ignoreZValue, Float.parseFloat(vals[2].trim()));\n+            } catch (NumberFormatException ex) {\n+                throw new ElasticsearchParseException(\"[{}]] must be a number\", Y_FIELD.getPreferredName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2014fde9a50c2e97c4e1551a9f6d8df0d2ca315d"}, "originalPosition": 98}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4252, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}