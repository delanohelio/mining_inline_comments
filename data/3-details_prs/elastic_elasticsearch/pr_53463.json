{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg3MTM4MjMw", "number": 53463, "title": "Only link fd* files during source-only snapshot", "bodyText": "Source-only snapshots currently create a second full source-only copy of the shard on disk to support incrementality during upload. Given that stored fields are occupying a substantial part of a shard's storage, this means that clusters with source-only snapshots can require up to 50% more local storage. Ideally we would only generate source-only parts of the shard for the things that need to be uploaded (i.e. do incrementality checks on original file instead of trimmed-down source-only versions), but that requires much bigger changes to the snapshot infrastructure. This here is an attempt to dramatically cut down on the storage used by the source-only copy of the shard by soft-linking the stored-fields files (fd*) instead of copying them.\nRelates #50231", "createdAt": "2020-03-12T09:43:12Z", "url": "https://github.com/elastic/elasticsearch/pull/53463", "merged": true, "mergeCommit": {"oid": "c8290793303d3f7f9cef08b924615fd22be9560c"}, "closed": true, "closedAt": "2020-03-23T09:50:38Z", "author": {"login": "ywelsch"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcM4R9AAH2gAyMzg3MTM4MjMwOjk3NWNmNjM0MjQ1MzZkNmZlNjIyYjY2NzBkMzA1MTg1N2E0MWNhY2U=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcQaP2hgH2gAyMzg3MTM4MjMwOjEwZGI5YWI4MGJhMzk2YjljZGI2MzVjNzVkNjc5ZTViZjgzOGYyOTg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "975cf63424536d6fe622b6670d3051857a41cace", "author": {"user": {"login": "ywelsch", "name": "Yannick Welsch"}}, "url": "https://github.com/elastic/elasticsearch/commit/975cf63424536d6fe622b6670d3051857a41cace", "committedDate": "2020-03-12T09:27:28Z", "message": "Only link fd* files during source-only snapshot"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0b0f91e599cbbdc60674ad8a1176eecf52f64fa0", "author": {"user": {"login": "ywelsch", "name": "Yannick Welsch"}}, "url": "https://github.com/elastic/elasticsearch/commit/0b0f91e599cbbdc60674ad8a1176eecf52f64fa0", "committedDate": "2020-03-12T13:02:14Z", "message": "Merge remote-tracking branch 'elastic/master' into source-only-linked-files"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1633d8e10febe82276d1268be599ee403eda0aef", "author": {"user": {"login": "ywelsch", "name": "Yannick Welsch"}}, "url": "https://github.com/elastic/elasticsearch/commit/1633d8e10febe82276d1268be599ee403eda0aef", "committedDate": "2020-03-12T13:03:15Z", "message": "checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a6e52ba3c8d6ff1ed13e41a19726b39807cee3fe", "author": {"user": {"login": "ywelsch", "name": "Yannick Welsch"}}, "url": "https://github.com/elastic/elasticsearch/commit/a6e52ba3c8d6ff1ed13e41a19726b39807cee3fe", "committedDate": "2020-03-13T09:45:23Z", "message": "Merge remote-tracking branch 'elastic/master' into source-only-linked-files"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc0NzI3ODAz", "url": "https://github.com/elastic/elasticsearch/pull/53463#pullrequestreview-374727803", "createdAt": "2020-03-14T13:37:45Z", "commit": {"oid": "1633d8e10febe82276d1268be599ee403eda0aef"}, "state": "APPROVED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNFQxMzo0MDoxNlrOF2Zvow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxNjo1MzoxN1rOF5buXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU4OTIxOQ==", "bodyText": "NIT: files.toArray(Strings.EMPTY_ARRAY)?", "url": "https://github.com/elastic/elasticsearch/pull/53463#discussion_r392589219", "createdAt": "2020-03-14T13:40:16Z", "author": {"login": "original-brownbear"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/snapshots/SourceOnlySnapshot.java", "diffHunk": "@@ -270,4 +295,172 @@ private boolean assertLiveDocs(Bits liveDocs, int deletes) {\n             this.bits = bits;\n         }\n     }\n+\n+    public static class LinkedFilesDirectory extends Directory {\n+\n+        private final Directory wrapped;\n+        private final Map<String, Directory> linkedFiles = new HashMap<>();\n+\n+        public LinkedFilesDirectory(Directory wrapped) {\n+            this.wrapped = wrapped;\n+        }\n+\n+        public Directory getWrapped() {\n+            return wrapped;\n+        }\n+\n+        @Override\n+        public String[] listAll() throws IOException {\n+            Set<String> files = new HashSet<>();\n+            for (String f : wrapped.listAll()) {\n+                files.add(f);\n+            }\n+            for (String f : linkedFiles.keySet()) {\n+                files.add(f);\n+            }\n+            String[] result = files.toArray(new String[files.size()]);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6e52ba3c8d6ff1ed13e41a19726b39807cee3fe"}, "originalPosition": 218}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU4OTkwMQ==", "bodyText": "NIT:\n            Collections.addAll(files, wrapped.listAll());\n            files.addAll(linkedFiles.keySet());", "url": "https://github.com/elastic/elasticsearch/pull/53463#discussion_r392589901", "createdAt": "2020-03-14T13:50:38Z", "author": {"login": "original-brownbear"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/snapshots/SourceOnlySnapshot.java", "diffHunk": "@@ -270,4 +295,172 @@ private boolean assertLiveDocs(Bits liveDocs, int deletes) {\n             this.bits = bits;\n         }\n     }\n+\n+    public static class LinkedFilesDirectory extends Directory {\n+\n+        private final Directory wrapped;\n+        private final Map<String, Directory> linkedFiles = new HashMap<>();\n+\n+        public LinkedFilesDirectory(Directory wrapped) {\n+            this.wrapped = wrapped;\n+        }\n+\n+        public Directory getWrapped() {\n+            return wrapped;\n+        }\n+\n+        @Override\n+        public String[] listAll() throws IOException {\n+            Set<String> files = new HashSet<>();\n+            for (String f : wrapped.listAll()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6e52ba3c8d6ff1ed13e41a19726b39807cee3fe"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU4OTk5Ng==", "bodyText": "NIT:\n                try (directory) {\n                    wrapped.deleteFile(name);\n                } catch (NoSuchFileException | FileNotFoundException e) {\n                    // ignore\n                }", "url": "https://github.com/elastic/elasticsearch/pull/53463#discussion_r392589996", "createdAt": "2020-03-14T13:51:37Z", "author": {"login": "original-brownbear"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/snapshots/SourceOnlySnapshot.java", "diffHunk": "@@ -270,4 +295,172 @@ private boolean assertLiveDocs(Bits liveDocs, int deletes) {\n             this.bits = bits;\n         }\n     }\n+\n+    public static class LinkedFilesDirectory extends Directory {\n+\n+        private final Directory wrapped;\n+        private final Map<String, Directory> linkedFiles = new HashMap<>();\n+\n+        public LinkedFilesDirectory(Directory wrapped) {\n+            this.wrapped = wrapped;\n+        }\n+\n+        public Directory getWrapped() {\n+            return wrapped;\n+        }\n+\n+        @Override\n+        public String[] listAll() throws IOException {\n+            Set<String> files = new HashSet<>();\n+            for (String f : wrapped.listAll()) {\n+                files.add(f);\n+            }\n+            for (String f : linkedFiles.keySet()) {\n+                files.add(f);\n+            }\n+            String[] result = files.toArray(new String[files.size()]);\n+            Arrays.sort(result);\n+            return result;\n+        }\n+\n+        @Override\n+        public void deleteFile(String name) throws IOException {\n+            final Directory directory = linkedFiles.remove(name);\n+            if (directory == null) {\n+                wrapped.deleteFile(name);\n+            } else {\n+                try {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6e52ba3c8d6ff1ed13e41a19726b39807cee3fe"}, "originalPosition": 229}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY5MTA2MA==", "bodyText": "Add the name to the exception message?", "url": "https://github.com/elastic/elasticsearch/pull/53463#discussion_r395691060", "createdAt": "2020-03-20T14:54:47Z", "author": {"login": "original-brownbear"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/snapshots/SourceOnlySnapshot.java", "diffHunk": "@@ -270,4 +295,172 @@ private boolean assertLiveDocs(Bits liveDocs, int deletes) {\n             this.bits = bits;\n         }\n     }\n+\n+    public static class LinkedFilesDirectory extends Directory {\n+\n+        private final Directory wrapped;\n+        private final Map<String, Directory> linkedFiles = new HashMap<>();\n+\n+        public LinkedFilesDirectory(Directory wrapped) {\n+            this.wrapped = wrapped;\n+        }\n+\n+        public Directory getWrapped() {\n+            return wrapped;\n+        }\n+\n+        @Override\n+        public String[] listAll() throws IOException {\n+            Set<String> files = new HashSet<>();\n+            for (String f : wrapped.listAll()) {\n+                files.add(f);\n+            }\n+            for (String f : linkedFiles.keySet()) {\n+                files.add(f);\n+            }\n+            String[] result = files.toArray(new String[files.size()]);\n+            Arrays.sort(result);\n+            return result;\n+        }\n+\n+        @Override\n+        public void deleteFile(String name) throws IOException {\n+            final Directory directory = linkedFiles.remove(name);\n+            if (directory == null) {\n+                wrapped.deleteFile(name);\n+            } else {\n+                try {\n+                    wrapped.deleteFile(name);\n+                } catch (NoSuchFileException | FileNotFoundException e) {\n+                    // ignore\n+                } finally {\n+                    directory.close();\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public long fileLength(String name) throws IOException {\n+            final Directory linkedDir = linkedFiles.get(name);\n+            if (linkedDir != null) {\n+                return linkedDir.fileLength(name);\n+            } else {\n+                return wrapped.fileLength(name);\n+            }\n+        }\n+\n+        @Override\n+        public IndexOutput createOutput(String name, IOContext context) throws IOException {\n+            if (linkedFiles.containsKey(name)) {\n+                throw new IllegalArgumentException();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6e52ba3c8d6ff1ed13e41a19726b39807cee3fe"}, "originalPosition": 252}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc2MDY0MA==", "bodyText": "NIT: replace with assert newInfo.getDelCount() == 0 || assertLiveDocs(liveDocs.bits, liveDocs.numDeletes);?", "url": "https://github.com/elastic/elasticsearch/pull/53463#discussion_r395760640", "createdAt": "2020-03-20T16:42:08Z", "author": {"login": "original-brownbear"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/snapshots/SourceOnlySnapshot.java", "diffHunk": "@@ -191,63 +199,80 @@ DirectoryReader wrapReader(DirectoryReader reader) throws IOException {\n \n     private SegmentCommitInfo syncSegment(SegmentCommitInfo segmentCommitInfo, LiveDocs liveDocs, FieldInfos fieldInfos,\n                                           Map<BytesRef, SegmentCommitInfo> existingSegments, List<String> createdFiles) throws IOException {\n-        SegmentInfo si = segmentCommitInfo.info;\n-        Codec codec = si.getCodec();\n-        final String segmentSuffix = \"\";\n-        SegmentCommitInfo newInfo;\n-        final TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(targetDirectory);\n-        BytesRef segmentId = new BytesRef(si.getId());\n-        boolean exists = existingSegments.containsKey(segmentId);\n-        if (exists == false) {\n-            SegmentInfo newSegmentInfo = new SegmentInfo(si.dir, si.getVersion(), si.getMinVersion(), si.name, si.maxDoc(), false,\n-                si.getCodec(), si.getDiagnostics(), si.getId(), si.getAttributes(), null);\n-            // we drop the sort on purpose since the field we sorted on doesn't exist in the target index anymore.\n-            newInfo = new SegmentCommitInfo(newSegmentInfo, 0, 0, -1, -1, -1);\n-            List<FieldInfo> fieldInfoCopy = new ArrayList<>(fieldInfos.size());\n-            for (FieldInfo fieldInfo : fieldInfos) {\n-                fieldInfoCopy.add(new FieldInfo(fieldInfo.name, fieldInfo.number,\n-                    false, false, false, IndexOptions.NONE, DocValuesType.NONE, -1, fieldInfo.attributes(), 0, 0, 0,\n-                    fieldInfo.isSoftDeletesField()));\n-            }\n-            FieldInfos newFieldInfos = new FieldInfos(fieldInfoCopy.toArray(new FieldInfo[0]));\n-            codec.fieldInfosFormat().write(trackingDir, newSegmentInfo, segmentSuffix, newFieldInfos, IOContext.DEFAULT);\n-            newInfo.setFieldInfosFiles(trackingDir.getCreatedFiles());\n-            String idxFile = IndexFileNames.segmentFileName(newSegmentInfo.name, segmentSuffix, FIELDS_INDEX_EXTENSION);\n-            String dataFile = IndexFileNames.segmentFileName(newSegmentInfo.name, segmentSuffix, FIELDS_EXTENSION);\n-            String metaFile = IndexFileNames.segmentFileName(newSegmentInfo.name, segmentSuffix, FIELDS_META_EXTENSION);\n-            Directory sourceDir = newSegmentInfo.dir;\n+        Directory toClose = null;\n+        try {\n+            SegmentInfo si = segmentCommitInfo.info;\n+            Codec codec = si.getCodec();\n+            Directory sourceDir = si.dir;\n             if (si.getUseCompoundFile()) {\n-                sourceDir = codec.compoundFormat().getCompoundReader(sourceDir, si, IOContext.DEFAULT);\n+                sourceDir = new LinkedFilesDirectory.CloseMePleaseWrapper(\n+                    codec.compoundFormat().getCompoundReader(sourceDir, si, IOContext.DEFAULT));\n+                toClose = sourceDir;\n+            }\n+            final String segmentSuffix = \"\";\n+            SegmentCommitInfo newInfo;\n+            final TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(targetDirectory);\n+            BytesRef segmentId = new BytesRef(si.getId());\n+            boolean exists = existingSegments.containsKey(segmentId);\n+            if (exists == false) {\n+                SegmentInfo newSegmentInfo = new SegmentInfo(targetDirectory, si.getVersion(), si.getMinVersion(), si.name, si.maxDoc(),\n+                    false, si.getCodec(), si.getDiagnostics(), si.getId(), si.getAttributes(), null);\n+                // we drop the sort on purpose since the field we sorted on doesn't exist in the target index anymore.\n+                newInfo = new SegmentCommitInfo(newSegmentInfo, 0, 0, -1, -1, -1);\n+                List<FieldInfo> fieldInfoCopy = new ArrayList<>(fieldInfos.size());\n+                for (FieldInfo fieldInfo : fieldInfos) {\n+                    fieldInfoCopy.add(new FieldInfo(fieldInfo.name, fieldInfo.number,\n+                        false, false, false, IndexOptions.NONE, DocValuesType.NONE, -1, fieldInfo.attributes(), 0, 0, 0,\n+                        fieldInfo.isSoftDeletesField()));\n+                }\n+                FieldInfos newFieldInfos = new FieldInfos(fieldInfoCopy.toArray(new FieldInfo[0]));\n+                codec.fieldInfosFormat().write(trackingDir, newSegmentInfo, segmentSuffix, newFieldInfos, IOContext.DEFAULT);\n+                newInfo.setFieldInfosFiles(trackingDir.getCreatedFiles());\n+            } else {\n+                newInfo = existingSegments.get(segmentId);\n+                assert newInfo.info.getUseCompoundFile() == false;\n             }\n+\n+            // link files for stored fields to target directory\n+            final String idxFile = IndexFileNames.segmentFileName(newInfo.info.name, segmentSuffix, FIELDS_INDEX_EXTENSION);\n+            final String dataFile = IndexFileNames.segmentFileName(newInfo.info.name, segmentSuffix, FIELDS_EXTENSION);\n+            final String metaFile = IndexFileNames.segmentFileName(newInfo.info.name, segmentSuffix, FIELDS_META_EXTENSION);\n             trackingDir.copyFrom(sourceDir, idxFile, idxFile, IOContext.DEFAULT);\n+            assert targetDirectory.linkedFiles.containsKey(idxFile);\n+            assert trackingDir.getCreatedFiles().contains(idxFile);\n             trackingDir.copyFrom(sourceDir, dataFile, dataFile, IOContext.DEFAULT);\n-             if (Arrays.asList(sourceDir.listAll()).contains(metaFile)) { // only exists for Lucene 8.5+ indices\n-                 trackingDir.copyFrom(sourceDir, metaFile, metaFile, IOContext.DEFAULT);\n-             }\n-            if (sourceDir != newSegmentInfo.dir) {\n-                sourceDir.close();\n+            assert targetDirectory.linkedFiles.containsKey(dataFile);\n+            assert trackingDir.getCreatedFiles().contains(dataFile);\n+            if (Arrays.asList(sourceDir.listAll()).contains(metaFile)) { // only exists for Lucene 8.5+ indices\n+                trackingDir.copyFrom(sourceDir, metaFile, metaFile, IOContext.DEFAULT);\n+                assert targetDirectory.linkedFiles.containsKey(metaFile);\n+                assert trackingDir.getCreatedFiles().contains(metaFile);\n             }\n-        } else {\n-            newInfo = existingSegments.get(segmentId);\n-            assert newInfo.info.getUseCompoundFile() == false;\n-        }\n-        if (liveDocs.bits != null && liveDocs.numDeletes != 0 && liveDocs.numDeletes != newInfo.getDelCount()) {\n-            if (newInfo.getDelCount() != 0) {\n-                assert assertLiveDocs(liveDocs.bits, liveDocs.numDeletes);\n+\n+            if (liveDocs.bits != null && liveDocs.numDeletes != 0 && liveDocs.numDeletes != newInfo.getDelCount()) {\n+                if (newInfo.getDelCount() != 0) {\n+                    assert assertLiveDocs(liveDocs.bits, liveDocs.numDeletes);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6e52ba3c8d6ff1ed13e41a19726b39807cee3fe"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc2NTA3OQ==", "bodyText": "NIT: Save 2 lines via IOUtils.close(previous);?", "url": "https://github.com/elastic/elasticsearch/pull/53463#discussion_r395765079", "createdAt": "2020-03-20T16:49:30Z", "author": {"login": "original-brownbear"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/snapshots/SourceOnlySnapshot.java", "diffHunk": "@@ -270,4 +295,172 @@ private boolean assertLiveDocs(Bits liveDocs, int deletes) {\n             this.bits = bits;\n         }\n     }\n+\n+    public static class LinkedFilesDirectory extends Directory {\n+\n+        private final Directory wrapped;\n+        private final Map<String, Directory> linkedFiles = new HashMap<>();\n+\n+        public LinkedFilesDirectory(Directory wrapped) {\n+            this.wrapped = wrapped;\n+        }\n+\n+        public Directory getWrapped() {\n+            return wrapped;\n+        }\n+\n+        @Override\n+        public String[] listAll() throws IOException {\n+            Set<String> files = new HashSet<>();\n+            for (String f : wrapped.listAll()) {\n+                files.add(f);\n+            }\n+            for (String f : linkedFiles.keySet()) {\n+                files.add(f);\n+            }\n+            String[] result = files.toArray(new String[files.size()]);\n+            Arrays.sort(result);\n+            return result;\n+        }\n+\n+        @Override\n+        public void deleteFile(String name) throws IOException {\n+            final Directory directory = linkedFiles.remove(name);\n+            if (directory == null) {\n+                wrapped.deleteFile(name);\n+            } else {\n+                try {\n+                    wrapped.deleteFile(name);\n+                } catch (NoSuchFileException | FileNotFoundException e) {\n+                    // ignore\n+                } finally {\n+                    directory.close();\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public long fileLength(String name) throws IOException {\n+            final Directory linkedDir = linkedFiles.get(name);\n+            if (linkedDir != null) {\n+                return linkedDir.fileLength(name);\n+            } else {\n+                return wrapped.fileLength(name);\n+            }\n+        }\n+\n+        @Override\n+        public IndexOutput createOutput(String name, IOContext context) throws IOException {\n+            if (linkedFiles.containsKey(name)) {\n+                throw new IllegalArgumentException();\n+            } else {\n+                return wrapped.createOutput(name, context);\n+            }\n+        }\n+\n+        @Override\n+        public IndexOutput createTempOutput(String prefix, String suffix, IOContext context) throws IOException {\n+            return wrapped.createTempOutput(prefix, suffix, context);\n+        }\n+\n+        @Override\n+        public void sync(Collection<String> names) throws IOException {\n+            final List<String> primaryNames = new ArrayList<>();\n+\n+            for (String name : names) {\n+                if (linkedFiles.containsKey(name) == false) {\n+                    primaryNames.add(name);\n+                }\n+            }\n+\n+            if (primaryNames.isEmpty() == false) {\n+                wrapped.sync(primaryNames);\n+            }\n+        }\n+\n+        @Override\n+        public void syncMetaData() throws IOException {\n+            wrapped.syncMetaData();\n+        }\n+\n+        @Override\n+        public void rename(String source, String dest) throws IOException {\n+            if (linkedFiles.containsKey(source) || linkedFiles.containsKey(dest)) {\n+                throw new IllegalArgumentException();\n+            } else {\n+                wrapped.rename(source, dest);\n+            }\n+        }\n+\n+        @Override\n+        public IndexInput openInput(String name, IOContext context) throws IOException {\n+            final Directory linkedDir = linkedFiles.get(name);\n+            if (linkedDir != null) {\n+                return linkedDir.openInput(name, context);\n+            } else {\n+                return wrapped.openInput(name, context);\n+            }\n+        }\n+\n+        @Override\n+        public Lock obtainLock(String name) throws IOException {\n+            return wrapped.obtainLock(name);\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            IOUtils.close(linkedFiles.values());\n+            linkedFiles.clear();\n+            wrapped.close();\n+        }\n+\n+        @Override\n+        public void copyFrom(Directory from, String src, String dest, IOContext context) throws IOException {\n+            if (src.equals(dest) == false) {\n+                throw new IllegalArgumentException();\n+            } else {\n+                final Directory previous;\n+                if (from instanceof CloseMePleaseWrapper) {\n+                    ((CloseMePleaseWrapper) from).incRef();\n+                    previous = linkedFiles.put(src, from);\n+                } else {\n+                    previous = linkedFiles.put(src, new FilterDirectory(from) {\n+                        @Override\n+                        public void close() {\n+                            // ignore\n+                        }\n+                    });\n+                }\n+                if (previous != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6e52ba3c8d6ff1ed13e41a19726b39807cee3fe"}, "originalPosition": 331}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc2NzM4OQ==", "bodyText": "NIT: Maybe make it safer/shorter via IOUtils.close(() -> IOUtils.close(linkedFiles.values()), linkedFiles::clear, wrapped);?", "url": "https://github.com/elastic/elasticsearch/pull/53463#discussion_r395767389", "createdAt": "2020-03-20T16:53:17Z", "author": {"login": "original-brownbear"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/snapshots/SourceOnlySnapshot.java", "diffHunk": "@@ -270,4 +295,172 @@ private boolean assertLiveDocs(Bits liveDocs, int deletes) {\n             this.bits = bits;\n         }\n     }\n+\n+    public static class LinkedFilesDirectory extends Directory {\n+\n+        private final Directory wrapped;\n+        private final Map<String, Directory> linkedFiles = new HashMap<>();\n+\n+        public LinkedFilesDirectory(Directory wrapped) {\n+            this.wrapped = wrapped;\n+        }\n+\n+        public Directory getWrapped() {\n+            return wrapped;\n+        }\n+\n+        @Override\n+        public String[] listAll() throws IOException {\n+            Set<String> files = new HashSet<>();\n+            for (String f : wrapped.listAll()) {\n+                files.add(f);\n+            }\n+            for (String f : linkedFiles.keySet()) {\n+                files.add(f);\n+            }\n+            String[] result = files.toArray(new String[files.size()]);\n+            Arrays.sort(result);\n+            return result;\n+        }\n+\n+        @Override\n+        public void deleteFile(String name) throws IOException {\n+            final Directory directory = linkedFiles.remove(name);\n+            if (directory == null) {\n+                wrapped.deleteFile(name);\n+            } else {\n+                try {\n+                    wrapped.deleteFile(name);\n+                } catch (NoSuchFileException | FileNotFoundException e) {\n+                    // ignore\n+                } finally {\n+                    directory.close();\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public long fileLength(String name) throws IOException {\n+            final Directory linkedDir = linkedFiles.get(name);\n+            if (linkedDir != null) {\n+                return linkedDir.fileLength(name);\n+            } else {\n+                return wrapped.fileLength(name);\n+            }\n+        }\n+\n+        @Override\n+        public IndexOutput createOutput(String name, IOContext context) throws IOException {\n+            if (linkedFiles.containsKey(name)) {\n+                throw new IllegalArgumentException();\n+            } else {\n+                return wrapped.createOutput(name, context);\n+            }\n+        }\n+\n+        @Override\n+        public IndexOutput createTempOutput(String prefix, String suffix, IOContext context) throws IOException {\n+            return wrapped.createTempOutput(prefix, suffix, context);\n+        }\n+\n+        @Override\n+        public void sync(Collection<String> names) throws IOException {\n+            final List<String> primaryNames = new ArrayList<>();\n+\n+            for (String name : names) {\n+                if (linkedFiles.containsKey(name) == false) {\n+                    primaryNames.add(name);\n+                }\n+            }\n+\n+            if (primaryNames.isEmpty() == false) {\n+                wrapped.sync(primaryNames);\n+            }\n+        }\n+\n+        @Override\n+        public void syncMetaData() throws IOException {\n+            wrapped.syncMetaData();\n+        }\n+\n+        @Override\n+        public void rename(String source, String dest) throws IOException {\n+            if (linkedFiles.containsKey(source) || linkedFiles.containsKey(dest)) {\n+                throw new IllegalArgumentException();\n+            } else {\n+                wrapped.rename(source, dest);\n+            }\n+        }\n+\n+        @Override\n+        public IndexInput openInput(String name, IOContext context) throws IOException {\n+            final Directory linkedDir = linkedFiles.get(name);\n+            if (linkedDir != null) {\n+                return linkedDir.openInput(name, context);\n+            } else {\n+                return wrapped.openInput(name, context);\n+            }\n+        }\n+\n+        @Override\n+        public Lock obtainLock(String name) throws IOException {\n+            return wrapped.obtainLock(name);\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            IOUtils.close(linkedFiles.values());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6e52ba3c8d6ff1ed13e41a19726b39807cee3fe"}, "originalPosition": 309}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0687b50f18bd8b9649864dd9c8514301cd9134b3", "author": {"user": {"login": "ywelsch", "name": "Yannick Welsch"}}, "url": "https://github.com/elastic/elasticsearch/commit/0687b50f18bd8b9649864dd9c8514301cd9134b3", "committedDate": "2020-03-23T08:32:15Z", "message": "Merge remote-tracking branch 'elastic/master' into source-only-linked-files"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "10db9ab80ba396b9cdb635c75d679e5bf838f298", "author": {"user": {"login": "ywelsch", "name": "Yannick Welsch"}}, "url": "https://github.com/elastic/elasticsearch/commit/10db9ab80ba396b9cdb635c75d679e5bf838f298", "committedDate": "2020-03-23T08:43:43Z", "message": "nits"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1543, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}