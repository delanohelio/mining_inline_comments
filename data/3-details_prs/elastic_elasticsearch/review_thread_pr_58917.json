{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQzNTE4NDE2", "number": 58917, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMzo1ODozNFrOEK6Kgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMjowMDo1OVrOEMQh7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5ODc0MTc4OnYy", "diffSide": "RIGHT", "path": "rest-api-spec/src/main/resources/rest-api-spec/api/update.json", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMzo1ODozNFrOGsOIqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODozNTo0MVrOGsZEaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAyMjEyMQ==", "bodyText": "Which update requests need this flag? Isn't it that when the doc already exists then the index exists as well and the update doc request has no power here?", "url": "https://github.com/elastic/elasticsearch/pull/58917#discussion_r449022121", "createdAt": "2020-07-02T13:58:34Z", "author": {"login": "przemekwitek"}, "path": "rest-api-spec/src/main/resources/rest-api-spec/api/update.json", "diffHunk": "@@ -99,6 +99,10 @@\n       \"if_primary_term\":{\n         \"type\":\"number\",\n         \"description\":\"only perform the update operation if the last operation that has changed the document has the specified primary term\"\n+      },\n+      \"no_auto_create\": {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b324dcd09ac54be6b5743abc5e7587c62a956e7f"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIwMTI1Ng==", "bodyText": "@przemekwitek it is possible that an update request is also an upsert. There are options to say \"create the doc this way if it does not already exist\".", "url": "https://github.com/elastic/elasticsearch/pull/58917#discussion_r449201256", "createdAt": "2020-07-02T18:35:41Z", "author": {"login": "benwtrent"}, "path": "rest-api-spec/src/main/resources/rest-api-spec/api/update.json", "diffHunk": "@@ -99,6 +99,10 @@\n       \"if_primary_term\":{\n         \"type\":\"number\",\n         \"description\":\"only perform the update operation if the last operation that has changed the document has the specified primary term\"\n+      },\n+      \"no_auto_create\": {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAyMjEyMQ=="}, "originalCommit": {"oid": "b324dcd09ac54be6b5743abc5e7587c62a956e7f"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5ODc3NTE4OnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/elasticsearch/action/support/AutoCreateIndexTests.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNDowNjoyNlrOGsOdyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNzoyNTozN1rOGsmeWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAyNzUzMA==", "bodyText": "Where does the defaulting of request-level setting to index-level setting happen?", "url": "https://github.com/elastic/elasticsearch/pull/58917#discussion_r449027530", "createdAt": "2020-07-02T14:06:26Z", "author": {"login": "przemekwitek"}, "path": "server/src/test/java/org/elasticsearch/action/support/AutoCreateIndexTests.java", "diffHunk": "@@ -85,26 +85,36 @@ public void testAutoCreationDisabled() {\n         AutoCreateIndex autoCreateIndex = newAutoCreateIndex(settings);\n         String randomIndex = randomAlphaOfLengthBetween(1, 10);\n         IndexNotFoundException e = expectThrows(IndexNotFoundException.class, () ->\n-            autoCreateIndex.shouldAutoCreate(randomIndex, buildClusterState()));\n+            autoCreateIndex.shouldAutoCreate(randomIndex, false, buildClusterState()));\n         assertEquals(\"no such index [\" + randomIndex + \"] and [action.auto_create_index] is [false]\", e.getMessage());\n     }\n \n     public void testAutoCreationEnabled() {\n         Settings settings = Settings.builder().put(AutoCreateIndex.AUTO_CREATE_INDEX_SETTING.getKey(), true).build();\n         AutoCreateIndex autoCreateIndex = newAutoCreateIndex(settings);\n-        assertThat(autoCreateIndex.shouldAutoCreate(randomAlphaOfLengthBetween(1, 10), buildClusterState()), equalTo(true));\n+        assertThat(autoCreateIndex.shouldAutoCreate(randomAlphaOfLengthBetween(1, 10), false, buildClusterState()), equalTo(true));\n+    }\n+\n+    public void testAutoCreationEnabledWithNoAutoCreateFlagSet() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b324dcd09ac54be6b5743abc5e7587c62a956e7f"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIwMTkzNg==", "bodyText": "I don't understand your question.\nWhat is the default of the setting? Or how are the settings adjusted for this test?", "url": "https://github.com/elastic/elasticsearch/pull/58917#discussion_r449201936", "createdAt": "2020-07-02T18:37:12Z", "author": {"login": "benwtrent"}, "path": "server/src/test/java/org/elasticsearch/action/support/AutoCreateIndexTests.java", "diffHunk": "@@ -85,26 +85,36 @@ public void testAutoCreationDisabled() {\n         AutoCreateIndex autoCreateIndex = newAutoCreateIndex(settings);\n         String randomIndex = randomAlphaOfLengthBetween(1, 10);\n         IndexNotFoundException e = expectThrows(IndexNotFoundException.class, () ->\n-            autoCreateIndex.shouldAutoCreate(randomIndex, buildClusterState()));\n+            autoCreateIndex.shouldAutoCreate(randomIndex, false, buildClusterState()));\n         assertEquals(\"no such index [\" + randomIndex + \"] and [action.auto_create_index] is [false]\", e.getMessage());\n     }\n \n     public void testAutoCreationEnabled() {\n         Settings settings = Settings.builder().put(AutoCreateIndex.AUTO_CREATE_INDEX_SETTING.getKey(), true).build();\n         AutoCreateIndex autoCreateIndex = newAutoCreateIndex(settings);\n-        assertThat(autoCreateIndex.shouldAutoCreate(randomAlphaOfLengthBetween(1, 10), buildClusterState()), equalTo(true));\n+        assertThat(autoCreateIndex.shouldAutoCreate(randomAlphaOfLengthBetween(1, 10), false, buildClusterState()), equalTo(true));\n+    }\n+\n+    public void testAutoCreationEnabledWithNoAutoCreateFlagSet() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAyNzUzMA=="}, "originalCommit": {"oid": "b324dcd09ac54be6b5743abc5e7587c62a956e7f"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQyMDg4OQ==", "bodyText": "What I meant is more: where is the code that checks the value of the index-level setting should the request-level setting be false.", "url": "https://github.com/elastic/elasticsearch/pull/58917#discussion_r449420889", "createdAt": "2020-07-03T07:25:37Z", "author": {"login": "przemekwitek"}, "path": "server/src/test/java/org/elasticsearch/action/support/AutoCreateIndexTests.java", "diffHunk": "@@ -85,26 +85,36 @@ public void testAutoCreationDisabled() {\n         AutoCreateIndex autoCreateIndex = newAutoCreateIndex(settings);\n         String randomIndex = randomAlphaOfLengthBetween(1, 10);\n         IndexNotFoundException e = expectThrows(IndexNotFoundException.class, () ->\n-            autoCreateIndex.shouldAutoCreate(randomIndex, buildClusterState()));\n+            autoCreateIndex.shouldAutoCreate(randomIndex, false, buildClusterState()));\n         assertEquals(\"no such index [\" + randomIndex + \"] and [action.auto_create_index] is [false]\", e.getMessage());\n     }\n \n     public void testAutoCreationEnabled() {\n         Settings settings = Settings.builder().put(AutoCreateIndex.AUTO_CREATE_INDEX_SETTING.getKey(), true).build();\n         AutoCreateIndex autoCreateIndex = newAutoCreateIndex(settings);\n-        assertThat(autoCreateIndex.shouldAutoCreate(randomAlphaOfLengthBetween(1, 10), buildClusterState()), equalTo(true));\n+        assertThat(autoCreateIndex.shouldAutoCreate(randomAlphaOfLengthBetween(1, 10), false, buildClusterState()), equalTo(true));\n+    }\n+\n+    public void testAutoCreationEnabledWithNoAutoCreateFlagSet() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAyNzUzMA=="}, "originalCommit": {"oid": "b324dcd09ac54be6b5743abc5e7587c62a956e7f"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMjg0MjcwOnYy", "diffSide": "RIGHT", "path": "modules/reindex/src/main/java/org/elasticsearch/index/reindex/ReindexValidator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMTo0Mzo0MFrOGuQsWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMTo0Mzo0MFrOGuQsWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE2MTE3Ng==", "bodyText": "I think we could make this clearer, users will see \"[require_alias] request flag is [true]\" (they'll totally ignore the IndexNotFoundException part) and not have any idea what the error actually is, maybe something like:\n\"[require_alias] request flag is [true] and [myindex] is not an alias\"", "url": "https://github.com/elastic/elasticsearch/pull/58917#discussion_r451161176", "createdAt": "2020-07-07T21:43:40Z", "author": {"login": "dakrone"}, "path": "modules/reindex/src/main/java/org/elasticsearch/index/reindex/ReindexValidator.java", "diffHunk": "@@ -111,6 +113,9 @@ static void validateAgainstAliases(SearchRequest source, IndexRequest destinatio\n             return;\n         }\n         String target = destination.index();\n+        if (destination.isRequireAlias() && (false == clusterState.getMetadata().hasAlias(target))) {\n+            throw new IndexNotFoundException(\"[\" + DocWriteRequest.REQUIRE_ALIAS + \"] request flag is [true]\", target);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "158403a9e7b252f20185dc195a89629c7657c854"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMjg1ODI5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/bulk/TransportBulkAction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMTo0OTowOVrOGuQ12Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxMToyOTowOVrOGujp5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE2MzYwOQ==", "bodyText": "This is confusing I think, because I think it means that if someone has two bulk actions and one has require_alias: true and another require_alias: false that it will overall be require_alias: false. Since isRequireAlias cannot return null, that means that having it unset for a single operation effectively disables the require_alias flag for all operations for that index.\nI think we may want to err on the side of being stricter (if any operation requires it to be an alias, they all do) and change this to v1 || v2 instead of v1 && v2.\nEither that, or we will need to make the boolean a Boolean and differentiate between explicitly set and unset default values (I suspect just using || is an easier solution).\nAlso, can you add a test for this scenario?", "url": "https://github.com/elastic/elasticsearch/pull/58917#discussion_r451163609", "createdAt": "2020-07-07T21:49:09Z", "author": {"login": "dakrone"}, "path": "server/src/main/java/org/elasticsearch/action/bulk/TransportBulkAction.java", "diffHunk": "@@ -222,28 +222,29 @@ protected void doInternalExecute(Task task, BulkRequest bulkRequest, ActionListe\n         if (needToCheck()) {\n             // Attempt to create all the indices that we're going to need during the bulk before we start.\n             // Step 1: collect all the indices in the request\n-            final Set<String> indices = bulkRequest.requests.stream()\n-                    // delete requests should not attempt to create the index (if the index does not\n-                    // exists), unless an external versioning is used\n+            final Map<String, Boolean> indices = bulkRequest.requests.stream()\n+                // delete requests should not attempt to create the index (if the index does not\n+                // exists), unless an external versioning is used\n                 .filter(request -> request.opType() != DocWriteRequest.OpType.DELETE\n-                        || request.versionType() == VersionType.EXTERNAL\n-                        || request.versionType() == VersionType.EXTERNAL_GTE)\n-                .map(DocWriteRequest::index)\n-                .collect(Collectors.toSet());\n+                    || request.versionType() == VersionType.EXTERNAL\n+                    || request.versionType() == VersionType.EXTERNAL_GTE)\n+                .collect(Collectors.toMap(DocWriteRequest::index, DocWriteRequest::isRequireAlias, (v1, v2) -> v1 && v2));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "158403a9e7b252f20185dc195a89629c7657c854"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQ3MTg0Nw==", "bodyText": "I think we may want to err on the side of being stricter\n\nSounds good to me", "url": "https://github.com/elastic/elasticsearch/pull/58917#discussion_r451471847", "createdAt": "2020-07-08T11:29:09Z", "author": {"login": "benwtrent"}, "path": "server/src/main/java/org/elasticsearch/action/bulk/TransportBulkAction.java", "diffHunk": "@@ -222,28 +222,29 @@ protected void doInternalExecute(Task task, BulkRequest bulkRequest, ActionListe\n         if (needToCheck()) {\n             // Attempt to create all the indices that we're going to need during the bulk before we start.\n             // Step 1: collect all the indices in the request\n-            final Set<String> indices = bulkRequest.requests.stream()\n-                    // delete requests should not attempt to create the index (if the index does not\n-                    // exists), unless an external versioning is used\n+            final Map<String, Boolean> indices = bulkRequest.requests.stream()\n+                // delete requests should not attempt to create the index (if the index does not\n+                // exists), unless an external versioning is used\n                 .filter(request -> request.opType() != DocWriteRequest.OpType.DELETE\n-                        || request.versionType() == VersionType.EXTERNAL\n-                        || request.versionType() == VersionType.EXTERNAL_GTE)\n-                .map(DocWriteRequest::index)\n-                .collect(Collectors.toSet());\n+                    || request.versionType() == VersionType.EXTERNAL\n+                    || request.versionType() == VersionType.EXTERNAL_GTE)\n+                .collect(Collectors.toMap(DocWriteRequest::index, DocWriteRequest::isRequireAlias, (v1, v2) -> v1 && v2));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE2MzYwOQ=="}, "originalCommit": {"oid": "158403a9e7b252f20185dc195a89629c7657c854"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMjg3NDIwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/update/TransportUpdateAction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMTo1NDo0MFrOGuQ_cA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMTo1NDo0MFrOGuQ_cA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE2NjA2NA==", "bodyText": "Same comment here about making the error message a bit clearer", "url": "https://github.com/elastic/elasticsearch/pull/58917#discussion_r451166064", "createdAt": "2020-07-07T21:54:40Z", "author": {"login": "dakrone"}, "path": "server/src/main/java/org/elasticsearch/action/update/TransportUpdateAction.java", "diffHunk": "@@ -115,6 +119,9 @@ public static void resolveAndValidateRouting(Metadata metadata, String concreteI\n \n     @Override\n     protected void doExecute(Task task, final UpdateRequest request, final ActionListener<UpdateResponse> listener) {\n+        if (request.isRequireAlias() && (clusterService.state().getMetadata().hasAlias(request.index()) == false)) {\n+            throw new IndexNotFoundException(\"[\" + DocWriteRequest.REQUIRE_ALIAS + \"] request flag is [true]\", request.index());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "158403a9e7b252f20185dc195a89629c7657c854"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMjg3NzI4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/update/UpdateRequest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMTo1NTo1MVrOGuRBPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMTo1NTo1MVrOGuRBPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE2NjUyNA==", "bodyText": "I don't think we should make this parsed out of the body of the request, it should stay as a querystring parameter for the update request, but not in the actual xcontent", "url": "https://github.com/elastic/elasticsearch/pull/58917#discussion_r451166524", "createdAt": "2020-07-07T21:55:51Z", "author": {"login": "dakrone"}, "path": "server/src/main/java/org/elasticsearch/action/update/UpdateRequest.java", "diffHunk": "@@ -99,6 +100,7 @@\n             ObjectParser.ValueType.OBJECT_ARRAY_BOOLEAN_OR_STRING);\n         PARSER.declareLong(UpdateRequest::setIfSeqNo, IF_SEQ_NO);\n         PARSER.declareLong(UpdateRequest::setIfPrimaryTerm, IF_PRIMARY_TERM);\n+        PARSER.declareBoolean(UpdateRequest::setRequireAlias, REQUIRE_ALIAS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "158403a9e7b252f20185dc195a89629c7657c854"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMjg4NDA3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/reindex/ReindexRequest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMTo1ODowOVrOGuRFXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMTo1ODowOVrOGuRFXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE2NzU4Mg==", "bodyText": "I can kind of understand this parsing (more than the update request), but I don't like that we are parsing it out of the body here. I would prefer to only grab it from the querystring parameters, not from any request bodies", "url": "https://github.com/elastic/elasticsearch/pull/58917#discussion_r451167582", "createdAt": "2020-07-07T21:58:09Z", "author": {"login": "dakrone"}, "path": "server/src/main/java/org/elasticsearch/index/reindex/ReindexRequest.java", "diffHunk": "@@ -345,6 +357,7 @@ public XContentBuilder toXContent(XContentBuilder builder, Params params) throws\n         destParser.declareString(IndexRequest::routing, new ParseField(\"routing\"));\n         destParser.declareString(IndexRequest::opType, new ParseField(\"op_type\"));\n         destParser.declareString(IndexRequest::setPipeline, new ParseField(\"pipeline\"));\n+        destParser.declareBoolean(IndexRequest::setRequireAlias, new ParseField(DocWriteRequest.REQUIRE_ALIAS));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "158403a9e7b252f20185dc195a89629c7657c854"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMjg4ODA2OnYy", "diffSide": "RIGHT", "path": "rest-api-spec/src/main/resources/rest-api-spec/test/bulk/10_basic.yml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMTo1OTo0MlrOGuRH1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMTo1OTo0MlrOGuRH1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE2ODIxMg==", "bodyText": "I think in addition to specifying it on a per-operation basis, we need to support the require_alias parameter on the bulk API itself. Otherwise we require a client to add the flag 1000 times for 1000 different requests (even if they go to the same index)", "url": "https://github.com/elastic/elasticsearch/pull/58917#discussion_r451168212", "createdAt": "2020-07-07T21:59:42Z", "author": {"login": "dakrone"}, "path": "rest-api-spec/src/main/resources/rest-api-spec/test/bulk/10_basic.yml", "diffHunk": "@@ -116,3 +116,43 @@\n            {\"index\": {\"_index\": \"test_index\", \"_id\": \"test_id\"}}\n            {\"f1\": \"v1\", \"f2\": 42}\n            {}\n+\n+---\n+\"When setting require_alias flag\":\n+  - skip:\n+      # TODO adjust after backport\n+      version: \" - 7.99.99\"\n+      reason: \"require_alias flag was added in version 7.9\"\n+\n+  - do:\n+      indices.create:\n+        index: backing_index\n+        body:\n+          mappings: {}\n+          aliases:\n+            test_require_alias: {}\n+  - do:\n+      bulk:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "158403a9e7b252f20185dc195a89629c7657c854"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMjg5MTk3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/rest/action/document/RestIndexAction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMjowMDo1OVrOGuRKLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMjowMDo1OVrOGuRKLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE2ODgxMw==", "bodyText": "We need to add this in RestBulkAction also, and make it top-level rather than only allowing it per-operation", "url": "https://github.com/elastic/elasticsearch/pull/58917#discussion_r451168813", "createdAt": "2020-07-07T22:00:59Z", "author": {"login": "dakrone"}, "path": "server/src/main/java/org/elasticsearch/rest/action/document/RestIndexAction.java", "diffHunk": "@@ -122,6 +123,7 @@ public RestChannelConsumer prepareRequest(final RestRequest request, final NodeC\n         indexRequest.versionType(VersionType.fromString(request.param(\"version_type\"), indexRequest.versionType()));\n         indexRequest.setIfSeqNo(request.paramAsLong(\"if_seq_no\", indexRequest.ifSeqNo()));\n         indexRequest.setIfPrimaryTerm(request.paramAsLong(\"if_primary_term\", indexRequest.ifPrimaryTerm()));\n+        indexRequest.setRequireAlias(request.paramAsBoolean(DocWriteRequest.REQUIRE_ALIAS, indexRequest.isRequireAlias()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "158403a9e7b252f20185dc195a89629c7657c854"}, "originalPosition": 12}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2132, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}