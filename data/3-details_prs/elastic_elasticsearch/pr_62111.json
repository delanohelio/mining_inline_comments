{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDgyMTIyNTYz", "number": 62111, "title": "Async search: don't track fetch failures", "bodyText": "Fetch failures are currently tracked by AsyncSearchTask like ordinary shard failures. Though they should be treated differently or they end up causing weird scenarios like total=num_shards and successful=num_shards as the query phase ran fine yet the failed count would reflect the number of shards where fetch failed.\nGiven that partial results only include aggs for now and are complete even if fetch fails, we can ignore fetch failures in async search, as they will be anyways included in the response. They are in fact either received as a failure when all shards fail during fetch, or as part of the final response when only some shards fail during fetch.\nWe decided to make this change about 5 months ago here but I only got to it now.", "createdAt": "2020-09-08T15:21:02Z", "url": "https://github.com/elastic/elasticsearch/pull/62111", "merged": true, "mergeCommit": {"oid": "654f8baabc68a9618cdf9c8adcfbbb0ac0b6c72c"}, "closed": true, "closedAt": "2020-09-09T08:17:41Z", "author": {"login": "javanna"}, "timelineItems": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdG5KgrgH2gAyNDgyMTIyNTYzOjY1MmI1ZDVjNTk3MTg2NzFmZDEyZjI0NDI0MjRlMjc3ODE3NDliNjY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdHHLnuAH2gAyNDgyMTIyNTYzOjZiYzkwODI4NTQ0ZmFmMjNhMjhjMWMwNTg2NjAxMTNmMmIwMzM2N2Q=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "652b5d5c59718671fd12f2442424e27781749b66", "author": {"user": {"login": "javanna", "name": "Luca Cavanna"}}, "url": "https://github.com/elastic/elasticsearch/commit/652b5d5c59718671fd12f2442424e27781749b66", "committedDate": "2020-09-08T15:16:51Z", "message": "Async search: don't track fetch failures\n\nFetch failures are currently tracked byy AsyncSearchTask like ordinary shard failures. Though they should be treated differently or they end up causing weird scenarios like total=num_shards and successful=num_shards as the query phase ran fine yet the failed count would reflect the number of shards where fetch failed.\n\nGiven that partial results only include aggs for now and are complete even if fetch fails, we can ignore fetch failures in async search, as they will be anyways included in the response. They are in fact either received as a failure when all shards fail during fetch, or as part of the final response when only some shards fail during fetch."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e436e5d8a0c058d017521f2336151f43097c69ac", "author": {"user": {"login": "javanna", "name": "Luca Cavanna"}}, "url": "https://github.com/elastic/elasticsearch/commit/e436e5d8a0c058d017521f2336151f43097c69ac", "committedDate": "2020-09-08T16:09:43Z", "message": "adjust AsyncSearchTaskTests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0NDQzMzY5", "url": "https://github.com/elastic/elasticsearch/pull/62111#pullrequestreview-484443369", "createdAt": "2020-09-08T19:46:30Z", "commit": {"oid": "e436e5d8a0c058d017521f2336151f43097c69ac"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxOTo0NjozMVrOHOrnSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxOTo1MjoyMFrOHOry_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE1NjY4MQ==", "bodyText": "Can we keep the name as is for now. I understand that we want to call it query failures after this change but we may also want to provide a way to return partial top hits in the future. My point being that we might reintroduce fetch failures when they make sense.", "url": "https://github.com/elastic/elasticsearch/pull/62111#discussion_r485156681", "createdAt": "2020-09-08T19:46:31Z", "author": {"login": "jimczi"}, "path": "x-pack/plugin/async-search/src/main/java/org/elasticsearch/xpack/search/MutableSearchResponse.java", "diffHunk": "@@ -35,7 +35,7 @@\n     private final int totalShards;\n     private final int skippedShards;\n     private final Clusters clusters;\n-    private final AtomicArray<ShardSearchFailure> shardFailures;\n+    private final AtomicArray<ShardSearchFailure> queryFailures;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e436e5d8a0c058d017521f2336151f43097c69ac"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE1OTY3Nw==", "bodyText": "nit: you could derive it from the index name instead ?", "url": "https://github.com/elastic/elasticsearch/pull/62111#discussion_r485159677", "createdAt": "2020-09-08T19:52:20Z", "author": {"login": "jimczi"}, "path": "x-pack/plugin/async-search/src/test/java/org/elasticsearch/xpack/search/AsyncSearchSingleNodeTests.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.search;\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.elasticsearch.ElasticsearchStatusException;\n+import org.elasticsearch.action.admin.indices.refresh.RefreshRequest;\n+import org.elasticsearch.action.index.IndexRequest;\n+import org.elasticsearch.action.index.IndexResponse;\n+import org.elasticsearch.action.search.SearchPhaseExecutionException;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.action.search.ShardSearchFailure;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.plugins.SearchPlugin;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.search.aggregations.bucket.terms.StringTerms;\n+import org.elasticsearch.search.aggregations.bucket.terms.TermsAggregationBuilder;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.elasticsearch.search.fetch.FetchSubPhase;\n+import org.elasticsearch.search.fetch.FetchSubPhaseProcessor;\n+import org.elasticsearch.test.ESSingleNodeTestCase;\n+import org.elasticsearch.xpack.core.search.action.AsyncSearchResponse;\n+import org.elasticsearch.xpack.core.search.action.SubmitAsyncSearchAction;\n+import org.elasticsearch.xpack.core.search.action.SubmitAsyncSearchRequest;\n+import org.hamcrest.CoreMatchers;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+\n+public class AsyncSearchSingleNodeTests extends ESSingleNodeTestCase {\n+\n+    @Override\n+    protected Collection<Class<? extends Plugin>> getPlugins() {\n+        return List.of(AsyncSearch.class, SubFetchPhasePlugin.class);\n+    }\n+\n+    public void testFetchFailuresAllShards() throws Exception {\n+        for (int i = 0; i < 10; i++) {\n+            IndexResponse indexResponse = client().index(new IndexRequest(\"boom\" + i).id(\"boom\" + i).source(\"text\", \"value\")).get();\n+            assertEquals(RestStatus.CREATED, indexResponse.status());\n+        }\n+        client().admin().indices().refresh(new RefreshRequest()).get();\n+\n+        TermsAggregationBuilder agg = new TermsAggregationBuilder(\"text\").field(\"text.keyword\");\n+        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder().aggregation(agg);\n+        SubmitAsyncSearchRequest submitAsyncSearchRequest = new SubmitAsyncSearchRequest(sourceBuilder);\n+        submitAsyncSearchRequest.setWaitForCompletionTimeout(TimeValue.timeValueSeconds(10));\n+        AsyncSearchResponse asyncSearchResponse = client().execute(SubmitAsyncSearchAction.INSTANCE, submitAsyncSearchRequest).actionGet();\n+\n+        assertFalse(asyncSearchResponse.isRunning());\n+        assertTrue(asyncSearchResponse.isPartial());\n+        SearchResponse searchResponse = asyncSearchResponse.getSearchResponse();\n+        assertEquals(10, searchResponse.getTotalShards());\n+        assertEquals(10, searchResponse.getSuccessfulShards());\n+        assertEquals(0, searchResponse.getFailedShards());\n+        assertEquals(0, searchResponse.getShardFailures().length);\n+        assertEquals(10, searchResponse.getHits().getTotalHits().value);\n+        assertEquals(0, searchResponse.getHits().getHits().length);\n+        StringTerms terms = searchResponse.getAggregations().get(\"text\");\n+        assertEquals(1, terms.getBuckets().size());\n+        assertEquals(10, terms.getBucketByKey(\"value\").getDocCount());\n+        assertNotNull(asyncSearchResponse.getFailure());\n+        assertThat(asyncSearchResponse.getFailure(), CoreMatchers.instanceOf(ElasticsearchStatusException.class));\n+        ElasticsearchStatusException statusException = (ElasticsearchStatusException) asyncSearchResponse.getFailure();\n+        assertEquals(RestStatus.INTERNAL_SERVER_ERROR, statusException.status());\n+        assertThat(asyncSearchResponse.getFailure().getCause(), CoreMatchers.instanceOf(SearchPhaseExecutionException.class));\n+        SearchPhaseExecutionException phaseExecutionException = (SearchPhaseExecutionException) asyncSearchResponse.getFailure().getCause();\n+        assertEquals(\"fetch\", phaseExecutionException.getPhaseName());\n+        assertEquals(\"boom\", phaseExecutionException.getCause().getMessage());\n+        assertEquals(10, phaseExecutionException.shardFailures().length);\n+        for (ShardSearchFailure shardSearchFailure : phaseExecutionException.shardFailures()) {\n+            assertEquals(\"boom\", shardSearchFailure.getCause().getMessage());\n+        }\n+    }\n+\n+    public void testFetchFailuresOnlySomeShards() throws Exception {\n+        for (int i = 0; i < 5; i++) {\n+            IndexResponse indexResponse = client().index(new IndexRequest(\"boom\" + i).id(\"boom\" + i).source(\"text\", \"value\")).get();\n+            assertEquals(RestStatus.CREATED, indexResponse.status());\n+        }\n+        for (int i = 0; i < 5; i++) {\n+            IndexResponse indexResponse = client().index(new IndexRequest(\"index\" + i).id(\"index\" + i).source(\"text\", \"value\")).get();\n+            assertEquals(RestStatus.CREATED, indexResponse.status());\n+        }\n+        client().admin().indices().refresh(new RefreshRequest()).get();\n+\n+        TermsAggregationBuilder agg = new TermsAggregationBuilder(\"text\").field(\"text.keyword\");\n+        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder().aggregation(agg);\n+        SubmitAsyncSearchRequest submitAsyncSearchRequest = new SubmitAsyncSearchRequest(sourceBuilder);\n+        submitAsyncSearchRequest.setWaitForCompletionTimeout(TimeValue.timeValueSeconds(10));\n+        AsyncSearchResponse asyncSearchResponse = client().execute(SubmitAsyncSearchAction.INSTANCE, submitAsyncSearchRequest).actionGet();\n+\n+        assertFalse(asyncSearchResponse.isRunning());\n+        assertFalse(asyncSearchResponse.isPartial());\n+        assertNull(asyncSearchResponse.getFailure());\n+        SearchResponse searchResponse = asyncSearchResponse.getSearchResponse();\n+        assertEquals(10, searchResponse.getTotalShards());\n+        assertEquals(5, searchResponse.getSuccessfulShards());\n+        assertEquals(5, searchResponse.getFailedShards());\n+        assertEquals(10, searchResponse.getHits().getTotalHits().value);\n+        assertEquals(5, searchResponse.getHits().getHits().length);\n+        StringTerms terms = searchResponse.getAggregations().get(\"text\");\n+        assertEquals(1, terms.getBuckets().size());\n+        assertEquals(10, terms.getBucketByKey(\"value\").getDocCount());\n+        assertEquals(5, searchResponse.getShardFailures().length);\n+        for (ShardSearchFailure shardFailure : searchResponse.getShardFailures()) {\n+            assertEquals(\"boom\", shardFailure.getCause().getMessage());\n+        }\n+    }\n+\n+    public static final class SubFetchPhasePlugin extends Plugin implements SearchPlugin {\n+        @Override\n+        public List<FetchSubPhase> getFetchSubPhases(FetchPhaseConstructionContext context) {\n+            return Collections.singletonList(searchContext -> new FetchSubPhaseProcessor() {\n+                @Override\n+                public void setNextReader(LeafReaderContext readerContext) {}\n+\n+                @Override\n+                public void process(FetchSubPhase.HitContext hitContext) {\n+                    if (hitContext.hit().getId().startsWith(\"boom\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e436e5d8a0c058d017521f2336151f43097c69ac"}, "originalPosition": 126}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6bc90828544faf23a28c1c058660113f2b03367d", "author": {"user": {"login": "javanna", "name": "Luca Cavanna"}}, "url": "https://github.com/elastic/elasticsearch/commit/6bc90828544faf23a28c1c058660113f2b03367d", "committedDate": "2020-09-09T07:36:44Z", "message": "Merge branch 'master' into enhancement/async_search_fetch_failures"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4783, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}