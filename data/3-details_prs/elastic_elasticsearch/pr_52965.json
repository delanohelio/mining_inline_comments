{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgxNTA5Njk1", "number": 52965, "title": "Support multiple metrics in `top_metrics` agg", "bodyText": "This adds support for returning multiple metrics to the top_metrics\nagg. It looks like:\nPOST /test/_search?filter_path=aggregations\n{\n  \"aggs\": {\n    \"tm\": {\n      \"top_metrics\": {\n        \"metrics\": [\n          {\"field\": \"v\"},\n          {\"field\": \"m\"}\n        ],\n        \"sort\": {\"s\": \"desc\"}\n      }\n    }\n  }\n}\n\nRelates to #51813.", "createdAt": "2020-02-28T17:35:05Z", "url": "https://github.com/elastic/elasticsearch/pull/52965", "merged": true, "mergeCommit": {"oid": "56058ab6af9cba48b9f7812ef8899e27b3046a4f"}, "closed": true, "closedAt": "2020-03-05T11:53:38Z", "author": {"login": "nik9000"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcIzSnVAH2gAyMzgxNTA5Njk1OmNkYjc3NjA5OGJhYTc0YmVlYzIwMzMwYTVkNTMyYTgyYjY1ZDhiYzY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcKeu2bgFqTM2OTE3NDA5NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "cdb776098baa74beec20330a5d532a82b65d8bc6", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/cdb776098baa74beec20330a5d532a82b65d8bc6", "committedDate": "2020-02-28T17:22:58Z", "message": "Support multiple metrics in `top_metrics` agg\n\nThis adds support for returning multiple metrics to the `top_metrics`\nagg. It looks like:\n```\nPOST /test/_search?filter_path=aggregations\n{\n  \"aggs\": {\n    \"tm\": {\n      \"top_metrics\": {\n        \"metrics\": [\n          {\"field\": \"v\"},\n          {\"field\": \"m\"}\n        ],\n        \"sort\": {\"s\": \"desc\"}\n      }\n    }\n  }\n}\n```"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ce163a69f1475961e28e5f21fcbda876a70fc5ea", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/ce163a69f1475961e28e5f21fcbda876a70fc5ea", "committedDate": "2020-02-28T18:22:48Z", "message": "Ooops"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4OTg2NzYx", "url": "https://github.com/elastic/elasticsearch/pull/52965#pullrequestreview-368986761", "createdAt": "2020-03-04T17:42:41Z", "commit": {"oid": "ce163a69f1475961e28e5f21fcbda876a70fc5ea"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNzo0Mjo0MlrOFx3H7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxODoyNjoyM1rOFx4jug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgyNzY5NA==", "bodyText": "Would be nice to have at least one example of what the output looks like for multiple metrics.  From the other examples, it looks like the metrics return value will always be a map keyed by the field names we're selecting, but I didn't see a place where we actually say that, and it's not 100% clear to me what we get back for multiple metrics.", "url": "https://github.com/elastic/elasticsearch/pull/52965#discussion_r387827694", "createdAt": "2020-03-04T17:42:42Z", "author": {"login": "not-napoleon"}, "path": "docs/reference/aggregations/metrics/top-metrics-aggregation.asciidoc", "diffHunk": "@@ -68,11 +68,40 @@ request. So,\n NOTE: This aggregation doesn't support any sort of \"tie breaking\". If two documents have\n the same sort values then this aggregation could return either document's fields.\n \n-==== `metric`\n+==== `metrics`\n \n-At this point `metric` supports only `{\"field\": \"field_name\"}` and all metrics\n-are returned as double precision floating point numbers. Expect more to\n-come here.\n+`metrics` selects the fields to of the \"top\" document to return. Like most other\n+aggregations, `top_metrics` casts these values cast to `double` precision\n+floating point numbers. So they have to be numeric. Dates *work*, but they\n+come back as a `double` precision floating point containing milliseconds since\n+epoch. `keyword` fields aren't allowed.\n+\n+You can return multiple metrics by providing a list:\n+\n+[source,console,id=search-aggregations-metrics-top-metrics-list-of-metrics]\n+----\n+POST /test/_bulk?refresh\n+{\"index\": {}}\n+{\"s\": 1, \"v\": 3.1415, \"m\": 1.9}\n+{\"index\": {}}\n+{\"s\": 2, \"v\": 1.0, \"m\": 6.7}\n+{\"index\": {}}\n+{\"s\": 3, \"v\": 2.71828, \"m\": -12.2}\n+POST /test/_search?filter_path=aggregations\n+{\n+  \"aggs\": {\n+    \"tm\": {\n+      \"top_metrics\": {\n+        \"metrics\": [\n+          {\"field\": \"v\"},\n+          {\"field\": \"m\"}\n+        ],\n+        \"sort\": {\"s\": \"desc\"}\n+      }\n+    }\n+  }\n+}\n+----", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce163a69f1475961e28e5f21fcbda876a70fc5ea"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgzMDI4Ng==", "bodyText": "so, to be clear, the metrics parameter can be either an object or an array of objects?  Is an array with a single value the same as just passing one object?  I'm a little uncomfortable about dual natured json fields.  Is there any reason to not always make metrics an array?", "url": "https://github.com/elastic/elasticsearch/pull/52965#discussion_r387830286", "createdAt": "2020-03-04T17:47:21Z", "author": {"login": "not-napoleon"}, "path": "docs/reference/aggregations/metrics/top-metrics-aggregation.asciidoc", "diffHunk": "@@ -92,7 +121,7 @@ POST /test/_search?filter_path=aggregations\n   \"aggs\": {\n     \"tm\": {\n       \"top_metrics\": {\n-        \"metric\": {\"field\": \"v\"},\n+        \"metrics\": {\"field\": \"v\"},", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce163a69f1475961e28e5f21fcbda876a70fc5ea"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgzMzE4NQ==", "bodyText": "Just checking, again, that there are still no released versions of the serialization format, and thus changing it here is safe?", "url": "https://github.com/elastic/elasticsearch/pull/52965#discussion_r387833185", "createdAt": "2020-03-04T17:52:50Z", "author": {"login": "not-napoleon"}, "path": "x-pack/plugin/analytics/src/main/java/org/elasticsearch/xpack/analytics/topmetrics/InternalTopMetrics.java", "diffHunk": "@@ -55,15 +59,15 @@ static InternalTopMetrics buildEmptyAggregation(String name, String metricField,\n     public InternalTopMetrics(StreamInput in) throws IOException {\n         super(in);\n         sortOrder = SortOrder.readFromStream(in);\n-        metricName = in.readString();\n+        metricNames = in.readStringList();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce163a69f1475961e28e5f21fcbda876a70fc5ea"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgzNjM4MQ==", "bodyText": "I don't understand what this error message means.   Should it read \"Unknown metric...\"?", "url": "https://github.com/elastic/elasticsearch/pull/52965#discussion_r387836381", "createdAt": "2020-03-04T17:58:35Z", "author": {"login": "not-napoleon"}, "path": "x-pack/plugin/analytics/src/main/java/org/elasticsearch/xpack/analytics/topmetrics/InternalTopMetrics.java", "diffHunk": "@@ -128,37 +136,38 @@ public boolean isMapped() {\n     public XContentBuilder doXContentBody(XContentBuilder builder, Params params) throws IOException {\n         builder.startArray(\"top\");\n         for (TopMetric top : topMetrics) {\n-            top.toXContent(builder, metricName);\n+            top.toXContent(builder, metricNames);\n         }\n         builder.endArray();\n         return builder;\n     }\n \n     @Override\n     public int hashCode() {\n-        return Objects.hash(super.hashCode(), sortOrder, metricName, size, topMetrics);\n+        return Objects.hash(super.hashCode(), sortOrder, metricNames, size, topMetrics);\n     }\n \n     @Override\n     public boolean equals(Object obj) {\n         if (super.equals(obj) == false) return false;\n         InternalTopMetrics other = (InternalTopMetrics) obj;\n         return sortOrder.equals(other.sortOrder) &&\n-            metricName.equals(other.metricName) &&\n+            metricNames.equals(other.metricNames) &&\n             size == other.size &&\n             topMetrics.equals(other.topMetrics);\n     }\n \n     @Override\n     public double value(String name) {\n-        if (metricName.equals(name)) {\n-            if (topMetrics.isEmpty()) {\n-                return Double.NaN;\n-            }\n-            assert topMetrics.size() == 1 : \"property paths should only resolve against top metrics with size == 1.\";\n-            return topMetrics.get(0).metricValue;\n+        int index = metricNames.indexOf(name);\n+        if (index < 0) {\n+            throw new IllegalArgumentException(\"known metric [\" + name + \"]\");            ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce163a69f1475961e28e5f21fcbda876a70fc5ea"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgzOTgwOQ==", "bodyText": "Can you expand on this a bit, and/or open a ticket for it? Feel free to ignore this comment if you're planing to resolve this TODO soon, but I'm worried that if we find this again in a few months we won't remember what it is we intended to do here.\nAlso, it looks like later on, we just turn this into a list of ValuesSourceConfig.  Why not just start with ValuesSourceConfig at this point?", "url": "https://github.com/elastic/elasticsearch/pull/52965#discussion_r387839809", "createdAt": "2020-03-04T18:05:11Z", "author": {"login": "not-napoleon"}, "path": "x-pack/plugin/analytics/src/main/java/org/elasticsearch/xpack/analytics/topmetrics/TopMetricsAggregationBuilder.java", "diffHunk": "@@ -47,34 +47,35 @@\n                 if (size < 1) {\n                     throw new IllegalArgumentException(\"[size] must be more than 0 but was [\" + size + \"]\");\n                 }\n-                MultiValuesSourceFieldConfig metricField = (MultiValuesSourceFieldConfig) args[2];\n-                return new TopMetricsAggregationBuilder(name, sorts, size, metricField);\n+                @SuppressWarnings(\"unchecked\")\n+                List<MultiValuesSourceFieldConfig> metricFields = (List<MultiValuesSourceFieldConfig>) args[2];\n+                return new TopMetricsAggregationBuilder(name, sorts, size, metricFields);\n             });\n     static {\n         PARSER.declareField(constructorArg(), (p, n) -> SortBuilder.fromXContent(p), SORT_FIELD,\n                 ObjectParser.ValueType.OBJECT_ARRAY_OR_STRING);\n         PARSER.declareInt(optionalConstructorArg(), SIZE_FIELD);\n         ContextParser<Void, MultiValuesSourceFieldConfig.Builder> metricParser = MultiValuesSourceFieldConfig.PARSER.apply(true, false);\n-        PARSER.declareObject(constructorArg(), (p, n) -> metricParser.parse(p, null).build(), METRIC_FIELD);\n+        PARSER.declareObjectArray(constructorArg(), (p, n) -> metricParser.parse(p, null).build(), METRIC_FIELD);\n     }\n \n     private final List<SortBuilder<?>> sortBuilders;\n-    // TODO MultiValuesSourceFieldConfig has more things than we support and less things than we want to support\n     private final int size;\n-    private final MultiValuesSourceFieldConfig metricField;\n+    private final List<MultiValuesSourceFieldConfig> metricFields;\n+    // TODO MultiValuesSourceFieldConfig has more things than we support and less things than we want to support", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce163a69f1475961e28e5f21fcbda876a70fc5ea"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg0NDkyMQ==", "bodyText": "Does ValuesSourceConfig#resolve actually return null in some cases? I didn't see a path that would cause that.  Or is this just being defensive?", "url": "https://github.com/elastic/elasticsearch/pull/52965#discussion_r387844921", "createdAt": "2020-03-04T18:14:43Z", "author": {"login": "not-napoleon"}, "path": "x-pack/plugin/analytics/src/main/java/org/elasticsearch/xpack/analytics/topmetrics/TopMetricsAggregator.java", "diffHunk": "@@ -117,41 +117,122 @@ public void setScorer(Scorable s) throws IOException {\n \n     @Override\n     public InternalAggregation buildAggregation(long bucket) throws IOException {\n-        if (metricValueSource == null) {\n-            return buildEmptyAggregation();\n-        }\n-        List<InternalTopMetrics.TopMetric> topMetrics = sort.getValues(bucket, values.resultBuilder(sort.getFormat()));\n+        List<InternalTopMetrics.TopMetric> topMetrics = sort.getValues(bucket, metrics.resultBuilder(sort.getFormat()));\n         assert topMetrics.size() <= size;\n-        return new InternalTopMetrics(name, sort.getOrder(), metricName, size, topMetrics, pipelineAggregators(), metaData());\n+        return new InternalTopMetrics(name, sort.getOrder(), metrics.names, size, topMetrics, pipelineAggregators(), metaData());\n     }\n \n     @Override\n     public InternalTopMetrics buildEmptyAggregation() {\n-        // The sort format and sort order aren't used in reduction so we pass the simplest thing.\n-        return InternalTopMetrics.buildEmptyAggregation(name, metricName, pipelineAggregators(),\n-                metaData());\n+        return InternalTopMetrics.buildEmptyAggregation(name, metrics.names, pipelineAggregators(), metaData());\n     }\n \n     @Override\n     public void doClose() {\n-        Releasables.close(sort, values);\n+        Releasables.close(sort, metrics);\n+    }\n+\n+    private static class Metrics implements BucketedSort.ExtraData, Releasable {\n+        private final List<String> names;\n+        private final MetricValues[] values;\n+\n+        Metrics(int size, QueryShardContext ctx, List<MultiValuesSourceFieldConfig> fieldsConfig) {\n+            names = fieldsConfig.stream().map(MultiValuesSourceFieldConfig::getFieldName).collect(toList());\n+            values = new MetricValues[fieldsConfig.size()];\n+            int i = 0;\n+            for (MultiValuesSourceFieldConfig config : fieldsConfig) {\n+                ValuesSourceConfig<ValuesSource.Numeric> resolved = ValuesSourceConfig.resolve(ctx, ValueType.NUMERIC,\n+                        config.getFieldName(), config.getScript(), config.getMissing(), config.getTimeZone(), null);\n+                if (resolved == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce163a69f1475961e28e5f21fcbda876a70fc5ea"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg0NTM0Mw==", "bodyText": "Be aware that this can throw on invalid configs (i.e. configs containing neither a script nor a field)", "url": "https://github.com/elastic/elasticsearch/pull/52965#discussion_r387845343", "createdAt": "2020-03-04T18:15:30Z", "author": {"login": "not-napoleon"}, "path": "x-pack/plugin/analytics/src/main/java/org/elasticsearch/xpack/analytics/topmetrics/TopMetricsAggregator.java", "diffHunk": "@@ -117,41 +117,122 @@ public void setScorer(Scorable s) throws IOException {\n \n     @Override\n     public InternalAggregation buildAggregation(long bucket) throws IOException {\n-        if (metricValueSource == null) {\n-            return buildEmptyAggregation();\n-        }\n-        List<InternalTopMetrics.TopMetric> topMetrics = sort.getValues(bucket, values.resultBuilder(sort.getFormat()));\n+        List<InternalTopMetrics.TopMetric> topMetrics = sort.getValues(bucket, metrics.resultBuilder(sort.getFormat()));\n         assert topMetrics.size() <= size;\n-        return new InternalTopMetrics(name, sort.getOrder(), metricName, size, topMetrics, pipelineAggregators(), metaData());\n+        return new InternalTopMetrics(name, sort.getOrder(), metrics.names, size, topMetrics, pipelineAggregators(), metaData());\n     }\n \n     @Override\n     public InternalTopMetrics buildEmptyAggregation() {\n-        // The sort format and sort order aren't used in reduction so we pass the simplest thing.\n-        return InternalTopMetrics.buildEmptyAggregation(name, metricName, pipelineAggregators(),\n-                metaData());\n+        return InternalTopMetrics.buildEmptyAggregation(name, metrics.names, pipelineAggregators(), metaData());\n     }\n \n     @Override\n     public void doClose() {\n-        Releasables.close(sort, values);\n+        Releasables.close(sort, metrics);\n+    }\n+\n+    private static class Metrics implements BucketedSort.ExtraData, Releasable {\n+        private final List<String> names;\n+        private final MetricValues[] values;\n+\n+        Metrics(int size, QueryShardContext ctx, List<MultiValuesSourceFieldConfig> fieldsConfig) {\n+            names = fieldsConfig.stream().map(MultiValuesSourceFieldConfig::getFieldName).collect(toList());\n+            values = new MetricValues[fieldsConfig.size()];\n+            int i = 0;\n+            for (MultiValuesSourceFieldConfig config : fieldsConfig) {\n+                ValuesSourceConfig<ValuesSource.Numeric> resolved = ValuesSourceConfig.resolve(ctx, ValueType.NUMERIC,\n+                        config.getFieldName(), config.getScript(), config.getMissing(), config.getTimeZone(), null);\n+                if (resolved == null) {\n+                    values[i++] = new MissingMetricValues();\n+                    continue;\n+                }\n+                ValuesSource.Numeric valuesSource = resolved.toValuesSource(ctx);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce163a69f1475961e28e5f21fcbda876a70fc5ea"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg1MTE5NA==", "bodyText": "This seems late in the game to be resolving values sources.  Usually we do that at the border between the builder and the factory, and pass the values source(s) into the aggregator.  If it has to be this way, let's at least leave a comment as to why that's the case, please.", "url": "https://github.com/elastic/elasticsearch/pull/52965#discussion_r387851194", "createdAt": "2020-03-04T18:26:23Z", "author": {"login": "not-napoleon"}, "path": "x-pack/plugin/analytics/src/main/java/org/elasticsearch/xpack/analytics/topmetrics/TopMetricsAggregator.java", "diffHunk": "@@ -117,41 +117,122 @@ public void setScorer(Scorable s) throws IOException {\n \n     @Override\n     public InternalAggregation buildAggregation(long bucket) throws IOException {\n-        if (metricValueSource == null) {\n-            return buildEmptyAggregation();\n-        }\n-        List<InternalTopMetrics.TopMetric> topMetrics = sort.getValues(bucket, values.resultBuilder(sort.getFormat()));\n+        List<InternalTopMetrics.TopMetric> topMetrics = sort.getValues(bucket, metrics.resultBuilder(sort.getFormat()));\n         assert topMetrics.size() <= size;\n-        return new InternalTopMetrics(name, sort.getOrder(), metricName, size, topMetrics, pipelineAggregators(), metaData());\n+        return new InternalTopMetrics(name, sort.getOrder(), metrics.names, size, topMetrics, pipelineAggregators(), metaData());\n     }\n \n     @Override\n     public InternalTopMetrics buildEmptyAggregation() {\n-        // The sort format and sort order aren't used in reduction so we pass the simplest thing.\n-        return InternalTopMetrics.buildEmptyAggregation(name, metricName, pipelineAggregators(),\n-                metaData());\n+        return InternalTopMetrics.buildEmptyAggregation(name, metrics.names, pipelineAggregators(), metaData());\n     }\n \n     @Override\n     public void doClose() {\n-        Releasables.close(sort, values);\n+        Releasables.close(sort, metrics);\n+    }\n+\n+    private static class Metrics implements BucketedSort.ExtraData, Releasable {\n+        private final List<String> names;\n+        private final MetricValues[] values;\n+\n+        Metrics(int size, QueryShardContext ctx, List<MultiValuesSourceFieldConfig> fieldsConfig) {\n+            names = fieldsConfig.stream().map(MultiValuesSourceFieldConfig::getFieldName).collect(toList());\n+            values = new MetricValues[fieldsConfig.size()];\n+            int i = 0;\n+            for (MultiValuesSourceFieldConfig config : fieldsConfig) {\n+                ValuesSourceConfig<ValuesSource.Numeric> resolved = ValuesSourceConfig.resolve(ctx, ValueType.NUMERIC,\n+                        config.getFieldName(), config.getScript(), config.getMissing(), config.getTimeZone(), null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce163a69f1475961e28e5f21fcbda876a70fc5ea"}, "originalPosition": 137}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "09cdff0734ab6e7a38b6735c95c7f4a3d6cf570f", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/09cdff0734ab6e7a38b6735c95c7f4a3d6cf570f", "committedDate": "2020-03-04T21:47:48Z", "message": "Merge branch 'master' into top_metrics_many"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "537459a4a8310044fb55c4491b96bf70b4acfa0a", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/537459a4a8310044fb55c4491b96bf70b4acfa0a", "committedDate": "2020-03-04T21:59:34Z", "message": "Update from comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8dd3b36e63dd422e32ff6d0afdac20cd42eff4f8", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/8dd3b36e63dd422e32ff6d0afdac20cd42eff4f8", "committedDate": "2020-03-04T22:06:31Z", "message": "Merge branch 'master' into top_metrics_many"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5MTc0MDk0", "url": "https://github.com/elastic/elasticsearch/pull/52965#pullrequestreview-369174094", "createdAt": "2020-03-04T22:33:39Z", "commit": {"oid": "8dd3b36e63dd422e32ff6d0afdac20cd42eff4f8"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1866, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}