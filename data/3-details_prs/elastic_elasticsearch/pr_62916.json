{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkzNTU5MDk0", "number": 62916, "title": "Introduce new audit record for security configuration changes via API", "bodyText": "This PR introduces a new event.type category for audit records, namely the security_config_change, in the existing audit trail . Events in this category record that a security configuration has been set (eg user/role created/updated) or cleared (eg user/role deleted). The events are emitted by default, but can be explicitly toggled by the security_config_changed handler. The record contains all the change details, (e.g. the rules of the particular role mapping that has been created or updated), but all credentials are redacted out. The change details are formatted as a JSON object are are part of audit record structure (i.e. they are not JSON-escaped and put in a string field).\nSample audit log output:\n{\"type\":\"audit\", \"timestamp\":\"2020-09-26T12:58:13,369+0300\", \"node.id\":\"6BXu_9j6QPK7jvmOwzxqLQ\", \"event.type\":\"transport\", \"event.action\":\"access_granted\", \"user.name\":\"elastic\", \"user.realm\":\"reserved\", \"user.roles\":[\"superuser\"], \"origin.type\":\"rest\", \"authentication.type\":\"REALM\", \"origin.address\":\"[::1]:50481\", \"request.id\":\"JLr1ftaoTuODAUZl-8g4Bg\", \"request.name\":\"PutUserRequest\"}\n{\"type\":\"audit\", \"timestamp\":\"2020-09-26T12:58:13,370+0300\", \"node.id\":\"6BXu_9j6QPK7jvmOwzxqLQ\", \"event.type\":\"security_config_change\", \"event.action\":\"put\", \"request.id\":\"JLr1ftaoTuODAUZl-8g4Bg\", \"config_change\":{\"put_user\":{\"username\":\"test_user2\",\"roles\":[\"superuser\"],\"full_name\":\"Jack Nicholson\",\"email\":\"jacknich@example.com\",\"metadata\":{\"intelligence\":7},\"enabled\":true,\"password_hash\":\"<redacted>\"}}}\n{\"type\":\"audit\", \"timestamp\":\"2020-09-26T12:58:52,954+0300\", \"node.id\":\"6BXu_9j6QPK7jvmOwzxqLQ\", \"event.type\":\"transport\", \"event.action\":\"access_granted\", \"user.name\":\"elastic\", \"user.realm\":\"reserved\", \"user.roles\":[\"superuser\"], \"origin.type\":\"rest\", \"authentication.type\":\"REALM\", \"origin.address\":\"[::1]:50482\", \"request.id\":\"i2XtJLCoRheGuwUdCXjDJw\", \"request.name\":\"PutRoleRequest\"}\n{\"type\":\"audit\", \"timestamp\":\"2020-09-26T12:58:52,955+0300\", \"node.id\":\"6BXu_9j6QPK7jvmOwzxqLQ\", \"event.type\":\"security_config_change\", \"event.action\":\"put\", \"request.id\":\"i2XtJLCoRheGuwUdCXjDJw\", \"config_change\":{\"put_role\":{\"name\":\"role_fls\",\"cluster_privileges\":[\"all\"],\"run_as\":[],\"indices_privileges\":[{\"names\":[\"apm*\"],\"privileges\":[\"read\"],\"field_security\":{\"grant\":[\"granted\"]},\"query\":\"{\\\"term\\\": {\\\"service.name\\\": \\\"bar\\\"}}\",\"allow_restricted_indices\":false},{\"names\":[\"apm-all*\"],\"privileges\":[\"all\"],\"query\":\"{\\\"term\\\": {\\\"service.name\\\": \\\"bar2\\\"}}\",\"allow_restricted_indices\":false}],\"application_privileges\":[],\"metadata\":{},\"configurable_cluster_privileges\":{}}}}\n\nNotes:\n\nAPI key ids are not currently audited (but the name is). I'll open a prerequisite PR to enable that, and then adjust this (or open a follow-up PR)\nThe request.id field of the new audit record for the security change refers back to the security transport action, which is different from the request.id of the REST action that triggered it all. This will be addressed in another PR.\n\n\nOutstanding questions:\n\nShould we move the new event type to another output file? I believe the new record blends relatively well, and it simplifies the admin operations to have only one audit file per node. But arguments can be made that the new event uses a nested-JSON structure, unlike the others. Unfortunately a flat JSON is not an option, as the change body contains lists of objects (eg a role with a list of index permissions), and escaping the JSON body as a string hurts readability IMO (JSON is not the best at user friendly presentations alone, even more if we have to escape every quote).\nDo we need differentiated behaviour between the different types of credentials: ES tokens, kerberos tickets, ES passwords, and ES password hashes? Currently they are all redacted out (instead of the value, the audited field contains the <redacted> placeholder.\nThis records the creation of ES tokens too. Although not technically a true configuration, tokens are similar to API keys with expiration dates, and API keys are similar to users, hence I've made the decision to audit ALL such credential creation in order to avoid admin user confusion and line-drawing arguments. The question then is: should we audit tokens created for a successful SAML/OIDC authentication? These don't fit at all as \"configuration changes\". How about tokens created following the delegated PKI authentication?\n\nOverrides #62740", "createdAt": "2020-09-26T10:25:20Z", "url": "https://github.com/elastic/elasticsearch/pull/62916", "merged": true, "mergeCommit": {"oid": "22fed6814004dd5824f749c080068bdfcd7ba7fb"}, "closed": true, "closedAt": "2020-12-15T10:10:06Z", "author": {"login": "albertzaharovits"}, "timelineItems": {"totalCount": 96, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdL9Ry_gH2gAyNDkzNTU5MDk0Ojg0NDA3Nzk5ODMzNDllN2Y2OGQ2ZjQ0ODMxYjlmNjlkZDA1MzBjMDY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdmV4ebgH2gAyNDkzNTU5MDk0OjI1MmIxNzBlNDI3NTU2MDljNjM1NTU0OGY3ZWQwOTU4OWEyNDY0ZmI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "8440779983349e7f68d6f44831b9f69dd0530c06", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/8440779983349e7f68d6f44831b9f69dd0530c06", "committedDate": "2020-09-24T08:54:03Z", "message": "SomeRequests to XContent"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7240823dbaba3ed16bb4328bab37ab816b8ac022", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/7240823dbaba3ed16bb4328bab37ab816b8ac022", "committedDate": "2020-09-25T08:51:46Z", "message": "Merge branch 'master' into audit_request_body_for_certain_transport_requests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "79868b9b8df093ab0fbe343160db5fd2a2609c5c", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/79868b9b8df093ab0fbe343160db5fd2a2609c5c", "committedDate": "2020-09-25T09:33:37Z", "message": "Do not audit non-write security changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "81fe94e4ea4417fce2a41dba2607609afee40f21", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/81fe94e4ea4417fce2a41dba2607609afee40f21", "committedDate": "2020-09-25T14:16:14Z", "message": "Almost all requests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d7f566ee8fddd2e9e42776fb518ea0d20309b5a2", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/d7f566ee8fddd2e9e42776fb518ea0d20309b5a2", "committedDate": "2020-09-25T17:07:43Z", "message": "draft ready"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "03d4edb1e40c5ba6b02c1be416aa5cf868296fe0", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/03d4edb1e40c5ba6b02c1be416aa5cf868296fe0", "committedDate": "2020-09-26T11:28:17Z", "message": "Revert unnecessary changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5490420a3fb0ffbf90073043e2d6d3356696590c", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/5490420a3fb0ffbf90073043e2d6d3356696590c", "committedDate": "2020-09-26T11:29:28Z", "message": "Merge branch 'master' into audit_request_body_for_certain_transport_requests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8bd844160fcc3b009f19db1cd91a3cc72822f7c8", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/8bd844160fcc3b009f19db1cd91a3cc72822f7c8", "committedDate": "2020-10-04T18:17:07Z", "message": "Merge branch 'master' into audit_request_body_for_certain_transport_requests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f0579b10c74b5826c392afd911b0002983980eb5", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/f0579b10c74b5826c392afd911b0002983980eb5", "committedDate": "2020-10-04T19:37:54Z", "message": "tweaks"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNjUzNTE1", "url": "https://github.com/elastic/elasticsearch/pull/62916#pullrequestreview-501653515", "createdAt": "2020-10-04T19:45:02Z", "commit": {"oid": "f0579b10c74b5826c392afd911b0002983980eb5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxOTo0NTowMlrOHcJvXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxOTo0NTowMlrOHcJvXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI4MTc1OA==", "bodyText": "The origin.type and event.type definitions have been reversed.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r499281758", "createdAt": "2020-10-04T19:45:02Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/core/src/main/config/log4j2.properties", "diffHunk": "@@ -51,7 +52,7 @@ appender.audit_rolling.layout.pattern = {\\\n # \"user.run_by.realm\" the realm name of the impersonating subject (\"user.run_by.name\")\n # \"user.run_as.realm\" if this \"event.action\" is of a run_as type, this is the realm name the impersonated user is looked up from\n # \"user.roles\" the roles array of the user; these are the roles that are granting privileges\n-# \"origin.type\" it is \"rest\" if the event is originating (is in relation to) a REST request; possible other values are \"transport\" and \"ip_filter\"\n+# \"event.type\" it is \"rest\" if the event is originating (is in relation to) a REST request; possible other values are \"transport\", \"ip_filter\" and \"security_config_change\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0579b10c74b5826c392afd911b0002983980eb5"}, "originalPosition": 20}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNjU3MzU4", "url": "https://github.com/elastic/elasticsearch/pull/62916#pullrequestreview-501657358", "createdAt": "2020-10-04T20:36:10Z", "commit": {"oid": "f0579b10c74b5826c392afd911b0002983980eb5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQyMDozNjoxMFrOHcKBLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQyMDozNjoxMFrOHcKBLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI4NjMxOA==", "bodyText": "The new field that contains the configuration taking effect, as an un-escaped JSON object, for records with event.type: \"security_config_change\".", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r499286318", "createdAt": "2020-10-04T20:36:10Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/core/src/main/config/log4j2.properties", "diffHunk": "@@ -37,12 +37,13 @@ appender.audit_rolling.layout.pattern = {\\\n                 %varsNotEmpty{, \"transport.profile\":\"%enc{%map{transport.profile}}{JSON}\"}\\\n                 %varsNotEmpty{, \"rule\":\"%enc{%map{rule}}{JSON}\"}\\\n                 %varsNotEmpty{, \"event.category\":\"%enc{%map{event.category}}{JSON}\"}\\\n+                %varsNotEmpty{, \"config_change\":%map{config_change}}\\", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0579b10c74b5826c392afd911b0002983980eb5"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9fcd0595f1d7b9fe8492f8a54763c92398da95ed", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/9fcd0595f1d7b9fe8492f8a54763c92398da95ed", "committedDate": "2020-10-04T21:20:24Z", "message": "requests contain operation names"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNzA5ODg4", "url": "https://github.com/elastic/elasticsearch/pull/62916#pullrequestreview-501709888", "createdAt": "2020-10-05T03:58:51Z", "commit": {"oid": "9fcd0595f1d7b9fe8492f8a54763c92398da95ed"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwMzo1ODo1MlrOHcNC3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwNTowMjo0OVrOHcNudA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTMzNTkwMQ==", "bodyText": "Why do we want to hide refresh policy? I assume it is not because of security, but for verbosity?", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r499335901", "createdAt": "2020-10-05T03:58:52Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/action/user/ChangePasswordRequest.java", "diffHunk": "@@ -92,4 +95,21 @@ public void writeTo(StreamOutput out) throws IOException {\n         out.writeBytesReference(new BytesArray(CharArrays.toUtf8Bytes(passwordHash)));\n         refreshPolicy.writeTo(out);\n     }\n+\n+    @Override\n+    public final XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject()\n+                .startObject(\"change_password\")\n+                .field(\"username\", username);\n+        if (params.paramAsBoolean(AuditToXContentParams.INCLUDE_CREDENTIALS, false)) {\n+            builder.field(\"password_hash\", passwordHash != null ? String.valueOf(passwordHash) : null);\n+        } else {\n+            builder.field(\"password_hash\", passwordHash != null ? \"<redacted>\" : null);\n+        }\n+        builder.endObject(); // change_password\n+        if (params.paramAsBoolean(AuditToXContentParams.INCLUDE_REFRESH_POLICY, false)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fcd0595f1d7b9fe8492f8a54763c92398da95ed"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM0MjAxMA==", "bodyText": "I wonder whether we could introduce interfaces dedicated to these, something like the follows:\ninterface SecurityConfigAuditable {\n    String action();\n    String content();  // this method is equivalent to `ToXContent#toXContent`\n}\n\ninterface PutSecurityConfigAuditable() {\n    default String action() {\n        return \"put\";\n    }\n}\n\ninterface DeleteSecurityConfigAuditable() {\n    default String action() {\n        return \"delete\";\n    }\n}\nTo me, it will make the code easier to read and write. I also think it is more preferable to have dedicated interfaces for serialising the request object for auditing purpose instead of the generic ToXContent interface, because 1) the string representation it provides is specific to auditing; 2) security change auditing has pretty good business meaning and we may discover new things later that could add to the interfaces.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r499342010", "createdAt": "2020-10-05T04:35:23Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -482,6 +501,41 @@ public void accessGranted(String requestId, Authentication authentication, Strin\n                 logger.info(AUDIT_MARKER, logEntry);\n             }\n         }\n+        // \"config change\" records are not filtered out by ignore policies (i.e. they are always printed).\n+        // The security changes here are the consequences of *user* requests,\n+        // so in a strict interpretation we should filter them out if there are ignore policies in place for the causing user,\n+        // but we don't because filtering out security changes by the causing user is trappy.\n+        if (events.contains(SECURITY_CONFIG_CHANGED)) {\n+            String eventAction = null;\n+            if (msg instanceof PutUserRequest ||\n+                    msg instanceof PutRoleMappingRequest ||\n+                    msg instanceof PutRoleRequest ||\n+                    msg instanceof SetEnabledRequest ||\n+                    msg instanceof ChangePasswordRequest ||\n+                    msg instanceof CreateApiKeyRequest ||\n+                    msg instanceof GrantApiKeyRequest ||\n+                    msg instanceof CreateTokenRequest ||\n+                    msg instanceof PutPrivilegesRequest) {\n+                eventAction = \"put\";\n+            } else if (msg instanceof DeleteUserRequest ||\n+                    msg instanceof DeleteRoleMappingRequest ||\n+                    msg instanceof DeleteRoleRequest ||\n+                    msg instanceof InvalidateTokenRequest ||\n+                    msg instanceof InvalidateApiKeyRequest ||\n+                    msg instanceof DeletePrivilegesRequest) {\n+                eventAction = \"delete\";\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fcd0595f1d7b9fe8492f8a54763c92398da95ed"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM0NTE0OA==", "bodyText": "Nit: technically, when the auditing happens, the config has not been \"changed\" yet. So it is probably better just be SECURITY_CONFIG_CHANGE.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r499345148", "createdAt": "2020-10-05T04:53:08Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/AuditLevel.java", "diffHunk": "@@ -22,6 +21,7 @@\n     CONNECTION_GRANTED,\n     CONNECTION_DENIED,\n     SYSTEM_ACCESS_GRANTED,\n+    SECURITY_CONFIG_CHANGED,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fcd0595f1d7b9fe8492f8a54763c92398da95ed"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM0NzA2MA==", "bodyText": "If we are redacting, should we just always show <redacted> regardless of whether the value is null or not? It is better from the information disclosure perspective.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r499347060", "createdAt": "2020-10-05T05:02:49Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/action/GrantApiKeyRequest.java", "diffHunk": "@@ -86,6 +89,21 @@ public void setPassword(SecureString password) {\n         public void setAccessToken(SecureString accessToken) {\n             this.accessToken = accessToken;\n         }\n+\n+        @Override\n+        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+            builder.startObject()\n+                    .field(\"type\", type)\n+                    .field(\"username\", username);\n+            if (params.paramAsBoolean(AuditToXContentParams.INCLUDE_CREDENTIALS, false)) {\n+                builder.field(\"password\", password != null ? password.toString() : null);\n+                builder.field(\"access_token\", accessToken != null ? accessToken.toString() : null);\n+            } else {\n+                builder.field(\"password\", password != null ? \"<redacted>\" : null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fcd0595f1d7b9fe8492f8a54763c92398da95ed"}, "originalPosition": 42}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9550f42e27c1cc5b6513939e9ea16d74187dc7ff", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/9550f42e27c1cc5b6513939e9ea16d74187dc7ff", "committedDate": "2020-10-05T14:01:48Z", "message": "WIP"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fb941c1dd539422af9ecfa58144e3ec999a951b7", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/fb941c1dd539422af9ecfa58144e3ec999a951b7", "committedDate": "2020-10-05T14:26:19Z", "message": "Merge branch 'master' into audit_request_body_for_certain_transport_requests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6bb09a0c42a27e1eab6d9f3dc96fe286503cda80", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/6bb09a0c42a27e1eab6d9f3dc96fe286503cda80", "committedDate": "2020-10-05T14:31:57Z", "message": "Security Config Change"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "47131aec30983517610a948842b94276c3043dc3", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/47131aec30983517610a948842b94276c3043dc3", "committedDate": "2020-10-06T06:48:53Z", "message": "WIP"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyODM3NjE2", "url": "https://github.com/elastic/elasticsearch/pull/62916#pullrequestreview-502837616", "createdAt": "2020-10-06T11:25:27Z", "commit": {"oid": "9fcd0595f1d7b9fe8492f8a54763c92398da95ed"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxMToyNToyN1rOHdBuRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxNTowMDo1N1rOHdL1GQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDE5ODk4MQ==", "bodyText": "I agree that in this case it doesn't make much difference. For instance, the only thing that the existence of the password field ( redacted vs null) \"discloses\" is that the request is using the password grant type, as this is the only case where this is allowed as a parameter.\nIn general, from an audit perspective, as a legitimate administrator, I would like to know as much information as possible so I would prefer to know if a parameter was specified when the call to the API was made* and in that sense I prefer to have \"\" vs null.\n* In the case of an investigation, I might want to know if an attacker had access to a valid password or if they figured out another way to compromise the system/api.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r500198981", "createdAt": "2020-10-06T11:25:27Z", "author": {"login": "jkakavas"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/action/GrantApiKeyRequest.java", "diffHunk": "@@ -86,6 +89,21 @@ public void setPassword(SecureString password) {\n         public void setAccessToken(SecureString accessToken) {\n             this.accessToken = accessToken;\n         }\n+\n+        @Override\n+        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+            builder.startObject()\n+                    .field(\"type\", type)\n+                    .field(\"username\", username);\n+            if (params.paramAsBoolean(AuditToXContentParams.INCLUDE_CREDENTIALS, false)) {\n+                builder.field(\"password\", password != null ? password.toString() : null);\n+                builder.field(\"access_token\", accessToken != null ? accessToken.toString() : null);\n+            } else {\n+                builder.field(\"password\", password != null ? \"<redacted>\" : null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM0NzA2MA=="}, "originalCommit": {"oid": "9fcd0595f1d7b9fe8492f8a54763c92398da95ed"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDM2NDU2OQ==", "bodyText": "Apologies if we have already discuss this in the past. Does this come from a user request? I can't see the use case for auditing credential values in plaintext and it seems like a dangerous option to include ( even if it defaults to false )", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r500364569", "createdAt": "2020-10-06T15:00:57Z", "author": {"login": "jkakavas"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/xcontent/XContentUtils.java", "diffHunk": "@@ -14,6 +14,11 @@\n \n public class XContentUtils {\n \n+    public static final class AuditToXContentParams {\n+        public static final String INCLUDE_CREDENTIALS = \"include_credentials\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fcd0595f1d7b9fe8492f8a54763c92398da95ed"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "598622358108df67512ed1fa01094e1406bfe08e", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/598622358108df67512ed1fa01094e1406bfe08e", "committedDate": "2020-10-07T21:54:36Z", "message": "review"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3fceda2bcb7fed1187f276c54b987d49622d223b", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/3fceda2bcb7fed1187f276c54b987d49622d223b", "committedDate": "2020-10-07T22:24:43Z", "message": "nit"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f62a1fd5ecd65bb33441ece15eda343fd1ca685a", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/f62a1fd5ecd65bb33441ece15eda343fd1ca685a", "committedDate": "2020-10-07T22:26:32Z", "message": "Merge branch 'master' into audit_request_body_for_certain_transport_requests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a535098854562f1b65efb83dd93a3328815c1955", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/a535098854562f1b65efb83dd93a3328815c1955", "committedDate": "2020-10-07T23:10:10Z", "message": "Merge fallout"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6f8ceafc8b263f3066535ed725257b3c906d3dab", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/6f8ceafc8b263f3066535ed725257b3c906d3dab", "committedDate": "2020-10-07T23:19:37Z", "message": "WIP tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ff6b54402822d1b6f1e30d90cdf189e3d4fa2f28", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/ff6b54402822d1b6f1e30d90cdf189e3d4fa2f28", "committedDate": "2020-10-08T08:46:38Z", "message": "Mhm"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4d2a10483e150ed77c0fb834fa6990a8cf960fdf", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/4d2a10483e150ed77c0fb834fa6990a8cf960fdf", "committedDate": "2020-10-08T09:00:29Z", "message": "trims"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "61c9e2884dadb460125595e6302562bbb739a214", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/61c9e2884dadb460125595e6302562bbb739a214", "committedDate": "2020-10-08T09:13:36Z", "message": "Checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bd44688d2fc7f5ca8af42ed7ca89e2b5e1ce5edf", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/bd44688d2fc7f5ca8af42ed7ca89e2b5e1ce5edf", "committedDate": "2020-10-08T12:27:27Z", "message": "Test audit cluster settings update"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2dca8e4221d94bccb4d2024755b96af1b5920fd2", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/2dca8e4221d94bccb4d2024755b96af1b5920fd2", "committedDate": "2020-10-08T14:08:55Z", "message": "Tests in progress"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "93be896e181730a113a1d8a7fc0c71359c91f5b9", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/93be896e181730a113a1d8a7fc0c71359c91f5b9", "committedDate": "2020-10-18T10:08:13Z", "message": "Merge branch 'master' into audit_request_body_for_certain_transport_requests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e831fc9030f62538b3e399ef97de5e4b67fdaafa", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/e831fc9030f62538b3e399ef97de5e4b67fdaafa", "committedDate": "2020-10-18T10:43:42Z", "message": "Revert useless"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTExMTMxNjcy", "url": "https://github.com/elastic/elasticsearch/pull/62916#pullrequestreview-511131672", "createdAt": "2020-10-18T10:48:47Z", "commit": {"oid": "bd44688d2fc7f5ca8af42ed7ca89e2b5e1ce5edf"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQxMDo0ODo0N1rOHjmWeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQxMDo0ODo0N1rOHjmWeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzA5MDU1NA==", "bodyText": "The new audit event.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r507090554", "createdAt": "2020-10-18T10:48:47Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/AuditLevel.java", "diffHunk": "@@ -61,6 +61,9 @@\n                 case \"system_access_granted\":\n                     enumSet.add(SYSTEM_ACCESS_GRANTED);\n                     break;\n+                case \"security_config_change\":\n+                    enumSet.add(SECURITY_CONFIG_CHANGE);\n+                    break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd44688d2fc7f5ca8af42ed7ca89e2b5e1ce5edf"}, "originalPosition": 22}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "92d97898385d28fe977a4297197e67d73bbd5958", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/92d97898385d28fe977a4297197e67d73bbd5958", "committedDate": "2020-10-18T11:16:50Z", "message": "master merge mistake"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "576f7d43807ff8f6a2c139bcfa33a2d76f2915d7", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/576f7d43807ff8f6a2c139bcfa33a2d76f2915d7", "committedDate": "2020-10-18T11:31:03Z", "message": "log4j audit pattern equals"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7f33a26843c7219e3ae3da16a70c902fce5107a4", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/7f33a26843c7219e3ae3da16a70c902fce5107a4", "committedDate": "2020-10-18T11:42:08Z", "message": "Don't overcomplicate the diff"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTExMTM2Mjky", "url": "https://github.com/elastic/elasticsearch/pull/62916#pullrequestreview-511136292", "createdAt": "2020-10-18T11:44:56Z", "commit": {"oid": "7f33a26843c7219e3ae3da16a70c902fce5107a4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQxMTo0NDo1NlrOHjnj9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQxMTo0NDo1NlrOHjnj9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzExMDM4OA==", "bodyText": "Unlike general request body auditing, security change events are emitted by default.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r507110388", "createdAt": "2020-10-18T11:44:56Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -136,7 +169,7 @@\n             Property.NodeScope, Property.Dynamic);\n     private static final List<String> DEFAULT_EVENT_INCLUDES = Arrays.asList(ACCESS_DENIED.toString(), ACCESS_GRANTED.toString(),\n             ANONYMOUS_ACCESS_DENIED.toString(), AUTHENTICATION_FAILED.toString(), CONNECTION_DENIED.toString(), TAMPERED_REQUEST.toString(),\n-            RUN_AS_DENIED.toString(), RUN_AS_GRANTED.toString());\n+            RUN_AS_DENIED.toString(), RUN_AS_GRANTED.toString(), SECURITY_CONFIG_CHANGE.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f33a26843c7219e3ae3da16a70c902fce5107a4"}, "originalPosition": 89}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTExMTM2OTM5", "url": "https://github.com/elastic/elasticsearch/pull/62916#pullrequestreview-511136939", "createdAt": "2020-10-18T11:53:28Z", "commit": {"oid": "7f33a26843c7219e3ae3da16a70c902fce5107a4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQxMTo1MzoyOFrOHjnxTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQxMTo1MzoyOFrOHjnxTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzExMzgwNA==", "bodyText": "Changes like these are a small refactoring. It allows to build the log entry in a single statement.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r507113804", "createdAt": "2020-10-18T11:53:28Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -245,7 +288,7 @@ public void authenticationSuccess(String requestId, Authentication authenticatio\n                         Optional.empty())) == false) {\n             // this is redundant information maintained for bwc purposes\n             final String authnRealm = authentication.getAuthenticatedBy().getName();\n-            final StringMapMessage logEntry = new LogEntryBuilder()\n+            new LogEntryBuilder()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f33a26843c7219e3ae3da16a70c902fce5107a4"}, "originalPosition": 122}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTExMTQxMTk4", "url": "https://github.com/elastic/elasticsearch/pull/62916#pullrequestreview-511141198", "createdAt": "2020-10-18T12:44:05Z", "commit": {"oid": "7f33a26843c7219e3ae3da16a70c902fce5107a4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQxMjo0NDowNVrOHjo59A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQxMjo0NDowNVrOHjo59A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzEzMjQwNA==", "bodyText": "api key id not currently audited we need to settle on the best approach, between carrying the id in the request object and intercepting the id from the response (see #63708).", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r507132404", "createdAt": "2020-10-18T12:44:05Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -736,7 +802,218 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"realm\", inferRealmNameFromUsername.apply(putUserRequest.username()))\n+                    .array(\"roles\", putUserRequest.roles())\n+                    .field(\"full_name\", putUserRequest.fullName())\n+                    .field(\"email\", putUserRequest.email())\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .field(\"has_password\", putUserRequest.passwordHash() != null)\n+                    // TODO metadata can fail because it might contain unknown class types\n+                    // ensure toXContent on such maps is a superset of the metadata maps role mapping can manage\n+                    .field(\"metadata\", putUserRequest.metadata())\n+                    .endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", changePasswordRequest.username())\n+                    .field(\"realm\", inferRealmNameFromUsername.apply(changePasswordRequest.username()))\n+                    .endObject() // user\n+                    .endObject();\n+            logEntry.with(CHANGE_PASSWORD_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleRequest putRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", putRoleRequest.name())\n+                    .array(\"cluster_privileges\", putRoleRequest.cluster())\n+                    .array(\"run_as\", putRoleRequest.runAs())\n+                    .array(\"indices_privileges\", (Object[]) putRoleRequest.indices())\n+                    .field(\"application_privileges\", putRoleRequest.applicationPrivileges())\n+                    .field(\"metadata\", putRoleRequest.metadata());\n+            builder.startObject(\"conditional_cluster_privileges\");\n+            for (ConfigurableClusterPrivilege conditionalClusterPrivilege : putRoleRequest.conditionalClusterPrivileges()) {\n+                conditionalClusterPrivilege.toXContent(builder, ToXContent.EMPTY_PARAMS);\n+            }\n+            builder.endObject() // configurable_cluster_privileges\n+                    .endObject() // role\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleMappingRequest putRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", putRoleMappingRequest.getName())\n+                    .field(\"role_names\", putRoleMappingRequest.getRoles())\n+                    .field(\"role_templates\", putRoleMappingRequest.getRoleTemplates())\n+                    .field(\"rules\", putRoleMappingRequest.getRules())\n+                    .field(\"enabled\", putRoleMappingRequest.isEnabled())\n+                    .field(\"metadata\", putRoleMappingRequest.getMetadata())\n+                    .endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(SetEnabledRequest setEnabledRequest) throws IOException {\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", setEnabledRequest.username())\n+                    .field(\"realm\", inferRealmNameFromUsername.apply(setEnabledRequest.username()))\n+                    .endObject() // user\n+                    .endObject();\n+            if (setEnabledRequest.enabled()) {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"enable_user\");\n+                logEntry.with(ENABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            } else {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"disable_user\");\n+                logEntry.with(DISABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            }\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutPrivilegesRequest putPrivilegesRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_privileges\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .field(\"privileges\", putPrivilegesRequest.getPrivileges())\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            TimeValue expiration = createApiKeyRequest.getExpiration();\n+            builder.startObject()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f33a26843c7219e3ae3da16a70c902fce5107a4"}, "originalPosition": 628}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e2c305d6c2aef0be961ee56211ac9ef07524649b", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/e2c305d6c2aef0be961ee56211ac9ef07524649b", "committedDate": "2020-10-18T17:48:12Z", "message": "Nit javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4a0aa79ff786bef8c03fc40523b3b1694103bc10", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/4a0aa79ff786bef8c03fc40523b3b1694103bc10", "committedDate": "2020-10-18T18:06:47Z", "message": "Minor thing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "10dad5bfdf78feda49a5f53923835c6a6f852203", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/10dad5bfdf78feda49a5f53923835c6a6f852203", "committedDate": "2020-10-18T20:53:16Z", "message": "Uninteresting test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTExMjY5MTc4", "url": "https://github.com/elastic/elasticsearch/pull/62916#pullrequestreview-511269178", "createdAt": "2020-10-18T23:16:39Z", "commit": {"oid": "10dad5bfdf78feda49a5f53923835c6a6f852203"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQyMzoxNjozOVrOHjv6uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQyMzoxNjozOVrOHjv6uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzI0NzI5MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // the fields below are used exclusively for \"security_configuration_change\" type of events, and show the configuration\n          \n          \n            \n                // the fields below are used exclusively for \"security_config_change\" type of events, and show the configuration", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r507247291", "createdAt": "2020-10-18T23:16:39Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -124,6 +164,17 @@\n     public static final String RULE_FIELD_NAME = \"rule\";\n     public static final String OPAQUE_ID_FIELD_NAME = \"opaque_id\";\n     public static final String X_FORWARDED_FOR_FIELD_NAME = \"x_forwarded_for\";\n+    // the fields below are used exclusively for \"security_configuration_change\" type of events, and show the configuration", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10dad5bfdf78feda49a5f53923835c6a6f852203"}, "originalPosition": 102}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTExMzE1Nzc1", "url": "https://github.com/elastic/elasticsearch/pull/62916#pullrequestreview-511315775", "createdAt": "2020-10-19T00:01:16Z", "commit": {"oid": "10dad5bfdf78feda49a5f53923835c6a6f852203"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQwMDowMToxN1rOHjxFTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQwMDowMToxN1rOHjxFTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzI2NjM4Mw==", "bodyText": "I have a general question: What is our intention for handling errors occur during auditing time? Do we want to propogate the error message back to user in the HTTP response, or do we only need to print it in server log? IIUC, by throwing IllegalStateException, the error will be in the HTTP response?", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r507266383", "createdAt": "2020-10-19T00:01:17Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -479,7 +535,60 @@ public void accessGranted(String requestId, Authentication authentication, Strin\n                         .withXForwardedFor(threadContext)\n                         .with(authorizationInfo.asMap())\n                         .build();\n-                logger.info(AUDIT_MARKER, logEntry);\n+            }\n+        }\n+        // \"Security config change\" records are not filtered out by ignore policies (i.e. they are always printed).\n+        // The security changes here are the consequences of *user* requests,\n+        // so in a strict interpretation we should filter them out if there are ignore policies in place for the causing user,\n+        // but we do NOT do that because filtering out audit records of security changes can be unexpectedly dangerous.\n+        if (events.contains(SECURITY_CONFIG_CHANGE) && SECURITY_CHANGE_ACTIONS.contains(action)) {\n+            try {\n+                if (msg instanceof PutUserRequest) {\n+                    assert PutUserAction.NAME.equals(action);\n+                    securityChangeLogEntryBuilder(requestId).withRequestBody((PutUserRequest) msg).build();\n+                } else if (msg instanceof PutRoleRequest) {\n+                    assert PutRoleAction.NAME.equals(action);\n+                    securityChangeLogEntryBuilder(requestId).withRequestBody((PutRoleRequest) msg).build();\n+                } else if (msg instanceof PutRoleMappingRequest) {\n+                    assert PutRoleMappingAction.NAME.equals(action);\n+                    securityChangeLogEntryBuilder(requestId).withRequestBody((PutRoleMappingRequest) msg).build();\n+                } else if (msg instanceof SetEnabledRequest) {\n+                    assert SetEnabledAction.NAME.equals(action);\n+                    securityChangeLogEntryBuilder(requestId).withRequestBody((SetEnabledRequest) msg).build();\n+                } else if (msg instanceof ChangePasswordRequest) {\n+                    assert ChangePasswordAction.NAME.equals(action);\n+                    securityChangeLogEntryBuilder(requestId).withRequestBody((ChangePasswordRequest) msg).build();\n+                } else if (msg instanceof CreateApiKeyRequest) {\n+                    assert CreateApiKeyAction.NAME.equals(action);\n+                    securityChangeLogEntryBuilder(requestId).withRequestBody((CreateApiKeyRequest) msg).build();\n+                } else if (msg instanceof GrantApiKeyRequest) {\n+                    assert GrantApiKeyAction.NAME.equals(action);\n+                    securityChangeLogEntryBuilder(requestId).withRequestBody((GrantApiKeyRequest) msg).build();\n+                } else if (msg instanceof PutPrivilegesRequest) {\n+                    assert PutPrivilegesAction.NAME.equals(action);\n+                    securityChangeLogEntryBuilder(requestId).withRequestBody((PutPrivilegesRequest) msg).build();\n+                } else if (msg instanceof DeleteUserRequest) {\n+                    assert DeleteUserAction.NAME.equals(action);\n+                    securityChangeLogEntryBuilder(requestId).withRequestBody((DeleteUserRequest) msg).build();\n+                } else if (msg instanceof DeleteRoleRequest) {\n+                    assert DeleteRoleAction.NAME.equals(action);\n+                    securityChangeLogEntryBuilder(requestId).withRequestBody((DeleteRoleRequest) msg).build();\n+                } else if (msg instanceof DeleteRoleMappingRequest) {\n+                    assert DeleteRoleMappingAction.NAME.equals(action);\n+                    securityChangeLogEntryBuilder(requestId).withRequestBody((DeleteRoleMappingRequest) msg).build();\n+                } else if (msg instanceof InvalidateApiKeyRequest) {\n+                    assert InvalidateApiKeyAction.NAME.equals(action);\n+                    securityChangeLogEntryBuilder(requestId).withRequestBody((InvalidateApiKeyRequest) msg).build();\n+                } else if (msg instanceof DeletePrivilegesRequest) {\n+                    assert DeletePrivilegesAction.NAME.equals(action);\n+                    securityChangeLogEntryBuilder(requestId).withRequestBody((DeletePrivilegesRequest) msg).build();\n+                } else {\n+                    throw new IllegalStateException(\"Unknown message class type [\" + msg.getClass().getSimpleName() +\n+                            \"] for the \\\"security change\\\" action [\" + action + \"]\");\n+                }\n+            } catch (IOException e) {\n+                // TODO ensure and test that IOExceptions are gracefully handled up the call stack\n+                // TODO Especially check that all valid metadata can be serialized in the audit record\n             }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10dad5bfdf78feda49a5f53923835c6a6f852203"}, "originalPosition": 399}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTExMzUzMDM1", "url": "https://github.com/elastic/elasticsearch/pull/62916#pullrequestreview-511353035", "createdAt": "2020-10-19T00:31:30Z", "commit": {"oid": "10dad5bfdf78feda49a5f53923835c6a6f852203"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQwMDozMTozMFrOHjyBAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQwMDozMTozMFrOHjyBAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzI4MTY2NQ==", "bodyText": "The name put looks a bit off in this context. I understand it is a carry over from the Rest action. But put or post is too HTTP specific and do not seem to blend in very well with other verbs like create, enable etc. I'd suggest to use upsert.\nI also wonder whether we could have more consistency and simplicity in the names. The mixed usage of underscore and dot looks a bit standing out. Can we use just either of them, but not both? Some of the fields are named as verb.noun or verb_noun, is it possible to make these field more generic to contain only the verb. The noun part of it will be in the body anyway.\nNames are hard. These are just my 2cents.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r507281665", "createdAt": "2020-10-19T00:31:30Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -124,6 +164,17 @@\n     public static final String RULE_FIELD_NAME = \"rule\";\n     public static final String OPAQUE_ID_FIELD_NAME = \"opaque_id\";\n     public static final String X_FORWARDED_FOR_FIELD_NAME = \"x_forwarded_for\";\n+    // the fields below are used exclusively for \"security_configuration_change\" type of events, and show the configuration\n+    // object taking effect; it could be creating a new, or updating an existing configuration\n+    // if our (REST) APIs (at least the security APIs) would make the distinction between creating a *new* resource using the POST\n+    // verb and updating an *existing* resource using the PUT verb, then auditing would also be able to show the create/update distinction\n+    public static final String PUT_CONFIG_FIELD_NAME = \"put\";\n+    public static final String DELETE_CONFIG_FIELD_NAME = \"delete\";\n+    public static final String CHANGE_PASSWORD_FIELD_NAME = \"change_password\";\n+    public static final String ENABLE_CONFIG_FIELD_NAME = \"enable\";\n+    public static final String DISABLE_CONFIG_FIELD_NAME = \"disable\";\n+    public static final String CREATE_API_KEY_FIELD_NAME = \"create.apikey\";\n+    public static final String INVALIDATE_API_KEYS_FIELD_NAME = \"invalidate_apikeys\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10dad5bfdf78feda49a5f53923835c6a6f852203"}, "originalPosition": 112}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9823e29b821c764c8126a728e2cfb413a0cc1310", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/9823e29b821c764c8126a728e2cfb413a0cc1310", "committedDate": "2020-10-19T09:32:51Z", "message": "Update x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java\n\nCo-authored-by: Yang Wang <ywangd@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f7f569d5670fdbb311744e13e0802705fa7ecfeb", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/f7f569d5670fdbb311744e13e0802705fa7ecfeb", "committedDate": "2020-10-19T09:39:06Z", "message": "Nit"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "44ac3723e3fb947b9f6291be60adcb1a68ae905b", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/44ac3723e3fb947b9f6291be60adcb1a68ae905b", "committedDate": "2020-10-20T14:53:43Z", "message": "More restructuring on the format"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "59e9e85a6a9947afb6cc3b244d8b3a6d752a83c8", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/59e9e85a6a9947afb6cc3b244d8b3a6d752a83c8", "committedDate": "2020-10-20T15:44:39Z", "message": "Do not show some null fields"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "44d68d778338562282e68fc54bc2846474bbf58b", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/44d68d778338562282e68fc54bc2846474bbf58b", "committedDate": "2020-10-20T16:19:36Z", "message": "tests still in progress"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5d3e6ed1ebee599620eaa7498f81ad5562262f86", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/5d3e6ed1ebee599620eaa7498f81ad5562262f86", "committedDate": "2020-10-21T09:15:30Z", "message": "Lose the _"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c3bdaf0129fe1313cf8cf8a6ce6339bb048f8e75", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/c3bdaf0129fe1313cf8cf8a6ce6339bb048f8e75", "committedDate": "2020-10-21T09:56:52Z", "message": "Fix for the above"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4e8a0d508890fe255025c66919011de67b0c555e", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/4e8a0d508890fe255025c66919011de67b0c555e", "committedDate": "2020-10-21T10:04:11Z", "message": "Condition_cluster to global rename"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c5859d21c9d2ed58dea2709371e73306e9df4178", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/c5859d21c9d2ed58dea2709371e73306e9df4178", "committedDate": "2020-10-22T13:49:25Z", "message": "Almost"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3e0d84675b997bee82eef0aafe8137fd4dd60e51", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/3e0d84675b997bee82eef0aafe8137fd4dd60e51", "committedDate": "2020-10-22T14:00:16Z", "message": "Checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5d502bca4440a579a852a2e8169d6c2cc3a45b83", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/5d502bca4440a579a852a2e8169d6c2cc3a45b83", "committedDate": "2020-10-22T14:25:59Z", "message": "Checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "daa77faf969873ec889390fc6aaa23d8d5c3f531", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/daa77faf969873ec889390fc6aaa23d8d5c3f531", "committedDate": "2020-10-22T14:26:28Z", "message": "Merge branch 'master' into audit_request_body_for_certain_transport_requests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7b1d40f23bc0c34d9d7faaebd9268f85430f1411", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/7b1d40f23bc0c34d9d7faaebd9268f85430f1411", "committedDate": "2020-10-22T15:18:09Z", "message": "Create API key test done"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "988d600cde774431cbf507f741598e63bd01a12b", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/988d600cde774431cbf507f741598e63bd01a12b", "committedDate": "2020-10-22T17:32:40Z", "message": "Indices privileges"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "96300cefd48e2001d330de67938939d55b353f78", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/96300cefd48e2001d330de67938939d55b353f78", "committedDate": "2020-10-23T07:51:43Z", "message": "grant api key tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e02cf8d70f617c6bb0014175d06564a27bdefdcf", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/e02cf8d70f617c6bb0014175d06564a27bdefdcf", "committedDate": "2020-10-23T07:52:15Z", "message": "Merge branch 'master' into audit_request_body_for_certain_transport_requests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "93817bbfab1d4b3bfc50f44b98fa2a8b41448cab", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/93817bbfab1d4b3bfc50f44b98fa2a8b41448cab", "committedDate": "2020-10-24T08:32:33Z", "message": "Role"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "78874a5aaa33c6b73b2def83234ec42e080bec2c", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/78874a5aaa33c6b73b2def83234ec42e080bec2c", "committedDate": "2020-10-25T12:41:29Z", "message": "Put user security changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "38fbb4fc6056ef9058f3c008dab755a8b35bb81e", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/38fbb4fc6056ef9058f3c008dab755a8b35bb81e", "committedDate": "2020-10-25T13:04:03Z", "message": "Enable user test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c183458842bcb4f110bdc4c5e9b2262d49624f20", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/c183458842bcb4f110bdc4c5e9b2262d49624f20", "committedDate": "2020-10-25T13:36:35Z", "message": "Disable user and change password"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "85be35f0f14acab7c4500bc1fdd2dffa406d6620", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/85be35f0f14acab7c4500bc1fdd2dffa406d6620", "committedDate": "2020-10-25T16:44:47Z", "message": "Role mapping changes tested"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ea15a059119c353b990b35ed0a6e0bec67bf1860", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/ea15a059119c353b990b35ed0a6e0bec67bf1860", "committedDate": "2020-10-25T21:37:01Z", "message": "Api Key invalidation tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f7bc2fe04f8c38a40bc8818e8bd3605a8e619358", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/f7bc2fe04f8c38a40bc8818e8bd3605a8e619358", "committedDate": "2020-10-25T21:37:38Z", "message": "Merge branch 'master' into audit_request_body_for_certain_transport_requests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "61b3121b6bb411b0daa1c224cc37008e57b1fdb6", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/61b3121b6bb411b0daa1c224cc37008e57b1fdb6", "committedDate": "2020-10-25T21:39:48Z", "message": "Resolve Exception TODO"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8a6be5ed4aef189f1a801bff5c98949312d289ce", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/8a6be5ed4aef189f1a801bff5c98949312d289ce", "committedDate": "2020-10-25T22:08:45Z", "message": "Checkstyle"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2NDQ4NTIw", "url": "https://github.com/elastic/elasticsearch/pull/62916#pullrequestreview-516448520", "createdAt": "2020-10-26T03:23:56Z", "commit": {"oid": "8a6be5ed4aef189f1a801bff5c98949312d289ce"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQwMzoyMzo1NlrOHn_0QA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQwMzoyMzo1NlrOHn_0QA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTcwMjA4MA==", "bodyText": "This approach bothers me.\nPutting this code into the Audit trail rather than in the requests itself increases the risk that we will change the implementation of a request object, but fail to account for that in the audit logs (new fields, etc).\nAt one point we talked about an AuditableRequest interface with a toAuditXContent method. Is there  a reason we moved away from that idea?", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r511702080", "createdAt": "2020-10-26T03:23:56Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -479,7 +538,59 @@ public void accessGranted(String requestId, Authentication authentication, Strin\n                         .withXForwardedFor(threadContext)\n                         .with(authorizationInfo.asMap())\n                         .build();\n-                logger.info(AUDIT_MARKER, logEntry);\n+            }\n+        }\n+        // \"Security config change\" records are not filtered out by ignore policies (i.e. they are always printed).\n+        // The security changes here are the consequences of *user* requests,\n+        // so in a strict interpretation we should filter them out if there are ignore policies in place for the causing user,\n+        // but we do NOT do that because filtering out audit records of security changes can be unexpectedly dangerous.\n+        if (events.contains(SECURITY_CONFIG_CHANGE) && SECURITY_CHANGE_ACTIONS.contains(action)) {\n+            try {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a6be5ed4aef189f1a801bff5c98949312d289ce"}, "originalPosition": 355}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "83b699248e9e0b092e09419b426d16037d1c87ca", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/83b699248e9e0b092e09419b426d16037d1c87ca", "committedDate": "2020-10-26T11:30:34Z", "message": "More tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "612e69c8729f0f78350235cd45b4ae1314fd6636", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/612e69c8729f0f78350235cd45b4ae1314fd6636", "committedDate": "2020-10-26T12:16:10Z", "message": "More tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "79f495a568f7778dea4bd2b9cfc1eeacc88d6be2", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/79f495a568f7778dea4bd2b9cfc1eeacc88d6be2", "committedDate": "2020-10-26T12:45:34Z", "message": "great..."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQwNjU2NTgz", "url": "https://github.com/elastic/elasticsearch/pull/62916#pullrequestreview-540656583", "createdAt": "2020-11-30T07:41:13Z", "commit": {"oid": "79f495a568f7778dea4bd2b9cfc1eeacc88d6be2"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQwNzo0MToxM1rOH7u4TA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQwNzo1NjoyM1rOH7vR1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM5NjEwOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final String NAME = \"default_native\";\n          \n          \n            \n                public static final String DEFAULT_NAME = \"default_native\";", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r532396108", "createdAt": "2020-11-30T07:41:13Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authc/esnative/NativeRealmSettings.java", "diffHunk": "@@ -14,6 +14,7 @@\n \n public final class NativeRealmSettings {\n     public static final String TYPE = \"native\";\n+    public static final String NAME = \"default_native\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79f495a568f7778dea4bd2b9cfc1eeacc88d6be2"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM5NjY5Mw==", "bodyText": "As above.\nGiven that an admin can be name these realms whatever they want, I think NAME has the potential to be misleading to future readers.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r532396693", "createdAt": "2020-11-30T07:42:32Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authc/file/FileRealmSettings.java", "diffHunk": "@@ -14,6 +14,7 @@\n \n public final class FileRealmSettings {\n     public static final String TYPE = \"file\";\n+    public static final String NAME = \"default_file\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79f495a568f7778dea4bd2b9cfc1eeacc88d6be2"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM5OTAxMg==", "bodyText": "This doesn't seem right.\nAmong other things, the native realm might be named something different, and also the reserved realm might be disabled.\nIf we really need to record a realm name for a user then I think we need to do it correctly.\nDoing it in a possibly-not-correct way isn't helping anyone.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r532399012", "createdAt": "2020-11-30T07:48:21Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -191,6 +249,17 @@ public LoggingAuditTrail(Settings settings, ClusterService clusterService, Threa\n         this.events = parse(INCLUDE_EVENT_SETTINGS.get(settings), EXCLUDE_EVENT_SETTINGS.get(settings));\n         this.includeRequestBody = INCLUDE_REQUEST_BODY.get(settings);\n         this.threadContext = threadContext;\n+        this.inferRealmNameFromUsername = (username) -> {\n+            if (username == null) {\n+                return null;\n+            } else if (AnonymousUser.isAnonymousEnabled(settings) && AnonymousUser.isAnonymousUsername(username, settings)) {\n+                return null;\n+            } else if (ClientReservedRealm.isReserved(username, settings)) {\n+                return ReservedRealm.NAME;\n+            } else {\n+                return NativeRealmSettings.NAME;\n+            }\n+        };", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79f495a568f7778dea4bd2b9cfc1eeacc88d6be2"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQwMDU0OQ==", "bodyText": "you can track all the uses of the request class in the IDE and adapt all the consumers as well\n\nI think we need something more reliable than that, but I'm happy to add it in a followup.\nI'm thinking something like a test in the audit package that verifies that the request/request builder matches the format we expect, so that changes in the request, will force a matching change in the audit implementation.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r532400549", "createdAt": "2020-11-30T07:51:46Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -479,7 +538,59 @@ public void accessGranted(String requestId, Authentication authentication, Strin\n                         .withXForwardedFor(threadContext)\n                         .with(authorizationInfo.asMap())\n                         .build();\n-                logger.info(AUDIT_MARKER, logEntry);\n+            }\n+        }\n+        // \"Security config change\" records are not filtered out by ignore policies (i.e. they are always printed).\n+        // The security changes here are the consequences of *user* requests,\n+        // so in a strict interpretation we should filter them out if there are ignore policies in place for the causing user,\n+        // but we do NOT do that because filtering out audit records of security changes can be unexpectedly dangerous.\n+        if (events.contains(SECURITY_CONFIG_CHANGE) && SECURITY_CHANGE_ACTIONS.contains(action)) {\n+            try {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTcwMjA4MA=="}, "originalCommit": {"oid": "8a6be5ed4aef189f1a801bff5c98949312d289ce"}, "originalPosition": 355}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQwMjY0NA==", "bodyText": "This PR adds 500 lines to a file that is already over 1,000 lines long.\nI really think we need to split it up in some way.\nHappy for it to be a separate PR, but this class is getting way too huge.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r532402644", "createdAt": "2020-11-30T07:56:23Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +830,337 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"realm\", inferRealmNameFromUsername.apply(putUserRequest.username()))\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"role_names\", putUserRequest.roles());\n+                    if (putUserRequest.fullName() != null) {\n+                        builder.field(\"full_name\", putUserRequest.fullName());\n+                    }\n+                    if (putUserRequest.email() != null) {\n+                        builder.field(\"email\", putUserRequest.email());\n+                    }\n+                    // password and password hashes are not exposed in the audit log\n+                    builder.field(\"has_password\", putUserRequest.passwordHash() != null);\n+                    if (putUserRequest.metadata() != null && false == putUserRequest.metadata().isEmpty()) {\n+                        // JSON building for the metadata might fail when encountering unknown class types.\n+                        // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                        // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                        // Also the malevolent metadata can only be produced by the transport client.\n+                        builder.field(\"metadata\", putUserRequest.metadata());\n+                    }\n+                    builder.endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"password\")\n+                    .startObject(\"user\")\n+                    .field(\"name\", changePasswordRequest.username())\n+                    // it's nice for consistency to show the name of the realm, when possible\n+                    .field(\"realm\", inferRealmNameFromUsername.apply(changePasswordRequest.username()))\n+                    .endObject() // user\n+                    .endObject() // password\n+                    .endObject();\n+            logEntry.with(CHANGE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleRequest putRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                        .startObject(\"role\")\n+                        .field(\"name\", putRoleRequest.name())\n+                        // the \"privilege\" nested structure, where the \"name\" is left out, is closer to the event structure\n+                        // for creating API Keys\n+                        .startObject(\"privilege\")\n+                            .startArray(\"index\");\n+                                for (RoleDescriptor.IndicesPrivileges indicesPrivileges : putRoleRequest.indices()) {\n+                                    withIndicesPrivileges(builder, indicesPrivileges);\n+                                }\n+                            builder.endArray() // index\n+                            .array(\"cluster\", putRoleRequest.cluster())\n+                            .array(\"run_as\", putRoleRequest.runAs())\n+                            // the toXContent method of the {@code RoleDescriptor.ApplicationResourcePrivileges) does a good job\n+                            .field(\"application\", putRoleRequest.applicationPrivileges())\n+                            .field(\"global\");\n+                            // This fails if this list contains multiple instances of the {@code ManageApplicationPrivileges}\n+                            // Again, only the transport client can produce this, and this only introduces a different failure mode and\n+                            // not a new one (i.e. without auditing it would fail differently, but it would still fail)\n+                            ConfigurableClusterPrivileges.toXContent(builder, ToXContent.EMPTY_PARAMS,\n+                                    Arrays.asList(putRoleRequest.conditionalClusterPrivileges()));\n+                            if (putRoleRequest.metadata() != null && false == putRoleRequest.metadata().isEmpty()) {\n+                                // JSON building for the metadata might fail when encountering unknown class types.\n+                                // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                                // cause troubles in downstream code (eg metadata store), so this simply introduces a new failure mode.\n+                                // Also the malevolent metadata can only be produced by the transport client.\n+                                builder.field(\"metadata\", putRoleRequest.metadata());\n+                            }\n+                        builder.endObject() // privilege\n+                        .endObject() // role\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleMappingRequest putRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", putRoleMappingRequest.getName());\n+                    if (putRoleMappingRequest.getRoles() != null && false == putRoleMappingRequest.getRoles().isEmpty()) {\n+                        builder.field(\"role_names\", putRoleMappingRequest.getRoles());\n+                    }\n+                    if (putRoleMappingRequest.getRoleTemplates() != null && false == putRoleMappingRequest.getRoleTemplates().isEmpty()) {\n+                        // the toXContent method of the {@code TemplateRoleName} does a good job\n+                        builder.field(\"role_templates\", putRoleMappingRequest.getRoleTemplates());\n+                    }\n+                    // the toXContent methods of the {@code RoleMapperExpression} instances do a good job\n+                    builder.field(\"rule\", putRoleMappingRequest.getRules())\n+                    .field(\"enabled\", putRoleMappingRequest.isEnabled());\n+                    if (putRoleMappingRequest.getMetadata() != null && false == putRoleMappingRequest.getMetadata().isEmpty()) {\n+                        builder.field(\"metadata\", putRoleMappingRequest.getMetadata());\n+                    }\n+                    builder.endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(SetEnabledRequest setEnabledRequest) throws IOException {\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", setEnabledRequest.username())\n+                    .field(\"realm\", inferRealmNameFromUsername.apply(setEnabledRequest.username()))\n+                    .endObject() // user\n+                    .endObject();\n+            if (setEnabledRequest.enabled() != null && setEnabledRequest.enabled()) {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"enable_user\");\n+                logEntry.with(ENABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            } else {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"disable_user\");\n+                logEntry.with(DISABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            }\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutPrivilegesRequest putPrivilegesRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_privileges\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    // toXContent of {@code ApplicationPrivilegeDescriptor} does a good job\n+                    .field(\"privileges\", putPrivilegesRequest.getPrivileges())\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, createApiKeyRequest);\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(GrantApiKeyRequest grantApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, grantApiKeyRequest.getApiKeyRequest());\n+            GrantApiKeyRequest.Grant grant = grantApiKeyRequest.getGrant();\n+            builder.startObject(\"grant\")\n+                        .field(\"type\", grant.getType());\n+                        if (grant.getUsername() != null) {\n+                            builder.startObject(\"user\")\n+                                    .field(\"name\", grant.getUsername())\n+                                    .field(\"has_password\", grant.getPassword() != null)\n+                                    .endObject(); // user\n+                        }\n+                        if (grant.getAccessToken() != null) {\n+                            builder.field(\"has_access_token\", grant.getAccessToken() != null);\n+                        }\n+                    builder.endObject(); // grant\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        private void withRequestBody(XContentBuilder builder, CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            TimeValue expiration = createApiKeyRequest.getExpiration();\n+            builder.startObject(\"apikey\")\n+                    .field(\"name\", createApiKeyRequest.getName())\n+                    .field(\"expiration\", expiration != null ? expiration.toString() : null)\n+                    .startArray(\"privileges\");\n+            for (RoleDescriptor roleDescriptor : createApiKeyRequest.getRoleDescriptors()) {\n+                builder.startObject()\n+                        .startArray(\"index\");\n+                        for (RoleDescriptor.IndicesPrivileges indicesPrivileges : roleDescriptor.getIndicesPrivileges()) {\n+                            withIndicesPrivileges(builder, indicesPrivileges);\n+                        }\n+                        builder.endArray() // index\n+                        .array(\"cluster\", roleDescriptor.getClusterPrivileges())\n+                        .array(\"run_as\", roleDescriptor.getRunAs())\n+                        // the toXContent method of the {@code RoleDescriptor.ApplicationResourcePrivileges) does a good job\n+                        .array(\"application\", (Object[]) roleDescriptor.getApplicationPrivileges())\n+                        .field(\"global\");\n+                // This fails if this list contains multiple instances of the {@code ManageApplicationPrivileges}\n+                // Again, only the transport client can produce this, and this only introduces a different failure mode and\n+                // not a new one (without auditing it would fail differently, but it would still fail)\n+                ConfigurableClusterPrivileges.toXContent(builder, ToXContent.EMPTY_PARAMS,\n+                        Arrays.asList(roleDescriptor.getConditionalClusterPrivileges()));\n+                if (roleDescriptor.getMetadata() != null && false == roleDescriptor.getMetadata().isEmpty()) {\n+                    // JSON building for the metadata might fail when encountering unknown class types.\n+                    // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                    // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                    // Also the malevolent metadata can only be produced by the transport client.\n+                    builder.field(\"metadata\", roleDescriptor.getMetadata());\n+                }\n+                builder.endObject(); // privilege\n+            }\n+            builder.endArray() // privileges\n+            .endObject(); // apikey\n+        }\n+\n+        private void withIndicesPrivileges(XContentBuilder builder, RoleDescriptor.IndicesPrivileges indicesPrivileges) throws IOException {\n+            builder.startObject();\n+            builder.array(\"names\", indicesPrivileges.getIndices());\n+            builder.array(\"privileges\", indicesPrivileges.getPrivileges());\n+            if (indicesPrivileges.hasGrantedFields() || indicesPrivileges.hasDeniedFields()) {\n+                builder.startObject(\"fields\");\n+                if (indicesPrivileges.hasGrantedFields()) {\n+                    builder.array(\"grant\", indicesPrivileges.getGrantedFields());\n+                }\n+                if (indicesPrivileges.hasDeniedFields()) {\n+                    builder.array(\"except\", indicesPrivileges.getDeniedFields());\n+                }\n+                builder.endObject(); // fields\n+            }\n+            if (indicesPrivileges.getQuery() != null) {\n+                builder.startObject(\"documents\")\n+                        // \"query_string\" conveys that the DLS query is not a nested object, but a string which has quotes escaped, etc.\n+                        .field(\"query_string\", indicesPrivileges.getQuery().utf8ToString())\n+                        .endObject();\n+            }\n+            // default for \"allow_restricted_indices\" is false, and it's very common to stay that way, so don't show it unless otherwise\n+            if (indicesPrivileges.allowRestrictedIndices()) {\n+                builder.field(\"allow_restricted_indices\", indicesPrivileges.allowRestrictedIndices());\n+            }\n+            builder.endObject();\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteUserRequest deleteUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                        .field(\"name\", deleteUserRequest.username())\n+                        .field(\"realm\", inferRealmNameFromUsername.apply(deleteUserRequest.username()))\n+                    .endObject() // user\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteRoleRequest deleteRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", deleteRoleRequest.name())\n+                    .endObject() // role\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteRoleMappingRequest deleteRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", deleteRoleMappingRequest.getName())\n+                    .endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(InvalidateApiKeyRequest invalidateApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"invalidate_apikeys\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"apikeys\");\n+                if (invalidateApiKeyRequest.getIds() != null && invalidateApiKeyRequest.getIds().length > 0) {\n+                    builder.array(\"ids\", invalidateApiKeyRequest.getIds());\n+                }\n+                if (Strings.hasLength(invalidateApiKeyRequest.getName())) {\n+                    builder.field(\"name\", invalidateApiKeyRequest.getName());\n+                }\n+                builder.field(\"owned_by_authenticated_user\", invalidateApiKeyRequest.ownedByAuthenticatedUser());\n+                if (Strings.hasLength(invalidateApiKeyRequest.getUserName()) || Strings.hasLength(invalidateApiKeyRequest.getRealmName())) {\n+                    builder.startObject(\"user\")\n+                            .field(\"name\", invalidateApiKeyRequest.getUserName())\n+                            .field(\"realm\", invalidateApiKeyRequest.getRealmName())\n+                            .endObject(); // user\n+                }\n+            builder.endObject() // apikeys\n+                    .endObject();\n+            logEntry.with(INVALIDATE_API_KEYS_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeletePrivilegesRequest deletePrivilegesRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_privileges\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"privileges\")\n+                        .field(\"application\", deletePrivilegesRequest.application())\n+                        .array(\"privileges\", deletePrivilegesRequest.privileges())\n+                    .endObject() // privileges\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79f495a568f7778dea4bd2b9cfc1eeacc88d6be2"}, "originalPosition": 892}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5218d723c04230614bb8732528e557c7590bad3b", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/5218d723c04230614bb8732528e557c7590bad3b", "committedDate": "2020-12-02T18:37:10Z", "message": "Merge branch 'master' into audit_request_body_for_certain_transport_requests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "42b6de0bb3ca615f56374362e10324b6ce1508ad", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/42b6de0bb3ca615f56374362e10324b6ce1508ad", "committedDate": "2020-12-02T19:56:59Z", "message": "Update x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authc/esnative/NativeRealmSettings.java\n\nCo-authored-by: Tim Vernum <tim@adjective.org>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "68f2445228168ca3a22333e3ac0f453ac5a7232e", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/68f2445228168ca3a22333e3ac0f453ac5a7232e", "committedDate": "2020-12-02T20:26:17Z", "message": "Remove realm name"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b647408c928554973b1a27e07b38e35261495105", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/b647408c928554973b1a27e07b38e35261495105", "committedDate": "2020-12-02T21:36:17Z", "message": "Checkstyle"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ1NTc5NTk5", "url": "https://github.com/elastic/elasticsearch/pull/62916#pullrequestreview-545579599", "createdAt": "2020-12-05T11:18:46Z", "commit": {"oid": "b647408c928554973b1a27e07b38e35261495105"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQxMToxODo0NlrOH_1Dow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQxMzo1MzowM1rOH_6CaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjY5MTYxOQ==", "bodyText": "Should we delete this comment about event.category since it is removed from the above configuration?", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r536691619", "createdAt": "2020-12-05T11:18:46Z", "author": {"login": "ywangd"}, "path": "distribution/docker/src/docker/config/log4j2.properties", "diffHunk": "@@ -114,6 +120,8 @@ appender.audit_rolling.layout.pattern = {\\\n # \"transport.profile\" name of the transport profile in case this is a \"connection_granted\" or \"connection_denied\" event\n # \"rule\" name of the applied rule if the \"origin.type\" is \"ip_filter\"\n # \"event.category\" fixed value \"elasticsearch-audit\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b647408c928554973b1a27e07b38e35261495105"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjcwMzU4NA==", "bodyText": "Nit: The word originating throws me off a bit because the field is now event.type instead of origin.type. IIUC, even.type says something about \"at which layer the current request is being processed\". This definition works fine for the existing values of rest, transport and ip_filter, but falls short with the new security_config_change value. I don't have a good suggestion, maybe something like \"it is for the broader nature of the current request, the possible values are ...\". Please feel free to come up with your own version.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r536703584", "createdAt": "2020-12-05T11:42:03Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/core/src/main/config/log4j2.properties", "diffHunk": "@@ -51,7 +52,7 @@ appender.audit_rolling.layout.pattern = {\\\n # \"user.run_by.realm\" the realm name of the impersonating subject (\"user.run_by.name\")\n # \"user.run_as.realm\" if this \"event.action\" is of a run_as type, this is the realm name the impersonated user is looked up from\n # \"user.roles\" the roles array of the user; these are the roles that are granting privileges\n-# \"origin.type\" it is \"rest\" if the event is originating (is in relation to) a REST request; possible other values are \"transport\" and \"ip_filter\"\n+# \"event.type\" it is \"rest\" if the event is originating (is in relation to) a REST request; possible other values are \"transport\", \"ip_filter\" and \"security_config_change\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI4MTc1OA=="}, "originalCommit": {"oid": "f0579b10c74b5826c392afd911b0002983980eb5"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjcwMzc0Ng==", "bodyText": "Same here for remove the comment about event.category.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r536703746", "createdAt": "2020-12-05T11:42:28Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/core/src/main/config/log4j2.properties", "diffHunk": "@@ -70,6 +76,8 @@ appender.audit_rolling.layout.pattern = {\\\n # \"transport.profile\" name of the transport profile in case this is a \"connection_granted\" or \"connection_denied\" event\n # \"rule\" name of the applied rule if the \"origin.type\" is \"ip_filter\"\n # \"event.category\" fixed value \"elasticsearch-audit\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b647408c928554973b1a27e07b38e35261495105"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjcyMTg0Ng==", "bodyText": "Can we just pass LoggingAuditTrail.entryCommonFields.commonFields at instantiation time of LogEntryBuilder? It seems only the commonFields and includeRequestBody is from the parent class. So the effort to split the class out is not daunting? Seperate it out could also help tests (which are pretty challenging to read right now), especially around testing the message format, which would not need having to go through instantiating a LoggingAuditTrail. And tests for LoggingAuditTrail itself could mock out the LogEntryBuilder and just assert relevant methods are called.\nI also like the idea of having a base class for it because the \"security_config_change\" auditing has almost no overlap with all other usages, even the common premable needs to be modified for \"security_config_change\".", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r536721846", "createdAt": "2020-12-05T12:21:30Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +830,337 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"realm\", inferRealmNameFromUsername.apply(putUserRequest.username()))\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"role_names\", putUserRequest.roles());\n+                    if (putUserRequest.fullName() != null) {\n+                        builder.field(\"full_name\", putUserRequest.fullName());\n+                    }\n+                    if (putUserRequest.email() != null) {\n+                        builder.field(\"email\", putUserRequest.email());\n+                    }\n+                    // password and password hashes are not exposed in the audit log\n+                    builder.field(\"has_password\", putUserRequest.passwordHash() != null);\n+                    if (putUserRequest.metadata() != null && false == putUserRequest.metadata().isEmpty()) {\n+                        // JSON building for the metadata might fail when encountering unknown class types.\n+                        // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                        // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                        // Also the malevolent metadata can only be produced by the transport client.\n+                        builder.field(\"metadata\", putUserRequest.metadata());\n+                    }\n+                    builder.endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"password\")\n+                    .startObject(\"user\")\n+                    .field(\"name\", changePasswordRequest.username())\n+                    // it's nice for consistency to show the name of the realm, when possible\n+                    .field(\"realm\", inferRealmNameFromUsername.apply(changePasswordRequest.username()))\n+                    .endObject() // user\n+                    .endObject() // password\n+                    .endObject();\n+            logEntry.with(CHANGE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleRequest putRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                        .startObject(\"role\")\n+                        .field(\"name\", putRoleRequest.name())\n+                        // the \"privilege\" nested structure, where the \"name\" is left out, is closer to the event structure\n+                        // for creating API Keys\n+                        .startObject(\"privilege\")\n+                            .startArray(\"index\");\n+                                for (RoleDescriptor.IndicesPrivileges indicesPrivileges : putRoleRequest.indices()) {\n+                                    withIndicesPrivileges(builder, indicesPrivileges);\n+                                }\n+                            builder.endArray() // index\n+                            .array(\"cluster\", putRoleRequest.cluster())\n+                            .array(\"run_as\", putRoleRequest.runAs())\n+                            // the toXContent method of the {@code RoleDescriptor.ApplicationResourcePrivileges) does a good job\n+                            .field(\"application\", putRoleRequest.applicationPrivileges())\n+                            .field(\"global\");\n+                            // This fails if this list contains multiple instances of the {@code ManageApplicationPrivileges}\n+                            // Again, only the transport client can produce this, and this only introduces a different failure mode and\n+                            // not a new one (i.e. without auditing it would fail differently, but it would still fail)\n+                            ConfigurableClusterPrivileges.toXContent(builder, ToXContent.EMPTY_PARAMS,\n+                                    Arrays.asList(putRoleRequest.conditionalClusterPrivileges()));\n+                            if (putRoleRequest.metadata() != null && false == putRoleRequest.metadata().isEmpty()) {\n+                                // JSON building for the metadata might fail when encountering unknown class types.\n+                                // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                                // cause troubles in downstream code (eg metadata store), so this simply introduces a new failure mode.\n+                                // Also the malevolent metadata can only be produced by the transport client.\n+                                builder.field(\"metadata\", putRoleRequest.metadata());\n+                            }\n+                        builder.endObject() // privilege\n+                        .endObject() // role\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleMappingRequest putRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", putRoleMappingRequest.getName());\n+                    if (putRoleMappingRequest.getRoles() != null && false == putRoleMappingRequest.getRoles().isEmpty()) {\n+                        builder.field(\"role_names\", putRoleMappingRequest.getRoles());\n+                    }\n+                    if (putRoleMappingRequest.getRoleTemplates() != null && false == putRoleMappingRequest.getRoleTemplates().isEmpty()) {\n+                        // the toXContent method of the {@code TemplateRoleName} does a good job\n+                        builder.field(\"role_templates\", putRoleMappingRequest.getRoleTemplates());\n+                    }\n+                    // the toXContent methods of the {@code RoleMapperExpression} instances do a good job\n+                    builder.field(\"rule\", putRoleMappingRequest.getRules())\n+                    .field(\"enabled\", putRoleMappingRequest.isEnabled());\n+                    if (putRoleMappingRequest.getMetadata() != null && false == putRoleMappingRequest.getMetadata().isEmpty()) {\n+                        builder.field(\"metadata\", putRoleMappingRequest.getMetadata());\n+                    }\n+                    builder.endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(SetEnabledRequest setEnabledRequest) throws IOException {\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", setEnabledRequest.username())\n+                    .field(\"realm\", inferRealmNameFromUsername.apply(setEnabledRequest.username()))\n+                    .endObject() // user\n+                    .endObject();\n+            if (setEnabledRequest.enabled() != null && setEnabledRequest.enabled()) {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"enable_user\");\n+                logEntry.with(ENABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            } else {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"disable_user\");\n+                logEntry.with(DISABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            }\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutPrivilegesRequest putPrivilegesRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_privileges\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    // toXContent of {@code ApplicationPrivilegeDescriptor} does a good job\n+                    .field(\"privileges\", putPrivilegesRequest.getPrivileges())\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, createApiKeyRequest);\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(GrantApiKeyRequest grantApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, grantApiKeyRequest.getApiKeyRequest());\n+            GrantApiKeyRequest.Grant grant = grantApiKeyRequest.getGrant();\n+            builder.startObject(\"grant\")\n+                        .field(\"type\", grant.getType());\n+                        if (grant.getUsername() != null) {\n+                            builder.startObject(\"user\")\n+                                    .field(\"name\", grant.getUsername())\n+                                    .field(\"has_password\", grant.getPassword() != null)\n+                                    .endObject(); // user\n+                        }\n+                        if (grant.getAccessToken() != null) {\n+                            builder.field(\"has_access_token\", grant.getAccessToken() != null);\n+                        }\n+                    builder.endObject(); // grant\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        private void withRequestBody(XContentBuilder builder, CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            TimeValue expiration = createApiKeyRequest.getExpiration();\n+            builder.startObject(\"apikey\")\n+                    .field(\"name\", createApiKeyRequest.getName())\n+                    .field(\"expiration\", expiration != null ? expiration.toString() : null)\n+                    .startArray(\"privileges\");\n+            for (RoleDescriptor roleDescriptor : createApiKeyRequest.getRoleDescriptors()) {\n+                builder.startObject()\n+                        .startArray(\"index\");\n+                        for (RoleDescriptor.IndicesPrivileges indicesPrivileges : roleDescriptor.getIndicesPrivileges()) {\n+                            withIndicesPrivileges(builder, indicesPrivileges);\n+                        }\n+                        builder.endArray() // index\n+                        .array(\"cluster\", roleDescriptor.getClusterPrivileges())\n+                        .array(\"run_as\", roleDescriptor.getRunAs())\n+                        // the toXContent method of the {@code RoleDescriptor.ApplicationResourcePrivileges) does a good job\n+                        .array(\"application\", (Object[]) roleDescriptor.getApplicationPrivileges())\n+                        .field(\"global\");\n+                // This fails if this list contains multiple instances of the {@code ManageApplicationPrivileges}\n+                // Again, only the transport client can produce this, and this only introduces a different failure mode and\n+                // not a new one (without auditing it would fail differently, but it would still fail)\n+                ConfigurableClusterPrivileges.toXContent(builder, ToXContent.EMPTY_PARAMS,\n+                        Arrays.asList(roleDescriptor.getConditionalClusterPrivileges()));\n+                if (roleDescriptor.getMetadata() != null && false == roleDescriptor.getMetadata().isEmpty()) {\n+                    // JSON building for the metadata might fail when encountering unknown class types.\n+                    // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                    // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                    // Also the malevolent metadata can only be produced by the transport client.\n+                    builder.field(\"metadata\", roleDescriptor.getMetadata());\n+                }\n+                builder.endObject(); // privilege\n+            }\n+            builder.endArray() // privileges\n+            .endObject(); // apikey\n+        }\n+\n+        private void withIndicesPrivileges(XContentBuilder builder, RoleDescriptor.IndicesPrivileges indicesPrivileges) throws IOException {\n+            builder.startObject();\n+            builder.array(\"names\", indicesPrivileges.getIndices());\n+            builder.array(\"privileges\", indicesPrivileges.getPrivileges());\n+            if (indicesPrivileges.hasGrantedFields() || indicesPrivileges.hasDeniedFields()) {\n+                builder.startObject(\"fields\");\n+                if (indicesPrivileges.hasGrantedFields()) {\n+                    builder.array(\"grant\", indicesPrivileges.getGrantedFields());\n+                }\n+                if (indicesPrivileges.hasDeniedFields()) {\n+                    builder.array(\"except\", indicesPrivileges.getDeniedFields());\n+                }\n+                builder.endObject(); // fields\n+            }\n+            if (indicesPrivileges.getQuery() != null) {\n+                builder.startObject(\"documents\")\n+                        // \"query_string\" conveys that the DLS query is not a nested object, but a string which has quotes escaped, etc.\n+                        .field(\"query_string\", indicesPrivileges.getQuery().utf8ToString())\n+                        .endObject();\n+            }\n+            // default for \"allow_restricted_indices\" is false, and it's very common to stay that way, so don't show it unless otherwise\n+            if (indicesPrivileges.allowRestrictedIndices()) {\n+                builder.field(\"allow_restricted_indices\", indicesPrivileges.allowRestrictedIndices());\n+            }\n+            builder.endObject();\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteUserRequest deleteUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                        .field(\"name\", deleteUserRequest.username())\n+                        .field(\"realm\", inferRealmNameFromUsername.apply(deleteUserRequest.username()))\n+                    .endObject() // user\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteRoleRequest deleteRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", deleteRoleRequest.name())\n+                    .endObject() // role\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteRoleMappingRequest deleteRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", deleteRoleMappingRequest.getName())\n+                    .endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(InvalidateApiKeyRequest invalidateApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"invalidate_apikeys\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"apikeys\");\n+                if (invalidateApiKeyRequest.getIds() != null && invalidateApiKeyRequest.getIds().length > 0) {\n+                    builder.array(\"ids\", invalidateApiKeyRequest.getIds());\n+                }\n+                if (Strings.hasLength(invalidateApiKeyRequest.getName())) {\n+                    builder.field(\"name\", invalidateApiKeyRequest.getName());\n+                }\n+                builder.field(\"owned_by_authenticated_user\", invalidateApiKeyRequest.ownedByAuthenticatedUser());\n+                if (Strings.hasLength(invalidateApiKeyRequest.getUserName()) || Strings.hasLength(invalidateApiKeyRequest.getRealmName())) {\n+                    builder.startObject(\"user\")\n+                            .field(\"name\", invalidateApiKeyRequest.getUserName())\n+                            .field(\"realm\", invalidateApiKeyRequest.getRealmName())\n+                            .endObject(); // user\n+                }\n+            builder.endObject() // apikeys\n+                    .endObject();\n+            logEntry.with(INVALIDATE_API_KEYS_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeletePrivilegesRequest deletePrivilegesRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_privileges\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"privileges\")\n+                        .field(\"application\", deletePrivilegesRequest.application())\n+                        .array(\"privileges\", deletePrivilegesRequest.privileges())\n+                    .endObject() // privileges\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQwMjY0NA=="}, "originalCommit": {"oid": "79f495a568f7778dea4bd2b9cfc1eeacc88d6be2"}, "originalPosition": 892}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjcyNTAwMQ==", "bodyText": "Nit: It always gets me when Builder#build() does not return anything but relies on side effect. I'd prefer to have something like ...build().log(logger) or just plain logger.info(...build()). I am aware that we already have this pattern in other places. So I am adding this as a Nit so that no action is needed if you think otherwise.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r536725001", "createdAt": "2020-12-05T12:29:27Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -880,8 +1283,8 @@ LogEntryBuilder with(Map<String, Object> map) {\n             return this;\n         }\n \n-        StringMapMessage build() {\n-            return logEntry;\n+        void build() {\n+            logger.info(AUDIT_MARKER, logEntry);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b647408c928554973b1a27e07b38e35261495105"}, "originalPosition": 865}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjcyNTk2Ng==", "bodyText": "This is a a good change. Not related to your change, but it's interesting that we decided to call this default_file as if there could be other file realms.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r536725966", "createdAt": "2020-12-05T12:31:56Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/Realms.java", "diffHunk": "@@ -292,15 +292,15 @@ public void usageStats(ActionListener<Map<String, Object>> listener) {\n     private void addNativeRealms(List<Realm> realms) throws Exception {\n         Realm.Factory fileRealm = factories.get(FileRealmSettings.TYPE);\n         if (fileRealm != null) {\n-            var realmIdentifier = new RealmConfig.RealmIdentifier(FileRealmSettings.TYPE, \"default_\" + FileRealmSettings.TYPE);\n+            var realmIdentifier = new RealmConfig.RealmIdentifier(FileRealmSettings.TYPE, FileRealmSettings.DEFAULT_NAME);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b647408c928554973b1a27e07b38e35261495105"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjcyNjE1Mw==", "bodyText": "\ud83d\udc4d for clarity", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r536726153", "createdAt": "2020-12-05T12:32:13Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/esnative/ReservedRealm.java", "diffHunk": "@@ -67,10 +68,10 @@\n \n     public ReservedRealm(Environment env, Settings settings, NativeUsersStore nativeUsersStore, AnonymousUser anonymousUser,\n                          SecurityIndexManager securityIndex, ThreadPool threadPool) {\n-        super(new RealmConfig(new RealmConfig.RealmIdentifier(TYPE, TYPE),\n+        super(new RealmConfig(new RealmConfig.RealmIdentifier(TYPE, NAME),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b647408c928554973b1a27e07b38e35261495105"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjc3MTg2NQ==", "bodyText": "Any particular reason to use a largely similar but slightly different representation for a RoleDescriptor? I am worried that we are introducing unnecessary congitive load here for both users and us. For an example, the term privilege here is confusing imo. We already have other usages of privilege. It does not feel right to overload it. Also index vs indices, fields vs field_security, query vs documents.query_string. I am not saying that the existing names are all great and shiny. But they have the practical advantage of being around for a while and familarity. Unless we have a strong reason to do otherwise, I'd prefer to stick with them.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r536771865", "createdAt": "2020-12-05T13:50:27Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +814,332 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"role_names\", putUserRequest.roles());\n+                    if (putUserRequest.fullName() != null) {\n+                        builder.field(\"full_name\", putUserRequest.fullName());\n+                    }\n+                    if (putUserRequest.email() != null) {\n+                        builder.field(\"email\", putUserRequest.email());\n+                    }\n+                    // password and password hashes are not exposed in the audit log\n+                    builder.field(\"has_password\", putUserRequest.passwordHash() != null);\n+                    if (putUserRequest.metadata() != null && false == putUserRequest.metadata().isEmpty()) {\n+                        // JSON building for the metadata might fail when encountering unknown class types.\n+                        // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                        // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                        // Also the malevolent metadata can only be produced by the transport client.\n+                        builder.field(\"metadata\", putUserRequest.metadata());\n+                    }\n+                    builder.endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"password\")\n+                    .startObject(\"user\")\n+                    .field(\"name\", changePasswordRequest.username())\n+                    .endObject() // user\n+                    .endObject() // password\n+                    .endObject();\n+            logEntry.with(CHANGE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleRequest putRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                        .startObject(\"role\")\n+                        .field(\"name\", putRoleRequest.name())\n+                        // the \"privilege\" nested structure, where the \"name\" is left out, is closer to the event structure\n+                        // for creating API Keys\n+                        .startObject(\"privilege\")\n+                            .startArray(\"index\");\n+                                for (RoleDescriptor.IndicesPrivileges indicesPrivileges : putRoleRequest.indices()) {\n+                                    withIndicesPrivileges(builder, indicesPrivileges);\n+                                }\n+                            builder.endArray() // index\n+                            .array(\"cluster\", putRoleRequest.cluster())\n+                            .array(\"run_as\", putRoleRequest.runAs())\n+                            // the toXContent method of the {@code RoleDescriptor.ApplicationResourcePrivileges) does a good job\n+                            .field(\"application\", putRoleRequest.applicationPrivileges())\n+                            .field(\"global\");\n+                            // This fails if this list contains multiple instances of the {@code ManageApplicationPrivileges}\n+                            // Again, only the transport client can produce this, and this only introduces a different failure mode and\n+                            // not a new one (i.e. without auditing it would fail differently, but it would still fail)\n+                            ConfigurableClusterPrivileges.toXContent(builder, ToXContent.EMPTY_PARAMS,\n+                                    Arrays.asList(putRoleRequest.conditionalClusterPrivileges()));\n+                            if (putRoleRequest.metadata() != null && false == putRoleRequest.metadata().isEmpty()) {\n+                                // JSON building for the metadata might fail when encountering unknown class types.\n+                                // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                                // cause troubles in downstream code (eg metadata store), so this simply introduces a new failure mode.\n+                                // Also the malevolent metadata can only be produced by the transport client.\n+                                builder.field(\"metadata\", putRoleRequest.metadata());\n+                            }\n+                        builder.endObject() // privilege", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b647408c928554973b1a27e07b38e35261495105"}, "originalPosition": 628}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjc3MzIyNA==", "bodyText": "The null value for different arguments is handled within the constructor of RoleDescriptor. So if we want to ensure null value works the same as empty list/array/map, it seems better to have a separate test for RoleDescriptor elsewhere instead of trying to cover all variations here.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r536773224", "createdAt": "2020-12-05T13:53:03Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrailTests.java", "diffHunk": "@@ -279,6 +343,738 @@ public void testAuditFilterSettingValidation() {\n         assertThat(e, hasToString(containsString(\"invalid pattern [/no-inspiration]\")));\n     }\n \n+    public void testSecurityConfigChangeEventFormattingForRoles() throws IOException {\n+        final Path path = getDataPath(\"/org/elasticsearch/xpack/security/audit/logfile/audited_roles.txt\");\n+        final Map<String, String> auditedRolesMap = new HashMap<>();\n+        try (BufferedReader reader = new BufferedReader(new InputStreamReader(new BufferedInputStream(Files.newInputStream(path)),\n+                StandardCharsets.UTF_8))) {\n+            String line;\n+            while ((line = reader.readLine()) != null) {\n+                // even number of lines\n+                auditedRolesMap.put(line, reader.readLine());\n+            }\n+        }\n+\n+        RoleDescriptor nullRoleDescriptor = new RoleDescriptor(\"null_role\", randomFrom((String[]) null, new String[0]),\n+                randomFrom((RoleDescriptor.IndicesPrivileges[]) null, new RoleDescriptor.IndicesPrivileges[0]),\n+                randomFrom((RoleDescriptor.ApplicationResourcePrivileges[])null, new RoleDescriptor.ApplicationResourcePrivileges[0]),\n+                randomFrom((ConfigurableClusterPrivilege[])null, new ConfigurableClusterPrivilege[0]),\n+                randomFrom((String[])null, new String[0]),\n+                randomFrom((Map<String, Object>)null, Map.of()),\n+                Map.of(\"transient\", \"meta\", \"is\", \"ignored\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b647408c928554973b1a27e07b38e35261495105"}, "originalPosition": 177}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c75e4d335c26d1b08fcdd974421b8fe5f42a6230", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/c75e4d335c26d1b08fcdd974421b8fe5f42a6230", "committedDate": "2020-12-07T10:08:58Z", "message": "Merge branch 'master' into audit_request_body_for_certain_transport_requests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e6d9a35437c9c817735af2bdea627ed3e2df9768", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/e6d9a35437c9c817735af2bdea627ed3e2df9768", "committedDate": "2020-12-07T15:08:20Z", "message": "Nits"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3b8f339732a3420f49d35e277cd148fa24a3a6ad", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/3b8f339732a3420f49d35e277cd148fa24a3a6ad", "committedDate": "2020-12-09T09:54:38Z", "message": "Merge branch 'master' into audit_request_body_for_certain_transport_requests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f27629e02bf9264769464c154ee94a8b63b7c2e3", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/f27629e02bf9264769464c154ee94a8b63b7c2e3", "committedDate": "2020-12-09T14:35:07Z", "message": "Review role descriptor privileges"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8b3dcf0aa1684d0662ddfb95934c3f563db291c1", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/8b3dcf0aa1684d0662ddfb95934c3f563db291c1", "committedDate": "2020-12-09T16:12:19Z", "message": "RoleDescriptorTests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "49f7fdbae87dd4ea7011f6205435bc3bf9c369d5", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/49f7fdbae87dd4ea7011f6205435bc3bf9c369d5", "committedDate": "2020-12-09T16:50:19Z", "message": "Show run_as when empty"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "413f6136331621983c64d92831abdf983f5890b7", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/413f6136331621983c64d92831abdf983f5890b7", "committedDate": "2020-12-09T16:51:58Z", "message": "Merge branch 'master' into audit_request_body_for_certain_transport_requests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ4NzQ0ODE3", "url": "https://github.com/elastic/elasticsearch/pull/62916#pullrequestreview-548744817", "createdAt": "2020-12-10T01:16:35Z", "commit": {"oid": "413f6136331621983c64d92831abdf983f5890b7"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwMToxNjozNVrOICw6Tw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwNDoyNzowM1rOIC0-PA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc2OTQyMw==", "bodyText": "I'd change this field to be just roles because 1) It is what is used in the request; 2) ECS also has a definition of user.roles.\nI understand the argument that auditing entries do not have to be exactly the same as the request body. And in some cases they cannot be or are preferred not to be. But at the same time, this new auditing is for the request body after all. Therefore, unless there are great reasons, I'd prefer to keep the same field name.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r539769423", "createdAt": "2020-12-10T01:16:35Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +814,313 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"role_names\", putUserRequest.roles());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "413f6136331621983c64d92831abdf983f5890b7"}, "originalPosition": 561}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc3Mjg1Mw==", "bodyText": "Same here for roles vs role_names.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r539772853", "createdAt": "2020-12-10T01:25:58Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +814,313 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"role_names\", putUserRequest.roles());\n+                    if (putUserRequest.fullName() != null) {\n+                        builder.field(\"full_name\", putUserRequest.fullName());\n+                    }\n+                    if (putUserRequest.email() != null) {\n+                        builder.field(\"email\", putUserRequest.email());\n+                    }\n+                    // password and password hashes are not exposed in the audit log\n+                    builder.field(\"has_password\", putUserRequest.passwordHash() != null);\n+                    if (putUserRequest.metadata() != null && false == putUserRequest.metadata().isEmpty()) {\n+                        // JSON building for the metadata might fail when encountering unknown class types.\n+                        // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                        // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                        // Also the malevolent metadata can only be produced by the transport client.\n+                        builder.field(\"metadata\", putUserRequest.metadata());\n+                    }\n+                    builder.endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"password\")\n+                    .startObject(\"user\")\n+                    .field(\"name\", changePasswordRequest.username())\n+                    .endObject() // user\n+                    .endObject() // password\n+                    .endObject();\n+            logEntry.with(CHANGE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleRequest putRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", putRoleRequest.name())\n+                    // the \"role_descriptor\" nested structure, where the \"name\" is left out, is closer to the event structure\n+                    // for creating API Keys\n+                    .field(\"role_descriptor\");\n+            withRoleDescriptor(builder, putRoleRequest.roleDescriptor());\n+            builder.endObject() // role\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleMappingRequest putRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", putRoleMappingRequest.getName());\n+                    if (putRoleMappingRequest.getRoles() != null && false == putRoleMappingRequest.getRoles().isEmpty()) {\n+                        builder.field(\"role_names\", putRoleMappingRequest.getRoles());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "413f6136331621983c64d92831abdf983f5890b7"}, "originalPosition": 620}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc3Njk3Mg==", "bodyText": "I am abit torned by this one. I slightly prefer to call it rules, but the serialisation is a singleton map instead of an array, so rule seems to be fine.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r539776972", "createdAt": "2020-12-10T01:36:41Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +814,313 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"role_names\", putUserRequest.roles());\n+                    if (putUserRequest.fullName() != null) {\n+                        builder.field(\"full_name\", putUserRequest.fullName());\n+                    }\n+                    if (putUserRequest.email() != null) {\n+                        builder.field(\"email\", putUserRequest.email());\n+                    }\n+                    // password and password hashes are not exposed in the audit log\n+                    builder.field(\"has_password\", putUserRequest.passwordHash() != null);\n+                    if (putUserRequest.metadata() != null && false == putUserRequest.metadata().isEmpty()) {\n+                        // JSON building for the metadata might fail when encountering unknown class types.\n+                        // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                        // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                        // Also the malevolent metadata can only be produced by the transport client.\n+                        builder.field(\"metadata\", putUserRequest.metadata());\n+                    }\n+                    builder.endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"password\")\n+                    .startObject(\"user\")\n+                    .field(\"name\", changePasswordRequest.username())\n+                    .endObject() // user\n+                    .endObject() // password\n+                    .endObject();\n+            logEntry.with(CHANGE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleRequest putRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", putRoleRequest.name())\n+                    // the \"role_descriptor\" nested structure, where the \"name\" is left out, is closer to the event structure\n+                    // for creating API Keys\n+                    .field(\"role_descriptor\");\n+            withRoleDescriptor(builder, putRoleRequest.roleDescriptor());\n+            builder.endObject() // role\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleMappingRequest putRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", putRoleMappingRequest.getName());\n+                    if (putRoleMappingRequest.getRoles() != null && false == putRoleMappingRequest.getRoles().isEmpty()) {\n+                        builder.field(\"role_names\", putRoleMappingRequest.getRoles());\n+                    }\n+                    if (putRoleMappingRequest.getRoleTemplates() != null && false == putRoleMappingRequest.getRoleTemplates().isEmpty()) {\n+                        // the toXContent method of the {@code TemplateRoleName} does a good job\n+                        builder.field(\"role_templates\", putRoleMappingRequest.getRoleTemplates());\n+                    }\n+                    // the toXContent methods of the {@code RoleMapperExpression} instances do a good job\n+                    builder.field(\"rule\", putRoleMappingRequest.getRules())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "413f6136331621983c64d92831abdf983f5890b7"}, "originalPosition": 627}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc3OTQ5Nw==", "bodyText": "In my opinion, this nesting of password field can be skipped, i.e.:\n{\"change_password\": { \"user\": {\"name\": \"foo\"} }}", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r539779497", "createdAt": "2020-12-10T01:43:15Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +814,313 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"role_names\", putUserRequest.roles());\n+                    if (putUserRequest.fullName() != null) {\n+                        builder.field(\"full_name\", putUserRequest.fullName());\n+                    }\n+                    if (putUserRequest.email() != null) {\n+                        builder.field(\"email\", putUserRequest.email());\n+                    }\n+                    // password and password hashes are not exposed in the audit log\n+                    builder.field(\"has_password\", putUserRequest.passwordHash() != null);\n+                    if (putUserRequest.metadata() != null && false == putUserRequest.metadata().isEmpty()) {\n+                        // JSON building for the metadata might fail when encountering unknown class types.\n+                        // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                        // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                        // Also the malevolent metadata can only be produced by the transport client.\n+                        builder.field(\"metadata\", putUserRequest.metadata());\n+                    }\n+                    builder.endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"password\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "413f6136331621983c64d92831abdf983f5890b7"}, "originalPosition": 587}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc4MjAwOA==", "bodyText": "privileges is such an overused term. I personally think the privileges related APIs should have been more explicitly about the fact that they are for \"application privileges\". Given the choice this particular field name is entirely up to auditing (since user visible request does not have anything about it), I wonder whether it could be named as application_privileges for clarity.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r539782008", "createdAt": "2020-12-10T01:50:05Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +814,313 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"role_names\", putUserRequest.roles());\n+                    if (putUserRequest.fullName() != null) {\n+                        builder.field(\"full_name\", putUserRequest.fullName());\n+                    }\n+                    if (putUserRequest.email() != null) {\n+                        builder.field(\"email\", putUserRequest.email());\n+                    }\n+                    // password and password hashes are not exposed in the audit log\n+                    builder.field(\"has_password\", putUserRequest.passwordHash() != null);\n+                    if (putUserRequest.metadata() != null && false == putUserRequest.metadata().isEmpty()) {\n+                        // JSON building for the metadata might fail when encountering unknown class types.\n+                        // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                        // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                        // Also the malevolent metadata can only be produced by the transport client.\n+                        builder.field(\"metadata\", putUserRequest.metadata());\n+                    }\n+                    builder.endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"password\")\n+                    .startObject(\"user\")\n+                    .field(\"name\", changePasswordRequest.username())\n+                    .endObject() // user\n+                    .endObject() // password\n+                    .endObject();\n+            logEntry.with(CHANGE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleRequest putRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", putRoleRequest.name())\n+                    // the \"role_descriptor\" nested structure, where the \"name\" is left out, is closer to the event structure\n+                    // for creating API Keys\n+                    .field(\"role_descriptor\");\n+            withRoleDescriptor(builder, putRoleRequest.roleDescriptor());\n+            builder.endObject() // role\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleMappingRequest putRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", putRoleMappingRequest.getName());\n+                    if (putRoleMappingRequest.getRoles() != null && false == putRoleMappingRequest.getRoles().isEmpty()) {\n+                        builder.field(\"role_names\", putRoleMappingRequest.getRoles());\n+                    }\n+                    if (putRoleMappingRequest.getRoleTemplates() != null && false == putRoleMappingRequest.getRoleTemplates().isEmpty()) {\n+                        // the toXContent method of the {@code TemplateRoleName} does a good job\n+                        builder.field(\"role_templates\", putRoleMappingRequest.getRoleTemplates());\n+                    }\n+                    // the toXContent methods of the {@code RoleMapperExpression} instances do a good job\n+                    builder.field(\"rule\", putRoleMappingRequest.getRules())\n+                    .field(\"enabled\", putRoleMappingRequest.isEnabled());\n+                    if (putRoleMappingRequest.getMetadata() != null && false == putRoleMappingRequest.getMetadata().isEmpty()) {\n+                        builder.field(\"metadata\", putRoleMappingRequest.getMetadata());\n+                    }\n+                    builder.endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(SetEnabledRequest setEnabledRequest) throws IOException {\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", setEnabledRequest.username())\n+                    .endObject() // user\n+                    .endObject();\n+            if (setEnabledRequest.enabled() != null && setEnabledRequest.enabled()) {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"enable_user\");\n+                logEntry.with(ENABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            } else {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"disable_user\");\n+                logEntry.with(DISABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            }\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutPrivilegesRequest putPrivilegesRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_privileges\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    // toXContent of {@code ApplicationPrivilegeDescriptor} does a good job\n+                    .field(\"privileges\", putPrivilegesRequest.getPrivileges())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "413f6136331621983c64d92831abdf983f5890b7"}, "originalPosition": 660}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTgzMTI5Ng==", "bodyText": "Should this be grant_api_key and save the nested grant field?", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r539831296", "createdAt": "2020-12-10T04:11:54Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +814,313 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"role_names\", putUserRequest.roles());\n+                    if (putUserRequest.fullName() != null) {\n+                        builder.field(\"full_name\", putUserRequest.fullName());\n+                    }\n+                    if (putUserRequest.email() != null) {\n+                        builder.field(\"email\", putUserRequest.email());\n+                    }\n+                    // password and password hashes are not exposed in the audit log\n+                    builder.field(\"has_password\", putUserRequest.passwordHash() != null);\n+                    if (putUserRequest.metadata() != null && false == putUserRequest.metadata().isEmpty()) {\n+                        // JSON building for the metadata might fail when encountering unknown class types.\n+                        // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                        // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                        // Also the malevolent metadata can only be produced by the transport client.\n+                        builder.field(\"metadata\", putUserRequest.metadata());\n+                    }\n+                    builder.endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"password\")\n+                    .startObject(\"user\")\n+                    .field(\"name\", changePasswordRequest.username())\n+                    .endObject() // user\n+                    .endObject() // password\n+                    .endObject();\n+            logEntry.with(CHANGE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleRequest putRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", putRoleRequest.name())\n+                    // the \"role_descriptor\" nested structure, where the \"name\" is left out, is closer to the event structure\n+                    // for creating API Keys\n+                    .field(\"role_descriptor\");\n+            withRoleDescriptor(builder, putRoleRequest.roleDescriptor());\n+            builder.endObject() // role\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleMappingRequest putRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", putRoleMappingRequest.getName());\n+                    if (putRoleMappingRequest.getRoles() != null && false == putRoleMappingRequest.getRoles().isEmpty()) {\n+                        builder.field(\"role_names\", putRoleMappingRequest.getRoles());\n+                    }\n+                    if (putRoleMappingRequest.getRoleTemplates() != null && false == putRoleMappingRequest.getRoleTemplates().isEmpty()) {\n+                        // the toXContent method of the {@code TemplateRoleName} does a good job\n+                        builder.field(\"role_templates\", putRoleMappingRequest.getRoleTemplates());\n+                    }\n+                    // the toXContent methods of the {@code RoleMapperExpression} instances do a good job\n+                    builder.field(\"rule\", putRoleMappingRequest.getRules())\n+                    .field(\"enabled\", putRoleMappingRequest.isEnabled());\n+                    if (putRoleMappingRequest.getMetadata() != null && false == putRoleMappingRequest.getMetadata().isEmpty()) {\n+                        builder.field(\"metadata\", putRoleMappingRequest.getMetadata());\n+                    }\n+                    builder.endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(SetEnabledRequest setEnabledRequest) throws IOException {\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", setEnabledRequest.username())\n+                    .endObject() // user\n+                    .endObject();\n+            if (setEnabledRequest.enabled() != null && setEnabledRequest.enabled()) {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"enable_user\");\n+                logEntry.with(ENABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            } else {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"disable_user\");\n+                logEntry.with(DISABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            }\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutPrivilegesRequest putPrivilegesRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_privileges\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    // toXContent of {@code ApplicationPrivilegeDescriptor} does a good job\n+                    .field(\"privileges\", putPrivilegesRequest.getPrivileges())\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, createApiKeyRequest);\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(GrantApiKeyRequest grantApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "413f6136331621983c64d92831abdf983f5890b7"}, "originalPosition": 677}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTgzMTg4MA==", "bodyText": "Often times (if not all), in serialisation form, it is called api_key.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r539831880", "createdAt": "2020-12-10T04:13:50Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +814,313 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"role_names\", putUserRequest.roles());\n+                    if (putUserRequest.fullName() != null) {\n+                        builder.field(\"full_name\", putUserRequest.fullName());\n+                    }\n+                    if (putUserRequest.email() != null) {\n+                        builder.field(\"email\", putUserRequest.email());\n+                    }\n+                    // password and password hashes are not exposed in the audit log\n+                    builder.field(\"has_password\", putUserRequest.passwordHash() != null);\n+                    if (putUserRequest.metadata() != null && false == putUserRequest.metadata().isEmpty()) {\n+                        // JSON building for the metadata might fail when encountering unknown class types.\n+                        // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                        // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                        // Also the malevolent metadata can only be produced by the transport client.\n+                        builder.field(\"metadata\", putUserRequest.metadata());\n+                    }\n+                    builder.endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"password\")\n+                    .startObject(\"user\")\n+                    .field(\"name\", changePasswordRequest.username())\n+                    .endObject() // user\n+                    .endObject() // password\n+                    .endObject();\n+            logEntry.with(CHANGE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleRequest putRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", putRoleRequest.name())\n+                    // the \"role_descriptor\" nested structure, where the \"name\" is left out, is closer to the event structure\n+                    // for creating API Keys\n+                    .field(\"role_descriptor\");\n+            withRoleDescriptor(builder, putRoleRequest.roleDescriptor());\n+            builder.endObject() // role\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleMappingRequest putRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", putRoleMappingRequest.getName());\n+                    if (putRoleMappingRequest.getRoles() != null && false == putRoleMappingRequest.getRoles().isEmpty()) {\n+                        builder.field(\"role_names\", putRoleMappingRequest.getRoles());\n+                    }\n+                    if (putRoleMappingRequest.getRoleTemplates() != null && false == putRoleMappingRequest.getRoleTemplates().isEmpty()) {\n+                        // the toXContent method of the {@code TemplateRoleName} does a good job\n+                        builder.field(\"role_templates\", putRoleMappingRequest.getRoleTemplates());\n+                    }\n+                    // the toXContent methods of the {@code RoleMapperExpression} instances do a good job\n+                    builder.field(\"rule\", putRoleMappingRequest.getRules())\n+                    .field(\"enabled\", putRoleMappingRequest.isEnabled());\n+                    if (putRoleMappingRequest.getMetadata() != null && false == putRoleMappingRequest.getMetadata().isEmpty()) {\n+                        builder.field(\"metadata\", putRoleMappingRequest.getMetadata());\n+                    }\n+                    builder.endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(SetEnabledRequest setEnabledRequest) throws IOException {\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", setEnabledRequest.username())\n+                    .endObject() // user\n+                    .endObject();\n+            if (setEnabledRequest.enabled() != null && setEnabledRequest.enabled()) {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"enable_user\");\n+                logEntry.with(ENABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            } else {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"disable_user\");\n+                logEntry.with(DISABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            }\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutPrivilegesRequest putPrivilegesRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_privileges\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    // toXContent of {@code ApplicationPrivilegeDescriptor} does a good job\n+                    .field(\"privileges\", putPrivilegesRequest.getPrivileges())\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, createApiKeyRequest);\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(GrantApiKeyRequest grantApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, grantApiKeyRequest.getApiKeyRequest());\n+            GrantApiKeyRequest.Grant grant = grantApiKeyRequest.getGrant();\n+            builder.startObject(\"grant\")\n+                        .field(\"type\", grant.getType());\n+                        if (grant.getUsername() != null) {\n+                            builder.startObject(\"user\")\n+                                    .field(\"name\", grant.getUsername())\n+                                    .field(\"has_password\", grant.getPassword() != null)\n+                                    .endObject(); // user\n+                        }\n+                        if (grant.getAccessToken() != null) {\n+                            builder.field(\"has_access_token\", grant.getAccessToken() != null);\n+                        }\n+                    builder.endObject(); // grant\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        private void withRequestBody(XContentBuilder builder, CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            TimeValue expiration = createApiKeyRequest.getExpiration();\n+            builder.startObject(\"apikey\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "413f6136331621983c64d92831abdf983f5890b7"}, "originalPosition": 701}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTgzNDQ1MA==", "bodyText": "Similarly, I'd prefer api_keys.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r539834450", "createdAt": "2020-12-10T04:22:13Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +814,313 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"role_names\", putUserRequest.roles());\n+                    if (putUserRequest.fullName() != null) {\n+                        builder.field(\"full_name\", putUserRequest.fullName());\n+                    }\n+                    if (putUserRequest.email() != null) {\n+                        builder.field(\"email\", putUserRequest.email());\n+                    }\n+                    // password and password hashes are not exposed in the audit log\n+                    builder.field(\"has_password\", putUserRequest.passwordHash() != null);\n+                    if (putUserRequest.metadata() != null && false == putUserRequest.metadata().isEmpty()) {\n+                        // JSON building for the metadata might fail when encountering unknown class types.\n+                        // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                        // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                        // Also the malevolent metadata can only be produced by the transport client.\n+                        builder.field(\"metadata\", putUserRequest.metadata());\n+                    }\n+                    builder.endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"password\")\n+                    .startObject(\"user\")\n+                    .field(\"name\", changePasswordRequest.username())\n+                    .endObject() // user\n+                    .endObject() // password\n+                    .endObject();\n+            logEntry.with(CHANGE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleRequest putRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", putRoleRequest.name())\n+                    // the \"role_descriptor\" nested structure, where the \"name\" is left out, is closer to the event structure\n+                    // for creating API Keys\n+                    .field(\"role_descriptor\");\n+            withRoleDescriptor(builder, putRoleRequest.roleDescriptor());\n+            builder.endObject() // role\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleMappingRequest putRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", putRoleMappingRequest.getName());\n+                    if (putRoleMappingRequest.getRoles() != null && false == putRoleMappingRequest.getRoles().isEmpty()) {\n+                        builder.field(\"role_names\", putRoleMappingRequest.getRoles());\n+                    }\n+                    if (putRoleMappingRequest.getRoleTemplates() != null && false == putRoleMappingRequest.getRoleTemplates().isEmpty()) {\n+                        // the toXContent method of the {@code TemplateRoleName} does a good job\n+                        builder.field(\"role_templates\", putRoleMappingRequest.getRoleTemplates());\n+                    }\n+                    // the toXContent methods of the {@code RoleMapperExpression} instances do a good job\n+                    builder.field(\"rule\", putRoleMappingRequest.getRules())\n+                    .field(\"enabled\", putRoleMappingRequest.isEnabled());\n+                    if (putRoleMappingRequest.getMetadata() != null && false == putRoleMappingRequest.getMetadata().isEmpty()) {\n+                        builder.field(\"metadata\", putRoleMappingRequest.getMetadata());\n+                    }\n+                    builder.endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(SetEnabledRequest setEnabledRequest) throws IOException {\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", setEnabledRequest.username())\n+                    .endObject() // user\n+                    .endObject();\n+            if (setEnabledRequest.enabled() != null && setEnabledRequest.enabled()) {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"enable_user\");\n+                logEntry.with(ENABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            } else {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"disable_user\");\n+                logEntry.with(DISABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            }\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutPrivilegesRequest putPrivilegesRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_privileges\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    // toXContent of {@code ApplicationPrivilegeDescriptor} does a good job\n+                    .field(\"privileges\", putPrivilegesRequest.getPrivileges())\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, createApiKeyRequest);\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(GrantApiKeyRequest grantApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, grantApiKeyRequest.getApiKeyRequest());\n+            GrantApiKeyRequest.Grant grant = grantApiKeyRequest.getGrant();\n+            builder.startObject(\"grant\")\n+                        .field(\"type\", grant.getType());\n+                        if (grant.getUsername() != null) {\n+                            builder.startObject(\"user\")\n+                                    .field(\"name\", grant.getUsername())\n+                                    .field(\"has_password\", grant.getPassword() != null)\n+                                    .endObject(); // user\n+                        }\n+                        if (grant.getAccessToken() != null) {\n+                            builder.field(\"has_access_token\", grant.getAccessToken() != null);\n+                        }\n+                    builder.endObject(); // grant\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        private void withRequestBody(XContentBuilder builder, CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            TimeValue expiration = createApiKeyRequest.getExpiration();\n+            builder.startObject(\"apikey\")\n+                    .field(\"name\", createApiKeyRequest.getName())\n+                    .field(\"expiration\", expiration != null ? expiration.toString() : null)\n+                    .startArray(\"role_descriptors\");\n+            for (RoleDescriptor roleDescriptor : createApiKeyRequest.getRoleDescriptors()) {\n+                withRoleDescriptor(builder, roleDescriptor);\n+            }\n+            builder.endArray() // role_descriptors\n+            .endObject(); // apikey\n+        }\n+\n+        private void withRoleDescriptor(XContentBuilder builder, RoleDescriptor roleDescriptor) throws IOException {\n+            builder.startObject()\n+                .array(RoleDescriptor.Fields.CLUSTER.getPreferredName(), roleDescriptor.getClusterPrivileges());\n+            if (roleDescriptor.getConditionalClusterPrivileges() != null && roleDescriptor.getConditionalClusterPrivileges().length > 0) {\n+                // This fails if this list contains multiple instances of the {@code ManageApplicationPrivileges}\n+                // Again, only the transport client can produce this, and this only introduces a different failure mode and\n+                // not a new one (i.e. without auditing it would fail differently, but it would still fail)\n+                builder.field(RoleDescriptor.Fields.GLOBAL.getPreferredName());\n+                ConfigurableClusterPrivileges.toXContent(builder, ToXContent.EMPTY_PARAMS,\n+                        Arrays.asList(roleDescriptor.getConditionalClusterPrivileges()));\n+            }\n+            builder.startArray(RoleDescriptor.Fields.INDICES.getPreferredName());\n+            for (RoleDescriptor.IndicesPrivileges indicesPrivileges : roleDescriptor.getIndicesPrivileges()) {\n+                withIndicesPrivileges(builder, indicesPrivileges);\n+            }\n+            builder.endArray();\n+            // the toXContent method of the {@code RoleDescriptor.ApplicationResourcePrivileges) does a good job\n+            builder.array(RoleDescriptor.Fields.APPLICATIONS.getPreferredName(), (Object[]) roleDescriptor.getApplicationPrivileges());\n+            builder.array(RoleDescriptor.Fields.RUN_AS.getPreferredName(), roleDescriptor.getRunAs());\n+            if (roleDescriptor.getMetadata() != null && false == roleDescriptor.getMetadata().isEmpty()) {\n+                // JSON building for the metadata might fail when encountering unknown class types.\n+                // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                // Also the malevolent metadata can only be produced by the transport client.\n+                builder.field(RoleDescriptor.Fields.METADATA.getPreferredName(), roleDescriptor.getMetadata());\n+            }\n+            builder.endObject();\n+        }\n+\n+        private void withIndicesPrivileges(XContentBuilder builder, RoleDescriptor.IndicesPrivileges indicesPrivileges) throws IOException {\n+            builder.startObject();\n+            builder.array(\"names\", indicesPrivileges.getIndices());\n+            builder.array(\"privileges\", indicesPrivileges.getPrivileges());\n+            if (indicesPrivileges.isUsingFieldLevelSecurity()) {\n+                builder.startObject(RoleDescriptor.Fields.FIELD_PERMISSIONS.getPreferredName());\n+                if (indicesPrivileges.hasGrantedFields()) {\n+                    builder.array(RoleDescriptor.Fields.GRANT_FIELDS.getPreferredName(), indicesPrivileges.getGrantedFields());\n+                }\n+                if (indicesPrivileges.hasDeniedFields()) {\n+                    builder.array(RoleDescriptor.Fields.EXCEPT_FIELDS.getPreferredName(), indicesPrivileges.getDeniedFields());\n+                }\n+                builder.endObject();\n+            }\n+            if (indicesPrivileges.isUsingDocumentLevelSecurity()) {\n+                builder.field(\"query\", indicesPrivileges.getQuery().utf8ToString());\n+            }\n+            // default for \"allow_restricted_indices\" is false, and it's very common to stay that way, so don't show it unless true\n+            if (indicesPrivileges.allowRestrictedIndices()) {\n+                builder.field(\"allow_restricted_indices\", indicesPrivileges.allowRestrictedIndices());\n+            }\n+            builder.endObject();\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteUserRequest deleteUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                        .field(\"name\", deleteUserRequest.username())\n+                    .endObject() // user\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteRoleRequest deleteRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", deleteRoleRequest.name())\n+                    .endObject() // role\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteRoleMappingRequest deleteRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", deleteRoleMappingRequest.getName())\n+                    .endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(InvalidateApiKeyRequest invalidateApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"invalidate_apikeys\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"apikeys\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "413f6136331621983c64d92831abdf983f5890b7"}, "originalPosition": 805}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTgzNTA0MA==", "bodyText": "It is possible that one of them could be empty. Do we need to skip the empty value?", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r539835040", "createdAt": "2020-12-10T04:24:07Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +814,313 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"role_names\", putUserRequest.roles());\n+                    if (putUserRequest.fullName() != null) {\n+                        builder.field(\"full_name\", putUserRequest.fullName());\n+                    }\n+                    if (putUserRequest.email() != null) {\n+                        builder.field(\"email\", putUserRequest.email());\n+                    }\n+                    // password and password hashes are not exposed in the audit log\n+                    builder.field(\"has_password\", putUserRequest.passwordHash() != null);\n+                    if (putUserRequest.metadata() != null && false == putUserRequest.metadata().isEmpty()) {\n+                        // JSON building for the metadata might fail when encountering unknown class types.\n+                        // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                        // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                        // Also the malevolent metadata can only be produced by the transport client.\n+                        builder.field(\"metadata\", putUserRequest.metadata());\n+                    }\n+                    builder.endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"password\")\n+                    .startObject(\"user\")\n+                    .field(\"name\", changePasswordRequest.username())\n+                    .endObject() // user\n+                    .endObject() // password\n+                    .endObject();\n+            logEntry.with(CHANGE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleRequest putRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", putRoleRequest.name())\n+                    // the \"role_descriptor\" nested structure, where the \"name\" is left out, is closer to the event structure\n+                    // for creating API Keys\n+                    .field(\"role_descriptor\");\n+            withRoleDescriptor(builder, putRoleRequest.roleDescriptor());\n+            builder.endObject() // role\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleMappingRequest putRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", putRoleMappingRequest.getName());\n+                    if (putRoleMappingRequest.getRoles() != null && false == putRoleMappingRequest.getRoles().isEmpty()) {\n+                        builder.field(\"role_names\", putRoleMappingRequest.getRoles());\n+                    }\n+                    if (putRoleMappingRequest.getRoleTemplates() != null && false == putRoleMappingRequest.getRoleTemplates().isEmpty()) {\n+                        // the toXContent method of the {@code TemplateRoleName} does a good job\n+                        builder.field(\"role_templates\", putRoleMappingRequest.getRoleTemplates());\n+                    }\n+                    // the toXContent methods of the {@code RoleMapperExpression} instances do a good job\n+                    builder.field(\"rule\", putRoleMappingRequest.getRules())\n+                    .field(\"enabled\", putRoleMappingRequest.isEnabled());\n+                    if (putRoleMappingRequest.getMetadata() != null && false == putRoleMappingRequest.getMetadata().isEmpty()) {\n+                        builder.field(\"metadata\", putRoleMappingRequest.getMetadata());\n+                    }\n+                    builder.endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(SetEnabledRequest setEnabledRequest) throws IOException {\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", setEnabledRequest.username())\n+                    .endObject() // user\n+                    .endObject();\n+            if (setEnabledRequest.enabled() != null && setEnabledRequest.enabled()) {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"enable_user\");\n+                logEntry.with(ENABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            } else {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"disable_user\");\n+                logEntry.with(DISABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            }\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutPrivilegesRequest putPrivilegesRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_privileges\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    // toXContent of {@code ApplicationPrivilegeDescriptor} does a good job\n+                    .field(\"privileges\", putPrivilegesRequest.getPrivileges())\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, createApiKeyRequest);\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(GrantApiKeyRequest grantApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, grantApiKeyRequest.getApiKeyRequest());\n+            GrantApiKeyRequest.Grant grant = grantApiKeyRequest.getGrant();\n+            builder.startObject(\"grant\")\n+                        .field(\"type\", grant.getType());\n+                        if (grant.getUsername() != null) {\n+                            builder.startObject(\"user\")\n+                                    .field(\"name\", grant.getUsername())\n+                                    .field(\"has_password\", grant.getPassword() != null)\n+                                    .endObject(); // user\n+                        }\n+                        if (grant.getAccessToken() != null) {\n+                            builder.field(\"has_access_token\", grant.getAccessToken() != null);\n+                        }\n+                    builder.endObject(); // grant\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        private void withRequestBody(XContentBuilder builder, CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            TimeValue expiration = createApiKeyRequest.getExpiration();\n+            builder.startObject(\"apikey\")\n+                    .field(\"name\", createApiKeyRequest.getName())\n+                    .field(\"expiration\", expiration != null ? expiration.toString() : null)\n+                    .startArray(\"role_descriptors\");\n+            for (RoleDescriptor roleDescriptor : createApiKeyRequest.getRoleDescriptors()) {\n+                withRoleDescriptor(builder, roleDescriptor);\n+            }\n+            builder.endArray() // role_descriptors\n+            .endObject(); // apikey\n+        }\n+\n+        private void withRoleDescriptor(XContentBuilder builder, RoleDescriptor roleDescriptor) throws IOException {\n+            builder.startObject()\n+                .array(RoleDescriptor.Fields.CLUSTER.getPreferredName(), roleDescriptor.getClusterPrivileges());\n+            if (roleDescriptor.getConditionalClusterPrivileges() != null && roleDescriptor.getConditionalClusterPrivileges().length > 0) {\n+                // This fails if this list contains multiple instances of the {@code ManageApplicationPrivileges}\n+                // Again, only the transport client can produce this, and this only introduces a different failure mode and\n+                // not a new one (i.e. without auditing it would fail differently, but it would still fail)\n+                builder.field(RoleDescriptor.Fields.GLOBAL.getPreferredName());\n+                ConfigurableClusterPrivileges.toXContent(builder, ToXContent.EMPTY_PARAMS,\n+                        Arrays.asList(roleDescriptor.getConditionalClusterPrivileges()));\n+            }\n+            builder.startArray(RoleDescriptor.Fields.INDICES.getPreferredName());\n+            for (RoleDescriptor.IndicesPrivileges indicesPrivileges : roleDescriptor.getIndicesPrivileges()) {\n+                withIndicesPrivileges(builder, indicesPrivileges);\n+            }\n+            builder.endArray();\n+            // the toXContent method of the {@code RoleDescriptor.ApplicationResourcePrivileges) does a good job\n+            builder.array(RoleDescriptor.Fields.APPLICATIONS.getPreferredName(), (Object[]) roleDescriptor.getApplicationPrivileges());\n+            builder.array(RoleDescriptor.Fields.RUN_AS.getPreferredName(), roleDescriptor.getRunAs());\n+            if (roleDescriptor.getMetadata() != null && false == roleDescriptor.getMetadata().isEmpty()) {\n+                // JSON building for the metadata might fail when encountering unknown class types.\n+                // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                // Also the malevolent metadata can only be produced by the transport client.\n+                builder.field(RoleDescriptor.Fields.METADATA.getPreferredName(), roleDescriptor.getMetadata());\n+            }\n+            builder.endObject();\n+        }\n+\n+        private void withIndicesPrivileges(XContentBuilder builder, RoleDescriptor.IndicesPrivileges indicesPrivileges) throws IOException {\n+            builder.startObject();\n+            builder.array(\"names\", indicesPrivileges.getIndices());\n+            builder.array(\"privileges\", indicesPrivileges.getPrivileges());\n+            if (indicesPrivileges.isUsingFieldLevelSecurity()) {\n+                builder.startObject(RoleDescriptor.Fields.FIELD_PERMISSIONS.getPreferredName());\n+                if (indicesPrivileges.hasGrantedFields()) {\n+                    builder.array(RoleDescriptor.Fields.GRANT_FIELDS.getPreferredName(), indicesPrivileges.getGrantedFields());\n+                }\n+                if (indicesPrivileges.hasDeniedFields()) {\n+                    builder.array(RoleDescriptor.Fields.EXCEPT_FIELDS.getPreferredName(), indicesPrivileges.getDeniedFields());\n+                }\n+                builder.endObject();\n+            }\n+            if (indicesPrivileges.isUsingDocumentLevelSecurity()) {\n+                builder.field(\"query\", indicesPrivileges.getQuery().utf8ToString());\n+            }\n+            // default for \"allow_restricted_indices\" is false, and it's very common to stay that way, so don't show it unless true\n+            if (indicesPrivileges.allowRestrictedIndices()) {\n+                builder.field(\"allow_restricted_indices\", indicesPrivileges.allowRestrictedIndices());\n+            }\n+            builder.endObject();\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteUserRequest deleteUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                        .field(\"name\", deleteUserRequest.username())\n+                    .endObject() // user\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteRoleRequest deleteRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", deleteRoleRequest.name())\n+                    .endObject() // role\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteRoleMappingRequest deleteRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", deleteRoleMappingRequest.getName())\n+                    .endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(InvalidateApiKeyRequest invalidateApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"invalidate_apikeys\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"apikeys\");\n+                if (invalidateApiKeyRequest.getIds() != null && invalidateApiKeyRequest.getIds().length > 0) {\n+                    builder.array(\"ids\", invalidateApiKeyRequest.getIds());\n+                }\n+                if (Strings.hasLength(invalidateApiKeyRequest.getName())) {\n+                    builder.field(\"name\", invalidateApiKeyRequest.getName());\n+                }\n+                builder.field(\"owned_by_authenticated_user\", invalidateApiKeyRequest.ownedByAuthenticatedUser());\n+                if (Strings.hasLength(invalidateApiKeyRequest.getUserName()) || Strings.hasLength(invalidateApiKeyRequest.getRealmName())) {\n+                    builder.startObject(\"user\")\n+                            .field(\"name\", invalidateApiKeyRequest.getUserName())\n+                            .field(\"realm\", invalidateApiKeyRequest.getRealmName())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "413f6136331621983c64d92831abdf983f5890b7"}, "originalPosition": 816}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTgzNTk2NA==", "bodyText": "Similarly, this is probably better to be named application_privileges especially since there is an immediately nested privileges field which does not read well in my opinion.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r539835964", "createdAt": "2020-12-10T04:27:03Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +814,313 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"role_names\", putUserRequest.roles());\n+                    if (putUserRequest.fullName() != null) {\n+                        builder.field(\"full_name\", putUserRequest.fullName());\n+                    }\n+                    if (putUserRequest.email() != null) {\n+                        builder.field(\"email\", putUserRequest.email());\n+                    }\n+                    // password and password hashes are not exposed in the audit log\n+                    builder.field(\"has_password\", putUserRequest.passwordHash() != null);\n+                    if (putUserRequest.metadata() != null && false == putUserRequest.metadata().isEmpty()) {\n+                        // JSON building for the metadata might fail when encountering unknown class types.\n+                        // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                        // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                        // Also the malevolent metadata can only be produced by the transport client.\n+                        builder.field(\"metadata\", putUserRequest.metadata());\n+                    }\n+                    builder.endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"password\")\n+                    .startObject(\"user\")\n+                    .field(\"name\", changePasswordRequest.username())\n+                    .endObject() // user\n+                    .endObject() // password\n+                    .endObject();\n+            logEntry.with(CHANGE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleRequest putRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", putRoleRequest.name())\n+                    // the \"role_descriptor\" nested structure, where the \"name\" is left out, is closer to the event structure\n+                    // for creating API Keys\n+                    .field(\"role_descriptor\");\n+            withRoleDescriptor(builder, putRoleRequest.roleDescriptor());\n+            builder.endObject() // role\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleMappingRequest putRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", putRoleMappingRequest.getName());\n+                    if (putRoleMappingRequest.getRoles() != null && false == putRoleMappingRequest.getRoles().isEmpty()) {\n+                        builder.field(\"role_names\", putRoleMappingRequest.getRoles());\n+                    }\n+                    if (putRoleMappingRequest.getRoleTemplates() != null && false == putRoleMappingRequest.getRoleTemplates().isEmpty()) {\n+                        // the toXContent method of the {@code TemplateRoleName} does a good job\n+                        builder.field(\"role_templates\", putRoleMappingRequest.getRoleTemplates());\n+                    }\n+                    // the toXContent methods of the {@code RoleMapperExpression} instances do a good job\n+                    builder.field(\"rule\", putRoleMappingRequest.getRules())\n+                    .field(\"enabled\", putRoleMappingRequest.isEnabled());\n+                    if (putRoleMappingRequest.getMetadata() != null && false == putRoleMappingRequest.getMetadata().isEmpty()) {\n+                        builder.field(\"metadata\", putRoleMappingRequest.getMetadata());\n+                    }\n+                    builder.endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(SetEnabledRequest setEnabledRequest) throws IOException {\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", setEnabledRequest.username())\n+                    .endObject() // user\n+                    .endObject();\n+            if (setEnabledRequest.enabled() != null && setEnabledRequest.enabled()) {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"enable_user\");\n+                logEntry.with(ENABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            } else {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"disable_user\");\n+                logEntry.with(DISABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            }\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutPrivilegesRequest putPrivilegesRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_privileges\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    // toXContent of {@code ApplicationPrivilegeDescriptor} does a good job\n+                    .field(\"privileges\", putPrivilegesRequest.getPrivileges())\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, createApiKeyRequest);\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(GrantApiKeyRequest grantApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, grantApiKeyRequest.getApiKeyRequest());\n+            GrantApiKeyRequest.Grant grant = grantApiKeyRequest.getGrant();\n+            builder.startObject(\"grant\")\n+                        .field(\"type\", grant.getType());\n+                        if (grant.getUsername() != null) {\n+                            builder.startObject(\"user\")\n+                                    .field(\"name\", grant.getUsername())\n+                                    .field(\"has_password\", grant.getPassword() != null)\n+                                    .endObject(); // user\n+                        }\n+                        if (grant.getAccessToken() != null) {\n+                            builder.field(\"has_access_token\", grant.getAccessToken() != null);\n+                        }\n+                    builder.endObject(); // grant\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        private void withRequestBody(XContentBuilder builder, CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            TimeValue expiration = createApiKeyRequest.getExpiration();\n+            builder.startObject(\"apikey\")\n+                    .field(\"name\", createApiKeyRequest.getName())\n+                    .field(\"expiration\", expiration != null ? expiration.toString() : null)\n+                    .startArray(\"role_descriptors\");\n+            for (RoleDescriptor roleDescriptor : createApiKeyRequest.getRoleDescriptors()) {\n+                withRoleDescriptor(builder, roleDescriptor);\n+            }\n+            builder.endArray() // role_descriptors\n+            .endObject(); // apikey\n+        }\n+\n+        private void withRoleDescriptor(XContentBuilder builder, RoleDescriptor roleDescriptor) throws IOException {\n+            builder.startObject()\n+                .array(RoleDescriptor.Fields.CLUSTER.getPreferredName(), roleDescriptor.getClusterPrivileges());\n+            if (roleDescriptor.getConditionalClusterPrivileges() != null && roleDescriptor.getConditionalClusterPrivileges().length > 0) {\n+                // This fails if this list contains multiple instances of the {@code ManageApplicationPrivileges}\n+                // Again, only the transport client can produce this, and this only introduces a different failure mode and\n+                // not a new one (i.e. without auditing it would fail differently, but it would still fail)\n+                builder.field(RoleDescriptor.Fields.GLOBAL.getPreferredName());\n+                ConfigurableClusterPrivileges.toXContent(builder, ToXContent.EMPTY_PARAMS,\n+                        Arrays.asList(roleDescriptor.getConditionalClusterPrivileges()));\n+            }\n+            builder.startArray(RoleDescriptor.Fields.INDICES.getPreferredName());\n+            for (RoleDescriptor.IndicesPrivileges indicesPrivileges : roleDescriptor.getIndicesPrivileges()) {\n+                withIndicesPrivileges(builder, indicesPrivileges);\n+            }\n+            builder.endArray();\n+            // the toXContent method of the {@code RoleDescriptor.ApplicationResourcePrivileges) does a good job\n+            builder.array(RoleDescriptor.Fields.APPLICATIONS.getPreferredName(), (Object[]) roleDescriptor.getApplicationPrivileges());\n+            builder.array(RoleDescriptor.Fields.RUN_AS.getPreferredName(), roleDescriptor.getRunAs());\n+            if (roleDescriptor.getMetadata() != null && false == roleDescriptor.getMetadata().isEmpty()) {\n+                // JSON building for the metadata might fail when encountering unknown class types.\n+                // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                // Also the malevolent metadata can only be produced by the transport client.\n+                builder.field(RoleDescriptor.Fields.METADATA.getPreferredName(), roleDescriptor.getMetadata());\n+            }\n+            builder.endObject();\n+        }\n+\n+        private void withIndicesPrivileges(XContentBuilder builder, RoleDescriptor.IndicesPrivileges indicesPrivileges) throws IOException {\n+            builder.startObject();\n+            builder.array(\"names\", indicesPrivileges.getIndices());\n+            builder.array(\"privileges\", indicesPrivileges.getPrivileges());\n+            if (indicesPrivileges.isUsingFieldLevelSecurity()) {\n+                builder.startObject(RoleDescriptor.Fields.FIELD_PERMISSIONS.getPreferredName());\n+                if (indicesPrivileges.hasGrantedFields()) {\n+                    builder.array(RoleDescriptor.Fields.GRANT_FIELDS.getPreferredName(), indicesPrivileges.getGrantedFields());\n+                }\n+                if (indicesPrivileges.hasDeniedFields()) {\n+                    builder.array(RoleDescriptor.Fields.EXCEPT_FIELDS.getPreferredName(), indicesPrivileges.getDeniedFields());\n+                }\n+                builder.endObject();\n+            }\n+            if (indicesPrivileges.isUsingDocumentLevelSecurity()) {\n+                builder.field(\"query\", indicesPrivileges.getQuery().utf8ToString());\n+            }\n+            // default for \"allow_restricted_indices\" is false, and it's very common to stay that way, so don't show it unless true\n+            if (indicesPrivileges.allowRestrictedIndices()) {\n+                builder.field(\"allow_restricted_indices\", indicesPrivileges.allowRestrictedIndices());\n+            }\n+            builder.endObject();\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteUserRequest deleteUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                        .field(\"name\", deleteUserRequest.username())\n+                    .endObject() // user\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteRoleRequest deleteRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", deleteRoleRequest.name())\n+                    .endObject() // role\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteRoleMappingRequest deleteRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", deleteRoleMappingRequest.getName())\n+                    .endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(InvalidateApiKeyRequest invalidateApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"invalidate_apikeys\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"apikeys\");\n+                if (invalidateApiKeyRequest.getIds() != null && invalidateApiKeyRequest.getIds().length > 0) {\n+                    builder.array(\"ids\", invalidateApiKeyRequest.getIds());\n+                }\n+                if (Strings.hasLength(invalidateApiKeyRequest.getName())) {\n+                    builder.field(\"name\", invalidateApiKeyRequest.getName());\n+                }\n+                builder.field(\"owned_by_authenticated_user\", invalidateApiKeyRequest.ownedByAuthenticatedUser());\n+                if (Strings.hasLength(invalidateApiKeyRequest.getUserName()) || Strings.hasLength(invalidateApiKeyRequest.getRealmName())) {\n+                    builder.startObject(\"user\")\n+                            .field(\"name\", invalidateApiKeyRequest.getUserName())\n+                            .field(\"realm\", invalidateApiKeyRequest.getRealmName())\n+                            .endObject(); // user\n+                }\n+            builder.endObject() // apikeys\n+                    .endObject();\n+            logEntry.with(INVALIDATE_API_KEYS_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeletePrivilegesRequest deletePrivilegesRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_privileges\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"privileges\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "413f6136331621983c64d92831abdf983f5890b7"}, "originalPosition": 829}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a369b2f58772ce33670b47c301d994c611a06a79", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/a369b2f58772ce33670b47c301d994c611a06a79", "committedDate": "2020-12-10T07:36:17Z", "message": "Merge branch 'master' into audit_request_body_for_certain_transport_requests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "71c399c7d9cacd415d176c8460aafc16c17c4d1d", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/71c399c7d9cacd415d176c8460aafc16c17c4d1d", "committedDate": "2020-12-10T08:35:33Z", "message": "Renames++"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3008905a84ba16390b031d219bde47d1d83ca77c", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/3008905a84ba16390b031d219bde47d1d83ca77c", "committedDate": "2020-12-10T13:25:34Z", "message": "Merge branch 'master' into audit_request_body_for_certain_transport_requests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5MTYyMDc3", "url": "https://github.com/elastic/elasticsearch/pull/62916#pullrequestreview-549162077", "createdAt": "2020-12-10T12:48:32Z", "commit": {"oid": "71c399c7d9cacd415d176c8460aafc16c17c4d1d"}, "state": "APPROVED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxMjo0ODozM1rOIDHpMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxMzozOToxMVrOIDJrng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE0MTg3NQ==", "bodyText": "Nit: TransportRequest#validate is called before the requet reaches the auditing logic. For GrantApiKeyRequest, it is not possible to have some of the combinations that could be randomized here, e.g. null grant type. Anyway, I think the randomization can be argued as defensive programming.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r540141875", "createdAt": "2020-12-10T12:48:33Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrailTests.java", "diffHunk": "@@ -279,6 +343,738 @@ public void testAuditFilterSettingValidation() {\n         assertThat(e, hasToString(containsString(\"invalid pattern [/no-inspiration]\")));\n     }\n \n+    public void testSecurityConfigChangeEventFormattingForRoles() throws IOException {\n+        final Path path = getDataPath(\"/org/elasticsearch/xpack/security/audit/logfile/audited_roles.txt\");\n+        final Map<String, String> auditedRolesMap = new HashMap<>();\n+        try (BufferedReader reader = new BufferedReader(new InputStreamReader(new BufferedInputStream(Files.newInputStream(path)),\n+                StandardCharsets.UTF_8))) {\n+            String line;\n+            while ((line = reader.readLine()) != null) {\n+                // even number of lines\n+                auditedRolesMap.put(line, reader.readLine());\n+            }\n+        }\n+\n+        RoleDescriptor nullRoleDescriptor = new RoleDescriptor(\"null_role\", randomFrom((String[]) null, new String[0]),\n+                randomFrom((RoleDescriptor.IndicesPrivileges[]) null, new RoleDescriptor.IndicesPrivileges[0]),\n+                randomFrom((RoleDescriptor.ApplicationResourcePrivileges[])null, new RoleDescriptor.ApplicationResourcePrivileges[0]),\n+                randomFrom((ConfigurableClusterPrivilege[])null, new ConfigurableClusterPrivilege[0]),\n+                randomFrom((String[])null, new String[0]),\n+                randomFrom((Map<String, Object>)null, Map.of()),\n+                Map.of(\"transient\", \"meta\", \"is\", \"ignored\"));\n+        RoleDescriptor roleDescriptor1 = new RoleDescriptor(\"role_descriptor1\", new String[]{\"monitor\"},\n+                new RoleDescriptor.IndicesPrivileges[]{RoleDescriptor.IndicesPrivileges.builder()\n+                        .indices(\"test*\")\n+                        .privileges(\"read\", \"create_index\")\n+                        .grantedFields(\"grantedField1\")\n+                        .query(\"{\\\"match_all\\\":{}}\")\n+                        .allowRestrictedIndices(true)\n+                        .build()},\n+                randomFrom((RoleDescriptor.ApplicationResourcePrivileges[]) null, new RoleDescriptor.ApplicationResourcePrivileges[0]),\n+                randomFrom((ConfigurableClusterPrivilege[]) null, new ConfigurableClusterPrivilege[0]),\n+                randomFrom((String[]) null, new String[0]),\n+                randomFrom((Map<String, Object>) null, Map.of()),\n+                Map.of()\n+        );\n+        RoleDescriptor roleDescriptor2 = new RoleDescriptor(\"role_descriptor2\", randomFrom((String[]) null, new String[0]),\n+                new RoleDescriptor.IndicesPrivileges[]{\n+                        RoleDescriptor.IndicesPrivileges.builder()\n+                                .indices(\"na\\\"me\", \"*\")\n+                                .privileges(\"manage_ilm\")\n+                                .deniedFields(\"denied*\")\n+                                .query(\"{\\\"match\\\": {\\\"category\\\": \\\"click\\\"}}\")\n+                                .build(),\n+                        RoleDescriptor.IndicesPrivileges.builder()\n+                                .indices(\"/@&~(\\\\.security.*)/\")\n+                                .privileges(\"all\", \"cluster:a_wrong_*_one\")\n+                                .build()},\n+                new RoleDescriptor.ApplicationResourcePrivileges[] {\n+                        RoleDescriptor.ApplicationResourcePrivileges.builder()\n+                                .application(\"maps\")\n+                                .resources(\"raster:*\")\n+                                .privileges(\"coming\", \"up\", \"with\", \"random\", \"names\", \"is\", \"hard\")\n+                                .build()},\n+                randomFrom((ConfigurableClusterPrivilege[]) null, new ConfigurableClusterPrivilege[0]),\n+                new String[] {\"impersonated???\"},\n+                randomFrom((Map<String, Object>) null, Map.of()),\n+                Map.of()\n+        );\n+        RoleDescriptor roleDescriptor3 = new RoleDescriptor(\"role_descriptor3\", randomFrom((String[]) null, new String[0]),\n+                randomFrom((RoleDescriptor.IndicesPrivileges[]) null, new RoleDescriptor.IndicesPrivileges[0]),\n+                new RoleDescriptor.ApplicationResourcePrivileges[] {\n+                        RoleDescriptor.ApplicationResourcePrivileges.builder()\n+                                .application(\"maps\")\n+                                .resources(\"raster:*\")\n+                                .privileges(\"{\", \"}\", \"\\n\", \"\\\\\", \"\\\"\")\n+                                .build(),\n+                        RoleDescriptor.ApplicationResourcePrivileges.builder()\n+                                .application(\"maps\")\n+                                .resources(\"noooooo!!\\n\\n\\f\\\\\\\\r\", \"{\")\n+                                .privileges(\"*:*\")\n+                                .build()},\n+                randomFrom((ConfigurableClusterPrivilege[]) null, new ConfigurableClusterPrivilege[0]),\n+                new String[] {\"jack\", \"nich*\", \"//\\\"\"},\n+                Map.of(\"some meta\", 42),\n+                Map.of()\n+        );\n+        Map<String, Object> metaMap = new TreeMap<>();\n+        metaMap.put(\"?list\", List.of(\"e1\", \"e2\", \"*\"));\n+        metaMap.put(\"some other meta\", Map.of(\"r\", \"t\"));\n+        RoleDescriptor roleDescriptor4 = new RoleDescriptor(\"role_descriptor4\", new String[] {\"manage_ml\", \"grant_api_key\",\n+                \"manage_rollup\"},\n+                new RoleDescriptor.IndicesPrivileges[]{\n+                        RoleDescriptor.IndicesPrivileges.builder()\n+                                .indices(\"/. ? + * | { } [ ] ( ) \\\" \\\\/\", \"*\")\n+                                .privileges(\"read\", \"read_cross_cluster\")\n+                                .grantedFields(\"almost\", \"all*\")\n+                                .deniedFields(\"denied*\")\n+                                .build()},\n+                randomFrom((RoleDescriptor.ApplicationResourcePrivileges[]) null, new RoleDescriptor.ApplicationResourcePrivileges[0]),\n+                new ConfigurableClusterPrivilege[] {\n+                        new ConfigurableClusterPrivileges.ManageApplicationPrivileges(Set.of(\"a+b+|b+a+\"))\n+                },\n+                new String[] {\"//+a+\\\"[a]/\"},\n+                metaMap,\n+                Map.of(\"ignored\", 2)\n+        );\n+        String keyName = randomAlphaOfLength(4);\n+        TimeValue expiration = randomFrom(new TimeValue(randomNonNegativeLong(), randomFrom(TimeUnit.values())), null);\n+        List<RoleDescriptor> allTestRoleDescriptors = List.of(nullRoleDescriptor, roleDescriptor1, roleDescriptor2, roleDescriptor3,\n+                roleDescriptor4);\n+        List<RoleDescriptor> keyRoleDescriptors = randomSubsetOf(allTestRoleDescriptors);\n+        StringBuilder roleDescriptorsStringBuilder = new StringBuilder();\n+        roleDescriptorsStringBuilder.append(\"\\\"role_descriptors\\\":[\");\n+        keyRoleDescriptors.forEach(roleDescriptor -> {\n+            roleDescriptorsStringBuilder.append(auditedRolesMap.get(roleDescriptor.getName()));\n+            roleDescriptorsStringBuilder.append(',');\n+        });\n+        if (false == keyRoleDescriptors.isEmpty()) {\n+            // delete last comma\n+            roleDescriptorsStringBuilder.deleteCharAt(roleDescriptorsStringBuilder.length() - 1);\n+        }\n+        roleDescriptorsStringBuilder.append(\"]\");\n+        final String requestId = randomRequestId();\n+        final String[] expectedRoles = randomArray(0, 4, String[]::new, () -> randomBoolean() ? null : randomAlphaOfLengthBetween(1, 4));\n+        final AuthorizationInfo authorizationInfo = () -> Collections.singletonMap(PRINCIPAL_ROLES_FIELD_NAME, expectedRoles);\n+        final Authentication authentication = createAuthentication();\n+\n+        CreateApiKeyRequest createApiKeyRequest = new CreateApiKeyRequest(keyName, keyRoleDescriptors, expiration);\n+        createApiKeyRequest.setRefreshPolicy(randomFrom(WriteRequest.RefreshPolicy.values()));\n+        auditTrail.accessGranted(requestId, authentication, CreateApiKeyAction.NAME, createApiKeyRequest, authorizationInfo);\n+        StringBuilder createKeyAuditEventStringBuilder = new StringBuilder();\n+        createKeyAuditEventStringBuilder.append(\"\\\"create\\\":{\\\"apikey\\\":{\\\"name\\\":\\\"\" + keyName + \"\\\",\\\"expiration\\\":\" +\n+                (expiration != null ? \"\\\"\" + expiration.toString() + \"\\\"\" : \"null\") + \",\");\n+        createKeyAuditEventStringBuilder.append(roleDescriptorsStringBuilder.toString());\n+        createKeyAuditEventStringBuilder.append(\"}}\");\n+        String expectedCreateKeyAuditEventString = createKeyAuditEventStringBuilder.toString();\n+        List<String> output = CapturingLogger.output(logger.getName(), Level.INFO);\n+        assertThat(output.size(), is(2));\n+        String generatedCreateKeyAuditEventString = output.get(1);\n+        assertThat(generatedCreateKeyAuditEventString, containsString(expectedCreateKeyAuditEventString));\n+        generatedCreateKeyAuditEventString = generatedCreateKeyAuditEventString.replace(\", \" + expectedCreateKeyAuditEventString, \"\");\n+        MapBuilder<String, String> checkedFields = new MapBuilder<>(commonFields);\n+        checkedFields.remove(LoggingAuditTrail.ORIGIN_ADDRESS_FIELD_NAME);\n+        checkedFields.remove(LoggingAuditTrail.ORIGIN_TYPE_FIELD_NAME);\n+        checkedFields.put(\"type\", \"audit\")\n+                .put(LoggingAuditTrail.EVENT_TYPE_FIELD_NAME, \"security_config_change\")\n+                .put(LoggingAuditTrail.EVENT_ACTION_FIELD_NAME, \"create_apikey\")\n+                .put(LoggingAuditTrail.REQUEST_ID_FIELD_NAME, requestId);\n+        assertMsg(generatedCreateKeyAuditEventString, checkedFields.immutableMap());\n+        // clear log\n+        CapturingLogger.output(logger.getName(), Level.INFO).clear();\n+\n+        GrantApiKeyRequest grantApiKeyRequest = new GrantApiKeyRequest();\n+        grantApiKeyRequest.setRefreshPolicy(randomFrom(WriteRequest.RefreshPolicy.values()));\n+        grantApiKeyRequest.getGrant().setType(randomFrom(randomAlphaOfLength(8), null));\n+        grantApiKeyRequest.getGrant().setUsername(randomFrom(randomAlphaOfLength(8), null));\n+        grantApiKeyRequest.getGrant().setPassword(randomFrom(new SecureString(\"password not exposed\"), null));\n+        grantApiKeyRequest.getGrant().setAccessToken(randomFrom(new SecureString(\"access token not exposed\"), null));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71c399c7d9cacd415d176c8460aafc16c17c4d1d"}, "originalPosition": 304}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE0NTIxOA==", "bodyText": "Nit: I don't think we have any role with a null name. So this branch is not necessary.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r540145218", "createdAt": "2020-12-10T12:53:58Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrailTests.java", "diffHunk": "@@ -279,6 +343,738 @@ public void testAuditFilterSettingValidation() {\n         assertThat(e, hasToString(containsString(\"invalid pattern [/no-inspiration]\")));\n     }\n \n+    public void testSecurityConfigChangeEventFormattingForRoles() throws IOException {\n+        final Path path = getDataPath(\"/org/elasticsearch/xpack/security/audit/logfile/audited_roles.txt\");\n+        final Map<String, String> auditedRolesMap = new HashMap<>();\n+        try (BufferedReader reader = new BufferedReader(new InputStreamReader(new BufferedInputStream(Files.newInputStream(path)),\n+                StandardCharsets.UTF_8))) {\n+            String line;\n+            while ((line = reader.readLine()) != null) {\n+                // even number of lines\n+                auditedRolesMap.put(line, reader.readLine());\n+            }\n+        }\n+\n+        RoleDescriptor nullRoleDescriptor = new RoleDescriptor(\"null_role\", randomFrom((String[]) null, new String[0]),\n+                randomFrom((RoleDescriptor.IndicesPrivileges[]) null, new RoleDescriptor.IndicesPrivileges[0]),\n+                randomFrom((RoleDescriptor.ApplicationResourcePrivileges[])null, new RoleDescriptor.ApplicationResourcePrivileges[0]),\n+                randomFrom((ConfigurableClusterPrivilege[])null, new ConfigurableClusterPrivilege[0]),\n+                randomFrom((String[])null, new String[0]),\n+                randomFrom((Map<String, Object>)null, Map.of()),\n+                Map.of(\"transient\", \"meta\", \"is\", \"ignored\"));\n+        RoleDescriptor roleDescriptor1 = new RoleDescriptor(\"role_descriptor1\", new String[]{\"monitor\"},\n+                new RoleDescriptor.IndicesPrivileges[]{RoleDescriptor.IndicesPrivileges.builder()\n+                        .indices(\"test*\")\n+                        .privileges(\"read\", \"create_index\")\n+                        .grantedFields(\"grantedField1\")\n+                        .query(\"{\\\"match_all\\\":{}}\")\n+                        .allowRestrictedIndices(true)\n+                        .build()},\n+                randomFrom((RoleDescriptor.ApplicationResourcePrivileges[]) null, new RoleDescriptor.ApplicationResourcePrivileges[0]),\n+                randomFrom((ConfigurableClusterPrivilege[]) null, new ConfigurableClusterPrivilege[0]),\n+                randomFrom((String[]) null, new String[0]),\n+                randomFrom((Map<String, Object>) null, Map.of()),\n+                Map.of()\n+        );\n+        RoleDescriptor roleDescriptor2 = new RoleDescriptor(\"role_descriptor2\", randomFrom((String[]) null, new String[0]),\n+                new RoleDescriptor.IndicesPrivileges[]{\n+                        RoleDescriptor.IndicesPrivileges.builder()\n+                                .indices(\"na\\\"me\", \"*\")\n+                                .privileges(\"manage_ilm\")\n+                                .deniedFields(\"denied*\")\n+                                .query(\"{\\\"match\\\": {\\\"category\\\": \\\"click\\\"}}\")\n+                                .build(),\n+                        RoleDescriptor.IndicesPrivileges.builder()\n+                                .indices(\"/@&~(\\\\.security.*)/\")\n+                                .privileges(\"all\", \"cluster:a_wrong_*_one\")\n+                                .build()},\n+                new RoleDescriptor.ApplicationResourcePrivileges[] {\n+                        RoleDescriptor.ApplicationResourcePrivileges.builder()\n+                                .application(\"maps\")\n+                                .resources(\"raster:*\")\n+                                .privileges(\"coming\", \"up\", \"with\", \"random\", \"names\", \"is\", \"hard\")\n+                                .build()},\n+                randomFrom((ConfigurableClusterPrivilege[]) null, new ConfigurableClusterPrivilege[0]),\n+                new String[] {\"impersonated???\"},\n+                randomFrom((Map<String, Object>) null, Map.of()),\n+                Map.of()\n+        );\n+        RoleDescriptor roleDescriptor3 = new RoleDescriptor(\"role_descriptor3\", randomFrom((String[]) null, new String[0]),\n+                randomFrom((RoleDescriptor.IndicesPrivileges[]) null, new RoleDescriptor.IndicesPrivileges[0]),\n+                new RoleDescriptor.ApplicationResourcePrivileges[] {\n+                        RoleDescriptor.ApplicationResourcePrivileges.builder()\n+                                .application(\"maps\")\n+                                .resources(\"raster:*\")\n+                                .privileges(\"{\", \"}\", \"\\n\", \"\\\\\", \"\\\"\")\n+                                .build(),\n+                        RoleDescriptor.ApplicationResourcePrivileges.builder()\n+                                .application(\"maps\")\n+                                .resources(\"noooooo!!\\n\\n\\f\\\\\\\\r\", \"{\")\n+                                .privileges(\"*:*\")\n+                                .build()},\n+                randomFrom((ConfigurableClusterPrivilege[]) null, new ConfigurableClusterPrivilege[0]),\n+                new String[] {\"jack\", \"nich*\", \"//\\\"\"},\n+                Map.of(\"some meta\", 42),\n+                Map.of()\n+        );\n+        Map<String, Object> metaMap = new TreeMap<>();\n+        metaMap.put(\"?list\", List.of(\"e1\", \"e2\", \"*\"));\n+        metaMap.put(\"some other meta\", Map.of(\"r\", \"t\"));\n+        RoleDescriptor roleDescriptor4 = new RoleDescriptor(\"role_descriptor4\", new String[] {\"manage_ml\", \"grant_api_key\",\n+                \"manage_rollup\"},\n+                new RoleDescriptor.IndicesPrivileges[]{\n+                        RoleDescriptor.IndicesPrivileges.builder()\n+                                .indices(\"/. ? + * | { } [ ] ( ) \\\" \\\\/\", \"*\")\n+                                .privileges(\"read\", \"read_cross_cluster\")\n+                                .grantedFields(\"almost\", \"all*\")\n+                                .deniedFields(\"denied*\")\n+                                .build()},\n+                randomFrom((RoleDescriptor.ApplicationResourcePrivileges[]) null, new RoleDescriptor.ApplicationResourcePrivileges[0]),\n+                new ConfigurableClusterPrivilege[] {\n+                        new ConfigurableClusterPrivileges.ManageApplicationPrivileges(Set.of(\"a+b+|b+a+\"))\n+                },\n+                new String[] {\"//+a+\\\"[a]/\"},\n+                metaMap,\n+                Map.of(\"ignored\", 2)\n+        );\n+        String keyName = randomAlphaOfLength(4);\n+        TimeValue expiration = randomFrom(new TimeValue(randomNonNegativeLong(), randomFrom(TimeUnit.values())), null);\n+        List<RoleDescriptor> allTestRoleDescriptors = List.of(nullRoleDescriptor, roleDescriptor1, roleDescriptor2, roleDescriptor3,\n+                roleDescriptor4);\n+        List<RoleDescriptor> keyRoleDescriptors = randomSubsetOf(allTestRoleDescriptors);\n+        StringBuilder roleDescriptorsStringBuilder = new StringBuilder();\n+        roleDescriptorsStringBuilder.append(\"\\\"role_descriptors\\\":[\");\n+        keyRoleDescriptors.forEach(roleDescriptor -> {\n+            roleDescriptorsStringBuilder.append(auditedRolesMap.get(roleDescriptor.getName()));\n+            roleDescriptorsStringBuilder.append(',');\n+        });\n+        if (false == keyRoleDescriptors.isEmpty()) {\n+            // delete last comma\n+            roleDescriptorsStringBuilder.deleteCharAt(roleDescriptorsStringBuilder.length() - 1);\n+        }\n+        roleDescriptorsStringBuilder.append(\"]\");\n+        final String requestId = randomRequestId();\n+        final String[] expectedRoles = randomArray(0, 4, String[]::new, () -> randomBoolean() ? null : randomAlphaOfLengthBetween(1, 4));\n+        final AuthorizationInfo authorizationInfo = () -> Collections.singletonMap(PRINCIPAL_ROLES_FIELD_NAME, expectedRoles);\n+        final Authentication authentication = createAuthentication();\n+\n+        CreateApiKeyRequest createApiKeyRequest = new CreateApiKeyRequest(keyName, keyRoleDescriptors, expiration);\n+        createApiKeyRequest.setRefreshPolicy(randomFrom(WriteRequest.RefreshPolicy.values()));\n+        auditTrail.accessGranted(requestId, authentication, CreateApiKeyAction.NAME, createApiKeyRequest, authorizationInfo);\n+        StringBuilder createKeyAuditEventStringBuilder = new StringBuilder();\n+        createKeyAuditEventStringBuilder.append(\"\\\"create\\\":{\\\"apikey\\\":{\\\"name\\\":\\\"\" + keyName + \"\\\",\\\"expiration\\\":\" +\n+                (expiration != null ? \"\\\"\" + expiration.toString() + \"\\\"\" : \"null\") + \",\");\n+        createKeyAuditEventStringBuilder.append(roleDescriptorsStringBuilder.toString());\n+        createKeyAuditEventStringBuilder.append(\"}}\");\n+        String expectedCreateKeyAuditEventString = createKeyAuditEventStringBuilder.toString();\n+        List<String> output = CapturingLogger.output(logger.getName(), Level.INFO);\n+        assertThat(output.size(), is(2));\n+        String generatedCreateKeyAuditEventString = output.get(1);\n+        assertThat(generatedCreateKeyAuditEventString, containsString(expectedCreateKeyAuditEventString));\n+        generatedCreateKeyAuditEventString = generatedCreateKeyAuditEventString.replace(\", \" + expectedCreateKeyAuditEventString, \"\");\n+        MapBuilder<String, String> checkedFields = new MapBuilder<>(commonFields);\n+        checkedFields.remove(LoggingAuditTrail.ORIGIN_ADDRESS_FIELD_NAME);\n+        checkedFields.remove(LoggingAuditTrail.ORIGIN_TYPE_FIELD_NAME);\n+        checkedFields.put(\"type\", \"audit\")\n+                .put(LoggingAuditTrail.EVENT_TYPE_FIELD_NAME, \"security_config_change\")\n+                .put(LoggingAuditTrail.EVENT_ACTION_FIELD_NAME, \"create_apikey\")\n+                .put(LoggingAuditTrail.REQUEST_ID_FIELD_NAME, requestId);\n+        assertMsg(generatedCreateKeyAuditEventString, checkedFields.immutableMap());\n+        // clear log\n+        CapturingLogger.output(logger.getName(), Level.INFO).clear();\n+\n+        GrantApiKeyRequest grantApiKeyRequest = new GrantApiKeyRequest();\n+        grantApiKeyRequest.setRefreshPolicy(randomFrom(WriteRequest.RefreshPolicy.values()));\n+        grantApiKeyRequest.getGrant().setType(randomFrom(randomAlphaOfLength(8), null));\n+        grantApiKeyRequest.getGrant().setUsername(randomFrom(randomAlphaOfLength(8), null));\n+        grantApiKeyRequest.getGrant().setPassword(randomFrom(new SecureString(\"password not exposed\"), null));\n+        grantApiKeyRequest.getGrant().setAccessToken(randomFrom(new SecureString(\"access token not exposed\"), null));\n+        grantApiKeyRequest.setApiKeyRequest(createApiKeyRequest);\n+        auditTrail.accessGranted(requestId, authentication, GrantApiKeyAction.NAME, grantApiKeyRequest, authorizationInfo);\n+        output = CapturingLogger.output(logger.getName(), Level.INFO);\n+        assertThat(output.size(), is(2));\n+        String generatedGrantKeyAuditEventString = output.get(1);\n+        StringBuilder grantKeyAuditEventStringBuilder = new StringBuilder();\n+        grantKeyAuditEventStringBuilder.append(\"\\\"create\\\":{\\\"apikey\\\":{\\\"name\\\":\\\"\" + keyName + \"\\\",\\\"expiration\\\":\" +\n+                (expiration != null ? \"\\\"\" + expiration.toString() + \"\\\"\" : \"null\") + \",\");\n+        grantKeyAuditEventStringBuilder.append(roleDescriptorsStringBuilder.toString());\n+        grantKeyAuditEventStringBuilder.append(\"},\\\"grant\\\":{\\\"type\\\":\");\n+        if (grantApiKeyRequest.getGrant().getType() != null) {\n+            grantKeyAuditEventStringBuilder.append(\"\\\"\").append(grantApiKeyRequest.getGrant().getType()).append(\"\\\"\");\n+        } else {\n+            grantKeyAuditEventStringBuilder.append(\"null\");\n+        }\n+        if (grantApiKeyRequest.getGrant().getUsername() != null) {\n+            grantKeyAuditEventStringBuilder.append(\",\\\"user\\\":{\\\"name\\\":\\\"\").append(grantApiKeyRequest.getGrant().getUsername())\n+                    .append(\"\\\",\\\"has_password\\\":\").append(grantApiKeyRequest.getGrant().getPassword() != null).append(\"}\");\n+        }\n+        if (grantApiKeyRequest.getGrant().getAccessToken() != null) {\n+            grantKeyAuditEventStringBuilder.append(\",\\\"has_access_token\\\":\").append(true);\n+        }\n+        grantKeyAuditEventStringBuilder.append(\"}}\");\n+        String expectedGrantKeyAuditEventString = grantKeyAuditEventStringBuilder.toString();\n+        assertThat(generatedGrantKeyAuditEventString, containsString(expectedGrantKeyAuditEventString));\n+        generatedGrantKeyAuditEventString = generatedGrantKeyAuditEventString.replace(\", \" + expectedGrantKeyAuditEventString, \"\");\n+        checkedFields = new MapBuilder<>(commonFields);\n+        checkedFields.remove(LoggingAuditTrail.ORIGIN_ADDRESS_FIELD_NAME);\n+        checkedFields.remove(LoggingAuditTrail.ORIGIN_TYPE_FIELD_NAME);\n+        checkedFields.put(\"type\", \"audit\")\n+                .put(LoggingAuditTrail.EVENT_TYPE_FIELD_NAME, \"security_config_change\")\n+                .put(LoggingAuditTrail.EVENT_ACTION_FIELD_NAME, \"create_apikey\")\n+                .put(LoggingAuditTrail.REQUEST_ID_FIELD_NAME, requestId);\n+        assertMsg(generatedGrantKeyAuditEventString, checkedFields.immutableMap());\n+        // clear log\n+        CapturingLogger.output(logger.getName(), Level.INFO).clear();\n+\n+        PutRoleRequest putRoleRequest = new PutRoleRequest();\n+        putRoleRequest.setRefreshPolicy(randomFrom(WriteRequest.RefreshPolicy.values()));\n+        RoleDescriptor roleDescriptor = randomFrom(allTestRoleDescriptors);\n+        putRoleRequest.name(roleDescriptor.getName());\n+        putRoleRequest.cluster(roleDescriptor.getClusterPrivileges());\n+        putRoleRequest.addIndex(roleDescriptor.getIndicesPrivileges());\n+        putRoleRequest.runAs(roleDescriptor.getRunAs());\n+        putRoleRequest.conditionalCluster(roleDescriptor.getConditionalClusterPrivileges());\n+        putRoleRequest.addApplicationPrivileges(roleDescriptor.getApplicationPrivileges());\n+        putRoleRequest.metadata(roleDescriptor.getMetadata());\n+        auditTrail.accessGranted(requestId, authentication, PutRoleAction.NAME, putRoleRequest, authorizationInfo);\n+        output = CapturingLogger.output(logger.getName(), Level.INFO);\n+        assertThat(output.size(), is(2));\n+        String generatedPutRoleAuditEventString = output.get(1);\n+        StringBuilder putRoleAuditEventStringBuilder = new StringBuilder();\n+        putRoleAuditEventStringBuilder.append(\"\\\"put\\\":{\\\"role\\\":{\\\"name\\\":\\\"\" + putRoleRequest.name() + \"\\\",\")\n+                .append(\"\\\"role_descriptor\\\":\")\n+                .append(auditedRolesMap.get(putRoleRequest.name()))\n+                .append(\"}}\");\n+        String expectedPutRoleAuditEventString = putRoleAuditEventStringBuilder.toString();\n+        assertThat(generatedPutRoleAuditEventString, containsString(expectedPutRoleAuditEventString));\n+        generatedPutRoleAuditEventString = generatedPutRoleAuditEventString.replace(\", \" + expectedPutRoleAuditEventString, \"\");\n+        checkedFields = new MapBuilder<>(commonFields);\n+        checkedFields.remove(LoggingAuditTrail.ORIGIN_ADDRESS_FIELD_NAME);\n+        checkedFields.remove(LoggingAuditTrail.ORIGIN_TYPE_FIELD_NAME);\n+        checkedFields.put(\"type\", \"audit\")\n+                .put(LoggingAuditTrail.EVENT_TYPE_FIELD_NAME, \"security_config_change\")\n+                .put(LoggingAuditTrail.EVENT_ACTION_FIELD_NAME, \"put_role\")\n+                .put(LoggingAuditTrail.REQUEST_ID_FIELD_NAME, requestId);\n+        assertMsg(generatedPutRoleAuditEventString, checkedFields.immutableMap());\n+        // clear log\n+        CapturingLogger.output(logger.getName(), Level.INFO).clear();\n+\n+        DeleteRoleRequest deleteRoleRequest = new DeleteRoleRequest();\n+        deleteRoleRequest.setRefreshPolicy(randomFrom(WriteRequest.RefreshPolicy.values()));\n+        deleteRoleRequest.name(putRoleRequest.name());\n+        auditTrail.accessGranted(requestId, authentication, DeleteRoleAction.NAME, deleteRoleRequest, authorizationInfo);\n+        output = CapturingLogger.output(logger.getName(), Level.INFO);\n+        assertThat(output.size(), is(2));\n+        String generatedDeleteRoleAuditEventString = output.get(1);\n+        StringBuilder deleteRoleStringBuilder = new StringBuilder();\n+        deleteRoleStringBuilder.append(\"\\\"delete\\\":{\\\"role\\\":{\\\"name\\\":\");\n+        if (deleteRoleRequest.name() == null) {\n+            deleteRoleStringBuilder.append(\"null\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71c399c7d9cacd415d176c8460aafc16c17c4d1d"}, "originalPosition": 385}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE1Mjc0Mw==", "bodyText": "Similar situation here: I think the issue is we are using Strings#hashLength here. This means a whitespace string, e.g. \"    \" will be output literally here, while it is actually treated as not-specified in the code (tested with Strings#hasText). I'd prefer we log consistently for empty (equivalent to not-specified) values.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r540152743", "createdAt": "2020-12-10T13:05:44Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +814,313 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"roles\", putUserRequest.roles());\n+                    if (putUserRequest.fullName() != null) {\n+                        builder.field(\"full_name\", putUserRequest.fullName());\n+                    }\n+                    if (putUserRequest.email() != null) {\n+                        builder.field(\"email\", putUserRequest.email());\n+                    }\n+                    // password and password hashes are not exposed in the audit log\n+                    builder.field(\"has_password\", putUserRequest.passwordHash() != null);\n+                    if (putUserRequest.metadata() != null && false == putUserRequest.metadata().isEmpty()) {\n+                        // JSON building for the metadata might fail when encountering unknown class types.\n+                        // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                        // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                        // Also the malevolent metadata can only be produced by the transport client.\n+                        builder.field(\"metadata\", putUserRequest.metadata());\n+                    }\n+                    builder.endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"password\")\n+                    .startObject(\"user\")\n+                    .field(\"name\", changePasswordRequest.username())\n+                    .endObject() // user\n+                    .endObject() // password\n+                    .endObject();\n+            logEntry.with(CHANGE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleRequest putRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", putRoleRequest.name())\n+                    // the \"role_descriptor\" nested structure, where the \"name\" is left out, is closer to the event structure\n+                    // for creating API Keys\n+                    .field(\"role_descriptor\");\n+            withRoleDescriptor(builder, putRoleRequest.roleDescriptor());\n+            builder.endObject() // role\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleMappingRequest putRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", putRoleMappingRequest.getName());\n+                    if (putRoleMappingRequest.getRoles() != null && false == putRoleMappingRequest.getRoles().isEmpty()) {\n+                        builder.field(\"roles\", putRoleMappingRequest.getRoles());\n+                    }\n+                    if (putRoleMappingRequest.getRoleTemplates() != null && false == putRoleMappingRequest.getRoleTemplates().isEmpty()) {\n+                        // the toXContent method of the {@code TemplateRoleName} does a good job\n+                        builder.field(\"role_templates\", putRoleMappingRequest.getRoleTemplates());\n+                    }\n+                    // the toXContent methods of the {@code RoleMapperExpression} instances do a good job\n+                    builder.field(\"rules\", putRoleMappingRequest.getRules())\n+                    .field(\"enabled\", putRoleMappingRequest.isEnabled());\n+                    if (putRoleMappingRequest.getMetadata() != null && false == putRoleMappingRequest.getMetadata().isEmpty()) {\n+                        builder.field(\"metadata\", putRoleMappingRequest.getMetadata());\n+                    }\n+                    builder.endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(SetEnabledRequest setEnabledRequest) throws IOException {\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", setEnabledRequest.username())\n+                    .endObject() // user\n+                    .endObject();\n+            if (setEnabledRequest.enabled() != null && setEnabledRequest.enabled()) {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"enable_user\");\n+                logEntry.with(ENABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            } else {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"disable_user\");\n+                logEntry.with(DISABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            }\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutPrivilegesRequest putPrivilegesRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_privileges\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    // toXContent of {@code ApplicationPrivilegeDescriptor} does a good job\n+                    .field(\"privileges\", putPrivilegesRequest.getPrivileges())\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, createApiKeyRequest);\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(GrantApiKeyRequest grantApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, grantApiKeyRequest.getApiKeyRequest());\n+            GrantApiKeyRequest.Grant grant = grantApiKeyRequest.getGrant();\n+            builder.startObject(\"grant\")\n+                        .field(\"type\", grant.getType());\n+                        if (grant.getUsername() != null) {\n+                            builder.startObject(\"user\")\n+                                    .field(\"name\", grant.getUsername())\n+                                    .field(\"has_password\", grant.getPassword() != null)\n+                                    .endObject(); // user\n+                        }\n+                        if (grant.getAccessToken() != null) {\n+                            builder.field(\"has_access_token\", grant.getAccessToken() != null);\n+                        }\n+                    builder.endObject(); // grant\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        private void withRequestBody(XContentBuilder builder, CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            TimeValue expiration = createApiKeyRequest.getExpiration();\n+            builder.startObject(\"apikey\")\n+                    .field(\"name\", createApiKeyRequest.getName())\n+                    .field(\"expiration\", expiration != null ? expiration.toString() : null)\n+                    .startArray(\"role_descriptors\");\n+            for (RoleDescriptor roleDescriptor : createApiKeyRequest.getRoleDescriptors()) {\n+                withRoleDescriptor(builder, roleDescriptor);\n+            }\n+            builder.endArray() // role_descriptors\n+            .endObject(); // apikey\n+        }\n+\n+        private void withRoleDescriptor(XContentBuilder builder, RoleDescriptor roleDescriptor) throws IOException {\n+            builder.startObject()\n+                .array(RoleDescriptor.Fields.CLUSTER.getPreferredName(), roleDescriptor.getClusterPrivileges());\n+            if (roleDescriptor.getConditionalClusterPrivileges() != null && roleDescriptor.getConditionalClusterPrivileges().length > 0) {\n+                // This fails if this list contains multiple instances of the {@code ManageApplicationPrivileges}\n+                // Again, only the transport client can produce this, and this only introduces a different failure mode and\n+                // not a new one (i.e. without auditing it would fail differently, but it would still fail)\n+                builder.field(RoleDescriptor.Fields.GLOBAL.getPreferredName());\n+                ConfigurableClusterPrivileges.toXContent(builder, ToXContent.EMPTY_PARAMS,\n+                        Arrays.asList(roleDescriptor.getConditionalClusterPrivileges()));\n+            }\n+            builder.startArray(RoleDescriptor.Fields.INDICES.getPreferredName());\n+            for (RoleDescriptor.IndicesPrivileges indicesPrivileges : roleDescriptor.getIndicesPrivileges()) {\n+                withIndicesPrivileges(builder, indicesPrivileges);\n+            }\n+            builder.endArray();\n+            // the toXContent method of the {@code RoleDescriptor.ApplicationResourcePrivileges) does a good job\n+            builder.array(RoleDescriptor.Fields.APPLICATIONS.getPreferredName(), (Object[]) roleDescriptor.getApplicationPrivileges());\n+            builder.array(RoleDescriptor.Fields.RUN_AS.getPreferredName(), roleDescriptor.getRunAs());\n+            if (roleDescriptor.getMetadata() != null && false == roleDescriptor.getMetadata().isEmpty()) {\n+                // JSON building for the metadata might fail when encountering unknown class types.\n+                // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                // Also the malevolent metadata can only be produced by the transport client.\n+                builder.field(RoleDescriptor.Fields.METADATA.getPreferredName(), roleDescriptor.getMetadata());\n+            }\n+            builder.endObject();\n+        }\n+\n+        private void withIndicesPrivileges(XContentBuilder builder, RoleDescriptor.IndicesPrivileges indicesPrivileges) throws IOException {\n+            builder.startObject();\n+            builder.array(\"names\", indicesPrivileges.getIndices());\n+            builder.array(\"privileges\", indicesPrivileges.getPrivileges());\n+            if (indicesPrivileges.isUsingFieldLevelSecurity()) {\n+                builder.startObject(RoleDescriptor.Fields.FIELD_PERMISSIONS.getPreferredName());\n+                if (indicesPrivileges.hasGrantedFields()) {\n+                    builder.array(RoleDescriptor.Fields.GRANT_FIELDS.getPreferredName(), indicesPrivileges.getGrantedFields());\n+                }\n+                if (indicesPrivileges.hasDeniedFields()) {\n+                    builder.array(RoleDescriptor.Fields.EXCEPT_FIELDS.getPreferredName(), indicesPrivileges.getDeniedFields());\n+                }\n+                builder.endObject();\n+            }\n+            if (indicesPrivileges.isUsingDocumentLevelSecurity()) {\n+                builder.field(\"query\", indicesPrivileges.getQuery().utf8ToString());\n+            }\n+            // default for \"allow_restricted_indices\" is false, and it's very common to stay that way, so don't show it unless true\n+            if (indicesPrivileges.allowRestrictedIndices()) {\n+                builder.field(\"allow_restricted_indices\", indicesPrivileges.allowRestrictedIndices());\n+            }\n+            builder.endObject();\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteUserRequest deleteUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                        .field(\"name\", deleteUserRequest.username())\n+                    .endObject() // user\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteRoleRequest deleteRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", deleteRoleRequest.name())\n+                    .endObject() // role\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteRoleMappingRequest deleteRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", deleteRoleMappingRequest.getName())\n+                    .endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(InvalidateApiKeyRequest invalidateApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"invalidate_apikeys\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"apikeys\");\n+                if (invalidateApiKeyRequest.getIds() != null && invalidateApiKeyRequest.getIds().length > 0) {\n+                    builder.array(\"ids\", invalidateApiKeyRequest.getIds());\n+                }\n+                if (Strings.hasLength(invalidateApiKeyRequest.getName())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71c399c7d9cacd415d176c8460aafc16c17c4d1d"}, "originalPosition": 809}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE1MzY1NQ==", "bodyText": "Some of the usage of Strings#hasLength needs to be updated if it is changed in the main code.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r540153655", "createdAt": "2020-12-10T13:07:10Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrailTests.java", "diffHunk": "@@ -279,6 +343,738 @@ public void testAuditFilterSettingValidation() {\n         assertThat(e, hasToString(containsString(\"invalid pattern [/no-inspiration]\")));\n     }\n \n+    public void testSecurityConfigChangeEventFormattingForRoles() throws IOException {\n+        final Path path = getDataPath(\"/org/elasticsearch/xpack/security/audit/logfile/audited_roles.txt\");\n+        final Map<String, String> auditedRolesMap = new HashMap<>();\n+        try (BufferedReader reader = new BufferedReader(new InputStreamReader(new BufferedInputStream(Files.newInputStream(path)),\n+                StandardCharsets.UTF_8))) {\n+            String line;\n+            while ((line = reader.readLine()) != null) {\n+                // even number of lines\n+                auditedRolesMap.put(line, reader.readLine());\n+            }\n+        }\n+\n+        RoleDescriptor nullRoleDescriptor = new RoleDescriptor(\"null_role\", randomFrom((String[]) null, new String[0]),\n+                randomFrom((RoleDescriptor.IndicesPrivileges[]) null, new RoleDescriptor.IndicesPrivileges[0]),\n+                randomFrom((RoleDescriptor.ApplicationResourcePrivileges[])null, new RoleDescriptor.ApplicationResourcePrivileges[0]),\n+                randomFrom((ConfigurableClusterPrivilege[])null, new ConfigurableClusterPrivilege[0]),\n+                randomFrom((String[])null, new String[0]),\n+                randomFrom((Map<String, Object>)null, Map.of()),\n+                Map.of(\"transient\", \"meta\", \"is\", \"ignored\"));\n+        RoleDescriptor roleDescriptor1 = new RoleDescriptor(\"role_descriptor1\", new String[]{\"monitor\"},\n+                new RoleDescriptor.IndicesPrivileges[]{RoleDescriptor.IndicesPrivileges.builder()\n+                        .indices(\"test*\")\n+                        .privileges(\"read\", \"create_index\")\n+                        .grantedFields(\"grantedField1\")\n+                        .query(\"{\\\"match_all\\\":{}}\")\n+                        .allowRestrictedIndices(true)\n+                        .build()},\n+                randomFrom((RoleDescriptor.ApplicationResourcePrivileges[]) null, new RoleDescriptor.ApplicationResourcePrivileges[0]),\n+                randomFrom((ConfigurableClusterPrivilege[]) null, new ConfigurableClusterPrivilege[0]),\n+                randomFrom((String[]) null, new String[0]),\n+                randomFrom((Map<String, Object>) null, Map.of()),\n+                Map.of()\n+        );\n+        RoleDescriptor roleDescriptor2 = new RoleDescriptor(\"role_descriptor2\", randomFrom((String[]) null, new String[0]),\n+                new RoleDescriptor.IndicesPrivileges[]{\n+                        RoleDescriptor.IndicesPrivileges.builder()\n+                                .indices(\"na\\\"me\", \"*\")\n+                                .privileges(\"manage_ilm\")\n+                                .deniedFields(\"denied*\")\n+                                .query(\"{\\\"match\\\": {\\\"category\\\": \\\"click\\\"}}\")\n+                                .build(),\n+                        RoleDescriptor.IndicesPrivileges.builder()\n+                                .indices(\"/@&~(\\\\.security.*)/\")\n+                                .privileges(\"all\", \"cluster:a_wrong_*_one\")\n+                                .build()},\n+                new RoleDescriptor.ApplicationResourcePrivileges[] {\n+                        RoleDescriptor.ApplicationResourcePrivileges.builder()\n+                                .application(\"maps\")\n+                                .resources(\"raster:*\")\n+                                .privileges(\"coming\", \"up\", \"with\", \"random\", \"names\", \"is\", \"hard\")\n+                                .build()},\n+                randomFrom((ConfigurableClusterPrivilege[]) null, new ConfigurableClusterPrivilege[0]),\n+                new String[] {\"impersonated???\"},\n+                randomFrom((Map<String, Object>) null, Map.of()),\n+                Map.of()\n+        );\n+        RoleDescriptor roleDescriptor3 = new RoleDescriptor(\"role_descriptor3\", randomFrom((String[]) null, new String[0]),\n+                randomFrom((RoleDescriptor.IndicesPrivileges[]) null, new RoleDescriptor.IndicesPrivileges[0]),\n+                new RoleDescriptor.ApplicationResourcePrivileges[] {\n+                        RoleDescriptor.ApplicationResourcePrivileges.builder()\n+                                .application(\"maps\")\n+                                .resources(\"raster:*\")\n+                                .privileges(\"{\", \"}\", \"\\n\", \"\\\\\", \"\\\"\")\n+                                .build(),\n+                        RoleDescriptor.ApplicationResourcePrivileges.builder()\n+                                .application(\"maps\")\n+                                .resources(\"noooooo!!\\n\\n\\f\\\\\\\\r\", \"{\")\n+                                .privileges(\"*:*\")\n+                                .build()},\n+                randomFrom((ConfigurableClusterPrivilege[]) null, new ConfigurableClusterPrivilege[0]),\n+                new String[] {\"jack\", \"nich*\", \"//\\\"\"},\n+                Map.of(\"some meta\", 42),\n+                Map.of()\n+        );\n+        Map<String, Object> metaMap = new TreeMap<>();\n+        metaMap.put(\"?list\", List.of(\"e1\", \"e2\", \"*\"));\n+        metaMap.put(\"some other meta\", Map.of(\"r\", \"t\"));\n+        RoleDescriptor roleDescriptor4 = new RoleDescriptor(\"role_descriptor4\", new String[] {\"manage_ml\", \"grant_api_key\",\n+                \"manage_rollup\"},\n+                new RoleDescriptor.IndicesPrivileges[]{\n+                        RoleDescriptor.IndicesPrivileges.builder()\n+                                .indices(\"/. ? + * | { } [ ] ( ) \\\" \\\\/\", \"*\")\n+                                .privileges(\"read\", \"read_cross_cluster\")\n+                                .grantedFields(\"almost\", \"all*\")\n+                                .deniedFields(\"denied*\")\n+                                .build()},\n+                randomFrom((RoleDescriptor.ApplicationResourcePrivileges[]) null, new RoleDescriptor.ApplicationResourcePrivileges[0]),\n+                new ConfigurableClusterPrivilege[] {\n+                        new ConfigurableClusterPrivileges.ManageApplicationPrivileges(Set.of(\"a+b+|b+a+\"))\n+                },\n+                new String[] {\"//+a+\\\"[a]/\"},\n+                metaMap,\n+                Map.of(\"ignored\", 2)\n+        );\n+        String keyName = randomAlphaOfLength(4);\n+        TimeValue expiration = randomFrom(new TimeValue(randomNonNegativeLong(), randomFrom(TimeUnit.values())), null);\n+        List<RoleDescriptor> allTestRoleDescriptors = List.of(nullRoleDescriptor, roleDescriptor1, roleDescriptor2, roleDescriptor3,\n+                roleDescriptor4);\n+        List<RoleDescriptor> keyRoleDescriptors = randomSubsetOf(allTestRoleDescriptors);\n+        StringBuilder roleDescriptorsStringBuilder = new StringBuilder();\n+        roleDescriptorsStringBuilder.append(\"\\\"role_descriptors\\\":[\");\n+        keyRoleDescriptors.forEach(roleDescriptor -> {\n+            roleDescriptorsStringBuilder.append(auditedRolesMap.get(roleDescriptor.getName()));\n+            roleDescriptorsStringBuilder.append(',');\n+        });\n+        if (false == keyRoleDescriptors.isEmpty()) {\n+            // delete last comma\n+            roleDescriptorsStringBuilder.deleteCharAt(roleDescriptorsStringBuilder.length() - 1);\n+        }\n+        roleDescriptorsStringBuilder.append(\"]\");\n+        final String requestId = randomRequestId();\n+        final String[] expectedRoles = randomArray(0, 4, String[]::new, () -> randomBoolean() ? null : randomAlphaOfLengthBetween(1, 4));\n+        final AuthorizationInfo authorizationInfo = () -> Collections.singletonMap(PRINCIPAL_ROLES_FIELD_NAME, expectedRoles);\n+        final Authentication authentication = createAuthentication();\n+\n+        CreateApiKeyRequest createApiKeyRequest = new CreateApiKeyRequest(keyName, keyRoleDescriptors, expiration);\n+        createApiKeyRequest.setRefreshPolicy(randomFrom(WriteRequest.RefreshPolicy.values()));\n+        auditTrail.accessGranted(requestId, authentication, CreateApiKeyAction.NAME, createApiKeyRequest, authorizationInfo);\n+        StringBuilder createKeyAuditEventStringBuilder = new StringBuilder();\n+        createKeyAuditEventStringBuilder.append(\"\\\"create\\\":{\\\"apikey\\\":{\\\"name\\\":\\\"\" + keyName + \"\\\",\\\"expiration\\\":\" +\n+                (expiration != null ? \"\\\"\" + expiration.toString() + \"\\\"\" : \"null\") + \",\");\n+        createKeyAuditEventStringBuilder.append(roleDescriptorsStringBuilder.toString());\n+        createKeyAuditEventStringBuilder.append(\"}}\");\n+        String expectedCreateKeyAuditEventString = createKeyAuditEventStringBuilder.toString();\n+        List<String> output = CapturingLogger.output(logger.getName(), Level.INFO);\n+        assertThat(output.size(), is(2));\n+        String generatedCreateKeyAuditEventString = output.get(1);\n+        assertThat(generatedCreateKeyAuditEventString, containsString(expectedCreateKeyAuditEventString));\n+        generatedCreateKeyAuditEventString = generatedCreateKeyAuditEventString.replace(\", \" + expectedCreateKeyAuditEventString, \"\");\n+        MapBuilder<String, String> checkedFields = new MapBuilder<>(commonFields);\n+        checkedFields.remove(LoggingAuditTrail.ORIGIN_ADDRESS_FIELD_NAME);\n+        checkedFields.remove(LoggingAuditTrail.ORIGIN_TYPE_FIELD_NAME);\n+        checkedFields.put(\"type\", \"audit\")\n+                .put(LoggingAuditTrail.EVENT_TYPE_FIELD_NAME, \"security_config_change\")\n+                .put(LoggingAuditTrail.EVENT_ACTION_FIELD_NAME, \"create_apikey\")\n+                .put(LoggingAuditTrail.REQUEST_ID_FIELD_NAME, requestId);\n+        assertMsg(generatedCreateKeyAuditEventString, checkedFields.immutableMap());\n+        // clear log\n+        CapturingLogger.output(logger.getName(), Level.INFO).clear();\n+\n+        GrantApiKeyRequest grantApiKeyRequest = new GrantApiKeyRequest();\n+        grantApiKeyRequest.setRefreshPolicy(randomFrom(WriteRequest.RefreshPolicy.values()));\n+        grantApiKeyRequest.getGrant().setType(randomFrom(randomAlphaOfLength(8), null));\n+        grantApiKeyRequest.getGrant().setUsername(randomFrom(randomAlphaOfLength(8), null));\n+        grantApiKeyRequest.getGrant().setPassword(randomFrom(new SecureString(\"password not exposed\"), null));\n+        grantApiKeyRequest.getGrant().setAccessToken(randomFrom(new SecureString(\"access token not exposed\"), null));\n+        grantApiKeyRequest.setApiKeyRequest(createApiKeyRequest);\n+        auditTrail.accessGranted(requestId, authentication, GrantApiKeyAction.NAME, grantApiKeyRequest, authorizationInfo);\n+        output = CapturingLogger.output(logger.getName(), Level.INFO);\n+        assertThat(output.size(), is(2));\n+        String generatedGrantKeyAuditEventString = output.get(1);\n+        StringBuilder grantKeyAuditEventStringBuilder = new StringBuilder();\n+        grantKeyAuditEventStringBuilder.append(\"\\\"create\\\":{\\\"apikey\\\":{\\\"name\\\":\\\"\" + keyName + \"\\\",\\\"expiration\\\":\" +\n+                (expiration != null ? \"\\\"\" + expiration.toString() + \"\\\"\" : \"null\") + \",\");\n+        grantKeyAuditEventStringBuilder.append(roleDescriptorsStringBuilder.toString());\n+        grantKeyAuditEventStringBuilder.append(\"},\\\"grant\\\":{\\\"type\\\":\");\n+        if (grantApiKeyRequest.getGrant().getType() != null) {\n+            grantKeyAuditEventStringBuilder.append(\"\\\"\").append(grantApiKeyRequest.getGrant().getType()).append(\"\\\"\");\n+        } else {\n+            grantKeyAuditEventStringBuilder.append(\"null\");\n+        }\n+        if (grantApiKeyRequest.getGrant().getUsername() != null) {\n+            grantKeyAuditEventStringBuilder.append(\",\\\"user\\\":{\\\"name\\\":\\\"\").append(grantApiKeyRequest.getGrant().getUsername())\n+                    .append(\"\\\",\\\"has_password\\\":\").append(grantApiKeyRequest.getGrant().getPassword() != null).append(\"}\");\n+        }\n+        if (grantApiKeyRequest.getGrant().getAccessToken() != null) {\n+            grantKeyAuditEventStringBuilder.append(\",\\\"has_access_token\\\":\").append(true);\n+        }\n+        grantKeyAuditEventStringBuilder.append(\"}}\");\n+        String expectedGrantKeyAuditEventString = grantKeyAuditEventStringBuilder.toString();\n+        assertThat(generatedGrantKeyAuditEventString, containsString(expectedGrantKeyAuditEventString));\n+        generatedGrantKeyAuditEventString = generatedGrantKeyAuditEventString.replace(\", \" + expectedGrantKeyAuditEventString, \"\");\n+        checkedFields = new MapBuilder<>(commonFields);\n+        checkedFields.remove(LoggingAuditTrail.ORIGIN_ADDRESS_FIELD_NAME);\n+        checkedFields.remove(LoggingAuditTrail.ORIGIN_TYPE_FIELD_NAME);\n+        checkedFields.put(\"type\", \"audit\")\n+                .put(LoggingAuditTrail.EVENT_TYPE_FIELD_NAME, \"security_config_change\")\n+                .put(LoggingAuditTrail.EVENT_ACTION_FIELD_NAME, \"create_apikey\")\n+                .put(LoggingAuditTrail.REQUEST_ID_FIELD_NAME, requestId);\n+        assertMsg(generatedGrantKeyAuditEventString, checkedFields.immutableMap());\n+        // clear log\n+        CapturingLogger.output(logger.getName(), Level.INFO).clear();\n+\n+        PutRoleRequest putRoleRequest = new PutRoleRequest();\n+        putRoleRequest.setRefreshPolicy(randomFrom(WriteRequest.RefreshPolicy.values()));\n+        RoleDescriptor roleDescriptor = randomFrom(allTestRoleDescriptors);\n+        putRoleRequest.name(roleDescriptor.getName());\n+        putRoleRequest.cluster(roleDescriptor.getClusterPrivileges());\n+        putRoleRequest.addIndex(roleDescriptor.getIndicesPrivileges());\n+        putRoleRequest.runAs(roleDescriptor.getRunAs());\n+        putRoleRequest.conditionalCluster(roleDescriptor.getConditionalClusterPrivileges());\n+        putRoleRequest.addApplicationPrivileges(roleDescriptor.getApplicationPrivileges());\n+        putRoleRequest.metadata(roleDescriptor.getMetadata());\n+        auditTrail.accessGranted(requestId, authentication, PutRoleAction.NAME, putRoleRequest, authorizationInfo);\n+        output = CapturingLogger.output(logger.getName(), Level.INFO);\n+        assertThat(output.size(), is(2));\n+        String generatedPutRoleAuditEventString = output.get(1);\n+        StringBuilder putRoleAuditEventStringBuilder = new StringBuilder();\n+        putRoleAuditEventStringBuilder.append(\"\\\"put\\\":{\\\"role\\\":{\\\"name\\\":\\\"\" + putRoleRequest.name() + \"\\\",\")\n+                .append(\"\\\"role_descriptor\\\":\")\n+                .append(auditedRolesMap.get(putRoleRequest.name()))\n+                .append(\"}}\");\n+        String expectedPutRoleAuditEventString = putRoleAuditEventStringBuilder.toString();\n+        assertThat(generatedPutRoleAuditEventString, containsString(expectedPutRoleAuditEventString));\n+        generatedPutRoleAuditEventString = generatedPutRoleAuditEventString.replace(\", \" + expectedPutRoleAuditEventString, \"\");\n+        checkedFields = new MapBuilder<>(commonFields);\n+        checkedFields.remove(LoggingAuditTrail.ORIGIN_ADDRESS_FIELD_NAME);\n+        checkedFields.remove(LoggingAuditTrail.ORIGIN_TYPE_FIELD_NAME);\n+        checkedFields.put(\"type\", \"audit\")\n+                .put(LoggingAuditTrail.EVENT_TYPE_FIELD_NAME, \"security_config_change\")\n+                .put(LoggingAuditTrail.EVENT_ACTION_FIELD_NAME, \"put_role\")\n+                .put(LoggingAuditTrail.REQUEST_ID_FIELD_NAME, requestId);\n+        assertMsg(generatedPutRoleAuditEventString, checkedFields.immutableMap());\n+        // clear log\n+        CapturingLogger.output(logger.getName(), Level.INFO).clear();\n+\n+        DeleteRoleRequest deleteRoleRequest = new DeleteRoleRequest();\n+        deleteRoleRequest.setRefreshPolicy(randomFrom(WriteRequest.RefreshPolicy.values()));\n+        deleteRoleRequest.name(putRoleRequest.name());\n+        auditTrail.accessGranted(requestId, authentication, DeleteRoleAction.NAME, deleteRoleRequest, authorizationInfo);\n+        output = CapturingLogger.output(logger.getName(), Level.INFO);\n+        assertThat(output.size(), is(2));\n+        String generatedDeleteRoleAuditEventString = output.get(1);\n+        StringBuilder deleteRoleStringBuilder = new StringBuilder();\n+        deleteRoleStringBuilder.append(\"\\\"delete\\\":{\\\"role\\\":{\\\"name\\\":\");\n+        if (deleteRoleRequest.name() == null) {\n+            deleteRoleStringBuilder.append(\"null\");\n+        } else {\n+            deleteRoleStringBuilder.append(\"\\\"\").append(deleteRoleRequest.name()).append(\"\\\"\");\n+        }\n+        deleteRoleStringBuilder.append(\"}}\");\n+        String expectedDeleteRoleAuditEventString = deleteRoleStringBuilder.toString();\n+        assertThat(generatedDeleteRoleAuditEventString, containsString(expectedDeleteRoleAuditEventString));\n+        generatedDeleteRoleAuditEventString =\n+                generatedDeleteRoleAuditEventString.replace(\", \" + expectedDeleteRoleAuditEventString,\"\");\n+        checkedFields = new MapBuilder<>(commonFields);\n+        checkedFields.remove(LoggingAuditTrail.ORIGIN_ADDRESS_FIELD_NAME);\n+        checkedFields.remove(LoggingAuditTrail.ORIGIN_TYPE_FIELD_NAME);\n+        checkedFields.put(\"type\", \"audit\")\n+                .put(LoggingAuditTrail.EVENT_TYPE_FIELD_NAME, \"security_config_change\")\n+                .put(LoggingAuditTrail.EVENT_ACTION_FIELD_NAME, \"delete_role\")\n+                .put(LoggingAuditTrail.REQUEST_ID_FIELD_NAME, requestId);\n+        assertMsg(generatedDeleteRoleAuditEventString, checkedFields.immutableMap());\n+    }\n+\n+    public void testSecurityConfigChangeEventFormattingForApiKeyInvalidation() throws IOException {\n+        final String requestId = randomRequestId();\n+        final String[] expectedRoles = randomArray(0, 4, String[]::new, () -> randomBoolean() ? null : randomAlphaOfLengthBetween(1, 4));\n+        final AuthorizationInfo authorizationInfo = () -> Collections.singletonMap(PRINCIPAL_ROLES_FIELD_NAME, expectedRoles);\n+        final Authentication authentication = createAuthentication();\n+\n+        final InvalidateApiKeyRequest invalidateApiKeyRequest;\n+        if (randomBoolean()) {\n+            invalidateApiKeyRequest = new InvalidateApiKeyRequest(randomFrom(randomAlphaOfLength(8), null),\n+                    randomFrom(randomAlphaOfLength(8), null), null, randomFrom(randomAlphaOfLength(8), null), randomBoolean(),\n+                    randomFrom(randomArray(3, String[]::new, () -> randomAlphaOfLength(8)), null));\n+        } else {\n+            invalidateApiKeyRequest = new InvalidateApiKeyRequest(randomFrom(randomAlphaOfLength(8), null),\n+                    randomFrom(randomAlphaOfLength(8), null), randomAlphaOfLength(8), randomFrom(randomAlphaOfLength(8), null),\n+                    randomBoolean());\n+        }\n+        auditTrail.accessGranted(requestId, authentication, InvalidateApiKeyAction.NAME, invalidateApiKeyRequest, authorizationInfo);\n+        List<String> output = CapturingLogger.output(logger.getName(), Level.INFO);\n+        assertThat(output.size(), is(2));\n+        String generatedInvalidateKeyAuditEventString = output.get(1);\n+        StringBuilder invalidateKeyEventStringBuilder = new StringBuilder();\n+        invalidateKeyEventStringBuilder.append(\"\\\"invalidate\\\":{\\\"apikeys\\\":{\");\n+        if (invalidateApiKeyRequest.getIds() != null && invalidateApiKeyRequest.getIds().length > 0) {\n+            invalidateKeyEventStringBuilder.append(\"\\\"ids\\\":[\");\n+            for (String apiKeyId : invalidateApiKeyRequest.getIds()) {\n+                invalidateKeyEventStringBuilder.append(\"\\\"\").append(apiKeyId).append(\"\\\",\");\n+            }\n+            // delete last comma\n+            invalidateKeyEventStringBuilder.deleteCharAt(invalidateKeyEventStringBuilder.length() - 1);\n+            invalidateKeyEventStringBuilder.append(\"],\");\n+        }\n+        if (Strings.hasLength(invalidateApiKeyRequest.getName())) {\n+            invalidateKeyEventStringBuilder.append(\"\\\"name\\\":\\\"\").append(invalidateApiKeyRequest.getName()).append(\"\\\",\");\n+        }\n+        invalidateKeyEventStringBuilder.append(\"\\\"owned_by_authenticated_user\\\":\")\n+                .append(invalidateApiKeyRequest.ownedByAuthenticatedUser());\n+        if (Strings.hasLength(invalidateApiKeyRequest.getUserName()) || Strings.hasLength(invalidateApiKeyRequest.getRealmName())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71c399c7d9cacd415d176c8460aafc16c17c4d1d"}, "originalPosition": 440}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE3NTI2Mg==", "bodyText": "I think some of the issue here is the usage of Strings#hasLength, while the Request and Handler code uses Strings#hasText, which eliminates strings of all whitespace. So if you change it to hasText, it will at least get rid of the logging for a string like \"    \".\nI wasn't sure before but now I think I prefer to skip the empty values:\n\nIf null values are really that important here and should be logged, then we should always log them. This means even when both realmName and userName are null, we should log them, because they mean all. But I think this is apparently too much. So the opposite approach, which I prefer, is to not log them on missing values.\nBecause of the internal leniency of the InvalidateApiKeyRequest, empty values can take multiple forms. It is a hassle to consolidate them. And as you said, the right place for the consolidation is in the Request class itself. But I don't think we should drag it into this PR. Therefore, instead of logging different formats of \"null\" value, skipping them at least has the benefit of consistency.\nEven though null has the practical effect of all here, I don't think it really is that special. In my opinion, it is quite obvious because all these variables are search criteria. If not specified, it's obvious that it should take no effect. Also strictly speaking, null does not mean all. It really just means \"missing\" because you will not see it in the final search query at all. The cluster privileges in RoleDescriptor is a different story because it is not a search query, so its meaning could be ambiguous when skipped. If anything, the RoleDescriptor's query field is skipped on missing value because it is also a search criteria.\n\nSo my concrete suggestion would be to use Strings#hasText here and skip empty values.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r540175262", "createdAt": "2020-12-10T13:39:11Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +814,313 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"role_names\", putUserRequest.roles());\n+                    if (putUserRequest.fullName() != null) {\n+                        builder.field(\"full_name\", putUserRequest.fullName());\n+                    }\n+                    if (putUserRequest.email() != null) {\n+                        builder.field(\"email\", putUserRequest.email());\n+                    }\n+                    // password and password hashes are not exposed in the audit log\n+                    builder.field(\"has_password\", putUserRequest.passwordHash() != null);\n+                    if (putUserRequest.metadata() != null && false == putUserRequest.metadata().isEmpty()) {\n+                        // JSON building for the metadata might fail when encountering unknown class types.\n+                        // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                        // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                        // Also the malevolent metadata can only be produced by the transport client.\n+                        builder.field(\"metadata\", putUserRequest.metadata());\n+                    }\n+                    builder.endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"password\")\n+                    .startObject(\"user\")\n+                    .field(\"name\", changePasswordRequest.username())\n+                    .endObject() // user\n+                    .endObject() // password\n+                    .endObject();\n+            logEntry.with(CHANGE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleRequest putRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", putRoleRequest.name())\n+                    // the \"role_descriptor\" nested structure, where the \"name\" is left out, is closer to the event structure\n+                    // for creating API Keys\n+                    .field(\"role_descriptor\");\n+            withRoleDescriptor(builder, putRoleRequest.roleDescriptor());\n+            builder.endObject() // role\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleMappingRequest putRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", putRoleMappingRequest.getName());\n+                    if (putRoleMappingRequest.getRoles() != null && false == putRoleMappingRequest.getRoles().isEmpty()) {\n+                        builder.field(\"role_names\", putRoleMappingRequest.getRoles());\n+                    }\n+                    if (putRoleMappingRequest.getRoleTemplates() != null && false == putRoleMappingRequest.getRoleTemplates().isEmpty()) {\n+                        // the toXContent method of the {@code TemplateRoleName} does a good job\n+                        builder.field(\"role_templates\", putRoleMappingRequest.getRoleTemplates());\n+                    }\n+                    // the toXContent methods of the {@code RoleMapperExpression} instances do a good job\n+                    builder.field(\"rule\", putRoleMappingRequest.getRules())\n+                    .field(\"enabled\", putRoleMappingRequest.isEnabled());\n+                    if (putRoleMappingRequest.getMetadata() != null && false == putRoleMappingRequest.getMetadata().isEmpty()) {\n+                        builder.field(\"metadata\", putRoleMappingRequest.getMetadata());\n+                    }\n+                    builder.endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(SetEnabledRequest setEnabledRequest) throws IOException {\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", setEnabledRequest.username())\n+                    .endObject() // user\n+                    .endObject();\n+            if (setEnabledRequest.enabled() != null && setEnabledRequest.enabled()) {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"enable_user\");\n+                logEntry.with(ENABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            } else {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"disable_user\");\n+                logEntry.with(DISABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            }\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutPrivilegesRequest putPrivilegesRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_privileges\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    // toXContent of {@code ApplicationPrivilegeDescriptor} does a good job\n+                    .field(\"privileges\", putPrivilegesRequest.getPrivileges())\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, createApiKeyRequest);\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(GrantApiKeyRequest grantApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, grantApiKeyRequest.getApiKeyRequest());\n+            GrantApiKeyRequest.Grant grant = grantApiKeyRequest.getGrant();\n+            builder.startObject(\"grant\")\n+                        .field(\"type\", grant.getType());\n+                        if (grant.getUsername() != null) {\n+                            builder.startObject(\"user\")\n+                                    .field(\"name\", grant.getUsername())\n+                                    .field(\"has_password\", grant.getPassword() != null)\n+                                    .endObject(); // user\n+                        }\n+                        if (grant.getAccessToken() != null) {\n+                            builder.field(\"has_access_token\", grant.getAccessToken() != null);\n+                        }\n+                    builder.endObject(); // grant\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        private void withRequestBody(XContentBuilder builder, CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            TimeValue expiration = createApiKeyRequest.getExpiration();\n+            builder.startObject(\"apikey\")\n+                    .field(\"name\", createApiKeyRequest.getName())\n+                    .field(\"expiration\", expiration != null ? expiration.toString() : null)\n+                    .startArray(\"role_descriptors\");\n+            for (RoleDescriptor roleDescriptor : createApiKeyRequest.getRoleDescriptors()) {\n+                withRoleDescriptor(builder, roleDescriptor);\n+            }\n+            builder.endArray() // role_descriptors\n+            .endObject(); // apikey\n+        }\n+\n+        private void withRoleDescriptor(XContentBuilder builder, RoleDescriptor roleDescriptor) throws IOException {\n+            builder.startObject()\n+                .array(RoleDescriptor.Fields.CLUSTER.getPreferredName(), roleDescriptor.getClusterPrivileges());\n+            if (roleDescriptor.getConditionalClusterPrivileges() != null && roleDescriptor.getConditionalClusterPrivileges().length > 0) {\n+                // This fails if this list contains multiple instances of the {@code ManageApplicationPrivileges}\n+                // Again, only the transport client can produce this, and this only introduces a different failure mode and\n+                // not a new one (i.e. without auditing it would fail differently, but it would still fail)\n+                builder.field(RoleDescriptor.Fields.GLOBAL.getPreferredName());\n+                ConfigurableClusterPrivileges.toXContent(builder, ToXContent.EMPTY_PARAMS,\n+                        Arrays.asList(roleDescriptor.getConditionalClusterPrivileges()));\n+            }\n+            builder.startArray(RoleDescriptor.Fields.INDICES.getPreferredName());\n+            for (RoleDescriptor.IndicesPrivileges indicesPrivileges : roleDescriptor.getIndicesPrivileges()) {\n+                withIndicesPrivileges(builder, indicesPrivileges);\n+            }\n+            builder.endArray();\n+            // the toXContent method of the {@code RoleDescriptor.ApplicationResourcePrivileges) does a good job\n+            builder.array(RoleDescriptor.Fields.APPLICATIONS.getPreferredName(), (Object[]) roleDescriptor.getApplicationPrivileges());\n+            builder.array(RoleDescriptor.Fields.RUN_AS.getPreferredName(), roleDescriptor.getRunAs());\n+            if (roleDescriptor.getMetadata() != null && false == roleDescriptor.getMetadata().isEmpty()) {\n+                // JSON building for the metadata might fail when encountering unknown class types.\n+                // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                // Also the malevolent metadata can only be produced by the transport client.\n+                builder.field(RoleDescriptor.Fields.METADATA.getPreferredName(), roleDescriptor.getMetadata());\n+            }\n+            builder.endObject();\n+        }\n+\n+        private void withIndicesPrivileges(XContentBuilder builder, RoleDescriptor.IndicesPrivileges indicesPrivileges) throws IOException {\n+            builder.startObject();\n+            builder.array(\"names\", indicesPrivileges.getIndices());\n+            builder.array(\"privileges\", indicesPrivileges.getPrivileges());\n+            if (indicesPrivileges.isUsingFieldLevelSecurity()) {\n+                builder.startObject(RoleDescriptor.Fields.FIELD_PERMISSIONS.getPreferredName());\n+                if (indicesPrivileges.hasGrantedFields()) {\n+                    builder.array(RoleDescriptor.Fields.GRANT_FIELDS.getPreferredName(), indicesPrivileges.getGrantedFields());\n+                }\n+                if (indicesPrivileges.hasDeniedFields()) {\n+                    builder.array(RoleDescriptor.Fields.EXCEPT_FIELDS.getPreferredName(), indicesPrivileges.getDeniedFields());\n+                }\n+                builder.endObject();\n+            }\n+            if (indicesPrivileges.isUsingDocumentLevelSecurity()) {\n+                builder.field(\"query\", indicesPrivileges.getQuery().utf8ToString());\n+            }\n+            // default for \"allow_restricted_indices\" is false, and it's very common to stay that way, so don't show it unless true\n+            if (indicesPrivileges.allowRestrictedIndices()) {\n+                builder.field(\"allow_restricted_indices\", indicesPrivileges.allowRestrictedIndices());\n+            }\n+            builder.endObject();\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteUserRequest deleteUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                        .field(\"name\", deleteUserRequest.username())\n+                    .endObject() // user\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteRoleRequest deleteRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", deleteRoleRequest.name())\n+                    .endObject() // role\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(DeleteRoleMappingRequest deleteRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"delete_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", deleteRoleMappingRequest.getName())\n+                    .endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(DELETE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(InvalidateApiKeyRequest invalidateApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"invalidate_apikeys\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"apikeys\");\n+                if (invalidateApiKeyRequest.getIds() != null && invalidateApiKeyRequest.getIds().length > 0) {\n+                    builder.array(\"ids\", invalidateApiKeyRequest.getIds());\n+                }\n+                if (Strings.hasLength(invalidateApiKeyRequest.getName())) {\n+                    builder.field(\"name\", invalidateApiKeyRequest.getName());\n+                }\n+                builder.field(\"owned_by_authenticated_user\", invalidateApiKeyRequest.ownedByAuthenticatedUser());\n+                if (Strings.hasLength(invalidateApiKeyRequest.getUserName()) || Strings.hasLength(invalidateApiKeyRequest.getRealmName())) {\n+                    builder.startObject(\"user\")\n+                            .field(\"name\", invalidateApiKeyRequest.getUserName())\n+                            .field(\"realm\", invalidateApiKeyRequest.getRealmName())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTgzNTA0MA=="}, "originalCommit": {"oid": "413f6136331621983c64d92831abdf983f5890b7"}, "originalPosition": 816}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUxMDcxMzQ2", "url": "https://github.com/elastic/elasticsearch/pull/62916#pullrequestreview-551071346", "createdAt": "2020-12-14T06:21:38Z", "commit": {"oid": "413f6136331621983c64d92831abdf983f5890b7"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQwNjoyMjoyMlrOIFBhMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQwNjoyNzoxMlrOIFBn1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjEzODY3Mg==", "bodyText": "It's a minor thing, but I find it strange that a role with:\n\"field_security\": { \"grant\": [ \"*\" ], \"except\": [ \"secret*\" ] }\n\nwould be audited as\n\"field_security\": { \"except\": [ \"secret*\" ] }\n\nIt's not wrong, but it reads strangely, and my personal view is that it is less clear.", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r542138672", "createdAt": "2020-12-14T06:22:22Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -727,16 +814,313 @@ public void runAsDenied(String requestId, Authentication authentication, RestReq\n                     .withOpaqueId(threadContext)\n                     .withXForwardedFor(threadContext)\n                     .build();\n-            logger.info(AUDIT_MARKER, logEntry);\n         }\n     }\n \n+    private LogEntryBuilder securityChangeLogEntryBuilder(String requestId) {\n+        return new LogEntryBuilder(false)\n+                .with(EVENT_TYPE_FIELD_NAME, SECURITY_CHANGE_ORIGIN_FIELD_VALUE)\n+                .withRequestId(requestId);\n+    }\n+\n     private class LogEntryBuilder {\n \n         private final StringMapMessage logEntry;\n \n         LogEntryBuilder() {\n+            this(true);\n+        }\n+\n+        LogEntryBuilder(boolean showOrigin) {\n             logEntry = new StringMapMessage(LoggingAuditTrail.this.entryCommonFields.commonFields);\n+            if (false == showOrigin) {\n+                logEntry.remove(ORIGIN_ADDRESS_FIELD_NAME);\n+                logEntry.remove(ORIGIN_TYPE_FIELD_NAME);\n+            }\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutUserRequest putUserRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_user\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", putUserRequest.username())\n+                    .field(\"enabled\", putUserRequest.enabled())\n+                    .array(\"roles\", putUserRequest.roles());\n+                    if (putUserRequest.fullName() != null) {\n+                        builder.field(\"full_name\", putUserRequest.fullName());\n+                    }\n+                    if (putUserRequest.email() != null) {\n+                        builder.field(\"email\", putUserRequest.email());\n+                    }\n+                    // password and password hashes are not exposed in the audit log\n+                    builder.field(\"has_password\", putUserRequest.passwordHash() != null);\n+                    if (putUserRequest.metadata() != null && false == putUserRequest.metadata().isEmpty()) {\n+                        // JSON building for the metadata might fail when encountering unknown class types.\n+                        // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                        // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                        // Also the malevolent metadata can only be produced by the transport client.\n+                        builder.field(\"metadata\", putUserRequest.metadata());\n+                    }\n+                    builder.endObject() // user\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(ChangePasswordRequest changePasswordRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"change_password\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"password\")\n+                    .startObject(\"user\")\n+                    .field(\"name\", changePasswordRequest.username())\n+                    .endObject() // user\n+                    .endObject() // password\n+                    .endObject();\n+            logEntry.with(CHANGE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleRequest putRoleRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role\")\n+                    .field(\"name\", putRoleRequest.name())\n+                    // the \"role_descriptor\" nested structure, where the \"name\" is left out, is closer to the event structure\n+                    // for creating API Keys\n+                    .field(\"role_descriptor\");\n+            withRoleDescriptor(builder, putRoleRequest.roleDescriptor());\n+            builder.endObject() // role\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutRoleMappingRequest putRoleMappingRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_role_mapping\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"role_mapping\")\n+                    .field(\"name\", putRoleMappingRequest.getName());\n+                    if (putRoleMappingRequest.getRoles() != null && false == putRoleMappingRequest.getRoles().isEmpty()) {\n+                        builder.field(\"roles\", putRoleMappingRequest.getRoles());\n+                    }\n+                    if (putRoleMappingRequest.getRoleTemplates() != null && false == putRoleMappingRequest.getRoleTemplates().isEmpty()) {\n+                        // the toXContent method of the {@code TemplateRoleName} does a good job\n+                        builder.field(\"role_templates\", putRoleMappingRequest.getRoleTemplates());\n+                    }\n+                    // the toXContent methods of the {@code RoleMapperExpression} instances do a good job\n+                    builder.field(\"rules\", putRoleMappingRequest.getRules())\n+                    .field(\"enabled\", putRoleMappingRequest.isEnabled());\n+                    if (putRoleMappingRequest.getMetadata() != null && false == putRoleMappingRequest.getMetadata().isEmpty()) {\n+                        builder.field(\"metadata\", putRoleMappingRequest.getMetadata());\n+                    }\n+                    builder.endObject() // role_mapping\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(SetEnabledRequest setEnabledRequest) throws IOException {\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    .startObject(\"user\")\n+                    .field(\"name\", setEnabledRequest.username())\n+                    .endObject() // user\n+                    .endObject();\n+            if (setEnabledRequest.enabled() != null && setEnabledRequest.enabled()) {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"enable_user\");\n+                logEntry.with(ENABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            } else {\n+                logEntry.with(EVENT_ACTION_FIELD_NAME, \"disable_user\");\n+                logEntry.with(DISABLE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            }\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(PutPrivilegesRequest putPrivilegesRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"put_privileges\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject()\n+                    // toXContent of {@code ApplicationPrivilegeDescriptor} does a good job\n+                    .field(\"privileges\", putPrivilegesRequest.getPrivileges())\n+                    .endObject();\n+            logEntry.with(PUT_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, createApiKeyRequest);\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        LogEntryBuilder withRequestBody(GrantApiKeyRequest grantApiKeyRequest) throws IOException {\n+            logEntry.with(EVENT_ACTION_FIELD_NAME, \"create_apikey\");\n+            XContentBuilder builder = JsonXContent.contentBuilder().humanReadable(true);\n+            builder.startObject();\n+            withRequestBody(builder, grantApiKeyRequest.getApiKeyRequest());\n+            GrantApiKeyRequest.Grant grant = grantApiKeyRequest.getGrant();\n+            builder.startObject(\"grant\")\n+                        .field(\"type\", grant.getType());\n+                        if (grant.getUsername() != null) {\n+                            builder.startObject(\"user\")\n+                                    .field(\"name\", grant.getUsername())\n+                                    .field(\"has_password\", grant.getPassword() != null)\n+                                    .endObject(); // user\n+                        }\n+                        if (grant.getAccessToken() != null) {\n+                            builder.field(\"has_access_token\", grant.getAccessToken() != null);\n+                        }\n+                    builder.endObject(); // grant\n+            builder.endObject();\n+            logEntry.with(CREATE_CONFIG_FIELD_NAME, Strings.toString(builder));\n+            return this;\n+        }\n+\n+        private void withRequestBody(XContentBuilder builder, CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+            TimeValue expiration = createApiKeyRequest.getExpiration();\n+            builder.startObject(\"apikey\")\n+                    .field(\"name\", createApiKeyRequest.getName())\n+                    .field(\"expiration\", expiration != null ? expiration.toString() : null)\n+                    .startArray(\"role_descriptors\");\n+            for (RoleDescriptor roleDescriptor : createApiKeyRequest.getRoleDescriptors()) {\n+                withRoleDescriptor(builder, roleDescriptor);\n+            }\n+            builder.endArray() // role_descriptors\n+            .endObject(); // apikey\n+        }\n+\n+        private void withRoleDescriptor(XContentBuilder builder, RoleDescriptor roleDescriptor) throws IOException {\n+            builder.startObject()\n+                .array(RoleDescriptor.Fields.CLUSTER.getPreferredName(), roleDescriptor.getClusterPrivileges());\n+            if (roleDescriptor.getConditionalClusterPrivileges() != null && roleDescriptor.getConditionalClusterPrivileges().length > 0) {\n+                // This fails if this list contains multiple instances of the {@code ManageApplicationPrivileges}\n+                // Again, only the transport client can produce this, and this only introduces a different failure mode and\n+                // not a new one (i.e. without auditing it would fail differently, but it would still fail)\n+                builder.field(RoleDescriptor.Fields.GLOBAL.getPreferredName());\n+                ConfigurableClusterPrivileges.toXContent(builder, ToXContent.EMPTY_PARAMS,\n+                        Arrays.asList(roleDescriptor.getConditionalClusterPrivileges()));\n+            }\n+            builder.startArray(RoleDescriptor.Fields.INDICES.getPreferredName());\n+            for (RoleDescriptor.IndicesPrivileges indicesPrivileges : roleDescriptor.getIndicesPrivileges()) {\n+                withIndicesPrivileges(builder, indicesPrivileges);\n+            }\n+            builder.endArray();\n+            // the toXContent method of the {@code RoleDescriptor.ApplicationResourcePrivileges) does a good job\n+            builder.array(RoleDescriptor.Fields.APPLICATIONS.getPreferredName(), (Object[]) roleDescriptor.getApplicationPrivileges());\n+            builder.array(RoleDescriptor.Fields.RUN_AS.getPreferredName(), roleDescriptor.getRunAs());\n+            if (roleDescriptor.getMetadata() != null && false == roleDescriptor.getMetadata().isEmpty()) {\n+                // JSON building for the metadata might fail when encountering unknown class types.\n+                // This is NOT a problem because such metadata (eg containing GeoPoint) will most probably\n+                // cause troubles in downstream code (eg storing the metadata), so this simply introduces a new failure mode.\n+                // Also the malevolent metadata can only be produced by the transport client.\n+                builder.field(RoleDescriptor.Fields.METADATA.getPreferredName(), roleDescriptor.getMetadata());\n+            }\n+            builder.endObject();\n+        }\n+\n+        private void withIndicesPrivileges(XContentBuilder builder, RoleDescriptor.IndicesPrivileges indicesPrivileges) throws IOException {\n+            builder.startObject();\n+            builder.array(\"names\", indicesPrivileges.getIndices());\n+            builder.array(\"privileges\", indicesPrivileges.getPrivileges());\n+            if (indicesPrivileges.isUsingFieldLevelSecurity()) {\n+                builder.startObject(RoleDescriptor.Fields.FIELD_PERMISSIONS.getPreferredName());\n+                if (indicesPrivileges.hasGrantedFields()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3008905a84ba16390b031d219bde47d1d83ca77c"}, "originalPosition": 747}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE0MDM3NA==", "bodyText": "Sorry, it's late in the review process for this, so don't worry about it too much, but can you explain your choice to make enable & disable top level fields, rather than something like:\n\"change\": {\n  \"enabled\": {\n    \"user\": { \"name\" : \"example\" }, \n    \"enabled\": true | false\n  }\n}", "url": "https://github.com/elastic/elasticsearch/pull/62916#discussion_r542140374", "createdAt": "2020-12-14T06:27:12Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java", "diffHunk": "@@ -124,6 +161,17 @@\n     public static final String RULE_FIELD_NAME = \"rule\";\n     public static final String OPAQUE_ID_FIELD_NAME = \"opaque_id\";\n     public static final String X_FORWARDED_FOR_FIELD_NAME = \"x_forwarded_for\";\n+    // the fields below are used exclusively for \"security_config_change\" type of events, and show the configuration\n+    // object taking effect; it could be creating a new, or updating an existing configuration\n+    // if our (REST) APIs (at least the security APIs) would make the distinction between creating a *new* resource using the POST\n+    // verb and updating an *existing* resource using the PUT verb, then auditing would also be able to show the create/update distinction\n+    public static final String PUT_CONFIG_FIELD_NAME = \"put\";\n+    public static final String DELETE_CONFIG_FIELD_NAME = \"delete\";\n+    public static final String CHANGE_CONFIG_FIELD_NAME = \"change\";\n+    public static final String ENABLE_CONFIG_FIELD_NAME = \"enable\";\n+    public static final String DISABLE_CONFIG_FIELD_NAME = \"disable\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3008905a84ba16390b031d219bde47d1d83ca77c"}, "originalPosition": 104}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3716966db85a261fcfdc7d050b333124fb353bdd", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/3716966db85a261fcfdc7d050b333124fb353bdd", "committedDate": "2020-12-14T08:23:07Z", "message": "Merge branch 'master' into audit_request_body_for_certain_transport_requests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "786518ba128664a60731e7cd98b6b50293dcf7ee", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/786518ba128664a60731e7cd98b6b50293dcf7ee", "committedDate": "2020-12-14T12:57:29Z", "message": "Always print grant fields"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f99e95f237b7ac40506dd6d9b6512e69e7f87bfb", "author": {"user": {"login": "albertzaharovits", "name": "Albert Zaharovits"}}, "url": "https://github.com/elastic/elasticsearch/commit/f99e95f237b7ac40506dd6d9b6512e69e7f87bfb", "committedDate": "2020-12-14T13:19:45Z", "message": "change:enable and change:disable"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUyMDkzMTk3", "url": "https://github.com/elastic/elasticsearch/pull/62916#pullrequestreview-552093197", "createdAt": "2020-12-15T04:16:08Z", "commit": {"oid": "f99e95f237b7ac40506dd6d9b6512e69e7f87bfb"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "252b170e42755609c6355548f7ed09589a2464fb", "author": {"user": {"login": "elasticmachine", "name": "Elastic Machine"}}, "url": "https://github.com/elastic/elasticsearch/commit/252b170e42755609c6355548f7ed09589a2464fb", "committedDate": "2020-12-15T08:16:03Z", "message": "Merge branch 'master' into audit_request_body_for_certain_transport_requests"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4632, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}