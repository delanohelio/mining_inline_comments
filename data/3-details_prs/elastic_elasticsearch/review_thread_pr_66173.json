{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM1OTcyNjkw", "number": 66173, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxNToyMTo0MVrOFDiEJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQwNjo1OTo0MVrOFD2A8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MjQ4MTY1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/common/cache/Cache.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxNToyMTo0MVrOIDOlnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxOTo1NzozOVrOIDa1aA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI1NTY0NQ==", "bodyText": "Would holding the readLock not be enough?", "url": "https://github.com/elastic/elasticsearch/pull/66173#discussion_r540255645", "createdAt": "2020-12-10T15:21:41Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/common/cache/Cache.java", "diffHunk": "@@ -650,6 +651,31 @@ public void remove() {\n         };\n     }\n \n+    /**\n+     * Performs an action for each cache entry in the cache. While iterating over the cache entries this method is protected from mutations\n+     * that occurs within the same cache segment by acquiring the segment's writing lock during all the iteration. As such, the specified\n+     * consumer should not try to modify the cache. Modifications that occur in already traveled segments won't been seen by the consumer\n+     * but modification that occur in non yet traveled segments should be.\n+     *\n+     * @param consumer the {@link Consumer}\n+     */\n+    public void forEach(BiConsumer<K, V> consumer) {\n+        for (CacheSegment<K, V> segment : segments) {\n+            try (ReleasableLock ignored = segment.writeLock.acquire()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c1a6e9cc7cb9f4fb13b53bbb4f4b10d07241b37"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ1NjI5Ng==", "bodyText": "It is enough, I'm not sure why I used and documented the usage of the write lock here. I pushed 082e0c8 to use the read lock instead (as it should prevent any mutation anyway)", "url": "https://github.com/elastic/elasticsearch/pull/66173#discussion_r540456296", "createdAt": "2020-12-10T19:57:39Z", "author": {"login": "tlrx"}, "path": "server/src/main/java/org/elasticsearch/common/cache/Cache.java", "diffHunk": "@@ -650,6 +651,31 @@ public void remove() {\n         };\n     }\n \n+    /**\n+     * Performs an action for each cache entry in the cache. While iterating over the cache entries this method is protected from mutations\n+     * that occurs within the same cache segment by acquiring the segment's writing lock during all the iteration. As such, the specified\n+     * consumer should not try to modify the cache. Modifications that occur in already traveled segments won't been seen by the consumer\n+     * but modification that occur in non yet traveled segments should be.\n+     *\n+     * @param consumer the {@link Consumer}\n+     */\n+    public void forEach(BiConsumer<K, V> consumer) {\n+        for (CacheSegment<K, V> segment : segments) {\n+            try (ReleasableLock ignored = segment.writeLock.acquire()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI1NTY0NQ=="}, "originalCommit": {"oid": "6c1a6e9cc7cb9f4fb13b53bbb4f4b10d07241b37"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MjYyMjk4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/cache/CacheService.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxNTo0NzoyNFrOIDP6Qg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxNDoyOTowOFrOIPufkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI3NzMxNA==", "bodyText": "I am not sure this is necessary. When cache.invalidate fails, it already removed the object from the map, so if we retry an eviction, it will not hit the shard anyway.\nSo if we can remove this, I think we can also drop the shardsEvictionLock, which makes markShardAsEvictedInCache safer wrt. being called from the cluster applier thread.", "url": "https://github.com/elastic/elasticsearch/pull/66173#discussion_r540277314", "createdAt": "2020-12-10T15:47:24Z", "author": {"login": "henningandersen"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/cache/CacheService.java", "diffHunk": "@@ -277,6 +290,88 @@ public void removeFromCache(final CacheKey cacheKey) {\n         cache.invalidate(cacheKey);\n     }\n \n+    /**\n+     * Marks the specified searchable snapshot shard as evicted in cache. Cache files associated with this shard will be evicted from cache.\n+     *\n+     * @param snapshotId the {@link SnapshotId}\n+     * @param indexId the {@link SnapshotId}\n+     * @param shardId the {@link SnapshotId}\n+     */\n+    public void markShardAsEvictedInCache(SnapshotId snapshotId, IndexId indexId, ShardId shardId) {\n+        boolean markedAsEvicted = false;\n+        final ShardEviction shardEviction = new ShardEviction(snapshotId, indexId, shardId);\n+        try (Releasable ignored = shardsEvictionLock.acquire(shardEviction)) {\n+            if (evictedShards.add(shardEviction)) {\n+                markedAsEvicted = true;\n+            }\n+        }\n+        if (markedAsEvicted) {\n+            threadPool.generic().submit(new AbstractRunnable() {\n+                @Override\n+                protected void doRun() {\n+                    runIfShardMarkedAsEvictedInCache(shardEviction, () -> {\n+                        assert shardsEvictionLock.isHeldByCurrentThread(shardEviction);\n+                        final Map<CacheKey, CacheFile> cacheFilesToEvict = new HashMap<>();\n+                        cache.forEach((cacheKey, cacheFile) -> {\n+                            if (shardEviction.matches(cacheKey)) {\n+                                cacheFilesToEvict.put(cacheKey, cacheFile);\n+                            }\n+                        });\n+                        if (cacheFilesToEvict.isEmpty() == false) {\n+                            cacheFilesToEvict.forEach(cache::invalidate);\n+                        }\n+                    });\n+                }\n+\n+                @Override\n+                public void onFailure(Exception e) {\n+                    logger.warn(\n+                        () -> new ParameterizedMessage(\"failed to evict cache files associated with evicted shard {}\", shardEviction),\n+                        e\n+                    );\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Allows to run the specified {@link Runnable} if the shard represented by the triplet ({@link SnapshotId}, {@link IndexId},\n+     * {@link SnapshotId}) is still marked as evicted at the time this method is executed. The @link Runnable} will be executed\n+     * while the current thread is holding the lock associated to the shard.\n+     *\n+     * @param snapshotId the snapshot the evicted searchable snapshots shard belongs to\n+     * @param indexId    the index in the snapshot the evicted searchable snapshots shard belongs to\n+     * @param shardId    the searchable snapshots shard id\n+     * @param runnable   a runnable to execute\n+     */\n+    public void runIfShardMarkedAsEvictedInCache(SnapshotId snapshotId, IndexId indexId, ShardId shardId, Runnable runnable) {\n+        runIfShardMarkedAsEvictedInCache(new ShardEviction(snapshotId, indexId, shardId), runnable);\n+    }\n+\n+    /**\n+     * Allows to run the specified {@link Runnable} if the shard represented by {@link ShardEviction} is still marked as evicted at the time\n+     * this method is executed. The @link Runnable} will be executed while the current thread is holding the lock associated to the shard.\n+     *\n+     * @param shardEviction a {@link ShardEviction} representing the shard marked as evicted\n+     * @param runnable      a runnable to execute\n+     */\n+    private void runIfShardMarkedAsEvictedInCache(ShardEviction shardEviction, Runnable runnable) {\n+        try (Releasable ignored = shardsEvictionLock.acquire(shardEviction)) {\n+            boolean success = false;\n+            try {\n+                if (evictedShards.remove(shardEviction)) {\n+                    runnable.run();\n+                }\n+                success = true;\n+            } finally {\n+                if (success == false) {\n+                    final boolean added = evictedShards.add(shardEviction);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c1a6e9cc7cb9f4fb13b53bbb4f4b10d07241b37"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ1NjI2NA==", "bodyText": "I think you are right, I pushed 393deaf to remove the usage of the lock here (but such locks are still necessary to avoid cache files eviction while starting the directory). Let me know what you think.", "url": "https://github.com/elastic/elasticsearch/pull/66173#discussion_r540456264", "createdAt": "2020-12-10T19:57:35Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/cache/CacheService.java", "diffHunk": "@@ -277,6 +290,88 @@ public void removeFromCache(final CacheKey cacheKey) {\n         cache.invalidate(cacheKey);\n     }\n \n+    /**\n+     * Marks the specified searchable snapshot shard as evicted in cache. Cache files associated with this shard will be evicted from cache.\n+     *\n+     * @param snapshotId the {@link SnapshotId}\n+     * @param indexId the {@link SnapshotId}\n+     * @param shardId the {@link SnapshotId}\n+     */\n+    public void markShardAsEvictedInCache(SnapshotId snapshotId, IndexId indexId, ShardId shardId) {\n+        boolean markedAsEvicted = false;\n+        final ShardEviction shardEviction = new ShardEviction(snapshotId, indexId, shardId);\n+        try (Releasable ignored = shardsEvictionLock.acquire(shardEviction)) {\n+            if (evictedShards.add(shardEviction)) {\n+                markedAsEvicted = true;\n+            }\n+        }\n+        if (markedAsEvicted) {\n+            threadPool.generic().submit(new AbstractRunnable() {\n+                @Override\n+                protected void doRun() {\n+                    runIfShardMarkedAsEvictedInCache(shardEviction, () -> {\n+                        assert shardsEvictionLock.isHeldByCurrentThread(shardEviction);\n+                        final Map<CacheKey, CacheFile> cacheFilesToEvict = new HashMap<>();\n+                        cache.forEach((cacheKey, cacheFile) -> {\n+                            if (shardEviction.matches(cacheKey)) {\n+                                cacheFilesToEvict.put(cacheKey, cacheFile);\n+                            }\n+                        });\n+                        if (cacheFilesToEvict.isEmpty() == false) {\n+                            cacheFilesToEvict.forEach(cache::invalidate);\n+                        }\n+                    });\n+                }\n+\n+                @Override\n+                public void onFailure(Exception e) {\n+                    logger.warn(\n+                        () -> new ParameterizedMessage(\"failed to evict cache files associated with evicted shard {}\", shardEviction),\n+                        e\n+                    );\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Allows to run the specified {@link Runnable} if the shard represented by the triplet ({@link SnapshotId}, {@link IndexId},\n+     * {@link SnapshotId}) is still marked as evicted at the time this method is executed. The @link Runnable} will be executed\n+     * while the current thread is holding the lock associated to the shard.\n+     *\n+     * @param snapshotId the snapshot the evicted searchable snapshots shard belongs to\n+     * @param indexId    the index in the snapshot the evicted searchable snapshots shard belongs to\n+     * @param shardId    the searchable snapshots shard id\n+     * @param runnable   a runnable to execute\n+     */\n+    public void runIfShardMarkedAsEvictedInCache(SnapshotId snapshotId, IndexId indexId, ShardId shardId, Runnable runnable) {\n+        runIfShardMarkedAsEvictedInCache(new ShardEviction(snapshotId, indexId, shardId), runnable);\n+    }\n+\n+    /**\n+     * Allows to run the specified {@link Runnable} if the shard represented by {@link ShardEviction} is still marked as evicted at the time\n+     * this method is executed. The @link Runnable} will be executed while the current thread is holding the lock associated to the shard.\n+     *\n+     * @param shardEviction a {@link ShardEviction} representing the shard marked as evicted\n+     * @param runnable      a runnable to execute\n+     */\n+    private void runIfShardMarkedAsEvictedInCache(ShardEviction shardEviction, Runnable runnable) {\n+        try (Releasable ignored = shardsEvictionLock.acquire(shardEviction)) {\n+            boolean success = false;\n+            try {\n+                if (evictedShards.remove(shardEviction)) {\n+                    runnable.run();\n+                }\n+                success = true;\n+            } finally {\n+                if (success == false) {\n+                    final boolean added = evictedShards.add(shardEviction);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI3NzMxNA=="}, "originalCommit": {"oid": "6c1a6e9cc7cb9f4fb13b53bbb4f4b10d07241b37"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDczODk2NQ==", "bodyText": "I think the locks could be removed with some restructure, but we can tackle that in a follow-up, it is not really important.\nHowever, if we add to evictedShards here while running the job on the thread, I think we risk it leaking since nothing will remove it later? I think we should assert success here. AFAICS, there is no way this should fail unless there is a bug somewhere.", "url": "https://github.com/elastic/elasticsearch/pull/66173#discussion_r540738965", "createdAt": "2020-12-11T07:19:01Z", "author": {"login": "henningandersen"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/cache/CacheService.java", "diffHunk": "@@ -277,6 +290,88 @@ public void removeFromCache(final CacheKey cacheKey) {\n         cache.invalidate(cacheKey);\n     }\n \n+    /**\n+     * Marks the specified searchable snapshot shard as evicted in cache. Cache files associated with this shard will be evicted from cache.\n+     *\n+     * @param snapshotId the {@link SnapshotId}\n+     * @param indexId the {@link SnapshotId}\n+     * @param shardId the {@link SnapshotId}\n+     */\n+    public void markShardAsEvictedInCache(SnapshotId snapshotId, IndexId indexId, ShardId shardId) {\n+        boolean markedAsEvicted = false;\n+        final ShardEviction shardEviction = new ShardEviction(snapshotId, indexId, shardId);\n+        try (Releasable ignored = shardsEvictionLock.acquire(shardEviction)) {\n+            if (evictedShards.add(shardEviction)) {\n+                markedAsEvicted = true;\n+            }\n+        }\n+        if (markedAsEvicted) {\n+            threadPool.generic().submit(new AbstractRunnable() {\n+                @Override\n+                protected void doRun() {\n+                    runIfShardMarkedAsEvictedInCache(shardEviction, () -> {\n+                        assert shardsEvictionLock.isHeldByCurrentThread(shardEviction);\n+                        final Map<CacheKey, CacheFile> cacheFilesToEvict = new HashMap<>();\n+                        cache.forEach((cacheKey, cacheFile) -> {\n+                            if (shardEviction.matches(cacheKey)) {\n+                                cacheFilesToEvict.put(cacheKey, cacheFile);\n+                            }\n+                        });\n+                        if (cacheFilesToEvict.isEmpty() == false) {\n+                            cacheFilesToEvict.forEach(cache::invalidate);\n+                        }\n+                    });\n+                }\n+\n+                @Override\n+                public void onFailure(Exception e) {\n+                    logger.warn(\n+                        () -> new ParameterizedMessage(\"failed to evict cache files associated with evicted shard {}\", shardEviction),\n+                        e\n+                    );\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Allows to run the specified {@link Runnable} if the shard represented by the triplet ({@link SnapshotId}, {@link IndexId},\n+     * {@link SnapshotId}) is still marked as evicted at the time this method is executed. The @link Runnable} will be executed\n+     * while the current thread is holding the lock associated to the shard.\n+     *\n+     * @param snapshotId the snapshot the evicted searchable snapshots shard belongs to\n+     * @param indexId    the index in the snapshot the evicted searchable snapshots shard belongs to\n+     * @param shardId    the searchable snapshots shard id\n+     * @param runnable   a runnable to execute\n+     */\n+    public void runIfShardMarkedAsEvictedInCache(SnapshotId snapshotId, IndexId indexId, ShardId shardId, Runnable runnable) {\n+        runIfShardMarkedAsEvictedInCache(new ShardEviction(snapshotId, indexId, shardId), runnable);\n+    }\n+\n+    /**\n+     * Allows to run the specified {@link Runnable} if the shard represented by {@link ShardEviction} is still marked as evicted at the time\n+     * this method is executed. The @link Runnable} will be executed while the current thread is holding the lock associated to the shard.\n+     *\n+     * @param shardEviction a {@link ShardEviction} representing the shard marked as evicted\n+     * @param runnable      a runnable to execute\n+     */\n+    private void runIfShardMarkedAsEvictedInCache(ShardEviction shardEviction, Runnable runnable) {\n+        try (Releasable ignored = shardsEvictionLock.acquire(shardEviction)) {\n+            boolean success = false;\n+            try {\n+                if (evictedShards.remove(shardEviction)) {\n+                    runnable.run();\n+                }\n+                success = true;\n+            } finally {\n+                if (success == false) {\n+                    final boolean added = evictedShards.add(shardEviction);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI3NzMxNA=="}, "originalCommit": {"oid": "6c1a6e9cc7cb9f4fb13b53bbb4f4b10d07241b37"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDgzMTM2Mw==", "bodyText": "I will be happy to know more about how you think it could be restructured. For now I'm taking this point and will come back to you in a short future for tackling this.\nI agree there's a risk of leaking a ShardEviction around but I think it is very unlikely to happen. One idea would be to hook into the cache sync task to clean up any left overs ShardEviction there. If that's OK we can address this too as a follow up with the previous point. For now I added the success assertion.", "url": "https://github.com/elastic/elasticsearch/pull/66173#discussion_r540831363", "createdAt": "2020-12-11T10:04:31Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/cache/CacheService.java", "diffHunk": "@@ -277,6 +290,88 @@ public void removeFromCache(final CacheKey cacheKey) {\n         cache.invalidate(cacheKey);\n     }\n \n+    /**\n+     * Marks the specified searchable snapshot shard as evicted in cache. Cache files associated with this shard will be evicted from cache.\n+     *\n+     * @param snapshotId the {@link SnapshotId}\n+     * @param indexId the {@link SnapshotId}\n+     * @param shardId the {@link SnapshotId}\n+     */\n+    public void markShardAsEvictedInCache(SnapshotId snapshotId, IndexId indexId, ShardId shardId) {\n+        boolean markedAsEvicted = false;\n+        final ShardEviction shardEviction = new ShardEviction(snapshotId, indexId, shardId);\n+        try (Releasable ignored = shardsEvictionLock.acquire(shardEviction)) {\n+            if (evictedShards.add(shardEviction)) {\n+                markedAsEvicted = true;\n+            }\n+        }\n+        if (markedAsEvicted) {\n+            threadPool.generic().submit(new AbstractRunnable() {\n+                @Override\n+                protected void doRun() {\n+                    runIfShardMarkedAsEvictedInCache(shardEviction, () -> {\n+                        assert shardsEvictionLock.isHeldByCurrentThread(shardEviction);\n+                        final Map<CacheKey, CacheFile> cacheFilesToEvict = new HashMap<>();\n+                        cache.forEach((cacheKey, cacheFile) -> {\n+                            if (shardEviction.matches(cacheKey)) {\n+                                cacheFilesToEvict.put(cacheKey, cacheFile);\n+                            }\n+                        });\n+                        if (cacheFilesToEvict.isEmpty() == false) {\n+                            cacheFilesToEvict.forEach(cache::invalidate);\n+                        }\n+                    });\n+                }\n+\n+                @Override\n+                public void onFailure(Exception e) {\n+                    logger.warn(\n+                        () -> new ParameterizedMessage(\"failed to evict cache files associated with evicted shard {}\", shardEviction),\n+                        e\n+                    );\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Allows to run the specified {@link Runnable} if the shard represented by the triplet ({@link SnapshotId}, {@link IndexId},\n+     * {@link SnapshotId}) is still marked as evicted at the time this method is executed. The @link Runnable} will be executed\n+     * while the current thread is holding the lock associated to the shard.\n+     *\n+     * @param snapshotId the snapshot the evicted searchable snapshots shard belongs to\n+     * @param indexId    the index in the snapshot the evicted searchable snapshots shard belongs to\n+     * @param shardId    the searchable snapshots shard id\n+     * @param runnable   a runnable to execute\n+     */\n+    public void runIfShardMarkedAsEvictedInCache(SnapshotId snapshotId, IndexId indexId, ShardId shardId, Runnable runnable) {\n+        runIfShardMarkedAsEvictedInCache(new ShardEviction(snapshotId, indexId, shardId), runnable);\n+    }\n+\n+    /**\n+     * Allows to run the specified {@link Runnable} if the shard represented by {@link ShardEviction} is still marked as evicted at the time\n+     * this method is executed. The @link Runnable} will be executed while the current thread is holding the lock associated to the shard.\n+     *\n+     * @param shardEviction a {@link ShardEviction} representing the shard marked as evicted\n+     * @param runnable      a runnable to execute\n+     */\n+    private void runIfShardMarkedAsEvictedInCache(ShardEviction shardEviction, Runnable runnable) {\n+        try (Releasable ignored = shardsEvictionLock.acquire(shardEviction)) {\n+            boolean success = false;\n+            try {\n+                if (evictedShards.remove(shardEviction)) {\n+                    runnable.run();\n+                }\n+                success = true;\n+            } finally {\n+                if (success == false) {\n+                    final boolean added = evictedShards.add(shardEviction);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI3NzMxNA=="}, "originalCommit": {"oid": "6c1a6e9cc7cb9f4fb13b53bbb4f4b10d07241b37"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzM2MTI5Nw==", "bodyText": "I've opened #67160 which should improve the situation.", "url": "https://github.com/elastic/elasticsearch/pull/66173#discussion_r553361297", "createdAt": "2021-01-07T14:29:08Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/cache/CacheService.java", "diffHunk": "@@ -277,6 +290,88 @@ public void removeFromCache(final CacheKey cacheKey) {\n         cache.invalidate(cacheKey);\n     }\n \n+    /**\n+     * Marks the specified searchable snapshot shard as evicted in cache. Cache files associated with this shard will be evicted from cache.\n+     *\n+     * @param snapshotId the {@link SnapshotId}\n+     * @param indexId the {@link SnapshotId}\n+     * @param shardId the {@link SnapshotId}\n+     */\n+    public void markShardAsEvictedInCache(SnapshotId snapshotId, IndexId indexId, ShardId shardId) {\n+        boolean markedAsEvicted = false;\n+        final ShardEviction shardEviction = new ShardEviction(snapshotId, indexId, shardId);\n+        try (Releasable ignored = shardsEvictionLock.acquire(shardEviction)) {\n+            if (evictedShards.add(shardEviction)) {\n+                markedAsEvicted = true;\n+            }\n+        }\n+        if (markedAsEvicted) {\n+            threadPool.generic().submit(new AbstractRunnable() {\n+                @Override\n+                protected void doRun() {\n+                    runIfShardMarkedAsEvictedInCache(shardEviction, () -> {\n+                        assert shardsEvictionLock.isHeldByCurrentThread(shardEviction);\n+                        final Map<CacheKey, CacheFile> cacheFilesToEvict = new HashMap<>();\n+                        cache.forEach((cacheKey, cacheFile) -> {\n+                            if (shardEviction.matches(cacheKey)) {\n+                                cacheFilesToEvict.put(cacheKey, cacheFile);\n+                            }\n+                        });\n+                        if (cacheFilesToEvict.isEmpty() == false) {\n+                            cacheFilesToEvict.forEach(cache::invalidate);\n+                        }\n+                    });\n+                }\n+\n+                @Override\n+                public void onFailure(Exception e) {\n+                    logger.warn(\n+                        () -> new ParameterizedMessage(\"failed to evict cache files associated with evicted shard {}\", shardEviction),\n+                        e\n+                    );\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Allows to run the specified {@link Runnable} if the shard represented by the triplet ({@link SnapshotId}, {@link IndexId},\n+     * {@link SnapshotId}) is still marked as evicted at the time this method is executed. The @link Runnable} will be executed\n+     * while the current thread is holding the lock associated to the shard.\n+     *\n+     * @param snapshotId the snapshot the evicted searchable snapshots shard belongs to\n+     * @param indexId    the index in the snapshot the evicted searchable snapshots shard belongs to\n+     * @param shardId    the searchable snapshots shard id\n+     * @param runnable   a runnable to execute\n+     */\n+    public void runIfShardMarkedAsEvictedInCache(SnapshotId snapshotId, IndexId indexId, ShardId shardId, Runnable runnable) {\n+        runIfShardMarkedAsEvictedInCache(new ShardEviction(snapshotId, indexId, shardId), runnable);\n+    }\n+\n+    /**\n+     * Allows to run the specified {@link Runnable} if the shard represented by {@link ShardEviction} is still marked as evicted at the time\n+     * this method is executed. The @link Runnable} will be executed while the current thread is holding the lock associated to the shard.\n+     *\n+     * @param shardEviction a {@link ShardEviction} representing the shard marked as evicted\n+     * @param runnable      a runnable to execute\n+     */\n+    private void runIfShardMarkedAsEvictedInCache(ShardEviction shardEviction, Runnable runnable) {\n+        try (Releasable ignored = shardsEvictionLock.acquire(shardEviction)) {\n+            boolean success = false;\n+            try {\n+                if (evictedShards.remove(shardEviction)) {\n+                    runnable.run();\n+                }\n+                success = true;\n+            } finally {\n+                if (success == false) {\n+                    final boolean added = evictedShards.add(shardEviction);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI3NzMxNA=="}, "originalCommit": {"oid": "6c1a6e9cc7cb9f4fb13b53bbb4f4b10d07241b37"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MjYyODQ5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/cache/CacheService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxNTo0ODozNFrOIDP9zg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxOTo1Nzo0NFrOIDa1pA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI3ODIyMg==", "bodyText": "Perhaps we need to catch exception here and assert that they are io-related, write a warning and then continue with the next file? That ensures we remove all cache files from the cache in one go, but may linger some files if there are io-issues.", "url": "https://github.com/elastic/elasticsearch/pull/66173#discussion_r540278222", "createdAt": "2020-12-10T15:48:34Z", "author": {"login": "henningandersen"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/cache/CacheService.java", "diffHunk": "@@ -277,6 +290,88 @@ public void removeFromCache(final CacheKey cacheKey) {\n         cache.invalidate(cacheKey);\n     }\n \n+    /**\n+     * Marks the specified searchable snapshot shard as evicted in cache. Cache files associated with this shard will be evicted from cache.\n+     *\n+     * @param snapshotId the {@link SnapshotId}\n+     * @param indexId the {@link SnapshotId}\n+     * @param shardId the {@link SnapshotId}\n+     */\n+    public void markShardAsEvictedInCache(SnapshotId snapshotId, IndexId indexId, ShardId shardId) {\n+        boolean markedAsEvicted = false;\n+        final ShardEviction shardEviction = new ShardEviction(snapshotId, indexId, shardId);\n+        try (Releasable ignored = shardsEvictionLock.acquire(shardEviction)) {\n+            if (evictedShards.add(shardEviction)) {\n+                markedAsEvicted = true;\n+            }\n+        }\n+        if (markedAsEvicted) {\n+            threadPool.generic().submit(new AbstractRunnable() {\n+                @Override\n+                protected void doRun() {\n+                    runIfShardMarkedAsEvictedInCache(shardEviction, () -> {\n+                        assert shardsEvictionLock.isHeldByCurrentThread(shardEviction);\n+                        final Map<CacheKey, CacheFile> cacheFilesToEvict = new HashMap<>();\n+                        cache.forEach((cacheKey, cacheFile) -> {\n+                            if (shardEviction.matches(cacheKey)) {\n+                                cacheFilesToEvict.put(cacheKey, cacheFile);\n+                            }\n+                        });\n+                        if (cacheFilesToEvict.isEmpty() == false) {\n+                            cacheFilesToEvict.forEach(cache::invalidate);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c1a6e9cc7cb9f4fb13b53bbb4f4b10d07241b37"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ1NjM1Ng==", "bodyText": "Yes, your suggestion makes eviction safer - just in case. I pushed 58b7bd9", "url": "https://github.com/elastic/elasticsearch/pull/66173#discussion_r540456356", "createdAt": "2020-12-10T19:57:44Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/cache/CacheService.java", "diffHunk": "@@ -277,6 +290,88 @@ public void removeFromCache(final CacheKey cacheKey) {\n         cache.invalidate(cacheKey);\n     }\n \n+    /**\n+     * Marks the specified searchable snapshot shard as evicted in cache. Cache files associated with this shard will be evicted from cache.\n+     *\n+     * @param snapshotId the {@link SnapshotId}\n+     * @param indexId the {@link SnapshotId}\n+     * @param shardId the {@link SnapshotId}\n+     */\n+    public void markShardAsEvictedInCache(SnapshotId snapshotId, IndexId indexId, ShardId shardId) {\n+        boolean markedAsEvicted = false;\n+        final ShardEviction shardEviction = new ShardEviction(snapshotId, indexId, shardId);\n+        try (Releasable ignored = shardsEvictionLock.acquire(shardEviction)) {\n+            if (evictedShards.add(shardEviction)) {\n+                markedAsEvicted = true;\n+            }\n+        }\n+        if (markedAsEvicted) {\n+            threadPool.generic().submit(new AbstractRunnable() {\n+                @Override\n+                protected void doRun() {\n+                    runIfShardMarkedAsEvictedInCache(shardEviction, () -> {\n+                        assert shardsEvictionLock.isHeldByCurrentThread(shardEviction);\n+                        final Map<CacheKey, CacheFile> cacheFilesToEvict = new HashMap<>();\n+                        cache.forEach((cacheKey, cacheFile) -> {\n+                            if (shardEviction.matches(cacheKey)) {\n+                                cacheFilesToEvict.put(cacheKey, cacheFile);\n+                            }\n+                        });\n+                        if (cacheFilesToEvict.isEmpty() == false) {\n+                            cacheFilesToEvict.forEach(cache::invalidate);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI3ODIyMg=="}, "originalCommit": {"oid": "6c1a6e9cc7cb9f4fb13b53bbb4f4b10d07241b37"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5NTczNjAxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/cache/CacheService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQwNjo1NDoxN1rOIDrhMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMDowMDo1NFrOIDxl8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDcyOTY1MA==", "bodyText": "nit: this check seems superfluous?", "url": "https://github.com/elastic/elasticsearch/pull/66173#discussion_r540729650", "createdAt": "2020-12-11T06:54:17Z", "author": {"login": "henningandersen"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/cache/CacheService.java", "diffHunk": "@@ -277,6 +290,89 @@ public void removeFromCache(final CacheKey cacheKey) {\n         cache.invalidate(cacheKey);\n     }\n \n+    /**\n+     * Marks the specified searchable snapshot shard as evicted in cache. Cache files associated with this shard will be evicted from cache.\n+     *\n+     * @param snapshotId the {@link SnapshotId}\n+     * @param indexId the {@link SnapshotId}\n+     * @param shardId the {@link SnapshotId}\n+     */\n+    public void markShardAsEvictedInCache(SnapshotId snapshotId, IndexId indexId, ShardId shardId) {\n+        final ShardEviction shardEviction = new ShardEviction(snapshotId, indexId, shardId);\n+        if (evictedShards.add(shardEviction)) {\n+            threadPool.generic().submit(new AbstractRunnable() {\n+                @Override\n+                protected void doRun() {\n+                    runIfShardMarkedAsEvictedInCache(shardEviction, () -> {\n+                        assert shardsEvictionLock.isHeldByCurrentThread(shardEviction);\n+                        final Map<CacheKey, CacheFile> cacheFilesToEvict = new HashMap<>();\n+                        cache.forEach((cacheKey, cacheFile) -> {\n+                            if (shardEviction.matches(cacheKey)) {\n+                                cacheFilesToEvict.put(cacheKey, cacheFile);\n+                            }\n+                        });\n+                        if (cacheFilesToEvict.isEmpty() == false) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1c9e543ca083ef0356fece7319f540d3431aa02"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDgyOTE2OQ==", "bodyText": "Yes, I removed it", "url": "https://github.com/elastic/elasticsearch/pull/66173#discussion_r540829169", "createdAt": "2020-12-11T10:00:54Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/cache/CacheService.java", "diffHunk": "@@ -277,6 +290,89 @@ public void removeFromCache(final CacheKey cacheKey) {\n         cache.invalidate(cacheKey);\n     }\n \n+    /**\n+     * Marks the specified searchable snapshot shard as evicted in cache. Cache files associated with this shard will be evicted from cache.\n+     *\n+     * @param snapshotId the {@link SnapshotId}\n+     * @param indexId the {@link SnapshotId}\n+     * @param shardId the {@link SnapshotId}\n+     */\n+    public void markShardAsEvictedInCache(SnapshotId snapshotId, IndexId indexId, ShardId shardId) {\n+        final ShardEviction shardEviction = new ShardEviction(snapshotId, indexId, shardId);\n+        if (evictedShards.add(shardEviction)) {\n+            threadPool.generic().submit(new AbstractRunnable() {\n+                @Override\n+                protected void doRun() {\n+                    runIfShardMarkedAsEvictedInCache(shardEviction, () -> {\n+                        assert shardsEvictionLock.isHeldByCurrentThread(shardEviction);\n+                        final Map<CacheKey, CacheFile> cacheFilesToEvict = new HashMap<>();\n+                        cache.forEach((cacheKey, cacheFile) -> {\n+                            if (shardEviction.matches(cacheKey)) {\n+                                cacheFilesToEvict.put(cacheKey, cacheFile);\n+                            }\n+                        });\n+                        if (cacheFilesToEvict.isEmpty() == false) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDcyOTY1MA=="}, "originalCommit": {"oid": "c1c9e543ca083ef0356fece7319f540d3431aa02"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5NTc0NjY2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/cache/CacheService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQwNjo1ODoxMlrOIDrm7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMDowMDo1MlrOIDxl1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDczMTExOQ==", "bodyText": "Can we just catch RuntimeException instead, since invalidate declares to not throw checked?", "url": "https://github.com/elastic/elasticsearch/pull/66173#discussion_r540731119", "createdAt": "2020-12-11T06:58:12Z", "author": {"login": "henningandersen"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/cache/CacheService.java", "diffHunk": "@@ -277,6 +290,89 @@ public void removeFromCache(final CacheKey cacheKey) {\n         cache.invalidate(cacheKey);\n     }\n \n+    /**\n+     * Marks the specified searchable snapshot shard as evicted in cache. Cache files associated with this shard will be evicted from cache.\n+     *\n+     * @param snapshotId the {@link SnapshotId}\n+     * @param indexId the {@link SnapshotId}\n+     * @param shardId the {@link SnapshotId}\n+     */\n+    public void markShardAsEvictedInCache(SnapshotId snapshotId, IndexId indexId, ShardId shardId) {\n+        final ShardEviction shardEviction = new ShardEviction(snapshotId, indexId, shardId);\n+        if (evictedShards.add(shardEviction)) {\n+            threadPool.generic().submit(new AbstractRunnable() {\n+                @Override\n+                protected void doRun() {\n+                    runIfShardMarkedAsEvictedInCache(shardEviction, () -> {\n+                        assert shardsEvictionLock.isHeldByCurrentThread(shardEviction);\n+                        final Map<CacheKey, CacheFile> cacheFilesToEvict = new HashMap<>();\n+                        cache.forEach((cacheKey, cacheFile) -> {\n+                            if (shardEviction.matches(cacheKey)) {\n+                                cacheFilesToEvict.put(cacheKey, cacheFile);\n+                            }\n+                        });\n+                        if (cacheFilesToEvict.isEmpty() == false) {\n+                            for (Map.Entry<CacheKey, CacheFile> cacheFile : cacheFilesToEvict.entrySet()) {\n+                                try {\n+                                    cache.invalidate(cacheFile.getKey(), cacheFile.getValue());\n+                                } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1c9e543ca083ef0356fece7319f540d3431aa02"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDgyOTE0Mg==", "bodyText": "Sure.", "url": "https://github.com/elastic/elasticsearch/pull/66173#discussion_r540829142", "createdAt": "2020-12-11T10:00:52Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/cache/CacheService.java", "diffHunk": "@@ -277,6 +290,89 @@ public void removeFromCache(final CacheKey cacheKey) {\n         cache.invalidate(cacheKey);\n     }\n \n+    /**\n+     * Marks the specified searchable snapshot shard as evicted in cache. Cache files associated with this shard will be evicted from cache.\n+     *\n+     * @param snapshotId the {@link SnapshotId}\n+     * @param indexId the {@link SnapshotId}\n+     * @param shardId the {@link SnapshotId}\n+     */\n+    public void markShardAsEvictedInCache(SnapshotId snapshotId, IndexId indexId, ShardId shardId) {\n+        final ShardEviction shardEviction = new ShardEviction(snapshotId, indexId, shardId);\n+        if (evictedShards.add(shardEviction)) {\n+            threadPool.generic().submit(new AbstractRunnable() {\n+                @Override\n+                protected void doRun() {\n+                    runIfShardMarkedAsEvictedInCache(shardEviction, () -> {\n+                        assert shardsEvictionLock.isHeldByCurrentThread(shardEviction);\n+                        final Map<CacheKey, CacheFile> cacheFilesToEvict = new HashMap<>();\n+                        cache.forEach((cacheKey, cacheFile) -> {\n+                            if (shardEviction.matches(cacheKey)) {\n+                                cacheFilesToEvict.put(cacheKey, cacheFile);\n+                            }\n+                        });\n+                        if (cacheFilesToEvict.isEmpty() == false) {\n+                            for (Map.Entry<CacheKey, CacheFile> cacheFile : cacheFilesToEvict.entrySet()) {\n+                                try {\n+                                    cache.invalidate(cacheFile.getKey(), cacheFile.getValue());\n+                                } catch (Exception e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDczMTExOQ=="}, "originalCommit": {"oid": "c1c9e543ca083ef0356fece7319f540d3431aa02"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5NTc0ODM5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/cache/CacheService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQwNjo1OTowMVrOIDrn5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMDowMDo1MFrOIDxlwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDczMTM2Nw==", "bodyText": "Looking closer at this, I suppose this should never happen since we catch IO exceptions in onCacheFileRemoval, so we could just assert false : e here instead?", "url": "https://github.com/elastic/elasticsearch/pull/66173#discussion_r540731367", "createdAt": "2020-12-11T06:59:01Z", "author": {"login": "henningandersen"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/cache/CacheService.java", "diffHunk": "@@ -277,6 +290,89 @@ public void removeFromCache(final CacheKey cacheKey) {\n         cache.invalidate(cacheKey);\n     }\n \n+    /**\n+     * Marks the specified searchable snapshot shard as evicted in cache. Cache files associated with this shard will be evicted from cache.\n+     *\n+     * @param snapshotId the {@link SnapshotId}\n+     * @param indexId the {@link SnapshotId}\n+     * @param shardId the {@link SnapshotId}\n+     */\n+    public void markShardAsEvictedInCache(SnapshotId snapshotId, IndexId indexId, ShardId shardId) {\n+        final ShardEviction shardEviction = new ShardEviction(snapshotId, indexId, shardId);\n+        if (evictedShards.add(shardEviction)) {\n+            threadPool.generic().submit(new AbstractRunnable() {\n+                @Override\n+                protected void doRun() {\n+                    runIfShardMarkedAsEvictedInCache(shardEviction, () -> {\n+                        assert shardsEvictionLock.isHeldByCurrentThread(shardEviction);\n+                        final Map<CacheKey, CacheFile> cacheFilesToEvict = new HashMap<>();\n+                        cache.forEach((cacheKey, cacheFile) -> {\n+                            if (shardEviction.matches(cacheKey)) {\n+                                cacheFilesToEvict.put(cacheKey, cacheFile);\n+                            }\n+                        });\n+                        if (cacheFilesToEvict.isEmpty() == false) {\n+                            for (Map.Entry<CacheKey, CacheFile> cacheFile : cacheFilesToEvict.entrySet()) {\n+                                try {\n+                                    cache.invalidate(cacheFile.getKey(), cacheFile.getValue());\n+                                } catch (Exception e) {\n+                                    assert e instanceof IOException : e;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1c9e543ca083ef0356fece7319f540d3431aa02"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDgyOTEyMA==", "bodyText": "Agreed.", "url": "https://github.com/elastic/elasticsearch/pull/66173#discussion_r540829120", "createdAt": "2020-12-11T10:00:50Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/cache/CacheService.java", "diffHunk": "@@ -277,6 +290,89 @@ public void removeFromCache(final CacheKey cacheKey) {\n         cache.invalidate(cacheKey);\n     }\n \n+    /**\n+     * Marks the specified searchable snapshot shard as evicted in cache. Cache files associated with this shard will be evicted from cache.\n+     *\n+     * @param snapshotId the {@link SnapshotId}\n+     * @param indexId the {@link SnapshotId}\n+     * @param shardId the {@link SnapshotId}\n+     */\n+    public void markShardAsEvictedInCache(SnapshotId snapshotId, IndexId indexId, ShardId shardId) {\n+        final ShardEviction shardEviction = new ShardEviction(snapshotId, indexId, shardId);\n+        if (evictedShards.add(shardEviction)) {\n+            threadPool.generic().submit(new AbstractRunnable() {\n+                @Override\n+                protected void doRun() {\n+                    runIfShardMarkedAsEvictedInCache(shardEviction, () -> {\n+                        assert shardsEvictionLock.isHeldByCurrentThread(shardEviction);\n+                        final Map<CacheKey, CacheFile> cacheFilesToEvict = new HashMap<>();\n+                        cache.forEach((cacheKey, cacheFile) -> {\n+                            if (shardEviction.matches(cacheKey)) {\n+                                cacheFilesToEvict.put(cacheKey, cacheFile);\n+                            }\n+                        });\n+                        if (cacheFilesToEvict.isEmpty() == false) {\n+                            for (Map.Entry<CacheKey, CacheFile> cacheFile : cacheFilesToEvict.entrySet()) {\n+                                try {\n+                                    cache.invalidate(cacheFile.getKey(), cacheFile.getValue());\n+                                } catch (Exception e) {\n+                                    assert e instanceof IOException : e;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDczMTM2Nw=="}, "originalCommit": {"oid": "c1c9e543ca083ef0356fece7319f540d3431aa02"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5NTc1MDI2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/cache/CacheService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQwNjo1OTo0MVrOIDro2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMDowMDo0OFrOIDxlrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDczMTYwOQ==", "bodyText": "I think we could also assert false : e here?", "url": "https://github.com/elastic/elasticsearch/pull/66173#discussion_r540731609", "createdAt": "2020-12-11T06:59:41Z", "author": {"login": "henningandersen"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/cache/CacheService.java", "diffHunk": "@@ -277,6 +290,89 @@ public void removeFromCache(final CacheKey cacheKey) {\n         cache.invalidate(cacheKey);\n     }\n \n+    /**\n+     * Marks the specified searchable snapshot shard as evicted in cache. Cache files associated with this shard will be evicted from cache.\n+     *\n+     * @param snapshotId the {@link SnapshotId}\n+     * @param indexId the {@link SnapshotId}\n+     * @param shardId the {@link SnapshotId}\n+     */\n+    public void markShardAsEvictedInCache(SnapshotId snapshotId, IndexId indexId, ShardId shardId) {\n+        final ShardEviction shardEviction = new ShardEviction(snapshotId, indexId, shardId);\n+        if (evictedShards.add(shardEviction)) {\n+            threadPool.generic().submit(new AbstractRunnable() {\n+                @Override\n+                protected void doRun() {\n+                    runIfShardMarkedAsEvictedInCache(shardEviction, () -> {\n+                        assert shardsEvictionLock.isHeldByCurrentThread(shardEviction);\n+                        final Map<CacheKey, CacheFile> cacheFilesToEvict = new HashMap<>();\n+                        cache.forEach((cacheKey, cacheFile) -> {\n+                            if (shardEviction.matches(cacheKey)) {\n+                                cacheFilesToEvict.put(cacheKey, cacheFile);\n+                            }\n+                        });\n+                        if (cacheFilesToEvict.isEmpty() == false) {\n+                            for (Map.Entry<CacheKey, CacheFile> cacheFile : cacheFilesToEvict.entrySet()) {\n+                                try {\n+                                    cache.invalidate(cacheFile.getKey(), cacheFile.getValue());\n+                                } catch (Exception e) {\n+                                    assert e instanceof IOException : e;\n+                                    logger.warn(() -> new ParameterizedMessage(\"failed to evict cache file {}\", cacheFile.getKey()), e);\n+                                }\n+                            }\n+                        }\n+                    });\n+                }\n+\n+                @Override\n+                public void onFailure(Exception e) {\n+                    logger.warn(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1c9e543ca083ef0356fece7319f540d3431aa02"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDgyOTEwMg==", "bodyText": "+1", "url": "https://github.com/elastic/elasticsearch/pull/66173#discussion_r540829102", "createdAt": "2020-12-11T10:00:48Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/cache/CacheService.java", "diffHunk": "@@ -277,6 +290,89 @@ public void removeFromCache(final CacheKey cacheKey) {\n         cache.invalidate(cacheKey);\n     }\n \n+    /**\n+     * Marks the specified searchable snapshot shard as evicted in cache. Cache files associated with this shard will be evicted from cache.\n+     *\n+     * @param snapshotId the {@link SnapshotId}\n+     * @param indexId the {@link SnapshotId}\n+     * @param shardId the {@link SnapshotId}\n+     */\n+    public void markShardAsEvictedInCache(SnapshotId snapshotId, IndexId indexId, ShardId shardId) {\n+        final ShardEviction shardEviction = new ShardEviction(snapshotId, indexId, shardId);\n+        if (evictedShards.add(shardEviction)) {\n+            threadPool.generic().submit(new AbstractRunnable() {\n+                @Override\n+                protected void doRun() {\n+                    runIfShardMarkedAsEvictedInCache(shardEviction, () -> {\n+                        assert shardsEvictionLock.isHeldByCurrentThread(shardEviction);\n+                        final Map<CacheKey, CacheFile> cacheFilesToEvict = new HashMap<>();\n+                        cache.forEach((cacheKey, cacheFile) -> {\n+                            if (shardEviction.matches(cacheKey)) {\n+                                cacheFilesToEvict.put(cacheKey, cacheFile);\n+                            }\n+                        });\n+                        if (cacheFilesToEvict.isEmpty() == false) {\n+                            for (Map.Entry<CacheKey, CacheFile> cacheFile : cacheFilesToEvict.entrySet()) {\n+                                try {\n+                                    cache.invalidate(cacheFile.getKey(), cacheFile.getValue());\n+                                } catch (Exception e) {\n+                                    assert e instanceof IOException : e;\n+                                    logger.warn(() -> new ParameterizedMessage(\"failed to evict cache file {}\", cacheFile.getKey()), e);\n+                                }\n+                            }\n+                        }\n+                    });\n+                }\n+\n+                @Override\n+                public void onFailure(Exception e) {\n+                    logger.warn(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDczMTYwOQ=="}, "originalCommit": {"oid": "c1c9e543ca083ef0356fece7319f540d3431aa02"}, "originalPosition": 92}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4740, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}