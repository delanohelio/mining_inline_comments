{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYzNTQxNDg0", "number": 51088, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNDoxNDowMFrODYhBQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMTo1NjozMFrODbi87Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MDMzNDEwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNDoxNDowMFrOFeasKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNDoxNDowMFrOFeasKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQzODg5MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                return 0; // kep NotEquals' order\n          \n          \n            \n                                return 0; // keep NotEquals' order", "url": "https://github.com/elastic/elasticsearch/pull/51088#discussion_r367438890", "createdAt": "2020-01-16T14:14:00Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -1290,14 +1290,20 @@ private Expression combine(And and) {\n             boolean changed = false;\n \n             List<Expression> andExps = Predicates.splitAnd(and);\n-            // Ranges need to show up before BinaryComparisons in list, to allow the latter be optimized away into a Range, if possible\n+            // Ranges need to show up before BinaryComparisons in list, to allow the latter be optimized away into a Range, if possible.\n+            // NotEquals need to be last in list, to have a complete set of Ranges (ranges) and BinaryComparisons (bcs) and allow these to\n+            // optimize the NotEquals away.\n             andExps.sort((o1, o2) -> {\n                 if (o1 instanceof Range && o2 instanceof Range) {\n                     return 0; // keep ranges' order\n                 } else if (o1 instanceof Range || o2 instanceof Range) {\n-                    return o2 instanceof Range ? 1 : -1;\n+                    return o2 instanceof Range ? 1 : -1; // push Ranges down\n+                } else if (o1 instanceof NotEquals && o2 instanceof NotEquals) {\n+                    return 0; // kep NotEquals' order", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50e4fbb0bd94f6c6b1ee739bafe7711d4a92a442"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MDMzNzQ3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNDoxNTowN1rOFeauUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNDoxNTowN1rOFeauUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQzOTQ0MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                return 0; // keep non-Ranges' and non-NotEquals order\n          \n          \n            \n                                return 0; // keep non-Ranges' and non-NotEquals' order", "url": "https://github.com/elastic/elasticsearch/pull/51088#discussion_r367439440", "createdAt": "2020-01-16T14:15:07Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -1290,14 +1290,20 @@ private Expression combine(And and) {\n             boolean changed = false;\n \n             List<Expression> andExps = Predicates.splitAnd(and);\n-            // Ranges need to show up before BinaryComparisons in list, to allow the latter be optimized away into a Range, if possible\n+            // Ranges need to show up before BinaryComparisons in list, to allow the latter be optimized away into a Range, if possible.\n+            // NotEquals need to be last in list, to have a complete set of Ranges (ranges) and BinaryComparisons (bcs) and allow these to\n+            // optimize the NotEquals away.\n             andExps.sort((o1, o2) -> {\n                 if (o1 instanceof Range && o2 instanceof Range) {\n                     return 0; // keep ranges' order\n                 } else if (o1 instanceof Range || o2 instanceof Range) {\n-                    return o2 instanceof Range ? 1 : -1;\n+                    return o2 instanceof Range ? 1 : -1; // push Ranges down\n+                } else if (o1 instanceof NotEquals && o2 instanceof NotEquals) {\n+                    return 0; // kep NotEquals' order\n+                } else if (o1 instanceof NotEquals || o2 instanceof NotEquals) {\n+                    return o1 instanceof NotEquals ? 1 : -1; // push NotEquals up\n                 } else {\n-                    return 0; // keep non-ranges' order\n+                    return 0; // keep non-Ranges' and non-NotEquals order", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50e4fbb0bd94f6c6b1ee739bafe7711d4a92a442"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MDg4MzY3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNjozOToyNVrOFegBGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMzo1Njo1NFrOFe5r0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUyNjE3MA==", "bodyText": "I would prefer the return value of the function to be boolean and not Boolean since false is never returned currently. Or if I'm confused if false is also a valid return value then why do we return a below literal with Boolean.TRUE instead of using the updated variable there?", "url": "https://github.com/elastic/elasticsearch/pull/51088#discussion_r367526170", "createdAt": "2020-01-16T16:39:25Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -1391,7 +1412,14 @@ private Expression combine(Or or) {\n                 }\n             }\n \n-            return changed ? Predicates.combineOr(CollectionUtils.combine(exps, bcs, ranges)) : or;\n+            Boolean updated = filterDisjunctionByNotEquals(notEquals, bcs, ranges);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23e3aac6ab9b77c3902ca45772da4c2c0b7ae676"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU1NjUxNA==", "bodyText": "false will be returned in case the fields of a NotEquals and a BinaryComparison aren't semantically equal (and can't be simplified otherwise either; smth like a != 2 OR b < 3).\nSo I'd need a three states-return: one for no optimisation possible, one for optimisation has been applied and another one when the entire expression evaluates to literal TRUE.\nI thought an enum might be too much, but happy to apply suggestions.", "url": "https://github.com/elastic/elasticsearch/pull/51088#discussion_r367556514", "createdAt": "2020-01-16T17:37:27Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -1391,7 +1412,14 @@ private Expression combine(Or or) {\n                 }\n             }\n \n-            return changed ? Predicates.combineOr(CollectionUtils.combine(exps, bcs, ranges)) : or;\n+            Boolean updated = filterDisjunctionByNotEquals(notEquals, bcs, ranges);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUyNjE3MA=="}, "originalCommit": {"oid": "23e3aac6ab9b77c3902ca45772da4c2c0b7ae676"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk0NjcwNQ==", "bodyText": "Ok, thank you, I missed that somehow.", "url": "https://github.com/elastic/elasticsearch/pull/51088#discussion_r367946705", "createdAt": "2020-01-17T13:56:54Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -1391,7 +1412,14 @@ private Expression combine(Or or) {\n                 }\n             }\n \n-            return changed ? Predicates.combineOr(CollectionUtils.combine(exps, bcs, ranges)) : or;\n+            Boolean updated = filterDisjunctionByNotEquals(notEquals, bcs, ranges);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUyNjE3MA=="}, "originalCommit": {"oid": "23e3aac6ab9b77c3902ca45772da4c2c0b7ae676"}, "originalPosition": 156}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3OTUxNjQ2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQwNzowMDo1NVrOFfwB-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxNDo0MTo0N1rOFf8Z7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODgzNzExMg==", "bodyText": "I find a bit confusing and potentially problematic, in the future if this code will change, re-using the comp variable in this block. Initially, it has a value assigned to it in on an upper level, it goes through two if branches, then in a separate, distinct conditional branch on an inner level gets another value and is treated similarly as before. I am not suggesting to change this, I am just mentioning it as a nitpick.", "url": "https://github.com/elastic/elasticsearch/pull/51088#discussion_r368837112", "createdAt": "2020-01-21T07:00:55Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -1643,6 +1671,137 @@ else if ((other instanceof LessThan || other instanceof LessThanOrEqual) &&\n \n             return false;\n         }\n+\n+        private static boolean notEqualsIsRemovableFromConjunction(NotEquals notEquals, List<Range> ranges, List<BinaryComparison> bcs) {\n+            Object neqVal = notEquals.right().fold();\n+            Integer comp;\n+\n+            // check on \"condition-overlapping\" ranges:\n+            // a != 2 AND 3 < a < 5 -> 3 < a < 5; a != 2 AND 0 < a < 1 -> 0 < a < 1 (discard NotEquals)\n+            // a != 2 AND 2 <= a < 3 -> 2 < a < 3; a != 3 AND 2 < a <= 3 -> 2 < a < 3 (discard NotEquals, plus update Range)\n+            // a != 2 AND 1 < a < 3 -> nop (do nothing)\n+            for (int i = 0; i < ranges.size(); i ++) {\n+                Range range = ranges.get(i);\n+\n+                if (notEquals.left().semanticEquals(range.value())) {\n+                    comp = range.lower().foldable() ? BinaryComparison.compare(neqVal, range.lower().fold()) : null;\n+                    if (comp != null) {\n+                        if (comp <= 0) {\n+                            if (comp == 0 && range.includeLower()) { // a != 2 AND 2 <= a < ? -> 2 < a < ?\n+                                ranges.set(i, new Range(range.source(), range.value(), range.lower(), false, range.upper(),\n+                                    range.includeUpper()));\n+                            }\n+                            // else: !.includeLower() : a != 2 AND 2 < a < 3 -> 2 < a < 3; or:\n+                            // else: comp < 0 : a != 2 AND 3 < a < ? ->  3 < a < ?\n+\n+                            return true;\n+                        } else { // comp > 0 : a != 4 AND 2 < a < ? : can only remove NotEquals if outside the range\n+                            comp = range.upper().foldable() ? BinaryComparison.compare(neqVal, range.upper().fold()) : null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b7fc42accf23af586c4bc780b3215db99619af2"}, "originalPosition": 196}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTAzOTg1Mw==", "bodyText": "The result of a comp assignment is used right away (i.e. next line) and there only. So I considered unnecessary to declare multiple vars. But I can see how this can be regarded with unease. I'd think that if the usage pattern ever changes, a new var is indeed preferable.", "url": "https://github.com/elastic/elasticsearch/pull/51088#discussion_r369039853", "createdAt": "2020-01-21T14:41:47Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -1643,6 +1671,137 @@ else if ((other instanceof LessThan || other instanceof LessThanOrEqual) &&\n \n             return false;\n         }\n+\n+        private static boolean notEqualsIsRemovableFromConjunction(NotEquals notEquals, List<Range> ranges, List<BinaryComparison> bcs) {\n+            Object neqVal = notEquals.right().fold();\n+            Integer comp;\n+\n+            // check on \"condition-overlapping\" ranges:\n+            // a != 2 AND 3 < a < 5 -> 3 < a < 5; a != 2 AND 0 < a < 1 -> 0 < a < 1 (discard NotEquals)\n+            // a != 2 AND 2 <= a < 3 -> 2 < a < 3; a != 3 AND 2 < a <= 3 -> 2 < a < 3 (discard NotEquals, plus update Range)\n+            // a != 2 AND 1 < a < 3 -> nop (do nothing)\n+            for (int i = 0; i < ranges.size(); i ++) {\n+                Range range = ranges.get(i);\n+\n+                if (notEquals.left().semanticEquals(range.value())) {\n+                    comp = range.lower().foldable() ? BinaryComparison.compare(neqVal, range.lower().fold()) : null;\n+                    if (comp != null) {\n+                        if (comp <= 0) {\n+                            if (comp == 0 && range.includeLower()) { // a != 2 AND 2 <= a < ? -> 2 < a < ?\n+                                ranges.set(i, new Range(range.source(), range.value(), range.lower(), false, range.upper(),\n+                                    range.includeUpper()));\n+                            }\n+                            // else: !.includeLower() : a != 2 AND 2 < a < 3 -> 2 < a < 3; or:\n+                            // else: comp < 0 : a != 2 AND 3 < a < ? ->  3 < a < ?\n+\n+                            return true;\n+                        } else { // comp > 0 : a != 4 AND 2 < a < ? : can only remove NotEquals if outside the range\n+                            comp = range.upper().foldable() ? BinaryComparison.compare(neqVal, range.upper().fold()) : null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODgzNzExMg=="}, "originalCommit": {"oid": "4b7fc42accf23af586c4bc780b3215db99619af2"}, "originalPosition": 196}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3OTU1NTg3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "isResolved": false, "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQwNzoyMzo1NVrOFfwZYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxMDoyNzo1N1rOFg5YGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg0MzEwNg==", "bodyText": "I don't understand this simplification here. If the not-equality and a < or > act on the same variable (a in this case) why is a != 2 OR a < 3 resulting in a a != 2 condition?\nOne edge case is a = 2 and in this case it matches a < 3. The other edge case is anything >= 3 and in this case it matches the condition a != 2. The way I see it, a != 2 OR a < 3 is always TRUE.\nBUT, in Elasticsearch these two conditions being existent in a query (even if they can be simplified), they can contribute to the scoring of a document: an OR is translated into a bool query with two should statements. And, even if, the documents being returned are the same in a simplified (assuming the simplification returns always TRUE) and non-simplified way, if the user also asks for SCORE(), the actual results will be different in the two cases. I would take a step back and re-evaluate the OR simplification in general to make sure it doesn't affect the scoring of documents, in case SCORE() is returned.", "url": "https://github.com/elastic/elasticsearch/pull/51088#discussion_r368843106", "createdAt": "2020-01-21T07:23:55Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -1643,6 +1671,137 @@ else if ((other instanceof LessThan || other instanceof LessThanOrEqual) &&\n \n             return false;\n         }\n+\n+        private static boolean notEqualsIsRemovableFromConjunction(NotEquals notEquals, List<Range> ranges, List<BinaryComparison> bcs) {\n+            Object neqVal = notEquals.right().fold();\n+            Integer comp;\n+\n+            // check on \"condition-overlapping\" ranges:\n+            // a != 2 AND 3 < a < 5 -> 3 < a < 5; a != 2 AND 0 < a < 1 -> 0 < a < 1 (discard NotEquals)\n+            // a != 2 AND 2 <= a < 3 -> 2 < a < 3; a != 3 AND 2 < a <= 3 -> 2 < a < 3 (discard NotEquals, plus update Range)\n+            // a != 2 AND 1 < a < 3 -> nop (do nothing)\n+            for (int i = 0; i < ranges.size(); i ++) {\n+                Range range = ranges.get(i);\n+\n+                if (notEquals.left().semanticEquals(range.value())) {\n+                    comp = range.lower().foldable() ? BinaryComparison.compare(neqVal, range.lower().fold()) : null;\n+                    if (comp != null) {\n+                        if (comp <= 0) {\n+                            if (comp == 0 && range.includeLower()) { // a != 2 AND 2 <= a < ? -> 2 < a < ?\n+                                ranges.set(i, new Range(range.source(), range.value(), range.lower(), false, range.upper(),\n+                                    range.includeUpper()));\n+                            }\n+                            // else: !.includeLower() : a != 2 AND 2 < a < 3 -> 2 < a < 3; or:\n+                            // else: comp < 0 : a != 2 AND 3 < a < ? ->  3 < a < ?\n+\n+                            return true;\n+                        } else { // comp > 0 : a != 4 AND 2 < a < ? : can only remove NotEquals if outside the range\n+                            comp = range.upper().foldable() ? BinaryComparison.compare(neqVal, range.upper().fold()) : null;\n+                            if (comp != null && comp >= 0) {\n+                                if (comp == 0 && range.includeUpper()) { // a != 4 AND 2 < a <= 4 -> 2 < a < 4\n+                                    ranges.set(i, new Range(range.source(), range.value(), range.lower(), range.includeLower(),\n+                                        range.upper(), false));\n+                                }\n+                                // else: !.includeUpper() : a != 4 AND 2 < a < 4 -> 2 < a < 4\n+                                // else: comp > 0 : a != 4 AND 2 < a < 3 -> 2 < a < 3\n+\n+                                return true;\n+                            }\n+                            // else: comp < 0 : a != 4 AND 2 < a < 5 -> nop; or:\n+                            // else: comp == null : upper bound not comparable -> nop\n+                        }\n+                    } // else: comp == null : lower bound not comparable: evaluate upper bound, in case non-equality value is \">=\"\n+\n+                    comp = range.upper().foldable() ? BinaryComparison.compare(neqVal, range.upper().fold()) : null;\n+                    if (comp != null && comp >= 0) {\n+                        if (comp == 0 && range.includeUpper()) { // a != 3 AND ?? < a <= 3 -> ?? < a < 3\n+                            ranges.set(i, new Range(range.source(), range.value(), range.lower(), range.includeLower(), range.upper(),\n+                                false));\n+                        }\n+                        // else: !.includeUpper() : a != 3 AND ?? < a < 3 -> ?? < a < 3\n+                        // else: comp > 0 : a != 3 and ?? < a < 2 -> ?? < a < 2\n+\n+                        return true;\n+                    }\n+                    // else: comp < 0 : a != 3 AND ?? < a < 4 -> nop, as a decision can't be drawn; or:\n+                    // else: comp == null : a != 3 AND ?? < a < ?? -> nop\n+                }\n+            }\n+\n+            // check on \"condition-overlapping\" inequalities:\n+            // a != 2 AND a > 3 -> a > 3 (discard NotEquals)\n+            // a != 2 AND a >= 2 -> a > 2 (discard NotEquals plus update inequality)\n+            // a != 2 AND a > 1 -> nop (do nothing)\n+            //\n+            // a != 2 AND a < 3 -> nop\n+            // a != 2 AND a <= 2 -> a < 2\n+            // a != 2 AND a < 1 -> a < 1\n+            for (int i = 0; i < bcs.size(); i ++) {\n+                BinaryComparison bc = bcs.get(i);\n+\n+                if (bc instanceof LessThan || bc instanceof LessThanOrEqual) {\n+                    comp = bc.right().foldable() ? BinaryComparison.compare(neqVal, bc.right().fold()) : null;\n+                    if (comp != null) {\n+                        if (comp >= 0) {\n+                            if (comp == 0 && bc instanceof LessThanOrEqual) { // a != 2 AND a <= 2 -> a < 2\n+                                bcs.set(i, new LessThan(bc.source(), bc.left(), bc.right()));\n+                            } // else : comp > 0 (a != 2 AND a </<= 1 -> a </<= 1), or == 0 && bc i.of \"<\" (a != 2 AND a < 2 -> a < 2)\n+                            return true;\n+                        } // else: comp < 0 : a != 2 AND a </<= 3 -> nop\n+                    } // else: non-comparable, nop\n+                } else if (bc instanceof GreaterThan || bc instanceof GreaterThanOrEqual) {\n+                    comp = bc.right().foldable() ? BinaryComparison.compare(neqVal, bc.right().fold()) : null;\n+                    if (comp != null) {\n+                        if (comp <= 0) {\n+                            if (comp == 0 && bc instanceof GreaterThanOrEqual) { // a != 2 AND a >= 2 -> a > 2\n+                                bcs.set(i, new GreaterThan(bc.source(), bc.left(), bc.right()));\n+                            } // else: comp < 0 (a != 2 AND a >/>= 3 -> a >/>= 3), or == 0 && bc i.of \">\" (a != 2 AND a > 2 -> a > 2)\n+                            return true;\n+                        } // else: comp > 0 : a != 2 AND a >/>= 1 -> nop\n+                    } // else: non-comparable, nop\n+                } // else: other non-relevant type\n+            }\n+\n+            return false;\n+        }\n+\n+        // a != X OR Y < a < Z -> a != X (plus equivalent inequalities)\n+        // a != X OR X <= a < Z -> TRUE (plus equality on upper bound, plus equivalent inequalities)\n+        private static Boolean filterDisjunctionByNotEquals(List<NotEquals> notEquals, List<BinaryComparison> bcs, List<Range> ranges) {\n+            Boolean updated = false;\n+\n+            for (NotEquals neq : notEquals) {\n+                for (Iterator<BinaryComparison> bcIterator = bcs.iterator(); bcIterator.hasNext(); ) {\n+                    BinaryComparison bc = bcIterator.next();\n+                    if (neq.left().semanticEquals(bc.left())) {\n+                        if (bc instanceof LessThan || bc instanceof GreaterThan) { // a != 2 OR a < 3 -> a != 2 (plus LessThen)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b7fc42accf23af586c4bc780b3215db99619af2"}, "originalPosition": 274}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTAyNjU2MA==", "bodyText": "One edge case is a = 2 and in this case it matches a < 3. The other edge case is anything >= 3 and in this case it matches the condition a != 2. The way I see it, a != 2 OR a < 3 is always TRUE.\n\nThat's actually TRUE, thanks for catching it!\nI believe the correct optimisation for a != X OR Y </<= a </<= Z should be to:\n\na != X if:\n\nX \u2209 (Y, Z); or\nbound equalities are disjunctive: X==Y && (Y < a ... ) or X==Z && (... a < Z);\n\n\nTRUE in all other cases.\n\nAnd same goes for inequalities, where Y or Z would become -\u221e or +\u221e respectively.\nI'll fix it.", "url": "https://github.com/elastic/elasticsearch/pull/51088#discussion_r369026560", "createdAt": "2020-01-21T14:19:30Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -1643,6 +1671,137 @@ else if ((other instanceof LessThan || other instanceof LessThanOrEqual) &&\n \n             return false;\n         }\n+\n+        private static boolean notEqualsIsRemovableFromConjunction(NotEquals notEquals, List<Range> ranges, List<BinaryComparison> bcs) {\n+            Object neqVal = notEquals.right().fold();\n+            Integer comp;\n+\n+            // check on \"condition-overlapping\" ranges:\n+            // a != 2 AND 3 < a < 5 -> 3 < a < 5; a != 2 AND 0 < a < 1 -> 0 < a < 1 (discard NotEquals)\n+            // a != 2 AND 2 <= a < 3 -> 2 < a < 3; a != 3 AND 2 < a <= 3 -> 2 < a < 3 (discard NotEquals, plus update Range)\n+            // a != 2 AND 1 < a < 3 -> nop (do nothing)\n+            for (int i = 0; i < ranges.size(); i ++) {\n+                Range range = ranges.get(i);\n+\n+                if (notEquals.left().semanticEquals(range.value())) {\n+                    comp = range.lower().foldable() ? BinaryComparison.compare(neqVal, range.lower().fold()) : null;\n+                    if (comp != null) {\n+                        if (comp <= 0) {\n+                            if (comp == 0 && range.includeLower()) { // a != 2 AND 2 <= a < ? -> 2 < a < ?\n+                                ranges.set(i, new Range(range.source(), range.value(), range.lower(), false, range.upper(),\n+                                    range.includeUpper()));\n+                            }\n+                            // else: !.includeLower() : a != 2 AND 2 < a < 3 -> 2 < a < 3; or:\n+                            // else: comp < 0 : a != 2 AND 3 < a < ? ->  3 < a < ?\n+\n+                            return true;\n+                        } else { // comp > 0 : a != 4 AND 2 < a < ? : can only remove NotEquals if outside the range\n+                            comp = range.upper().foldable() ? BinaryComparison.compare(neqVal, range.upper().fold()) : null;\n+                            if (comp != null && comp >= 0) {\n+                                if (comp == 0 && range.includeUpper()) { // a != 4 AND 2 < a <= 4 -> 2 < a < 4\n+                                    ranges.set(i, new Range(range.source(), range.value(), range.lower(), range.includeLower(),\n+                                        range.upper(), false));\n+                                }\n+                                // else: !.includeUpper() : a != 4 AND 2 < a < 4 -> 2 < a < 4\n+                                // else: comp > 0 : a != 4 AND 2 < a < 3 -> 2 < a < 3\n+\n+                                return true;\n+                            }\n+                            // else: comp < 0 : a != 4 AND 2 < a < 5 -> nop; or:\n+                            // else: comp == null : upper bound not comparable -> nop\n+                        }\n+                    } // else: comp == null : lower bound not comparable: evaluate upper bound, in case non-equality value is \">=\"\n+\n+                    comp = range.upper().foldable() ? BinaryComparison.compare(neqVal, range.upper().fold()) : null;\n+                    if (comp != null && comp >= 0) {\n+                        if (comp == 0 && range.includeUpper()) { // a != 3 AND ?? < a <= 3 -> ?? < a < 3\n+                            ranges.set(i, new Range(range.source(), range.value(), range.lower(), range.includeLower(), range.upper(),\n+                                false));\n+                        }\n+                        // else: !.includeUpper() : a != 3 AND ?? < a < 3 -> ?? < a < 3\n+                        // else: comp > 0 : a != 3 and ?? < a < 2 -> ?? < a < 2\n+\n+                        return true;\n+                    }\n+                    // else: comp < 0 : a != 3 AND ?? < a < 4 -> nop, as a decision can't be drawn; or:\n+                    // else: comp == null : a != 3 AND ?? < a < ?? -> nop\n+                }\n+            }\n+\n+            // check on \"condition-overlapping\" inequalities:\n+            // a != 2 AND a > 3 -> a > 3 (discard NotEquals)\n+            // a != 2 AND a >= 2 -> a > 2 (discard NotEquals plus update inequality)\n+            // a != 2 AND a > 1 -> nop (do nothing)\n+            //\n+            // a != 2 AND a < 3 -> nop\n+            // a != 2 AND a <= 2 -> a < 2\n+            // a != 2 AND a < 1 -> a < 1\n+            for (int i = 0; i < bcs.size(); i ++) {\n+                BinaryComparison bc = bcs.get(i);\n+\n+                if (bc instanceof LessThan || bc instanceof LessThanOrEqual) {\n+                    comp = bc.right().foldable() ? BinaryComparison.compare(neqVal, bc.right().fold()) : null;\n+                    if (comp != null) {\n+                        if (comp >= 0) {\n+                            if (comp == 0 && bc instanceof LessThanOrEqual) { // a != 2 AND a <= 2 -> a < 2\n+                                bcs.set(i, new LessThan(bc.source(), bc.left(), bc.right()));\n+                            } // else : comp > 0 (a != 2 AND a </<= 1 -> a </<= 1), or == 0 && bc i.of \"<\" (a != 2 AND a < 2 -> a < 2)\n+                            return true;\n+                        } // else: comp < 0 : a != 2 AND a </<= 3 -> nop\n+                    } // else: non-comparable, nop\n+                } else if (bc instanceof GreaterThan || bc instanceof GreaterThanOrEqual) {\n+                    comp = bc.right().foldable() ? BinaryComparison.compare(neqVal, bc.right().fold()) : null;\n+                    if (comp != null) {\n+                        if (comp <= 0) {\n+                            if (comp == 0 && bc instanceof GreaterThanOrEqual) { // a != 2 AND a >= 2 -> a > 2\n+                                bcs.set(i, new GreaterThan(bc.source(), bc.left(), bc.right()));\n+                            } // else: comp < 0 (a != 2 AND a >/>= 3 -> a >/>= 3), or == 0 && bc i.of \">\" (a != 2 AND a > 2 -> a > 2)\n+                            return true;\n+                        } // else: comp > 0 : a != 2 AND a >/>= 1 -> nop\n+                    } // else: non-comparable, nop\n+                } // else: other non-relevant type\n+            }\n+\n+            return false;\n+        }\n+\n+        // a != X OR Y < a < Z -> a != X (plus equivalent inequalities)\n+        // a != X OR X <= a < Z -> TRUE (plus equality on upper bound, plus equivalent inequalities)\n+        private static Boolean filterDisjunctionByNotEquals(List<NotEquals> notEquals, List<BinaryComparison> bcs, List<Range> ranges) {\n+            Boolean updated = false;\n+\n+            for (NotEquals neq : notEquals) {\n+                for (Iterator<BinaryComparison> bcIterator = bcs.iterator(); bcIterator.hasNext(); ) {\n+                    BinaryComparison bc = bcIterator.next();\n+                    if (neq.left().semanticEquals(bc.left())) {\n+                        if (bc instanceof LessThan || bc instanceof GreaterThan) { // a != 2 OR a < 3 -> a != 2 (plus LessThen)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg0MzEwNg=="}, "originalCommit": {"oid": "4b7fc42accf23af586c4bc780b3215db99619af2"}, "originalPosition": 274}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTAzMjc5MA==", "bodyText": "I would take a step back and re-evaluate the OR simplification in general to make sure it doesn't affect the scoring of documents, in case SCORE() is returned.\n\nInteresting point. Do you think it'd be easy (or even necessary) to come up with an example? This being about numerical conditions optimisations, I'm wondering if the scoring would be indeed affected, in isolation: a != 2 OR a > 3 OR b = 'foo' vs. a != 2 OR b = 'foo' would yield different scores?\nI'll look into it (unless you're positive about it and I can save that time). Others - @costin? - welcome to chime in, I believe the simplifications in the optimiser  are not isolated to equalities and inequalities around AND/ORs.", "url": "https://github.com/elastic/elasticsearch/pull/51088#discussion_r369032790", "createdAt": "2020-01-21T14:30:02Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -1643,6 +1671,137 @@ else if ((other instanceof LessThan || other instanceof LessThanOrEqual) &&\n \n             return false;\n         }\n+\n+        private static boolean notEqualsIsRemovableFromConjunction(NotEquals notEquals, List<Range> ranges, List<BinaryComparison> bcs) {\n+            Object neqVal = notEquals.right().fold();\n+            Integer comp;\n+\n+            // check on \"condition-overlapping\" ranges:\n+            // a != 2 AND 3 < a < 5 -> 3 < a < 5; a != 2 AND 0 < a < 1 -> 0 < a < 1 (discard NotEquals)\n+            // a != 2 AND 2 <= a < 3 -> 2 < a < 3; a != 3 AND 2 < a <= 3 -> 2 < a < 3 (discard NotEquals, plus update Range)\n+            // a != 2 AND 1 < a < 3 -> nop (do nothing)\n+            for (int i = 0; i < ranges.size(); i ++) {\n+                Range range = ranges.get(i);\n+\n+                if (notEquals.left().semanticEquals(range.value())) {\n+                    comp = range.lower().foldable() ? BinaryComparison.compare(neqVal, range.lower().fold()) : null;\n+                    if (comp != null) {\n+                        if (comp <= 0) {\n+                            if (comp == 0 && range.includeLower()) { // a != 2 AND 2 <= a < ? -> 2 < a < ?\n+                                ranges.set(i, new Range(range.source(), range.value(), range.lower(), false, range.upper(),\n+                                    range.includeUpper()));\n+                            }\n+                            // else: !.includeLower() : a != 2 AND 2 < a < 3 -> 2 < a < 3; or:\n+                            // else: comp < 0 : a != 2 AND 3 < a < ? ->  3 < a < ?\n+\n+                            return true;\n+                        } else { // comp > 0 : a != 4 AND 2 < a < ? : can only remove NotEquals if outside the range\n+                            comp = range.upper().foldable() ? BinaryComparison.compare(neqVal, range.upper().fold()) : null;\n+                            if (comp != null && comp >= 0) {\n+                                if (comp == 0 && range.includeUpper()) { // a != 4 AND 2 < a <= 4 -> 2 < a < 4\n+                                    ranges.set(i, new Range(range.source(), range.value(), range.lower(), range.includeLower(),\n+                                        range.upper(), false));\n+                                }\n+                                // else: !.includeUpper() : a != 4 AND 2 < a < 4 -> 2 < a < 4\n+                                // else: comp > 0 : a != 4 AND 2 < a < 3 -> 2 < a < 3\n+\n+                                return true;\n+                            }\n+                            // else: comp < 0 : a != 4 AND 2 < a < 5 -> nop; or:\n+                            // else: comp == null : upper bound not comparable -> nop\n+                        }\n+                    } // else: comp == null : lower bound not comparable: evaluate upper bound, in case non-equality value is \">=\"\n+\n+                    comp = range.upper().foldable() ? BinaryComparison.compare(neqVal, range.upper().fold()) : null;\n+                    if (comp != null && comp >= 0) {\n+                        if (comp == 0 && range.includeUpper()) { // a != 3 AND ?? < a <= 3 -> ?? < a < 3\n+                            ranges.set(i, new Range(range.source(), range.value(), range.lower(), range.includeLower(), range.upper(),\n+                                false));\n+                        }\n+                        // else: !.includeUpper() : a != 3 AND ?? < a < 3 -> ?? < a < 3\n+                        // else: comp > 0 : a != 3 and ?? < a < 2 -> ?? < a < 2\n+\n+                        return true;\n+                    }\n+                    // else: comp < 0 : a != 3 AND ?? < a < 4 -> nop, as a decision can't be drawn; or:\n+                    // else: comp == null : a != 3 AND ?? < a < ?? -> nop\n+                }\n+            }\n+\n+            // check on \"condition-overlapping\" inequalities:\n+            // a != 2 AND a > 3 -> a > 3 (discard NotEquals)\n+            // a != 2 AND a >= 2 -> a > 2 (discard NotEquals plus update inequality)\n+            // a != 2 AND a > 1 -> nop (do nothing)\n+            //\n+            // a != 2 AND a < 3 -> nop\n+            // a != 2 AND a <= 2 -> a < 2\n+            // a != 2 AND a < 1 -> a < 1\n+            for (int i = 0; i < bcs.size(); i ++) {\n+                BinaryComparison bc = bcs.get(i);\n+\n+                if (bc instanceof LessThan || bc instanceof LessThanOrEqual) {\n+                    comp = bc.right().foldable() ? BinaryComparison.compare(neqVal, bc.right().fold()) : null;\n+                    if (comp != null) {\n+                        if (comp >= 0) {\n+                            if (comp == 0 && bc instanceof LessThanOrEqual) { // a != 2 AND a <= 2 -> a < 2\n+                                bcs.set(i, new LessThan(bc.source(), bc.left(), bc.right()));\n+                            } // else : comp > 0 (a != 2 AND a </<= 1 -> a </<= 1), or == 0 && bc i.of \"<\" (a != 2 AND a < 2 -> a < 2)\n+                            return true;\n+                        } // else: comp < 0 : a != 2 AND a </<= 3 -> nop\n+                    } // else: non-comparable, nop\n+                } else if (bc instanceof GreaterThan || bc instanceof GreaterThanOrEqual) {\n+                    comp = bc.right().foldable() ? BinaryComparison.compare(neqVal, bc.right().fold()) : null;\n+                    if (comp != null) {\n+                        if (comp <= 0) {\n+                            if (comp == 0 && bc instanceof GreaterThanOrEqual) { // a != 2 AND a >= 2 -> a > 2\n+                                bcs.set(i, new GreaterThan(bc.source(), bc.left(), bc.right()));\n+                            } // else: comp < 0 (a != 2 AND a >/>= 3 -> a >/>= 3), or == 0 && bc i.of \">\" (a != 2 AND a > 2 -> a > 2)\n+                            return true;\n+                        } // else: comp > 0 : a != 2 AND a >/>= 1 -> nop\n+                    } // else: non-comparable, nop\n+                } // else: other non-relevant type\n+            }\n+\n+            return false;\n+        }\n+\n+        // a != X OR Y < a < Z -> a != X (plus equivalent inequalities)\n+        // a != X OR X <= a < Z -> TRUE (plus equality on upper bound, plus equivalent inequalities)\n+        private static Boolean filterDisjunctionByNotEquals(List<NotEquals> notEquals, List<BinaryComparison> bcs, List<Range> ranges) {\n+            Boolean updated = false;\n+\n+            for (NotEquals neq : notEquals) {\n+                for (Iterator<BinaryComparison> bcIterator = bcs.iterator(); bcIterator.hasNext(); ) {\n+                    BinaryComparison bc = bcIterator.next();\n+                    if (neq.left().semanticEquals(bc.left())) {\n+                        if (bc instanceof LessThan || bc instanceof GreaterThan) { // a != 2 OR a < 3 -> a != 2 (plus LessThen)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg0MzEwNg=="}, "originalCommit": {"oid": "4b7fc42accf23af586c4bc780b3215db99619af2"}, "originalPosition": 274}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTA0MjMwMg==", "bodyText": "@bpintea select SCORE(), salary from test_emp where salary <> 70000 OR salary < 30000 ORDER BY salary which is the case for a != X OR a < Y. The results are like this (tested this in 6.8, but I am reasonably confident it's the same in master):\n    SCORE()    |    salary     \n---------------+---------------\n2.0            |25324          \n2.0            |25945          \n2.0            |25976          \n2.0            |26436          \n2.0            |27215          \n2.0            |28035          \n2.0            |28336          \n2.0            |28941          \n2.0            |29175          \n1.0            |30404          \n1.0            |31120          \n1.0            |31897          \n1.0            |32263          \n1.0            |32272          \n1.0            |32568          \n1.0            |33370          \n1.0            |33956          \n1.0            |34341          \n1.0            |35222          \n1.0            |35742          \n1.0            |36051          \n1.0            |36174          \n1.0            |37112          \n1.0            |37137          \n1.0            |37691          \n1.0            |37702          \n1.0            |37716          \n1.0            |37853          \n\nIf you simplify those two conditions to TRUE, there will be a single score of 1.0 I think.", "url": "https://github.com/elastic/elasticsearch/pull/51088#discussion_r369042302", "createdAt": "2020-01-21T14:45:27Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -1643,6 +1671,137 @@ else if ((other instanceof LessThan || other instanceof LessThanOrEqual) &&\n \n             return false;\n         }\n+\n+        private static boolean notEqualsIsRemovableFromConjunction(NotEquals notEquals, List<Range> ranges, List<BinaryComparison> bcs) {\n+            Object neqVal = notEquals.right().fold();\n+            Integer comp;\n+\n+            // check on \"condition-overlapping\" ranges:\n+            // a != 2 AND 3 < a < 5 -> 3 < a < 5; a != 2 AND 0 < a < 1 -> 0 < a < 1 (discard NotEquals)\n+            // a != 2 AND 2 <= a < 3 -> 2 < a < 3; a != 3 AND 2 < a <= 3 -> 2 < a < 3 (discard NotEquals, plus update Range)\n+            // a != 2 AND 1 < a < 3 -> nop (do nothing)\n+            for (int i = 0; i < ranges.size(); i ++) {\n+                Range range = ranges.get(i);\n+\n+                if (notEquals.left().semanticEquals(range.value())) {\n+                    comp = range.lower().foldable() ? BinaryComparison.compare(neqVal, range.lower().fold()) : null;\n+                    if (comp != null) {\n+                        if (comp <= 0) {\n+                            if (comp == 0 && range.includeLower()) { // a != 2 AND 2 <= a < ? -> 2 < a < ?\n+                                ranges.set(i, new Range(range.source(), range.value(), range.lower(), false, range.upper(),\n+                                    range.includeUpper()));\n+                            }\n+                            // else: !.includeLower() : a != 2 AND 2 < a < 3 -> 2 < a < 3; or:\n+                            // else: comp < 0 : a != 2 AND 3 < a < ? ->  3 < a < ?\n+\n+                            return true;\n+                        } else { // comp > 0 : a != 4 AND 2 < a < ? : can only remove NotEquals if outside the range\n+                            comp = range.upper().foldable() ? BinaryComparison.compare(neqVal, range.upper().fold()) : null;\n+                            if (comp != null && comp >= 0) {\n+                                if (comp == 0 && range.includeUpper()) { // a != 4 AND 2 < a <= 4 -> 2 < a < 4\n+                                    ranges.set(i, new Range(range.source(), range.value(), range.lower(), range.includeLower(),\n+                                        range.upper(), false));\n+                                }\n+                                // else: !.includeUpper() : a != 4 AND 2 < a < 4 -> 2 < a < 4\n+                                // else: comp > 0 : a != 4 AND 2 < a < 3 -> 2 < a < 3\n+\n+                                return true;\n+                            }\n+                            // else: comp < 0 : a != 4 AND 2 < a < 5 -> nop; or:\n+                            // else: comp == null : upper bound not comparable -> nop\n+                        }\n+                    } // else: comp == null : lower bound not comparable: evaluate upper bound, in case non-equality value is \">=\"\n+\n+                    comp = range.upper().foldable() ? BinaryComparison.compare(neqVal, range.upper().fold()) : null;\n+                    if (comp != null && comp >= 0) {\n+                        if (comp == 0 && range.includeUpper()) { // a != 3 AND ?? < a <= 3 -> ?? < a < 3\n+                            ranges.set(i, new Range(range.source(), range.value(), range.lower(), range.includeLower(), range.upper(),\n+                                false));\n+                        }\n+                        // else: !.includeUpper() : a != 3 AND ?? < a < 3 -> ?? < a < 3\n+                        // else: comp > 0 : a != 3 and ?? < a < 2 -> ?? < a < 2\n+\n+                        return true;\n+                    }\n+                    // else: comp < 0 : a != 3 AND ?? < a < 4 -> nop, as a decision can't be drawn; or:\n+                    // else: comp == null : a != 3 AND ?? < a < ?? -> nop\n+                }\n+            }\n+\n+            // check on \"condition-overlapping\" inequalities:\n+            // a != 2 AND a > 3 -> a > 3 (discard NotEquals)\n+            // a != 2 AND a >= 2 -> a > 2 (discard NotEquals plus update inequality)\n+            // a != 2 AND a > 1 -> nop (do nothing)\n+            //\n+            // a != 2 AND a < 3 -> nop\n+            // a != 2 AND a <= 2 -> a < 2\n+            // a != 2 AND a < 1 -> a < 1\n+            for (int i = 0; i < bcs.size(); i ++) {\n+                BinaryComparison bc = bcs.get(i);\n+\n+                if (bc instanceof LessThan || bc instanceof LessThanOrEqual) {\n+                    comp = bc.right().foldable() ? BinaryComparison.compare(neqVal, bc.right().fold()) : null;\n+                    if (comp != null) {\n+                        if (comp >= 0) {\n+                            if (comp == 0 && bc instanceof LessThanOrEqual) { // a != 2 AND a <= 2 -> a < 2\n+                                bcs.set(i, new LessThan(bc.source(), bc.left(), bc.right()));\n+                            } // else : comp > 0 (a != 2 AND a </<= 1 -> a </<= 1), or == 0 && bc i.of \"<\" (a != 2 AND a < 2 -> a < 2)\n+                            return true;\n+                        } // else: comp < 0 : a != 2 AND a </<= 3 -> nop\n+                    } // else: non-comparable, nop\n+                } else if (bc instanceof GreaterThan || bc instanceof GreaterThanOrEqual) {\n+                    comp = bc.right().foldable() ? BinaryComparison.compare(neqVal, bc.right().fold()) : null;\n+                    if (comp != null) {\n+                        if (comp <= 0) {\n+                            if (comp == 0 && bc instanceof GreaterThanOrEqual) { // a != 2 AND a >= 2 -> a > 2\n+                                bcs.set(i, new GreaterThan(bc.source(), bc.left(), bc.right()));\n+                            } // else: comp < 0 (a != 2 AND a >/>= 3 -> a >/>= 3), or == 0 && bc i.of \">\" (a != 2 AND a > 2 -> a > 2)\n+                            return true;\n+                        } // else: comp > 0 : a != 2 AND a >/>= 1 -> nop\n+                    } // else: non-comparable, nop\n+                } // else: other non-relevant type\n+            }\n+\n+            return false;\n+        }\n+\n+        // a != X OR Y < a < Z -> a != X (plus equivalent inequalities)\n+        // a != X OR X <= a < Z -> TRUE (plus equality on upper bound, plus equivalent inequalities)\n+        private static Boolean filterDisjunctionByNotEquals(List<NotEquals> notEquals, List<BinaryComparison> bcs, List<Range> ranges) {\n+            Boolean updated = false;\n+\n+            for (NotEquals neq : notEquals) {\n+                for (Iterator<BinaryComparison> bcIterator = bcs.iterator(); bcIterator.hasNext(); ) {\n+                    BinaryComparison bc = bcIterator.next();\n+                    if (neq.left().semanticEquals(bc.left())) {\n+                        if (bc instanceof LessThan || bc instanceof GreaterThan) { // a != 2 OR a < 3 -> a != 2 (plus LessThen)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg0MzEwNg=="}, "originalCommit": {"oid": "4b7fc42accf23af586c4bc780b3215db99619af2"}, "originalPosition": 274}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTA3MDgyNg==", "bodyText": "Thanks.\nIt seems indeed that other (existing) optimisations would also impact the scoring. (Smth like WHERE salary < 30000 OR salary < 50000 yield same scores as without the first condition, merging inequalities into ranges would probably also affect it etc.)\nSo I guess the presence of scoring might require a deeper consideration in regards to deploying the optimiser?", "url": "https://github.com/elastic/elasticsearch/pull/51088#discussion_r369070826", "createdAt": "2020-01-21T15:31:40Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -1643,6 +1671,137 @@ else if ((other instanceof LessThan || other instanceof LessThanOrEqual) &&\n \n             return false;\n         }\n+\n+        private static boolean notEqualsIsRemovableFromConjunction(NotEquals notEquals, List<Range> ranges, List<BinaryComparison> bcs) {\n+            Object neqVal = notEquals.right().fold();\n+            Integer comp;\n+\n+            // check on \"condition-overlapping\" ranges:\n+            // a != 2 AND 3 < a < 5 -> 3 < a < 5; a != 2 AND 0 < a < 1 -> 0 < a < 1 (discard NotEquals)\n+            // a != 2 AND 2 <= a < 3 -> 2 < a < 3; a != 3 AND 2 < a <= 3 -> 2 < a < 3 (discard NotEquals, plus update Range)\n+            // a != 2 AND 1 < a < 3 -> nop (do nothing)\n+            for (int i = 0; i < ranges.size(); i ++) {\n+                Range range = ranges.get(i);\n+\n+                if (notEquals.left().semanticEquals(range.value())) {\n+                    comp = range.lower().foldable() ? BinaryComparison.compare(neqVal, range.lower().fold()) : null;\n+                    if (comp != null) {\n+                        if (comp <= 0) {\n+                            if (comp == 0 && range.includeLower()) { // a != 2 AND 2 <= a < ? -> 2 < a < ?\n+                                ranges.set(i, new Range(range.source(), range.value(), range.lower(), false, range.upper(),\n+                                    range.includeUpper()));\n+                            }\n+                            // else: !.includeLower() : a != 2 AND 2 < a < 3 -> 2 < a < 3; or:\n+                            // else: comp < 0 : a != 2 AND 3 < a < ? ->  3 < a < ?\n+\n+                            return true;\n+                        } else { // comp > 0 : a != 4 AND 2 < a < ? : can only remove NotEquals if outside the range\n+                            comp = range.upper().foldable() ? BinaryComparison.compare(neqVal, range.upper().fold()) : null;\n+                            if (comp != null && comp >= 0) {\n+                                if (comp == 0 && range.includeUpper()) { // a != 4 AND 2 < a <= 4 -> 2 < a < 4\n+                                    ranges.set(i, new Range(range.source(), range.value(), range.lower(), range.includeLower(),\n+                                        range.upper(), false));\n+                                }\n+                                // else: !.includeUpper() : a != 4 AND 2 < a < 4 -> 2 < a < 4\n+                                // else: comp > 0 : a != 4 AND 2 < a < 3 -> 2 < a < 3\n+\n+                                return true;\n+                            }\n+                            // else: comp < 0 : a != 4 AND 2 < a < 5 -> nop; or:\n+                            // else: comp == null : upper bound not comparable -> nop\n+                        }\n+                    } // else: comp == null : lower bound not comparable: evaluate upper bound, in case non-equality value is \">=\"\n+\n+                    comp = range.upper().foldable() ? BinaryComparison.compare(neqVal, range.upper().fold()) : null;\n+                    if (comp != null && comp >= 0) {\n+                        if (comp == 0 && range.includeUpper()) { // a != 3 AND ?? < a <= 3 -> ?? < a < 3\n+                            ranges.set(i, new Range(range.source(), range.value(), range.lower(), range.includeLower(), range.upper(),\n+                                false));\n+                        }\n+                        // else: !.includeUpper() : a != 3 AND ?? < a < 3 -> ?? < a < 3\n+                        // else: comp > 0 : a != 3 and ?? < a < 2 -> ?? < a < 2\n+\n+                        return true;\n+                    }\n+                    // else: comp < 0 : a != 3 AND ?? < a < 4 -> nop, as a decision can't be drawn; or:\n+                    // else: comp == null : a != 3 AND ?? < a < ?? -> nop\n+                }\n+            }\n+\n+            // check on \"condition-overlapping\" inequalities:\n+            // a != 2 AND a > 3 -> a > 3 (discard NotEquals)\n+            // a != 2 AND a >= 2 -> a > 2 (discard NotEquals plus update inequality)\n+            // a != 2 AND a > 1 -> nop (do nothing)\n+            //\n+            // a != 2 AND a < 3 -> nop\n+            // a != 2 AND a <= 2 -> a < 2\n+            // a != 2 AND a < 1 -> a < 1\n+            for (int i = 0; i < bcs.size(); i ++) {\n+                BinaryComparison bc = bcs.get(i);\n+\n+                if (bc instanceof LessThan || bc instanceof LessThanOrEqual) {\n+                    comp = bc.right().foldable() ? BinaryComparison.compare(neqVal, bc.right().fold()) : null;\n+                    if (comp != null) {\n+                        if (comp >= 0) {\n+                            if (comp == 0 && bc instanceof LessThanOrEqual) { // a != 2 AND a <= 2 -> a < 2\n+                                bcs.set(i, new LessThan(bc.source(), bc.left(), bc.right()));\n+                            } // else : comp > 0 (a != 2 AND a </<= 1 -> a </<= 1), or == 0 && bc i.of \"<\" (a != 2 AND a < 2 -> a < 2)\n+                            return true;\n+                        } // else: comp < 0 : a != 2 AND a </<= 3 -> nop\n+                    } // else: non-comparable, nop\n+                } else if (bc instanceof GreaterThan || bc instanceof GreaterThanOrEqual) {\n+                    comp = bc.right().foldable() ? BinaryComparison.compare(neqVal, bc.right().fold()) : null;\n+                    if (comp != null) {\n+                        if (comp <= 0) {\n+                            if (comp == 0 && bc instanceof GreaterThanOrEqual) { // a != 2 AND a >= 2 -> a > 2\n+                                bcs.set(i, new GreaterThan(bc.source(), bc.left(), bc.right()));\n+                            } // else: comp < 0 (a != 2 AND a >/>= 3 -> a >/>= 3), or == 0 && bc i.of \">\" (a != 2 AND a > 2 -> a > 2)\n+                            return true;\n+                        } // else: comp > 0 : a != 2 AND a >/>= 1 -> nop\n+                    } // else: non-comparable, nop\n+                } // else: other non-relevant type\n+            }\n+\n+            return false;\n+        }\n+\n+        // a != X OR Y < a < Z -> a != X (plus equivalent inequalities)\n+        // a != X OR X <= a < Z -> TRUE (plus equality on upper bound, plus equivalent inequalities)\n+        private static Boolean filterDisjunctionByNotEquals(List<NotEquals> notEquals, List<BinaryComparison> bcs, List<Range> ranges) {\n+            Boolean updated = false;\n+\n+            for (NotEquals neq : notEquals) {\n+                for (Iterator<BinaryComparison> bcIterator = bcs.iterator(); bcIterator.hasNext(); ) {\n+                    BinaryComparison bc = bcIterator.next();\n+                    if (neq.left().semanticEquals(bc.left())) {\n+                        if (bc instanceof LessThan || bc instanceof GreaterThan) { // a != 2 OR a < 3 -> a != 2 (plus LessThen)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg0MzEwNg=="}, "originalCommit": {"oid": "4b7fc42accf23af586c4bc780b3215db99619af2"}, "originalPosition": 274}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTIxODAyOA==", "bodyText": "@astefan has a good point. The optimizations for AND should be safe since either you pass all o them or none - thus there's no scoring.\nHowever with OR one result can match multiple queries hence why I would trim the optimizations to a minimum.\nWe could add awarness regarding scoring and thus enable some optimizations only when no scoring is needed however I think that adds additional complexity for unclear gains thus I would spend the effort somewhere else.", "url": "https://github.com/elastic/elasticsearch/pull/51088#discussion_r369218028", "createdAt": "2020-01-21T20:09:36Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -1643,6 +1671,137 @@ else if ((other instanceof LessThan || other instanceof LessThanOrEqual) &&\n \n             return false;\n         }\n+\n+        private static boolean notEqualsIsRemovableFromConjunction(NotEquals notEquals, List<Range> ranges, List<BinaryComparison> bcs) {\n+            Object neqVal = notEquals.right().fold();\n+            Integer comp;\n+\n+            // check on \"condition-overlapping\" ranges:\n+            // a != 2 AND 3 < a < 5 -> 3 < a < 5; a != 2 AND 0 < a < 1 -> 0 < a < 1 (discard NotEquals)\n+            // a != 2 AND 2 <= a < 3 -> 2 < a < 3; a != 3 AND 2 < a <= 3 -> 2 < a < 3 (discard NotEquals, plus update Range)\n+            // a != 2 AND 1 < a < 3 -> nop (do nothing)\n+            for (int i = 0; i < ranges.size(); i ++) {\n+                Range range = ranges.get(i);\n+\n+                if (notEquals.left().semanticEquals(range.value())) {\n+                    comp = range.lower().foldable() ? BinaryComparison.compare(neqVal, range.lower().fold()) : null;\n+                    if (comp != null) {\n+                        if (comp <= 0) {\n+                            if (comp == 0 && range.includeLower()) { // a != 2 AND 2 <= a < ? -> 2 < a < ?\n+                                ranges.set(i, new Range(range.source(), range.value(), range.lower(), false, range.upper(),\n+                                    range.includeUpper()));\n+                            }\n+                            // else: !.includeLower() : a != 2 AND 2 < a < 3 -> 2 < a < 3; or:\n+                            // else: comp < 0 : a != 2 AND 3 < a < ? ->  3 < a < ?\n+\n+                            return true;\n+                        } else { // comp > 0 : a != 4 AND 2 < a < ? : can only remove NotEquals if outside the range\n+                            comp = range.upper().foldable() ? BinaryComparison.compare(neqVal, range.upper().fold()) : null;\n+                            if (comp != null && comp >= 0) {\n+                                if (comp == 0 && range.includeUpper()) { // a != 4 AND 2 < a <= 4 -> 2 < a < 4\n+                                    ranges.set(i, new Range(range.source(), range.value(), range.lower(), range.includeLower(),\n+                                        range.upper(), false));\n+                                }\n+                                // else: !.includeUpper() : a != 4 AND 2 < a < 4 -> 2 < a < 4\n+                                // else: comp > 0 : a != 4 AND 2 < a < 3 -> 2 < a < 3\n+\n+                                return true;\n+                            }\n+                            // else: comp < 0 : a != 4 AND 2 < a < 5 -> nop; or:\n+                            // else: comp == null : upper bound not comparable -> nop\n+                        }\n+                    } // else: comp == null : lower bound not comparable: evaluate upper bound, in case non-equality value is \">=\"\n+\n+                    comp = range.upper().foldable() ? BinaryComparison.compare(neqVal, range.upper().fold()) : null;\n+                    if (comp != null && comp >= 0) {\n+                        if (comp == 0 && range.includeUpper()) { // a != 3 AND ?? < a <= 3 -> ?? < a < 3\n+                            ranges.set(i, new Range(range.source(), range.value(), range.lower(), range.includeLower(), range.upper(),\n+                                false));\n+                        }\n+                        // else: !.includeUpper() : a != 3 AND ?? < a < 3 -> ?? < a < 3\n+                        // else: comp > 0 : a != 3 and ?? < a < 2 -> ?? < a < 2\n+\n+                        return true;\n+                    }\n+                    // else: comp < 0 : a != 3 AND ?? < a < 4 -> nop, as a decision can't be drawn; or:\n+                    // else: comp == null : a != 3 AND ?? < a < ?? -> nop\n+                }\n+            }\n+\n+            // check on \"condition-overlapping\" inequalities:\n+            // a != 2 AND a > 3 -> a > 3 (discard NotEquals)\n+            // a != 2 AND a >= 2 -> a > 2 (discard NotEquals plus update inequality)\n+            // a != 2 AND a > 1 -> nop (do nothing)\n+            //\n+            // a != 2 AND a < 3 -> nop\n+            // a != 2 AND a <= 2 -> a < 2\n+            // a != 2 AND a < 1 -> a < 1\n+            for (int i = 0; i < bcs.size(); i ++) {\n+                BinaryComparison bc = bcs.get(i);\n+\n+                if (bc instanceof LessThan || bc instanceof LessThanOrEqual) {\n+                    comp = bc.right().foldable() ? BinaryComparison.compare(neqVal, bc.right().fold()) : null;\n+                    if (comp != null) {\n+                        if (comp >= 0) {\n+                            if (comp == 0 && bc instanceof LessThanOrEqual) { // a != 2 AND a <= 2 -> a < 2\n+                                bcs.set(i, new LessThan(bc.source(), bc.left(), bc.right()));\n+                            } // else : comp > 0 (a != 2 AND a </<= 1 -> a </<= 1), or == 0 && bc i.of \"<\" (a != 2 AND a < 2 -> a < 2)\n+                            return true;\n+                        } // else: comp < 0 : a != 2 AND a </<= 3 -> nop\n+                    } // else: non-comparable, nop\n+                } else if (bc instanceof GreaterThan || bc instanceof GreaterThanOrEqual) {\n+                    comp = bc.right().foldable() ? BinaryComparison.compare(neqVal, bc.right().fold()) : null;\n+                    if (comp != null) {\n+                        if (comp <= 0) {\n+                            if (comp == 0 && bc instanceof GreaterThanOrEqual) { // a != 2 AND a >= 2 -> a > 2\n+                                bcs.set(i, new GreaterThan(bc.source(), bc.left(), bc.right()));\n+                            } // else: comp < 0 (a != 2 AND a >/>= 3 -> a >/>= 3), or == 0 && bc i.of \">\" (a != 2 AND a > 2 -> a > 2)\n+                            return true;\n+                        } // else: comp > 0 : a != 2 AND a >/>= 1 -> nop\n+                    } // else: non-comparable, nop\n+                } // else: other non-relevant type\n+            }\n+\n+            return false;\n+        }\n+\n+        // a != X OR Y < a < Z -> a != X (plus equivalent inequalities)\n+        // a != X OR X <= a < Z -> TRUE (plus equality on upper bound, plus equivalent inequalities)\n+        private static Boolean filterDisjunctionByNotEquals(List<NotEquals> notEquals, List<BinaryComparison> bcs, List<Range> ranges) {\n+            Boolean updated = false;\n+\n+            for (NotEquals neq : notEquals) {\n+                for (Iterator<BinaryComparison> bcIterator = bcs.iterator(); bcIterator.hasNext(); ) {\n+                    BinaryComparison bc = bcIterator.next();\n+                    if (neq.left().semanticEquals(bc.left())) {\n+                        if (bc instanceof LessThan || bc instanceof GreaterThan) { // a != 2 OR a < 3 -> a != 2 (plus LessThen)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg0MzEwNg=="}, "originalCommit": {"oid": "4b7fc42accf23af586c4bc780b3215db99619af2"}, "originalPosition": 274}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTgzOTc0NQ==", "bodyText": "However with OR one result can match multiple queries hence why I would trim the optimizations to a minimum.\n\nSure, I'll then trim the extras.\n\nWe could add awarness regarding scoring and thus enable some optimizations only when no scoring is needed however I think that adds additional complexity for unclear gains thus I would spend the effort somewhere else.\n\nGot it. I guess machine-generated queries - maybe also BIs - can produce very verbose statements, but it's true that the optimisations can be an obscure ground and maybe not worth it if users tend to go for the scores as well.\nWould opening a ticket to track/remove existing optimisation be worth it?\n\n  \n    \n      elasticsearch/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java\n    \n    \n         Line 1367\n      in\n      9396e75\n    \n    \n    \n    \n\n        \n          \n           private Expression combine(Or or) { \n        \n    \n  \n\n\n\n  \n    \n      elasticsearch/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java\n    \n    \n         Line 1435\n      in\n      9396e75\n    \n    \n    \n    \n\n        \n          \n           // (1 < a < 3) OR (2 < a < 3) -> (1 < a < 3) \n        \n    \n  \n\n\npotentially others?", "url": "https://github.com/elastic/elasticsearch/pull/51088#discussion_r369839745", "createdAt": "2020-01-22T22:27:59Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -1643,6 +1671,137 @@ else if ((other instanceof LessThan || other instanceof LessThanOrEqual) &&\n \n             return false;\n         }\n+\n+        private static boolean notEqualsIsRemovableFromConjunction(NotEquals notEquals, List<Range> ranges, List<BinaryComparison> bcs) {\n+            Object neqVal = notEquals.right().fold();\n+            Integer comp;\n+\n+            // check on \"condition-overlapping\" ranges:\n+            // a != 2 AND 3 < a < 5 -> 3 < a < 5; a != 2 AND 0 < a < 1 -> 0 < a < 1 (discard NotEquals)\n+            // a != 2 AND 2 <= a < 3 -> 2 < a < 3; a != 3 AND 2 < a <= 3 -> 2 < a < 3 (discard NotEquals, plus update Range)\n+            // a != 2 AND 1 < a < 3 -> nop (do nothing)\n+            for (int i = 0; i < ranges.size(); i ++) {\n+                Range range = ranges.get(i);\n+\n+                if (notEquals.left().semanticEquals(range.value())) {\n+                    comp = range.lower().foldable() ? BinaryComparison.compare(neqVal, range.lower().fold()) : null;\n+                    if (comp != null) {\n+                        if (comp <= 0) {\n+                            if (comp == 0 && range.includeLower()) { // a != 2 AND 2 <= a < ? -> 2 < a < ?\n+                                ranges.set(i, new Range(range.source(), range.value(), range.lower(), false, range.upper(),\n+                                    range.includeUpper()));\n+                            }\n+                            // else: !.includeLower() : a != 2 AND 2 < a < 3 -> 2 < a < 3; or:\n+                            // else: comp < 0 : a != 2 AND 3 < a < ? ->  3 < a < ?\n+\n+                            return true;\n+                        } else { // comp > 0 : a != 4 AND 2 < a < ? : can only remove NotEquals if outside the range\n+                            comp = range.upper().foldable() ? BinaryComparison.compare(neqVal, range.upper().fold()) : null;\n+                            if (comp != null && comp >= 0) {\n+                                if (comp == 0 && range.includeUpper()) { // a != 4 AND 2 < a <= 4 -> 2 < a < 4\n+                                    ranges.set(i, new Range(range.source(), range.value(), range.lower(), range.includeLower(),\n+                                        range.upper(), false));\n+                                }\n+                                // else: !.includeUpper() : a != 4 AND 2 < a < 4 -> 2 < a < 4\n+                                // else: comp > 0 : a != 4 AND 2 < a < 3 -> 2 < a < 3\n+\n+                                return true;\n+                            }\n+                            // else: comp < 0 : a != 4 AND 2 < a < 5 -> nop; or:\n+                            // else: comp == null : upper bound not comparable -> nop\n+                        }\n+                    } // else: comp == null : lower bound not comparable: evaluate upper bound, in case non-equality value is \">=\"\n+\n+                    comp = range.upper().foldable() ? BinaryComparison.compare(neqVal, range.upper().fold()) : null;\n+                    if (comp != null && comp >= 0) {\n+                        if (comp == 0 && range.includeUpper()) { // a != 3 AND ?? < a <= 3 -> ?? < a < 3\n+                            ranges.set(i, new Range(range.source(), range.value(), range.lower(), range.includeLower(), range.upper(),\n+                                false));\n+                        }\n+                        // else: !.includeUpper() : a != 3 AND ?? < a < 3 -> ?? < a < 3\n+                        // else: comp > 0 : a != 3 and ?? < a < 2 -> ?? < a < 2\n+\n+                        return true;\n+                    }\n+                    // else: comp < 0 : a != 3 AND ?? < a < 4 -> nop, as a decision can't be drawn; or:\n+                    // else: comp == null : a != 3 AND ?? < a < ?? -> nop\n+                }\n+            }\n+\n+            // check on \"condition-overlapping\" inequalities:\n+            // a != 2 AND a > 3 -> a > 3 (discard NotEquals)\n+            // a != 2 AND a >= 2 -> a > 2 (discard NotEquals plus update inequality)\n+            // a != 2 AND a > 1 -> nop (do nothing)\n+            //\n+            // a != 2 AND a < 3 -> nop\n+            // a != 2 AND a <= 2 -> a < 2\n+            // a != 2 AND a < 1 -> a < 1\n+            for (int i = 0; i < bcs.size(); i ++) {\n+                BinaryComparison bc = bcs.get(i);\n+\n+                if (bc instanceof LessThan || bc instanceof LessThanOrEqual) {\n+                    comp = bc.right().foldable() ? BinaryComparison.compare(neqVal, bc.right().fold()) : null;\n+                    if (comp != null) {\n+                        if (comp >= 0) {\n+                            if (comp == 0 && bc instanceof LessThanOrEqual) { // a != 2 AND a <= 2 -> a < 2\n+                                bcs.set(i, new LessThan(bc.source(), bc.left(), bc.right()));\n+                            } // else : comp > 0 (a != 2 AND a </<= 1 -> a </<= 1), or == 0 && bc i.of \"<\" (a != 2 AND a < 2 -> a < 2)\n+                            return true;\n+                        } // else: comp < 0 : a != 2 AND a </<= 3 -> nop\n+                    } // else: non-comparable, nop\n+                } else if (bc instanceof GreaterThan || bc instanceof GreaterThanOrEqual) {\n+                    comp = bc.right().foldable() ? BinaryComparison.compare(neqVal, bc.right().fold()) : null;\n+                    if (comp != null) {\n+                        if (comp <= 0) {\n+                            if (comp == 0 && bc instanceof GreaterThanOrEqual) { // a != 2 AND a >= 2 -> a > 2\n+                                bcs.set(i, new GreaterThan(bc.source(), bc.left(), bc.right()));\n+                            } // else: comp < 0 (a != 2 AND a >/>= 3 -> a >/>= 3), or == 0 && bc i.of \">\" (a != 2 AND a > 2 -> a > 2)\n+                            return true;\n+                        } // else: comp > 0 : a != 2 AND a >/>= 1 -> nop\n+                    } // else: non-comparable, nop\n+                } // else: other non-relevant type\n+            }\n+\n+            return false;\n+        }\n+\n+        // a != X OR Y < a < Z -> a != X (plus equivalent inequalities)\n+        // a != X OR X <= a < Z -> TRUE (plus equality on upper bound, plus equivalent inequalities)\n+        private static Boolean filterDisjunctionByNotEquals(List<NotEquals> notEquals, List<BinaryComparison> bcs, List<Range> ranges) {\n+            Boolean updated = false;\n+\n+            for (NotEquals neq : notEquals) {\n+                for (Iterator<BinaryComparison> bcIterator = bcs.iterator(); bcIterator.hasNext(); ) {\n+                    BinaryComparison bc = bcIterator.next();\n+                    if (neq.left().semanticEquals(bc.left())) {\n+                        if (bc instanceof LessThan || bc instanceof GreaterThan) { // a != 2 OR a < 3 -> a != 2 (plus LessThen)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg0MzEwNg=="}, "originalCommit": {"oid": "4b7fc42accf23af586c4bc780b3215db99619af2"}, "originalPosition": 274}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDAzODgxMQ==", "bodyText": "Would opening a ticket to track/remove existing optimisation be worth it?\n\nPlease go ahead - it's better to have an issue that we close than forget about it because there's no issue.", "url": "https://github.com/elastic/elasticsearch/pull/51088#discussion_r370038811", "createdAt": "2020-01-23T10:27:57Z", "author": {"login": "costin"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -1643,6 +1671,137 @@ else if ((other instanceof LessThan || other instanceof LessThanOrEqual) &&\n \n             return false;\n         }\n+\n+        private static boolean notEqualsIsRemovableFromConjunction(NotEquals notEquals, List<Range> ranges, List<BinaryComparison> bcs) {\n+            Object neqVal = notEquals.right().fold();\n+            Integer comp;\n+\n+            // check on \"condition-overlapping\" ranges:\n+            // a != 2 AND 3 < a < 5 -> 3 < a < 5; a != 2 AND 0 < a < 1 -> 0 < a < 1 (discard NotEquals)\n+            // a != 2 AND 2 <= a < 3 -> 2 < a < 3; a != 3 AND 2 < a <= 3 -> 2 < a < 3 (discard NotEquals, plus update Range)\n+            // a != 2 AND 1 < a < 3 -> nop (do nothing)\n+            for (int i = 0; i < ranges.size(); i ++) {\n+                Range range = ranges.get(i);\n+\n+                if (notEquals.left().semanticEquals(range.value())) {\n+                    comp = range.lower().foldable() ? BinaryComparison.compare(neqVal, range.lower().fold()) : null;\n+                    if (comp != null) {\n+                        if (comp <= 0) {\n+                            if (comp == 0 && range.includeLower()) { // a != 2 AND 2 <= a < ? -> 2 < a < ?\n+                                ranges.set(i, new Range(range.source(), range.value(), range.lower(), false, range.upper(),\n+                                    range.includeUpper()));\n+                            }\n+                            // else: !.includeLower() : a != 2 AND 2 < a < 3 -> 2 < a < 3; or:\n+                            // else: comp < 0 : a != 2 AND 3 < a < ? ->  3 < a < ?\n+\n+                            return true;\n+                        } else { // comp > 0 : a != 4 AND 2 < a < ? : can only remove NotEquals if outside the range\n+                            comp = range.upper().foldable() ? BinaryComparison.compare(neqVal, range.upper().fold()) : null;\n+                            if (comp != null && comp >= 0) {\n+                                if (comp == 0 && range.includeUpper()) { // a != 4 AND 2 < a <= 4 -> 2 < a < 4\n+                                    ranges.set(i, new Range(range.source(), range.value(), range.lower(), range.includeLower(),\n+                                        range.upper(), false));\n+                                }\n+                                // else: !.includeUpper() : a != 4 AND 2 < a < 4 -> 2 < a < 4\n+                                // else: comp > 0 : a != 4 AND 2 < a < 3 -> 2 < a < 3\n+\n+                                return true;\n+                            }\n+                            // else: comp < 0 : a != 4 AND 2 < a < 5 -> nop; or:\n+                            // else: comp == null : upper bound not comparable -> nop\n+                        }\n+                    } // else: comp == null : lower bound not comparable: evaluate upper bound, in case non-equality value is \">=\"\n+\n+                    comp = range.upper().foldable() ? BinaryComparison.compare(neqVal, range.upper().fold()) : null;\n+                    if (comp != null && comp >= 0) {\n+                        if (comp == 0 && range.includeUpper()) { // a != 3 AND ?? < a <= 3 -> ?? < a < 3\n+                            ranges.set(i, new Range(range.source(), range.value(), range.lower(), range.includeLower(), range.upper(),\n+                                false));\n+                        }\n+                        // else: !.includeUpper() : a != 3 AND ?? < a < 3 -> ?? < a < 3\n+                        // else: comp > 0 : a != 3 and ?? < a < 2 -> ?? < a < 2\n+\n+                        return true;\n+                    }\n+                    // else: comp < 0 : a != 3 AND ?? < a < 4 -> nop, as a decision can't be drawn; or:\n+                    // else: comp == null : a != 3 AND ?? < a < ?? -> nop\n+                }\n+            }\n+\n+            // check on \"condition-overlapping\" inequalities:\n+            // a != 2 AND a > 3 -> a > 3 (discard NotEquals)\n+            // a != 2 AND a >= 2 -> a > 2 (discard NotEquals plus update inequality)\n+            // a != 2 AND a > 1 -> nop (do nothing)\n+            //\n+            // a != 2 AND a < 3 -> nop\n+            // a != 2 AND a <= 2 -> a < 2\n+            // a != 2 AND a < 1 -> a < 1\n+            for (int i = 0; i < bcs.size(); i ++) {\n+                BinaryComparison bc = bcs.get(i);\n+\n+                if (bc instanceof LessThan || bc instanceof LessThanOrEqual) {\n+                    comp = bc.right().foldable() ? BinaryComparison.compare(neqVal, bc.right().fold()) : null;\n+                    if (comp != null) {\n+                        if (comp >= 0) {\n+                            if (comp == 0 && bc instanceof LessThanOrEqual) { // a != 2 AND a <= 2 -> a < 2\n+                                bcs.set(i, new LessThan(bc.source(), bc.left(), bc.right()));\n+                            } // else : comp > 0 (a != 2 AND a </<= 1 -> a </<= 1), or == 0 && bc i.of \"<\" (a != 2 AND a < 2 -> a < 2)\n+                            return true;\n+                        } // else: comp < 0 : a != 2 AND a </<= 3 -> nop\n+                    } // else: non-comparable, nop\n+                } else if (bc instanceof GreaterThan || bc instanceof GreaterThanOrEqual) {\n+                    comp = bc.right().foldable() ? BinaryComparison.compare(neqVal, bc.right().fold()) : null;\n+                    if (comp != null) {\n+                        if (comp <= 0) {\n+                            if (comp == 0 && bc instanceof GreaterThanOrEqual) { // a != 2 AND a >= 2 -> a > 2\n+                                bcs.set(i, new GreaterThan(bc.source(), bc.left(), bc.right()));\n+                            } // else: comp < 0 (a != 2 AND a >/>= 3 -> a >/>= 3), or == 0 && bc i.of \">\" (a != 2 AND a > 2 -> a > 2)\n+                            return true;\n+                        } // else: comp > 0 : a != 2 AND a >/>= 1 -> nop\n+                    } // else: non-comparable, nop\n+                } // else: other non-relevant type\n+            }\n+\n+            return false;\n+        }\n+\n+        // a != X OR Y < a < Z -> a != X (plus equivalent inequalities)\n+        // a != X OR X <= a < Z -> TRUE (plus equality on upper bound, plus equivalent inequalities)\n+        private static Boolean filterDisjunctionByNotEquals(List<NotEquals> notEquals, List<BinaryComparison> bcs, List<Range> ranges) {\n+            Boolean updated = false;\n+\n+            for (NotEquals neq : notEquals) {\n+                for (Iterator<BinaryComparison> bcIterator = bcs.iterator(); bcIterator.hasNext(); ) {\n+                    BinaryComparison bc = bcIterator.next();\n+                    if (neq.left().semanticEquals(bc.left())) {\n+                        if (bc instanceof LessThan || bc instanceof GreaterThan) { // a != 2 OR a < 3 -> a != 2 (plus LessThen)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg0MzEwNg=="}, "originalCommit": {"oid": "4b7fc42accf23af586c4bc780b3215db99619af2"}, "originalPosition": 274}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMjEwNzk3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/optimizer/OptimizerTests.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMTo1NjozMFrOFjF3iA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxNzozMDo1OFrOFjzlrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM0MDYxNg==", "bodyText": "Wouldn't here be more correct to also assert that the expression resulted from applying the rule is the same And as before? Meaning, is it enough to assume the type of the expression is And?", "url": "https://github.com/elastic/elasticsearch/pull/51088#discussion_r372340616", "createdAt": "2020-01-29T11:56:30Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/optimizer/OptimizerTests.java", "diffHunk": "@@ -1241,6 +1267,173 @@ public void testRangesOverlappingConjunctionNoLowerBoundary() {\n         assertEquals(r1, exp);\n     }\n \n+    // a != 2 AND 3 < a < 5 -> 3 < a < 5\n+    public void testCombineBinaryComparisonsConjunction_Neq2AndRangeGt3Lt5() {\n+        FieldAttribute fa = getFieldAttribute();\n+\n+        NotEquals neq = new NotEquals(EMPTY, fa, TWO);\n+        Range range = new Range(EMPTY, fa, THREE, false, FIVE, false);\n+        And and = new And(EMPTY, range, neq);\n+\n+        CombineBinaryComparisons rule = new CombineBinaryComparisons();\n+        Expression exp = rule.rule(and);\n+        assertEquals(Range.class, exp.getClass());\n+        Range r = (Range) exp;\n+        assertEquals(THREE, r.lower());\n+        assertFalse(r.includeLower());\n+        assertEquals(FIVE, r.upper());\n+        assertFalse(r.includeUpper());\n+    }\n+\n+    // a != 2 AND 0 < a < 1 -> 0 < a < 1\n+    public void testCombineBinaryComparisonsConjunction_Neq2AndRangeGt0Lt1() {\n+        FieldAttribute fa = getFieldAttribute();\n+\n+        NotEquals neq = new NotEquals(EMPTY, fa, TWO);\n+        Range range = new Range(EMPTY, fa, L(0), false, ONE, false);\n+        And and = new And(EMPTY, neq, range);\n+\n+        CombineBinaryComparisons rule = new CombineBinaryComparisons();\n+        Expression exp = rule.rule(and);\n+        assertEquals(Range.class, exp.getClass());\n+        Range r = (Range) exp;\n+        assertEquals(L(0), r.lower());\n+        assertFalse(r.includeLower());\n+        assertEquals(ONE, r.upper());\n+        assertFalse(r.includeUpper());\n+    }\n+\n+    // a != 2 AND 2 <= a < 3 -> 2 < a < 3\n+    public void testCombineBinaryComparisonsConjunction_Neq2AndRangeGte2Lt3() {\n+        FieldAttribute fa = getFieldAttribute();\n+\n+        NotEquals neq = new NotEquals(EMPTY, fa, TWO);\n+        Range range = new Range(EMPTY, fa, TWO, true, THREE, false);\n+        And and = new And(EMPTY, neq, range);\n+\n+        CombineBinaryComparisons rule = new CombineBinaryComparisons();\n+        Expression exp = rule.rule(and);\n+        assertEquals(Range.class, exp.getClass());\n+        Range r = (Range) exp;\n+        assertEquals(TWO, r.lower());\n+        assertFalse(r.includeLower());\n+        assertEquals(THREE, r.upper());\n+        assertFalse(r.includeUpper());\n+    }\n+\n+    // a != 3 AND 2 < a <= 3 -> 2 < a < 3\n+    public void testCombineBinaryComparisonsConjunction_Neq3AndRangeGt2Lte3() {\n+        FieldAttribute fa = getFieldAttribute();\n+\n+        NotEquals neq = new NotEquals(EMPTY, fa, THREE);\n+        Range range = new Range(EMPTY, fa, TWO, false, THREE, true);\n+        And and = new And(EMPTY, neq, range);\n+\n+        CombineBinaryComparisons rule = new CombineBinaryComparisons();\n+        Expression exp = rule.rule(and);\n+        assertEquals(Range.class, exp.getClass());\n+        Range r = (Range) exp;\n+        assertEquals(TWO, r.lower());\n+        assertFalse(r.includeLower());\n+        assertEquals(THREE, r.upper());\n+        assertFalse(r.includeUpper());\n+    }\n+\n+    // a != 2 AND 1 < a < 3\n+    public void testCombineBinaryComparisonsConjunction_Neq2AndRangeGt1Lt3() {\n+        FieldAttribute fa = getFieldAttribute();\n+\n+        NotEquals neq = new NotEquals(EMPTY, fa, TWO);\n+        Range range = new Range(EMPTY, fa, ONE, false, THREE, false);\n+        And and = new And(EMPTY, neq, range);\n+\n+        CombineBinaryComparisons rule = new CombineBinaryComparisons();\n+        Expression exp = rule.rule(and);\n+        assertEquals(And.class, exp.getClass()); // can't optimize\n+    }\n+\n+    // a != 2 AND a > 3 -> a > 3\n+    public void testCombineBinaryComparisonsConjunction_Neq2AndGt3() {\n+        FieldAttribute fa = getFieldAttribute();\n+\n+        NotEquals neq = new NotEquals(EMPTY, fa, TWO);\n+        GreaterThan gt = new GreaterThan(EMPTY, fa, THREE);\n+        And and = new And(EMPTY, neq, gt);\n+\n+        CombineBinaryComparisons rule = new CombineBinaryComparisons();\n+        Expression exp = rule.rule(and);\n+        assertEquals(gt, exp);\n+    }\n+\n+    // a != 2 AND a >= 2 -> a > 2\n+    public void testCombineBinaryComparisonsConjunction_Neq2AndGte2() {\n+        FieldAttribute fa = getFieldAttribute();\n+\n+        NotEquals neq = new NotEquals(EMPTY, fa, TWO);\n+        GreaterThanOrEqual gte = new GreaterThanOrEqual(EMPTY, fa, TWO);\n+        And and = new And(EMPTY, neq, gte);\n+\n+        CombineBinaryComparisons rule = new CombineBinaryComparisons();\n+        Expression exp = rule.rule(and);\n+        assertEquals(GreaterThan.class, exp.getClass());\n+        GreaterThan gt = (GreaterThan) exp;\n+        assertEquals(TWO, gt.right());\n+    }\n+\n+    // a != 2 AND a >= 1 -> nop\n+    public void testCombineBinaryComparisonsConjunction_Neq2AndGte1() {\n+        FieldAttribute fa = getFieldAttribute();\n+\n+        NotEquals neq = new NotEquals(EMPTY, fa, TWO);\n+        GreaterThanOrEqual gte = new GreaterThanOrEqual(EMPTY, fa, ONE);\n+        And and = new And(EMPTY, neq, gte);\n+\n+        CombineBinaryComparisons rule = new CombineBinaryComparisons();\n+        Expression exp = rule.rule(and);\n+        assertEquals(And.class, exp.getClass()); // can't optimize\n+    }\n+\n+    // a != 2 AND a <= 3 -> nop\n+    public void testCombineBinaryComparisonsConjunction_Neq2AndLte3() {\n+        FieldAttribute fa = getFieldAttribute();\n+\n+        NotEquals neq = new NotEquals(EMPTY, fa, TWO);\n+        LessThanOrEqual lte = new LessThanOrEqual(EMPTY, fa, THREE);\n+        And and = new And(EMPTY, neq, lte);\n+\n+        CombineBinaryComparisons rule = new CombineBinaryComparisons();\n+        Expression exp = rule.rule(and);\n+        assertEquals(And.class, exp.getClass()); // can't optimize", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4bb889909ba5c9616ea68940a5de364bfddc3f9e"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzA4OTcwOA==", "bodyText": "That'd be a stricter check than necessary: if the evaluation would build another And instance, the test would still be correct.\nOtoh, given the implementation, it's safe to assume that it should be the same And instance, so I've taken on your suggestion.", "url": "https://github.com/elastic/elasticsearch/pull/51088#discussion_r373089708", "createdAt": "2020-01-30T17:30:58Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/optimizer/OptimizerTests.java", "diffHunk": "@@ -1241,6 +1267,173 @@ public void testRangesOverlappingConjunctionNoLowerBoundary() {\n         assertEquals(r1, exp);\n     }\n \n+    // a != 2 AND 3 < a < 5 -> 3 < a < 5\n+    public void testCombineBinaryComparisonsConjunction_Neq2AndRangeGt3Lt5() {\n+        FieldAttribute fa = getFieldAttribute();\n+\n+        NotEquals neq = new NotEquals(EMPTY, fa, TWO);\n+        Range range = new Range(EMPTY, fa, THREE, false, FIVE, false);\n+        And and = new And(EMPTY, range, neq);\n+\n+        CombineBinaryComparisons rule = new CombineBinaryComparisons();\n+        Expression exp = rule.rule(and);\n+        assertEquals(Range.class, exp.getClass());\n+        Range r = (Range) exp;\n+        assertEquals(THREE, r.lower());\n+        assertFalse(r.includeLower());\n+        assertEquals(FIVE, r.upper());\n+        assertFalse(r.includeUpper());\n+    }\n+\n+    // a != 2 AND 0 < a < 1 -> 0 < a < 1\n+    public void testCombineBinaryComparisonsConjunction_Neq2AndRangeGt0Lt1() {\n+        FieldAttribute fa = getFieldAttribute();\n+\n+        NotEquals neq = new NotEquals(EMPTY, fa, TWO);\n+        Range range = new Range(EMPTY, fa, L(0), false, ONE, false);\n+        And and = new And(EMPTY, neq, range);\n+\n+        CombineBinaryComparisons rule = new CombineBinaryComparisons();\n+        Expression exp = rule.rule(and);\n+        assertEquals(Range.class, exp.getClass());\n+        Range r = (Range) exp;\n+        assertEquals(L(0), r.lower());\n+        assertFalse(r.includeLower());\n+        assertEquals(ONE, r.upper());\n+        assertFalse(r.includeUpper());\n+    }\n+\n+    // a != 2 AND 2 <= a < 3 -> 2 < a < 3\n+    public void testCombineBinaryComparisonsConjunction_Neq2AndRangeGte2Lt3() {\n+        FieldAttribute fa = getFieldAttribute();\n+\n+        NotEquals neq = new NotEquals(EMPTY, fa, TWO);\n+        Range range = new Range(EMPTY, fa, TWO, true, THREE, false);\n+        And and = new And(EMPTY, neq, range);\n+\n+        CombineBinaryComparisons rule = new CombineBinaryComparisons();\n+        Expression exp = rule.rule(and);\n+        assertEquals(Range.class, exp.getClass());\n+        Range r = (Range) exp;\n+        assertEquals(TWO, r.lower());\n+        assertFalse(r.includeLower());\n+        assertEquals(THREE, r.upper());\n+        assertFalse(r.includeUpper());\n+    }\n+\n+    // a != 3 AND 2 < a <= 3 -> 2 < a < 3\n+    public void testCombineBinaryComparisonsConjunction_Neq3AndRangeGt2Lte3() {\n+        FieldAttribute fa = getFieldAttribute();\n+\n+        NotEquals neq = new NotEquals(EMPTY, fa, THREE);\n+        Range range = new Range(EMPTY, fa, TWO, false, THREE, true);\n+        And and = new And(EMPTY, neq, range);\n+\n+        CombineBinaryComparisons rule = new CombineBinaryComparisons();\n+        Expression exp = rule.rule(and);\n+        assertEquals(Range.class, exp.getClass());\n+        Range r = (Range) exp;\n+        assertEquals(TWO, r.lower());\n+        assertFalse(r.includeLower());\n+        assertEquals(THREE, r.upper());\n+        assertFalse(r.includeUpper());\n+    }\n+\n+    // a != 2 AND 1 < a < 3\n+    public void testCombineBinaryComparisonsConjunction_Neq2AndRangeGt1Lt3() {\n+        FieldAttribute fa = getFieldAttribute();\n+\n+        NotEquals neq = new NotEquals(EMPTY, fa, TWO);\n+        Range range = new Range(EMPTY, fa, ONE, false, THREE, false);\n+        And and = new And(EMPTY, neq, range);\n+\n+        CombineBinaryComparisons rule = new CombineBinaryComparisons();\n+        Expression exp = rule.rule(and);\n+        assertEquals(And.class, exp.getClass()); // can't optimize\n+    }\n+\n+    // a != 2 AND a > 3 -> a > 3\n+    public void testCombineBinaryComparisonsConjunction_Neq2AndGt3() {\n+        FieldAttribute fa = getFieldAttribute();\n+\n+        NotEquals neq = new NotEquals(EMPTY, fa, TWO);\n+        GreaterThan gt = new GreaterThan(EMPTY, fa, THREE);\n+        And and = new And(EMPTY, neq, gt);\n+\n+        CombineBinaryComparisons rule = new CombineBinaryComparisons();\n+        Expression exp = rule.rule(and);\n+        assertEquals(gt, exp);\n+    }\n+\n+    // a != 2 AND a >= 2 -> a > 2\n+    public void testCombineBinaryComparisonsConjunction_Neq2AndGte2() {\n+        FieldAttribute fa = getFieldAttribute();\n+\n+        NotEquals neq = new NotEquals(EMPTY, fa, TWO);\n+        GreaterThanOrEqual gte = new GreaterThanOrEqual(EMPTY, fa, TWO);\n+        And and = new And(EMPTY, neq, gte);\n+\n+        CombineBinaryComparisons rule = new CombineBinaryComparisons();\n+        Expression exp = rule.rule(and);\n+        assertEquals(GreaterThan.class, exp.getClass());\n+        GreaterThan gt = (GreaterThan) exp;\n+        assertEquals(TWO, gt.right());\n+    }\n+\n+    // a != 2 AND a >= 1 -> nop\n+    public void testCombineBinaryComparisonsConjunction_Neq2AndGte1() {\n+        FieldAttribute fa = getFieldAttribute();\n+\n+        NotEquals neq = new NotEquals(EMPTY, fa, TWO);\n+        GreaterThanOrEqual gte = new GreaterThanOrEqual(EMPTY, fa, ONE);\n+        And and = new And(EMPTY, neq, gte);\n+\n+        CombineBinaryComparisons rule = new CombineBinaryComparisons();\n+        Expression exp = rule.rule(and);\n+        assertEquals(And.class, exp.getClass()); // can't optimize\n+    }\n+\n+    // a != 2 AND a <= 3 -> nop\n+    public void testCombineBinaryComparisonsConjunction_Neq2AndLte3() {\n+        FieldAttribute fa = getFieldAttribute();\n+\n+        NotEquals neq = new NotEquals(EMPTY, fa, TWO);\n+        LessThanOrEqual lte = new LessThanOrEqual(EMPTY, fa, THREE);\n+        And and = new And(EMPTY, neq, lte);\n+\n+        CombineBinaryComparisons rule = new CombineBinaryComparisons();\n+        Expression exp = rule.rule(and);\n+        assertEquals(And.class, exp.getClass()); // can't optimize", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM0MDYxNg=="}, "originalCommit": {"oid": "4bb889909ba5c9616ea68940a5de364bfddc3f9e"}, "originalPosition": 173}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4633, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}