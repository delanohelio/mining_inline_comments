{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYzNjc3NTM3", "number": 51104, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNzowMDo1N1rODYk2QA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNzowMjowOVrODYk3mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MDk2MTI4OnYy", "diffSide": "RIGHT", "path": "modules/ingest-common/src/main/java/org/elasticsearch/ingest/common/ForEachProcessor.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNzowMDo1N1rOFegx9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QyMDoxODo0MVrOFfEM6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUzODY3OQ==", "bodyText": "I like this approach. In the case of inner processor going async; whichever thread sets this atomic boolean last should continue with the next value.\nAnd in the case inner processor doesn't go async then on the second getAndSet(...) the current thread continues with the next value.\nI do wonder if this variable can be renamed to describe this beter.", "url": "https://github.com/elastic/elasticsearch/pull/51104#discussion_r367538679", "createdAt": "2020-01-16T17:00:57Z", "author": {"login": "martijnvg"}, "path": "modules/ingest-common/src/main/java/org/elasticsearch/ingest/common/ForEachProcessor.java", "diffHunk": "@@ -79,41 +76,35 @@ public void execute(IngestDocument ingestDocument, BiConsumer<IngestDocument, Ex\n                 handler.accept(null, new IllegalArgumentException(\"field [\" + field + \"] is null, cannot loop over its elements.\"));\n             }\n         } else {\n-            List<Object> newValues = new CopyOnWriteArrayList<>();\n-            innerExecute(0, values, newValues, ingestDocument, handler);\n+            innerExecute(0, values, Collections.synchronizedList(new ArrayList<>(values.size())), ingestDocument, handler);\n         }\n     }\n \n     void innerExecute(int index, List<?> values, List<Object> newValues, IngestDocument document,\n                       BiConsumer<IngestDocument, Exception> handler) {\n+        for (; index < values.size(); index++) {\n+            AtomicBoolean shouldContinueHere = new AtomicBoolean();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d9276d5a4dd868fefa90a071f572920c3cf4535"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg1MDIzMQ==", "bodyText": "I wonder about this scenario:\n\nThe current thread sets shouldContinueHere first.\nNext value is handled  and also manages to set shouldContinueHere first.\nBoth async call manage to return and update newValues simultaneously.\n\nIs this scenario possible? And if so should have protection against this?", "url": "https://github.com/elastic/elasticsearch/pull/51104#discussion_r367850231", "createdAt": "2020-01-17T09:50:29Z", "author": {"login": "martijnvg"}, "path": "modules/ingest-common/src/main/java/org/elasticsearch/ingest/common/ForEachProcessor.java", "diffHunk": "@@ -79,41 +76,35 @@ public void execute(IngestDocument ingestDocument, BiConsumer<IngestDocument, Ex\n                 handler.accept(null, new IllegalArgumentException(\"field [\" + field + \"] is null, cannot loop over its elements.\"));\n             }\n         } else {\n-            List<Object> newValues = new CopyOnWriteArrayList<>();\n-            innerExecute(0, values, newValues, ingestDocument, handler);\n+            innerExecute(0, values, Collections.synchronizedList(new ArrayList<>(values.size())), ingestDocument, handler);\n         }\n     }\n \n     void innerExecute(int index, List<?> values, List<Object> newValues, IngestDocument document,\n                       BiConsumer<IngestDocument, Exception> handler) {\n+        for (; index < values.size(); index++) {\n+            AtomicBoolean shouldContinueHere = new AtomicBoolean();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUzODY3OQ=="}, "originalCommit": {"oid": "0d9276d5a4dd868fefa90a071f572920c3cf4535"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA4MjM3Nw==", "bodyText": "If current thread hits shouldContinueHere first, then it sees false and ends the loop (returns).\nIf it hits it second that means it's after async call already finished and other thread updated newValues already.\nAs you mentioned in first comment only thread that checks shouldContinueHere last actually proceeds\nDoes it answer your question or did I misunderstand the scenario?", "url": "https://github.com/elastic/elasticsearch/pull/51104#discussion_r368082377", "createdAt": "2020-01-17T18:47:15Z", "author": {"login": "probakowski"}, "path": "modules/ingest-common/src/main/java/org/elasticsearch/ingest/common/ForEachProcessor.java", "diffHunk": "@@ -79,41 +76,35 @@ public void execute(IngestDocument ingestDocument, BiConsumer<IngestDocument, Ex\n                 handler.accept(null, new IllegalArgumentException(\"field [\" + field + \"] is null, cannot loop over its elements.\"));\n             }\n         } else {\n-            List<Object> newValues = new CopyOnWriteArrayList<>();\n-            innerExecute(0, values, newValues, ingestDocument, handler);\n+            innerExecute(0, values, Collections.synchronizedList(new ArrayList<>(values.size())), ingestDocument, handler);\n         }\n     }\n \n     void innerExecute(int index, List<?> values, List<Object> newValues, IngestDocument document,\n                       BiConsumer<IngestDocument, Exception> handler) {\n+        for (; index < values.size(); index++) {\n+            AtomicBoolean shouldContinueHere = new AtomicBoolean();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUzODY3OQ=="}, "originalCommit": {"oid": "0d9276d5a4dd868fefa90a071f572920c3cf4535"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODExOTAxOA==", "bodyText": "Thanks for clarifying. I misinterpreted the if statement on line 98 when looking at it this morning.\nIt is not possible that multiple values from the list are handled concurrently.", "url": "https://github.com/elastic/elasticsearch/pull/51104#discussion_r368119018", "createdAt": "2020-01-17T20:18:41Z", "author": {"login": "martijnvg"}, "path": "modules/ingest-common/src/main/java/org/elasticsearch/ingest/common/ForEachProcessor.java", "diffHunk": "@@ -79,41 +76,35 @@ public void execute(IngestDocument ingestDocument, BiConsumer<IngestDocument, Ex\n                 handler.accept(null, new IllegalArgumentException(\"field [\" + field + \"] is null, cannot loop over its elements.\"));\n             }\n         } else {\n-            List<Object> newValues = new CopyOnWriteArrayList<>();\n-            innerExecute(0, values, newValues, ingestDocument, handler);\n+            innerExecute(0, values, Collections.synchronizedList(new ArrayList<>(values.size())), ingestDocument, handler);\n         }\n     }\n \n     void innerExecute(int index, List<?> values, List<Object> newValues, IngestDocument document,\n                       BiConsumer<IngestDocument, Exception> handler) {\n+        for (; index < values.size(); index++) {\n+            AtomicBoolean shouldContinueHere = new AtomicBoolean();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUzODY3OQ=="}, "originalCommit": {"oid": "0d9276d5a4dd868fefa90a071f572920c3cf4535"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MDk2NDc0OnYy", "diffSide": "RIGHT", "path": "modules/ingest-common/src/main/java/org/elasticsearch/ingest/common/ForEachProcessor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNzowMjowOVrOFeg0Pw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNzowMjowOVrOFeg0Pw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUzOTI2Mw==", "bodyText": "In this case recursion does happen, but we're not risking a SO here, because it always a different thread would get here.", "url": "https://github.com/elastic/elasticsearch/pull/51104#discussion_r367539263", "createdAt": "2020-01-16T17:02:09Z", "author": {"login": "martijnvg"}, "path": "modules/ingest-common/src/main/java/org/elasticsearch/ingest/common/ForEachProcessor.java", "diffHunk": "@@ -79,41 +76,35 @@ public void execute(IngestDocument ingestDocument, BiConsumer<IngestDocument, Ex\n                 handler.accept(null, new IllegalArgumentException(\"field [\" + field + \"] is null, cannot loop over its elements.\"));\n             }\n         } else {\n-            List<Object> newValues = new CopyOnWriteArrayList<>();\n-            innerExecute(0, values, newValues, ingestDocument, handler);\n+            innerExecute(0, values, Collections.synchronizedList(new ArrayList<>(values.size())), ingestDocument, handler);\n         }\n     }\n \n     void innerExecute(int index, List<?> values, List<Object> newValues, IngestDocument document,\n                       BiConsumer<IngestDocument, Exception> handler) {\n+        for (; index < values.size(); index++) {\n+            AtomicBoolean shouldContinueHere = new AtomicBoolean();\n+            Object value = values.get(index);\n+            Object previousValue = document.getIngestMetadata().put(\"_value\", value);\n+            int nextIndex = index + 1;\n+            processor.execute(document, (result, e) -> {\n+                newValues.add(document.getIngestMetadata().put(\"_value\", previousValue));\n+                if (e != null || result == null) {\n+                    handler.accept(result, e);\n+                } else if (shouldContinueHere.getAndSet(true)) {\n+                    innerExecute(nextIndex, values, newValues, document, handler);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d9276d5a4dd868fefa90a071f572920c3cf4535"}, "originalPosition": 58}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4480, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}