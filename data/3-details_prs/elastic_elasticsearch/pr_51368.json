{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY2NTExMzIw", "number": 51368, "title": "[Transform] avoid mapping problems with index templates", "bodyText": "insert explict mappings for objects in nested output to avoid clashes with index templates\nfixes #51321", "createdAt": "2020-01-23T18:50:34Z", "url": "https://github.com/elastic/elasticsearch/pull/51368", "merged": true, "mergeCommit": {"oid": "4d11e1ad245e7a322fedd6052111eeb5b4831ce3"}, "closed": true, "closedAt": "2020-01-28T08:12:11Z", "author": {"login": "hendrikmuhs"}, "timelineItems": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb9MraHgH2gAyMzY2NTExMzIwOjU0ZWNiMWZmMmY3OWE4OTJhNDUwYmEzYThkZmIwYTA1MTczODIyNTc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb-eCQZgFqTM0ODcwOTcyOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "54ecb1ff2f79a892a450ba3a8dfb0a0517382257", "author": {"user": {"login": "hendrikmuhs", "name": "Hendrik Muhs"}}, "url": "https://github.com/elastic/elasticsearch/commit/54ecb1ff2f79a892a450ba3a8dfb0a0517382257", "committedDate": "2020-01-23T16:10:35Z", "message": "insert explict mappings for objects in nested output to avoid clashes with\nindex templates\n\nfixes #51321"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d657711a74353466507f767eae17ab633a24a621", "author": {"user": {"login": "hendrikmuhs", "name": "Hendrik Muhs"}}, "url": "https://github.com/elastic/elasticsearch/commit/d657711a74353466507f767eae17ab633a24a621", "committedDate": "2020-01-23T18:37:45Z", "message": "add unit test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3NTI4NDky", "url": "https://github.com/elastic/elasticsearch/pull/51368#pullrequestreview-347528492", "createdAt": "2020-01-23T18:51:18Z", "commit": {"oid": "d657711a74353466507f767eae17ab633a24a621"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxODo1MToxOFrOFhI8Ug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxODo1MToxOFrOFhI8Ug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI5Mzg0Mg==", "bodyText": "essential change in this file, called on line 176", "url": "https://github.com/elastic/elasticsearch/pull/51368#discussion_r370293842", "createdAt": "2020-01-23T18:51:18Z", "author": {"login": "hendrikmuhs"}, "path": "x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/pivot/SchemaUtil.java", "diffHunk": "@@ -165,34 +171,75 @@ public static void getDestinationFieldMappings(final Client client,\n                 targetMapping.put(targetFieldName, \"keyword\");\n             }\n         });\n+\n+        // insert object mappings for nested fields\n+        insertNestedObjectMappings(targetMapping);\n+\n         return targetMapping;\n     }\n \n     /*\n      * Very \"magic\" helper method to extract the source mappings\n      */\n-    private static void getSourceFieldMappings(Client client, String[] index, String[] fields,\n-                                               ActionListener<Map<String, String>> listener) {\n-        FieldCapabilitiesRequest fieldCapabilitiesRequest = new FieldCapabilitiesRequest()\n-            .indices(index)\n+    private static void getSourceFieldMappings(\n+        Client client,\n+        String[] index,\n+        String[] fields,\n+        ActionListener<Map<String, String>> listener\n+    ) {\n+        FieldCapabilitiesRequest fieldCapabilitiesRequest = new FieldCapabilitiesRequest().indices(index)\n             .fields(fields)\n             .indicesOptions(IndicesOptions.LENIENT_EXPAND_OPEN);\n-        client.execute(FieldCapabilitiesAction.INSTANCE, fieldCapabilitiesRequest, ActionListener.wrap(\n-            response -> listener.onResponse(extractFieldMappings(response)),\n-            listener::onFailure));\n+        client.execute(\n+            FieldCapabilitiesAction.INSTANCE,\n+            fieldCapabilitiesRequest,\n+            ActionListener.wrap(response -> listener.onResponse(extractFieldMappings(response)), listener::onFailure)\n+        );\n     }\n \n     private static Map<String, String> extractFieldMappings(FieldCapabilitiesResponse response) {\n         Map<String, String> extractedTypes = new HashMap<>();\n \n-        response.get().forEach((fieldName, capabilitiesMap) -> {\n-            // TODO: overwrites types, requires resolve if\n-            // types are mixed\n-            capabilitiesMap.forEach((name, capability) -> {\n-                logger.trace(\"Extracted type for [{}] : [{}]\", fieldName, capability.getType());\n-                extractedTypes.put(fieldName, capability.getType());\n-            });\n-        });\n+        response.get()\n+            .forEach(\n+                (fieldName, capabilitiesMap) -> {\n+                    // TODO: overwrites types, requires resolve if\n+                    // types are mixed\n+                    capabilitiesMap.forEach((name, capability) -> {\n+                        logger.trace(\"Extracted type for [{}] : [{}]\", fieldName, capability.getType());\n+                        extractedTypes.put(fieldName, capability.getType());\n+                    });\n+                }\n+            );\n         return extractedTypes;\n     }\n+\n+    /**\n+     * Insert object mappings for fields like:\n+     *\n+     * a.b.c : some_type\n+     *\n+     * in which case it creates additional mappings:\n+     *\n+     * a.b : object\n+     * a : object\n+     *\n+     * avoids snafu with index templates injecting incompatible mappings\n+     *\n+     * @param fieldMappings field mappings to inject to\n+     */\n+    static void insertNestedObjectMappings(Map<String, String> fieldMappings) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d657711a74353466507f767eae17ab633a24a621"}, "originalPosition": 202}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4NzA5NzI4", "url": "https://github.com/elastic/elasticsearch/pull/51368#pullrequestreview-348709728", "createdAt": "2020-01-27T14:38:40Z", "commit": {"oid": "d657711a74353466507f767eae17ab633a24a621"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxNDozODo0MVrOFiE6uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxNDo1NzoyNlrOFiFmcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI3NjQ3NQ==", "bodyText": "An empty string would also return -1. Do you mean disallow strings containing a single '.' that is at the beginning? Wouldn't that be an error case anyway?\nI ran a quick check in jshell:\njshell> \"\".lastIndexOf('.')\n$3 ==> -1", "url": "https://github.com/elastic/elasticsearch/pull/51368#discussion_r371276475", "createdAt": "2020-01-27T14:38:41Z", "author": {"login": "davidkyle"}, "path": "x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/pivot/SchemaUtil.java", "diffHunk": "@@ -165,34 +171,75 @@ public static void getDestinationFieldMappings(final Client client,\n                 targetMapping.put(targetFieldName, \"keyword\");\n             }\n         });\n+\n+        // insert object mappings for nested fields\n+        insertNestedObjectMappings(targetMapping);\n+\n         return targetMapping;\n     }\n \n     /*\n      * Very \"magic\" helper method to extract the source mappings\n      */\n-    private static void getSourceFieldMappings(Client client, String[] index, String[] fields,\n-                                               ActionListener<Map<String, String>> listener) {\n-        FieldCapabilitiesRequest fieldCapabilitiesRequest = new FieldCapabilitiesRequest()\n-            .indices(index)\n+    private static void getSourceFieldMappings(\n+        Client client,\n+        String[] index,\n+        String[] fields,\n+        ActionListener<Map<String, String>> listener\n+    ) {\n+        FieldCapabilitiesRequest fieldCapabilitiesRequest = new FieldCapabilitiesRequest().indices(index)\n             .fields(fields)\n             .indicesOptions(IndicesOptions.LENIENT_EXPAND_OPEN);\n-        client.execute(FieldCapabilitiesAction.INSTANCE, fieldCapabilitiesRequest, ActionListener.wrap(\n-            response -> listener.onResponse(extractFieldMappings(response)),\n-            listener::onFailure));\n+        client.execute(\n+            FieldCapabilitiesAction.INSTANCE,\n+            fieldCapabilitiesRequest,\n+            ActionListener.wrap(response -> listener.onResponse(extractFieldMappings(response)), listener::onFailure)\n+        );\n     }\n \n     private static Map<String, String> extractFieldMappings(FieldCapabilitiesResponse response) {\n         Map<String, String> extractedTypes = new HashMap<>();\n \n-        response.get().forEach((fieldName, capabilitiesMap) -> {\n-            // TODO: overwrites types, requires resolve if\n-            // types are mixed\n-            capabilitiesMap.forEach((name, capability) -> {\n-                logger.trace(\"Extracted type for [{}] : [{}]\", fieldName, capability.getType());\n-                extractedTypes.put(fieldName, capability.getType());\n-            });\n-        });\n+        response.get()\n+            .forEach(\n+                (fieldName, capabilitiesMap) -> {\n+                    // TODO: overwrites types, requires resolve if\n+                    // types are mixed\n+                    capabilitiesMap.forEach((name, capability) -> {\n+                        logger.trace(\"Extracted type for [{}] : [{}]\", fieldName, capability.getType());\n+                        extractedTypes.put(fieldName, capability.getType());\n+                    });\n+                }\n+            );\n         return extractedTypes;\n     }\n+\n+    /**\n+     * Insert object mappings for fields like:\n+     *\n+     * a.b.c : some_type\n+     *\n+     * in which case it creates additional mappings:\n+     *\n+     * a.b : object\n+     * a : object\n+     *\n+     * avoids snafu with index templates injecting incompatible mappings\n+     *\n+     * @param fieldMappings field mappings to inject to\n+     */\n+    static void insertNestedObjectMappings(Map<String, String> fieldMappings) {\n+        Map<String, String> additionalMappings = new HashMap<>();\n+        fieldMappings.keySet().stream().filter(key -> key.contains(\".\")).forEach(key -> {\n+            int pos;\n+            String objectKey = key;\n+            // lastIndexOf returns -1 on mismatch, but to disallow empty strings check for > 0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d657711a74353466507f767eae17ab633a24a621"}, "originalPosition": 207}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI4NzY2NQ==", "bodyText": "\ud83d\udc4d thanks for differentiating the code changes from the formatting changes", "url": "https://github.com/elastic/elasticsearch/pull/51368#discussion_r371287665", "createdAt": "2020-01-27T14:57:26Z", "author": {"login": "davidkyle"}, "path": "x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/pivot/SchemaUtil.java", "diffHunk": "@@ -165,34 +171,75 @@ public static void getDestinationFieldMappings(final Client client,\n                 targetMapping.put(targetFieldName, \"keyword\");\n             }\n         });\n+\n+        // insert object mappings for nested fields\n+        insertNestedObjectMappings(targetMapping);\n+\n         return targetMapping;\n     }\n \n     /*\n      * Very \"magic\" helper method to extract the source mappings\n      */\n-    private static void getSourceFieldMappings(Client client, String[] index, String[] fields,\n-                                               ActionListener<Map<String, String>> listener) {\n-        FieldCapabilitiesRequest fieldCapabilitiesRequest = new FieldCapabilitiesRequest()\n-            .indices(index)\n+    private static void getSourceFieldMappings(\n+        Client client,\n+        String[] index,\n+        String[] fields,\n+        ActionListener<Map<String, String>> listener\n+    ) {\n+        FieldCapabilitiesRequest fieldCapabilitiesRequest = new FieldCapabilitiesRequest().indices(index)\n             .fields(fields)\n             .indicesOptions(IndicesOptions.LENIENT_EXPAND_OPEN);\n-        client.execute(FieldCapabilitiesAction.INSTANCE, fieldCapabilitiesRequest, ActionListener.wrap(\n-            response -> listener.onResponse(extractFieldMappings(response)),\n-            listener::onFailure));\n+        client.execute(\n+            FieldCapabilitiesAction.INSTANCE,\n+            fieldCapabilitiesRequest,\n+            ActionListener.wrap(response -> listener.onResponse(extractFieldMappings(response)), listener::onFailure)\n+        );\n     }\n \n     private static Map<String, String> extractFieldMappings(FieldCapabilitiesResponse response) {\n         Map<String, String> extractedTypes = new HashMap<>();\n \n-        response.get().forEach((fieldName, capabilitiesMap) -> {\n-            // TODO: overwrites types, requires resolve if\n-            // types are mixed\n-            capabilitiesMap.forEach((name, capability) -> {\n-                logger.trace(\"Extracted type for [{}] : [{}]\", fieldName, capability.getType());\n-                extractedTypes.put(fieldName, capability.getType());\n-            });\n-        });\n+        response.get()\n+            .forEach(\n+                (fieldName, capabilitiesMap) -> {\n+                    // TODO: overwrites types, requires resolve if\n+                    // types are mixed\n+                    capabilitiesMap.forEach((name, capability) -> {\n+                        logger.trace(\"Extracted type for [{}] : [{}]\", fieldName, capability.getType());\n+                        extractedTypes.put(fieldName, capability.getType());\n+                    });\n+                }\n+            );\n         return extractedTypes;\n     }\n+\n+    /**\n+     * Insert object mappings for fields like:\n+     *\n+     * a.b.c : some_type\n+     *\n+     * in which case it creates additional mappings:\n+     *\n+     * a.b : object\n+     * a : object\n+     *\n+     * avoids snafu with index templates injecting incompatible mappings\n+     *\n+     * @param fieldMappings field mappings to inject to\n+     */\n+    static void insertNestedObjectMappings(Map<String, String> fieldMappings) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI5Mzg0Mg=="}, "originalCommit": {"oid": "d657711a74353466507f767eae17ab633a24a621"}, "originalPosition": 202}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2897, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}