{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM1NDM2OTY2", "number": 58193, "reviewThreads": {"totalCount": 28, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMTo1NzowOFrOEGUUmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxODowOTo1MFrOEKnMCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MDU5ODY2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/trainedmodel/EmptyConfigUpdate.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMTo1NzowOFrOGlCY_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMTo1NzowOFrOGlCY_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ4OTY2MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return (o == null || getClass() != o.getClass()) == false;\n          \n          \n            \n                    return o != null && getClass() == o.getClass();", "url": "https://github.com/elastic/elasticsearch/pull/58193#discussion_r441489660", "createdAt": "2020-06-17T11:57:08Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/trainedmodel/EmptyConfigUpdate.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.ml.inference.trainedmodel;\n+\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+\n+import java.io.IOException;\n+\n+/**\n+ * A config update that applies no changes.\n+ * Supports any type of {@link InferenceConfig}\n+ */\n+public class EmptyConfigUpdate implements InferenceConfigUpdate {\n+\n+    public static final ParseField NAME = new ParseField(\"empty\");\n+\n+    private static final ObjectParser<EmptyConfigUpdate, Void> PARSER =\n+        new ObjectParser<>(NAME.getPreferredName(), EmptyConfigUpdate::new);\n+\n+    public static EmptyConfigUpdate fromXContent(XContentParser parser) {\n+        return PARSER.apply(parser, null);\n+    }\n+\n+    public EmptyConfigUpdate() {\n+    }\n+\n+    public EmptyConfigUpdate(StreamInput in) {\n+    }\n+\n+    @Override\n+    public InferenceConfig apply(InferenceConfig originalConfig) {\n+        return originalConfig;\n+    }\n+\n+    @Override\n+    public InferenceConfig toConfig() {\n+        return RegressionConfig.EMPTY_PARAMS;\n+    }\n+\n+    @Override\n+    public boolean isSupported(InferenceConfig config) {\n+        return true;\n+    }\n+\n+    @Override\n+    public String getWriteableName() {\n+        return NAME.getPreferredName();\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return NAME.getPreferredName();\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject();\n+        builder.endObject();\n+        return builder;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        // Equal if o is not null and the same class\n+        return (o == null || getClass() != o.getClass()) == false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5c2cbc07e9bff54eaa8065f995339e654b60226"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MDYwOTYwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ml/qa/ml-with-security/build.gradle", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMjowMDozM1rOGlCgGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxMDowMDo0OFrOGloatQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ5MTQ4MA==", "bodyText": "None of these are expecting errors in their yaml tests. Why are they part of the blacklist?", "url": "https://github.com/elastic/elasticsearch/pull/58193#discussion_r441491480", "createdAt": "2020-06-17T12:00:33Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/ml/qa/ml-with-security/build.gradle", "diffHunk": "@@ -183,6 +183,9 @@ integTest.runner {\n     'ml/job_groups/Test put job with id that matches an existing group',\n     'ml/job_groups/Test put job with invalid group',\n     'ml/ml_info/Test ml info',\n+    'ml/pipeline_inference/Test pipeline regression simple',\n+    'ml/pipeline_inference/Test pipeline agg referencing a single bucket',\n+    'ml/pipeline_inference/Test all fields missing warning',", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5c2cbc07e9bff54eaa8065f995339e654b60226"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUxMjM4Mg==", "bodyText": "MlWithSecurityIT and MlWithSecurityUserRoleIT both pass but MlWithSecurityInsufficientRoleIT fails because it expects ml tests to fail if the user does not have one of the ml roles (user, admin).\nIn this case you don't need the ml role to run search so the test fails. This definitely opens up a discussion point which needs to be resolved but that can happen outside of this PR. So I hacked a solution to get green", "url": "https://github.com/elastic/elasticsearch/pull/58193#discussion_r441512382", "createdAt": "2020-06-17T12:39:04Z", "author": {"login": "davidkyle"}, "path": "x-pack/plugin/ml/qa/ml-with-security/build.gradle", "diffHunk": "@@ -183,6 +183,9 @@ integTest.runner {\n     'ml/job_groups/Test put job with id that matches an existing group',\n     'ml/job_groups/Test put job with invalid group',\n     'ml/ml_info/Test ml info',\n+    'ml/pipeline_inference/Test pipeline regression simple',\n+    'ml/pipeline_inference/Test pipeline agg referencing a single bucket',\n+    'ml/pipeline_inference/Test all fields missing warning',", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ5MTQ4MA=="}, "originalCommit": {"oid": "e5c2cbc07e9bff54eaa8065f995339e654b60226"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUxMzM4Mw==", "bodyText": "Thanks for the explanation :D.", "url": "https://github.com/elastic/elasticsearch/pull/58193#discussion_r441513383", "createdAt": "2020-06-17T12:40:43Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/ml/qa/ml-with-security/build.gradle", "diffHunk": "@@ -183,6 +183,9 @@ integTest.runner {\n     'ml/job_groups/Test put job with id that matches an existing group',\n     'ml/job_groups/Test put job with invalid group',\n     'ml/ml_info/Test ml info',\n+    'ml/pipeline_inference/Test pipeline regression simple',\n+    'ml/pipeline_inference/Test pipeline agg referencing a single bucket',\n+    'ml/pipeline_inference/Test all fields missing warning',", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ5MTQ4MA=="}, "originalCommit": {"oid": "e5c2cbc07e9bff54eaa8065f995339e654b60226"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUxODQyNA==", "bodyText": "Actually looking at MlWithSecurityUserRoleIT I think we can do something similar and check which endpoint was invoked by the test.\n\n  \n    \n      elasticsearch/x-pack/plugin/ml/qa/ml-with-security/src/test/java/org/elasticsearch/smoketest/MlWithSecurityUserRoleIT.java\n    \n    \n         Line 46\n      in\n      5fa36da\n    \n    \n    \n    \n\n        \n          \n           for (ExecutableSection section : testCandidate.getTestSection().getExecutableSections()) {", "url": "https://github.com/elastic/elasticsearch/pull/58193#discussion_r441518424", "createdAt": "2020-06-17T12:49:09Z", "author": {"login": "davidkyle"}, "path": "x-pack/plugin/ml/qa/ml-with-security/build.gradle", "diffHunk": "@@ -183,6 +183,9 @@ integTest.runner {\n     'ml/job_groups/Test put job with id that matches an existing group',\n     'ml/job_groups/Test put job with invalid group',\n     'ml/ml_info/Test ml info',\n+    'ml/pipeline_inference/Test pipeline regression simple',\n+    'ml/pipeline_inference/Test pipeline agg referencing a single bucket',\n+    'ml/pipeline_inference/Test all fields missing warning',", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ5MTQ4MA=="}, "originalCommit": {"oid": "e5c2cbc07e9bff54eaa8065f995339e654b60226"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjExMjY5Mw==", "bodyText": "The fix was quite simple I changed MlWithSecurityInsufficientRoleIT to check if an ml endpoint was called and only fail if that is the case.\nI pushed that change in c47d42d", "url": "https://github.com/elastic/elasticsearch/pull/58193#discussion_r442112693", "createdAt": "2020-06-18T10:00:48Z", "author": {"login": "davidkyle"}, "path": "x-pack/plugin/ml/qa/ml-with-security/build.gradle", "diffHunk": "@@ -183,6 +183,9 @@ integTest.runner {\n     'ml/job_groups/Test put job with id that matches an existing group',\n     'ml/job_groups/Test put job with invalid group',\n     'ml/ml_info/Test ml info',\n+    'ml/pipeline_inference/Test pipeline regression simple',\n+    'ml/pipeline_inference/Test pipeline agg referencing a single bucket',\n+    'ml/pipeline_inference/Test all fields missing warning',", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ5MTQ4MA=="}, "originalCommit": {"oid": "e5c2cbc07e9bff54eaa8065f995339e654b60226"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MDY0NjM0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/aggs/InferencePipelineAggregationBuilder.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMjoxMTo1NlrOGlC2sA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMjoxMTo1NlrOGlC2sA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ5NzI2NA==", "bodyText": "Loading the model could take seconds to finish. Depending on the threadpool/context this is bad.\nThis needs to be addressed before merge.\nA potential solution to this would have pipeline aggs satisfy some sort of \"rewrite\" phase. This way the context has time to make an asynchronous call before executing.", "url": "https://github.com/elastic/elasticsearch/pull/58193#discussion_r441497264", "createdAt": "2020-06-17T12:11:56Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/aggs/InferencePipelineAggregationBuilder.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ml.inference.aggs;\n+\n+import org.apache.lucene.util.SetOnce;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.LatchedActionListener;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.collect.Tuple;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.search.aggregations.pipeline.AbstractPipelineAggregationBuilder;\n+import org.elasticsearch.search.aggregations.pipeline.BucketHelpers;\n+import org.elasticsearch.search.aggregations.pipeline.PipelineAggregator;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.ClassificationConfig;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.ClassificationConfigUpdate;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.EmptyConfigUpdate;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.InferenceConfig;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.InferenceConfigUpdate;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.LenientlyParsedInferenceConfig;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.RegressionConfig;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.RegressionConfigUpdate;\n+import org.elasticsearch.xpack.core.ml.utils.ExceptionsHelper;\n+import org.elasticsearch.xpack.ml.inference.loadingservice.Model;\n+import org.elasticsearch.xpack.ml.inference.loadingservice.ModelLoadingService;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.CountDownLatch;\n+\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.constructorArg;\n+import static org.elasticsearch.search.aggregations.pipeline.PipelineAggregator.Parser.GAP_POLICY;\n+\n+public class InferencePipelineAggregationBuilder extends AbstractPipelineAggregationBuilder<InferencePipelineAggregationBuilder> {\n+\n+    public static String NAME = \"inference\";\n+\n+    public static final ParseField MODEL_ID = new ParseField(\"model_id\");\n+    private static final ParseField INFERENCE_CONFIG = new ParseField(\"inference_config\");\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static final ConstructingObjectParser<InferencePipelineAggregationBuilder,\n+        Tuple<SetOnce<ModelLoadingService>, String>> PARSER = new ConstructingObjectParser<>(\n+        NAME, false,\n+        (args, context) -> new InferencePipelineAggregationBuilder(context.v2(), context.v1(), (Map<String, String>) args[0])\n+    );\n+\n+    static {\n+        PARSER.declareObject(constructorArg(), (p, c) -> p.mapStrings(), BUCKETS_PATH_FIELD);\n+        PARSER.declareString(InferencePipelineAggregationBuilder::setModelId, MODEL_ID);\n+        PARSER.declareNamedObject(InferencePipelineAggregationBuilder::setInferenceConfig,\n+            (p, c, n) -> p.namedObject(LenientlyParsedInferenceConfig.class, n, c), INFERENCE_CONFIG);\n+        PARSER.declareField(InferencePipelineAggregationBuilder::setGapPolicy, p -> {\n+            if (p.currentToken() == XContentParser.Token.VALUE_STRING) {\n+                return BucketHelpers.GapPolicy.parse(p.text().toLowerCase(Locale.ROOT), p.getTokenLocation());\n+            }\n+            throw new IllegalArgumentException(\n+                \"Unsupported token [\" + p.currentToken() + \"] parsing inference aggregation \" + GAP_POLICY.getPreferredName());\n+        }, GAP_POLICY, ObjectParser.ValueType.STRING);\n+    }\n+\n+    private final Map<String, String> bucketPathMap;\n+    private String modelId;\n+    private InferenceConfig inferenceConfig;\n+    private final SetOnce<ModelLoadingService> modelLoadingService;\n+    private BucketHelpers.GapPolicy gapPolicy = BucketHelpers.GapPolicy.SKIP;\n+\n+    public static InferencePipelineAggregationBuilder parse(SetOnce<ModelLoadingService> modelLoadingService,\n+                                                            String pipelineAggregatorName,\n+                                                            XContentParser parser) {\n+        Tuple<SetOnce<ModelLoadingService>, String> context = new Tuple<>(modelLoadingService, pipelineAggregatorName);\n+        return PARSER.apply(parser, context);\n+    }\n+\n+    public InferencePipelineAggregationBuilder(String name, SetOnce<ModelLoadingService> modelLoadingService,\n+                                               Map<String, String> bucketsPath) {\n+        super(name, NAME, bucketsPath.values().toArray(new String[] {}));\n+        this.modelLoadingService = modelLoadingService;\n+        this.bucketPathMap = bucketsPath;\n+    }\n+\n+    public InferencePipelineAggregationBuilder(StreamInput in, SetOnce<ModelLoadingService> modelLoadingService) throws IOException {\n+        super(in, NAME);\n+        modelId = in.readString();\n+        bucketPathMap = in.readMap(StreamInput::readString, StreamInput::readString);\n+        inferenceConfig = in.readOptionalNamedWriteable(InferenceConfig.class);\n+        gapPolicy = BucketHelpers.GapPolicy.readFrom(in);\n+        this.modelLoadingService = modelLoadingService;\n+    }\n+\n+    void setModelId(String modelId) {\n+        this.modelId = modelId;\n+    }\n+\n+    void setInferenceConfig(InferenceConfig inferenceConfig) {\n+        this.inferenceConfig = inferenceConfig;\n+    }\n+\n+    void setGapPolicy(BucketHelpers.GapPolicy gapPolicy) {\n+        this.gapPolicy = gapPolicy;\n+    }\n+\n+    @Override\n+    protected void validate(ValidationContext context) {\n+        context.validateHasParent(NAME, name);\n+        if (modelId == null) {\n+            context.addValidationError(\"Model Id must be set\");\n+        }\n+        if (gapPolicy != BucketHelpers.GapPolicy.SKIP) {\n+            context.addValidationError(\"gap policy [\" + gapPolicy + \"] in not valid for [\" + NAME + \"] aggregation\");\n+        }\n+    }\n+\n+    @Override\n+    protected void doWriteTo(StreamOutput out) throws IOException {\n+        out.writeString(modelId);\n+        out.writeMap(bucketPathMap, StreamOutput::writeString, StreamOutput::writeString);\n+        out.writeOptionalNamedWriteable(inferenceConfig);\n+        gapPolicy.writeTo(out);\n+    }\n+\n+    @Override\n+    protected PipelineAggregator createInternal(Map<String, Object> metaData) {\n+\n+        SetOnce<Model> model = new SetOnce<>();\n+        SetOnce<Exception> error = new SetOnce<>();\n+        CountDownLatch latch = new CountDownLatch(1);\n+        ActionListener<Model> listener = new LatchedActionListener<>(\n+            ActionListener.wrap(model::set, error::set), latch);\n+\n+        modelLoadingService.get().getModelForSearch(modelId, listener);\n+        try {\n+            // TODO Avoid the blocking wait\n+            latch.await();\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(\"Inference aggregation interrupted loading model\", e);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5c2cbc07e9bff54eaa8065f995339e654b60226"}, "originalPosition": 148}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MDY1NjQzOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/aggs/InferencePipelineAggregator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMjoxNDo1OFrOGlC81Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMjoxNDo1OFrOGlC81Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ5ODgzNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public InferencePipelineAggregator(String name, Map<String,\n          \n          \n            \n                                                   String> bucketPathMap, Map<String, Object> metaData,\n          \n          \n            \n                public InferencePipelineAggregator(String name, \n          \n          \n            \n                                                   Map<String, String> bucketPathMap, \n          \n          \n            \n                                                   Map<String, Object> metaData,", "url": "https://github.com/elastic/elasticsearch/pull/58193#discussion_r441498837", "createdAt": "2020-06-17T12:14:58Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/aggs/InferencePipelineAggregator.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ml.inference.aggs;\n+\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.search.aggregations.AggregationExecutionException;\n+import org.elasticsearch.search.aggregations.InternalAggregation;\n+import org.elasticsearch.search.aggregations.InternalAggregations;\n+import org.elasticsearch.search.aggregations.InternalMultiBucketAggregation;\n+import org.elasticsearch.search.aggregations.bucket.MultiBucketsAggregation;\n+import org.elasticsearch.search.aggregations.bucket.terms.StringTerms;\n+import org.elasticsearch.search.aggregations.metrics.InternalNumericMetricsAggregation;\n+import org.elasticsearch.search.aggregations.pipeline.AbstractPipelineAggregationBuilder;\n+import org.elasticsearch.search.aggregations.pipeline.PipelineAggregator;\n+import org.elasticsearch.search.aggregations.support.AggregationPath;\n+import org.elasticsearch.xpack.core.ml.inference.results.InferenceResults;\n+import org.elasticsearch.xpack.core.ml.inference.results.WarningInferenceResults;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.InferenceConfigUpdate;\n+import org.elasticsearch.xpack.ml.inference.loadingservice.Model;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+\n+public class InferencePipelineAggregator extends PipelineAggregator {\n+\n+    private Map<String, String> bucketPathMap;\n+    private InferenceConfigUpdate configUpdate;\n+    private Model model;\n+\n+    public InferencePipelineAggregator(String name, Map<String,\n+                                       String> bucketPathMap, Map<String, Object> metaData,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5c2cbc07e9bff54eaa8065f995339e654b60226"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NDQxNzE5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/aggs/InferencePipelineAggregationBuilder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwOTo1NDowN1rOGloLgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwOTo1NDowN1rOGloLgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjEwODgwMg==", "bodyText": "I agree with what Ben said about the need to remove the latch await, and if that is done there will hopefully be no need to catch InterruptedException here.  However, if we do still have to catch it, the handler should interrupt the current thread before throwing a different type of exception, because the class that owns the thread (e.g. a thread pool) may be relying on the interrupted status to decide what to do with the thread.", "url": "https://github.com/elastic/elasticsearch/pull/58193#discussion_r442108802", "createdAt": "2020-06-18T09:54:07Z", "author": {"login": "droberts195"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/aggs/InferencePipelineAggregationBuilder.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ml.inference.aggs;\n+\n+import org.apache.lucene.util.SetOnce;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.LatchedActionListener;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.collect.Tuple;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.search.aggregations.pipeline.AbstractPipelineAggregationBuilder;\n+import org.elasticsearch.search.aggregations.pipeline.BucketHelpers;\n+import org.elasticsearch.search.aggregations.pipeline.PipelineAggregator;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.ClassificationConfig;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.ClassificationConfigUpdate;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.EmptyConfigUpdate;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.InferenceConfig;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.InferenceConfigUpdate;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.LenientlyParsedInferenceConfig;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.RegressionConfig;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.RegressionConfigUpdate;\n+import org.elasticsearch.xpack.core.ml.utils.ExceptionsHelper;\n+import org.elasticsearch.xpack.ml.inference.loadingservice.Model;\n+import org.elasticsearch.xpack.ml.inference.loadingservice.ModelLoadingService;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.CountDownLatch;\n+\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.constructorArg;\n+import static org.elasticsearch.search.aggregations.pipeline.PipelineAggregator.Parser.GAP_POLICY;\n+\n+public class InferencePipelineAggregationBuilder extends AbstractPipelineAggregationBuilder<InferencePipelineAggregationBuilder> {\n+\n+    public static String NAME = \"inference\";\n+\n+    public static final ParseField MODEL_ID = new ParseField(\"model_id\");\n+    private static final ParseField INFERENCE_CONFIG = new ParseField(\"inference_config\");\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static final ConstructingObjectParser<InferencePipelineAggregationBuilder,\n+        Tuple<SetOnce<ModelLoadingService>, String>> PARSER = new ConstructingObjectParser<>(\n+        NAME, false,\n+        (args, context) -> new InferencePipelineAggregationBuilder(context.v2(), context.v1(), (Map<String, String>) args[0])\n+    );\n+\n+    static {\n+        PARSER.declareObject(constructorArg(), (p, c) -> p.mapStrings(), BUCKETS_PATH_FIELD);\n+        PARSER.declareString(InferencePipelineAggregationBuilder::setModelId, MODEL_ID);\n+        PARSER.declareNamedObject(InferencePipelineAggregationBuilder::setInferenceConfig,\n+            (p, c, n) -> p.namedObject(LenientlyParsedInferenceConfig.class, n, c), INFERENCE_CONFIG);\n+        PARSER.declareField(InferencePipelineAggregationBuilder::setGapPolicy, p -> {\n+            if (p.currentToken() == XContentParser.Token.VALUE_STRING) {\n+                return BucketHelpers.GapPolicy.parse(p.text().toLowerCase(Locale.ROOT), p.getTokenLocation());\n+            }\n+            throw new IllegalArgumentException(\n+                \"Unsupported token [\" + p.currentToken() + \"] parsing inference aggregation \" + GAP_POLICY.getPreferredName());\n+        }, GAP_POLICY, ObjectParser.ValueType.STRING);\n+    }\n+\n+    private final Map<String, String> bucketPathMap;\n+    private String modelId;\n+    private InferenceConfig inferenceConfig;\n+    private final SetOnce<ModelLoadingService> modelLoadingService;\n+    private BucketHelpers.GapPolicy gapPolicy = BucketHelpers.GapPolicy.SKIP;\n+\n+    public static InferencePipelineAggregationBuilder parse(SetOnce<ModelLoadingService> modelLoadingService,\n+                                                            String pipelineAggregatorName,\n+                                                            XContentParser parser) {\n+        Tuple<SetOnce<ModelLoadingService>, String> context = new Tuple<>(modelLoadingService, pipelineAggregatorName);\n+        return PARSER.apply(parser, context);\n+    }\n+\n+    public InferencePipelineAggregationBuilder(String name, SetOnce<ModelLoadingService> modelLoadingService,\n+                                               Map<String, String> bucketsPath) {\n+        super(name, NAME, bucketsPath.values().toArray(new String[] {}));\n+        this.modelLoadingService = modelLoadingService;\n+        this.bucketPathMap = bucketsPath;\n+    }\n+\n+    public InferencePipelineAggregationBuilder(StreamInput in, SetOnce<ModelLoadingService> modelLoadingService) throws IOException {\n+        super(in, NAME);\n+        modelId = in.readString();\n+        bucketPathMap = in.readMap(StreamInput::readString, StreamInput::readString);\n+        inferenceConfig = in.readOptionalNamedWriteable(InferenceConfig.class);\n+        gapPolicy = BucketHelpers.GapPolicy.readFrom(in);\n+        this.modelLoadingService = modelLoadingService;\n+    }\n+\n+    void setModelId(String modelId) {\n+        this.modelId = modelId;\n+    }\n+\n+    void setInferenceConfig(InferenceConfig inferenceConfig) {\n+        this.inferenceConfig = inferenceConfig;\n+    }\n+\n+    void setGapPolicy(BucketHelpers.GapPolicy gapPolicy) {\n+        this.gapPolicy = gapPolicy;\n+    }\n+\n+    @Override\n+    protected void validate(ValidationContext context) {\n+        context.validateHasParent(NAME, name);\n+        if (modelId == null) {\n+            context.addValidationError(\"Model Id must be set\");\n+        }\n+        if (gapPolicy != BucketHelpers.GapPolicy.SKIP) {\n+            context.addValidationError(\"gap policy [\" + gapPolicy + \"] in not valid for [\" + NAME + \"] aggregation\");\n+        }\n+    }\n+\n+    @Override\n+    protected void doWriteTo(StreamOutput out) throws IOException {\n+        out.writeString(modelId);\n+        out.writeMap(bucketPathMap, StreamOutput::writeString, StreamOutput::writeString);\n+        out.writeOptionalNamedWriteable(inferenceConfig);\n+        gapPolicy.writeTo(out);\n+    }\n+\n+    @Override\n+    protected PipelineAggregator createInternal(Map<String, Object> metaData) {\n+\n+        SetOnce<Model> model = new SetOnce<>();\n+        SetOnce<Exception> error = new SetOnce<>();\n+        CountDownLatch latch = new CountDownLatch(1);\n+        ActionListener<Model> listener = new LatchedActionListener<>(\n+            ActionListener.wrap(model::set, error::set), latch);\n+\n+        modelLoadingService.get().getModelForSearch(modelId, listener);\n+        try {\n+            // TODO Avoid the blocking wait\n+            latch.await();\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(\"Inference aggregation interrupted loading model\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c47d42d5c91ef55490abff9683f7a7c0b1bdde0c"}, "originalPosition": 147}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NDQyNTYwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/aggs/InferencePipelineAggregationBuilder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwOTo1NjoyOVrOGloREQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwOTo1NjoyOVrOGloREQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjExMDIyNQ==", "bodyText": "Most exceptions used in Elasticsearch are already RuntimeExceptions.  It would be better if these weren't wrapped in a generic runtime exception, as that will look less friendly in error messages and especially if it ends up getting transported to a different node.  So it would be better to only wrap the exception if it's not already instanceof RuntimeException.", "url": "https://github.com/elastic/elasticsearch/pull/58193#discussion_r442110225", "createdAt": "2020-06-18T09:56:29Z", "author": {"login": "droberts195"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/aggs/InferencePipelineAggregationBuilder.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ml.inference.aggs;\n+\n+import org.apache.lucene.util.SetOnce;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.LatchedActionListener;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.collect.Tuple;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.search.aggregations.pipeline.AbstractPipelineAggregationBuilder;\n+import org.elasticsearch.search.aggregations.pipeline.BucketHelpers;\n+import org.elasticsearch.search.aggregations.pipeline.PipelineAggregator;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.ClassificationConfig;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.ClassificationConfigUpdate;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.EmptyConfigUpdate;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.InferenceConfig;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.InferenceConfigUpdate;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.LenientlyParsedInferenceConfig;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.RegressionConfig;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.RegressionConfigUpdate;\n+import org.elasticsearch.xpack.core.ml.utils.ExceptionsHelper;\n+import org.elasticsearch.xpack.ml.inference.loadingservice.Model;\n+import org.elasticsearch.xpack.ml.inference.loadingservice.ModelLoadingService;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.CountDownLatch;\n+\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.constructorArg;\n+import static org.elasticsearch.search.aggregations.pipeline.PipelineAggregator.Parser.GAP_POLICY;\n+\n+public class InferencePipelineAggregationBuilder extends AbstractPipelineAggregationBuilder<InferencePipelineAggregationBuilder> {\n+\n+    public static String NAME = \"inference\";\n+\n+    public static final ParseField MODEL_ID = new ParseField(\"model_id\");\n+    private static final ParseField INFERENCE_CONFIG = new ParseField(\"inference_config\");\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static final ConstructingObjectParser<InferencePipelineAggregationBuilder,\n+        Tuple<SetOnce<ModelLoadingService>, String>> PARSER = new ConstructingObjectParser<>(\n+        NAME, false,\n+        (args, context) -> new InferencePipelineAggregationBuilder(context.v2(), context.v1(), (Map<String, String>) args[0])\n+    );\n+\n+    static {\n+        PARSER.declareObject(constructorArg(), (p, c) -> p.mapStrings(), BUCKETS_PATH_FIELD);\n+        PARSER.declareString(InferencePipelineAggregationBuilder::setModelId, MODEL_ID);\n+        PARSER.declareNamedObject(InferencePipelineAggregationBuilder::setInferenceConfig,\n+            (p, c, n) -> p.namedObject(LenientlyParsedInferenceConfig.class, n, c), INFERENCE_CONFIG);\n+        PARSER.declareField(InferencePipelineAggregationBuilder::setGapPolicy, p -> {\n+            if (p.currentToken() == XContentParser.Token.VALUE_STRING) {\n+                return BucketHelpers.GapPolicy.parse(p.text().toLowerCase(Locale.ROOT), p.getTokenLocation());\n+            }\n+            throw new IllegalArgumentException(\n+                \"Unsupported token [\" + p.currentToken() + \"] parsing inference aggregation \" + GAP_POLICY.getPreferredName());\n+        }, GAP_POLICY, ObjectParser.ValueType.STRING);\n+    }\n+\n+    private final Map<String, String> bucketPathMap;\n+    private String modelId;\n+    private InferenceConfig inferenceConfig;\n+    private final SetOnce<ModelLoadingService> modelLoadingService;\n+    private BucketHelpers.GapPolicy gapPolicy = BucketHelpers.GapPolicy.SKIP;\n+\n+    public static InferencePipelineAggregationBuilder parse(SetOnce<ModelLoadingService> modelLoadingService,\n+                                                            String pipelineAggregatorName,\n+                                                            XContentParser parser) {\n+        Tuple<SetOnce<ModelLoadingService>, String> context = new Tuple<>(modelLoadingService, pipelineAggregatorName);\n+        return PARSER.apply(parser, context);\n+    }\n+\n+    public InferencePipelineAggregationBuilder(String name, SetOnce<ModelLoadingService> modelLoadingService,\n+                                               Map<String, String> bucketsPath) {\n+        super(name, NAME, bucketsPath.values().toArray(new String[] {}));\n+        this.modelLoadingService = modelLoadingService;\n+        this.bucketPathMap = bucketsPath;\n+    }\n+\n+    public InferencePipelineAggregationBuilder(StreamInput in, SetOnce<ModelLoadingService> modelLoadingService) throws IOException {\n+        super(in, NAME);\n+        modelId = in.readString();\n+        bucketPathMap = in.readMap(StreamInput::readString, StreamInput::readString);\n+        inferenceConfig = in.readOptionalNamedWriteable(InferenceConfig.class);\n+        gapPolicy = BucketHelpers.GapPolicy.readFrom(in);\n+        this.modelLoadingService = modelLoadingService;\n+    }\n+\n+    void setModelId(String modelId) {\n+        this.modelId = modelId;\n+    }\n+\n+    void setInferenceConfig(InferenceConfig inferenceConfig) {\n+        this.inferenceConfig = inferenceConfig;\n+    }\n+\n+    void setGapPolicy(BucketHelpers.GapPolicy gapPolicy) {\n+        this.gapPolicy = gapPolicy;\n+    }\n+\n+    @Override\n+    protected void validate(ValidationContext context) {\n+        context.validateHasParent(NAME, name);\n+        if (modelId == null) {\n+            context.addValidationError(\"Model Id must be set\");\n+        }\n+        if (gapPolicy != BucketHelpers.GapPolicy.SKIP) {\n+            context.addValidationError(\"gap policy [\" + gapPolicy + \"] in not valid for [\" + NAME + \"] aggregation\");\n+        }\n+    }\n+\n+    @Override\n+    protected void doWriteTo(StreamOutput out) throws IOException {\n+        out.writeString(modelId);\n+        out.writeMap(bucketPathMap, StreamOutput::writeString, StreamOutput::writeString);\n+        out.writeOptionalNamedWriteable(inferenceConfig);\n+        gapPolicy.writeTo(out);\n+    }\n+\n+    @Override\n+    protected PipelineAggregator createInternal(Map<String, Object> metaData) {\n+\n+        SetOnce<Model> model = new SetOnce<>();\n+        SetOnce<Exception> error = new SetOnce<>();\n+        CountDownLatch latch = new CountDownLatch(1);\n+        ActionListener<Model> listener = new LatchedActionListener<>(\n+            ActionListener.wrap(model::set, error::set), latch);\n+\n+        modelLoadingService.get().getModelForSearch(modelId, listener);\n+        try {\n+            // TODO Avoid the blocking wait\n+            latch.await();\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(\"Inference aggregation interrupted loading model\", e);\n+        }\n+\n+        if (error.get() != null) {\n+            throw new RuntimeException(error.get());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c47d42d5c91ef55490abff9683f7a7c0b1bdde0c"}, "originalPosition": 151}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3NjY4MDY3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/aggs/InternalInferenceAggregation.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNToxMjowOVrOGo_VRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxNjoxNzo0MlrOGpm0qA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTYzMzg2Mg==", "bodyText": "It might be good to add a predictedValue() method to the InferenceResults interface. That way you can access it without these castings, especially since all inference results will either have a predicted value or null.", "url": "https://github.com/elastic/elasticsearch/pull/58193#discussion_r445633862", "createdAt": "2020-06-25T15:12:09Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/aggs/InternalInferenceAggregation.java", "diffHunk": "@@ -48,24 +51,44 @@ public InternalAggregation reduce(List<InternalAggregation> aggregations, Reduce\n     }\n \n     @Override\n-    @SuppressWarnings(\"unchecked\")\n     public Object getProperty(List<String> path) {\n-        Map<String, Object> resultMap = this.inferenceResult.writeResultToMap();\n-\n-        for (int i=0; i<path.size() -1; i++) {\n-            Object value = resultMap.get(path.get(i));\n-            if (value == null) {\n-                throw new InvalidAggregationPathException(\"Cannot find an key [\" + path.get(i) + \"] in \" + path);\n-            }\n-\n-            if (value instanceof Map<?, ?>) {\n-                resultMap = (Map<String, Object>)value;\n+        if (path.isEmpty()) {\n+            return this;\n+        } else if (path.size() == 1) {\n+            String field = path.get(0);\n+            if (CommonFields.VALUE.getPreferredName().equals(field)) {\n+                if (inferenceResult instanceof ClassificationInferenceResults) {\n+                    return ((ClassificationInferenceResults)inferenceResult).transformedPredictedValue();\n+                } else if (inferenceResult instanceof SingleValueInferenceResults) {\n+                    return ((SingleValueInferenceResults)inferenceResult).value();\n+                } else {\n+                    return null;\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab6e17850c7623cfec2ee7f0cdc51f8864d5dcb5"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY0MjI4MQ==", "bodyText": "Yes the problem is value returns a Double and transformedPredictedValue returns an Object that may be a Double, String or Boolean.\nI'll take another look though as it would be nice to simplify this", "url": "https://github.com/elastic/elasticsearch/pull/58193#discussion_r445642281", "createdAt": "2020-06-25T15:23:51Z", "author": {"login": "davidkyle"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/aggs/InternalInferenceAggregation.java", "diffHunk": "@@ -48,24 +51,44 @@ public InternalAggregation reduce(List<InternalAggregation> aggregations, Reduce\n     }\n \n     @Override\n-    @SuppressWarnings(\"unchecked\")\n     public Object getProperty(List<String> path) {\n-        Map<String, Object> resultMap = this.inferenceResult.writeResultToMap();\n-\n-        for (int i=0; i<path.size() -1; i++) {\n-            Object value = resultMap.get(path.get(i));\n-            if (value == null) {\n-                throw new InvalidAggregationPathException(\"Cannot find an key [\" + path.get(i) + \"] in \" + path);\n-            }\n-\n-            if (value instanceof Map<?, ?>) {\n-                resultMap = (Map<String, Object>)value;\n+        if (path.isEmpty()) {\n+            return this;\n+        } else if (path.size() == 1) {\n+            String field = path.get(0);\n+            if (CommonFields.VALUE.getPreferredName().equals(field)) {\n+                if (inferenceResult instanceof ClassificationInferenceResults) {\n+                    return ((ClassificationInferenceResults)inferenceResult).transformedPredictedValue();\n+                } else if (inferenceResult instanceof SingleValueInferenceResults) {\n+                    return ((SingleValueInferenceResults)inferenceResult).value();\n+                } else {\n+                    return null;\n+                }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTYzMzg2Mg=="}, "originalCommit": {"oid": "ab6e17850c7623cfec2ee7f0cdc51f8864d5dcb5"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY0NTA5Mw==", "bodyText": "Object getPredictedValue() or something on the Interface could help. Fewer branches would be good :D", "url": "https://github.com/elastic/elasticsearch/pull/58193#discussion_r445645093", "createdAt": "2020-06-25T15:27:45Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/aggs/InternalInferenceAggregation.java", "diffHunk": "@@ -48,24 +51,44 @@ public InternalAggregation reduce(List<InternalAggregation> aggregations, Reduce\n     }\n \n     @Override\n-    @SuppressWarnings(\"unchecked\")\n     public Object getProperty(List<String> path) {\n-        Map<String, Object> resultMap = this.inferenceResult.writeResultToMap();\n-\n-        for (int i=0; i<path.size() -1; i++) {\n-            Object value = resultMap.get(path.get(i));\n-            if (value == null) {\n-                throw new InvalidAggregationPathException(\"Cannot find an key [\" + path.get(i) + \"] in \" + path);\n-            }\n-\n-            if (value instanceof Map<?, ?>) {\n-                resultMap = (Map<String, Object>)value;\n+        if (path.isEmpty()) {\n+            return this;\n+        } else if (path.size() == 1) {\n+            String field = path.get(0);\n+            if (CommonFields.VALUE.getPreferredName().equals(field)) {\n+                if (inferenceResult instanceof ClassificationInferenceResults) {\n+                    return ((ClassificationInferenceResults)inferenceResult).transformedPredictedValue();\n+                } else if (inferenceResult instanceof SingleValueInferenceResults) {\n+                    return ((SingleValueInferenceResults)inferenceResult).value();\n+                } else {\n+                    return null;\n+                }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTYzMzg2Mg=="}, "originalCommit": {"oid": "ab6e17850c7623cfec2ee7f0cdc51f8864d5dcb5"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI4MDg3Mg==", "bodyText": "I went with Object getPredictedValue()", "url": "https://github.com/elastic/elasticsearch/pull/58193#discussion_r446280872", "createdAt": "2020-06-26T16:17:42Z", "author": {"login": "davidkyle"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/aggs/InternalInferenceAggregation.java", "diffHunk": "@@ -48,24 +51,44 @@ public InternalAggregation reduce(List<InternalAggregation> aggregations, Reduce\n     }\n \n     @Override\n-    @SuppressWarnings(\"unchecked\")\n     public Object getProperty(List<String> path) {\n-        Map<String, Object> resultMap = this.inferenceResult.writeResultToMap();\n-\n-        for (int i=0; i<path.size() -1; i++) {\n-            Object value = resultMap.get(path.get(i));\n-            if (value == null) {\n-                throw new InvalidAggregationPathException(\"Cannot find an key [\" + path.get(i) + \"] in \" + path);\n-            }\n-\n-            if (value instanceof Map<?, ?>) {\n-                resultMap = (Map<String, Object>)value;\n+        if (path.isEmpty()) {\n+            return this;\n+        } else if (path.size() == 1) {\n+            String field = path.get(0);\n+            if (CommonFields.VALUE.getPreferredName().equals(field)) {\n+                if (inferenceResult instanceof ClassificationInferenceResults) {\n+                    return ((ClassificationInferenceResults)inferenceResult).transformedPredictedValue();\n+                } else if (inferenceResult instanceof SingleValueInferenceResults) {\n+                    return ((SingleValueInferenceResults)inferenceResult).value();\n+                } else {\n+                    return null;\n+                }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTYzMzg2Mg=="}, "originalCommit": {"oid": "ab6e17850c7623cfec2ee7f0cdc51f8864d5dcb5"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3NjY4NTU4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/aggs/InternalInferenceAggregation.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNToxMzoxOFrOGo_Yhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNTo0MzoxMVrOGpAphA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTYzNDY5NA==", "bodyText": "awe snap! Since we are handling the paths...I wonder if we could handle paths like feature_importance.0.importance and feature_importance.0.feature_name", "url": "https://github.com/elastic/elasticsearch/pull/58193#discussion_r445634694", "createdAt": "2020-06-25T15:13:18Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/aggs/InternalInferenceAggregation.java", "diffHunk": "@@ -48,24 +51,44 @@ public InternalAggregation reduce(List<InternalAggregation> aggregations, Reduce\n     }\n \n     @Override\n-    @SuppressWarnings(\"unchecked\")\n     public Object getProperty(List<String> path) {\n-        Map<String, Object> resultMap = this.inferenceResult.writeResultToMap();\n-\n-        for (int i=0; i<path.size() -1; i++) {\n-            Object value = resultMap.get(path.get(i));\n-            if (value == null) {\n-                throw new InvalidAggregationPathException(\"Cannot find an key [\" + path.get(i) + \"] in \" + path);\n-            }\n-\n-            if (value instanceof Map<?, ?>) {\n-                resultMap = (Map<String, Object>)value;\n+        if (path.isEmpty()) {\n+            return this;\n+        } else if (path.size() == 1) {\n+            String field = path.get(0);\n+            if (CommonFields.VALUE.getPreferredName().equals(field)) {\n+                if (inferenceResult instanceof ClassificationInferenceResults) {\n+                    return ((ClassificationInferenceResults)inferenceResult).transformedPredictedValue();\n+                } else if (inferenceResult instanceof SingleValueInferenceResults) {\n+                    return ((SingleValueInferenceResults)inferenceResult).value();\n+                } else {\n+                    return null;\n+                }\n+            } else if (SingleValueInferenceResults.FEATURE_IMPORTANCE.equals(field)) {\n+                if (inferenceResult instanceof SingleValueInferenceResults) {\n+                    SingleValueInferenceResults valueResult = (SingleValueInferenceResults) inferenceResult;\n+                    return valueResult.getFeatureImportance();\n+                } else {\n+                    return null;\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab6e17850c7623cfec2ee7f0cdc51f8864d5dcb5"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY0NjY0Nw==", "bodyText": "The original implementation I had converted the result to a map which the code would navigate through using the split path so it was more generic as you suggested. I actually changed that so I could take a few lines of code out of this PR.\nThe only use of this method I could find is in a Bucket Selector which will only work with Doubles so I though this was sufficient in the first case.\nI'm open to the change though, maybe in the follow up PR?", "url": "https://github.com/elastic/elasticsearch/pull/58193#discussion_r445646647", "createdAt": "2020-06-25T15:29:50Z", "author": {"login": "davidkyle"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/aggs/InternalInferenceAggregation.java", "diffHunk": "@@ -48,24 +51,44 @@ public InternalAggregation reduce(List<InternalAggregation> aggregations, Reduce\n     }\n \n     @Override\n-    @SuppressWarnings(\"unchecked\")\n     public Object getProperty(List<String> path) {\n-        Map<String, Object> resultMap = this.inferenceResult.writeResultToMap();\n-\n-        for (int i=0; i<path.size() -1; i++) {\n-            Object value = resultMap.get(path.get(i));\n-            if (value == null) {\n-                throw new InvalidAggregationPathException(\"Cannot find an key [\" + path.get(i) + \"] in \" + path);\n-            }\n-\n-            if (value instanceof Map<?, ?>) {\n-                resultMap = (Map<String, Object>)value;\n+        if (path.isEmpty()) {\n+            return this;\n+        } else if (path.size() == 1) {\n+            String field = path.get(0);\n+            if (CommonFields.VALUE.getPreferredName().equals(field)) {\n+                if (inferenceResult instanceof ClassificationInferenceResults) {\n+                    return ((ClassificationInferenceResults)inferenceResult).transformedPredictedValue();\n+                } else if (inferenceResult instanceof SingleValueInferenceResults) {\n+                    return ((SingleValueInferenceResults)inferenceResult).value();\n+                } else {\n+                    return null;\n+                }\n+            } else if (SingleValueInferenceResults.FEATURE_IMPORTANCE.equals(field)) {\n+                if (inferenceResult instanceof SingleValueInferenceResults) {\n+                    SingleValueInferenceResults valueResult = (SingleValueInferenceResults) inferenceResult;\n+                    return valueResult.getFeatureImportance();\n+                } else {\n+                    return null;\n+                }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTYzNDY5NA=="}, "originalCommit": {"oid": "ab6e17850c7623cfec2ee7f0cdc51f8864d5dcb5"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY1NTQyOA==", "bodyText": "Follow up PR would be good.\nBucket select for when the most important feature is > X or when top class probability/score is > X would be neat!", "url": "https://github.com/elastic/elasticsearch/pull/58193#discussion_r445655428", "createdAt": "2020-06-25T15:43:11Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/aggs/InternalInferenceAggregation.java", "diffHunk": "@@ -48,24 +51,44 @@ public InternalAggregation reduce(List<InternalAggregation> aggregations, Reduce\n     }\n \n     @Override\n-    @SuppressWarnings(\"unchecked\")\n     public Object getProperty(List<String> path) {\n-        Map<String, Object> resultMap = this.inferenceResult.writeResultToMap();\n-\n-        for (int i=0; i<path.size() -1; i++) {\n-            Object value = resultMap.get(path.get(i));\n-            if (value == null) {\n-                throw new InvalidAggregationPathException(\"Cannot find an key [\" + path.get(i) + \"] in \" + path);\n-            }\n-\n-            if (value instanceof Map<?, ?>) {\n-                resultMap = (Map<String, Object>)value;\n+        if (path.isEmpty()) {\n+            return this;\n+        } else if (path.size() == 1) {\n+            String field = path.get(0);\n+            if (CommonFields.VALUE.getPreferredName().equals(field)) {\n+                if (inferenceResult instanceof ClassificationInferenceResults) {\n+                    return ((ClassificationInferenceResults)inferenceResult).transformedPredictedValue();\n+                } else if (inferenceResult instanceof SingleValueInferenceResults) {\n+                    return ((SingleValueInferenceResults)inferenceResult).value();\n+                } else {\n+                    return null;\n+                }\n+            } else if (SingleValueInferenceResults.FEATURE_IMPORTANCE.equals(field)) {\n+                if (inferenceResult instanceof SingleValueInferenceResults) {\n+                    SingleValueInferenceResults valueResult = (SingleValueInferenceResults) inferenceResult;\n+                    return valueResult.getFeatureImportance();\n+                } else {\n+                    return null;\n+                }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTYzNDY5NA=="}, "originalCommit": {"oid": "ab6e17850c7623cfec2ee7f0cdc51f8864d5dcb5"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3NjY4OTg5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/aggs/InternalInferenceAggregation.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNToxNDoxNFrOGo_bMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNToxNDoxNFrOGo_bMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTYzNTM3OA==", "bodyText": "similar to the feature_importance path. Could we support getting the top class probability?", "url": "https://github.com/elastic/elasticsearch/pull/58193#discussion_r445635378", "createdAt": "2020-06-25T15:14:14Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/aggs/InternalInferenceAggregation.java", "diffHunk": "@@ -48,24 +51,44 @@ public InternalAggregation reduce(List<InternalAggregation> aggregations, Reduce\n     }\n \n     @Override\n-    @SuppressWarnings(\"unchecked\")\n     public Object getProperty(List<String> path) {\n-        Map<String, Object> resultMap = this.inferenceResult.writeResultToMap();\n-\n-        for (int i=0; i<path.size() -1; i++) {\n-            Object value = resultMap.get(path.get(i));\n-            if (value == null) {\n-                throw new InvalidAggregationPathException(\"Cannot find an key [\" + path.get(i) + \"] in \" + path);\n-            }\n-\n-            if (value instanceof Map<?, ?>) {\n-                resultMap = (Map<String, Object>)value;\n+        if (path.isEmpty()) {\n+            return this;\n+        } else if (path.size() == 1) {\n+            String field = path.get(0);\n+            if (CommonFields.VALUE.getPreferredName().equals(field)) {\n+                if (inferenceResult instanceof ClassificationInferenceResults) {\n+                    return ((ClassificationInferenceResults)inferenceResult).transformedPredictedValue();\n+                } else if (inferenceResult instanceof SingleValueInferenceResults) {\n+                    return ((SingleValueInferenceResults)inferenceResult).value();\n+                } else {\n+                    return null;\n+                }\n+            } else if (SingleValueInferenceResults.FEATURE_IMPORTANCE.equals(field)) {\n+                if (inferenceResult instanceof SingleValueInferenceResults) {\n+                    SingleValueInferenceResults valueResult = (SingleValueInferenceResults) inferenceResult;\n+                    return valueResult.getFeatureImportance();\n+                } else {\n+                    return null;\n+                }\n+            } else if (ClassificationConfig.DEFAULT_TOP_CLASSES_RESULTS_FIELD.equals(field)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab6e17850c7623cfec2ee7f0cdc51f8864d5dcb5"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3Njg4MjY0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/aggs/InferencePipelineAggregationBuilder.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNjowMDoxNVrOGpBW2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQyMjoxODo1OFrOGqkZmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY2NzAzMg==", "bodyText": "Since it only accepts skip, you could just remove the option from the parser and hardcode it.", "url": "https://github.com/elastic/elasticsearch/pull/58193#discussion_r445667032", "createdAt": "2020-06-25T16:00:15Z", "author": {"login": "polyfractal"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/aggs/InferencePipelineAggregationBuilder.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ml.inference.aggs;\n+\n+import org.apache.lucene.util.SetOnce;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.LatchedActionListener;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.collect.Tuple;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.search.aggregations.pipeline.AbstractPipelineAggregationBuilder;\n+import org.elasticsearch.search.aggregations.pipeline.BucketHelpers;\n+import org.elasticsearch.search.aggregations.pipeline.PipelineAggregator;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.ClassificationConfig;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.ClassificationConfigUpdate;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.InferenceConfigUpdate;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.ResultsFieldUpdate;\n+import org.elasticsearch.xpack.core.ml.utils.ExceptionsHelper;\n+import org.elasticsearch.xpack.ml.inference.loadingservice.Model;\n+import org.elasticsearch.xpack.ml.inference.loadingservice.ModelLoadingService;\n+\n+import java.io.IOException;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.TreeMap;\n+import java.util.concurrent.CountDownLatch;\n+\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.constructorArg;\n+import static org.elasticsearch.search.aggregations.pipeline.PipelineAggregator.Parser.GAP_POLICY;\n+\n+public class InferencePipelineAggregationBuilder extends AbstractPipelineAggregationBuilder<InferencePipelineAggregationBuilder> {\n+\n+    public static String NAME = \"inference\";\n+\n+    public static final ParseField MODEL_ID = new ParseField(\"model_id\");\n+    private static final ParseField INFERENCE_CONFIG = new ParseField(\"inference_config\");\n+\n+    static String AGGREGATIONS_RESULTS_FIELD = \"value\";\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static final ConstructingObjectParser<InferencePipelineAggregationBuilder,\n+        Tuple<SetOnce<ModelLoadingService>, String>> PARSER = new ConstructingObjectParser<>(\n+        NAME, false,\n+        (args, context) -> new InferencePipelineAggregationBuilder(context.v2(), context.v1(), (Map<String, String>) args[0])\n+    );\n+\n+    static {\n+        PARSER.declareObject(constructorArg(), (p, c) -> p.mapStrings(), BUCKETS_PATH_FIELD);\n+        PARSER.declareString(InferencePipelineAggregationBuilder::setModelId, MODEL_ID);\n+        PARSER.declareNamedObject(InferencePipelineAggregationBuilder::setInferenceConfig,\n+            (p, c, n) -> p.namedObject(InferenceConfigUpdate.class, n, c), INFERENCE_CONFIG);\n+        PARSER.declareField(InferencePipelineAggregationBuilder::setGapPolicy, p -> {\n+            if (p.currentToken() == XContentParser.Token.VALUE_STRING) {\n+                return BucketHelpers.GapPolicy.parse(p.text().toLowerCase(Locale.ROOT), p.getTokenLocation());\n+            }\n+            throw new IllegalArgumentException(\n+                \"Unsupported token [\" + p.currentToken() + \"] parsing inference aggregation \" + GAP_POLICY.getPreferredName());\n+        }, GAP_POLICY, ObjectParser.ValueType.STRING);\n+    }\n+\n+    private final Map<String, String> bucketPathMap;\n+    private String modelId;\n+    private InferenceConfigUpdate inferenceConfig;\n+    private final SetOnce<ModelLoadingService> modelLoadingService;\n+    private BucketHelpers.GapPolicy gapPolicy = BucketHelpers.GapPolicy.SKIP;\n+\n+    public static InferencePipelineAggregationBuilder parse(SetOnce<ModelLoadingService> modelLoadingService,\n+                                                            String pipelineAggregatorName,\n+                                                            XContentParser parser) {\n+        Tuple<SetOnce<ModelLoadingService>, String> context = new Tuple<>(modelLoadingService, pipelineAggregatorName);\n+        return PARSER.apply(parser, context);\n+    }\n+\n+    public InferencePipelineAggregationBuilder(String name, SetOnce<ModelLoadingService> modelLoadingService,\n+                                               Map<String, String> bucketsPath) {\n+        super(name, NAME, new TreeMap<>(bucketsPath).values().toArray(new String[] {}));\n+        this.modelLoadingService = modelLoadingService;\n+        this.bucketPathMap = bucketsPath;\n+    }\n+\n+    public InferencePipelineAggregationBuilder(StreamInput in, SetOnce<ModelLoadingService> modelLoadingService) throws IOException {\n+        super(in, NAME);\n+        modelId = in.readString();\n+        bucketPathMap = in.readMap(StreamInput::readString, StreamInput::readString);\n+        inferenceConfig = in.readOptionalNamedWriteable(InferenceConfigUpdate.class);\n+        gapPolicy = BucketHelpers.GapPolicy.readFrom(in);\n+        this.modelLoadingService = modelLoadingService;\n+    }\n+\n+    void setModelId(String modelId) {\n+        this.modelId = modelId;\n+    }\n+\n+    void setInferenceConfig(InferenceConfigUpdate inferenceConfig) {\n+        this.inferenceConfig = inferenceConfig;\n+    }\n+\n+    void setGapPolicy(BucketHelpers.GapPolicy gapPolicy) {\n+        this.gapPolicy = gapPolicy;\n+    }\n+\n+    @Override\n+    protected void validate(ValidationContext context) {\n+        context.validateHasParent(NAME, name);\n+        if (modelId == null) {\n+            context.addValidationError(\"Model Id must be set\");\n+        }\n+        if (gapPolicy != BucketHelpers.GapPolicy.SKIP) {\n+            context.addValidationError(\"gap policy [\" + gapPolicy + \"] in not valid for [\" + NAME + \"] aggregation\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "285ae40134507395bb022490ab4e09bd24acd439"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI4MTg2MQ==", "bodyText": "GapPolicy is a common setting, it feels a little underhand to silently ignore the setting and rewrite it to skip.", "url": "https://github.com/elastic/elasticsearch/pull/58193#discussion_r446281861", "createdAt": "2020-06-26T16:19:45Z", "author": {"login": "davidkyle"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/aggs/InferencePipelineAggregationBuilder.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ml.inference.aggs;\n+\n+import org.apache.lucene.util.SetOnce;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.LatchedActionListener;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.collect.Tuple;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.search.aggregations.pipeline.AbstractPipelineAggregationBuilder;\n+import org.elasticsearch.search.aggregations.pipeline.BucketHelpers;\n+import org.elasticsearch.search.aggregations.pipeline.PipelineAggregator;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.ClassificationConfig;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.ClassificationConfigUpdate;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.InferenceConfigUpdate;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.ResultsFieldUpdate;\n+import org.elasticsearch.xpack.core.ml.utils.ExceptionsHelper;\n+import org.elasticsearch.xpack.ml.inference.loadingservice.Model;\n+import org.elasticsearch.xpack.ml.inference.loadingservice.ModelLoadingService;\n+\n+import java.io.IOException;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.TreeMap;\n+import java.util.concurrent.CountDownLatch;\n+\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.constructorArg;\n+import static org.elasticsearch.search.aggregations.pipeline.PipelineAggregator.Parser.GAP_POLICY;\n+\n+public class InferencePipelineAggregationBuilder extends AbstractPipelineAggregationBuilder<InferencePipelineAggregationBuilder> {\n+\n+    public static String NAME = \"inference\";\n+\n+    public static final ParseField MODEL_ID = new ParseField(\"model_id\");\n+    private static final ParseField INFERENCE_CONFIG = new ParseField(\"inference_config\");\n+\n+    static String AGGREGATIONS_RESULTS_FIELD = \"value\";\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static final ConstructingObjectParser<InferencePipelineAggregationBuilder,\n+        Tuple<SetOnce<ModelLoadingService>, String>> PARSER = new ConstructingObjectParser<>(\n+        NAME, false,\n+        (args, context) -> new InferencePipelineAggregationBuilder(context.v2(), context.v1(), (Map<String, String>) args[0])\n+    );\n+\n+    static {\n+        PARSER.declareObject(constructorArg(), (p, c) -> p.mapStrings(), BUCKETS_PATH_FIELD);\n+        PARSER.declareString(InferencePipelineAggregationBuilder::setModelId, MODEL_ID);\n+        PARSER.declareNamedObject(InferencePipelineAggregationBuilder::setInferenceConfig,\n+            (p, c, n) -> p.namedObject(InferenceConfigUpdate.class, n, c), INFERENCE_CONFIG);\n+        PARSER.declareField(InferencePipelineAggregationBuilder::setGapPolicy, p -> {\n+            if (p.currentToken() == XContentParser.Token.VALUE_STRING) {\n+                return BucketHelpers.GapPolicy.parse(p.text().toLowerCase(Locale.ROOT), p.getTokenLocation());\n+            }\n+            throw new IllegalArgumentException(\n+                \"Unsupported token [\" + p.currentToken() + \"] parsing inference aggregation \" + GAP_POLICY.getPreferredName());\n+        }, GAP_POLICY, ObjectParser.ValueType.STRING);\n+    }\n+\n+    private final Map<String, String> bucketPathMap;\n+    private String modelId;\n+    private InferenceConfigUpdate inferenceConfig;\n+    private final SetOnce<ModelLoadingService> modelLoadingService;\n+    private BucketHelpers.GapPolicy gapPolicy = BucketHelpers.GapPolicy.SKIP;\n+\n+    public static InferencePipelineAggregationBuilder parse(SetOnce<ModelLoadingService> modelLoadingService,\n+                                                            String pipelineAggregatorName,\n+                                                            XContentParser parser) {\n+        Tuple<SetOnce<ModelLoadingService>, String> context = new Tuple<>(modelLoadingService, pipelineAggregatorName);\n+        return PARSER.apply(parser, context);\n+    }\n+\n+    public InferencePipelineAggregationBuilder(String name, SetOnce<ModelLoadingService> modelLoadingService,\n+                                               Map<String, String> bucketsPath) {\n+        super(name, NAME, new TreeMap<>(bucketsPath).values().toArray(new String[] {}));\n+        this.modelLoadingService = modelLoadingService;\n+        this.bucketPathMap = bucketsPath;\n+    }\n+\n+    public InferencePipelineAggregationBuilder(StreamInput in, SetOnce<ModelLoadingService> modelLoadingService) throws IOException {\n+        super(in, NAME);\n+        modelId = in.readString();\n+        bucketPathMap = in.readMap(StreamInput::readString, StreamInput::readString);\n+        inferenceConfig = in.readOptionalNamedWriteable(InferenceConfigUpdate.class);\n+        gapPolicy = BucketHelpers.GapPolicy.readFrom(in);\n+        this.modelLoadingService = modelLoadingService;\n+    }\n+\n+    void setModelId(String modelId) {\n+        this.modelId = modelId;\n+    }\n+\n+    void setInferenceConfig(InferenceConfigUpdate inferenceConfig) {\n+        this.inferenceConfig = inferenceConfig;\n+    }\n+\n+    void setGapPolicy(BucketHelpers.GapPolicy gapPolicy) {\n+        this.gapPolicy = gapPolicy;\n+    }\n+\n+    @Override\n+    protected void validate(ValidationContext context) {\n+        context.validateHasParent(NAME, name);\n+        if (modelId == null) {\n+            context.addValidationError(\"Model Id must be set\");\n+        }\n+        if (gapPolicy != BucketHelpers.GapPolicy.SKIP) {\n+            context.addValidationError(\"gap policy [\" + gapPolicy + \"] in not valid for [\" + NAME + \"] aggregation\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY2NzAzMg=="}, "originalCommit": {"oid": "285ae40134507395bb022490ab4e09bd24acd439"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjMwMzY4MQ==", "bodyText": "I think we'd just make it not something the parser recognized at all. Lots of aggs don't have a gap policy.", "url": "https://github.com/elastic/elasticsearch/pull/58193#discussion_r446303681", "createdAt": "2020-06-26T17:01:50Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/aggs/InferencePipelineAggregationBuilder.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ml.inference.aggs;\n+\n+import org.apache.lucene.util.SetOnce;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.LatchedActionListener;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.collect.Tuple;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.search.aggregations.pipeline.AbstractPipelineAggregationBuilder;\n+import org.elasticsearch.search.aggregations.pipeline.BucketHelpers;\n+import org.elasticsearch.search.aggregations.pipeline.PipelineAggregator;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.ClassificationConfig;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.ClassificationConfigUpdate;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.InferenceConfigUpdate;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.ResultsFieldUpdate;\n+import org.elasticsearch.xpack.core.ml.utils.ExceptionsHelper;\n+import org.elasticsearch.xpack.ml.inference.loadingservice.Model;\n+import org.elasticsearch.xpack.ml.inference.loadingservice.ModelLoadingService;\n+\n+import java.io.IOException;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.TreeMap;\n+import java.util.concurrent.CountDownLatch;\n+\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.constructorArg;\n+import static org.elasticsearch.search.aggregations.pipeline.PipelineAggregator.Parser.GAP_POLICY;\n+\n+public class InferencePipelineAggregationBuilder extends AbstractPipelineAggregationBuilder<InferencePipelineAggregationBuilder> {\n+\n+    public static String NAME = \"inference\";\n+\n+    public static final ParseField MODEL_ID = new ParseField(\"model_id\");\n+    private static final ParseField INFERENCE_CONFIG = new ParseField(\"inference_config\");\n+\n+    static String AGGREGATIONS_RESULTS_FIELD = \"value\";\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static final ConstructingObjectParser<InferencePipelineAggregationBuilder,\n+        Tuple<SetOnce<ModelLoadingService>, String>> PARSER = new ConstructingObjectParser<>(\n+        NAME, false,\n+        (args, context) -> new InferencePipelineAggregationBuilder(context.v2(), context.v1(), (Map<String, String>) args[0])\n+    );\n+\n+    static {\n+        PARSER.declareObject(constructorArg(), (p, c) -> p.mapStrings(), BUCKETS_PATH_FIELD);\n+        PARSER.declareString(InferencePipelineAggregationBuilder::setModelId, MODEL_ID);\n+        PARSER.declareNamedObject(InferencePipelineAggregationBuilder::setInferenceConfig,\n+            (p, c, n) -> p.namedObject(InferenceConfigUpdate.class, n, c), INFERENCE_CONFIG);\n+        PARSER.declareField(InferencePipelineAggregationBuilder::setGapPolicy, p -> {\n+            if (p.currentToken() == XContentParser.Token.VALUE_STRING) {\n+                return BucketHelpers.GapPolicy.parse(p.text().toLowerCase(Locale.ROOT), p.getTokenLocation());\n+            }\n+            throw new IllegalArgumentException(\n+                \"Unsupported token [\" + p.currentToken() + \"] parsing inference aggregation \" + GAP_POLICY.getPreferredName());\n+        }, GAP_POLICY, ObjectParser.ValueType.STRING);\n+    }\n+\n+    private final Map<String, String> bucketPathMap;\n+    private String modelId;\n+    private InferenceConfigUpdate inferenceConfig;\n+    private final SetOnce<ModelLoadingService> modelLoadingService;\n+    private BucketHelpers.GapPolicy gapPolicy = BucketHelpers.GapPolicy.SKIP;\n+\n+    public static InferencePipelineAggregationBuilder parse(SetOnce<ModelLoadingService> modelLoadingService,\n+                                                            String pipelineAggregatorName,\n+                                                            XContentParser parser) {\n+        Tuple<SetOnce<ModelLoadingService>, String> context = new Tuple<>(modelLoadingService, pipelineAggregatorName);\n+        return PARSER.apply(parser, context);\n+    }\n+\n+    public InferencePipelineAggregationBuilder(String name, SetOnce<ModelLoadingService> modelLoadingService,\n+                                               Map<String, String> bucketsPath) {\n+        super(name, NAME, new TreeMap<>(bucketsPath).values().toArray(new String[] {}));\n+        this.modelLoadingService = modelLoadingService;\n+        this.bucketPathMap = bucketsPath;\n+    }\n+\n+    public InferencePipelineAggregationBuilder(StreamInput in, SetOnce<ModelLoadingService> modelLoadingService) throws IOException {\n+        super(in, NAME);\n+        modelId = in.readString();\n+        bucketPathMap = in.readMap(StreamInput::readString, StreamInput::readString);\n+        inferenceConfig = in.readOptionalNamedWriteable(InferenceConfigUpdate.class);\n+        gapPolicy = BucketHelpers.GapPolicy.readFrom(in);\n+        this.modelLoadingService = modelLoadingService;\n+    }\n+\n+    void setModelId(String modelId) {\n+        this.modelId = modelId;\n+    }\n+\n+    void setInferenceConfig(InferenceConfigUpdate inferenceConfig) {\n+        this.inferenceConfig = inferenceConfig;\n+    }\n+\n+    void setGapPolicy(BucketHelpers.GapPolicy gapPolicy) {\n+        this.gapPolicy = gapPolicy;\n+    }\n+\n+    @Override\n+    protected void validate(ValidationContext context) {\n+        context.validateHasParent(NAME, name);\n+        if (modelId == null) {\n+            context.addValidationError(\"Model Id must be set\");\n+        }\n+        if (gapPolicy != BucketHelpers.GapPolicy.SKIP) {\n+            context.addValidationError(\"gap policy [\" + gapPolicy + \"] in not valid for [\" + NAME + \"] aggregation\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY2NzAzMg=="}, "originalCommit": {"oid": "285ae40134507395bb022490ab4e09bd24acd439"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA5MjY0MA==", "bodyText": "Yep, I meant removing it from the parser, so it'd throw an exception if the user tried to set it.  Most pipeline aggs have a gap_policy but it's not a required feature of pipelines by any means.", "url": "https://github.com/elastic/elasticsearch/pull/58193#discussion_r447092640", "createdAt": "2020-06-29T16:17:58Z", "author": {"login": "polyfractal"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/aggs/InferencePipelineAggregationBuilder.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ml.inference.aggs;\n+\n+import org.apache.lucene.util.SetOnce;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.LatchedActionListener;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.collect.Tuple;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.search.aggregations.pipeline.AbstractPipelineAggregationBuilder;\n+import org.elasticsearch.search.aggregations.pipeline.BucketHelpers;\n+import org.elasticsearch.search.aggregations.pipeline.PipelineAggregator;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.ClassificationConfig;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.ClassificationConfigUpdate;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.InferenceConfigUpdate;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.ResultsFieldUpdate;\n+import org.elasticsearch.xpack.core.ml.utils.ExceptionsHelper;\n+import org.elasticsearch.xpack.ml.inference.loadingservice.Model;\n+import org.elasticsearch.xpack.ml.inference.loadingservice.ModelLoadingService;\n+\n+import java.io.IOException;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.TreeMap;\n+import java.util.concurrent.CountDownLatch;\n+\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.constructorArg;\n+import static org.elasticsearch.search.aggregations.pipeline.PipelineAggregator.Parser.GAP_POLICY;\n+\n+public class InferencePipelineAggregationBuilder extends AbstractPipelineAggregationBuilder<InferencePipelineAggregationBuilder> {\n+\n+    public static String NAME = \"inference\";\n+\n+    public static final ParseField MODEL_ID = new ParseField(\"model_id\");\n+    private static final ParseField INFERENCE_CONFIG = new ParseField(\"inference_config\");\n+\n+    static String AGGREGATIONS_RESULTS_FIELD = \"value\";\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static final ConstructingObjectParser<InferencePipelineAggregationBuilder,\n+        Tuple<SetOnce<ModelLoadingService>, String>> PARSER = new ConstructingObjectParser<>(\n+        NAME, false,\n+        (args, context) -> new InferencePipelineAggregationBuilder(context.v2(), context.v1(), (Map<String, String>) args[0])\n+    );\n+\n+    static {\n+        PARSER.declareObject(constructorArg(), (p, c) -> p.mapStrings(), BUCKETS_PATH_FIELD);\n+        PARSER.declareString(InferencePipelineAggregationBuilder::setModelId, MODEL_ID);\n+        PARSER.declareNamedObject(InferencePipelineAggregationBuilder::setInferenceConfig,\n+            (p, c, n) -> p.namedObject(InferenceConfigUpdate.class, n, c), INFERENCE_CONFIG);\n+        PARSER.declareField(InferencePipelineAggregationBuilder::setGapPolicy, p -> {\n+            if (p.currentToken() == XContentParser.Token.VALUE_STRING) {\n+                return BucketHelpers.GapPolicy.parse(p.text().toLowerCase(Locale.ROOT), p.getTokenLocation());\n+            }\n+            throw new IllegalArgumentException(\n+                \"Unsupported token [\" + p.currentToken() + \"] parsing inference aggregation \" + GAP_POLICY.getPreferredName());\n+        }, GAP_POLICY, ObjectParser.ValueType.STRING);\n+    }\n+\n+    private final Map<String, String> bucketPathMap;\n+    private String modelId;\n+    private InferenceConfigUpdate inferenceConfig;\n+    private final SetOnce<ModelLoadingService> modelLoadingService;\n+    private BucketHelpers.GapPolicy gapPolicy = BucketHelpers.GapPolicy.SKIP;\n+\n+    public static InferencePipelineAggregationBuilder parse(SetOnce<ModelLoadingService> modelLoadingService,\n+                                                            String pipelineAggregatorName,\n+                                                            XContentParser parser) {\n+        Tuple<SetOnce<ModelLoadingService>, String> context = new Tuple<>(modelLoadingService, pipelineAggregatorName);\n+        return PARSER.apply(parser, context);\n+    }\n+\n+    public InferencePipelineAggregationBuilder(String name, SetOnce<ModelLoadingService> modelLoadingService,\n+                                               Map<String, String> bucketsPath) {\n+        super(name, NAME, new TreeMap<>(bucketsPath).values().toArray(new String[] {}));\n+        this.modelLoadingService = modelLoadingService;\n+        this.bucketPathMap = bucketsPath;\n+    }\n+\n+    public InferencePipelineAggregationBuilder(StreamInput in, SetOnce<ModelLoadingService> modelLoadingService) throws IOException {\n+        super(in, NAME);\n+        modelId = in.readString();\n+        bucketPathMap = in.readMap(StreamInput::readString, StreamInput::readString);\n+        inferenceConfig = in.readOptionalNamedWriteable(InferenceConfigUpdate.class);\n+        gapPolicy = BucketHelpers.GapPolicy.readFrom(in);\n+        this.modelLoadingService = modelLoadingService;\n+    }\n+\n+    void setModelId(String modelId) {\n+        this.modelId = modelId;\n+    }\n+\n+    void setInferenceConfig(InferenceConfigUpdate inferenceConfig) {\n+        this.inferenceConfig = inferenceConfig;\n+    }\n+\n+    void setGapPolicy(BucketHelpers.GapPolicy gapPolicy) {\n+        this.gapPolicy = gapPolicy;\n+    }\n+\n+    @Override\n+    protected void validate(ValidationContext context) {\n+        context.validateHasParent(NAME, name);\n+        if (modelId == null) {\n+            context.addValidationError(\"Model Id must be set\");\n+        }\n+        if (gapPolicy != BucketHelpers.GapPolicy.SKIP) {\n+            context.addValidationError(\"gap policy [\" + gapPolicy + \"] in not valid for [\" + NAME + \"] aggregation\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY2NzAzMg=="}, "originalCommit": {"oid": "285ae40134507395bb022490ab4e09bd24acd439"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzI4OTc1Mg==", "bodyText": "\ud83d\udc4d  I assumed pipeline aggs must accept a gap_policy but that doesn't make sense in every case.\nThe code was silly anyway I was parsing the field validating it then never reading the setting again. It's gone now.", "url": "https://github.com/elastic/elasticsearch/pull/58193#discussion_r447289752", "createdAt": "2020-06-29T22:18:58Z", "author": {"login": "davidkyle"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/aggs/InferencePipelineAggregationBuilder.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ml.inference.aggs;\n+\n+import org.apache.lucene.util.SetOnce;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.LatchedActionListener;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.collect.Tuple;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.search.aggregations.pipeline.AbstractPipelineAggregationBuilder;\n+import org.elasticsearch.search.aggregations.pipeline.BucketHelpers;\n+import org.elasticsearch.search.aggregations.pipeline.PipelineAggregator;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.ClassificationConfig;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.ClassificationConfigUpdate;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.InferenceConfigUpdate;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.ResultsFieldUpdate;\n+import org.elasticsearch.xpack.core.ml.utils.ExceptionsHelper;\n+import org.elasticsearch.xpack.ml.inference.loadingservice.Model;\n+import org.elasticsearch.xpack.ml.inference.loadingservice.ModelLoadingService;\n+\n+import java.io.IOException;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.TreeMap;\n+import java.util.concurrent.CountDownLatch;\n+\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.constructorArg;\n+import static org.elasticsearch.search.aggregations.pipeline.PipelineAggregator.Parser.GAP_POLICY;\n+\n+public class InferencePipelineAggregationBuilder extends AbstractPipelineAggregationBuilder<InferencePipelineAggregationBuilder> {\n+\n+    public static String NAME = \"inference\";\n+\n+    public static final ParseField MODEL_ID = new ParseField(\"model_id\");\n+    private static final ParseField INFERENCE_CONFIG = new ParseField(\"inference_config\");\n+\n+    static String AGGREGATIONS_RESULTS_FIELD = \"value\";\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static final ConstructingObjectParser<InferencePipelineAggregationBuilder,\n+        Tuple<SetOnce<ModelLoadingService>, String>> PARSER = new ConstructingObjectParser<>(\n+        NAME, false,\n+        (args, context) -> new InferencePipelineAggregationBuilder(context.v2(), context.v1(), (Map<String, String>) args[0])\n+    );\n+\n+    static {\n+        PARSER.declareObject(constructorArg(), (p, c) -> p.mapStrings(), BUCKETS_PATH_FIELD);\n+        PARSER.declareString(InferencePipelineAggregationBuilder::setModelId, MODEL_ID);\n+        PARSER.declareNamedObject(InferencePipelineAggregationBuilder::setInferenceConfig,\n+            (p, c, n) -> p.namedObject(InferenceConfigUpdate.class, n, c), INFERENCE_CONFIG);\n+        PARSER.declareField(InferencePipelineAggregationBuilder::setGapPolicy, p -> {\n+            if (p.currentToken() == XContentParser.Token.VALUE_STRING) {\n+                return BucketHelpers.GapPolicy.parse(p.text().toLowerCase(Locale.ROOT), p.getTokenLocation());\n+            }\n+            throw new IllegalArgumentException(\n+                \"Unsupported token [\" + p.currentToken() + \"] parsing inference aggregation \" + GAP_POLICY.getPreferredName());\n+        }, GAP_POLICY, ObjectParser.ValueType.STRING);\n+    }\n+\n+    private final Map<String, String> bucketPathMap;\n+    private String modelId;\n+    private InferenceConfigUpdate inferenceConfig;\n+    private final SetOnce<ModelLoadingService> modelLoadingService;\n+    private BucketHelpers.GapPolicy gapPolicy = BucketHelpers.GapPolicy.SKIP;\n+\n+    public static InferencePipelineAggregationBuilder parse(SetOnce<ModelLoadingService> modelLoadingService,\n+                                                            String pipelineAggregatorName,\n+                                                            XContentParser parser) {\n+        Tuple<SetOnce<ModelLoadingService>, String> context = new Tuple<>(modelLoadingService, pipelineAggregatorName);\n+        return PARSER.apply(parser, context);\n+    }\n+\n+    public InferencePipelineAggregationBuilder(String name, SetOnce<ModelLoadingService> modelLoadingService,\n+                                               Map<String, String> bucketsPath) {\n+        super(name, NAME, new TreeMap<>(bucketsPath).values().toArray(new String[] {}));\n+        this.modelLoadingService = modelLoadingService;\n+        this.bucketPathMap = bucketsPath;\n+    }\n+\n+    public InferencePipelineAggregationBuilder(StreamInput in, SetOnce<ModelLoadingService> modelLoadingService) throws IOException {\n+        super(in, NAME);\n+        modelId = in.readString();\n+        bucketPathMap = in.readMap(StreamInput::readString, StreamInput::readString);\n+        inferenceConfig = in.readOptionalNamedWriteable(InferenceConfigUpdate.class);\n+        gapPolicy = BucketHelpers.GapPolicy.readFrom(in);\n+        this.modelLoadingService = modelLoadingService;\n+    }\n+\n+    void setModelId(String modelId) {\n+        this.modelId = modelId;\n+    }\n+\n+    void setInferenceConfig(InferenceConfigUpdate inferenceConfig) {\n+        this.inferenceConfig = inferenceConfig;\n+    }\n+\n+    void setGapPolicy(BucketHelpers.GapPolicy gapPolicy) {\n+        this.gapPolicy = gapPolicy;\n+    }\n+\n+    @Override\n+    protected void validate(ValidationContext context) {\n+        context.validateHasParent(NAME, name);\n+        if (modelId == null) {\n+            context.addValidationError(\"Model Id must be set\");\n+        }\n+        if (gapPolicy != BucketHelpers.GapPolicy.SKIP) {\n+            context.addValidationError(\"gap policy [\" + gapPolicy + \"] in not valid for [\" + NAME + \"] aggregation\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY2NzAzMg=="}, "originalCommit": {"oid": "285ae40134507395bb022490ab4e09bd24acd439"}, "originalPosition": 120}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3Njk0MDk0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/aggs/InferencePipelineAggregationBuilder.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNjoxNDoxMFrOGpB7cw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxNjoyMDoxN1rOGpm5kw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY3NjQwMw==", "bodyText": "I don't know what any of this is doing :), but I wanted to mention that by time this is called a lot of work will have been done on the data nodes.  So if any of this validation can be done earlier (parsing, etc) it would save some work.", "url": "https://github.com/elastic/elasticsearch/pull/58193#discussion_r445676403", "createdAt": "2020-06-25T16:14:10Z", "author": {"login": "polyfractal"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/aggs/InferencePipelineAggregationBuilder.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ml.inference.aggs;\n+\n+import org.apache.lucene.util.SetOnce;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.LatchedActionListener;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.collect.Tuple;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.search.aggregations.pipeline.AbstractPipelineAggregationBuilder;\n+import org.elasticsearch.search.aggregations.pipeline.BucketHelpers;\n+import org.elasticsearch.search.aggregations.pipeline.PipelineAggregator;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.ClassificationConfig;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.ClassificationConfigUpdate;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.InferenceConfigUpdate;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.ResultsFieldUpdate;\n+import org.elasticsearch.xpack.core.ml.utils.ExceptionsHelper;\n+import org.elasticsearch.xpack.ml.inference.loadingservice.Model;\n+import org.elasticsearch.xpack.ml.inference.loadingservice.ModelLoadingService;\n+\n+import java.io.IOException;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.TreeMap;\n+import java.util.concurrent.CountDownLatch;\n+\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.constructorArg;\n+import static org.elasticsearch.search.aggregations.pipeline.PipelineAggregator.Parser.GAP_POLICY;\n+\n+public class InferencePipelineAggregationBuilder extends AbstractPipelineAggregationBuilder<InferencePipelineAggregationBuilder> {\n+\n+    public static String NAME = \"inference\";\n+\n+    public static final ParseField MODEL_ID = new ParseField(\"model_id\");\n+    private static final ParseField INFERENCE_CONFIG = new ParseField(\"inference_config\");\n+\n+    static String AGGREGATIONS_RESULTS_FIELD = \"value\";\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static final ConstructingObjectParser<InferencePipelineAggregationBuilder,\n+        Tuple<SetOnce<ModelLoadingService>, String>> PARSER = new ConstructingObjectParser<>(\n+        NAME, false,\n+        (args, context) -> new InferencePipelineAggregationBuilder(context.v2(), context.v1(), (Map<String, String>) args[0])\n+    );\n+\n+    static {\n+        PARSER.declareObject(constructorArg(), (p, c) -> p.mapStrings(), BUCKETS_PATH_FIELD);\n+        PARSER.declareString(InferencePipelineAggregationBuilder::setModelId, MODEL_ID);\n+        PARSER.declareNamedObject(InferencePipelineAggregationBuilder::setInferenceConfig,\n+            (p, c, n) -> p.namedObject(InferenceConfigUpdate.class, n, c), INFERENCE_CONFIG);\n+        PARSER.declareField(InferencePipelineAggregationBuilder::setGapPolicy, p -> {\n+            if (p.currentToken() == XContentParser.Token.VALUE_STRING) {\n+                return BucketHelpers.GapPolicy.parse(p.text().toLowerCase(Locale.ROOT), p.getTokenLocation());\n+            }\n+            throw new IllegalArgumentException(\n+                \"Unsupported token [\" + p.currentToken() + \"] parsing inference aggregation \" + GAP_POLICY.getPreferredName());\n+        }, GAP_POLICY, ObjectParser.ValueType.STRING);\n+    }\n+\n+    private final Map<String, String> bucketPathMap;\n+    private String modelId;\n+    private InferenceConfigUpdate inferenceConfig;\n+    private final SetOnce<ModelLoadingService> modelLoadingService;\n+    private BucketHelpers.GapPolicy gapPolicy = BucketHelpers.GapPolicy.SKIP;\n+\n+    public static InferencePipelineAggregationBuilder parse(SetOnce<ModelLoadingService> modelLoadingService,\n+                                                            String pipelineAggregatorName,\n+                                                            XContentParser parser) {\n+        Tuple<SetOnce<ModelLoadingService>, String> context = new Tuple<>(modelLoadingService, pipelineAggregatorName);\n+        return PARSER.apply(parser, context);\n+    }\n+\n+    public InferencePipelineAggregationBuilder(String name, SetOnce<ModelLoadingService> modelLoadingService,\n+                                               Map<String, String> bucketsPath) {\n+        super(name, NAME, new TreeMap<>(bucketsPath).values().toArray(new String[] {}));\n+        this.modelLoadingService = modelLoadingService;\n+        this.bucketPathMap = bucketsPath;\n+    }\n+\n+    public InferencePipelineAggregationBuilder(StreamInput in, SetOnce<ModelLoadingService> modelLoadingService) throws IOException {\n+        super(in, NAME);\n+        modelId = in.readString();\n+        bucketPathMap = in.readMap(StreamInput::readString, StreamInput::readString);\n+        inferenceConfig = in.readOptionalNamedWriteable(InferenceConfigUpdate.class);\n+        gapPolicy = BucketHelpers.GapPolicy.readFrom(in);\n+        this.modelLoadingService = modelLoadingService;\n+    }\n+\n+    void setModelId(String modelId) {\n+        this.modelId = modelId;\n+    }\n+\n+    void setInferenceConfig(InferenceConfigUpdate inferenceConfig) {\n+        this.inferenceConfig = inferenceConfig;\n+    }\n+\n+    void setGapPolicy(BucketHelpers.GapPolicy gapPolicy) {\n+        this.gapPolicy = gapPolicy;\n+    }\n+\n+    @Override\n+    protected void validate(ValidationContext context) {\n+        context.validateHasParent(NAME, name);\n+        if (modelId == null) {\n+            context.addValidationError(\"Model Id must be set\");\n+        }\n+        if (gapPolicy != BucketHelpers.GapPolicy.SKIP) {\n+            context.addValidationError(\"gap policy [\" + gapPolicy + \"] in not valid for [\" + NAME + \"] aggregation\");\n+        }\n+    }\n+\n+    @Override\n+    protected void doWriteTo(StreamOutput out) throws IOException {\n+        out.writeString(modelId);\n+        out.writeMap(bucketPathMap, StreamOutput::writeString, StreamOutput::writeString);\n+        out.writeOptionalNamedWriteable(inferenceConfig);\n+        gapPolicy.writeTo(out);\n+    }\n+\n+    @Override\n+    protected PipelineAggregator createInternal(Map<String, Object> metaData) {\n+\n+        SetOnce<Model> model = new SetOnce<>();\n+        SetOnce<Exception> error = new SetOnce<>();\n+        CountDownLatch latch = new CountDownLatch(1);\n+        ActionListener<Model> listener = new LatchedActionListener<>(\n+            ActionListener.wrap(model::set, error::set), latch);\n+\n+        modelLoadingService.get().getModelForSearch(modelId, listener);\n+        try {\n+            // TODO Avoid the blocking wait\n+            latch.await();\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            throw new RuntimeException(\"Inference aggregation interrupted loading model\", e);\n+        }\n+\n+        Exception e = error.get();\n+        if (e != null) {\n+            if (e instanceof RuntimeException) {\n+                throw (RuntimeException)e;\n+            } else {\n+                throw new RuntimeException(error.get());\n+            }\n+        }\n+\n+        InferenceConfigUpdate update = adaptForAggregation(inferenceConfig);\n+\n+        return new InferencePipelineAggregator(name, bucketPathMap, metaData, update, model.get());\n+    }\n+\n+    static InferenceConfigUpdate adaptForAggregation(InferenceConfigUpdate originalUpdate) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "285ae40134507395bb022490ab4e09bd24acd439"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI4MjEzMQ==", "bodyText": "Very good point I've moved these checks to the validate() method", "url": "https://github.com/elastic/elasticsearch/pull/58193#discussion_r446282131", "createdAt": "2020-06-26T16:20:17Z", "author": {"login": "davidkyle"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/aggs/InferencePipelineAggregationBuilder.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ml.inference.aggs;\n+\n+import org.apache.lucene.util.SetOnce;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.LatchedActionListener;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.collect.Tuple;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.search.aggregations.pipeline.AbstractPipelineAggregationBuilder;\n+import org.elasticsearch.search.aggregations.pipeline.BucketHelpers;\n+import org.elasticsearch.search.aggregations.pipeline.PipelineAggregator;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.ClassificationConfig;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.ClassificationConfigUpdate;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.InferenceConfigUpdate;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.ResultsFieldUpdate;\n+import org.elasticsearch.xpack.core.ml.utils.ExceptionsHelper;\n+import org.elasticsearch.xpack.ml.inference.loadingservice.Model;\n+import org.elasticsearch.xpack.ml.inference.loadingservice.ModelLoadingService;\n+\n+import java.io.IOException;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.TreeMap;\n+import java.util.concurrent.CountDownLatch;\n+\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.constructorArg;\n+import static org.elasticsearch.search.aggregations.pipeline.PipelineAggregator.Parser.GAP_POLICY;\n+\n+public class InferencePipelineAggregationBuilder extends AbstractPipelineAggregationBuilder<InferencePipelineAggregationBuilder> {\n+\n+    public static String NAME = \"inference\";\n+\n+    public static final ParseField MODEL_ID = new ParseField(\"model_id\");\n+    private static final ParseField INFERENCE_CONFIG = new ParseField(\"inference_config\");\n+\n+    static String AGGREGATIONS_RESULTS_FIELD = \"value\";\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static final ConstructingObjectParser<InferencePipelineAggregationBuilder,\n+        Tuple<SetOnce<ModelLoadingService>, String>> PARSER = new ConstructingObjectParser<>(\n+        NAME, false,\n+        (args, context) -> new InferencePipelineAggregationBuilder(context.v2(), context.v1(), (Map<String, String>) args[0])\n+    );\n+\n+    static {\n+        PARSER.declareObject(constructorArg(), (p, c) -> p.mapStrings(), BUCKETS_PATH_FIELD);\n+        PARSER.declareString(InferencePipelineAggregationBuilder::setModelId, MODEL_ID);\n+        PARSER.declareNamedObject(InferencePipelineAggregationBuilder::setInferenceConfig,\n+            (p, c, n) -> p.namedObject(InferenceConfigUpdate.class, n, c), INFERENCE_CONFIG);\n+        PARSER.declareField(InferencePipelineAggregationBuilder::setGapPolicy, p -> {\n+            if (p.currentToken() == XContentParser.Token.VALUE_STRING) {\n+                return BucketHelpers.GapPolicy.parse(p.text().toLowerCase(Locale.ROOT), p.getTokenLocation());\n+            }\n+            throw new IllegalArgumentException(\n+                \"Unsupported token [\" + p.currentToken() + \"] parsing inference aggregation \" + GAP_POLICY.getPreferredName());\n+        }, GAP_POLICY, ObjectParser.ValueType.STRING);\n+    }\n+\n+    private final Map<String, String> bucketPathMap;\n+    private String modelId;\n+    private InferenceConfigUpdate inferenceConfig;\n+    private final SetOnce<ModelLoadingService> modelLoadingService;\n+    private BucketHelpers.GapPolicy gapPolicy = BucketHelpers.GapPolicy.SKIP;\n+\n+    public static InferencePipelineAggregationBuilder parse(SetOnce<ModelLoadingService> modelLoadingService,\n+                                                            String pipelineAggregatorName,\n+                                                            XContentParser parser) {\n+        Tuple<SetOnce<ModelLoadingService>, String> context = new Tuple<>(modelLoadingService, pipelineAggregatorName);\n+        return PARSER.apply(parser, context);\n+    }\n+\n+    public InferencePipelineAggregationBuilder(String name, SetOnce<ModelLoadingService> modelLoadingService,\n+                                               Map<String, String> bucketsPath) {\n+        super(name, NAME, new TreeMap<>(bucketsPath).values().toArray(new String[] {}));\n+        this.modelLoadingService = modelLoadingService;\n+        this.bucketPathMap = bucketsPath;\n+    }\n+\n+    public InferencePipelineAggregationBuilder(StreamInput in, SetOnce<ModelLoadingService> modelLoadingService) throws IOException {\n+        super(in, NAME);\n+        modelId = in.readString();\n+        bucketPathMap = in.readMap(StreamInput::readString, StreamInput::readString);\n+        inferenceConfig = in.readOptionalNamedWriteable(InferenceConfigUpdate.class);\n+        gapPolicy = BucketHelpers.GapPolicy.readFrom(in);\n+        this.modelLoadingService = modelLoadingService;\n+    }\n+\n+    void setModelId(String modelId) {\n+        this.modelId = modelId;\n+    }\n+\n+    void setInferenceConfig(InferenceConfigUpdate inferenceConfig) {\n+        this.inferenceConfig = inferenceConfig;\n+    }\n+\n+    void setGapPolicy(BucketHelpers.GapPolicy gapPolicy) {\n+        this.gapPolicy = gapPolicy;\n+    }\n+\n+    @Override\n+    protected void validate(ValidationContext context) {\n+        context.validateHasParent(NAME, name);\n+        if (modelId == null) {\n+            context.addValidationError(\"Model Id must be set\");\n+        }\n+        if (gapPolicy != BucketHelpers.GapPolicy.SKIP) {\n+            context.addValidationError(\"gap policy [\" + gapPolicy + \"] in not valid for [\" + NAME + \"] aggregation\");\n+        }\n+    }\n+\n+    @Override\n+    protected void doWriteTo(StreamOutput out) throws IOException {\n+        out.writeString(modelId);\n+        out.writeMap(bucketPathMap, StreamOutput::writeString, StreamOutput::writeString);\n+        out.writeOptionalNamedWriteable(inferenceConfig);\n+        gapPolicy.writeTo(out);\n+    }\n+\n+    @Override\n+    protected PipelineAggregator createInternal(Map<String, Object> metaData) {\n+\n+        SetOnce<Model> model = new SetOnce<>();\n+        SetOnce<Exception> error = new SetOnce<>();\n+        CountDownLatch latch = new CountDownLatch(1);\n+        ActionListener<Model> listener = new LatchedActionListener<>(\n+            ActionListener.wrap(model::set, error::set), latch);\n+\n+        modelLoadingService.get().getModelForSearch(modelId, listener);\n+        try {\n+            // TODO Avoid the blocking wait\n+            latch.await();\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            throw new RuntimeException(\"Inference aggregation interrupted loading model\", e);\n+        }\n+\n+        Exception e = error.get();\n+        if (e != null) {\n+            if (e instanceof RuntimeException) {\n+                throw (RuntimeException)e;\n+            } else {\n+                throw new RuntimeException(error.get());\n+            }\n+        }\n+\n+        InferenceConfigUpdate update = adaptForAggregation(inferenceConfig);\n+\n+        return new InferencePipelineAggregator(name, bucketPathMap, metaData, update, model.get());\n+    }\n+\n+    static InferenceConfigUpdate adaptForAggregation(InferenceConfigUpdate originalUpdate) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY3NjQwMw=="}, "originalCommit": {"oid": "285ae40134507395bb022490ab4e09bd24acd439"}, "originalPosition": 164}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3Njk1NDc5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/aggs/InferencePipelineAggregator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNjoxNzozMlrOGpCELw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNjoxNzozMlrOGpCELw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY3ODYzOQ==", "bodyText": "Can these all be final?", "url": "https://github.com/elastic/elasticsearch/pull/58193#discussion_r445678639", "createdAt": "2020-06-25T16:17:32Z", "author": {"login": "polyfractal"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/aggs/InferencePipelineAggregator.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ml.inference.aggs;\n+\n+import org.elasticsearch.search.aggregations.AggregationExecutionException;\n+import org.elasticsearch.search.aggregations.InternalAggregation;\n+import org.elasticsearch.search.aggregations.InternalAggregations;\n+import org.elasticsearch.search.aggregations.InternalMultiBucketAggregation;\n+import org.elasticsearch.search.aggregations.bucket.MultiBucketsAggregation;\n+import org.elasticsearch.search.aggregations.bucket.terms.StringTerms;\n+import org.elasticsearch.search.aggregations.metrics.InternalNumericMetricsAggregation;\n+import org.elasticsearch.search.aggregations.pipeline.AbstractPipelineAggregationBuilder;\n+import org.elasticsearch.search.aggregations.pipeline.PipelineAggregator;\n+import org.elasticsearch.search.aggregations.support.AggregationPath;\n+import org.elasticsearch.xpack.core.ml.inference.results.InferenceResults;\n+import org.elasticsearch.xpack.core.ml.inference.results.WarningInferenceResults;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.InferenceConfigUpdate;\n+import org.elasticsearch.xpack.ml.inference.loadingservice.Model;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+\n+public class InferencePipelineAggregator extends PipelineAggregator {\n+\n+    private Map<String, String> bucketPathMap;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "285ae40134507395bb022490ab4e09bd24acd439"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3NzAxNDU1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/results/ClassificationInferenceResults.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNjozMjoxN1rOGpCqEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNjozMjoxN1rOGpCqEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY4ODMzNw==", "bodyText": "Seems to be only accessed in tests.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public PredictionFieldType getPredictionFieldType() {\n          \n          \n            \n                PredictionFieldType getPredictionFieldType() {", "url": "https://github.com/elastic/elasticsearch/pull/58193#discussion_r445688337", "createdAt": "2020-06-25T16:32:17Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/results/ClassificationInferenceResults.java", "diffHunk": "@@ -85,6 +84,10 @@ public String getClassificationLabel() {\n         return topClasses;\n     }\n \n+    public PredictionFieldType getPredictionFieldType() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "285ae40134507395bb022490ab4e09bd24acd439"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3NzAyMTcxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/aggs/InferencePipelineAggregator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNjozNDoxMVrOGpCumQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxNjoyMDozOVrOGpm6Vw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY4OTQ5Nw==", "bodyText": "I think we can do bucket.getAggregations().asList().stream()... instead of StreamSupport.  The older pipelines have that laying around because they predated stream on the iterator itself iirc.", "url": "https://github.com/elastic/elasticsearch/pull/58193#discussion_r445689497", "createdAt": "2020-06-25T16:34:11Z", "author": {"login": "polyfractal"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/aggs/InferencePipelineAggregator.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ml.inference.aggs;\n+\n+import org.elasticsearch.search.aggregations.AggregationExecutionException;\n+import org.elasticsearch.search.aggregations.InternalAggregation;\n+import org.elasticsearch.search.aggregations.InternalAggregations;\n+import org.elasticsearch.search.aggregations.InternalMultiBucketAggregation;\n+import org.elasticsearch.search.aggregations.bucket.MultiBucketsAggregation;\n+import org.elasticsearch.search.aggregations.bucket.terms.StringTerms;\n+import org.elasticsearch.search.aggregations.metrics.InternalNumericMetricsAggregation;\n+import org.elasticsearch.search.aggregations.pipeline.AbstractPipelineAggregationBuilder;\n+import org.elasticsearch.search.aggregations.pipeline.PipelineAggregator;\n+import org.elasticsearch.search.aggregations.support.AggregationPath;\n+import org.elasticsearch.xpack.core.ml.inference.results.InferenceResults;\n+import org.elasticsearch.xpack.core.ml.inference.results.WarningInferenceResults;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.InferenceConfigUpdate;\n+import org.elasticsearch.xpack.ml.inference.loadingservice.Model;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+\n+public class InferencePipelineAggregator extends PipelineAggregator {\n+\n+    private Map<String, String> bucketPathMap;\n+    private InferenceConfigUpdate configUpdate;\n+    private Model model;\n+\n+    public InferencePipelineAggregator(String name, Map<String,\n+                                       String> bucketPathMap,\n+                                       Map<String, Object> metaData,\n+                                       InferenceConfigUpdate configUpdate,\n+                                       Model model) {\n+        super(name, bucketPathMap.values().toArray(new String[] {}), metaData);\n+        this.bucketPathMap = bucketPathMap;\n+        this.configUpdate = configUpdate;\n+        this.model = model;\n+    }\n+\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    @Override\n+    public InternalAggregation reduce(InternalAggregation aggregation, InternalAggregation.ReduceContext reduceContext) {\n+\n+        InternalMultiBucketAggregation<InternalMultiBucketAggregation, InternalMultiBucketAggregation.InternalBucket> originalAgg =\n+            (InternalMultiBucketAggregation<InternalMultiBucketAggregation, InternalMultiBucketAggregation.InternalBucket>) aggregation;\n+        List<? extends InternalMultiBucketAggregation.InternalBucket> buckets = originalAgg.getBuckets();\n+\n+        List<InternalMultiBucketAggregation.InternalBucket> newBuckets = new ArrayList<>();\n+        for (InternalMultiBucketAggregation.InternalBucket bucket : buckets) {\n+            Map<String, Object> inputFields = new HashMap<>();\n+\n+            if (bucket.getDocCount() == 0) {\n+                // ignore this empty bucket unless the doc count is used\n+                if (bucketPathMap.containsKey(\"_count\") == false) {\n+                    newBuckets.add(bucket);\n+                    continue;\n+                }\n+            }\n+\n+            for (Map.Entry<String, String> entry : bucketPathMap.entrySet()) {\n+                String aggName = entry.getKey();\n+                String bucketPath = entry.getValue();\n+                Object propertyValue = resolveBucketValue(originalAgg, bucket, bucketPath);\n+\n+                if (propertyValue instanceof Number) {\n+                    double doubleVal = ((Number) propertyValue).doubleValue();\n+                    // NaN or infinite values indicate a missing value\n+                    if (Double.isFinite(doubleVal)) {\n+                        inputFields.put(aggName, doubleVal);\n+                    }\n+                } else if (propertyValue instanceof InternalNumericMetricsAggregation.SingleValue) {\n+                    double doubleVal = ((InternalNumericMetricsAggregation.SingleValue) propertyValue).value();\n+                    if (Double.isFinite(doubleVal)) {\n+                        inputFields.put(aggName, doubleVal);\n+                    }\n+                } else if (propertyValue instanceof StringTerms.Bucket) {\n+                    StringTerms.Bucket b = (StringTerms.Bucket) propertyValue;\n+                    inputFields.put(aggName, b.getKeyAsString());\n+                } else if (propertyValue instanceof String) {\n+                    inputFields.put(aggName, propertyValue);\n+                } else if (propertyValue != null) {\n+                    // Doubles, String terms or null are valid, any other type is an error\n+                    throw invalidAggTypeError(bucketPath, propertyValue);\n+                }\n+            }\n+\n+\n+            InferenceResults inference;\n+            try {\n+                 inference = model.infer(inputFields, configUpdate);\n+            } catch (Exception e) {\n+                inference = new WarningInferenceResults(e.getMessage());\n+            }\n+\n+            final List<InternalAggregation> aggs = StreamSupport.stream(bucket.getAggregations().spliterator(), false).map(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "285ae40134507395bb022490ab4e09bd24acd439"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI4MjMyNw==", "bodyText": "\ud83d\udc4d Guilty of copy-and-paste here.", "url": "https://github.com/elastic/elasticsearch/pull/58193#discussion_r446282327", "createdAt": "2020-06-26T16:20:39Z", "author": {"login": "davidkyle"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/aggs/InferencePipelineAggregator.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ml.inference.aggs;\n+\n+import org.elasticsearch.search.aggregations.AggregationExecutionException;\n+import org.elasticsearch.search.aggregations.InternalAggregation;\n+import org.elasticsearch.search.aggregations.InternalAggregations;\n+import org.elasticsearch.search.aggregations.InternalMultiBucketAggregation;\n+import org.elasticsearch.search.aggregations.bucket.MultiBucketsAggregation;\n+import org.elasticsearch.search.aggregations.bucket.terms.StringTerms;\n+import org.elasticsearch.search.aggregations.metrics.InternalNumericMetricsAggregation;\n+import org.elasticsearch.search.aggregations.pipeline.AbstractPipelineAggregationBuilder;\n+import org.elasticsearch.search.aggregations.pipeline.PipelineAggregator;\n+import org.elasticsearch.search.aggregations.support.AggregationPath;\n+import org.elasticsearch.xpack.core.ml.inference.results.InferenceResults;\n+import org.elasticsearch.xpack.core.ml.inference.results.WarningInferenceResults;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.InferenceConfigUpdate;\n+import org.elasticsearch.xpack.ml.inference.loadingservice.Model;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+\n+public class InferencePipelineAggregator extends PipelineAggregator {\n+\n+    private Map<String, String> bucketPathMap;\n+    private InferenceConfigUpdate configUpdate;\n+    private Model model;\n+\n+    public InferencePipelineAggregator(String name, Map<String,\n+                                       String> bucketPathMap,\n+                                       Map<String, Object> metaData,\n+                                       InferenceConfigUpdate configUpdate,\n+                                       Model model) {\n+        super(name, bucketPathMap.values().toArray(new String[] {}), metaData);\n+        this.bucketPathMap = bucketPathMap;\n+        this.configUpdate = configUpdate;\n+        this.model = model;\n+    }\n+\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    @Override\n+    public InternalAggregation reduce(InternalAggregation aggregation, InternalAggregation.ReduceContext reduceContext) {\n+\n+        InternalMultiBucketAggregation<InternalMultiBucketAggregation, InternalMultiBucketAggregation.InternalBucket> originalAgg =\n+            (InternalMultiBucketAggregation<InternalMultiBucketAggregation, InternalMultiBucketAggregation.InternalBucket>) aggregation;\n+        List<? extends InternalMultiBucketAggregation.InternalBucket> buckets = originalAgg.getBuckets();\n+\n+        List<InternalMultiBucketAggregation.InternalBucket> newBuckets = new ArrayList<>();\n+        for (InternalMultiBucketAggregation.InternalBucket bucket : buckets) {\n+            Map<String, Object> inputFields = new HashMap<>();\n+\n+            if (bucket.getDocCount() == 0) {\n+                // ignore this empty bucket unless the doc count is used\n+                if (bucketPathMap.containsKey(\"_count\") == false) {\n+                    newBuckets.add(bucket);\n+                    continue;\n+                }\n+            }\n+\n+            for (Map.Entry<String, String> entry : bucketPathMap.entrySet()) {\n+                String aggName = entry.getKey();\n+                String bucketPath = entry.getValue();\n+                Object propertyValue = resolveBucketValue(originalAgg, bucket, bucketPath);\n+\n+                if (propertyValue instanceof Number) {\n+                    double doubleVal = ((Number) propertyValue).doubleValue();\n+                    // NaN or infinite values indicate a missing value\n+                    if (Double.isFinite(doubleVal)) {\n+                        inputFields.put(aggName, doubleVal);\n+                    }\n+                } else if (propertyValue instanceof InternalNumericMetricsAggregation.SingleValue) {\n+                    double doubleVal = ((InternalNumericMetricsAggregation.SingleValue) propertyValue).value();\n+                    if (Double.isFinite(doubleVal)) {\n+                        inputFields.put(aggName, doubleVal);\n+                    }\n+                } else if (propertyValue instanceof StringTerms.Bucket) {\n+                    StringTerms.Bucket b = (StringTerms.Bucket) propertyValue;\n+                    inputFields.put(aggName, b.getKeyAsString());\n+                } else if (propertyValue instanceof String) {\n+                    inputFields.put(aggName, propertyValue);\n+                } else if (propertyValue != null) {\n+                    // Doubles, String terms or null are valid, any other type is an error\n+                    throw invalidAggTypeError(bucketPath, propertyValue);\n+                }\n+            }\n+\n+\n+            InferenceResults inference;\n+            try {\n+                 inference = model.infer(inputFields, configUpdate);\n+            } catch (Exception e) {\n+                inference = new WarningInferenceResults(e.getMessage());\n+            }\n+\n+            final List<InternalAggregation> aggs = StreamSupport.stream(bucket.getAggregations().spliterator(), false).map(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY4OTQ5Nw=="}, "originalCommit": {"oid": "285ae40134507395bb022490ab4e09bd24acd439"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3NzA2NTM4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/trainedmodel/ClassificationConfigUpdate.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNjo0NjowNFrOGpDKlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNjo0NjowNFrOGpDKlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY5NjY2Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change", "url": "https://github.com/elastic/elasticsearch/pull/58193#discussion_r445696662", "createdAt": "2020-06-25T16:46:04Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/trainedmodel/ClassificationConfigUpdate.java", "diffHunk": "@@ -96,6 +96,8 @@ public ClassificationConfigUpdate(Integer numTopClasses,\n         }\n         this.numTopFeatureImportanceValues = featureImportance;\n         this.predictionFieldType = predictionFieldType;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "285ae40134507395bb022490ab4e09bd24acd439"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3NzA3NTU4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/aggs/InferencePipelineAggregator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNjo0ODozM1rOGpDQ7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNjo0ODozM1rOGpDQ7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY5ODI4Nw==", "bodyText": "Just an FYI if you care: there's currently no validation that the user doesn't enter the same bucket path multiple times with different keys.  It's not generally a problem elsewhere (and sometimes useful), but since your requirements might be different, wanted to mention it :)", "url": "https://github.com/elastic/elasticsearch/pull/58193#discussion_r445698287", "createdAt": "2020-06-25T16:48:33Z", "author": {"login": "polyfractal"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/aggs/InferencePipelineAggregator.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ml.inference.aggs;\n+\n+import org.elasticsearch.search.aggregations.AggregationExecutionException;\n+import org.elasticsearch.search.aggregations.InternalAggregation;\n+import org.elasticsearch.search.aggregations.InternalAggregations;\n+import org.elasticsearch.search.aggregations.InternalMultiBucketAggregation;\n+import org.elasticsearch.search.aggregations.bucket.MultiBucketsAggregation;\n+import org.elasticsearch.search.aggregations.bucket.terms.StringTerms;\n+import org.elasticsearch.search.aggregations.metrics.InternalNumericMetricsAggregation;\n+import org.elasticsearch.search.aggregations.pipeline.AbstractPipelineAggregationBuilder;\n+import org.elasticsearch.search.aggregations.pipeline.PipelineAggregator;\n+import org.elasticsearch.search.aggregations.support.AggregationPath;\n+import org.elasticsearch.xpack.core.ml.inference.results.InferenceResults;\n+import org.elasticsearch.xpack.core.ml.inference.results.WarningInferenceResults;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.InferenceConfigUpdate;\n+import org.elasticsearch.xpack.ml.inference.loadingservice.Model;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+\n+public class InferencePipelineAggregator extends PipelineAggregator {\n+\n+    private Map<String, String> bucketPathMap;\n+    private InferenceConfigUpdate configUpdate;\n+    private Model model;\n+\n+    public InferencePipelineAggregator(String name, Map<String,\n+                                       String> bucketPathMap,\n+                                       Map<String, Object> metaData,\n+                                       InferenceConfigUpdate configUpdate,\n+                                       Model model) {\n+        super(name, bucketPathMap.values().toArray(new String[] {}), metaData);\n+        this.bucketPathMap = bucketPathMap;\n+        this.configUpdate = configUpdate;\n+        this.model = model;\n+    }\n+\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    @Override\n+    public InternalAggregation reduce(InternalAggregation aggregation, InternalAggregation.ReduceContext reduceContext) {\n+\n+        InternalMultiBucketAggregation<InternalMultiBucketAggregation, InternalMultiBucketAggregation.InternalBucket> originalAgg =\n+            (InternalMultiBucketAggregation<InternalMultiBucketAggregation, InternalMultiBucketAggregation.InternalBucket>) aggregation;\n+        List<? extends InternalMultiBucketAggregation.InternalBucket> buckets = originalAgg.getBuckets();\n+\n+        List<InternalMultiBucketAggregation.InternalBucket> newBuckets = new ArrayList<>();\n+        for (InternalMultiBucketAggregation.InternalBucket bucket : buckets) {\n+            Map<String, Object> inputFields = new HashMap<>();\n+\n+            if (bucket.getDocCount() == 0) {\n+                // ignore this empty bucket unless the doc count is used\n+                if (bucketPathMap.containsKey(\"_count\") == false) {\n+                    newBuckets.add(bucket);\n+                    continue;\n+                }\n+            }\n+\n+            for (Map.Entry<String, String> entry : bucketPathMap.entrySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "285ae40134507395bb022490ab4e09bd24acd439"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3NzA5MjkwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/aggs/InferencePipelineAggregator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNjo1MzowMFrOGpDbxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNjo1MzowMFrOGpDbxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTcwMTA2MQ==", "bodyText": "Another Note: NaN or infinite could also mean the agg actually generate a NaN/Infinite.  Unfortunately there's not a good way of knowing without inspecting the underlying agg itself and seeing if it's using its placeholder value.\nOther pipelines don't particularly care, all NaN/Infinite are bad, so it's never been a problem.  But YMMV :)", "url": "https://github.com/elastic/elasticsearch/pull/58193#discussion_r445701061", "createdAt": "2020-06-25T16:53:00Z", "author": {"login": "polyfractal"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/aggs/InferencePipelineAggregator.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ml.inference.aggs;\n+\n+import org.elasticsearch.search.aggregations.AggregationExecutionException;\n+import org.elasticsearch.search.aggregations.InternalAggregation;\n+import org.elasticsearch.search.aggregations.InternalAggregations;\n+import org.elasticsearch.search.aggregations.InternalMultiBucketAggregation;\n+import org.elasticsearch.search.aggregations.bucket.MultiBucketsAggregation;\n+import org.elasticsearch.search.aggregations.bucket.terms.StringTerms;\n+import org.elasticsearch.search.aggregations.metrics.InternalNumericMetricsAggregation;\n+import org.elasticsearch.search.aggregations.pipeline.AbstractPipelineAggregationBuilder;\n+import org.elasticsearch.search.aggregations.pipeline.PipelineAggregator;\n+import org.elasticsearch.search.aggregations.support.AggregationPath;\n+import org.elasticsearch.xpack.core.ml.inference.results.InferenceResults;\n+import org.elasticsearch.xpack.core.ml.inference.results.WarningInferenceResults;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.InferenceConfigUpdate;\n+import org.elasticsearch.xpack.ml.inference.loadingservice.Model;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+\n+public class InferencePipelineAggregator extends PipelineAggregator {\n+\n+    private Map<String, String> bucketPathMap;\n+    private InferenceConfigUpdate configUpdate;\n+    private Model model;\n+\n+    public InferencePipelineAggregator(String name, Map<String,\n+                                       String> bucketPathMap,\n+                                       Map<String, Object> metaData,\n+                                       InferenceConfigUpdate configUpdate,\n+                                       Model model) {\n+        super(name, bucketPathMap.values().toArray(new String[] {}), metaData);\n+        this.bucketPathMap = bucketPathMap;\n+        this.configUpdate = configUpdate;\n+        this.model = model;\n+    }\n+\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    @Override\n+    public InternalAggregation reduce(InternalAggregation aggregation, InternalAggregation.ReduceContext reduceContext) {\n+\n+        InternalMultiBucketAggregation<InternalMultiBucketAggregation, InternalMultiBucketAggregation.InternalBucket> originalAgg =\n+            (InternalMultiBucketAggregation<InternalMultiBucketAggregation, InternalMultiBucketAggregation.InternalBucket>) aggregation;\n+        List<? extends InternalMultiBucketAggregation.InternalBucket> buckets = originalAgg.getBuckets();\n+\n+        List<InternalMultiBucketAggregation.InternalBucket> newBuckets = new ArrayList<>();\n+        for (InternalMultiBucketAggregation.InternalBucket bucket : buckets) {\n+            Map<String, Object> inputFields = new HashMap<>();\n+\n+            if (bucket.getDocCount() == 0) {\n+                // ignore this empty bucket unless the doc count is used\n+                if (bucketPathMap.containsKey(\"_count\") == false) {\n+                    newBuckets.add(bucket);\n+                    continue;\n+                }\n+            }\n+\n+            for (Map.Entry<String, String> entry : bucketPathMap.entrySet()) {\n+                String aggName = entry.getKey();\n+                String bucketPath = entry.getValue();\n+                Object propertyValue = resolveBucketValue(originalAgg, bucket, bucketPath);\n+\n+                if (propertyValue instanceof Number) {\n+                    double doubleVal = ((Number) propertyValue).doubleValue();\n+                    // NaN or infinite values indicate a missing value", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "285ae40134507395bb022490ab4e09bd24acd439"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3NzE1NzUwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/trainedmodel/InferenceConfigUpdate.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNzoxMTowOVrOGpEFEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxNjoyMToyMFrOGpm7mQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTcxMTYzMw==", "bodyText": "I know it will mean more LoC, but this method is not extensible and only exists for a single thing/path.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                InferenceConfigUpdate duplicateWithResultsField(String resultsField);\n          \n          \n            \n                Builder newBuilder();\n          \n          \n            \n            \n          \n          \n            \n                interface Builder<T extends Builder, U extends InferenceConfigUpdate> {\n          \n          \n            \n            \n          \n          \n            \n                    U build();\n          \n          \n            \n            \n          \n          \n            \n                    T setResultsField(String resultsField);\n          \n          \n            \n            \n          \n          \n            \n                }\n          \n      \n    \n    \n  \n\nThen each builder satisfies this interface and needs a copy ctor accepting their appropriate update object.\nThe code to replace the resultsField name is now\nInferenceConfigUpdate newUpdate = update.newBuilder().setResultsField(\"foo\").build();\n\nThis seems more general + more clean than a one off method.", "url": "https://github.com/elastic/elasticsearch/pull/58193#discussion_r445711633", "createdAt": "2020-06-25T17:11:09Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/trainedmodel/InferenceConfigUpdate.java", "diffHunk": "@@ -6,14 +6,48 @@\n package org.elasticsearch.xpack.core.ml.inference.trainedmodel;\n \n import org.elasticsearch.common.io.stream.NamedWriteable;\n+import org.elasticsearch.xpack.core.ml.inference.TrainedModelConfig;\n+import org.elasticsearch.xpack.core.ml.inference.results.WarningInferenceResults;\n+import org.elasticsearch.xpack.core.ml.utils.ExceptionsHelper;\n import org.elasticsearch.xpack.core.ml.utils.NamedXContentObject;\n \n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n \n public interface InferenceConfigUpdate extends NamedXContentObject, NamedWriteable {\n+    Set<String> RESERVED_ML_FIELD_NAMES = new HashSet<>(Arrays.asList(\n+        WarningInferenceResults.WARNING.getPreferredName(),\n+        TrainedModelConfig.MODEL_ID.getPreferredName()));\n \n     InferenceConfig apply(InferenceConfig originalConfig);\n \n     InferenceConfig toConfig();\n \n     boolean isSupported(InferenceConfig config);\n+\n+    String getResultsField();\n+\n+    InferenceConfigUpdate duplicateWithResultsField(String resultsField);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "285ae40134507395bb022490ab4e09bd24acd439"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI4MjY0OQ==", "bodyText": "Good suggestion I've implemented the builder", "url": "https://github.com/elastic/elasticsearch/pull/58193#discussion_r446282649", "createdAt": "2020-06-26T16:21:20Z", "author": {"login": "davidkyle"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/trainedmodel/InferenceConfigUpdate.java", "diffHunk": "@@ -6,14 +6,48 @@\n package org.elasticsearch.xpack.core.ml.inference.trainedmodel;\n \n import org.elasticsearch.common.io.stream.NamedWriteable;\n+import org.elasticsearch.xpack.core.ml.inference.TrainedModelConfig;\n+import org.elasticsearch.xpack.core.ml.inference.results.WarningInferenceResults;\n+import org.elasticsearch.xpack.core.ml.utils.ExceptionsHelper;\n import org.elasticsearch.xpack.core.ml.utils.NamedXContentObject;\n \n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n \n public interface InferenceConfigUpdate extends NamedXContentObject, NamedWriteable {\n+    Set<String> RESERVED_ML_FIELD_NAMES = new HashSet<>(Arrays.asList(\n+        WarningInferenceResults.WARNING.getPreferredName(),\n+        TrainedModelConfig.MODEL_ID.getPreferredName()));\n \n     InferenceConfig apply(InferenceConfig originalConfig);\n \n     InferenceConfig toConfig();\n \n     boolean isSupported(InferenceConfig config);\n+\n+    String getResultsField();\n+\n+    InferenceConfigUpdate duplicateWithResultsField(String resultsField);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTcxMTYzMw=="}, "originalCommit": {"oid": "285ae40134507395bb022490ab4e09bd24acd439"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3NzIwMjgxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/aggs/InferencePipelineAggregationBuilder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNzoyNDo0M1rOGpEiIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNzoyNDo0M1rOGpEiIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTcxOTA3Mw==", "bodyText": "These types of validations seem like they belong in the agg parser.\nMaybe we should always parse the named objects into a ResultsFieldUpdate object or something.\nAt a minimum, these validations should occur before we attempt to load the model.", "url": "https://github.com/elastic/elasticsearch/pull/58193#discussion_r445719073", "createdAt": "2020-06-25T17:24:43Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/aggs/InferencePipelineAggregationBuilder.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ml.inference.aggs;\n+\n+import org.apache.lucene.util.SetOnce;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.LatchedActionListener;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.collect.Tuple;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.search.aggregations.pipeline.AbstractPipelineAggregationBuilder;\n+import org.elasticsearch.search.aggregations.pipeline.BucketHelpers;\n+import org.elasticsearch.search.aggregations.pipeline.PipelineAggregator;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.ClassificationConfig;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.ClassificationConfigUpdate;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.InferenceConfigUpdate;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.ResultsFieldUpdate;\n+import org.elasticsearch.xpack.core.ml.utils.ExceptionsHelper;\n+import org.elasticsearch.xpack.ml.inference.loadingservice.Model;\n+import org.elasticsearch.xpack.ml.inference.loadingservice.ModelLoadingService;\n+\n+import java.io.IOException;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.TreeMap;\n+import java.util.concurrent.CountDownLatch;\n+\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.constructorArg;\n+import static org.elasticsearch.search.aggregations.pipeline.PipelineAggregator.Parser.GAP_POLICY;\n+\n+public class InferencePipelineAggregationBuilder extends AbstractPipelineAggregationBuilder<InferencePipelineAggregationBuilder> {\n+\n+    public static String NAME = \"inference\";\n+\n+    public static final ParseField MODEL_ID = new ParseField(\"model_id\");\n+    private static final ParseField INFERENCE_CONFIG = new ParseField(\"inference_config\");\n+\n+    static String AGGREGATIONS_RESULTS_FIELD = \"value\";\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static final ConstructingObjectParser<InferencePipelineAggregationBuilder,\n+        Tuple<SetOnce<ModelLoadingService>, String>> PARSER = new ConstructingObjectParser<>(\n+        NAME, false,\n+        (args, context) -> new InferencePipelineAggregationBuilder(context.v2(), context.v1(), (Map<String, String>) args[0])\n+    );\n+\n+    static {\n+        PARSER.declareObject(constructorArg(), (p, c) -> p.mapStrings(), BUCKETS_PATH_FIELD);\n+        PARSER.declareString(InferencePipelineAggregationBuilder::setModelId, MODEL_ID);\n+        PARSER.declareNamedObject(InferencePipelineAggregationBuilder::setInferenceConfig,\n+            (p, c, n) -> p.namedObject(InferenceConfigUpdate.class, n, c), INFERENCE_CONFIG);\n+        PARSER.declareField(InferencePipelineAggregationBuilder::setGapPolicy, p -> {\n+            if (p.currentToken() == XContentParser.Token.VALUE_STRING) {\n+                return BucketHelpers.GapPolicy.parse(p.text().toLowerCase(Locale.ROOT), p.getTokenLocation());\n+            }\n+            throw new IllegalArgumentException(\n+                \"Unsupported token [\" + p.currentToken() + \"] parsing inference aggregation \" + GAP_POLICY.getPreferredName());\n+        }, GAP_POLICY, ObjectParser.ValueType.STRING);\n+    }\n+\n+    private final Map<String, String> bucketPathMap;\n+    private String modelId;\n+    private InferenceConfigUpdate inferenceConfig;\n+    private final SetOnce<ModelLoadingService> modelLoadingService;\n+    private BucketHelpers.GapPolicy gapPolicy = BucketHelpers.GapPolicy.SKIP;\n+\n+    public static InferencePipelineAggregationBuilder parse(SetOnce<ModelLoadingService> modelLoadingService,\n+                                                            String pipelineAggregatorName,\n+                                                            XContentParser parser) {\n+        Tuple<SetOnce<ModelLoadingService>, String> context = new Tuple<>(modelLoadingService, pipelineAggregatorName);\n+        return PARSER.apply(parser, context);\n+    }\n+\n+    public InferencePipelineAggregationBuilder(String name, SetOnce<ModelLoadingService> modelLoadingService,\n+                                               Map<String, String> bucketsPath) {\n+        super(name, NAME, new TreeMap<>(bucketsPath).values().toArray(new String[] {}));\n+        this.modelLoadingService = modelLoadingService;\n+        this.bucketPathMap = bucketsPath;\n+    }\n+\n+    public InferencePipelineAggregationBuilder(StreamInput in, SetOnce<ModelLoadingService> modelLoadingService) throws IOException {\n+        super(in, NAME);\n+        modelId = in.readString();\n+        bucketPathMap = in.readMap(StreamInput::readString, StreamInput::readString);\n+        inferenceConfig = in.readOptionalNamedWriteable(InferenceConfigUpdate.class);\n+        gapPolicy = BucketHelpers.GapPolicy.readFrom(in);\n+        this.modelLoadingService = modelLoadingService;\n+    }\n+\n+    void setModelId(String modelId) {\n+        this.modelId = modelId;\n+    }\n+\n+    void setInferenceConfig(InferenceConfigUpdate inferenceConfig) {\n+        this.inferenceConfig = inferenceConfig;\n+    }\n+\n+    void setGapPolicy(BucketHelpers.GapPolicy gapPolicy) {\n+        this.gapPolicy = gapPolicy;\n+    }\n+\n+    @Override\n+    protected void validate(ValidationContext context) {\n+        context.validateHasParent(NAME, name);\n+        if (modelId == null) {\n+            context.addValidationError(\"Model Id must be set\");\n+        }\n+        if (gapPolicy != BucketHelpers.GapPolicy.SKIP) {\n+            context.addValidationError(\"gap policy [\" + gapPolicy + \"] in not valid for [\" + NAME + \"] aggregation\");\n+        }\n+    }\n+\n+    @Override\n+    protected void doWriteTo(StreamOutput out) throws IOException {\n+        out.writeString(modelId);\n+        out.writeMap(bucketPathMap, StreamOutput::writeString, StreamOutput::writeString);\n+        out.writeOptionalNamedWriteable(inferenceConfig);\n+        gapPolicy.writeTo(out);\n+    }\n+\n+    @Override\n+    protected PipelineAggregator createInternal(Map<String, Object> metaData) {\n+\n+        SetOnce<Model> model = new SetOnce<>();\n+        SetOnce<Exception> error = new SetOnce<>();\n+        CountDownLatch latch = new CountDownLatch(1);\n+        ActionListener<Model> listener = new LatchedActionListener<>(\n+            ActionListener.wrap(model::set, error::set), latch);\n+\n+        modelLoadingService.get().getModelForSearch(modelId, listener);\n+        try {\n+            // TODO Avoid the blocking wait\n+            latch.await();\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            throw new RuntimeException(\"Inference aggregation interrupted loading model\", e);\n+        }\n+\n+        Exception e = error.get();\n+        if (e != null) {\n+            if (e instanceof RuntimeException) {\n+                throw (RuntimeException)e;\n+            } else {\n+                throw new RuntimeException(error.get());\n+            }\n+        }\n+\n+        InferenceConfigUpdate update = adaptForAggregation(inferenceConfig);\n+\n+        return new InferencePipelineAggregator(name, bucketPathMap, metaData, update, model.get());\n+    }\n+\n+    static InferenceConfigUpdate adaptForAggregation(InferenceConfigUpdate originalUpdate) {\n+        InferenceConfigUpdate updated;\n+        if (originalUpdate == null) {\n+            updated = new ResultsFieldUpdate(AGGREGATIONS_RESULTS_FIELD);\n+        } else {\n+            if (originalUpdate instanceof ClassificationConfigUpdate) {\n+                ClassificationConfigUpdate classUpdate = (ClassificationConfigUpdate)originalUpdate;\n+\n+                // error if the top classes result field is set and not equal to the only acceptable value\n+                String topClassesField = classUpdate.getTopClassesResultsField();\n+                if (Strings.isNullOrEmpty(topClassesField) == false &&\n+                    ClassificationConfig.DEFAULT_TOP_CLASSES_RESULTS_FIELD.equals(topClassesField) == false) {\n+                    throw ExceptionsHelper.badRequestException(\"setting option [{}] to [{}] is not valid for inference aggregations\",\n+                        ClassificationConfig.DEFAULT_TOP_CLASSES_RESULTS_FIELD, topClassesField);\n+                }\n+            }\n+\n+            // error if the results field is set and not equal to the only acceptable value\n+            String resultsField = originalUpdate.getResultsField();\n+            if (Strings.isNullOrEmpty(resultsField) == false && AGGREGATIONS_RESULTS_FIELD.equals(resultsField) == false) {\n+                throw ExceptionsHelper.badRequestException(\"setting option [{}] to [{}] is not valid for inference aggregations\",\n+                    ClassificationConfig.RESULTS_FIELD.getPreferredName(), resultsField);\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "285ae40134507395bb022490ab4e09bd24acd439"}, "originalPosition": 186}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3NzIwNjUzOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/aggs/InferencePipelineAggregator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNzoyNTo0N1rOGpEkpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNzoyNTo0N1rOGpEkpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTcxOTcxNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change", "url": "https://github.com/elastic/elasticsearch/pull/58193#discussion_r445719716", "createdAt": "2020-06-25T17:25:47Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/aggs/InferencePipelineAggregator.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ml.inference.aggs;\n+\n+import org.elasticsearch.search.aggregations.AggregationExecutionException;\n+import org.elasticsearch.search.aggregations.InternalAggregation;\n+import org.elasticsearch.search.aggregations.InternalAggregations;\n+import org.elasticsearch.search.aggregations.InternalMultiBucketAggregation;\n+import org.elasticsearch.search.aggregations.bucket.MultiBucketsAggregation;\n+import org.elasticsearch.search.aggregations.bucket.terms.StringTerms;\n+import org.elasticsearch.search.aggregations.metrics.InternalNumericMetricsAggregation;\n+import org.elasticsearch.search.aggregations.pipeline.AbstractPipelineAggregationBuilder;\n+import org.elasticsearch.search.aggregations.pipeline.PipelineAggregator;\n+import org.elasticsearch.search.aggregations.support.AggregationPath;\n+import org.elasticsearch.xpack.core.ml.inference.results.InferenceResults;\n+import org.elasticsearch.xpack.core.ml.inference.results.WarningInferenceResults;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.InferenceConfigUpdate;\n+import org.elasticsearch.xpack.ml.inference.loadingservice.Model;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+\n+public class InferencePipelineAggregator extends PipelineAggregator {\n+\n+    private Map<String, String> bucketPathMap;\n+    private InferenceConfigUpdate configUpdate;\n+    private Model model;\n+\n+    public InferencePipelineAggregator(String name, Map<String,\n+                                       String> bucketPathMap,\n+                                       Map<String, Object> metaData,\n+                                       InferenceConfigUpdate configUpdate,\n+                                       Model model) {\n+        super(name, bucketPathMap.values().toArray(new String[] {}), metaData);\n+        this.bucketPathMap = bucketPathMap;\n+        this.configUpdate = configUpdate;\n+        this.model = model;\n+    }\n+\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    @Override\n+    public InternalAggregation reduce(InternalAggregation aggregation, InternalAggregation.ReduceContext reduceContext) {\n+\n+        InternalMultiBucketAggregation<InternalMultiBucketAggregation, InternalMultiBucketAggregation.InternalBucket> originalAgg =\n+            (InternalMultiBucketAggregation<InternalMultiBucketAggregation, InternalMultiBucketAggregation.InternalBucket>) aggregation;\n+        List<? extends InternalMultiBucketAggregation.InternalBucket> buckets = originalAgg.getBuckets();\n+\n+        List<InternalMultiBucketAggregation.InternalBucket> newBuckets = new ArrayList<>();\n+        for (InternalMultiBucketAggregation.InternalBucket bucket : buckets) {\n+            Map<String, Object> inputFields = new HashMap<>();\n+\n+            if (bucket.getDocCount() == 0) {\n+                // ignore this empty bucket unless the doc count is used\n+                if (bucketPathMap.containsKey(\"_count\") == false) {\n+                    newBuckets.add(bucket);\n+                    continue;\n+                }\n+            }\n+\n+            for (Map.Entry<String, String> entry : bucketPathMap.entrySet()) {\n+                String aggName = entry.getKey();\n+                String bucketPath = entry.getValue();\n+                Object propertyValue = resolveBucketValue(originalAgg, bucket, bucketPath);\n+\n+                if (propertyValue instanceof Number) {\n+                    double doubleVal = ((Number) propertyValue).doubleValue();\n+                    // NaN or infinite values indicate a missing value\n+                    if (Double.isFinite(doubleVal)) {\n+                        inputFields.put(aggName, doubleVal);\n+                    }\n+                } else if (propertyValue instanceof InternalNumericMetricsAggregation.SingleValue) {\n+                    double doubleVal = ((InternalNumericMetricsAggregation.SingleValue) propertyValue).value();\n+                    if (Double.isFinite(doubleVal)) {\n+                        inputFields.put(aggName, doubleVal);\n+                    }\n+                } else if (propertyValue instanceof StringTerms.Bucket) {\n+                    StringTerms.Bucket b = (StringTerms.Bucket) propertyValue;\n+                    inputFields.put(aggName, b.getKeyAsString());\n+                } else if (propertyValue instanceof String) {\n+                    inputFields.put(aggName, propertyValue);\n+                } else if (propertyValue != null) {\n+                    // Doubles, String terms or null are valid, any other type is an error\n+                    throw invalidAggTypeError(bucketPath, propertyValue);\n+                }\n+            }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "285ae40134507395bb022490ab4e09bd24acd439"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3NzIwODgwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/aggs/InferencePipelineAggregator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNzoyNjoyOVrOGpEmKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNzoyNjoyOVrOGpEmKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTcyMDEwNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                             inference = model.infer(inputFields, configUpdate);\n          \n          \n            \n                            inference = model.infer(inputFields, configUpdate);", "url": "https://github.com/elastic/elasticsearch/pull/58193#discussion_r445720106", "createdAt": "2020-06-25T17:26:29Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/aggs/InferencePipelineAggregator.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ml.inference.aggs;\n+\n+import org.elasticsearch.search.aggregations.AggregationExecutionException;\n+import org.elasticsearch.search.aggregations.InternalAggregation;\n+import org.elasticsearch.search.aggregations.InternalAggregations;\n+import org.elasticsearch.search.aggregations.InternalMultiBucketAggregation;\n+import org.elasticsearch.search.aggregations.bucket.MultiBucketsAggregation;\n+import org.elasticsearch.search.aggregations.bucket.terms.StringTerms;\n+import org.elasticsearch.search.aggregations.metrics.InternalNumericMetricsAggregation;\n+import org.elasticsearch.search.aggregations.pipeline.AbstractPipelineAggregationBuilder;\n+import org.elasticsearch.search.aggregations.pipeline.PipelineAggregator;\n+import org.elasticsearch.search.aggregations.support.AggregationPath;\n+import org.elasticsearch.xpack.core.ml.inference.results.InferenceResults;\n+import org.elasticsearch.xpack.core.ml.inference.results.WarningInferenceResults;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.InferenceConfigUpdate;\n+import org.elasticsearch.xpack.ml.inference.loadingservice.Model;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+\n+public class InferencePipelineAggregator extends PipelineAggregator {\n+\n+    private Map<String, String> bucketPathMap;\n+    private InferenceConfigUpdate configUpdate;\n+    private Model model;\n+\n+    public InferencePipelineAggregator(String name, Map<String,\n+                                       String> bucketPathMap,\n+                                       Map<String, Object> metaData,\n+                                       InferenceConfigUpdate configUpdate,\n+                                       Model model) {\n+        super(name, bucketPathMap.values().toArray(new String[] {}), metaData);\n+        this.bucketPathMap = bucketPathMap;\n+        this.configUpdate = configUpdate;\n+        this.model = model;\n+    }\n+\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    @Override\n+    public InternalAggregation reduce(InternalAggregation aggregation, InternalAggregation.ReduceContext reduceContext) {\n+\n+        InternalMultiBucketAggregation<InternalMultiBucketAggregation, InternalMultiBucketAggregation.InternalBucket> originalAgg =\n+            (InternalMultiBucketAggregation<InternalMultiBucketAggregation, InternalMultiBucketAggregation.InternalBucket>) aggregation;\n+        List<? extends InternalMultiBucketAggregation.InternalBucket> buckets = originalAgg.getBuckets();\n+\n+        List<InternalMultiBucketAggregation.InternalBucket> newBuckets = new ArrayList<>();\n+        for (InternalMultiBucketAggregation.InternalBucket bucket : buckets) {\n+            Map<String, Object> inputFields = new HashMap<>();\n+\n+            if (bucket.getDocCount() == 0) {\n+                // ignore this empty bucket unless the doc count is used\n+                if (bucketPathMap.containsKey(\"_count\") == false) {\n+                    newBuckets.add(bucket);\n+                    continue;\n+                }\n+            }\n+\n+            for (Map.Entry<String, String> entry : bucketPathMap.entrySet()) {\n+                String aggName = entry.getKey();\n+                String bucketPath = entry.getValue();\n+                Object propertyValue = resolveBucketValue(originalAgg, bucket, bucketPath);\n+\n+                if (propertyValue instanceof Number) {\n+                    double doubleVal = ((Number) propertyValue).doubleValue();\n+                    // NaN or infinite values indicate a missing value\n+                    if (Double.isFinite(doubleVal)) {\n+                        inputFields.put(aggName, doubleVal);\n+                    }\n+                } else if (propertyValue instanceof InternalNumericMetricsAggregation.SingleValue) {\n+                    double doubleVal = ((InternalNumericMetricsAggregation.SingleValue) propertyValue).value();\n+                    if (Double.isFinite(doubleVal)) {\n+                        inputFields.put(aggName, doubleVal);\n+                    }\n+                } else if (propertyValue instanceof StringTerms.Bucket) {\n+                    StringTerms.Bucket b = (StringTerms.Bucket) propertyValue;\n+                    inputFields.put(aggName, b.getKeyAsString());\n+                } else if (propertyValue instanceof String) {\n+                    inputFields.put(aggName, propertyValue);\n+                } else if (propertyValue != null) {\n+                    // Doubles, String terms or null are valid, any other type is an error\n+                    throw invalidAggTypeError(bucketPath, propertyValue);\n+                }\n+            }\n+\n+\n+            InferenceResults inference;\n+            try {\n+                 inference = model.infer(inputFields, configUpdate);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "285ae40134507395bb022490ab4e09bd24acd439"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3NzI1MzA2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/aggs/InternalInferenceAggregation.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNzozOTowMlrOGpFCWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxNjoyMzo0OVrOGpnAcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTcyNzMyMg==", "bodyText": "Its difficult to fully grok with all these branches. Any way to use the fact that these branches are all returning out of the function?\nSomething like\nif (predicate) {\n   return \"foo\";\n}\nif (predicate2) {\n   return \"bar\";\n}\nreturn null;", "url": "https://github.com/elastic/elasticsearch/pull/58193#discussion_r445727322", "createdAt": "2020-06-25T17:39:02Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/aggs/InternalInferenceAggregation.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ml.inference.aggs;\n+\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.search.aggregations.InternalAggregation;\n+import org.elasticsearch.search.aggregations.InvalidAggregationPathException;\n+import org.elasticsearch.xpack.core.ml.inference.results.ClassificationInferenceResults;\n+import org.elasticsearch.xpack.core.ml.inference.results.InferenceResults;\n+import org.elasticsearch.xpack.core.ml.inference.results.SingleValueInferenceResults;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.ClassificationConfig;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+public class InternalInferenceAggregation extends InternalAggregation {\n+\n+    private final InferenceResults inferenceResult;\n+\n+    protected InternalInferenceAggregation(String name, Map<String, Object> metadata,\n+                                           InferenceResults inferenceResult) {\n+        super(name, metadata);\n+        this.inferenceResult = inferenceResult;\n+    }\n+\n+    public InternalInferenceAggregation(StreamInput in) throws IOException {\n+        super(in);\n+        inferenceResult = in.readNamedWriteable(InferenceResults.class);\n+    }\n+\n+    public InferenceResults getInferenceResult() {\n+        return inferenceResult;\n+    }\n+\n+    @Override\n+    protected void doWriteTo(StreamOutput out) throws IOException {\n+        out.writeNamedWriteable(inferenceResult);\n+    }\n+\n+    @Override\n+    public InternalAggregation reduce(List<InternalAggregation> aggregations, ReduceContext reduceContext) {\n+        throw new UnsupportedOperationException(\"Reducing an inference aggregation is not supported\");\n+    }\n+\n+    @Override\n+    public Object getProperty(List<String> path) {\n+        if (path.isEmpty()) {\n+            return this;\n+        } else if (path.size() == 1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "285ae40134507395bb022490ab4e09bd24acd439"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI4Mzg4OA==", "bodyText": "I've changed this again \ud83d\ude1e  now it only respects the value property.\nI've deleted an awful lot of branching code because as we discussed above we can come up with a better solution in a later PR", "url": "https://github.com/elastic/elasticsearch/pull/58193#discussion_r446283888", "createdAt": "2020-06-26T16:23:49Z", "author": {"login": "davidkyle"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/aggs/InternalInferenceAggregation.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ml.inference.aggs;\n+\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.search.aggregations.InternalAggregation;\n+import org.elasticsearch.search.aggregations.InvalidAggregationPathException;\n+import org.elasticsearch.xpack.core.ml.inference.results.ClassificationInferenceResults;\n+import org.elasticsearch.xpack.core.ml.inference.results.InferenceResults;\n+import org.elasticsearch.xpack.core.ml.inference.results.SingleValueInferenceResults;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.ClassificationConfig;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+public class InternalInferenceAggregation extends InternalAggregation {\n+\n+    private final InferenceResults inferenceResult;\n+\n+    protected InternalInferenceAggregation(String name, Map<String, Object> metadata,\n+                                           InferenceResults inferenceResult) {\n+        super(name, metadata);\n+        this.inferenceResult = inferenceResult;\n+    }\n+\n+    public InternalInferenceAggregation(StreamInput in) throws IOException {\n+        super(in);\n+        inferenceResult = in.readNamedWriteable(InferenceResults.class);\n+    }\n+\n+    public InferenceResults getInferenceResult() {\n+        return inferenceResult;\n+    }\n+\n+    @Override\n+    protected void doWriteTo(StreamOutput out) throws IOException {\n+        out.writeNamedWriteable(inferenceResult);\n+    }\n+\n+    @Override\n+    public InternalAggregation reduce(List<InternalAggregation> aggregations, ReduceContext reduceContext) {\n+        throw new UnsupportedOperationException(\"Reducing an inference aggregation is not supported\");\n+    }\n+\n+    @Override\n+    public Object getProperty(List<String> path) {\n+        if (path.isEmpty()) {\n+            return this;\n+        } else if (path.size() == 1) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTcyNzMyMg=="}, "originalCommit": {"oid": "285ae40134507395bb022490ab4e09bd24acd439"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3NzI4MTgxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/aggs/ParsedInference.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNzo0NjozMlrOGpFUIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMzo1MTo1N1rOGphtsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczMTg3Mg==", "bodyText": "I do not see where this is used or referenced.", "url": "https://github.com/elastic/elasticsearch/pull/58193#discussion_r445731872", "createdAt": "2020-06-25T17:46:32Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/aggs/ParsedInference.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ml.inference.aggs;\n+\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParseException;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.search.aggregations.ParsedAggregation;\n+import org.elasticsearch.xpack.core.ml.inference.results.FeatureImportance;\n+import org.elasticsearch.xpack.core.ml.inference.results.SingleValueInferenceResults;\n+import org.elasticsearch.xpack.core.ml.inference.results.TopClassEntry;\n+import org.elasticsearch.xpack.core.ml.inference.results.WarningInferenceResults;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.ClassificationConfig;\n+\n+import java.io.IOException;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.optionalConstructorArg;\n+import static org.elasticsearch.xpack.core.ml.inference.results.SingleValueInferenceResults.FEATURE_IMPORTANCE;\n+\n+\n+/**\n+ * There isn't enough information in toXContent representation of the\n+ * {@link org.elasticsearch.xpack.core.ml.inference.results.InferenceResults}\n+ * objects to fully reconstruct them. In particular, depending on which\n+ * fields are written (result value, feature importance) it is not possible to\n+ * distinguish between a Regression result and a Classification result.\n+ *\n+ * This class parses the union all possible fields that may be written by\n+ * InferenceResults.\n+ *\n+ * The warning field is mutually exclusive with all the other fields.\n+ */\n+public class ParsedInference extends ParsedAggregation {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "285ae40134507395bb022490ab4e09bd24acd439"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTc1ODE1Ng==", "bodyText": "These are usually in the HLRC.", "url": "https://github.com/elastic/elasticsearch/pull/58193#discussion_r445758156", "createdAt": "2020-06-25T18:34:21Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/aggs/ParsedInference.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ml.inference.aggs;\n+\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParseException;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.search.aggregations.ParsedAggregation;\n+import org.elasticsearch.xpack.core.ml.inference.results.FeatureImportance;\n+import org.elasticsearch.xpack.core.ml.inference.results.SingleValueInferenceResults;\n+import org.elasticsearch.xpack.core.ml.inference.results.TopClassEntry;\n+import org.elasticsearch.xpack.core.ml.inference.results.WarningInferenceResults;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.ClassificationConfig;\n+\n+import java.io.IOException;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.optionalConstructorArg;\n+import static org.elasticsearch.xpack.core.ml.inference.results.SingleValueInferenceResults.FEATURE_IMPORTANCE;\n+\n+\n+/**\n+ * There isn't enough information in toXContent representation of the\n+ * {@link org.elasticsearch.xpack.core.ml.inference.results.InferenceResults}\n+ * objects to fully reconstruct them. In particular, depending on which\n+ * fields are written (result value, feature importance) it is not possible to\n+ * distinguish between a Regression result and a Classification result.\n+ *\n+ * This class parses the union all possible fields that may be written by\n+ * InferenceResults.\n+ *\n+ * The warning field is mutually exclusive with all the other fields.\n+ */\n+public class ParsedInference extends ParsedAggregation {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczMTg3Mg=="}, "originalCommit": {"oid": "285ae40134507395bb022490ab4e09bd24acd439"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTc2MjQ1Mg==", "bodyText": "But in that case it should be in the HLRC itself.", "url": "https://github.com/elastic/elasticsearch/pull/58193#discussion_r445762452", "createdAt": "2020-06-25T18:41:26Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/aggs/ParsedInference.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ml.inference.aggs;\n+\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParseException;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.search.aggregations.ParsedAggregation;\n+import org.elasticsearch.xpack.core.ml.inference.results.FeatureImportance;\n+import org.elasticsearch.xpack.core.ml.inference.results.SingleValueInferenceResults;\n+import org.elasticsearch.xpack.core.ml.inference.results.TopClassEntry;\n+import org.elasticsearch.xpack.core.ml.inference.results.WarningInferenceResults;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.ClassificationConfig;\n+\n+import java.io.IOException;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.optionalConstructorArg;\n+import static org.elasticsearch.xpack.core.ml.inference.results.SingleValueInferenceResults.FEATURE_IMPORTANCE;\n+\n+\n+/**\n+ * There isn't enough information in toXContent representation of the\n+ * {@link org.elasticsearch.xpack.core.ml.inference.results.InferenceResults}\n+ * objects to fully reconstruct them. In particular, depending on which\n+ * fields are written (result value, feature importance) it is not possible to\n+ * distinguish between a Regression result and a Classification result.\n+ *\n+ * This class parses the union all possible fields that may be written by\n+ * InferenceResults.\n+ *\n+ * The warning field is mutually exclusive with all the other fields.\n+ */\n+public class ParsedInference extends ParsedAggregation {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczMTg3Mg=="}, "originalCommit": {"oid": "285ae40134507395bb022490ab4e09bd24acd439"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE5MTMxOA==", "bodyText": "This class is used in InternalInferenceAggregationTests which extends InternalAggregationTestCase. It is the base test that requires an implementation of ParsedAggregation.\nI think the reason the class is in the src directory rather than test is that as Nik said it is used by the HLRC or at least that is the convention I've followed.", "url": "https://github.com/elastic/elasticsearch/pull/58193#discussion_r446191318", "createdAt": "2020-06-26T13:41:46Z", "author": {"login": "davidkyle"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/aggs/ParsedInference.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ml.inference.aggs;\n+\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParseException;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.search.aggregations.ParsedAggregation;\n+import org.elasticsearch.xpack.core.ml.inference.results.FeatureImportance;\n+import org.elasticsearch.xpack.core.ml.inference.results.SingleValueInferenceResults;\n+import org.elasticsearch.xpack.core.ml.inference.results.TopClassEntry;\n+import org.elasticsearch.xpack.core.ml.inference.results.WarningInferenceResults;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.ClassificationConfig;\n+\n+import java.io.IOException;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.optionalConstructorArg;\n+import static org.elasticsearch.xpack.core.ml.inference.results.SingleValueInferenceResults.FEATURE_IMPORTANCE;\n+\n+\n+/**\n+ * There isn't enough information in toXContent representation of the\n+ * {@link org.elasticsearch.xpack.core.ml.inference.results.InferenceResults}\n+ * objects to fully reconstruct them. In particular, depending on which\n+ * fields are written (result value, feature importance) it is not possible to\n+ * distinguish between a Regression result and a Classification result.\n+ *\n+ * This class parses the union all possible fields that may be written by\n+ * InferenceResults.\n+ *\n+ * The warning field is mutually exclusive with all the other fields.\n+ */\n+public class ParsedInference extends ParsedAggregation {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczMTg3Mg=="}, "originalCommit": {"oid": "285ae40134507395bb022490ab4e09bd24acd439"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE5NzE3MQ==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/elastic/elasticsearch/pull/58193#discussion_r446197171", "createdAt": "2020-06-26T13:51:57Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/aggs/ParsedInference.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ml.inference.aggs;\n+\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParseException;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.search.aggregations.ParsedAggregation;\n+import org.elasticsearch.xpack.core.ml.inference.results.FeatureImportance;\n+import org.elasticsearch.xpack.core.ml.inference.results.SingleValueInferenceResults;\n+import org.elasticsearch.xpack.core.ml.inference.results.TopClassEntry;\n+import org.elasticsearch.xpack.core.ml.inference.results.WarningInferenceResults;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.ClassificationConfig;\n+\n+import java.io.IOException;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.optionalConstructorArg;\n+import static org.elasticsearch.xpack.core.ml.inference.results.SingleValueInferenceResults.FEATURE_IMPORTANCE;\n+\n+\n+/**\n+ * There isn't enough information in toXContent representation of the\n+ * {@link org.elasticsearch.xpack.core.ml.inference.results.InferenceResults}\n+ * objects to fully reconstruct them. In particular, depending on which\n+ * fields are written (result value, feature importance) it is not possible to\n+ * distinguish between a Regression result and a Classification result.\n+ *\n+ * This class parses the union all possible fields that may be written by\n+ * InferenceResults.\n+ *\n+ * The warning field is mutually exclusive with all the other fields.\n+ */\n+public class ParsedInference extends ParsedAggregation {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczMTg3Mg=="}, "originalCommit": {"oid": "285ae40134507395bb022490ab4e09bd24acd439"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MzIzNjMzOnYy", "diffSide": "RIGHT", "path": "docs/reference/aggregations/pipeline/inference-bucket-aggregation.asciidoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwNjo0NzozOFrOGrY6oQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwNjo0NzozOFrOGrY6oQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODE1MDE3Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n            \n          \n          \n            \n            [[inference-bucket-agg-syntax]]", "url": "https://github.com/elastic/elasticsearch/pull/58193#discussion_r448150177", "createdAt": "2020-07-01T06:47:38Z", "author": {"login": "szabosteve"}, "path": "docs/reference/aggregations/pipeline/inference-bucket-aggregation.asciidoc", "diffHunk": "@@ -0,0 +1,75 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+[[search-aggregations-pipeline-inference-bucket-aggregation]]\n+=== Inference Bucket Aggregation\n+\n+A parent pipeline aggregation which loads a pre-trained model and performs inference on the\n+collated result field from the parent bucket aggregation.\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e8c63896d7ed268c0bbdd74d7a084badac1ae76"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MzI1ODgxOnYy", "diffSide": "RIGHT", "path": "docs/reference/aggregations/pipeline/inference-bucket-aggregation.asciidoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwNjo1NTo1M1rOGrZItg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwNjo1NTo1M1rOGrZItg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODE1Mzc4Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ==== Configuration options for Inference Models\n          \n          \n            \n            ==== Configuration options for {infer} models", "url": "https://github.com/elastic/elasticsearch/pull/58193#discussion_r448153782", "createdAt": "2020-07-01T06:55:53Z", "author": {"login": "szabosteve"}, "path": "docs/reference/aggregations/pipeline/inference-bucket-aggregation.asciidoc", "diffHunk": "@@ -0,0 +1,75 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+[[search-aggregations-pipeline-inference-bucket-aggregation]]\n+=== Inference Bucket Aggregation\n+\n+A parent pipeline aggregation which loads a pre-trained model and performs inference on the\n+collated result field from the parent bucket aggregation.\n+\n+==== Syntax\n+\n+A `inference` aggregation looks like this in isolation:\n+\n+[source,js]\n+--------------------------------------------------\n+{\n+    \"inference\": {\n+        \"model_id\": \"a_model_for_inference\", <1>\n+        \"inference_config\": { <2>\n+            \"regression_config\": {\n+                \"num_top_feature_importance_values\": 2\n+            }\n+        },\n+        \"buckets_path\": {\n+            \"avg_cost\": \"avg_agg\", <3>\n+            \"max_cost\": \"max_agg\"\n+        }\n+    }\n+}\n+--------------------------------------------------\n+// NOTCONSOLE\n+<1> The ID of model to use.\n+<2> The optional inference config which overrides the model's default settings\n+<3> Map the value of `avg_agg` to the model's input field `avg_cost`\n+\n+[[inference-bucket-params]]\n+.`inference` Parameters\n+[options=\"header\"]\n+|===\n+|Parameter Name |Description |Required |Default Value\n+| `model_id`         | The ID of the model to load and infer against       | Required  | -\n+| `inference_config` | Contains the inference type and its options. There are two types: <<inference-agg-regression-opt,`regression`>> and <<inference-agg-classification-opt,`classification`>>  | Optional | -\n+| `buckets_path`     | Defines the paths to the input aggregations and maps the aggregation names to the field names expected by the model.\n+See <<buckets-path-syntax>> for more details | Required       | -\n+|===\n+\n+\n+==== Configuration options for Inference Models", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e8c63896d7ed268c0bbdd74d7a084badac1ae76"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MzI2MTE3OnYy", "diffSide": "RIGHT", "path": "docs/reference/aggregations/pipeline/inference-bucket-aggregation.asciidoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwNjo1Njo0MlrOGrZKGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwNjo1Njo0MlrOGrZKGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODE1NDEzOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ===== Configuration options for {regression-cap} Models\n          \n          \n            \n            ===== Configuration options for {regression} models", "url": "https://github.com/elastic/elasticsearch/pull/58193#discussion_r448154138", "createdAt": "2020-07-01T06:56:42Z", "author": {"login": "szabosteve"}, "path": "docs/reference/aggregations/pipeline/inference-bucket-aggregation.asciidoc", "diffHunk": "@@ -0,0 +1,75 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+[[search-aggregations-pipeline-inference-bucket-aggregation]]\n+=== Inference Bucket Aggregation\n+\n+A parent pipeline aggregation which loads a pre-trained model and performs inference on the\n+collated result field from the parent bucket aggregation.\n+\n+==== Syntax\n+\n+A `inference` aggregation looks like this in isolation:\n+\n+[source,js]\n+--------------------------------------------------\n+{\n+    \"inference\": {\n+        \"model_id\": \"a_model_for_inference\", <1>\n+        \"inference_config\": { <2>\n+            \"regression_config\": {\n+                \"num_top_feature_importance_values\": 2\n+            }\n+        },\n+        \"buckets_path\": {\n+            \"avg_cost\": \"avg_agg\", <3>\n+            \"max_cost\": \"max_agg\"\n+        }\n+    }\n+}\n+--------------------------------------------------\n+// NOTCONSOLE\n+<1> The ID of model to use.\n+<2> The optional inference config which overrides the model's default settings\n+<3> Map the value of `avg_agg` to the model's input field `avg_cost`\n+\n+[[inference-bucket-params]]\n+.`inference` Parameters\n+[options=\"header\"]\n+|===\n+|Parameter Name |Description |Required |Default Value\n+| `model_id`         | The ID of the model to load and infer against       | Required  | -\n+| `inference_config` | Contains the inference type and its options. There are two types: <<inference-agg-regression-opt,`regression`>> and <<inference-agg-classification-opt,`classification`>>  | Optional | -\n+| `buckets_path`     | Defines the paths to the input aggregations and maps the aggregation names to the field names expected by the model.\n+See <<buckets-path-syntax>> for more details | Required       | -\n+|===\n+\n+\n+==== Configuration options for Inference Models\n+The `inference_config` setting is optional and usaully isn't required as the pre-trained models come equipped with sensible defaults.\n+In the context of aggregations some options can overridden for each of the 2 types of model.\n+\n+[discrete]\n+[[inference-agg-regression-opt]]\n+===== Configuration options for {regression-cap} Models", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e8c63896d7ed268c0bbdd74d7a084badac1ae76"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MzI2MjA3OnYy", "diffSide": "RIGHT", "path": "docs/reference/aggregations/pipeline/inference-bucket-aggregation.asciidoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwNjo1NzowMlrOGrZKow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwNjo1NzowMlrOGrZKow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODE1NDI3NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ===== Configuration options for {classification-cap} Models\n          \n          \n            \n            ===== Configuration options for {classification} models", "url": "https://github.com/elastic/elasticsearch/pull/58193#discussion_r448154275", "createdAt": "2020-07-01T06:57:02Z", "author": {"login": "szabosteve"}, "path": "docs/reference/aggregations/pipeline/inference-bucket-aggregation.asciidoc", "diffHunk": "@@ -0,0 +1,75 @@\n+[role=\"xpack\"]\n+[testenv=\"basic\"]\n+[[search-aggregations-pipeline-inference-bucket-aggregation]]\n+=== Inference Bucket Aggregation\n+\n+A parent pipeline aggregation which loads a pre-trained model and performs inference on the\n+collated result field from the parent bucket aggregation.\n+\n+==== Syntax\n+\n+A `inference` aggregation looks like this in isolation:\n+\n+[source,js]\n+--------------------------------------------------\n+{\n+    \"inference\": {\n+        \"model_id\": \"a_model_for_inference\", <1>\n+        \"inference_config\": { <2>\n+            \"regression_config\": {\n+                \"num_top_feature_importance_values\": 2\n+            }\n+        },\n+        \"buckets_path\": {\n+            \"avg_cost\": \"avg_agg\", <3>\n+            \"max_cost\": \"max_agg\"\n+        }\n+    }\n+}\n+--------------------------------------------------\n+// NOTCONSOLE\n+<1> The ID of model to use.\n+<2> The optional inference config which overrides the model's default settings\n+<3> Map the value of `avg_agg` to the model's input field `avg_cost`\n+\n+[[inference-bucket-params]]\n+.`inference` Parameters\n+[options=\"header\"]\n+|===\n+|Parameter Name |Description |Required |Default Value\n+| `model_id`         | The ID of the model to load and infer against       | Required  | -\n+| `inference_config` | Contains the inference type and its options. There are two types: <<inference-agg-regression-opt,`regression`>> and <<inference-agg-classification-opt,`classification`>>  | Optional | -\n+| `buckets_path`     | Defines the paths to the input aggregations and maps the aggregation names to the field names expected by the model.\n+See <<buckets-path-syntax>> for more details | Required       | -\n+|===\n+\n+\n+==== Configuration options for Inference Models\n+The `inference_config` setting is optional and usaully isn't required as the pre-trained models come equipped with sensible defaults.\n+In the context of aggregations some options can overridden for each of the 2 types of model.\n+\n+[discrete]\n+[[inference-agg-regression-opt]]\n+===== Configuration options for {regression-cap} Models\n+\n+`num_top_feature_importance_values`::\n+(Optional, integer)\n+include::{es-repo-dir}/ml/ml-shared.asciidoc[tag=inference-config-regression-num-top-feature-importance-values]\n+\n+[discrete]\n+[[inference-agg-classification-opt]]\n+===== Configuration options for {classification-cap} Models", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e8c63896d7ed268c0bbdd74d7a084badac1ae76"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NTYzMjcyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/aggs/InferencePipelineAggregationBuilder.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxODowOTo1MFrOGrwW2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwODo0MTo1N1rOGsDQjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODUzNDIzNQ==", "bodyText": "I'm ok to merge this, but I'll work immediately on replacing it with a rewrite. I don't think we can release this code.", "url": "https://github.com/elastic/elasticsearch/pull/58193#discussion_r448534235", "createdAt": "2020-07-01T18:09:50Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/aggs/InferencePipelineAggregationBuilder.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ml.inference.aggs;\n+\n+import org.apache.lucene.util.SetOnce;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.LatchedActionListener;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.collect.Tuple;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.search.aggregations.pipeline.AbstractPipelineAggregationBuilder;\n+import org.elasticsearch.search.aggregations.pipeline.PipelineAggregator;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.ClassificationConfig;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.ClassificationConfigUpdate;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.InferenceConfigUpdate;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.ResultsFieldUpdate;\n+import org.elasticsearch.xpack.ml.inference.loadingservice.LocalModel;\n+import org.elasticsearch.xpack.ml.inference.loadingservice.ModelLoadingService;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.TreeMap;\n+import java.util.concurrent.CountDownLatch;\n+\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.constructorArg;\n+\n+public class InferencePipelineAggregationBuilder extends AbstractPipelineAggregationBuilder<InferencePipelineAggregationBuilder> {\n+\n+    public static String NAME = \"inference\";\n+\n+    public static final ParseField MODEL_ID = new ParseField(\"model_id\");\n+    private static final ParseField INFERENCE_CONFIG = new ParseField(\"inference_config\");\n+\n+    static String AGGREGATIONS_RESULTS_FIELD = \"value\";\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static final ConstructingObjectParser<InferencePipelineAggregationBuilder,\n+        Tuple<SetOnce<ModelLoadingService>, String>> PARSER = new ConstructingObjectParser<>(\n+        NAME, false,\n+        (args, context) -> new InferencePipelineAggregationBuilder(context.v2(), context.v1(), (Map<String, String>) args[0])\n+    );\n+\n+    static {\n+        PARSER.declareObject(constructorArg(), (p, c) -> p.mapStrings(), BUCKETS_PATH_FIELD);\n+        PARSER.declareString(InferencePipelineAggregationBuilder::setModelId, MODEL_ID);\n+        PARSER.declareNamedObject(InferencePipelineAggregationBuilder::setInferenceConfig,\n+            (p, c, n) -> p.namedObject(InferenceConfigUpdate.class, n, c), INFERENCE_CONFIG);\n+    }\n+\n+    private final Map<String, String> bucketPathMap;\n+    private String modelId;\n+    private InferenceConfigUpdate inferenceConfig;\n+    private final SetOnce<ModelLoadingService> modelLoadingService;\n+\n+    public static InferencePipelineAggregationBuilder parse(SetOnce<ModelLoadingService> modelLoadingService,\n+                                                            String pipelineAggregatorName,\n+                                                            XContentParser parser) {\n+        Tuple<SetOnce<ModelLoadingService>, String> context = new Tuple<>(modelLoadingService, pipelineAggregatorName);\n+        return PARSER.apply(parser, context);\n+    }\n+\n+    public InferencePipelineAggregationBuilder(String name, SetOnce<ModelLoadingService> modelLoadingService,\n+                                               Map<String, String> bucketsPath) {\n+        super(name, NAME, new TreeMap<>(bucketsPath).values().toArray(new String[] {}));\n+        this.modelLoadingService = modelLoadingService;\n+        this.bucketPathMap = bucketsPath;\n+    }\n+\n+    public InferencePipelineAggregationBuilder(StreamInput in, SetOnce<ModelLoadingService> modelLoadingService) throws IOException {\n+        super(in, NAME);\n+        modelId = in.readString();\n+        bucketPathMap = in.readMap(StreamInput::readString, StreamInput::readString);\n+        inferenceConfig = in.readOptionalNamedWriteable(InferenceConfigUpdate.class);\n+        this.modelLoadingService = modelLoadingService;\n+    }\n+\n+    void setModelId(String modelId) {\n+        this.modelId = modelId;\n+    }\n+\n+    void setInferenceConfig(InferenceConfigUpdate inferenceConfig) {\n+        this.inferenceConfig = inferenceConfig;\n+    }\n+\n+    @Override\n+    protected void validate(ValidationContext context) {\n+        context.validateHasParent(NAME, name);\n+        if (modelId == null) {\n+            context.addValidationError(\"[model_id] must be set\");\n+        }\n+\n+        if (inferenceConfig != null) {\n+            // error if the results field is set and not equal to the only acceptable value\n+            String resultsField = inferenceConfig.getResultsField();\n+            if (Strings.isNullOrEmpty(resultsField) == false && AGGREGATIONS_RESULTS_FIELD.equals(resultsField) == false) {\n+                context.addValidationError(\"setting option [\" + ClassificationConfig.RESULTS_FIELD.getPreferredName()\n+                    + \"] to [\" + resultsField + \"] is not valid for inference aggregations\");\n+            }\n+\n+            if (inferenceConfig instanceof ClassificationConfigUpdate) {\n+                ClassificationConfigUpdate classUpdate = (ClassificationConfigUpdate)inferenceConfig;\n+\n+                // error if the top classes result field is set and not equal to the only acceptable value\n+                String topClassesField = classUpdate.getTopClassesResultsField();\n+                if (Strings.isNullOrEmpty(topClassesField) == false &&\n+                    ClassificationConfig.DEFAULT_TOP_CLASSES_RESULTS_FIELD.equals(topClassesField) == false) {\n+                    context.addValidationError(\"setting option [\" + ClassificationConfig.DEFAULT_TOP_CLASSES_RESULTS_FIELD\n+                        + \"] to [\" + topClassesField + \"] is not valid for inference aggregations\");\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void doWriteTo(StreamOutput out) throws IOException {\n+        out.writeString(modelId);\n+        out.writeMap(bucketPathMap, StreamOutput::writeString, StreamOutput::writeString);\n+        out.writeOptionalNamedWriteable(inferenceConfig);\n+    }\n+\n+    @Override\n+    protected PipelineAggregator createInternal(Map<String, Object> metaData) {\n+\n+        SetOnce<LocalModel> model = new SetOnce<>();\n+        SetOnce<Exception> error = new SetOnce<>();\n+        CountDownLatch latch = new CountDownLatch(1);\n+        ActionListener<LocalModel> listener = new LatchedActionListener<>(\n+            ActionListener.wrap(model::set, error::set), latch);\n+\n+        modelLoadingService.get().getModelForSearch(modelId, listener);\n+        try {\n+            // TODO Avoid the blocking wait\n+            latch.await();\n+        } catch (InterruptedException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a474b2e90b4ea1940bd717ad7e446251b3b829fc"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU5ODIwMw==", "bodyText": "I opened #58878 which should make this a thing we don't need to do any more. I've not made sure the tests pass with that yet, but I think it'll work soon enough.", "url": "https://github.com/elastic/elasticsearch/pull/58193#discussion_r448598203", "createdAt": "2020-07-01T20:26:36Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/aggs/InferencePipelineAggregationBuilder.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ml.inference.aggs;\n+\n+import org.apache.lucene.util.SetOnce;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.LatchedActionListener;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.collect.Tuple;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.search.aggregations.pipeline.AbstractPipelineAggregationBuilder;\n+import org.elasticsearch.search.aggregations.pipeline.PipelineAggregator;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.ClassificationConfig;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.ClassificationConfigUpdate;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.InferenceConfigUpdate;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.ResultsFieldUpdate;\n+import org.elasticsearch.xpack.ml.inference.loadingservice.LocalModel;\n+import org.elasticsearch.xpack.ml.inference.loadingservice.ModelLoadingService;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.TreeMap;\n+import java.util.concurrent.CountDownLatch;\n+\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.constructorArg;\n+\n+public class InferencePipelineAggregationBuilder extends AbstractPipelineAggregationBuilder<InferencePipelineAggregationBuilder> {\n+\n+    public static String NAME = \"inference\";\n+\n+    public static final ParseField MODEL_ID = new ParseField(\"model_id\");\n+    private static final ParseField INFERENCE_CONFIG = new ParseField(\"inference_config\");\n+\n+    static String AGGREGATIONS_RESULTS_FIELD = \"value\";\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static final ConstructingObjectParser<InferencePipelineAggregationBuilder,\n+        Tuple<SetOnce<ModelLoadingService>, String>> PARSER = new ConstructingObjectParser<>(\n+        NAME, false,\n+        (args, context) -> new InferencePipelineAggregationBuilder(context.v2(), context.v1(), (Map<String, String>) args[0])\n+    );\n+\n+    static {\n+        PARSER.declareObject(constructorArg(), (p, c) -> p.mapStrings(), BUCKETS_PATH_FIELD);\n+        PARSER.declareString(InferencePipelineAggregationBuilder::setModelId, MODEL_ID);\n+        PARSER.declareNamedObject(InferencePipelineAggregationBuilder::setInferenceConfig,\n+            (p, c, n) -> p.namedObject(InferenceConfigUpdate.class, n, c), INFERENCE_CONFIG);\n+    }\n+\n+    private final Map<String, String> bucketPathMap;\n+    private String modelId;\n+    private InferenceConfigUpdate inferenceConfig;\n+    private final SetOnce<ModelLoadingService> modelLoadingService;\n+\n+    public static InferencePipelineAggregationBuilder parse(SetOnce<ModelLoadingService> modelLoadingService,\n+                                                            String pipelineAggregatorName,\n+                                                            XContentParser parser) {\n+        Tuple<SetOnce<ModelLoadingService>, String> context = new Tuple<>(modelLoadingService, pipelineAggregatorName);\n+        return PARSER.apply(parser, context);\n+    }\n+\n+    public InferencePipelineAggregationBuilder(String name, SetOnce<ModelLoadingService> modelLoadingService,\n+                                               Map<String, String> bucketsPath) {\n+        super(name, NAME, new TreeMap<>(bucketsPath).values().toArray(new String[] {}));\n+        this.modelLoadingService = modelLoadingService;\n+        this.bucketPathMap = bucketsPath;\n+    }\n+\n+    public InferencePipelineAggregationBuilder(StreamInput in, SetOnce<ModelLoadingService> modelLoadingService) throws IOException {\n+        super(in, NAME);\n+        modelId = in.readString();\n+        bucketPathMap = in.readMap(StreamInput::readString, StreamInput::readString);\n+        inferenceConfig = in.readOptionalNamedWriteable(InferenceConfigUpdate.class);\n+        this.modelLoadingService = modelLoadingService;\n+    }\n+\n+    void setModelId(String modelId) {\n+        this.modelId = modelId;\n+    }\n+\n+    void setInferenceConfig(InferenceConfigUpdate inferenceConfig) {\n+        this.inferenceConfig = inferenceConfig;\n+    }\n+\n+    @Override\n+    protected void validate(ValidationContext context) {\n+        context.validateHasParent(NAME, name);\n+        if (modelId == null) {\n+            context.addValidationError(\"[model_id] must be set\");\n+        }\n+\n+        if (inferenceConfig != null) {\n+            // error if the results field is set and not equal to the only acceptable value\n+            String resultsField = inferenceConfig.getResultsField();\n+            if (Strings.isNullOrEmpty(resultsField) == false && AGGREGATIONS_RESULTS_FIELD.equals(resultsField) == false) {\n+                context.addValidationError(\"setting option [\" + ClassificationConfig.RESULTS_FIELD.getPreferredName()\n+                    + \"] to [\" + resultsField + \"] is not valid for inference aggregations\");\n+            }\n+\n+            if (inferenceConfig instanceof ClassificationConfigUpdate) {\n+                ClassificationConfigUpdate classUpdate = (ClassificationConfigUpdate)inferenceConfig;\n+\n+                // error if the top classes result field is set and not equal to the only acceptable value\n+                String topClassesField = classUpdate.getTopClassesResultsField();\n+                if (Strings.isNullOrEmpty(topClassesField) == false &&\n+                    ClassificationConfig.DEFAULT_TOP_CLASSES_RESULTS_FIELD.equals(topClassesField) == false) {\n+                    context.addValidationError(\"setting option [\" + ClassificationConfig.DEFAULT_TOP_CLASSES_RESULTS_FIELD\n+                        + \"] to [\" + topClassesField + \"] is not valid for inference aggregations\");\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void doWriteTo(StreamOutput out) throws IOException {\n+        out.writeString(modelId);\n+        out.writeMap(bucketPathMap, StreamOutput::writeString, StreamOutput::writeString);\n+        out.writeOptionalNamedWriteable(inferenceConfig);\n+    }\n+\n+    @Override\n+    protected PipelineAggregator createInternal(Map<String, Object> metaData) {\n+\n+        SetOnce<LocalModel> model = new SetOnce<>();\n+        SetOnce<Exception> error = new SetOnce<>();\n+        CountDownLatch latch = new CountDownLatch(1);\n+        ActionListener<LocalModel> listener = new LatchedActionListener<>(\n+            ActionListener.wrap(model::set, error::set), latch);\n+\n+        modelLoadingService.get().getModelForSearch(modelId, listener);\n+        try {\n+            // TODO Avoid the blocking wait\n+            latch.await();\n+        } catch (InterruptedException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODUzNDIzNQ=="}, "originalCommit": {"oid": "a474b2e90b4ea1940bd717ad7e446251b3b829fc"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg0MzkxNg==", "bodyText": "Thanks for the review", "url": "https://github.com/elastic/elasticsearch/pull/58193#discussion_r448843916", "createdAt": "2020-07-02T08:41:57Z", "author": {"login": "davidkyle"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/aggs/InferencePipelineAggregationBuilder.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ml.inference.aggs;\n+\n+import org.apache.lucene.util.SetOnce;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.LatchedActionListener;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.collect.Tuple;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.search.aggregations.pipeline.AbstractPipelineAggregationBuilder;\n+import org.elasticsearch.search.aggregations.pipeline.PipelineAggregator;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.ClassificationConfig;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.ClassificationConfigUpdate;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.InferenceConfigUpdate;\n+import org.elasticsearch.xpack.core.ml.inference.trainedmodel.ResultsFieldUpdate;\n+import org.elasticsearch.xpack.ml.inference.loadingservice.LocalModel;\n+import org.elasticsearch.xpack.ml.inference.loadingservice.ModelLoadingService;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.TreeMap;\n+import java.util.concurrent.CountDownLatch;\n+\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.constructorArg;\n+\n+public class InferencePipelineAggregationBuilder extends AbstractPipelineAggregationBuilder<InferencePipelineAggregationBuilder> {\n+\n+    public static String NAME = \"inference\";\n+\n+    public static final ParseField MODEL_ID = new ParseField(\"model_id\");\n+    private static final ParseField INFERENCE_CONFIG = new ParseField(\"inference_config\");\n+\n+    static String AGGREGATIONS_RESULTS_FIELD = \"value\";\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static final ConstructingObjectParser<InferencePipelineAggregationBuilder,\n+        Tuple<SetOnce<ModelLoadingService>, String>> PARSER = new ConstructingObjectParser<>(\n+        NAME, false,\n+        (args, context) -> new InferencePipelineAggregationBuilder(context.v2(), context.v1(), (Map<String, String>) args[0])\n+    );\n+\n+    static {\n+        PARSER.declareObject(constructorArg(), (p, c) -> p.mapStrings(), BUCKETS_PATH_FIELD);\n+        PARSER.declareString(InferencePipelineAggregationBuilder::setModelId, MODEL_ID);\n+        PARSER.declareNamedObject(InferencePipelineAggregationBuilder::setInferenceConfig,\n+            (p, c, n) -> p.namedObject(InferenceConfigUpdate.class, n, c), INFERENCE_CONFIG);\n+    }\n+\n+    private final Map<String, String> bucketPathMap;\n+    private String modelId;\n+    private InferenceConfigUpdate inferenceConfig;\n+    private final SetOnce<ModelLoadingService> modelLoadingService;\n+\n+    public static InferencePipelineAggregationBuilder parse(SetOnce<ModelLoadingService> modelLoadingService,\n+                                                            String pipelineAggregatorName,\n+                                                            XContentParser parser) {\n+        Tuple<SetOnce<ModelLoadingService>, String> context = new Tuple<>(modelLoadingService, pipelineAggregatorName);\n+        return PARSER.apply(parser, context);\n+    }\n+\n+    public InferencePipelineAggregationBuilder(String name, SetOnce<ModelLoadingService> modelLoadingService,\n+                                               Map<String, String> bucketsPath) {\n+        super(name, NAME, new TreeMap<>(bucketsPath).values().toArray(new String[] {}));\n+        this.modelLoadingService = modelLoadingService;\n+        this.bucketPathMap = bucketsPath;\n+    }\n+\n+    public InferencePipelineAggregationBuilder(StreamInput in, SetOnce<ModelLoadingService> modelLoadingService) throws IOException {\n+        super(in, NAME);\n+        modelId = in.readString();\n+        bucketPathMap = in.readMap(StreamInput::readString, StreamInput::readString);\n+        inferenceConfig = in.readOptionalNamedWriteable(InferenceConfigUpdate.class);\n+        this.modelLoadingService = modelLoadingService;\n+    }\n+\n+    void setModelId(String modelId) {\n+        this.modelId = modelId;\n+    }\n+\n+    void setInferenceConfig(InferenceConfigUpdate inferenceConfig) {\n+        this.inferenceConfig = inferenceConfig;\n+    }\n+\n+    @Override\n+    protected void validate(ValidationContext context) {\n+        context.validateHasParent(NAME, name);\n+        if (modelId == null) {\n+            context.addValidationError(\"[model_id] must be set\");\n+        }\n+\n+        if (inferenceConfig != null) {\n+            // error if the results field is set and not equal to the only acceptable value\n+            String resultsField = inferenceConfig.getResultsField();\n+            if (Strings.isNullOrEmpty(resultsField) == false && AGGREGATIONS_RESULTS_FIELD.equals(resultsField) == false) {\n+                context.addValidationError(\"setting option [\" + ClassificationConfig.RESULTS_FIELD.getPreferredName()\n+                    + \"] to [\" + resultsField + \"] is not valid for inference aggregations\");\n+            }\n+\n+            if (inferenceConfig instanceof ClassificationConfigUpdate) {\n+                ClassificationConfigUpdate classUpdate = (ClassificationConfigUpdate)inferenceConfig;\n+\n+                // error if the top classes result field is set and not equal to the only acceptable value\n+                String topClassesField = classUpdate.getTopClassesResultsField();\n+                if (Strings.isNullOrEmpty(topClassesField) == false &&\n+                    ClassificationConfig.DEFAULT_TOP_CLASSES_RESULTS_FIELD.equals(topClassesField) == false) {\n+                    context.addValidationError(\"setting option [\" + ClassificationConfig.DEFAULT_TOP_CLASSES_RESULTS_FIELD\n+                        + \"] to [\" + topClassesField + \"] is not valid for inference aggregations\");\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void doWriteTo(StreamOutput out) throws IOException {\n+        out.writeString(modelId);\n+        out.writeMap(bucketPathMap, StreamOutput::writeString, StreamOutput::writeString);\n+        out.writeOptionalNamedWriteable(inferenceConfig);\n+    }\n+\n+    @Override\n+    protected PipelineAggregator createInternal(Map<String, Object> metaData) {\n+\n+        SetOnce<LocalModel> model = new SetOnce<>();\n+        SetOnce<Exception> error = new SetOnce<>();\n+        CountDownLatch latch = new CountDownLatch(1);\n+        ActionListener<LocalModel> listener = new LatchedActionListener<>(\n+            ActionListener.wrap(model::set, error::set), latch);\n+\n+        modelLoadingService.get().getModelForSearch(modelId, listener);\n+        try {\n+            // TODO Avoid the blocking wait\n+            latch.await();\n+        } catch (InterruptedException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODUzNDIzNQ=="}, "originalCommit": {"oid": "a474b2e90b4ea1940bd717ad7e446251b3b829fc"}, "originalPosition": 144}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1521, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}