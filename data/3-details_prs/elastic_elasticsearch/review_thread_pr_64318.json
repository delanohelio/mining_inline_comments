{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTExODU1Mjgx", "number": 64318, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxNTo1NTozNlrOEzXZbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwMDoyNDo1OFrOEzh1tA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyMjk2MTc0OnYy", "diffSide": "RIGHT", "path": "docs/reference/aggregations.asciidoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxNTo1NTozNlrOHqixOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxNTo1NTozNlrOHqixOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDM3MTg5OA==", "bodyText": "We actually said a while back that we think we can remove \"experimental\" on matrix: #53065\nSo you can probably drop this.", "url": "https://github.com/elastic/elasticsearch/pull/64318#discussion_r514371898", "createdAt": "2020-10-29T15:55:36Z", "author": {"login": "nik9000"}, "path": "docs/reference/aggregations.asciidoc", "diffHunk": "@@ -3,117 +3,367 @@\n \n [partintro]\n --\n-The aggregations framework helps provide aggregated data based on a search query. It is based on simple building blocks\n-called aggregations, that can be composed in order to build complex summaries of the data.\n+An aggregation summarizes your data as metrics, statistics, or other analytics.\n+Aggregations help you answer questions like:\n \n-An aggregation can be seen as a _unit-of-work_ that builds analytic information over a set of documents. The context of\n-the execution defines what this document set is (e.g. a top-level aggregation executes within the context of the executed\n-query/filters of the search request).\n+* What's the average load time for my website?\n+* Who are my most valuable customers based on transaction volume?\n+* What would be considered a large file on my network?\n+* How many products are in each product category?\n \n-There are many different types of aggregations, each with its own purpose and output. To better understand these types,\n-it is often easier to break them into four main families:\n+{es} organizes aggregations into four categories:\n \n-<<search-aggregations-bucket, _Bucketing_>>::\n-\t\t\t\tA family of aggregations that build buckets, where each bucket is associated with a _key_ and a document\n-\t\t\t\tcriterion. When the aggregation is executed, all the buckets criteria are evaluated on every document in\n-\t\t\t\tthe context and when a criterion matches, the document is considered to \"fall in\" the relevant bucket.\n-\t\t\t\tBy the end of the aggregation process, we'll end up with a list of buckets - each one with a set of\n-\t\t\t\tdocuments that \"belong\" to it.\n+* <<search-aggregations-bucket,Bucket>> aggregations that\n+group documents into buckets, also called bins, based on field values, ranges,\n+or other criteria.\n \n-<<search-aggregations-metrics, _Metric_>>::\n-\t\t\t\tAggregations that keep track and compute metrics over a set of documents.\n+* <<search-aggregations-matrix,Matrix>> aggregations experimental:[] that output", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dac07bf80ba7f16a1e275d85502c17586b7a4c44"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyMjk2ODY3OnYy", "diffSide": "RIGHT", "path": "docs/reference/aggregations.asciidoc", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxNTo1NzowMFrOHqi1mg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxODozMzo0MlrOHqpbVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDM3MzAxOA==", "bodyText": "I'd flip the order of these to \"metric\", \"bucket\", \"pipeline\", and \"matrix\".", "url": "https://github.com/elastic/elasticsearch/pull/64318#discussion_r514373018", "createdAt": "2020-10-29T15:57:00Z", "author": {"login": "nik9000"}, "path": "docs/reference/aggregations.asciidoc", "diffHunk": "@@ -3,117 +3,367 @@\n \n [partintro]\n --\n-The aggregations framework helps provide aggregated data based on a search query. It is based on simple building blocks\n-called aggregations, that can be composed in order to build complex summaries of the data.\n+An aggregation summarizes your data as metrics, statistics, or other analytics.\n+Aggregations help you answer questions like:\n \n-An aggregation can be seen as a _unit-of-work_ that builds analytic information over a set of documents. The context of\n-the execution defines what this document set is (e.g. a top-level aggregation executes within the context of the executed\n-query/filters of the search request).\n+* What's the average load time for my website?\n+* Who are my most valuable customers based on transaction volume?\n+* What would be considered a large file on my network?\n+* How many products are in each product category?\n \n-There are many different types of aggregations, each with its own purpose and output. To better understand these types,\n-it is often easier to break them into four main families:\n+{es} organizes aggregations into four categories:\n \n-<<search-aggregations-bucket, _Bucketing_>>::\n-\t\t\t\tA family of aggregations that build buckets, where each bucket is associated with a _key_ and a document\n-\t\t\t\tcriterion. When the aggregation is executed, all the buckets criteria are evaluated on every document in\n-\t\t\t\tthe context and when a criterion matches, the document is considered to \"fall in\" the relevant bucket.\n-\t\t\t\tBy the end of the aggregation process, we'll end up with a list of buckets - each one with a set of\n-\t\t\t\tdocuments that \"belong\" to it.\n+* <<search-aggregations-bucket,Bucket>> aggregations that", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dac07bf80ba7f16a1e275d85502c17586b7a4c44"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDM3NDQ0Ng==", "bodyText": "It feels like the order of importance of concepts is  \"what you calculate\" \"how you group\" \"how you manipulate the results\" \"some tools for handling covariance\". \"Matrix\" isn't really a family at this point because there really is only matrix stats too. It is kind of a fancy \"metric\" aggregator.", "url": "https://github.com/elastic/elasticsearch/pull/64318#discussion_r514374446", "createdAt": "2020-10-29T15:58:54Z", "author": {"login": "nik9000"}, "path": "docs/reference/aggregations.asciidoc", "diffHunk": "@@ -3,117 +3,367 @@\n \n [partintro]\n --\n-The aggregations framework helps provide aggregated data based on a search query. It is based on simple building blocks\n-called aggregations, that can be composed in order to build complex summaries of the data.\n+An aggregation summarizes your data as metrics, statistics, or other analytics.\n+Aggregations help you answer questions like:\n \n-An aggregation can be seen as a _unit-of-work_ that builds analytic information over a set of documents. The context of\n-the execution defines what this document set is (e.g. a top-level aggregation executes within the context of the executed\n-query/filters of the search request).\n+* What's the average load time for my website?\n+* Who are my most valuable customers based on transaction volume?\n+* What would be considered a large file on my network?\n+* How many products are in each product category?\n \n-There are many different types of aggregations, each with its own purpose and output. To better understand these types,\n-it is often easier to break them into four main families:\n+{es} organizes aggregations into four categories:\n \n-<<search-aggregations-bucket, _Bucketing_>>::\n-\t\t\t\tA family of aggregations that build buckets, where each bucket is associated with a _key_ and a document\n-\t\t\t\tcriterion. When the aggregation is executed, all the buckets criteria are evaluated on every document in\n-\t\t\t\tthe context and when a criterion matches, the document is considered to \"fall in\" the relevant bucket.\n-\t\t\t\tBy the end of the aggregation process, we'll end up with a list of buckets - each one with a set of\n-\t\t\t\tdocuments that \"belong\" to it.\n+* <<search-aggregations-bucket,Bucket>> aggregations that", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDM3MzAxOA=="}, "originalCommit": {"oid": "dac07bf80ba7f16a1e275d85502c17586b7a4c44"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ4MDk4MA==", "bodyText": "With ea072c6, I dropped the Matrix family entirely and moved the stats matrix agg under the Metrics family. That should make things simpler for users. However, I can revert if needed. Thanks!", "url": "https://github.com/elastic/elasticsearch/pull/64318#discussion_r514480980", "createdAt": "2020-10-29T18:33:42Z", "author": {"login": "jrodewig"}, "path": "docs/reference/aggregations.asciidoc", "diffHunk": "@@ -3,117 +3,367 @@\n \n [partintro]\n --\n-The aggregations framework helps provide aggregated data based on a search query. It is based on simple building blocks\n-called aggregations, that can be composed in order to build complex summaries of the data.\n+An aggregation summarizes your data as metrics, statistics, or other analytics.\n+Aggregations help you answer questions like:\n \n-An aggregation can be seen as a _unit-of-work_ that builds analytic information over a set of documents. The context of\n-the execution defines what this document set is (e.g. a top-level aggregation executes within the context of the executed\n-query/filters of the search request).\n+* What's the average load time for my website?\n+* Who are my most valuable customers based on transaction volume?\n+* What would be considered a large file on my network?\n+* How many products are in each product category?\n \n-There are many different types of aggregations, each with its own purpose and output. To better understand these types,\n-it is often easier to break them into four main families:\n+{es} organizes aggregations into four categories:\n \n-<<search-aggregations-bucket, _Bucketing_>>::\n-\t\t\t\tA family of aggregations that build buckets, where each bucket is associated with a _key_ and a document\n-\t\t\t\tcriterion. When the aggregation is executed, all the buckets criteria are evaluated on every document in\n-\t\t\t\tthe context and when a criterion matches, the document is considered to \"fall in\" the relevant bucket.\n-\t\t\t\tBy the end of the aggregation process, we'll end up with a list of buckets - each one with a set of\n-\t\t\t\tdocuments that \"belong\" to it.\n+* <<search-aggregations-bucket,Bucket>> aggregations that", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDM3MzAxOA=="}, "originalCommit": {"oid": "dac07bf80ba7f16a1e275d85502c17586b7a4c44"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyMjk4NDYwOnYy", "diffSide": "RIGHT", "path": "docs/reference/aggregations.asciidoc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxNjowMDoxN1rOHqi_OA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxODozNTowNFrOHqpeog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDM3NTQ4MA==", "bodyText": "Collapsed sections with the results could be nice here, just so folks can see them.", "url": "https://github.com/elastic/elasticsearch/pull/64318#discussion_r514375480", "createdAt": "2020-10-29T16:00:17Z", "author": {"login": "nik9000"}, "path": "docs/reference/aggregations.asciidoc", "diffHunk": "@@ -3,117 +3,367 @@\n \n [partintro]\n --\n-The aggregations framework helps provide aggregated data based on a search query. It is based on simple building blocks\n-called aggregations, that can be composed in order to build complex summaries of the data.\n+An aggregation summarizes your data as metrics, statistics, or other analytics.\n+Aggregations help you answer questions like:\n \n-An aggregation can be seen as a _unit-of-work_ that builds analytic information over a set of documents. The context of\n-the execution defines what this document set is (e.g. a top-level aggregation executes within the context of the executed\n-query/filters of the search request).\n+* What's the average load time for my website?\n+* Who are my most valuable customers based on transaction volume?\n+* What would be considered a large file on my network?\n+* How many products are in each product category?\n \n-There are many different types of aggregations, each with its own purpose and output. To better understand these types,\n-it is often easier to break them into four main families:\n+{es} organizes aggregations into four categories:\n \n-<<search-aggregations-bucket, _Bucketing_>>::\n-\t\t\t\tA family of aggregations that build buckets, where each bucket is associated with a _key_ and a document\n-\t\t\t\tcriterion. When the aggregation is executed, all the buckets criteria are evaluated on every document in\n-\t\t\t\tthe context and when a criterion matches, the document is considered to \"fall in\" the relevant bucket.\n-\t\t\t\tBy the end of the aggregation process, we'll end up with a list of buckets - each one with a set of\n-\t\t\t\tdocuments that \"belong\" to it.\n+* <<search-aggregations-bucket,Bucket>> aggregations that\n+group documents into buckets, also called bins, based on field values, ranges,\n+or other criteria.\n \n-<<search-aggregations-metrics, _Metric_>>::\n-\t\t\t\tAggregations that keep track and compute metrics over a set of documents.\n+* <<search-aggregations-matrix,Matrix>> aggregations experimental:[] that output\n+a matrix based on multiple fields.\n \n-<<search-aggregations-matrix, _Matrix_>>::\n-                A family of aggregations that operate on multiple fields and produce a matrix result based on the\n-                values extracted from the requested document fields. Unlike metric and bucket aggregations, this\n-                aggregation family does not yet support scripting.\n+* <<search-aggregations-metrics,Metric>> aggregations that calculate metrics,\n+such as a sum or average, from field values.\n \n-<<search-aggregations-pipeline, _Pipeline_>>::\n-\t\t\t\tAggregations that aggregate the output of other aggregations and their associated metrics\n+* <<search-aggregations-pipeline,Pipeline>> aggregations that take input from\n+other aggregations instead of documents or fields.\n \n-The interesting part comes next. Since each bucket effectively defines a document set (all documents belonging to\n-the bucket), one can potentially associate aggregations on the bucket level, and those will execute within the context\n-of that bucket. This is where the real power of aggregations kicks in: *aggregations can be nested!*\n+[discrete]\n+[[run-an-agg]]\n+=== Run an aggregation\n+\n+{es} runs aggregations as part of a <<search-your-data,search>>. To run an\n+aggregation, use the <<search-search,search API>>'s `aggs` parameter. The\n+following search runs `my-agg-name`, a\n+<<search-aggregations-bucket-terms-aggregation,terms aggregation>> on\n+`my-field`:\n+\n+[source,console]\n+----\n+GET /my-index-000001/_search\n+{\n+  \"aggs\": {\n+    \"my-agg-name\": {\n+      \"terms\": {\n+        \"field\": \"my-field\"\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[setup:my_index]\n+// TEST[s/my-field/http.request.method/]\n+\n+[discrete]\n+[[change-agg-scope]]\n+=== Change an aggregation's scope\n+\n+Use the `query` parameter to limit the documents on which an aggregation runs:\n+\n+[source,console]\n+----\n+GET /my-index-000001/_search\n+{\n+  \"query\": {\n+    \"range\": {\n+      \"@timestamp\": {\n+        \"gte\": \"now-1d/d\",\n+        \"lt\": \"now/d\"\n+      }\n+    }\n+  },\n+  \"aggs\": {\n+    \"my-agg-name\": {\n+      \"terms\": {\n+        \"field\": \"my-field\"\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[setup:my_index]\n+// TEST[s/my-field/http.request.method/]\n \n-NOTE:\tBucketing aggregations can have sub-aggregations (bucketing or metric). The sub-aggregations will be computed for\n-\t\tthe buckets which their parent aggregation generates. There is no hard limit on the level/depth of nested\n-\t\taggregations (one can nest an aggregation under a \"parent\" aggregation, which is itself a sub-aggregation of\n-\t\tanother higher-level aggregation).\n+[discrete]\n+[[return-only-agg-results]]\n+=== Return only aggregation results\n \n-NOTE:   Aggregations operate on the `double` representation of\n-        the data. As a consequence, the result may be approximate when running on longs\n-        whose absolute value is greater than `2^53`.\n+By default, searches containing an aggregation return both search hits and\n+aggregation results. To return only aggregation results, set `size` to `0`:\n+\n+[source,console]\n+----\n+GET /my-index-000001/_search\n+{\n+  \"size\": 0,\n+  \"aggs\": {\n+    \"my-agg-name\": {\n+      \"terms\": {\n+        \"field\": \"my-field\"\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[setup:my_index]\n+// TEST[s/my-field/http.request.method/]\n \n [discrete]\n-== Structuring Aggregations\n+[[run-multiple-aggs]]\n+=== Run multiple aggregations\n \n-The following snippet captures the basic structure of aggregations:\n+You can specify multiple aggregations in the same request:\n \n-[source,js]\n---------------------------------------------------\n-\"aggregations\" : {\n-    \"<aggregation_name>\" : {\n-        \"<aggregation_type>\" : {\n-            <aggregation_body>\n+[source,console]\n+----\n+GET /my-index-000001/_search\n+{\n+  \"aggs\": {\n+    \"my-first-agg-name\": {\n+      \"terms\": {\n+        \"field\": \"my-field\"\n+      }\n+    },\n+    \"my-second-agg-name\": {\n+      \"avg\": {\n+        \"field\": \"my-other-field\"\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[setup:my_index]\n+// TEST[s/my-field/http.request.method/]\n+// TEST[s/my-other-field/http.response.bytes/]\n+\n+[discrete]\n+[[run-sub-aggs]]\n+=== Run sub-aggregations\n+\n+Bucket aggregations support bucket or metric sub-aggregations. For example, a\n+terms aggregation with an <<search-aggregations-metrics-avg-aggregation,avg>>\n+sub-aggregation calculates an average value for each bucket of documents. There\n+is no level or depth limit for nesting sub-aggregations.\n+\n+[source,console]\n+----\n+GET /my-index-000001/_search\n+{\n+  \"aggs\": {\n+    \"my-agg-name\": {\n+      \"terms\": {\n+        \"field\": \"my-field\"\n+      },\n+      \"aggs\": {\n+        \"my-sub-agg-name\": {\n+          \"avg\": {\n+            \"field\": \"my-other-field\"\n+          }\n         }\n-        [,\"meta\" : {  [<meta_data_body>] } ]?\n-        [,\"aggregations\" : { [<sub_aggregation>]+ } ]?\n+      }\n     }\n-    [,\"<aggregation_name_2>\" : { ... } ]*\n+  }\n }\n---------------------------------------------------\n-// NOTCONSOLE\n-\n-The `aggregations` object (the key `aggs` can also be used) in the JSON holds the aggregations to be computed. Each aggregation\n-is associated with a logical name that the user defines (e.g. if the aggregation computes the average price, then it would\n-make sense to name it `avg_price`). These logical names will also be used to uniquely identify the aggregations in the\n-response. Each aggregation has a specific type (`<aggregation_type>` in the above snippet) and is typically the first\n-key within the named aggregation body. Each type of aggregation defines its own body, depending on the nature of the\n-aggregation (e.g. an `avg` aggregation on a specific field will define the field on which the average will be calculated).\n-At the same level of the aggregation type definition, one can optionally define a set of additional aggregations,\n-though this only makes sense if the aggregation you defined is of a bucketing nature. In this scenario, the\n-sub-aggregations you define on the bucketing aggregation level will be computed for all the buckets built by the\n-bucketing aggregation. For example, if you define a set of aggregations under the `range` aggregation, the\n-sub-aggregations will be computed for the range buckets that are defined.\n+----\n+// TEST[setup:my_index]\n+// TEST[s/my-field/http.request.method/]\n+// TEST[s/my-other-field/http.response.bytes/]\n ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dac07bf80ba7f16a1e275d85502c17586b7a4c44"}, "originalPosition": 223}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ4MTgyNg==", "bodyText": "I selectively added some more responses. However, I'm trying to avoid collapsible sections as I've gotten feedback from others that they're easy to overlook and sometimes annoying to click through.", "url": "https://github.com/elastic/elasticsearch/pull/64318#discussion_r514481826", "createdAt": "2020-10-29T18:35:04Z", "author": {"login": "jrodewig"}, "path": "docs/reference/aggregations.asciidoc", "diffHunk": "@@ -3,117 +3,367 @@\n \n [partintro]\n --\n-The aggregations framework helps provide aggregated data based on a search query. It is based on simple building blocks\n-called aggregations, that can be composed in order to build complex summaries of the data.\n+An aggregation summarizes your data as metrics, statistics, or other analytics.\n+Aggregations help you answer questions like:\n \n-An aggregation can be seen as a _unit-of-work_ that builds analytic information over a set of documents. The context of\n-the execution defines what this document set is (e.g. a top-level aggregation executes within the context of the executed\n-query/filters of the search request).\n+* What's the average load time for my website?\n+* Who are my most valuable customers based on transaction volume?\n+* What would be considered a large file on my network?\n+* How many products are in each product category?\n \n-There are many different types of aggregations, each with its own purpose and output. To better understand these types,\n-it is often easier to break them into four main families:\n+{es} organizes aggregations into four categories:\n \n-<<search-aggregations-bucket, _Bucketing_>>::\n-\t\t\t\tA family of aggregations that build buckets, where each bucket is associated with a _key_ and a document\n-\t\t\t\tcriterion. When the aggregation is executed, all the buckets criteria are evaluated on every document in\n-\t\t\t\tthe context and when a criterion matches, the document is considered to \"fall in\" the relevant bucket.\n-\t\t\t\tBy the end of the aggregation process, we'll end up with a list of buckets - each one with a set of\n-\t\t\t\tdocuments that \"belong\" to it.\n+* <<search-aggregations-bucket,Bucket>> aggregations that\n+group documents into buckets, also called bins, based on field values, ranges,\n+or other criteria.\n \n-<<search-aggregations-metrics, _Metric_>>::\n-\t\t\t\tAggregations that keep track and compute metrics over a set of documents.\n+* <<search-aggregations-matrix,Matrix>> aggregations experimental:[] that output\n+a matrix based on multiple fields.\n \n-<<search-aggregations-matrix, _Matrix_>>::\n-                A family of aggregations that operate on multiple fields and produce a matrix result based on the\n-                values extracted from the requested document fields. Unlike metric and bucket aggregations, this\n-                aggregation family does not yet support scripting.\n+* <<search-aggregations-metrics,Metric>> aggregations that calculate metrics,\n+such as a sum or average, from field values.\n \n-<<search-aggregations-pipeline, _Pipeline_>>::\n-\t\t\t\tAggregations that aggregate the output of other aggregations and their associated metrics\n+* <<search-aggregations-pipeline,Pipeline>> aggregations that take input from\n+other aggregations instead of documents or fields.\n \n-The interesting part comes next. Since each bucket effectively defines a document set (all documents belonging to\n-the bucket), one can potentially associate aggregations on the bucket level, and those will execute within the context\n-of that bucket. This is where the real power of aggregations kicks in: *aggregations can be nested!*\n+[discrete]\n+[[run-an-agg]]\n+=== Run an aggregation\n+\n+{es} runs aggregations as part of a <<search-your-data,search>>. To run an\n+aggregation, use the <<search-search,search API>>'s `aggs` parameter. The\n+following search runs `my-agg-name`, a\n+<<search-aggregations-bucket-terms-aggregation,terms aggregation>> on\n+`my-field`:\n+\n+[source,console]\n+----\n+GET /my-index-000001/_search\n+{\n+  \"aggs\": {\n+    \"my-agg-name\": {\n+      \"terms\": {\n+        \"field\": \"my-field\"\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[setup:my_index]\n+// TEST[s/my-field/http.request.method/]\n+\n+[discrete]\n+[[change-agg-scope]]\n+=== Change an aggregation's scope\n+\n+Use the `query` parameter to limit the documents on which an aggregation runs:\n+\n+[source,console]\n+----\n+GET /my-index-000001/_search\n+{\n+  \"query\": {\n+    \"range\": {\n+      \"@timestamp\": {\n+        \"gte\": \"now-1d/d\",\n+        \"lt\": \"now/d\"\n+      }\n+    }\n+  },\n+  \"aggs\": {\n+    \"my-agg-name\": {\n+      \"terms\": {\n+        \"field\": \"my-field\"\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[setup:my_index]\n+// TEST[s/my-field/http.request.method/]\n \n-NOTE:\tBucketing aggregations can have sub-aggregations (bucketing or metric). The sub-aggregations will be computed for\n-\t\tthe buckets which their parent aggregation generates. There is no hard limit on the level/depth of nested\n-\t\taggregations (one can nest an aggregation under a \"parent\" aggregation, which is itself a sub-aggregation of\n-\t\tanother higher-level aggregation).\n+[discrete]\n+[[return-only-agg-results]]\n+=== Return only aggregation results\n \n-NOTE:   Aggregations operate on the `double` representation of\n-        the data. As a consequence, the result may be approximate when running on longs\n-        whose absolute value is greater than `2^53`.\n+By default, searches containing an aggregation return both search hits and\n+aggregation results. To return only aggregation results, set `size` to `0`:\n+\n+[source,console]\n+----\n+GET /my-index-000001/_search\n+{\n+  \"size\": 0,\n+  \"aggs\": {\n+    \"my-agg-name\": {\n+      \"terms\": {\n+        \"field\": \"my-field\"\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[setup:my_index]\n+// TEST[s/my-field/http.request.method/]\n \n [discrete]\n-== Structuring Aggregations\n+[[run-multiple-aggs]]\n+=== Run multiple aggregations\n \n-The following snippet captures the basic structure of aggregations:\n+You can specify multiple aggregations in the same request:\n \n-[source,js]\n---------------------------------------------------\n-\"aggregations\" : {\n-    \"<aggregation_name>\" : {\n-        \"<aggregation_type>\" : {\n-            <aggregation_body>\n+[source,console]\n+----\n+GET /my-index-000001/_search\n+{\n+  \"aggs\": {\n+    \"my-first-agg-name\": {\n+      \"terms\": {\n+        \"field\": \"my-field\"\n+      }\n+    },\n+    \"my-second-agg-name\": {\n+      \"avg\": {\n+        \"field\": \"my-other-field\"\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[setup:my_index]\n+// TEST[s/my-field/http.request.method/]\n+// TEST[s/my-other-field/http.response.bytes/]\n+\n+[discrete]\n+[[run-sub-aggs]]\n+=== Run sub-aggregations\n+\n+Bucket aggregations support bucket or metric sub-aggregations. For example, a\n+terms aggregation with an <<search-aggregations-metrics-avg-aggregation,avg>>\n+sub-aggregation calculates an average value for each bucket of documents. There\n+is no level or depth limit for nesting sub-aggregations.\n+\n+[source,console]\n+----\n+GET /my-index-000001/_search\n+{\n+  \"aggs\": {\n+    \"my-agg-name\": {\n+      \"terms\": {\n+        \"field\": \"my-field\"\n+      },\n+      \"aggs\": {\n+        \"my-sub-agg-name\": {\n+          \"avg\": {\n+            \"field\": \"my-other-field\"\n+          }\n         }\n-        [,\"meta\" : {  [<meta_data_body>] } ]?\n-        [,\"aggregations\" : { [<sub_aggregation>]+ } ]?\n+      }\n     }\n-    [,\"<aggregation_name_2>\" : { ... } ]*\n+  }\n }\n---------------------------------------------------\n-// NOTCONSOLE\n-\n-The `aggregations` object (the key `aggs` can also be used) in the JSON holds the aggregations to be computed. Each aggregation\n-is associated with a logical name that the user defines (e.g. if the aggregation computes the average price, then it would\n-make sense to name it `avg_price`). These logical names will also be used to uniquely identify the aggregations in the\n-response. Each aggregation has a specific type (`<aggregation_type>` in the above snippet) and is typically the first\n-key within the named aggregation body. Each type of aggregation defines its own body, depending on the nature of the\n-aggregation (e.g. an `avg` aggregation on a specific field will define the field on which the average will be calculated).\n-At the same level of the aggregation type definition, one can optionally define a set of additional aggregations,\n-though this only makes sense if the aggregation you defined is of a bucketing nature. In this scenario, the\n-sub-aggregations you define on the bucketing aggregation level will be computed for all the buckets built by the\n-bucketing aggregation. For example, if you define a set of aggregations under the `range` aggregation, the\n-sub-aggregations will be computed for the range buckets that are defined.\n+----\n+// TEST[setup:my_index]\n+// TEST[s/my-field/http.request.method/]\n+// TEST[s/my-other-field/http.response.bytes/]\n ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDM3NTQ4MA=="}, "originalCommit": {"oid": "dac07bf80ba7f16a1e275d85502c17586b7a4c44"}, "originalPosition": 223}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyMjk5Njc2OnYy", "diffSide": "RIGHT", "path": "docs/reference/aggregations.asciidoc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxNjowMjozMVrOHqjGtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxODozNTozMFrOHqpflA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDM3NzM5Nw==", "bodyText": "I think that the preference is less important than making sure you have size:0. If you have two shard copies you'll fill the cache pretty quick without preference. But if you don't have size:0 you can't get it at all!", "url": "https://github.com/elastic/elasticsearch/pull/64318#discussion_r514377397", "createdAt": "2020-10-29T16:02:31Z", "author": {"login": "nik9000"}, "path": "docs/reference/aggregations.asciidoc", "diffHunk": "@@ -3,117 +3,367 @@\n \n [partintro]\n --\n-The aggregations framework helps provide aggregated data based on a search query. It is based on simple building blocks\n-called aggregations, that can be composed in order to build complex summaries of the data.\n+An aggregation summarizes your data as metrics, statistics, or other analytics.\n+Aggregations help you answer questions like:\n \n-An aggregation can be seen as a _unit-of-work_ that builds analytic information over a set of documents. The context of\n-the execution defines what this document set is (e.g. a top-level aggregation executes within the context of the executed\n-query/filters of the search request).\n+* What's the average load time for my website?\n+* Who are my most valuable customers based on transaction volume?\n+* What would be considered a large file on my network?\n+* How many products are in each product category?\n \n-There are many different types of aggregations, each with its own purpose and output. To better understand these types,\n-it is often easier to break them into four main families:\n+{es} organizes aggregations into four categories:\n \n-<<search-aggregations-bucket, _Bucketing_>>::\n-\t\t\t\tA family of aggregations that build buckets, where each bucket is associated with a _key_ and a document\n-\t\t\t\tcriterion. When the aggregation is executed, all the buckets criteria are evaluated on every document in\n-\t\t\t\tthe context and when a criterion matches, the document is considered to \"fall in\" the relevant bucket.\n-\t\t\t\tBy the end of the aggregation process, we'll end up with a list of buckets - each one with a set of\n-\t\t\t\tdocuments that \"belong\" to it.\n+* <<search-aggregations-bucket,Bucket>> aggregations that\n+group documents into buckets, also called bins, based on field values, ranges,\n+or other criteria.\n \n-<<search-aggregations-metrics, _Metric_>>::\n-\t\t\t\tAggregations that keep track and compute metrics over a set of documents.\n+* <<search-aggregations-matrix,Matrix>> aggregations experimental:[] that output\n+a matrix based on multiple fields.\n \n-<<search-aggregations-matrix, _Matrix_>>::\n-                A family of aggregations that operate on multiple fields and produce a matrix result based on the\n-                values extracted from the requested document fields. Unlike metric and bucket aggregations, this\n-                aggregation family does not yet support scripting.\n+* <<search-aggregations-metrics,Metric>> aggregations that calculate metrics,\n+such as a sum or average, from field values.\n \n-<<search-aggregations-pipeline, _Pipeline_>>::\n-\t\t\t\tAggregations that aggregate the output of other aggregations and their associated metrics\n+* <<search-aggregations-pipeline,Pipeline>> aggregations that take input from\n+other aggregations instead of documents or fields.\n \n-The interesting part comes next. Since each bucket effectively defines a document set (all documents belonging to\n-the bucket), one can potentially associate aggregations on the bucket level, and those will execute within the context\n-of that bucket. This is where the real power of aggregations kicks in: *aggregations can be nested!*\n+[discrete]\n+[[run-an-agg]]\n+=== Run an aggregation\n+\n+{es} runs aggregations as part of a <<search-your-data,search>>. To run an\n+aggregation, use the <<search-search,search API>>'s `aggs` parameter. The\n+following search runs `my-agg-name`, a\n+<<search-aggregations-bucket-terms-aggregation,terms aggregation>> on\n+`my-field`:\n+\n+[source,console]\n+----\n+GET /my-index-000001/_search\n+{\n+  \"aggs\": {\n+    \"my-agg-name\": {\n+      \"terms\": {\n+        \"field\": \"my-field\"\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[setup:my_index]\n+// TEST[s/my-field/http.request.method/]\n+\n+[discrete]\n+[[change-agg-scope]]\n+=== Change an aggregation's scope\n+\n+Use the `query` parameter to limit the documents on which an aggregation runs:\n+\n+[source,console]\n+----\n+GET /my-index-000001/_search\n+{\n+  \"query\": {\n+    \"range\": {\n+      \"@timestamp\": {\n+        \"gte\": \"now-1d/d\",\n+        \"lt\": \"now/d\"\n+      }\n+    }\n+  },\n+  \"aggs\": {\n+    \"my-agg-name\": {\n+      \"terms\": {\n+        \"field\": \"my-field\"\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[setup:my_index]\n+// TEST[s/my-field/http.request.method/]\n \n-NOTE:\tBucketing aggregations can have sub-aggregations (bucketing or metric). The sub-aggregations will be computed for\n-\t\tthe buckets which their parent aggregation generates. There is no hard limit on the level/depth of nested\n-\t\taggregations (one can nest an aggregation under a \"parent\" aggregation, which is itself a sub-aggregation of\n-\t\tanother higher-level aggregation).\n+[discrete]\n+[[return-only-agg-results]]\n+=== Return only aggregation results\n \n-NOTE:   Aggregations operate on the `double` representation of\n-        the data. As a consequence, the result may be approximate when running on longs\n-        whose absolute value is greater than `2^53`.\n+By default, searches containing an aggregation return both search hits and\n+aggregation results. To return only aggregation results, set `size` to `0`:\n+\n+[source,console]\n+----\n+GET /my-index-000001/_search\n+{\n+  \"size\": 0,\n+  \"aggs\": {\n+    \"my-agg-name\": {\n+      \"terms\": {\n+        \"field\": \"my-field\"\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[setup:my_index]\n+// TEST[s/my-field/http.request.method/]\n \n [discrete]\n-== Structuring Aggregations\n+[[run-multiple-aggs]]\n+=== Run multiple aggregations\n \n-The following snippet captures the basic structure of aggregations:\n+You can specify multiple aggregations in the same request:\n \n-[source,js]\n---------------------------------------------------\n-\"aggregations\" : {\n-    \"<aggregation_name>\" : {\n-        \"<aggregation_type>\" : {\n-            <aggregation_body>\n+[source,console]\n+----\n+GET /my-index-000001/_search\n+{\n+  \"aggs\": {\n+    \"my-first-agg-name\": {\n+      \"terms\": {\n+        \"field\": \"my-field\"\n+      }\n+    },\n+    \"my-second-agg-name\": {\n+      \"avg\": {\n+        \"field\": \"my-other-field\"\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[setup:my_index]\n+// TEST[s/my-field/http.request.method/]\n+// TEST[s/my-other-field/http.response.bytes/]\n+\n+[discrete]\n+[[run-sub-aggs]]\n+=== Run sub-aggregations\n+\n+Bucket aggregations support bucket or metric sub-aggregations. For example, a\n+terms aggregation with an <<search-aggregations-metrics-avg-aggregation,avg>>\n+sub-aggregation calculates an average value for each bucket of documents. There\n+is no level or depth limit for nesting sub-aggregations.\n+\n+[source,console]\n+----\n+GET /my-index-000001/_search\n+{\n+  \"aggs\": {\n+    \"my-agg-name\": {\n+      \"terms\": {\n+        \"field\": \"my-field\"\n+      },\n+      \"aggs\": {\n+        \"my-sub-agg-name\": {\n+          \"avg\": {\n+            \"field\": \"my-other-field\"\n+          }\n         }\n-        [,\"meta\" : {  [<meta_data_body>] } ]?\n-        [,\"aggregations\" : { [<sub_aggregation>]+ } ]?\n+      }\n     }\n-    [,\"<aggregation_name_2>\" : { ... } ]*\n+  }\n }\n---------------------------------------------------\n-// NOTCONSOLE\n-\n-The `aggregations` object (the key `aggs` can also be used) in the JSON holds the aggregations to be computed. Each aggregation\n-is associated with a logical name that the user defines (e.g. if the aggregation computes the average price, then it would\n-make sense to name it `avg_price`). These logical names will also be used to uniquely identify the aggregations in the\n-response. Each aggregation has a specific type (`<aggregation_type>` in the above snippet) and is typically the first\n-key within the named aggregation body. Each type of aggregation defines its own body, depending on the nature of the\n-aggregation (e.g. an `avg` aggregation on a specific field will define the field on which the average will be calculated).\n-At the same level of the aggregation type definition, one can optionally define a set of additional aggregations,\n-though this only makes sense if the aggregation you defined is of a bucketing nature. In this scenario, the\n-sub-aggregations you define on the bucketing aggregation level will be computed for all the buckets built by the\n-bucketing aggregation. For example, if you define a set of aggregations under the `range` aggregation, the\n-sub-aggregations will be computed for the range buckets that are defined.\n+----\n+// TEST[setup:my_index]\n+// TEST[s/my-field/http.request.method/]\n+// TEST[s/my-other-field/http.response.bytes/]\n \n [discrete]\n-=== Values Source\n-\n-Some aggregations work on values extracted from the aggregated documents. Typically, the values will be extracted from\n-a specific document field which is set using the `field` key for the aggregations. It is also possible to define a\n-<<modules-scripting,`script`>> which will generate the values (per document).\n-\n-When both `field` and `script` settings are configured for the aggregation, the script will be treated as a\n-`value script`.  While normal scripts are evaluated on a document level (i.e. the script has access to all the data\n-associated with the document), value scripts are evaluated on the *value* level. In this mode, the values are extracted\n-from the configured `field` and the `script` is used to apply a \"transformation\" over these value/s.\n-\n-[\"NOTE\",id=\"aggs-script-note\"]\n-===============================\n-When working with scripts, the `lang` and `params` settings can also be defined. The former defines the scripting\n-language which is used (assuming the proper language is available in Elasticsearch, either by default or as a plugin). The latter\n-enables defining all the \"dynamic\" expressions in the script as parameters, which enables the script to keep itself static\n-between calls (this will ensure the use of the cached compiled scripts in Elasticsearch).\n-===============================\n-\n-Elasticsearch uses the type of the field in the mapping in order to figure out\n-how to run the aggregation and format the response. However there are two cases\n-in which Elasticsearch cannot figure out this information: unmapped fields (for\n-instance in the case of a search request across multiple indices, and only some\n-of them have a mapping for the field) and pure scripts. For those cases, it is\n-possible to give Elasticsearch a hint using the `value_type` option, which\n-accepts the following values: `string`, `long` (works for all integer types),\n-`double` (works for all decimal types like `float` or `scaled_float`), `date`,\n-`ip` and `boolean`.\n+[[add-metadata-to-an-agg]]\n+=== Add custom metadata\n \n---\n+Use the `meta` object to associate custom metadata with an aggregation:\n \n-include::aggregations/metrics.asciidoc[]\n+[source,console]\n+----\n+GET /my-index-000001/_search\n+{\n+  \"aggs\": {\n+    \"my-agg-name\": {\n+      \"terms\": {\n+        \"field\": \"my-field\"\n+      },\n+      \"meta\": {\n+        \"my-metadata-field\": \"foo\"\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[setup:my_index]\n+// TEST[s/_search/_search?size=0/]\n \n-include::aggregations/bucket.asciidoc[]\n+The response returns the `meta` object in place:\n \n-include::aggregations/pipeline.asciidoc[]\n+[source,console-result]\n+----\n+{\n+  ...\n+  \"aggregations\": {\n+    \"my-agg-name\": {\n+      \"meta\": {\n+        \"my-metadata-field\": \"foo\"\n+      },\n+      \"doc_count_error_upper_bound\": 0,\n+      \"sum_other_doc_count\": 0,\n+      \"buckets\": []\n+    }\n+  }\n+}\n+----\n+// TESTRESPONSE[s/\\.\\.\\./\"took\": \"$body.took\", \"timed_out\": false, \"_shards\": \"$body._shards\", \"hits\": \"$body.hits\",/]\n+\n+[discrete]\n+[[return-agg-type]]\n+=== Return the aggregation type\n+\n+By default, aggregation results include the aggregation's name but not its type.\n+To return the aggregation type, use the `typed_keys` query parameter.\n+\n+[source,console]\n+----\n+GET /my-index-000001/_search?typed_keys\n+{\n+  \"aggs\": {\n+    \"my-agg-name\": {\n+      \"histogram\": {\n+        \"field\": \"my-field\",\n+        \"interval\": 1000\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[setup:my_index]\n+// TEST[s/typed_keys/typed_keys&size=0/]\n+// TEST[s/my-field/http.response.bytes/]\n+\n+The response returns the aggregation type as a prefix to the aggregation's name.\n+\n+IMPORTANT: Some aggregations return a different aggregation type from the\n+type in the request. For example, the terms,\n+<<search-aggregations-bucket-significantterms-aggregation,significant terms>>,\n+and <<search-aggregations-metrics-percentile-aggregation,percentiles>>\n+aggregations return different aggregations types depending on the data type of\n+the aggregated field.\n+\n+[source,console-result]\n+----\n+{\n+  ...\n+  \"aggregations\": {\n+    \"histogram#my-agg-name\": {                 <1>\n+      \"buckets\": []\n+    }\n+  }\n+}\n+----\n+// TESTRESPONSE[s/\\.\\.\\./\"took\": \"$body.took\", \"timed_out\": false, \"_shards\": \"$body._shards\", \"hits\": \"$body.hits\",/]\n+// TESTRESPONSE[s/\"buckets\": \\[\\]/\"buckets\":\\[\\{\"key\":1070000.0,\"doc_count\":5\\}\\]/]\n+\n+<1> The aggregation type, `histogram`, followed by a `#` separator and the aggregation's name, `my-agg-name`.\n+\n+[discrete]\n+[[use-scripts-in-an-agg]]\n+=== Use scripts in an aggregation\n+\n+Some aggregations support <<modules-scripting,scripts>>. You can\n+use a `script` to extract or generate values for the aggregation:\n+\n+[source,console]\n+----\n+GET /my-index-000001/_search\n+{\n+  \"aggs\": {\n+    \"my-agg-name\": {\n+      \"histogram\": {\n+        \"interval\": 1000,\n+        \"script\": {\n+          \"source\": \"doc['my-field'].value.length()\"\n+        }\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[setup:my_index]\n+// TEST[s/my-field/http.request.method/]\n+\n+If you also specify a `field`, the `script` modifies the field values used in\n+the aggregation. The following aggregation uses a script to modify `my-field`\n+values:\n+\n+[source,console]\n+----\n+GET /my-index-000001/_search\n+{\n+  \"aggs\": {\n+    \"my-agg-name\": {\n+      \"histogram\": {\n+        \"field\": \"my-field\",\n+        \"interval\": 1000,\n+        \"script\": \"_value / 1000\"\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[setup:my_index]\n+// TEST[s/my-field/http.response.bytes/]\n+\n+Some aggregations only work on specific data types. Use the `value_type`\n+parameter to specify a data type for a script-generated value or an unmapped\n+field. `value_type` accepts the following values:\n+\n+* `boolean`\n+* `date`\n+* `double`, used for all floating-point numbers\n+* `long`, used for all integers\n+* `ip`\n+* `string`\n+\n+[source,console]\n+----\n+GET /my-index-000001/_search\n+{\n+  \"aggs\": {\n+    \"my-agg-name\": {\n+      \"histogram\": {\n+        \"field\": \"my-field\",\n+        \"interval\": 1000,\n+        \"script\": \"_value / 1000\",\n+        \"value_type\": \"long\"\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[setup:my_index]\n+// TEST[s/my-field/http.response.bytes/]\n+\n+[discrete]\n+[[agg-caches]]\n+=== Aggregation caches\n+\n+For faster responses, {es} caches the results of frequently run aggregations in\n+the <<shard-request-cache,shard request cache>>. To get cached results, use the\n+same <<shard-and-node-preference,`preference` string>> for each search. {es}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dac07bf80ba7f16a1e275d85502c17586b7a4c44"}, "originalPosition": 435}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ4MjA2OA==", "bodyText": "I updated this recommending setting size to 0 if you don't need search results.", "url": "https://github.com/elastic/elasticsearch/pull/64318#discussion_r514482068", "createdAt": "2020-10-29T18:35:30Z", "author": {"login": "jrodewig"}, "path": "docs/reference/aggregations.asciidoc", "diffHunk": "@@ -3,117 +3,367 @@\n \n [partintro]\n --\n-The aggregations framework helps provide aggregated data based on a search query. It is based on simple building blocks\n-called aggregations, that can be composed in order to build complex summaries of the data.\n+An aggregation summarizes your data as metrics, statistics, or other analytics.\n+Aggregations help you answer questions like:\n \n-An aggregation can be seen as a _unit-of-work_ that builds analytic information over a set of documents. The context of\n-the execution defines what this document set is (e.g. a top-level aggregation executes within the context of the executed\n-query/filters of the search request).\n+* What's the average load time for my website?\n+* Who are my most valuable customers based on transaction volume?\n+* What would be considered a large file on my network?\n+* How many products are in each product category?\n \n-There are many different types of aggregations, each with its own purpose and output. To better understand these types,\n-it is often easier to break them into four main families:\n+{es} organizes aggregations into four categories:\n \n-<<search-aggregations-bucket, _Bucketing_>>::\n-\t\t\t\tA family of aggregations that build buckets, where each bucket is associated with a _key_ and a document\n-\t\t\t\tcriterion. When the aggregation is executed, all the buckets criteria are evaluated on every document in\n-\t\t\t\tthe context and when a criterion matches, the document is considered to \"fall in\" the relevant bucket.\n-\t\t\t\tBy the end of the aggregation process, we'll end up with a list of buckets - each one with a set of\n-\t\t\t\tdocuments that \"belong\" to it.\n+* <<search-aggregations-bucket,Bucket>> aggregations that\n+group documents into buckets, also called bins, based on field values, ranges,\n+or other criteria.\n \n-<<search-aggregations-metrics, _Metric_>>::\n-\t\t\t\tAggregations that keep track and compute metrics over a set of documents.\n+* <<search-aggregations-matrix,Matrix>> aggregations experimental:[] that output\n+a matrix based on multiple fields.\n \n-<<search-aggregations-matrix, _Matrix_>>::\n-                A family of aggregations that operate on multiple fields and produce a matrix result based on the\n-                values extracted from the requested document fields. Unlike metric and bucket aggregations, this\n-                aggregation family does not yet support scripting.\n+* <<search-aggregations-metrics,Metric>> aggregations that calculate metrics,\n+such as a sum or average, from field values.\n \n-<<search-aggregations-pipeline, _Pipeline_>>::\n-\t\t\t\tAggregations that aggregate the output of other aggregations and their associated metrics\n+* <<search-aggregations-pipeline,Pipeline>> aggregations that take input from\n+other aggregations instead of documents or fields.\n \n-The interesting part comes next. Since each bucket effectively defines a document set (all documents belonging to\n-the bucket), one can potentially associate aggregations on the bucket level, and those will execute within the context\n-of that bucket. This is where the real power of aggregations kicks in: *aggregations can be nested!*\n+[discrete]\n+[[run-an-agg]]\n+=== Run an aggregation\n+\n+{es} runs aggregations as part of a <<search-your-data,search>>. To run an\n+aggregation, use the <<search-search,search API>>'s `aggs` parameter. The\n+following search runs `my-agg-name`, a\n+<<search-aggregations-bucket-terms-aggregation,terms aggregation>> on\n+`my-field`:\n+\n+[source,console]\n+----\n+GET /my-index-000001/_search\n+{\n+  \"aggs\": {\n+    \"my-agg-name\": {\n+      \"terms\": {\n+        \"field\": \"my-field\"\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[setup:my_index]\n+// TEST[s/my-field/http.request.method/]\n+\n+[discrete]\n+[[change-agg-scope]]\n+=== Change an aggregation's scope\n+\n+Use the `query` parameter to limit the documents on which an aggregation runs:\n+\n+[source,console]\n+----\n+GET /my-index-000001/_search\n+{\n+  \"query\": {\n+    \"range\": {\n+      \"@timestamp\": {\n+        \"gte\": \"now-1d/d\",\n+        \"lt\": \"now/d\"\n+      }\n+    }\n+  },\n+  \"aggs\": {\n+    \"my-agg-name\": {\n+      \"terms\": {\n+        \"field\": \"my-field\"\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[setup:my_index]\n+// TEST[s/my-field/http.request.method/]\n \n-NOTE:\tBucketing aggregations can have sub-aggregations (bucketing or metric). The sub-aggregations will be computed for\n-\t\tthe buckets which their parent aggregation generates. There is no hard limit on the level/depth of nested\n-\t\taggregations (one can nest an aggregation under a \"parent\" aggregation, which is itself a sub-aggregation of\n-\t\tanother higher-level aggregation).\n+[discrete]\n+[[return-only-agg-results]]\n+=== Return only aggregation results\n \n-NOTE:   Aggregations operate on the `double` representation of\n-        the data. As a consequence, the result may be approximate when running on longs\n-        whose absolute value is greater than `2^53`.\n+By default, searches containing an aggregation return both search hits and\n+aggregation results. To return only aggregation results, set `size` to `0`:\n+\n+[source,console]\n+----\n+GET /my-index-000001/_search\n+{\n+  \"size\": 0,\n+  \"aggs\": {\n+    \"my-agg-name\": {\n+      \"terms\": {\n+        \"field\": \"my-field\"\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[setup:my_index]\n+// TEST[s/my-field/http.request.method/]\n \n [discrete]\n-== Structuring Aggregations\n+[[run-multiple-aggs]]\n+=== Run multiple aggregations\n \n-The following snippet captures the basic structure of aggregations:\n+You can specify multiple aggregations in the same request:\n \n-[source,js]\n---------------------------------------------------\n-\"aggregations\" : {\n-    \"<aggregation_name>\" : {\n-        \"<aggregation_type>\" : {\n-            <aggregation_body>\n+[source,console]\n+----\n+GET /my-index-000001/_search\n+{\n+  \"aggs\": {\n+    \"my-first-agg-name\": {\n+      \"terms\": {\n+        \"field\": \"my-field\"\n+      }\n+    },\n+    \"my-second-agg-name\": {\n+      \"avg\": {\n+        \"field\": \"my-other-field\"\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[setup:my_index]\n+// TEST[s/my-field/http.request.method/]\n+// TEST[s/my-other-field/http.response.bytes/]\n+\n+[discrete]\n+[[run-sub-aggs]]\n+=== Run sub-aggregations\n+\n+Bucket aggregations support bucket or metric sub-aggregations. For example, a\n+terms aggregation with an <<search-aggregations-metrics-avg-aggregation,avg>>\n+sub-aggregation calculates an average value for each bucket of documents. There\n+is no level or depth limit for nesting sub-aggregations.\n+\n+[source,console]\n+----\n+GET /my-index-000001/_search\n+{\n+  \"aggs\": {\n+    \"my-agg-name\": {\n+      \"terms\": {\n+        \"field\": \"my-field\"\n+      },\n+      \"aggs\": {\n+        \"my-sub-agg-name\": {\n+          \"avg\": {\n+            \"field\": \"my-other-field\"\n+          }\n         }\n-        [,\"meta\" : {  [<meta_data_body>] } ]?\n-        [,\"aggregations\" : { [<sub_aggregation>]+ } ]?\n+      }\n     }\n-    [,\"<aggregation_name_2>\" : { ... } ]*\n+  }\n }\n---------------------------------------------------\n-// NOTCONSOLE\n-\n-The `aggregations` object (the key `aggs` can also be used) in the JSON holds the aggregations to be computed. Each aggregation\n-is associated with a logical name that the user defines (e.g. if the aggregation computes the average price, then it would\n-make sense to name it `avg_price`). These logical names will also be used to uniquely identify the aggregations in the\n-response. Each aggregation has a specific type (`<aggregation_type>` in the above snippet) and is typically the first\n-key within the named aggregation body. Each type of aggregation defines its own body, depending on the nature of the\n-aggregation (e.g. an `avg` aggregation on a specific field will define the field on which the average will be calculated).\n-At the same level of the aggregation type definition, one can optionally define a set of additional aggregations,\n-though this only makes sense if the aggregation you defined is of a bucketing nature. In this scenario, the\n-sub-aggregations you define on the bucketing aggregation level will be computed for all the buckets built by the\n-bucketing aggregation. For example, if you define a set of aggregations under the `range` aggregation, the\n-sub-aggregations will be computed for the range buckets that are defined.\n+----\n+// TEST[setup:my_index]\n+// TEST[s/my-field/http.request.method/]\n+// TEST[s/my-other-field/http.response.bytes/]\n \n [discrete]\n-=== Values Source\n-\n-Some aggregations work on values extracted from the aggregated documents. Typically, the values will be extracted from\n-a specific document field which is set using the `field` key for the aggregations. It is also possible to define a\n-<<modules-scripting,`script`>> which will generate the values (per document).\n-\n-When both `field` and `script` settings are configured for the aggregation, the script will be treated as a\n-`value script`.  While normal scripts are evaluated on a document level (i.e. the script has access to all the data\n-associated with the document), value scripts are evaluated on the *value* level. In this mode, the values are extracted\n-from the configured `field` and the `script` is used to apply a \"transformation\" over these value/s.\n-\n-[\"NOTE\",id=\"aggs-script-note\"]\n-===============================\n-When working with scripts, the `lang` and `params` settings can also be defined. The former defines the scripting\n-language which is used (assuming the proper language is available in Elasticsearch, either by default or as a plugin). The latter\n-enables defining all the \"dynamic\" expressions in the script as parameters, which enables the script to keep itself static\n-between calls (this will ensure the use of the cached compiled scripts in Elasticsearch).\n-===============================\n-\n-Elasticsearch uses the type of the field in the mapping in order to figure out\n-how to run the aggregation and format the response. However there are two cases\n-in which Elasticsearch cannot figure out this information: unmapped fields (for\n-instance in the case of a search request across multiple indices, and only some\n-of them have a mapping for the field) and pure scripts. For those cases, it is\n-possible to give Elasticsearch a hint using the `value_type` option, which\n-accepts the following values: `string`, `long` (works for all integer types),\n-`double` (works for all decimal types like `float` or `scaled_float`), `date`,\n-`ip` and `boolean`.\n+[[add-metadata-to-an-agg]]\n+=== Add custom metadata\n \n---\n+Use the `meta` object to associate custom metadata with an aggregation:\n \n-include::aggregations/metrics.asciidoc[]\n+[source,console]\n+----\n+GET /my-index-000001/_search\n+{\n+  \"aggs\": {\n+    \"my-agg-name\": {\n+      \"terms\": {\n+        \"field\": \"my-field\"\n+      },\n+      \"meta\": {\n+        \"my-metadata-field\": \"foo\"\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[setup:my_index]\n+// TEST[s/_search/_search?size=0/]\n \n-include::aggregations/bucket.asciidoc[]\n+The response returns the `meta` object in place:\n \n-include::aggregations/pipeline.asciidoc[]\n+[source,console-result]\n+----\n+{\n+  ...\n+  \"aggregations\": {\n+    \"my-agg-name\": {\n+      \"meta\": {\n+        \"my-metadata-field\": \"foo\"\n+      },\n+      \"doc_count_error_upper_bound\": 0,\n+      \"sum_other_doc_count\": 0,\n+      \"buckets\": []\n+    }\n+  }\n+}\n+----\n+// TESTRESPONSE[s/\\.\\.\\./\"took\": \"$body.took\", \"timed_out\": false, \"_shards\": \"$body._shards\", \"hits\": \"$body.hits\",/]\n+\n+[discrete]\n+[[return-agg-type]]\n+=== Return the aggregation type\n+\n+By default, aggregation results include the aggregation's name but not its type.\n+To return the aggregation type, use the `typed_keys` query parameter.\n+\n+[source,console]\n+----\n+GET /my-index-000001/_search?typed_keys\n+{\n+  \"aggs\": {\n+    \"my-agg-name\": {\n+      \"histogram\": {\n+        \"field\": \"my-field\",\n+        \"interval\": 1000\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[setup:my_index]\n+// TEST[s/typed_keys/typed_keys&size=0/]\n+// TEST[s/my-field/http.response.bytes/]\n+\n+The response returns the aggregation type as a prefix to the aggregation's name.\n+\n+IMPORTANT: Some aggregations return a different aggregation type from the\n+type in the request. For example, the terms,\n+<<search-aggregations-bucket-significantterms-aggregation,significant terms>>,\n+and <<search-aggregations-metrics-percentile-aggregation,percentiles>>\n+aggregations return different aggregations types depending on the data type of\n+the aggregated field.\n+\n+[source,console-result]\n+----\n+{\n+  ...\n+  \"aggregations\": {\n+    \"histogram#my-agg-name\": {                 <1>\n+      \"buckets\": []\n+    }\n+  }\n+}\n+----\n+// TESTRESPONSE[s/\\.\\.\\./\"took\": \"$body.took\", \"timed_out\": false, \"_shards\": \"$body._shards\", \"hits\": \"$body.hits\",/]\n+// TESTRESPONSE[s/\"buckets\": \\[\\]/\"buckets\":\\[\\{\"key\":1070000.0,\"doc_count\":5\\}\\]/]\n+\n+<1> The aggregation type, `histogram`, followed by a `#` separator and the aggregation's name, `my-agg-name`.\n+\n+[discrete]\n+[[use-scripts-in-an-agg]]\n+=== Use scripts in an aggregation\n+\n+Some aggregations support <<modules-scripting,scripts>>. You can\n+use a `script` to extract or generate values for the aggregation:\n+\n+[source,console]\n+----\n+GET /my-index-000001/_search\n+{\n+  \"aggs\": {\n+    \"my-agg-name\": {\n+      \"histogram\": {\n+        \"interval\": 1000,\n+        \"script\": {\n+          \"source\": \"doc['my-field'].value.length()\"\n+        }\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[setup:my_index]\n+// TEST[s/my-field/http.request.method/]\n+\n+If you also specify a `field`, the `script` modifies the field values used in\n+the aggregation. The following aggregation uses a script to modify `my-field`\n+values:\n+\n+[source,console]\n+----\n+GET /my-index-000001/_search\n+{\n+  \"aggs\": {\n+    \"my-agg-name\": {\n+      \"histogram\": {\n+        \"field\": \"my-field\",\n+        \"interval\": 1000,\n+        \"script\": \"_value / 1000\"\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[setup:my_index]\n+// TEST[s/my-field/http.response.bytes/]\n+\n+Some aggregations only work on specific data types. Use the `value_type`\n+parameter to specify a data type for a script-generated value or an unmapped\n+field. `value_type` accepts the following values:\n+\n+* `boolean`\n+* `date`\n+* `double`, used for all floating-point numbers\n+* `long`, used for all integers\n+* `ip`\n+* `string`\n+\n+[source,console]\n+----\n+GET /my-index-000001/_search\n+{\n+  \"aggs\": {\n+    \"my-agg-name\": {\n+      \"histogram\": {\n+        \"field\": \"my-field\",\n+        \"interval\": 1000,\n+        \"script\": \"_value / 1000\",\n+        \"value_type\": \"long\"\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[setup:my_index]\n+// TEST[s/my-field/http.response.bytes/]\n+\n+[discrete]\n+[[agg-caches]]\n+=== Aggregation caches\n+\n+For faster responses, {es} caches the results of frequently run aggregations in\n+the <<shard-request-cache,shard request cache>>. To get cached results, use the\n+same <<shard-and-node-preference,`preference` string>> for each search. {es}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDM3NzM5Nw=="}, "originalCommit": {"oid": "dac07bf80ba7f16a1e275d85502c17586b7a4c44"}, "originalPosition": 435}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyMjk5ODY0OnYy", "diffSide": "RIGHT", "path": "docs/reference/aggregations.asciidoc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxNjowMjo1NlrOHqjH5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxODozNjozMFrOHqph7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDM3NzcwMw==", "bodyText": "some results are approximate anyway by their very nature. Like cardinality. But I don't have a good way to say that.", "url": "https://github.com/elastic/elasticsearch/pull/64318#discussion_r514377703", "createdAt": "2020-10-29T16:02:56Z", "author": {"login": "nik9000"}, "path": "docs/reference/aggregations.asciidoc", "diffHunk": "@@ -3,117 +3,367 @@\n \n [partintro]\n --\n-The aggregations framework helps provide aggregated data based on a search query. It is based on simple building blocks\n-called aggregations, that can be composed in order to build complex summaries of the data.\n+An aggregation summarizes your data as metrics, statistics, or other analytics.\n+Aggregations help you answer questions like:\n \n-An aggregation can be seen as a _unit-of-work_ that builds analytic information over a set of documents. The context of\n-the execution defines what this document set is (e.g. a top-level aggregation executes within the context of the executed\n-query/filters of the search request).\n+* What's the average load time for my website?\n+* Who are my most valuable customers based on transaction volume?\n+* What would be considered a large file on my network?\n+* How many products are in each product category?\n \n-There are many different types of aggregations, each with its own purpose and output. To better understand these types,\n-it is often easier to break them into four main families:\n+{es} organizes aggregations into four categories:\n \n-<<search-aggregations-bucket, _Bucketing_>>::\n-\t\t\t\tA family of aggregations that build buckets, where each bucket is associated with a _key_ and a document\n-\t\t\t\tcriterion. When the aggregation is executed, all the buckets criteria are evaluated on every document in\n-\t\t\t\tthe context and when a criterion matches, the document is considered to \"fall in\" the relevant bucket.\n-\t\t\t\tBy the end of the aggregation process, we'll end up with a list of buckets - each one with a set of\n-\t\t\t\tdocuments that \"belong\" to it.\n+* <<search-aggregations-bucket,Bucket>> aggregations that\n+group documents into buckets, also called bins, based on field values, ranges,\n+or other criteria.\n \n-<<search-aggregations-metrics, _Metric_>>::\n-\t\t\t\tAggregations that keep track and compute metrics over a set of documents.\n+* <<search-aggregations-matrix,Matrix>> aggregations experimental:[] that output\n+a matrix based on multiple fields.\n \n-<<search-aggregations-matrix, _Matrix_>>::\n-                A family of aggregations that operate on multiple fields and produce a matrix result based on the\n-                values extracted from the requested document fields. Unlike metric and bucket aggregations, this\n-                aggregation family does not yet support scripting.\n+* <<search-aggregations-metrics,Metric>> aggregations that calculate metrics,\n+such as a sum or average, from field values.\n \n-<<search-aggregations-pipeline, _Pipeline_>>::\n-\t\t\t\tAggregations that aggregate the output of other aggregations and their associated metrics\n+* <<search-aggregations-pipeline,Pipeline>> aggregations that take input from\n+other aggregations instead of documents or fields.\n \n-The interesting part comes next. Since each bucket effectively defines a document set (all documents belonging to\n-the bucket), one can potentially associate aggregations on the bucket level, and those will execute within the context\n-of that bucket. This is where the real power of aggregations kicks in: *aggregations can be nested!*\n+[discrete]\n+[[run-an-agg]]\n+=== Run an aggregation\n+\n+{es} runs aggregations as part of a <<search-your-data,search>>. To run an\n+aggregation, use the <<search-search,search API>>'s `aggs` parameter. The\n+following search runs `my-agg-name`, a\n+<<search-aggregations-bucket-terms-aggregation,terms aggregation>> on\n+`my-field`:\n+\n+[source,console]\n+----\n+GET /my-index-000001/_search\n+{\n+  \"aggs\": {\n+    \"my-agg-name\": {\n+      \"terms\": {\n+        \"field\": \"my-field\"\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[setup:my_index]\n+// TEST[s/my-field/http.request.method/]\n+\n+[discrete]\n+[[change-agg-scope]]\n+=== Change an aggregation's scope\n+\n+Use the `query` parameter to limit the documents on which an aggregation runs:\n+\n+[source,console]\n+----\n+GET /my-index-000001/_search\n+{\n+  \"query\": {\n+    \"range\": {\n+      \"@timestamp\": {\n+        \"gte\": \"now-1d/d\",\n+        \"lt\": \"now/d\"\n+      }\n+    }\n+  },\n+  \"aggs\": {\n+    \"my-agg-name\": {\n+      \"terms\": {\n+        \"field\": \"my-field\"\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[setup:my_index]\n+// TEST[s/my-field/http.request.method/]\n \n-NOTE:\tBucketing aggregations can have sub-aggregations (bucketing or metric). The sub-aggregations will be computed for\n-\t\tthe buckets which their parent aggregation generates. There is no hard limit on the level/depth of nested\n-\t\taggregations (one can nest an aggregation under a \"parent\" aggregation, which is itself a sub-aggregation of\n-\t\tanother higher-level aggregation).\n+[discrete]\n+[[return-only-agg-results]]\n+=== Return only aggregation results\n \n-NOTE:   Aggregations operate on the `double` representation of\n-        the data. As a consequence, the result may be approximate when running on longs\n-        whose absolute value is greater than `2^53`.\n+By default, searches containing an aggregation return both search hits and\n+aggregation results. To return only aggregation results, set `size` to `0`:\n+\n+[source,console]\n+----\n+GET /my-index-000001/_search\n+{\n+  \"size\": 0,\n+  \"aggs\": {\n+    \"my-agg-name\": {\n+      \"terms\": {\n+        \"field\": \"my-field\"\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[setup:my_index]\n+// TEST[s/my-field/http.request.method/]\n \n [discrete]\n-== Structuring Aggregations\n+[[run-multiple-aggs]]\n+=== Run multiple aggregations\n \n-The following snippet captures the basic structure of aggregations:\n+You can specify multiple aggregations in the same request:\n \n-[source,js]\n---------------------------------------------------\n-\"aggregations\" : {\n-    \"<aggregation_name>\" : {\n-        \"<aggregation_type>\" : {\n-            <aggregation_body>\n+[source,console]\n+----\n+GET /my-index-000001/_search\n+{\n+  \"aggs\": {\n+    \"my-first-agg-name\": {\n+      \"terms\": {\n+        \"field\": \"my-field\"\n+      }\n+    },\n+    \"my-second-agg-name\": {\n+      \"avg\": {\n+        \"field\": \"my-other-field\"\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[setup:my_index]\n+// TEST[s/my-field/http.request.method/]\n+// TEST[s/my-other-field/http.response.bytes/]\n+\n+[discrete]\n+[[run-sub-aggs]]\n+=== Run sub-aggregations\n+\n+Bucket aggregations support bucket or metric sub-aggregations. For example, a\n+terms aggregation with an <<search-aggregations-metrics-avg-aggregation,avg>>\n+sub-aggregation calculates an average value for each bucket of documents. There\n+is no level or depth limit for nesting sub-aggregations.\n+\n+[source,console]\n+----\n+GET /my-index-000001/_search\n+{\n+  \"aggs\": {\n+    \"my-agg-name\": {\n+      \"terms\": {\n+        \"field\": \"my-field\"\n+      },\n+      \"aggs\": {\n+        \"my-sub-agg-name\": {\n+          \"avg\": {\n+            \"field\": \"my-other-field\"\n+          }\n         }\n-        [,\"meta\" : {  [<meta_data_body>] } ]?\n-        [,\"aggregations\" : { [<sub_aggregation>]+ } ]?\n+      }\n     }\n-    [,\"<aggregation_name_2>\" : { ... } ]*\n+  }\n }\n---------------------------------------------------\n-// NOTCONSOLE\n-\n-The `aggregations` object (the key `aggs` can also be used) in the JSON holds the aggregations to be computed. Each aggregation\n-is associated with a logical name that the user defines (e.g. if the aggregation computes the average price, then it would\n-make sense to name it `avg_price`). These logical names will also be used to uniquely identify the aggregations in the\n-response. Each aggregation has a specific type (`<aggregation_type>` in the above snippet) and is typically the first\n-key within the named aggregation body. Each type of aggregation defines its own body, depending on the nature of the\n-aggregation (e.g. an `avg` aggregation on a specific field will define the field on which the average will be calculated).\n-At the same level of the aggregation type definition, one can optionally define a set of additional aggregations,\n-though this only makes sense if the aggregation you defined is of a bucketing nature. In this scenario, the\n-sub-aggregations you define on the bucketing aggregation level will be computed for all the buckets built by the\n-bucketing aggregation. For example, if you define a set of aggregations under the `range` aggregation, the\n-sub-aggregations will be computed for the range buckets that are defined.\n+----\n+// TEST[setup:my_index]\n+// TEST[s/my-field/http.request.method/]\n+// TEST[s/my-other-field/http.response.bytes/]\n \n [discrete]\n-=== Values Source\n-\n-Some aggregations work on values extracted from the aggregated documents. Typically, the values will be extracted from\n-a specific document field which is set using the `field` key for the aggregations. It is also possible to define a\n-<<modules-scripting,`script`>> which will generate the values (per document).\n-\n-When both `field` and `script` settings are configured for the aggregation, the script will be treated as a\n-`value script`.  While normal scripts are evaluated on a document level (i.e. the script has access to all the data\n-associated with the document), value scripts are evaluated on the *value* level. In this mode, the values are extracted\n-from the configured `field` and the `script` is used to apply a \"transformation\" over these value/s.\n-\n-[\"NOTE\",id=\"aggs-script-note\"]\n-===============================\n-When working with scripts, the `lang` and `params` settings can also be defined. The former defines the scripting\n-language which is used (assuming the proper language is available in Elasticsearch, either by default or as a plugin). The latter\n-enables defining all the \"dynamic\" expressions in the script as parameters, which enables the script to keep itself static\n-between calls (this will ensure the use of the cached compiled scripts in Elasticsearch).\n-===============================\n-\n-Elasticsearch uses the type of the field in the mapping in order to figure out\n-how to run the aggregation and format the response. However there are two cases\n-in which Elasticsearch cannot figure out this information: unmapped fields (for\n-instance in the case of a search request across multiple indices, and only some\n-of them have a mapping for the field) and pure scripts. For those cases, it is\n-possible to give Elasticsearch a hint using the `value_type` option, which\n-accepts the following values: `string`, `long` (works for all integer types),\n-`double` (works for all decimal types like `float` or `scaled_float`), `date`,\n-`ip` and `boolean`.\n+[[add-metadata-to-an-agg]]\n+=== Add custom metadata\n \n---\n+Use the `meta` object to associate custom metadata with an aggregation:\n \n-include::aggregations/metrics.asciidoc[]\n+[source,console]\n+----\n+GET /my-index-000001/_search\n+{\n+  \"aggs\": {\n+    \"my-agg-name\": {\n+      \"terms\": {\n+        \"field\": \"my-field\"\n+      },\n+      \"meta\": {\n+        \"my-metadata-field\": \"foo\"\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[setup:my_index]\n+// TEST[s/_search/_search?size=0/]\n \n-include::aggregations/bucket.asciidoc[]\n+The response returns the `meta` object in place:\n \n-include::aggregations/pipeline.asciidoc[]\n+[source,console-result]\n+----\n+{\n+  ...\n+  \"aggregations\": {\n+    \"my-agg-name\": {\n+      \"meta\": {\n+        \"my-metadata-field\": \"foo\"\n+      },\n+      \"doc_count_error_upper_bound\": 0,\n+      \"sum_other_doc_count\": 0,\n+      \"buckets\": []\n+    }\n+  }\n+}\n+----\n+// TESTRESPONSE[s/\\.\\.\\./\"took\": \"$body.took\", \"timed_out\": false, \"_shards\": \"$body._shards\", \"hits\": \"$body.hits\",/]\n+\n+[discrete]\n+[[return-agg-type]]\n+=== Return the aggregation type\n+\n+By default, aggregation results include the aggregation's name but not its type.\n+To return the aggregation type, use the `typed_keys` query parameter.\n+\n+[source,console]\n+----\n+GET /my-index-000001/_search?typed_keys\n+{\n+  \"aggs\": {\n+    \"my-agg-name\": {\n+      \"histogram\": {\n+        \"field\": \"my-field\",\n+        \"interval\": 1000\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[setup:my_index]\n+// TEST[s/typed_keys/typed_keys&size=0/]\n+// TEST[s/my-field/http.response.bytes/]\n+\n+The response returns the aggregation type as a prefix to the aggregation's name.\n+\n+IMPORTANT: Some aggregations return a different aggregation type from the\n+type in the request. For example, the terms,\n+<<search-aggregations-bucket-significantterms-aggregation,significant terms>>,\n+and <<search-aggregations-metrics-percentile-aggregation,percentiles>>\n+aggregations return different aggregations types depending on the data type of\n+the aggregated field.\n+\n+[source,console-result]\n+----\n+{\n+  ...\n+  \"aggregations\": {\n+    \"histogram#my-agg-name\": {                 <1>\n+      \"buckets\": []\n+    }\n+  }\n+}\n+----\n+// TESTRESPONSE[s/\\.\\.\\./\"took\": \"$body.took\", \"timed_out\": false, \"_shards\": \"$body._shards\", \"hits\": \"$body.hits\",/]\n+// TESTRESPONSE[s/\"buckets\": \\[\\]/\"buckets\":\\[\\{\"key\":1070000.0,\"doc_count\":5\\}\\]/]\n+\n+<1> The aggregation type, `histogram`, followed by a `#` separator and the aggregation's name, `my-agg-name`.\n+\n+[discrete]\n+[[use-scripts-in-an-agg]]\n+=== Use scripts in an aggregation\n+\n+Some aggregations support <<modules-scripting,scripts>>. You can\n+use a `script` to extract or generate values for the aggregation:\n+\n+[source,console]\n+----\n+GET /my-index-000001/_search\n+{\n+  \"aggs\": {\n+    \"my-agg-name\": {\n+      \"histogram\": {\n+        \"interval\": 1000,\n+        \"script\": {\n+          \"source\": \"doc['my-field'].value.length()\"\n+        }\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[setup:my_index]\n+// TEST[s/my-field/http.request.method/]\n+\n+If you also specify a `field`, the `script` modifies the field values used in\n+the aggregation. The following aggregation uses a script to modify `my-field`\n+values:\n+\n+[source,console]\n+----\n+GET /my-index-000001/_search\n+{\n+  \"aggs\": {\n+    \"my-agg-name\": {\n+      \"histogram\": {\n+        \"field\": \"my-field\",\n+        \"interval\": 1000,\n+        \"script\": \"_value / 1000\"\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[setup:my_index]\n+// TEST[s/my-field/http.response.bytes/]\n+\n+Some aggregations only work on specific data types. Use the `value_type`\n+parameter to specify a data type for a script-generated value or an unmapped\n+field. `value_type` accepts the following values:\n+\n+* `boolean`\n+* `date`\n+* `double`, used for all floating-point numbers\n+* `long`, used for all integers\n+* `ip`\n+* `string`\n+\n+[source,console]\n+----\n+GET /my-index-000001/_search\n+{\n+  \"aggs\": {\n+    \"my-agg-name\": {\n+      \"histogram\": {\n+        \"field\": \"my-field\",\n+        \"interval\": 1000,\n+        \"script\": \"_value / 1000\",\n+        \"value_type\": \"long\"\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[setup:my_index]\n+// TEST[s/my-field/http.response.bytes/]\n+\n+[discrete]\n+[[agg-caches]]\n+=== Aggregation caches\n+\n+For faster responses, {es} caches the results of frequently run aggregations in\n+the <<shard-request-cache,shard request cache>>. To get cached results, use the\n+same <<shard-and-node-preference,`preference` string>> for each search. {es}\n+routes searches with the same preference string to the same shards. If the\n+shards' data doesn\u2019t change between searches, the shards return cached\n+aggregation results.\n+\n+[discrete]\n+[[limits-for-long-values]]\n+=== Limits for `long` values\n+\n+When running aggregations, {es} uses <<number,`double`>> values to hold and\n+represent numeric data. As a result, aggregations on <<number,`long`>> numbers\n+greater than +2^53^+ are approximate.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dac07bf80ba7f16a1e275d85502c17586b7a4c44"}, "originalPosition": 446}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ4MjY3MQ==", "bodyText": "some results are approximate anyway by their very nature\n\nThat feels more relevant for the docs of an individual agg. This seems more like a limitation that could apply to any agg dealing with numeric data.", "url": "https://github.com/elastic/elasticsearch/pull/64318#discussion_r514482671", "createdAt": "2020-10-29T18:36:30Z", "author": {"login": "jrodewig"}, "path": "docs/reference/aggregations.asciidoc", "diffHunk": "@@ -3,117 +3,367 @@\n \n [partintro]\n --\n-The aggregations framework helps provide aggregated data based on a search query. It is based on simple building blocks\n-called aggregations, that can be composed in order to build complex summaries of the data.\n+An aggregation summarizes your data as metrics, statistics, or other analytics.\n+Aggregations help you answer questions like:\n \n-An aggregation can be seen as a _unit-of-work_ that builds analytic information over a set of documents. The context of\n-the execution defines what this document set is (e.g. a top-level aggregation executes within the context of the executed\n-query/filters of the search request).\n+* What's the average load time for my website?\n+* Who are my most valuable customers based on transaction volume?\n+* What would be considered a large file on my network?\n+* How many products are in each product category?\n \n-There are many different types of aggregations, each with its own purpose and output. To better understand these types,\n-it is often easier to break them into four main families:\n+{es} organizes aggregations into four categories:\n \n-<<search-aggregations-bucket, _Bucketing_>>::\n-\t\t\t\tA family of aggregations that build buckets, where each bucket is associated with a _key_ and a document\n-\t\t\t\tcriterion. When the aggregation is executed, all the buckets criteria are evaluated on every document in\n-\t\t\t\tthe context and when a criterion matches, the document is considered to \"fall in\" the relevant bucket.\n-\t\t\t\tBy the end of the aggregation process, we'll end up with a list of buckets - each one with a set of\n-\t\t\t\tdocuments that \"belong\" to it.\n+* <<search-aggregations-bucket,Bucket>> aggregations that\n+group documents into buckets, also called bins, based on field values, ranges,\n+or other criteria.\n \n-<<search-aggregations-metrics, _Metric_>>::\n-\t\t\t\tAggregations that keep track and compute metrics over a set of documents.\n+* <<search-aggregations-matrix,Matrix>> aggregations experimental:[] that output\n+a matrix based on multiple fields.\n \n-<<search-aggregations-matrix, _Matrix_>>::\n-                A family of aggregations that operate on multiple fields and produce a matrix result based on the\n-                values extracted from the requested document fields. Unlike metric and bucket aggregations, this\n-                aggregation family does not yet support scripting.\n+* <<search-aggregations-metrics,Metric>> aggregations that calculate metrics,\n+such as a sum or average, from field values.\n \n-<<search-aggregations-pipeline, _Pipeline_>>::\n-\t\t\t\tAggregations that aggregate the output of other aggregations and their associated metrics\n+* <<search-aggregations-pipeline,Pipeline>> aggregations that take input from\n+other aggregations instead of documents or fields.\n \n-The interesting part comes next. Since each bucket effectively defines a document set (all documents belonging to\n-the bucket), one can potentially associate aggregations on the bucket level, and those will execute within the context\n-of that bucket. This is where the real power of aggregations kicks in: *aggregations can be nested!*\n+[discrete]\n+[[run-an-agg]]\n+=== Run an aggregation\n+\n+{es} runs aggregations as part of a <<search-your-data,search>>. To run an\n+aggregation, use the <<search-search,search API>>'s `aggs` parameter. The\n+following search runs `my-agg-name`, a\n+<<search-aggregations-bucket-terms-aggregation,terms aggregation>> on\n+`my-field`:\n+\n+[source,console]\n+----\n+GET /my-index-000001/_search\n+{\n+  \"aggs\": {\n+    \"my-agg-name\": {\n+      \"terms\": {\n+        \"field\": \"my-field\"\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[setup:my_index]\n+// TEST[s/my-field/http.request.method/]\n+\n+[discrete]\n+[[change-agg-scope]]\n+=== Change an aggregation's scope\n+\n+Use the `query` parameter to limit the documents on which an aggregation runs:\n+\n+[source,console]\n+----\n+GET /my-index-000001/_search\n+{\n+  \"query\": {\n+    \"range\": {\n+      \"@timestamp\": {\n+        \"gte\": \"now-1d/d\",\n+        \"lt\": \"now/d\"\n+      }\n+    }\n+  },\n+  \"aggs\": {\n+    \"my-agg-name\": {\n+      \"terms\": {\n+        \"field\": \"my-field\"\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[setup:my_index]\n+// TEST[s/my-field/http.request.method/]\n \n-NOTE:\tBucketing aggregations can have sub-aggregations (bucketing or metric). The sub-aggregations will be computed for\n-\t\tthe buckets which their parent aggregation generates. There is no hard limit on the level/depth of nested\n-\t\taggregations (one can nest an aggregation under a \"parent\" aggregation, which is itself a sub-aggregation of\n-\t\tanother higher-level aggregation).\n+[discrete]\n+[[return-only-agg-results]]\n+=== Return only aggregation results\n \n-NOTE:   Aggregations operate on the `double` representation of\n-        the data. As a consequence, the result may be approximate when running on longs\n-        whose absolute value is greater than `2^53`.\n+By default, searches containing an aggregation return both search hits and\n+aggregation results. To return only aggregation results, set `size` to `0`:\n+\n+[source,console]\n+----\n+GET /my-index-000001/_search\n+{\n+  \"size\": 0,\n+  \"aggs\": {\n+    \"my-agg-name\": {\n+      \"terms\": {\n+        \"field\": \"my-field\"\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[setup:my_index]\n+// TEST[s/my-field/http.request.method/]\n \n [discrete]\n-== Structuring Aggregations\n+[[run-multiple-aggs]]\n+=== Run multiple aggregations\n \n-The following snippet captures the basic structure of aggregations:\n+You can specify multiple aggregations in the same request:\n \n-[source,js]\n---------------------------------------------------\n-\"aggregations\" : {\n-    \"<aggregation_name>\" : {\n-        \"<aggregation_type>\" : {\n-            <aggregation_body>\n+[source,console]\n+----\n+GET /my-index-000001/_search\n+{\n+  \"aggs\": {\n+    \"my-first-agg-name\": {\n+      \"terms\": {\n+        \"field\": \"my-field\"\n+      }\n+    },\n+    \"my-second-agg-name\": {\n+      \"avg\": {\n+        \"field\": \"my-other-field\"\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[setup:my_index]\n+// TEST[s/my-field/http.request.method/]\n+// TEST[s/my-other-field/http.response.bytes/]\n+\n+[discrete]\n+[[run-sub-aggs]]\n+=== Run sub-aggregations\n+\n+Bucket aggregations support bucket or metric sub-aggregations. For example, a\n+terms aggregation with an <<search-aggregations-metrics-avg-aggregation,avg>>\n+sub-aggregation calculates an average value for each bucket of documents. There\n+is no level or depth limit for nesting sub-aggregations.\n+\n+[source,console]\n+----\n+GET /my-index-000001/_search\n+{\n+  \"aggs\": {\n+    \"my-agg-name\": {\n+      \"terms\": {\n+        \"field\": \"my-field\"\n+      },\n+      \"aggs\": {\n+        \"my-sub-agg-name\": {\n+          \"avg\": {\n+            \"field\": \"my-other-field\"\n+          }\n         }\n-        [,\"meta\" : {  [<meta_data_body>] } ]?\n-        [,\"aggregations\" : { [<sub_aggregation>]+ } ]?\n+      }\n     }\n-    [,\"<aggregation_name_2>\" : { ... } ]*\n+  }\n }\n---------------------------------------------------\n-// NOTCONSOLE\n-\n-The `aggregations` object (the key `aggs` can also be used) in the JSON holds the aggregations to be computed. Each aggregation\n-is associated with a logical name that the user defines (e.g. if the aggregation computes the average price, then it would\n-make sense to name it `avg_price`). These logical names will also be used to uniquely identify the aggregations in the\n-response. Each aggregation has a specific type (`<aggregation_type>` in the above snippet) and is typically the first\n-key within the named aggregation body. Each type of aggregation defines its own body, depending on the nature of the\n-aggregation (e.g. an `avg` aggregation on a specific field will define the field on which the average will be calculated).\n-At the same level of the aggregation type definition, one can optionally define a set of additional aggregations,\n-though this only makes sense if the aggregation you defined is of a bucketing nature. In this scenario, the\n-sub-aggregations you define on the bucketing aggregation level will be computed for all the buckets built by the\n-bucketing aggregation. For example, if you define a set of aggregations under the `range` aggregation, the\n-sub-aggregations will be computed for the range buckets that are defined.\n+----\n+// TEST[setup:my_index]\n+// TEST[s/my-field/http.request.method/]\n+// TEST[s/my-other-field/http.response.bytes/]\n \n [discrete]\n-=== Values Source\n-\n-Some aggregations work on values extracted from the aggregated documents. Typically, the values will be extracted from\n-a specific document field which is set using the `field` key for the aggregations. It is also possible to define a\n-<<modules-scripting,`script`>> which will generate the values (per document).\n-\n-When both `field` and `script` settings are configured for the aggregation, the script will be treated as a\n-`value script`.  While normal scripts are evaluated on a document level (i.e. the script has access to all the data\n-associated with the document), value scripts are evaluated on the *value* level. In this mode, the values are extracted\n-from the configured `field` and the `script` is used to apply a \"transformation\" over these value/s.\n-\n-[\"NOTE\",id=\"aggs-script-note\"]\n-===============================\n-When working with scripts, the `lang` and `params` settings can also be defined. The former defines the scripting\n-language which is used (assuming the proper language is available in Elasticsearch, either by default or as a plugin). The latter\n-enables defining all the \"dynamic\" expressions in the script as parameters, which enables the script to keep itself static\n-between calls (this will ensure the use of the cached compiled scripts in Elasticsearch).\n-===============================\n-\n-Elasticsearch uses the type of the field in the mapping in order to figure out\n-how to run the aggregation and format the response. However there are two cases\n-in which Elasticsearch cannot figure out this information: unmapped fields (for\n-instance in the case of a search request across multiple indices, and only some\n-of them have a mapping for the field) and pure scripts. For those cases, it is\n-possible to give Elasticsearch a hint using the `value_type` option, which\n-accepts the following values: `string`, `long` (works for all integer types),\n-`double` (works for all decimal types like `float` or `scaled_float`), `date`,\n-`ip` and `boolean`.\n+[[add-metadata-to-an-agg]]\n+=== Add custom metadata\n \n---\n+Use the `meta` object to associate custom metadata with an aggregation:\n \n-include::aggregations/metrics.asciidoc[]\n+[source,console]\n+----\n+GET /my-index-000001/_search\n+{\n+  \"aggs\": {\n+    \"my-agg-name\": {\n+      \"terms\": {\n+        \"field\": \"my-field\"\n+      },\n+      \"meta\": {\n+        \"my-metadata-field\": \"foo\"\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[setup:my_index]\n+// TEST[s/_search/_search?size=0/]\n \n-include::aggregations/bucket.asciidoc[]\n+The response returns the `meta` object in place:\n \n-include::aggregations/pipeline.asciidoc[]\n+[source,console-result]\n+----\n+{\n+  ...\n+  \"aggregations\": {\n+    \"my-agg-name\": {\n+      \"meta\": {\n+        \"my-metadata-field\": \"foo\"\n+      },\n+      \"doc_count_error_upper_bound\": 0,\n+      \"sum_other_doc_count\": 0,\n+      \"buckets\": []\n+    }\n+  }\n+}\n+----\n+// TESTRESPONSE[s/\\.\\.\\./\"took\": \"$body.took\", \"timed_out\": false, \"_shards\": \"$body._shards\", \"hits\": \"$body.hits\",/]\n+\n+[discrete]\n+[[return-agg-type]]\n+=== Return the aggregation type\n+\n+By default, aggregation results include the aggregation's name but not its type.\n+To return the aggregation type, use the `typed_keys` query parameter.\n+\n+[source,console]\n+----\n+GET /my-index-000001/_search?typed_keys\n+{\n+  \"aggs\": {\n+    \"my-agg-name\": {\n+      \"histogram\": {\n+        \"field\": \"my-field\",\n+        \"interval\": 1000\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[setup:my_index]\n+// TEST[s/typed_keys/typed_keys&size=0/]\n+// TEST[s/my-field/http.response.bytes/]\n+\n+The response returns the aggregation type as a prefix to the aggregation's name.\n+\n+IMPORTANT: Some aggregations return a different aggregation type from the\n+type in the request. For example, the terms,\n+<<search-aggregations-bucket-significantterms-aggregation,significant terms>>,\n+and <<search-aggregations-metrics-percentile-aggregation,percentiles>>\n+aggregations return different aggregations types depending on the data type of\n+the aggregated field.\n+\n+[source,console-result]\n+----\n+{\n+  ...\n+  \"aggregations\": {\n+    \"histogram#my-agg-name\": {                 <1>\n+      \"buckets\": []\n+    }\n+  }\n+}\n+----\n+// TESTRESPONSE[s/\\.\\.\\./\"took\": \"$body.took\", \"timed_out\": false, \"_shards\": \"$body._shards\", \"hits\": \"$body.hits\",/]\n+// TESTRESPONSE[s/\"buckets\": \\[\\]/\"buckets\":\\[\\{\"key\":1070000.0,\"doc_count\":5\\}\\]/]\n+\n+<1> The aggregation type, `histogram`, followed by a `#` separator and the aggregation's name, `my-agg-name`.\n+\n+[discrete]\n+[[use-scripts-in-an-agg]]\n+=== Use scripts in an aggregation\n+\n+Some aggregations support <<modules-scripting,scripts>>. You can\n+use a `script` to extract or generate values for the aggregation:\n+\n+[source,console]\n+----\n+GET /my-index-000001/_search\n+{\n+  \"aggs\": {\n+    \"my-agg-name\": {\n+      \"histogram\": {\n+        \"interval\": 1000,\n+        \"script\": {\n+          \"source\": \"doc['my-field'].value.length()\"\n+        }\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[setup:my_index]\n+// TEST[s/my-field/http.request.method/]\n+\n+If you also specify a `field`, the `script` modifies the field values used in\n+the aggregation. The following aggregation uses a script to modify `my-field`\n+values:\n+\n+[source,console]\n+----\n+GET /my-index-000001/_search\n+{\n+  \"aggs\": {\n+    \"my-agg-name\": {\n+      \"histogram\": {\n+        \"field\": \"my-field\",\n+        \"interval\": 1000,\n+        \"script\": \"_value / 1000\"\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[setup:my_index]\n+// TEST[s/my-field/http.response.bytes/]\n+\n+Some aggregations only work on specific data types. Use the `value_type`\n+parameter to specify a data type for a script-generated value or an unmapped\n+field. `value_type` accepts the following values:\n+\n+* `boolean`\n+* `date`\n+* `double`, used for all floating-point numbers\n+* `long`, used for all integers\n+* `ip`\n+* `string`\n+\n+[source,console]\n+----\n+GET /my-index-000001/_search\n+{\n+  \"aggs\": {\n+    \"my-agg-name\": {\n+      \"histogram\": {\n+        \"field\": \"my-field\",\n+        \"interval\": 1000,\n+        \"script\": \"_value / 1000\",\n+        \"value_type\": \"long\"\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[setup:my_index]\n+// TEST[s/my-field/http.response.bytes/]\n+\n+[discrete]\n+[[agg-caches]]\n+=== Aggregation caches\n+\n+For faster responses, {es} caches the results of frequently run aggregations in\n+the <<shard-request-cache,shard request cache>>. To get cached results, use the\n+same <<shard-and-node-preference,`preference` string>> for each search. {es}\n+routes searches with the same preference string to the same shards. If the\n+shards' data doesn\u2019t change between searches, the shards return cached\n+aggregation results.\n+\n+[discrete]\n+[[limits-for-long-values]]\n+=== Limits for `long` values\n+\n+When running aggregations, {es} uses <<number,`double`>> values to hold and\n+represent numeric data. As a result, aggregations on <<number,`long`>> numbers\n+greater than +2^53^+ are approximate.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDM3NzcwMw=="}, "originalCommit": {"oid": "dac07bf80ba7f16a1e275d85502c17586b7a4c44"}, "originalPosition": 446}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNDY1NTI1OnYy", "diffSide": "RIGHT", "path": "docs/reference/aggregations/matrix/stats-aggregation.asciidoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwMDoxNDo0OVrOHqzAhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwMDoxNDo0OVrOHqzAhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYzNzk1OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            === Matrix Stats Aggregation\n          \n          \n            \n            === Matrix stats aggregation", "url": "https://github.com/elastic/elasticsearch/pull/64318#discussion_r514637958", "createdAt": "2020-10-30T00:14:49Z", "author": {"login": "debadair"}, "path": "docs/reference/aggregations/matrix/stats-aggregation.asciidoc", "diffHunk": "@@ -1,5 +1,5 @@\n [[search-aggregations-matrix-stats-aggregation]]\n-=== Matrix Stats\n+=== Matrix Stats Aggregation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "350860cbcad148c61750627c6c22972c070372fb"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNDY1NjUwOnYy", "diffSide": "RIGHT", "path": "docs/reference/redirects.asciidoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwMDoxNTozMVrOHqzBPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwMDoxNTozMVrOHqzBPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYzODE0Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            === Aggregation Metadata\n          \n          \n            \n            === Aggregation metadata", "url": "https://github.com/elastic/elasticsearch/pull/64318#discussion_r514638143", "createdAt": "2020-10-30T00:15:31Z", "author": {"login": "debadair"}, "path": "docs/reference/redirects.asciidoc", "diffHunk": "@@ -1231,3 +1231,33 @@ See <<elasticsearch-croneval-parameters>>.\n \n The autoscaling decision API has been renamed to capacity,\n see <<autoscaling-get-autoscaling-capacity>>.\n+\n+[role=\"exclude\",id=\"caching-heavy-aggregations\"]\n+=== Caching heavy aggregations\n+\n+See <<agg-caches>>.\n+\n+[role=\"exclude\",id=\"returning-only-agg-results\"]\n+=== Returning only aggregation results\n+\n+See <<return-only-agg-results>>.\n+\n+[role=\"exclude\",id=\"agg-metadata\"]\n+=== Aggregation Metadata", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "350860cbcad148c61750627c6c22972c070372fb"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNDY2MzY3OnYy", "diffSide": "RIGHT", "path": "docs/reference/aggregations.asciidoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwMDoxOTo0MFrOHqzFhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwMDoxOTo0MFrOHqzFhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYzOTIzNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            {es} runs aggregations as part of a <<search-your-data,search>>. To run an\n          \n          \n            \n            aggregation, use the <<search-search,search API>>'s `aggs` parameter. The\n          \n          \n            \n            You can run aggregations as part of a <<search-your-data,search>> by specifying the <<search-search,search API>>'s `aggs` parameter. The", "url": "https://github.com/elastic/elasticsearch/pull/64318#discussion_r514639237", "createdAt": "2020-10-30T00:19:40Z", "author": {"login": "debadair"}, "path": "docs/reference/aggregations.asciidoc", "diffHunk": "@@ -3,117 +3,433 @@\n \n [partintro]\n --\n-The aggregations framework helps provide aggregated data based on a search query. It is based on simple building blocks\n-called aggregations, that can be composed in order to build complex summaries of the data.\n+An aggregation summarizes your data as metrics, statistics, or other analytics.\n+Aggregations help you answer questions like:\n \n-An aggregation can be seen as a _unit-of-work_ that builds analytic information over a set of documents. The context of\n-the execution defines what this document set is (e.g. a top-level aggregation executes within the context of the executed\n-query/filters of the search request).\n+* What's the average load time for my website?\n+* Who are my most valuable customers based on transaction volume?\n+* What would be considered a large file on my network?\n+* How many products are in each product category?\n \n-There are many different types of aggregations, each with its own purpose and output. To better understand these types,\n-it is often easier to break them into four main families:\n+{es} organizes aggregations into three categories:\n \n-<<search-aggregations-bucket, _Bucketing_>>::\n-\t\t\t\tA family of aggregations that build buckets, where each bucket is associated with a _key_ and a document\n-\t\t\t\tcriterion. When the aggregation is executed, all the buckets criteria are evaluated on every document in\n-\t\t\t\tthe context and when a criterion matches, the document is considered to \"fall in\" the relevant bucket.\n-\t\t\t\tBy the end of the aggregation process, we'll end up with a list of buckets - each one with a set of\n-\t\t\t\tdocuments that \"belong\" to it.\n+* <<search-aggregations-metrics,Metric>> aggregations that calculate metrics,\n+such as a sum or average, from field values.\n \n-<<search-aggregations-metrics, _Metric_>>::\n-\t\t\t\tAggregations that keep track and compute metrics over a set of documents.\n+* <<search-aggregations-bucket,Bucket>> aggregations that\n+group documents into buckets, also called bins, based on field values, ranges,\n+or other criteria.\n \n-<<search-aggregations-matrix, _Matrix_>>::\n-                A family of aggregations that operate on multiple fields and produce a matrix result based on the\n-                values extracted from the requested document fields. Unlike metric and bucket aggregations, this\n-                aggregation family does not yet support scripting.\n+* <<search-aggregations-pipeline,Pipeline>> aggregations that take input from\n+other aggregations instead of documents or fields.\n \n-<<search-aggregations-pipeline, _Pipeline_>>::\n-\t\t\t\tAggregations that aggregate the output of other aggregations and their associated metrics\n+[discrete]\n+[[run-an-agg]]\n+=== Run an aggregation\n+\n+{es} runs aggregations as part of a <<search-your-data,search>>. To run an\n+aggregation, use the <<search-search,search API>>'s `aggs` parameter. The", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "350860cbcad148c61750627c6c22972c070372fb"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNDY2NzY3OnYy", "diffSide": "RIGHT", "path": "docs/reference/aggregations.asciidoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwMDoyMTo1MFrOHqzH1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwMDoyMTo1MFrOHqzH1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYzOTgzMQ==", "bodyText": "The agg name is pretty self-explanatory--I don't think it needs to be called out.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            following search runs `my-agg-name`, a\n          \n          \n            \n            <<search-aggregations-bucket-terms-aggregation,terms aggregation>> on\n          \n          \n            \n            `my-field`:\n          \n          \n            \n            following search runs  a\n          \n          \n            \n            <<search-aggregations-bucket-terms-aggregation,terms aggregation>> on\n          \n          \n            \n            `my-field`:", "url": "https://github.com/elastic/elasticsearch/pull/64318#discussion_r514639831", "createdAt": "2020-10-30T00:21:50Z", "author": {"login": "debadair"}, "path": "docs/reference/aggregations.asciidoc", "diffHunk": "@@ -3,117 +3,433 @@\n \n [partintro]\n --\n-The aggregations framework helps provide aggregated data based on a search query. It is based on simple building blocks\n-called aggregations, that can be composed in order to build complex summaries of the data.\n+An aggregation summarizes your data as metrics, statistics, or other analytics.\n+Aggregations help you answer questions like:\n \n-An aggregation can be seen as a _unit-of-work_ that builds analytic information over a set of documents. The context of\n-the execution defines what this document set is (e.g. a top-level aggregation executes within the context of the executed\n-query/filters of the search request).\n+* What's the average load time for my website?\n+* Who are my most valuable customers based on transaction volume?\n+* What would be considered a large file on my network?\n+* How many products are in each product category?\n \n-There are many different types of aggregations, each with its own purpose and output. To better understand these types,\n-it is often easier to break them into four main families:\n+{es} organizes aggregations into three categories:\n \n-<<search-aggregations-bucket, _Bucketing_>>::\n-\t\t\t\tA family of aggregations that build buckets, where each bucket is associated with a _key_ and a document\n-\t\t\t\tcriterion. When the aggregation is executed, all the buckets criteria are evaluated on every document in\n-\t\t\t\tthe context and when a criterion matches, the document is considered to \"fall in\" the relevant bucket.\n-\t\t\t\tBy the end of the aggregation process, we'll end up with a list of buckets - each one with a set of\n-\t\t\t\tdocuments that \"belong\" to it.\n+* <<search-aggregations-metrics,Metric>> aggregations that calculate metrics,\n+such as a sum or average, from field values.\n \n-<<search-aggregations-metrics, _Metric_>>::\n-\t\t\t\tAggregations that keep track and compute metrics over a set of documents.\n+* <<search-aggregations-bucket,Bucket>> aggregations that\n+group documents into buckets, also called bins, based on field values, ranges,\n+or other criteria.\n \n-<<search-aggregations-matrix, _Matrix_>>::\n-                A family of aggregations that operate on multiple fields and produce a matrix result based on the\n-                values extracted from the requested document fields. Unlike metric and bucket aggregations, this\n-                aggregation family does not yet support scripting.\n+* <<search-aggregations-pipeline,Pipeline>> aggregations that take input from\n+other aggregations instead of documents or fields.\n \n-<<search-aggregations-pipeline, _Pipeline_>>::\n-\t\t\t\tAggregations that aggregate the output of other aggregations and their associated metrics\n+[discrete]\n+[[run-an-agg]]\n+=== Run an aggregation\n+\n+{es} runs aggregations as part of a <<search-your-data,search>>. To run an\n+aggregation, use the <<search-search,search API>>'s `aggs` parameter. The\n+following search runs `my-agg-name`, a\n+<<search-aggregations-bucket-terms-aggregation,terms aggregation>> on\n+`my-field`:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "350860cbcad148c61750627c6c22972c070372fb"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNDY3MjUyOnYy", "diffSide": "RIGHT", "path": "docs/reference/aggregations.asciidoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwMDoyNDo1OFrOHqzKxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwMDoyNDo1OFrOHqzKxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0MDU4Mg==", "bodyText": "Property or object?", "url": "https://github.com/elastic/elasticsearch/pull/64318#discussion_r514640582", "createdAt": "2020-10-30T00:24:58Z", "author": {"login": "debadair"}, "path": "docs/reference/aggregations.asciidoc", "diffHunk": "@@ -3,117 +3,433 @@\n \n [partintro]\n --\n-The aggregations framework helps provide aggregated data based on a search query. It is based on simple building blocks\n-called aggregations, that can be composed in order to build complex summaries of the data.\n+An aggregation summarizes your data as metrics, statistics, or other analytics.\n+Aggregations help you answer questions like:\n \n-An aggregation can be seen as a _unit-of-work_ that builds analytic information over a set of documents. The context of\n-the execution defines what this document set is (e.g. a top-level aggregation executes within the context of the executed\n-query/filters of the search request).\n+* What's the average load time for my website?\n+* Who are my most valuable customers based on transaction volume?\n+* What would be considered a large file on my network?\n+* How many products are in each product category?\n \n-There are many different types of aggregations, each with its own purpose and output. To better understand these types,\n-it is often easier to break them into four main families:\n+{es} organizes aggregations into three categories:\n \n-<<search-aggregations-bucket, _Bucketing_>>::\n-\t\t\t\tA family of aggregations that build buckets, where each bucket is associated with a _key_ and a document\n-\t\t\t\tcriterion. When the aggregation is executed, all the buckets criteria are evaluated on every document in\n-\t\t\t\tthe context and when a criterion matches, the document is considered to \"fall in\" the relevant bucket.\n-\t\t\t\tBy the end of the aggregation process, we'll end up with a list of buckets - each one with a set of\n-\t\t\t\tdocuments that \"belong\" to it.\n+* <<search-aggregations-metrics,Metric>> aggregations that calculate metrics,\n+such as a sum or average, from field values.\n \n-<<search-aggregations-metrics, _Metric_>>::\n-\t\t\t\tAggregations that keep track and compute metrics over a set of documents.\n+* <<search-aggregations-bucket,Bucket>> aggregations that\n+group documents into buckets, also called bins, based on field values, ranges,\n+or other criteria.\n \n-<<search-aggregations-matrix, _Matrix_>>::\n-                A family of aggregations that operate on multiple fields and produce a matrix result based on the\n-                values extracted from the requested document fields. Unlike metric and bucket aggregations, this\n-                aggregation family does not yet support scripting.\n+* <<search-aggregations-pipeline,Pipeline>> aggregations that take input from\n+other aggregations instead of documents or fields.\n \n-<<search-aggregations-pipeline, _Pipeline_>>::\n-\t\t\t\tAggregations that aggregate the output of other aggregations and their associated metrics\n+[discrete]\n+[[run-an-agg]]\n+=== Run an aggregation\n+\n+{es} runs aggregations as part of a <<search-your-data,search>>. To run an\n+aggregation, use the <<search-search,search API>>'s `aggs` parameter. The\n+following search runs `my-agg-name`, a\n+<<search-aggregations-bucket-terms-aggregation,terms aggregation>> on\n+`my-field`:\n+\n+[source,console]\n+----\n+GET /my-index-000001/_search\n+{\n+  \"aggs\": {\n+    \"my-agg-name\": {\n+      \"terms\": {\n+        \"field\": \"my-field\"\n+      }\n+    }\n+  }\n+}\n+----\n+// TEST[setup:my_index]\n+// TEST[s/my-field/http.request.method/]\n+\n+Aggregation results are in the response's `aggregations` property:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "350860cbcad148c61750627c6c22972c070372fb"}, "originalPosition": 71}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4171, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}