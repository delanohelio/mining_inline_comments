{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQxMjcyNjI3", "number": 58650, "title": "SQL: Redact credentials in connection exceptions", "bodyText": "This PR adds the functionality to redact the credentials from the\nexceptions generated when a connection attempt fails, preventing them\nfrom leaking into logs, console history etc.\nThere are a few causes that can lead to failed connections. The most\nchallenging to deal with is a malformed connection string. The redaction\ntries to get around it by modifying the URI to a parsable state, so that\nthe redaction can be applied reliably. If there's no reliability\nguarantee, the redaction will bluntly replace the entire connection\nstring and the user informed about the option to modify it so that the\nredaction won't apply. (This is done by using a caplitalized scheme,\nwhich is legal, but otherwise never used in practice.)\nThe PR fixes a couple of other issues with the URI parser:\n\nit allows an empty hostname, or even entire connection string (as per\nthe existing documentation);\nit reduces the editing of the connection string in the exception\nmessages (so that the user easier recognize their input);\nit uses the default URI as source for the scheme and hostname.\n\nCloses #56474", "createdAt": "2020-06-29T08:09:09Z", "url": "https://github.com/elastic/elasticsearch/pull/58650", "merged": true, "mergeCommit": {"oid": "a0bd5929d0658c4fed44404e0c4d78eac88222fd"}, "closed": true, "closedAt": "2020-07-02T20:00:57Z", "author": {"login": "bpintea"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcv8SpwAH2gAyNDQxMjcyNjI3OjUyM2VlNGY0OGNhMDkwZDA4MzE1ZTkyYmZhYWU0NTg4YjFjMjMzZjE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcwuIGwAH2gAyNDQxMjcyNjI3OmNmMmFlM2E1OGI1OTA4YWRlMDRiMzJhY2IwZjkyOTI0YjI1NjZhOTg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "523ee4f48ca090d08315e92bfaae4588b1c233f1", "author": {"user": {"login": "bpintea", "name": "Bogdan Pintea"}}, "url": "https://github.com/elastic/elasticsearch/commit/523ee4f48ca090d08315e92bfaae4588b1c233f1", "committedDate": "2020-06-29T07:55:12Z", "message": "Redact credentials in connection exceptions\n\nThis commit adds the functionality to redact the credentials from the\nexceptions generated when a connection attempt fails, preventing them\nfrom leaking into logs, console history etc.\n\nThere are a few causes that can lead to failed connections. The most\nchallenging to deal with is a malformed connection string. The redaction\ntries to get around it by modifying the URI to a parsable state, so that\nthe redaction can be applied reliably. If there's no reliability\nguarantee, the redaction will bluntly replace the entire connection\nstring and the user informed about the option to modify it so that the\nredaction won't apply. (This is done by using a caplitalized scheme,\nwhich is legal, but otherwise never used in practice.)\n\nThe commit fixes a couple of other issues with the URI parser:\n- it allows an empty hostname, or even entire connection string (as per\nthe existing documentation);\n- it reduces the editing of the connection string in the exception\nmessages (so that the user easier recognize their input);\n- it uses the default URI as source for the scheme and hostname."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5MTAxNDE0", "url": "https://github.com/elastic/elasticsearch/pull/58650#pullrequestreview-439101414", "createdAt": "2020-06-29T12:41:25Z", "commit": {"oid": "523ee4f48ca090d08315e92bfaae4588b1c233f1"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5ODQ2MzU0", "url": "https://github.com/elastic/elasticsearch/pull/58650#pullrequestreview-439846354", "createdAt": "2020-06-30T09:39:45Z", "commit": {"oid": "523ee4f48ca090d08315e92bfaae4588b1c233f1"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwOTozOTo0NVrOGq0Yow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwOTozOTo0NVrOGq0Yow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU1MTY1MQ==", "bodyText": "Minor: Those 2 lines seem to have inconsistent identation compared to the rest of the file.", "url": "https://github.com/elastic/elasticsearch/pull/58650#discussion_r447551651", "createdAt": "2020-06-30T09:39:45Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/sql/sql-client/src/test/java/org/elasticsearch/xpack/sql/client/UriUtilsTests.java", "diffHunk": "@@ -59,15 +82,197 @@ public void testHttpQuery() throws Exception {\n \n     public void testUnsupportedProtocol() throws Exception {\n         assertEquals(\n-                \"Invalid connection configuration [ftp://server:9201/]: Only http and https protocols are supported\",\n+                \"Invalid connection scheme [ftp] configuration: only http and https protocols are supported\",\n                 expectThrows(IllegalArgumentException.class, () -> parseURI(\"ftp://server:9201/\", DEFAULT_URI)).getMessage()\n         );\n     }\n \n-    public void testMalformed() throws Exception {\n+    public void testMalformedWhiteSpace() throws Exception {\n         assertEquals(\n-                \"Invalid connection configuration []: Expected authority at index 7: http://\",\n-                expectThrows(IllegalArgumentException.class, () -> parseURI(\"\", DEFAULT_URI)).getMessage()\n+            \"Invalid connection configuration: Illegal character in authority at index 7: http:// \",\n+            expectThrows(IllegalArgumentException.class, () -> parseURI(\" \", DEFAULT_URI)).getMessage()\n+        );\n+    }\n+\n+    public void testNoRedaction() {\n+        assertEquals(\n+                \"Invalid connection configuration: Illegal character in fragment at index 16: HTTP://host#frag#ment\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "523ee4f48ca090d08315e92bfaae4588b1c233f1"}, "originalPosition": 62}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b600ed7ff99fcd52f82eab0284957da202329d55", "author": {"user": {"login": "bpintea", "name": "Bogdan Pintea"}}, "url": "https://github.com/elastic/elasticsearch/commit/b600ed7ff99fcd52f82eab0284957da202329d55", "committedDate": "2020-06-30T10:56:41Z", "message": "style corrections\n\nAllign code in file w.r.t.:\n- indentation size;\n- parameters placement;\n- closing paranthesis placement."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "74a53b4d55123a3fa072c6c052d941d974f85b3a", "author": {"user": {"login": "elasticmachine", "name": "Elastic Machine"}}, "url": "https://github.com/elastic/elasticsearch/commit/74a53b4d55123a3fa072c6c052d941d974f85b3a", "committedDate": "2020-06-30T13:03:59Z", "message": "Merge branch 'master' into enh/redact_credentials_in_invalid_uri"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwNjE5NjQ2", "url": "https://github.com/elastic/elasticsearch/pull/58650#pullrequestreview-440619646", "createdAt": "2020-07-01T07:38:37Z", "commit": {"oid": "74a53b4d55123a3fa072c6c052d941d974f85b3a"}, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwNzozODozN1rOGraa6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwODowNTozOFrOGrbTlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODE3NDgyNA==", "bodyText": "This url is not used anymore. Can be removed.", "url": "https://github.com/elastic/elasticsearch/pull/58650#discussion_r448174824", "createdAt": "2020-07-01T07:38:37Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/jdbc/src/main/java/org/elasticsearch/xpack/sql/jdbc/JdbcConfiguration.java", "diffHunk": "@@ -115,15 +115,15 @@ public static JdbcConfiguration create(String u, Properties props, int loginTime\n \n     private static URI parseUrl(String u) throws JdbcSQLException {\n         String url = u;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74a53b4d55123a3fa072c6c052d941d974f85b3a"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODE3NjU3NQ==", "bodyText": "I know this comment is not the focus of this PR, but if you can add the missing description, that would great.", "url": "https://github.com/elastic/elasticsearch/pull/58650#discussion_r448176575", "createdAt": "2020-07-01T07:42:00Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/sql-client/src/main/java/org/elasticsearch/xpack/sql/client/UriUtils.java", "diffHunk": "@@ -7,18 +7,32 @@\n \n import java.net.URI;\n import java.net.URISyntaxException;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n \n public final class UriUtils {\n     private UriUtils() {\n \n     }\n \n+    static final String HTTP_SCHEME = \"http\";\n+    static final String HTTPS_SCHEME = \"https\";\n+    static final String HTTP_PREFIX = HTTP_SCHEME + \"://\";\n+    static final String HTTPS_PREFIX = HTTPS_SCHEME + \"://\";\n+\n     /**\n      * Parses the URL provided by the user and", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74a53b4d55123a3fa072c6c052d941d974f85b3a"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODE4MTExNw==", "bodyText": "Do we have a good/strong argument in favor of \"deactivating\" the redaction if URLs when the schema is uppercase and activating it when it's lowercase?\nWouldn't a URL parameter do the job, similar to validate.properties? Thoughts @costin @matriv ?", "url": "https://github.com/elastic/elasticsearch/pull/58650#discussion_r448181117", "createdAt": "2020-07-01T07:50:29Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/sql-client/src/main/java/org/elasticsearch/xpack/sql/client/UriUtils.java", "diffHunk": "@@ -42,42 +56,211 @@ public static URI parseURI(String connectionString, URI defaultURI) {\n         }\n     }\n \n-    private static URI parseWithNoScheme(String connectionString) {\n+    private static URI parseMaybeWithScheme(String connectionString, String defaultPrefix) {\n         URI uri;\n-        // check if URI can be parsed correctly without adding scheme\n-        // if the connection string is in format host:port or just host, the host is going to be null\n-        // if the connection string contains IPv6 localhost [::1] the parsing will fail\n-        URISyntaxException firstException = null;\n+        String c = connectionString.toLowerCase(Locale.ROOT);\n+        boolean hasAnHttpPrefix = c.startsWith(HTTP_PREFIX) || c.startsWith(HTTPS_PREFIX);\n         try {\n             uri = new URI(connectionString);\n-            if (uri.getHost() == null || uri.getScheme() == null) {\n-                uri = null;\n-            }\n         } catch (URISyntaxException e) {\n-            firstException = e;\n-            uri = null;\n+            // If the connection string contains no scheme plus an IP address with semicolon - like an IPv6 ([::1]), or an IPv4 plus port\n+            // (127.0.0.1:9200) - the URI parser will fail, as it'll try to interpret the pre-`:` chars as a scheme.\n+            if (hasAnHttpPrefix == false) {\n+                return parseMaybeWithScheme(defaultPrefix + connectionString, null);\n+            }\n+            URISyntaxException s = CredentialsRedaction.redactedURISyntaxException(e);\n+            throw new IllegalArgumentException(\"Invalid connection configuration: \" + s.getMessage(), s);\n         }\n \n-        if (uri == null) {\n-            // We couldn't parse URI without adding scheme, let's try again with scheme this time\n-            try {\n-                return new URI(\"http://\" + connectionString);\n-            } catch (URISyntaxException e) {\n-                IllegalArgumentException ie =\n-                    new IllegalArgumentException(\"Invalid connection configuration [\" + connectionString + \"]: \" + e.getMessage(), e);\n-                if (firstException != null) {\n-                    ie.addSuppressed(firstException);\n+        if (hasAnHttpPrefix == false) {\n+            if (uri.getHost() != null) { // URI is valid and with a host, so there's a scheme (otherwise host==null), but just not HTTP(S)\n+                throw new IllegalArgumentException(\n+                    \"Invalid connection scheme [\" + uri.getScheme() + \"] configuration: only \" + HTTP_SCHEME + \" and \" + HTTPS_SCHEME\n+                        + \" protocols are supported\");\n+            }\n+            // no host and either (1) no scheme (like for input 'host') or (2) invalid scheme (produced by parsing 'user:pass@host' or\n+            // 'host:9200' or just erroneous: 'ftp:/?foo' etc.): try with a HTTP scheme\n+            if (connectionString.length() > 0) { // an empty string is a valid connection string\n+                return parseMaybeWithScheme(defaultPrefix + connectionString, null);\n+            }\n+        }\n+\n+        return uri;\n+    }\n+\n+    public static class CredentialsRedaction {\n+        public static final Character REDACTION_CHAR = '*';\n+        private static final String USER_ATTR_NAME = \"user\";\n+        private static final String PASS_ATTR_NAME = \"password\";\n+\n+        // redacts the value of a named attribute in a given string, by finding the substring `attrName=`; everything following that is\n+        // considered as attribute's value.\n+        private static String redactAttributeInString(String string, String attrName, Character replacement) {\n+            String needle = attrName + \"=\";\n+            int attrIdx = string.toLowerCase(Locale.ROOT).indexOf(needle); // note: won't catch \"valid\" `=password[%20]+=` cases\n+            if (attrIdx >= 0) { // ex: `...=[value]password=foo...`\n+                int attrEndIdx = attrIdx + needle.length();\n+                return string.substring(0, attrEndIdx) + String.valueOf(replacement).repeat(string.length() - attrEndIdx);\n+            }\n+            return string;\n+        }\n+\n+        private static void redactValueForSimilarKey(String key, List<String> options, List<Map.Entry<String, String>> attrs,\n+                                                     Character replacement) {\n+            List<String> similar = StringUtils.findSimilar(key, options);\n+            for (String k : similar) {\n+                for (Map.Entry<String, String> e : attrs) {\n+                    if (e.getKey().equals(k)) {\n+                        e.setValue(String.valueOf(replacement).repeat(e.getValue().length()));\n+                    }\n                 }\n-                throw ie;\n             }\n-        } else {\n-            // We managed to parse URI and all necessary pieces are present, let's make sure the scheme is correct\n-            if (\"http\".equals(uri.getScheme()) == false && \"https\".equals(uri.getScheme()) == false) {\n-                throw new IllegalArgumentException(\n-                        \"Invalid connection configuration [\" + connectionString + \"]: Only http and https protocols are supported\");\n+        }\n+\n+        public static String redactCredentialsInRawUriQuery(String rawQuery, Character replacement) {\n+            List<Map.Entry<String, String>> attrs = new ArrayList<>();\n+            List<String> options = new ArrayList<>();\n+\n+            // break down the query in (key, value) tuples, redacting any malformed attribute values\n+            String key, value;\n+            for (String param : StringUtils.tokenize(rawQuery, \"&\")) {\n+                int eqIdx = param.indexOf('=');\n+                if (eqIdx <= 0) { // malformed param: no, or leading `=`: record entire param string as key and empty string as value\n+                    value = eqIdx < 0 ? null : StringUtils.EMPTY;\n+                    key = redactAttributeInString(param, USER_ATTR_NAME, replacement);\n+                    key = redactAttributeInString(key, PASS_ATTR_NAME, replacement);\n+                } else {\n+                    key = param.substring(0, eqIdx);\n+                    value = param.substring(eqIdx + 1);\n+                    if (value.indexOf('=') >= 0) { // `...&user=FOOpassword=BAR&...`\n+                        value = redactAttributeInString(value, USER_ATTR_NAME, replacement);\n+                        value = redactAttributeInString(value, PASS_ATTR_NAME, replacement);\n+                    }\n+                    options.add(key);\n+                }\n+                attrs.add(new AbstractMap.SimpleEntry<>(key, value));\n             }\n-            return uri;\n+\n+            // redact the credential attributes, as well as any other attribute that is similar to them, i.e. mistyped\n+            redactValueForSimilarKey(USER_ATTR_NAME, options, attrs, replacement);\n+            redactValueForSimilarKey(PASS_ATTR_NAME, options, attrs, replacement);\n+\n+            // re-construct the query\n+            StringBuilder sb = new StringBuilder(rawQuery.length());\n+            for (Map.Entry<String, String> a : attrs) {\n+                sb.append(\"&\");\n+                sb.append(a.getKey());\n+                if (a.getValue() != null) {\n+                    sb.append(\"=\");\n+                    sb.append(a.getValue());\n+                }\n+            }\n+            return sb.substring(1);\n         }\n+\n+        private static String editURI(URI uri, List<Map.Entry<Integer, Character>> faults, boolean hasPort) {\n+            StringBuilder sb = new StringBuilder();\n+            if (uri.getScheme() != null) {\n+                sb.append(uri.getScheme());\n+                sb.append(\"://\");\n+            }\n+            if (uri.getRawUserInfo() != null) {\n+                sb.append(\"\\0\".repeat(uri.getRawUserInfo().length()));\n+                if (uri.getHost() != null) {\n+                    sb.append('@');\n+                }\n+            }\n+            if (uri.getHost() != null) {\n+                sb.append(uri.getHost());\n+            }\n+            if (hasPort || uri.getPort() > 0) {\n+                sb.append(':');\n+            }\n+            if (uri.getPort() > 0) {\n+                sb.append(uri.getPort());\n+            }\n+            if (uri.getRawPath() != null) {\n+                sb.append(uri.getRawPath());\n+            }\n+            if (uri.getQuery() != null) {\n+                sb.append('?');\n+                // redact with the null character; this will later allow safe reinsertion of any character removed from the URI to make\n+                // it parsable\n+                sb.append(redactCredentialsInRawUriQuery(uri.getRawQuery(), '\\0'));\n+            }\n+            if (uri.getRawFragment() != null) {\n+                sb.append('#');\n+                sb.append(uri.getRawFragment());\n+            }\n+\n+            // reinsert any removed character back into the URI: if the reinsertion should be made between null characters, replace its\n+            // value with a null character, since it's part of the credential value\n+            Collections.reverse(faults);\n+            for (Map.Entry<Integer, Character> e : faults) {\n+                int idx = e.getKey();\n+                if (idx >= sb.length()) {\n+                    sb.append(e.getValue());\n+                } else {\n+                    sb.insert(idx,\n+                        (sb.charAt(idx) == '\\0' && (idx + 1 >= sb.length() || sb.charAt(idx + 1) == '\\0')) ? '\\0' : e.getValue());\n+                }\n+            }\n+\n+            StringBuilder ret = new StringBuilder();\n+            sb.chars().forEach(x -> ret.append(x == '\\0' ? REDACTION_CHAR : (char) x));\n+\n+            return ret.toString();\n+        }\n+\n+        private static String redactCredentialsInURLString(String urlString) {\n+            List<Map.Entry<Integer, Character>> faults = new ArrayList<>();\n+\n+            boolean hasPort = false;\n+            for (StringBuilder sb = new StringBuilder(urlString); sb.length() > 0; ) {\n+                try {\n+                    // parse as URL; ex. `http://ho~st` parses as URI, but with unparsable authority\n+                    URI uri = new URI(sb.toString()).parseServerAuthority();\n+                    return editURI(uri, faults, hasPort);\n+                } catch (URISyntaxException use) {\n+                    int idx = use.getIndex();\n+                    if (idx < 0 || idx >= sb.length()) {\n+                        break; // not a faulty character-related error\n+                    }\n+                    if (use.getReason().equals(\"Illegal character in port number\")) {\n+                        // if entire port part is broken (ex. `localhost:noDigit`), the trailing `:` will be lost in the resulting URI\n+                        hasPort = true;\n+                    }\n+                    faults.add(new AbstractMap.SimpleImmutableEntry<>(use.getIndex(), sb.charAt(idx)));\n+                    sb.deleteCharAt(idx);\n+                }\n+            }\n+            return null;\n+        }\n+\n+        public static String redactCredentialsInConnectionString(String connectionString) {\n+            if (connectionString.startsWith(HTTP_PREFIX.toUpperCase(Locale.ROOT))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74a53b4d55123a3fa072c6c052d941d974f85b3a"}, "originalPosition": 255}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODE4OTMzNQ==", "bodyText": "When can the idx be > sb.length()? And why the equality is not a valid use case to be redacted?", "url": "https://github.com/elastic/elasticsearch/pull/58650#discussion_r448189335", "createdAt": "2020-07-01T08:05:38Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/sql/sql-client/src/main/java/org/elasticsearch/xpack/sql/client/UriUtils.java", "diffHunk": "@@ -42,42 +56,211 @@ public static URI parseURI(String connectionString, URI defaultURI) {\n         }\n     }\n \n-    private static URI parseWithNoScheme(String connectionString) {\n+    private static URI parseMaybeWithScheme(String connectionString, String defaultPrefix) {\n         URI uri;\n-        // check if URI can be parsed correctly without adding scheme\n-        // if the connection string is in format host:port or just host, the host is going to be null\n-        // if the connection string contains IPv6 localhost [::1] the parsing will fail\n-        URISyntaxException firstException = null;\n+        String c = connectionString.toLowerCase(Locale.ROOT);\n+        boolean hasAnHttpPrefix = c.startsWith(HTTP_PREFIX) || c.startsWith(HTTPS_PREFIX);\n         try {\n             uri = new URI(connectionString);\n-            if (uri.getHost() == null || uri.getScheme() == null) {\n-                uri = null;\n-            }\n         } catch (URISyntaxException e) {\n-            firstException = e;\n-            uri = null;\n+            // If the connection string contains no scheme plus an IP address with semicolon - like an IPv6 ([::1]), or an IPv4 plus port\n+            // (127.0.0.1:9200) - the URI parser will fail, as it'll try to interpret the pre-`:` chars as a scheme.\n+            if (hasAnHttpPrefix == false) {\n+                return parseMaybeWithScheme(defaultPrefix + connectionString, null);\n+            }\n+            URISyntaxException s = CredentialsRedaction.redactedURISyntaxException(e);\n+            throw new IllegalArgumentException(\"Invalid connection configuration: \" + s.getMessage(), s);\n         }\n \n-        if (uri == null) {\n-            // We couldn't parse URI without adding scheme, let's try again with scheme this time\n-            try {\n-                return new URI(\"http://\" + connectionString);\n-            } catch (URISyntaxException e) {\n-                IllegalArgumentException ie =\n-                    new IllegalArgumentException(\"Invalid connection configuration [\" + connectionString + \"]: \" + e.getMessage(), e);\n-                if (firstException != null) {\n-                    ie.addSuppressed(firstException);\n+        if (hasAnHttpPrefix == false) {\n+            if (uri.getHost() != null) { // URI is valid and with a host, so there's a scheme (otherwise host==null), but just not HTTP(S)\n+                throw new IllegalArgumentException(\n+                    \"Invalid connection scheme [\" + uri.getScheme() + \"] configuration: only \" + HTTP_SCHEME + \" and \" + HTTPS_SCHEME\n+                        + \" protocols are supported\");\n+            }\n+            // no host and either (1) no scheme (like for input 'host') or (2) invalid scheme (produced by parsing 'user:pass@host' or\n+            // 'host:9200' or just erroneous: 'ftp:/?foo' etc.): try with a HTTP scheme\n+            if (connectionString.length() > 0) { // an empty string is a valid connection string\n+                return parseMaybeWithScheme(defaultPrefix + connectionString, null);\n+            }\n+        }\n+\n+        return uri;\n+    }\n+\n+    public static class CredentialsRedaction {\n+        public static final Character REDACTION_CHAR = '*';\n+        private static final String USER_ATTR_NAME = \"user\";\n+        private static final String PASS_ATTR_NAME = \"password\";\n+\n+        // redacts the value of a named attribute in a given string, by finding the substring `attrName=`; everything following that is\n+        // considered as attribute's value.\n+        private static String redactAttributeInString(String string, String attrName, Character replacement) {\n+            String needle = attrName + \"=\";\n+            int attrIdx = string.toLowerCase(Locale.ROOT).indexOf(needle); // note: won't catch \"valid\" `=password[%20]+=` cases\n+            if (attrIdx >= 0) { // ex: `...=[value]password=foo...`\n+                int attrEndIdx = attrIdx + needle.length();\n+                return string.substring(0, attrEndIdx) + String.valueOf(replacement).repeat(string.length() - attrEndIdx);\n+            }\n+            return string;\n+        }\n+\n+        private static void redactValueForSimilarKey(String key, List<String> options, List<Map.Entry<String, String>> attrs,\n+                                                     Character replacement) {\n+            List<String> similar = StringUtils.findSimilar(key, options);\n+            for (String k : similar) {\n+                for (Map.Entry<String, String> e : attrs) {\n+                    if (e.getKey().equals(k)) {\n+                        e.setValue(String.valueOf(replacement).repeat(e.getValue().length()));\n+                    }\n                 }\n-                throw ie;\n             }\n-        } else {\n-            // We managed to parse URI and all necessary pieces are present, let's make sure the scheme is correct\n-            if (\"http\".equals(uri.getScheme()) == false && \"https\".equals(uri.getScheme()) == false) {\n-                throw new IllegalArgumentException(\n-                        \"Invalid connection configuration [\" + connectionString + \"]: Only http and https protocols are supported\");\n+        }\n+\n+        public static String redactCredentialsInRawUriQuery(String rawQuery, Character replacement) {\n+            List<Map.Entry<String, String>> attrs = new ArrayList<>();\n+            List<String> options = new ArrayList<>();\n+\n+            // break down the query in (key, value) tuples, redacting any malformed attribute values\n+            String key, value;\n+            for (String param : StringUtils.tokenize(rawQuery, \"&\")) {\n+                int eqIdx = param.indexOf('=');\n+                if (eqIdx <= 0) { // malformed param: no, or leading `=`: record entire param string as key and empty string as value\n+                    value = eqIdx < 0 ? null : StringUtils.EMPTY;\n+                    key = redactAttributeInString(param, USER_ATTR_NAME, replacement);\n+                    key = redactAttributeInString(key, PASS_ATTR_NAME, replacement);\n+                } else {\n+                    key = param.substring(0, eqIdx);\n+                    value = param.substring(eqIdx + 1);\n+                    if (value.indexOf('=') >= 0) { // `...&user=FOOpassword=BAR&...`\n+                        value = redactAttributeInString(value, USER_ATTR_NAME, replacement);\n+                        value = redactAttributeInString(value, PASS_ATTR_NAME, replacement);\n+                    }\n+                    options.add(key);\n+                }\n+                attrs.add(new AbstractMap.SimpleEntry<>(key, value));\n             }\n-            return uri;\n+\n+            // redact the credential attributes, as well as any other attribute that is similar to them, i.e. mistyped\n+            redactValueForSimilarKey(USER_ATTR_NAME, options, attrs, replacement);\n+            redactValueForSimilarKey(PASS_ATTR_NAME, options, attrs, replacement);\n+\n+            // re-construct the query\n+            StringBuilder sb = new StringBuilder(rawQuery.length());\n+            for (Map.Entry<String, String> a : attrs) {\n+                sb.append(\"&\");\n+                sb.append(a.getKey());\n+                if (a.getValue() != null) {\n+                    sb.append(\"=\");\n+                    sb.append(a.getValue());\n+                }\n+            }\n+            return sb.substring(1);\n         }\n+\n+        private static String editURI(URI uri, List<Map.Entry<Integer, Character>> faults, boolean hasPort) {\n+            StringBuilder sb = new StringBuilder();\n+            if (uri.getScheme() != null) {\n+                sb.append(uri.getScheme());\n+                sb.append(\"://\");\n+            }\n+            if (uri.getRawUserInfo() != null) {\n+                sb.append(\"\\0\".repeat(uri.getRawUserInfo().length()));\n+                if (uri.getHost() != null) {\n+                    sb.append('@');\n+                }\n+            }\n+            if (uri.getHost() != null) {\n+                sb.append(uri.getHost());\n+            }\n+            if (hasPort || uri.getPort() > 0) {\n+                sb.append(':');\n+            }\n+            if (uri.getPort() > 0) {\n+                sb.append(uri.getPort());\n+            }\n+            if (uri.getRawPath() != null) {\n+                sb.append(uri.getRawPath());\n+            }\n+            if (uri.getQuery() != null) {\n+                sb.append('?');\n+                // redact with the null character; this will later allow safe reinsertion of any character removed from the URI to make\n+                // it parsable\n+                sb.append(redactCredentialsInRawUriQuery(uri.getRawQuery(), '\\0'));\n+            }\n+            if (uri.getRawFragment() != null) {\n+                sb.append('#');\n+                sb.append(uri.getRawFragment());\n+            }\n+\n+            // reinsert any removed character back into the URI: if the reinsertion should be made between null characters, replace its\n+            // value with a null character, since it's part of the credential value\n+            Collections.reverse(faults);\n+            for (Map.Entry<Integer, Character> e : faults) {\n+                int idx = e.getKey();\n+                if (idx >= sb.length()) {\n+                    sb.append(e.getValue());\n+                } else {\n+                    sb.insert(idx,\n+                        (sb.charAt(idx) == '\\0' && (idx + 1 >= sb.length() || sb.charAt(idx + 1) == '\\0')) ? '\\0' : e.getValue());\n+                }\n+            }\n+\n+            StringBuilder ret = new StringBuilder();\n+            sb.chars().forEach(x -> ret.append(x == '\\0' ? REDACTION_CHAR : (char) x));\n+\n+            return ret.toString();\n+        }\n+\n+        private static String redactCredentialsInURLString(String urlString) {\n+            List<Map.Entry<Integer, Character>> faults = new ArrayList<>();\n+\n+            boolean hasPort = false;\n+            for (StringBuilder sb = new StringBuilder(urlString); sb.length() > 0; ) {\n+                try {\n+                    // parse as URL; ex. `http://ho~st` parses as URI, but with unparsable authority\n+                    URI uri = new URI(sb.toString()).parseServerAuthority();\n+                    return editURI(uri, faults, hasPort);\n+                } catch (URISyntaxException use) {\n+                    int idx = use.getIndex();\n+                    if (idx < 0 || idx >= sb.length()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74a53b4d55123a3fa072c6c052d941d974f85b3a"}, "originalPosition": 240}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "43874ae97837177f4829f03ce95b0663104b4b72", "author": {"user": {"login": "bpintea", "name": "Bogdan Pintea"}}, "url": "https://github.com/elastic/elasticsearch/commit/43874ae97837177f4829f03ce95b0663104b4b72", "committedDate": "2020-07-01T12:12:29Z", "message": "Address review comments\n\n- remove unused var;\n- complete code comment."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9c9236871362f6375f86d71a227deace09b62245", "author": {"user": {"login": "elasticmachine", "name": "Elastic Machine"}}, "url": "https://github.com/elastic/elasticsearch/commit/9c9236871362f6375f86d71a227deace09b62245", "committedDate": "2020-07-01T14:15:41Z", "message": "Merge branch 'master' into enh/redact_credentials_in_invalid_uri"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cf2ae3a58b5908ade04b32acb0f92924b2566a98", "author": {"user": {"login": "elasticmachine", "name": "Elastic Machine"}}, "url": "https://github.com/elastic/elasticsearch/commit/cf2ae3a58b5908ade04b32acb0f92924b2566a98", "committedDate": "2020-07-01T17:58:56Z", "message": "Merge branch 'master' into enh/redact_credentials_in_invalid_uri"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2525, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}