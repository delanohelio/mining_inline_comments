{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMyNzUxOTI3", "number": 57962, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxODozMToxN1rOEOztYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxMjo0Njo0OFrOEPHRfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzOTYyNzIyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/fielddata/SortingNumericDocValues.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxODozMToxN1rOGyKxRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxODozMToxN1rOGyKxRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI1ODQzNg==", "bodyText": "l -> {} is good enough. But this is cool too.", "url": "https://github.com/elastic/elasticsearch/pull/57962#discussion_r455258436", "createdAt": "2020-07-15T18:31:17Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/index/fielddata/SortingNumericDocValues.java", "diffHunk": "@@ -33,8 +35,13 @@\n     protected long[] values;\n     protected int valuesCursor;\n     private final Sorter sorter;\n+    private LongConsumer circuitBreakerConsumer;\n \n     protected SortingNumericDocValues() {\n+        this((l) -> {});", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40b5388f2b6313d02b9996f51adec2fca25f5546"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzOTYzNzYzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/fielddata/SortingNumericDocValues.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxODozNDoxOFrOGyK4Nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxOTo1MzozN1rOGyNi0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI2MDIxNQ==", "bodyText": "Why not increment by the new size here and then decrement by the old size when we're done?", "url": "https://github.com/elastic/elasticsearch/pull/57962#discussion_r455260215", "createdAt": "2020-07-15T18:34:18Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/index/fielddata/SortingNumericDocValues.java", "diffHunk": "@@ -51,16 +58,40 @@ protected int compare(int i, int j) {\n                 return Long.compare(values[i], values[j]);\n             }\n         };\n+        this.circuitBreakerConsumer = circuitBreakerConsumer;\n+        // account for initial values size of 1\n+        this.circuitBreakerConsumer.accept(Long.BYTES);\n     }\n \n     /**\n      * Set the {@link #docValueCount()} and ensure that the {@link #values} array can\n      * store at least that many entries.\n      */\n     protected final void resize(int newSize) {\n+        int oldValuesLength = values.length;\n+        long oldValuesSizeInBytes = values.length * Long.BYTES;\n+\n+        // If array is expected to grow, increment the circuit breaker\n+        // to include both the additional bytes used by the grown array\n+        // as well as the overhead of keeping both arrays in memory while\n+        // copying.\n+        if (newSize > values.length) {\n+            int newValuesLength = ArrayUtil.oversize(newSize, Long.BYTES);\n+            long bytesDiff = (newValuesLength - oldValuesLength) * Long.BYTES;\n+            circuitBreakerConsumer.accept(bytesDiff);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40b5388f2b6313d02b9996f51adec2fca25f5546"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMwMzg5MA==", "bodyText": "I guess I was trying to keep consistent with the old logic, but I can see how this iterative addition can also be somewhat obtuse in this new logic.", "url": "https://github.com/elastic/elasticsearch/pull/57962#discussion_r455303890", "createdAt": "2020-07-15T19:53:37Z", "author": {"login": "talevy"}, "path": "server/src/main/java/org/elasticsearch/index/fielddata/SortingNumericDocValues.java", "diffHunk": "@@ -51,16 +58,40 @@ protected int compare(int i, int j) {\n                 return Long.compare(values[i], values[j]);\n             }\n         };\n+        this.circuitBreakerConsumer = circuitBreakerConsumer;\n+        // account for initial values size of 1\n+        this.circuitBreakerConsumer.accept(Long.BYTES);\n     }\n \n     /**\n      * Set the {@link #docValueCount()} and ensure that the {@link #values} array can\n      * store at least that many entries.\n      */\n     protected final void resize(int newSize) {\n+        int oldValuesLength = values.length;\n+        long oldValuesSizeInBytes = values.length * Long.BYTES;\n+\n+        // If array is expected to grow, increment the circuit breaker\n+        // to include both the additional bytes used by the grown array\n+        // as well as the overhead of keeping both arrays in memory while\n+        // copying.\n+        if (newSize > values.length) {\n+            int newValuesLength = ArrayUtil.oversize(newSize, Long.BYTES);\n+            long bytesDiff = (newValuesLength - oldValuesLength) * Long.BYTES;\n+            circuitBreakerConsumer.accept(bytesDiff);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI2MDIxNQ=="}, "originalCommit": {"oid": "40b5388f2b6313d02b9996f51adec2fca25f5546"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzOTY0MDcwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/fielddata/SortingNumericDocValues.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxODozNToxMlrOGyK6Mw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxODozNToxMlrOGyK6Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI2MDcyMw==", "bodyText": "I think it'd be clearer to bail early if the newSize <= values.length rather than relying on the behavior of ArrayUtils.grow", "url": "https://github.com/elastic/elasticsearch/pull/57962#discussion_r455260723", "createdAt": "2020-07-15T18:35:12Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/index/fielddata/SortingNumericDocValues.java", "diffHunk": "@@ -51,16 +58,40 @@ protected int compare(int i, int j) {\n                 return Long.compare(values[i], values[j]);\n             }\n         };\n+        this.circuitBreakerConsumer = circuitBreakerConsumer;\n+        // account for initial values size of 1\n+        this.circuitBreakerConsumer.accept(Long.BYTES);\n     }\n \n     /**\n      * Set the {@link #docValueCount()} and ensure that the {@link #values} array can\n      * store at least that many entries.\n      */\n     protected final void resize(int newSize) {\n+        int oldValuesLength = values.length;\n+        long oldValuesSizeInBytes = values.length * Long.BYTES;\n+\n+        // If array is expected to grow, increment the circuit breaker\n+        // to include both the additional bytes used by the grown array\n+        // as well as the overhead of keeping both arrays in memory while\n+        // copying.\n+        if (newSize > values.length) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40b5388f2b6313d02b9996f51adec2fca25f5546"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzOTY0NTY4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/fielddata/SortingNumericDocValues.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxODozNjozN1rOGyK9Zw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxODozNjozN1rOGyK9Zw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI2MTU0Mw==", "bodyText": "I think it'd be clearer overside on our side and then call growExact. That way you end up with a precise value that you are growing to for tracking. And I don't have to go and read the source of grow, just oversize.", "url": "https://github.com/elastic/elasticsearch/pull/57962#discussion_r455261543", "createdAt": "2020-07-15T18:36:37Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/index/fielddata/SortingNumericDocValues.java", "diffHunk": "@@ -51,16 +58,40 @@ protected int compare(int i, int j) {\n                 return Long.compare(values[i], values[j]);\n             }\n         };\n+        this.circuitBreakerConsumer = circuitBreakerConsumer;\n+        // account for initial values size of 1\n+        this.circuitBreakerConsumer.accept(Long.BYTES);\n     }\n \n     /**\n      * Set the {@link #docValueCount()} and ensure that the {@link #values} array can\n      * store at least that many entries.\n      */\n     protected final void resize(int newSize) {\n+        int oldValuesLength = values.length;\n+        long oldValuesSizeInBytes = values.length * Long.BYTES;\n+\n+        // If array is expected to grow, increment the circuit breaker\n+        // to include both the additional bytes used by the grown array\n+        // as well as the overhead of keeping both arrays in memory while\n+        // copying.\n+        if (newSize > values.length) {\n+            int newValuesLength = ArrayUtil.oversize(newSize, Long.BYTES);\n+            long bytesDiff = (newValuesLength - oldValuesLength) * Long.BYTES;\n+            circuitBreakerConsumer.accept(bytesDiff);\n+            circuitBreakerConsumer.accept(oldValuesSizeInBytes);\n+        }\n+\n+        // resize\n         count = newSize;\n         values = ArrayUtil.grow(values, count);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40b5388f2b6313d02b9996f51adec2fca25f5546"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MjgzMjYyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/fielddata/SortingNumericDocValues.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxMjo0Njo0OFrOGypS1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxMjo0Njo0OFrOGypS1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTc1ODU1MA==", "bodyText": "s/clean up/account for freeing/?", "url": "https://github.com/elastic/elasticsearch/pull/57962#discussion_r455758550", "createdAt": "2020-07-16T12:46:48Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/index/fielddata/SortingNumericDocValues.java", "diffHunk": "@@ -51,16 +58,35 @@ protected int compare(int i, int j) {\n                 return Long.compare(values[i], values[j]);\n             }\n         };\n+        this.circuitBreakerConsumer = circuitBreakerConsumer;\n+        // account for initial values size of 1\n+        this.circuitBreakerConsumer.accept(Long.BYTES);\n     }\n \n     /**\n      * Set the {@link #docValueCount()} and ensure that the {@link #values} array can\n      * store at least that many entries.\n      */\n     protected final void resize(int newSize) {\n+        if (newSize <= values.length) {\n+            return;\n+        }\n+\n+        // Array is expected to grow so increment the circuit breaker\n+        // to include both the additional bytes used by the grown array\n+        // as well as the overhead of keeping both arrays in memory while\n+        // copying.\n+        long oldValuesSizeInBytes = values.length * Long.BYTES;\n+        int newValuesLength = ArrayUtil.oversize(newSize, Long.BYTES);\n+        circuitBreakerConsumer.accept(newValuesLength * Long.BYTES);\n+\n+        // resize\n         count = newSize;\n-        values = ArrayUtil.grow(values, count);\n+        values = ArrayUtil.growExact(values, newValuesLength);\n         valuesCursor = 0;\n+\n+        // clean up old values array", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d470c72d3b1934d1a8fac06ed910a025a77252d"}, "originalPosition": 55}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1698, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}