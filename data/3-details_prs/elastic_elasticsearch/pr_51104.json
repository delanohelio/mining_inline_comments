{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYzNjc3NTM3", "number": 51104, "title": "Refactor ForEachProcessor to use iteration instead of recursion", "bodyText": "This change makes ForEachProcessor iterative and still non-blocking.\nIn case of non-async processors we use single for loop and no recursion at all.\nIn case of async processors we continue work on either current thread or thread\nstarted by downstream processor, whichever finishes second (usually processor thread).\nEverything is synchronized by single atomic variable.\nRelates #50514", "createdAt": "2020-01-16T14:34:58Z", "url": "https://github.com/elastic/elasticsearch/pull/51104", "merged": true, "mergeCommit": {"oid": "a4da1c9b46115624e630c9b91e73ee95d3f8262a"}, "closed": true, "closedAt": "2020-01-21T20:43:51Z", "author": {"login": "probakowski"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb642-WAH2gAyMzYzNjc3NTM3OjZlY2QzNzljZDNiMTQ4NGVjYzQyZjllZmJhYzU4NTdmNTExZDgxYTY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb8j_7EgFqTM0NjAyOTIzMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "6ecd379cd3b1484ecc42f9efbac5857f511d81a6", "author": {"user": {"login": "probakowski", "name": "Przemko Robakowski"}}, "url": "https://github.com/elastic/elasticsearch/commit/6ecd379cd3b1484ecc42f9efbac5857f511d81a6", "committedDate": "2020-01-16T11:57:16Z", "message": "Refactor ForEachProcessor to use iteration instead of recursion\n\nThis change makes ForEachProcessor iterative and still non-blocking.\nIn case of non-async processors we use single for loop and no recursion at all.\nIn case of async processors we continue work on either current thread or thread\nstarted by downstream processor, whichever is slower (usually processor thread).\nEverything is synchronised by single atomic variable.\n\nRelates #50514"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0d9276d5a4dd868fefa90a071f572920c3cf4535", "author": {"user": {"login": "probakowski", "name": "Przemko Robakowski"}}, "url": "https://github.com/elastic/elasticsearch/commit/0d9276d5a4dd868fefa90a071f572920c3cf4535", "committedDate": "2020-01-16T15:02:12Z", "message": "Unused imports removed"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0MDcwNzYz", "url": "https://github.com/elastic/elasticsearch/pull/51104#pullrequestreview-344070763", "createdAt": "2020-01-16T17:00:56Z", "commit": {"oid": "0d9276d5a4dd868fefa90a071f572920c3cf4535"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNzowMDo1N1rOFegx9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNzowMjowOVrOFeg0Pw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUzODY3OQ==", "bodyText": "I like this approach. In the case of inner processor going async; whichever thread sets this atomic boolean last should continue with the next value.\nAnd in the case inner processor doesn't go async then on the second getAndSet(...) the current thread continues with the next value.\nI do wonder if this variable can be renamed to describe this beter.", "url": "https://github.com/elastic/elasticsearch/pull/51104#discussion_r367538679", "createdAt": "2020-01-16T17:00:57Z", "author": {"login": "martijnvg"}, "path": "modules/ingest-common/src/main/java/org/elasticsearch/ingest/common/ForEachProcessor.java", "diffHunk": "@@ -79,41 +76,35 @@ public void execute(IngestDocument ingestDocument, BiConsumer<IngestDocument, Ex\n                 handler.accept(null, new IllegalArgumentException(\"field [\" + field + \"] is null, cannot loop over its elements.\"));\n             }\n         } else {\n-            List<Object> newValues = new CopyOnWriteArrayList<>();\n-            innerExecute(0, values, newValues, ingestDocument, handler);\n+            innerExecute(0, values, Collections.synchronizedList(new ArrayList<>(values.size())), ingestDocument, handler);\n         }\n     }\n \n     void innerExecute(int index, List<?> values, List<Object> newValues, IngestDocument document,\n                       BiConsumer<IngestDocument, Exception> handler) {\n+        for (; index < values.size(); index++) {\n+            AtomicBoolean shouldContinueHere = new AtomicBoolean();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d9276d5a4dd868fefa90a071f572920c3cf4535"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUzOTI2Mw==", "bodyText": "In this case recursion does happen, but we're not risking a SO here, because it always a different thread would get here.", "url": "https://github.com/elastic/elasticsearch/pull/51104#discussion_r367539263", "createdAt": "2020-01-16T17:02:09Z", "author": {"login": "martijnvg"}, "path": "modules/ingest-common/src/main/java/org/elasticsearch/ingest/common/ForEachProcessor.java", "diffHunk": "@@ -79,41 +76,35 @@ public void execute(IngestDocument ingestDocument, BiConsumer<IngestDocument, Ex\n                 handler.accept(null, new IllegalArgumentException(\"field [\" + field + \"] is null, cannot loop over its elements.\"));\n             }\n         } else {\n-            List<Object> newValues = new CopyOnWriteArrayList<>();\n-            innerExecute(0, values, newValues, ingestDocument, handler);\n+            innerExecute(0, values, Collections.synchronizedList(new ArrayList<>(values.size())), ingestDocument, handler);\n         }\n     }\n \n     void innerExecute(int index, List<?> values, List<Object> newValues, IngestDocument document,\n                       BiConsumer<IngestDocument, Exception> handler) {\n+        for (; index < values.size(); index++) {\n+            AtomicBoolean shouldContinueHere = new AtomicBoolean();\n+            Object value = values.get(index);\n+            Object previousValue = document.getIngestMetadata().put(\"_value\", value);\n+            int nextIndex = index + 1;\n+            processor.execute(document, (result, e) -> {\n+                newValues.add(document.getIngestMetadata().put(\"_value\", previousValue));\n+                if (e != null || result == null) {\n+                    handler.accept(result, e);\n+                } else if (shouldContinueHere.getAndSet(true)) {\n+                    innerExecute(nextIndex, values, newValues, document, handler);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d9276d5a4dd868fefa90a071f572920c3cf4535"}, "originalPosition": 58}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "089fca096833c79cfc442e0e4cd81babb555d204", "author": {"user": {"login": "probakowski", "name": "Przemko Robakowski"}}, "url": "https://github.com/elastic/elasticsearch/commit/089fca096833c79cfc442e0e4cd81babb555d204", "committedDate": "2020-01-16T20:28:26Z", "message": "Removed unnecessary synchronization, tests refactorings"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "03b0ab63c96e8ae783e0463c4554f6d4fdfed17c", "author": {"user": {"login": "probakowski", "name": "Przemko Robakowski"}}, "url": "https://github.com/elastic/elasticsearch/commit/03b0ab63c96e8ae783e0463c4554f6d4fdfed17c", "committedDate": "2020-01-16T20:39:09Z", "message": "Unused import removed"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bf8fdc201bf3497005cf291da1b40848f96c3a65", "author": {"user": {"login": "probakowski", "name": "Przemko Robakowski"}}, "url": "https://github.com/elastic/elasticsearch/commit/bf8fdc201bf3497005cf291da1b40848f96c3a65", "committedDate": "2020-01-16T20:53:36Z", "message": "Unused import removed"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0ODIwMjI3", "url": "https://github.com/elastic/elasticsearch/pull/51104#pullrequestreview-344820227", "createdAt": "2020-01-17T20:20:41Z", "commit": {"oid": "bf8fdc201bf3497005cf291da1b40848f96c3a65"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2MDI5MjMz", "url": "https://github.com/elastic/elasticsearch/pull/51104#pullrequestreview-346029233", "createdAt": "2020-01-21T16:46:53Z", "commit": {"oid": "bf8fdc201bf3497005cf291da1b40848f96c3a65"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2910, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}