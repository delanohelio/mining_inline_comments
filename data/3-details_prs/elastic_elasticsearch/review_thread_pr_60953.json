{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY1OTg3NTI2", "number": 60953, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNjoyODo1NFrOEXSgXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNjozMzoxN1rOEXSngw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyODU1OTAwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/common/compress/CompressedXContent.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNjoyODo1NFrOG-_zLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMDozMDowN1rOG_IISQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODcxMDE4OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return uncompressed().equals(uncompressed());\n          \n          \n            \n                    return uncompressed().equals(that.uncompressed());\n          \n      \n    \n    \n  \n\nalso looking at the code above, I wonder why we don't compare crc32 first before comparing the compressed byte arrays", "url": "https://github.com/elastic/elasticsearch/pull/60953#discussion_r468710189", "createdAt": "2020-08-11T16:28:54Z", "author": {"login": "jaymode"}, "path": "server/src/main/java/org/elasticsearch/common/compress/CompressedXContent.java", "diffHunk": "@@ -167,7 +162,7 @@ public boolean equals(Object o) {\n             return false;\n         }\n \n-        return Arrays.equals(uncompressed(), that.uncompressed());\n+        return uncompressed().equals(uncompressed());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c41903c6ac5e23824ab5c923497a7302c0e9e2f9"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODgyMjg1OA==", "bodyText": "\ud83e\udd26 thanks for spotting.\n\nI wonder why we don't compare crc32 first before comparing the compressed byte arrays\n\nI guess you could argue that it's really unlikely that the compressed bytes in the equal (as in equal uncompressed bytes) case aren't actually equal so you'd just add an extra int comparison in the equal case. So if we assume it's mostly the equal case here then the current version is better, I have no clue if that's true though. Probably doesn't matter much in practice since byte array comparison in JDK9+ is blazing fast anyway via jdk.internal.util.ArraysSupport#vectorizedMismatch? :)", "url": "https://github.com/elastic/elasticsearch/pull/60953#discussion_r468822858", "createdAt": "2020-08-11T19:44:29Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/common/compress/CompressedXContent.java", "diffHunk": "@@ -167,7 +162,7 @@ public boolean equals(Object o) {\n             return false;\n         }\n \n-        return Arrays.equals(uncompressed(), that.uncompressed());\n+        return uncompressed().equals(uncompressed());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODcxMDE4OQ=="}, "originalCommit": {"oid": "c41903c6ac5e23824ab5c923497a7302c0e9e2f9"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg0NjY2NQ==", "bodyText": "Probably doesn't matter much in practice\n\nI agree that it doesn't matter much. Just a random thought that popped into my head :)", "url": "https://github.com/elastic/elasticsearch/pull/60953#discussion_r468846665", "createdAt": "2020-08-11T20:30:07Z", "author": {"login": "jaymode"}, "path": "server/src/main/java/org/elasticsearch/common/compress/CompressedXContent.java", "diffHunk": "@@ -167,7 +162,7 @@ public boolean equals(Object o) {\n             return false;\n         }\n \n-        return Arrays.equals(uncompressed(), that.uncompressed());\n+        return uncompressed().equals(uncompressed());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODcxMDE4OQ=="}, "originalCommit": {"oid": "c41903c6ac5e23824ab5c923497a7302c0e9e2f9"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyODU3NzMxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/common/compress/DeflateCompressor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNjozMzoxOFrOG-_-Vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxOTo0NDozNFrOG_GreQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODcxMzA0Ng==", "bodyText": "IMO it would be a good idea to add a comment about why these threadlocals are not used in the other methods of the class", "url": "https://github.com/elastic/elasticsearch/pull/60953#discussion_r468713046", "createdAt": "2020-08-11T16:33:18Z", "author": {"login": "jaymode"}, "path": "server/src/main/java/org/elasticsearch/common/compress/DeflateCompressor.java", "diffHunk": "@@ -129,4 +131,37 @@ public void close() throws IOException {\n             }\n         };\n     }\n+\n+    private static final ThreadLocal<Inflater> inflaterRef = ThreadLocal.withInitial(() -> new Inflater(true));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c41903c6ac5e23824ab5c923497a7302c0e9e2f9"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODgyMjkwNQ==", "bodyText": "++", "url": "https://github.com/elastic/elasticsearch/pull/60953#discussion_r468822905", "createdAt": "2020-08-11T19:44:34Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/common/compress/DeflateCompressor.java", "diffHunk": "@@ -129,4 +131,37 @@ public void close() throws IOException {\n             }\n         };\n     }\n+\n+    private static final ThreadLocal<Inflater> inflaterRef = ThreadLocal.withInitial(() -> new Inflater(true));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODcxMzA0Ng=="}, "originalCommit": {"oid": "c41903c6ac5e23824ab5c923497a7302c0e9e2f9"}, "originalPosition": 21}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2552, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}