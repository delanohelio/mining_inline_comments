{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE5NzQzMDkw", "number": 64976, "title": "Makes testCcrRepositoryFetchesSnapshotShardSizeFromIndexShardStoreStats more robust", "bodyText": "Today this test fails because the sizes of the snapshot shards are only kept in a very short period of time in the InternalSnapshotsInfoService and are not guaranteed to exist once the shards are correctly assigned.\nThis test implements a suggestion from Armin to make the test both simpler and less prone to failures.\ncloses #64167", "createdAt": "2020-11-12T09:22:47Z", "url": "https://github.com/elastic/elasticsearch/pull/64976", "merged": true, "mergeCommit": {"oid": "ef5b67214faf7966cebbde5cc8f9073356a2786a"}, "closed": true, "closedAt": "2020-11-12T11:27:26Z", "author": {"login": "tlrx"}, "timelineItems": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdbvAejgH2gAyNTE5NzQzMDkwOmRiMWVmNGUyYjBhZTdhMzE2M2FhZGQxYzViYjVjZWZiYjlhYmE0ZGM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdbwBOHAH2gAyNTE5NzQzMDkwOmY5YjUzY2MwMjg1MjdkZjE1ZDExNmZjYzczZjRiMjM5MTQ0YmI5MTE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "db1ef4e2b0ae7a3163aadd1c5bb5cefbb9aba4dc", "author": {"user": {"login": "tlrx", "name": "Tanguy Leroux"}}, "url": "https://github.com/elastic/elasticsearch/commit/db1ef4e2b0ae7a3163aadd1c5bb5cefbb9aba4dc", "committedDate": "2020-11-12T09:19:15Z", "message": "Check snapshot shard sizes within cluster state listener\n\ncloses #64167"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI4OTQwMTQ3", "url": "https://github.com/elastic/elasticsearch/pull/64976#pullrequestreview-528940147", "createdAt": "2020-11-12T10:17:53Z", "commit": {"oid": "db1ef4e2b0ae7a3163aadd1c5bb5cefbb9aba4dc"}, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxMDoxNzo1M1rOHxz6gg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxMDoyMTowMlrOHx0CYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTk5MjgzNA==", "bodyText": "Should we  remove this listener before we enter the busy assert loop? Otherwise subsequent CS updates will run into it again in the background again and again? (technically probably not a problem because subsequent CS updates will prevent us from getting here but I'd still remove it to have one less thing to worry about when debugging this :)", "url": "https://github.com/elastic/elasticsearch/pull/64976#discussion_r521992834", "createdAt": "2020-11-12T10:17:53Z", "author": {"login": "original-brownbear"}, "path": "x-pack/plugin/ccr/src/internalClusterTest/java/org/elasticsearch/xpack/ccr/CcrRepositoryIT.java", "diffHunk": "@@ -513,69 +517,62 @@ public void testCcrRepositoryFetchesSnapshotShardSizeFromIndexShardStoreStats()\n                 equalTo(indexStats.getIndexShards().get(shardId).getPrimary().getStore().getSizeInBytes()));\n         }\n \n-        final CountDownLatch blockCcrRestore = new CountDownLatch(1);\n-\n-        final List<MockTransportService> transportServices = new ArrayList<>();\n-        for (TransportService transportService : getFollowerCluster().getDataOrMasterNodeInstances(TransportService.class)) {\n-            final MockTransportService mockTransportService = (MockTransportService) transportService;\n-            mockTransportService.addSendBehavior((connection, requestId, action, request, options) -> {\n-                if (action.equals(PutCcrRestoreSessionAction.NAME)) {\n-                    try {\n-                        blockCcrRestore.await();\n-                    } catch (InterruptedException e) {\n-                        throw new AssertionError(e);\n+        final String followerIndex = \"follower\";\n+        final RestoreService restoreService = getFollowerCluster().getCurrentMasterNodeInstance(RestoreService.class);\n+        final ClusterService clusterService = getFollowerCluster().getCurrentMasterNodeInstance(ClusterService.class);\n+        final SnapshotsInfoService snapshotsInfoService = getFollowerCluster().getCurrentMasterNodeInstance(SnapshotsInfoService.class);\n+\n+        final Map<Integer, Long> fetchedSnapshotShardSizes = new ConcurrentHashMap<>();\n+\n+        final PlainActionFuture<Void> waitForRestoreInProgress = PlainActionFuture.newFuture();\n+        final ClusterStateListener listener = event -> {\n+            RestoreInProgress restoreInProgress = event.state().custom(RestoreInProgress.TYPE, RestoreInProgress.EMPTY);\n+            if (restoreInProgress != null\n+                && restoreInProgress.isEmpty() == false\n+                && event.state().routingTable().hasIndex(followerIndex)) {\n+                final IndexRoutingTable indexRoutingTable = event.state().routingTable().index(followerIndex);\n+                for (ShardRouting shardRouting : indexRoutingTable.shardsWithState(ShardRoutingState.UNASSIGNED)) {\n+                    if (shardRouting.unassignedInfo().getLastAllocationStatus() == AllocationStatus.FETCHING_SHARD_DATA) {\n+                        try {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db1ef4e2b0ae7a3163aadd1c5bb5cefbb9aba4dc"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTk5MzE5Mg==", "bodyText": "Let's add the exception to the AssertionError?", "url": "https://github.com/elastic/elasticsearch/pull/64976#discussion_r521993192", "createdAt": "2020-11-12T10:18:28Z", "author": {"login": "original-brownbear"}, "path": "x-pack/plugin/ccr/src/internalClusterTest/java/org/elasticsearch/xpack/ccr/CcrRepositoryIT.java", "diffHunk": "@@ -513,69 +517,62 @@ public void testCcrRepositoryFetchesSnapshotShardSizeFromIndexShardStoreStats()\n                 equalTo(indexStats.getIndexShards().get(shardId).getPrimary().getStore().getSizeInBytes()));\n         }\n \n-        final CountDownLatch blockCcrRestore = new CountDownLatch(1);\n-\n-        final List<MockTransportService> transportServices = new ArrayList<>();\n-        for (TransportService transportService : getFollowerCluster().getDataOrMasterNodeInstances(TransportService.class)) {\n-            final MockTransportService mockTransportService = (MockTransportService) transportService;\n-            mockTransportService.addSendBehavior((connection, requestId, action, request, options) -> {\n-                if (action.equals(PutCcrRestoreSessionAction.NAME)) {\n-                    try {\n-                        blockCcrRestore.await();\n-                    } catch (InterruptedException e) {\n-                        throw new AssertionError(e);\n+        final String followerIndex = \"follower\";\n+        final RestoreService restoreService = getFollowerCluster().getCurrentMasterNodeInstance(RestoreService.class);\n+        final ClusterService clusterService = getFollowerCluster().getCurrentMasterNodeInstance(ClusterService.class);\n+        final SnapshotsInfoService snapshotsInfoService = getFollowerCluster().getCurrentMasterNodeInstance(SnapshotsInfoService.class);\n+\n+        final Map<Integer, Long> fetchedSnapshotShardSizes = new ConcurrentHashMap<>();\n+\n+        final PlainActionFuture<Void> waitForRestoreInProgress = PlainActionFuture.newFuture();\n+        final ClusterStateListener listener = event -> {\n+            RestoreInProgress restoreInProgress = event.state().custom(RestoreInProgress.TYPE, RestoreInProgress.EMPTY);\n+            if (restoreInProgress != null\n+                && restoreInProgress.isEmpty() == false\n+                && event.state().routingTable().hasIndex(followerIndex)) {\n+                final IndexRoutingTable indexRoutingTable = event.state().routingTable().index(followerIndex);\n+                for (ShardRouting shardRouting : indexRoutingTable.shardsWithState(ShardRoutingState.UNASSIGNED)) {\n+                    if (shardRouting.unassignedInfo().getLastAllocationStatus() == AllocationStatus.FETCHING_SHARD_DATA) {\n+                        try {\n+                            assertBusy(() -> {\n+                                final Long snapshotShardSize = snapshotsInfoService.snapshotShardSizes().getShardSize(shardRouting);\n+                                assertThat(snapshotShardSize, notNullValue());\n+                                fetchedSnapshotShardSizes.put(shardRouting.getId(), snapshotShardSize);\n+                            }, 30L, TimeUnit.SECONDS);\n+                        } catch (Exception e) {\n+                            throw new AssertionError(\"Failed to retrieve snapshot shard size for shard \" + shardRouting);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db1ef4e2b0ae7a3163aadd1c5bb5cefbb9aba4dc"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTk5MzUzOA==", "bodyText": "Let's add a -->  prefix to this logging like we have for other test log lines?", "url": "https://github.com/elastic/elasticsearch/pull/64976#discussion_r521993538", "createdAt": "2020-11-12T10:19:02Z", "author": {"login": "original-brownbear"}, "path": "x-pack/plugin/ccr/src/internalClusterTest/java/org/elasticsearch/xpack/ccr/CcrRepositoryIT.java", "diffHunk": "@@ -513,69 +517,62 @@ public void testCcrRepositoryFetchesSnapshotShardSizeFromIndexShardStoreStats()\n                 equalTo(indexStats.getIndexShards().get(shardId).getPrimary().getStore().getSizeInBytes()));\n         }\n \n-        final CountDownLatch blockCcrRestore = new CountDownLatch(1);\n-\n-        final List<MockTransportService> transportServices = new ArrayList<>();\n-        for (TransportService transportService : getFollowerCluster().getDataOrMasterNodeInstances(TransportService.class)) {\n-            final MockTransportService mockTransportService = (MockTransportService) transportService;\n-            mockTransportService.addSendBehavior((connection, requestId, action, request, options) -> {\n-                if (action.equals(PutCcrRestoreSessionAction.NAME)) {\n-                    try {\n-                        blockCcrRestore.await();\n-                    } catch (InterruptedException e) {\n-                        throw new AssertionError(e);\n+        final String followerIndex = \"follower\";\n+        final RestoreService restoreService = getFollowerCluster().getCurrentMasterNodeInstance(RestoreService.class);\n+        final ClusterService clusterService = getFollowerCluster().getCurrentMasterNodeInstance(ClusterService.class);\n+        final SnapshotsInfoService snapshotsInfoService = getFollowerCluster().getCurrentMasterNodeInstance(SnapshotsInfoService.class);\n+\n+        final Map<Integer, Long> fetchedSnapshotShardSizes = new ConcurrentHashMap<>();\n+\n+        final PlainActionFuture<Void> waitForRestoreInProgress = PlainActionFuture.newFuture();\n+        final ClusterStateListener listener = event -> {\n+            RestoreInProgress restoreInProgress = event.state().custom(RestoreInProgress.TYPE, RestoreInProgress.EMPTY);\n+            if (restoreInProgress != null\n+                && restoreInProgress.isEmpty() == false\n+                && event.state().routingTable().hasIndex(followerIndex)) {\n+                final IndexRoutingTable indexRoutingTable = event.state().routingTable().index(followerIndex);\n+                for (ShardRouting shardRouting : indexRoutingTable.shardsWithState(ShardRoutingState.UNASSIGNED)) {\n+                    if (shardRouting.unassignedInfo().getLastAllocationStatus() == AllocationStatus.FETCHING_SHARD_DATA) {\n+                        try {\n+                            assertBusy(() -> {\n+                                final Long snapshotShardSize = snapshotsInfoService.snapshotShardSizes().getShardSize(shardRouting);\n+                                assertThat(snapshotShardSize, notNullValue());\n+                                fetchedSnapshotShardSizes.put(shardRouting.getId(), snapshotShardSize);\n+                            }, 30L, TimeUnit.SECONDS);\n+                        } catch (Exception e) {\n+                            throw new AssertionError(\"Failed to retrieve snapshot shard size for shard \" + shardRouting);\n+                        }\n                     }\n                 }\n-                connection.sendRequest(requestId, action, request, options);\n-            });\n-            transportServices.add(mockTransportService);\n-        }\n-\n-        try {\n-            final String followerIndex = \"follower\";\n-            final RestoreService restoreService = getFollowerCluster().getCurrentMasterNodeInstance(RestoreService.class);\n-            final ClusterService clusterService = getFollowerCluster().getCurrentMasterNodeInstance(ClusterService.class);\n-\n-            final PlainActionFuture<IndexRoutingTable> waitForRestoreInProgress = PlainActionFuture.newFuture();\n-            final ClusterStateListener listener = event -> {\n-                RestoreInProgress restoreInProgress = event.state().custom(RestoreInProgress.TYPE, RestoreInProgress.EMPTY);\n-                if (restoreInProgress != null\n-                    && restoreInProgress.isEmpty() == false\n-                    && event.state().routingTable().hasIndex(followerIndex)) {\n-                    waitForRestoreInProgress.onResponse(event.state().routingTable().index(followerIndex));\n-                }\n-            };\n-            clusterService.addListener(listener);\n-\n-            final RestoreSnapshotRequest restoreRequest = new RestoreSnapshotRequest(leaderCluster, CcrRepository.LATEST)\n-                .indices(leaderIndex).indicesOptions(indicesOptions).renamePattern(\"^(.*)$\")\n-                .renameReplacement(followerIndex)\n-                .masterNodeTimeout(TimeValue.MAX_VALUE)\n-                .indexSettings(Settings.builder()\n-                    .put(IndexMetadata.SETTING_INDEX_PROVIDED_NAME, followerIndex)\n-                    .put(CcrSettings.CCR_FOLLOWING_INDEX_SETTING.getKey(), true));\n-            restoreService.restoreSnapshot(restoreRequest, PlainActionFuture.newFuture());\n-\n-            final IndexRoutingTable indexRoutingTable = waitForRestoreInProgress.get(30L, TimeUnit.SECONDS);\n-            clusterService.removeListener(listener);\n-\n-            final SnapshotsInfoService snapshotsInfoService = getFollowerCluster().getCurrentMasterNodeInstance(SnapshotsInfoService.class);\n-            assertBusy(() -> {\n-                SnapshotShardSizeInfo snapshotShardSizeInfo = snapshotsInfoService.snapshotShardSizes();\n-                for (int shardId = 0; shardId < numberOfShards; shardId++) {\n-                    Long snapshotShardSize = snapshotShardSizeInfo.getShardSize(indexRoutingTable.shard(shardId).primaryShard());\n-                    assertThat(snapshotShardSize,\n-                        equalTo(indexStats.getIndexShards().get(shardId).getPrimary().getStore().getSizeInBytes()));\n+                logger.info(\"[{}/{}] snapshot shard sizes fetched\", fetchedSnapshotShardSizes.size(), numberOfShards);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db1ef4e2b0ae7a3163aadd1c5bb5cefbb9aba4dc"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTk5NDg0OA==", "bodyText": "Could just make this a PlainActionFuture<Map<Integer, Long>> and return the map from it instead of having it in the outer scope? :) Makes it a little clearer when the map is coming from and you don't have to reason about why there's a CHM when debugging this.", "url": "https://github.com/elastic/elasticsearch/pull/64976#discussion_r521994848", "createdAt": "2020-11-12T10:21:02Z", "author": {"login": "original-brownbear"}, "path": "x-pack/plugin/ccr/src/internalClusterTest/java/org/elasticsearch/xpack/ccr/CcrRepositoryIT.java", "diffHunk": "@@ -513,69 +517,62 @@ public void testCcrRepositoryFetchesSnapshotShardSizeFromIndexShardStoreStats()\n                 equalTo(indexStats.getIndexShards().get(shardId).getPrimary().getStore().getSizeInBytes()));\n         }\n \n-        final CountDownLatch blockCcrRestore = new CountDownLatch(1);\n-\n-        final List<MockTransportService> transportServices = new ArrayList<>();\n-        for (TransportService transportService : getFollowerCluster().getDataOrMasterNodeInstances(TransportService.class)) {\n-            final MockTransportService mockTransportService = (MockTransportService) transportService;\n-            mockTransportService.addSendBehavior((connection, requestId, action, request, options) -> {\n-                if (action.equals(PutCcrRestoreSessionAction.NAME)) {\n-                    try {\n-                        blockCcrRestore.await();\n-                    } catch (InterruptedException e) {\n-                        throw new AssertionError(e);\n+        final String followerIndex = \"follower\";\n+        final RestoreService restoreService = getFollowerCluster().getCurrentMasterNodeInstance(RestoreService.class);\n+        final ClusterService clusterService = getFollowerCluster().getCurrentMasterNodeInstance(ClusterService.class);\n+        final SnapshotsInfoService snapshotsInfoService = getFollowerCluster().getCurrentMasterNodeInstance(SnapshotsInfoService.class);\n+\n+        final Map<Integer, Long> fetchedSnapshotShardSizes = new ConcurrentHashMap<>();\n+\n+        final PlainActionFuture<Void> waitForRestoreInProgress = PlainActionFuture.newFuture();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db1ef4e2b0ae7a3163aadd1c5bb5cefbb9aba4dc"}, "originalPosition": 61}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f9b53cc028527df15d116fcc73f4b239144bb911", "author": {"user": {"login": "tlrx", "name": "Tanguy Leroux"}}, "url": "https://github.com/elastic/elasticsearch/commit/f9b53cc028527df15d116fcc73f4b239144bb911", "committedDate": "2020-11-12T10:29:58Z", "message": "add exception ++ -->"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1040, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}