{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAxNjg2NDUz", "number": 55037, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxOTozODo1NFrODxXGSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzo1NDo0OFrODx9N_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMDg1MjU2OnYy", "diffSide": "LEFT", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/type/SqlDataTypes.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxOTozODo1NFrOGEyhNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxOTozODo1NFrOGEyhNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY3NTE4OA==", "bodyText": "@elastic/es-ql does anyone know why the geo_shape field was here as isFromDocValuesOnly when the field did not have doc values?", "url": "https://github.com/elastic/elasticsearch/pull/55037#discussion_r407675188", "createdAt": "2020-04-13T19:38:54Z", "author": {"login": "talevy"}, "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/type/SqlDataTypes.java", "diffHunk": "@@ -274,7 +274,6 @@ public static boolean isFromDocValuesOnly(DataType dataType) {\n                 || dataType == SCALED_FLOAT // because of scaling_factor\n                 || dataType == CONSTANT_KEYWORD\n                 || dataType == GEO_POINT\n-                || dataType == GEO_SHAPE", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d00c40b8a9799ec6cb3d62e081e659864f343c71"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzA5ODIxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/mapper/GeoShapeWithDocValuesFieldMapper.java", "isResolved": true, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzo1NDo0OFrOGFuBag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxNToyMjo1NFrOGGqrYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY1MDA5MA==", "bodyText": "Can we add a test that defines the behaviour when merging mapping with different set up in doc values? (I guess this class does not exists together with GeoShapeFieldMapper? you have either one or the other)", "url": "https://github.com/elastic/elasticsearch/pull/55037#discussion_r408650090", "createdAt": "2020-04-15T07:54:48Z", "author": {"login": "iverase"}, "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/mapper/GeoShapeWithDocValuesFieldMapper.java", "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.spatial.index.mapper;\n+\n+import org.apache.lucene.document.LatLonShape;\n+import org.apache.lucene.document.ShapeField;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.DocValuesFieldExistsQuery;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.TermQuery;\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.Explicit;\n+import org.elasticsearch.common.geo.GeometryParser;\n+import org.elasticsearch.common.geo.builders.ShapeBuilder;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.support.XContentMapValues;\n+import org.elasticsearch.geometry.Geometry;\n+import org.elasticsearch.index.fielddata.IndexFieldData;\n+import org.elasticsearch.index.mapper.AbstractGeometryFieldMapper;\n+import org.elasticsearch.index.mapper.FieldNamesFieldMapper;\n+import org.elasticsearch.index.mapper.GeoShapeIndexer;\n+import org.elasticsearch.index.mapper.LegacyGeoShapeFieldMapper;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+import org.elasticsearch.index.mapper.Mapper;\n+import org.elasticsearch.index.mapper.MapperParsingException;\n+import org.elasticsearch.index.mapper.ParseContext;\n+import org.elasticsearch.index.mapper.TypeParsers;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.index.query.QueryShardException;\n+import org.elasticsearch.index.query.VectorGeoShapeQueryProcessor;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Extension of {@link org.elasticsearch.index.mapper.GeoShapeFieldMapper} that supports docValues\n+ *\n+ * FieldMapper for indexing {@link LatLonShape}s.\n+ * <p>\n+ * Currently Shapes can only be indexed and can only be queried using\n+ * {@link org.elasticsearch.index.query.GeoShapeQueryBuilder}, consequently\n+ * a lot of behavior in this Mapper is disabled.\n+ * <p>\n+ * Format supported:\n+ * <p>\n+ * \"field\" : {\n+ * \"type\" : \"polygon\",\n+ * \"coordinates\" : [\n+ * [ [100.0, 0.0], [101.0, 0.0], [101.0, 1.0], [100.0, 1.0], [100.0, 0.0] ]\n+ * ]\n+ * }\n+ * <p>\n+ * or:\n+ * <p>\n+ * \"field\" : \"POLYGON ((100.0 0.0, 101.0 0.0, 101.0 1.0, 100.0 1.0, 100.0 0.0))\n+ */\n+public class GeoShapeWithDocValuesFieldMapper extends AbstractGeometryFieldMapper<Geometry, Geometry> {\n+    public static final String CONTENT_TYPE = \"geo_shape\";\n+\n+\n+    private Explicit<Boolean> docValues;\n+\n+    @Override\n+    public void doXContentBody(XContentBuilder builder, boolean includeDefaults, Params params) throws IOException {\n+        super.doXContentBody(builder, includeDefaults, params);\n+        if (includeDefaults || docValues.explicit()) {\n+            builder.field(TypeParsers.DOC_VALUES, docValues.value());\n+        }\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    public static class Builder extends AbstractGeometryFieldMapper.Builder<AbstractGeometryFieldMapper.Builder,\n+            GeoShapeWithDocValuesFieldMapper> {\n+        public Builder(String name) {\n+            super (name, new GeoShapeWithDocValuesFieldType(), new GeoShapeWithDocValuesFieldType());\n+        }\n+\n+        @Override\n+        public GeoShapeWithDocValuesFieldMapper build(BuilderContext context) {\n+            setupFieldType(context);\n+            return new GeoShapeWithDocValuesFieldMapper(name, fieldType, defaultFieldType, ignoreMalformed(context), coerce(context),\n+                ignoreZValue(), docValues(), context.indexSettings(),\n+                multiFieldsBuilder.build(this, context), copyTo);\n+        }\n+\n+        @Override\n+        public boolean defaultDocValues(Version indexCreated) {\n+            return Version.V_8_0_0.onOrBefore(indexCreated);\n+        }\n+\n+        protected Explicit<Boolean> docValues() {\n+            if (docValuesSet && fieldType.hasDocValues()) {\n+                return new Explicit<>(true, true);\n+            } else if (docValuesSet) {\n+                return new Explicit<>(false, true);\n+            }\n+            return new Explicit<>(fieldType.hasDocValues(), false);\n+        }\n+\n+        protected void setupFieldType(BuilderContext context) {\n+            super.setupFieldType(context);\n+\n+            GeoShapeWithDocValuesFieldType fieldType = (GeoShapeWithDocValuesFieldType)fieldType();\n+            boolean orientation = fieldType.orientation() == ShapeBuilder.Orientation.RIGHT;\n+\n+            GeometryParser geometryParser = new GeometryParser(orientation, coerce(context).value(), ignoreZValue().value());\n+\n+            fieldType.setGeometryIndexer(new GeoShapeIndexer(orientation, fieldType.name()) {\n+                @Override\n+                public List<IndexableField> indexShape(ParseContext context, Geometry shape) {\n+                    List<IndexableField> fields = super.indexShape(context, shape);\n+                    if (fieldType().hasDocValues()) {\n+                        CentroidCalculator calculator = new CentroidCalculator(shape);\n+                        final byte[] scratch = new byte[7 * Integer.BYTES];\n+                        // doc values are generated from the indexed fields.\n+                        ShapeField.DecodedTriangle[] triangles = new ShapeField.DecodedTriangle[fields.size()];\n+                        for (int i = 0; i < fields.size(); i++) {\n+                            BytesRef bytesRef = fields.get(i).binaryValue();\n+                            assert bytesRef.length == 7 * Integer.BYTES;\n+                            System.arraycopy(bytesRef.bytes, bytesRef.offset, scratch, 0, 7 * Integer.BYTES);\n+                            ShapeField.decodeTriangle(scratch, triangles[i] = new ShapeField.DecodedTriangle());\n+                        }\n+                        BinaryGeoShapeDocValuesField docValuesField =\n+                            (BinaryGeoShapeDocValuesField) context.doc().getByKey(name);\n+                        if (docValuesField == null) {\n+                            docValuesField = new BinaryGeoShapeDocValuesField(name, triangles, calculator);\n+                            context.doc().addWithKey(name, docValuesField);\n+                        } else {\n+                            docValuesField.add(triangles, calculator);\n+                        }\n+                    }\n+                    return fields;\n+                }\n+            });\n+            fieldType.setGeometryParser( (parser, mapper) -> geometryParser.parse(parser));\n+            fieldType.setGeometryQueryBuilder(new VectorGeoShapeQueryProcessor());\n+        }\n+    }\n+\n+    public static final class GeoShapeWithDocValuesFieldType extends AbstractGeometryFieldType<Geometry, Geometry> {\n+        public GeoShapeWithDocValuesFieldType() {\n+            super();\n+        }\n+\n+        protected GeoShapeWithDocValuesFieldType(GeoShapeWithDocValuesFieldType ref) {\n+            super(ref);\n+        }\n+\n+        public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName) {\n+            failIfNoDocValues();\n+            return new AbstractLatLonShapeDVIndexFieldData.Builder();\n+        }\n+\n+        @Override\n+        public Query existsQuery(QueryShardContext context) {\n+            if (hasDocValues()) {\n+                return new DocValuesFieldExistsQuery(name());\n+            } else {\n+                return new TermQuery(new Term(FieldNamesFieldMapper.NAME, name()));\n+            }\n+        }\n+\n+        @Override\n+        public Query termQuery(Object value, QueryShardContext context) {\n+            throw new QueryShardException(context, \"Geo fields do not support exact searching, use dedicated geo queries instead: [\"\n+                + name() + \"]\");\n+        }\n+\n+        @Override\n+        public GeoShapeWithDocValuesFieldType clone() {\n+            return new GeoShapeWithDocValuesFieldType(this);\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return CONTENT_TYPE;\n+        }\n+    }\n+\n+    public static final class TypeParser extends AbstractGeometryFieldMapper.TypeParser {\n+\n+        @Override\n+        @SuppressWarnings(\"rawtypes\")\n+        protected AbstractGeometryFieldMapper.Builder newBuilder(String name, Map<String, Object> params) {\n+            if (params.containsKey(DEPRECATED_PARAMETERS_KEY)) {\n+                return new LegacyGeoShapeFieldMapper.Builder(name,\n+                    (LegacyGeoShapeFieldMapper.DeprecatedParameters)params.get(DEPRECATED_PARAMETERS_KEY));\n+            }\n+            return new GeoShapeWithDocValuesFieldMapper.Builder(name);\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"rawtypes\")\n+        public Mapper.Builder parse(String name, Map<String, Object> node, ParserContext parserContext) throws MapperParsingException {\n+            Map<String, Object> params = new HashMap<>();\n+            AbstractGeometryFieldMapper.Builder builder = (AbstractGeometryFieldMapper.Builder) super.parse(name, node, parserContext);\n+            for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(); iterator.hasNext();) {\n+                Map.Entry<String, Object> entry = iterator.next();\n+                String fieldName = entry.getKey();\n+                Object fieldNode = entry.getValue();\n+                if (TypeParsers.DOC_VALUES.equals(fieldName)) {\n+                    params.put(TypeParsers.DOC_VALUES, XContentMapValues.nodeBooleanValue(fieldNode, name + \".\" + TypeParsers.DOC_VALUES));\n+                    iterator.remove();\n+                }\n+            }\n+\n+            if (params.containsKey(TypeParsers.DOC_VALUES)) {\n+                builder.docValues((Boolean) params.get(TypeParsers.DOC_VALUES));\n+            }\n+            return builder;\n+        }\n+    }\n+\n+    public GeoShapeWithDocValuesFieldMapper(String simpleName, MappedFieldType fieldType, MappedFieldType defaultFieldType,\n+                                            Explicit<Boolean> ignoreMalformed, Explicit<Boolean> coerce,\n+                                            Explicit<Boolean> ignoreZValue, Explicit<Boolean> docValues, Settings indexSettings,\n+                                            MultiFields multiFields, CopyTo copyTo) {\n+        super(simpleName, fieldType, defaultFieldType, ignoreMalformed, coerce, ignoreZValue, indexSettings,\n+            multiFields, copyTo);\n+        this.docValues = docValues;\n+    }\n+\n+    @Override\n+    protected void doMerge(Mapper mergeWith) {\n+        if (mergeWith instanceof LegacyGeoShapeFieldMapper) {\n+            LegacyGeoShapeFieldMapper legacy = (LegacyGeoShapeFieldMapper) mergeWith;\n+            throw new IllegalArgumentException(\"[\" + fieldType().name() + \"] with field mapper [\" + fieldType().typeName() + \"] \" +\n+                \"using [BKD] strategy cannot be merged with \" + \"[\" + legacy.fieldType().typeName() + \"] with [\" +\n+                legacy.fieldType().strategy() + \"] strategy\");\n+        }\n+        super.doMerge(mergeWith);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "12d6a6cdd7b8adbc1bbf910efdfef7f18ef74591"}, "originalPosition": 241}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg5MTI3Nw==", "bodyText": "yeah, I am not sure what the best way of testing this is. I think what would be best is to have an integration test where there is a full-cluster restart switching from OSS to Default", "url": "https://github.com/elastic/elasticsearch/pull/55037#discussion_r408891277", "createdAt": "2020-04-15T14:35:19Z", "author": {"login": "talevy"}, "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/mapper/GeoShapeWithDocValuesFieldMapper.java", "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.spatial.index.mapper;\n+\n+import org.apache.lucene.document.LatLonShape;\n+import org.apache.lucene.document.ShapeField;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.DocValuesFieldExistsQuery;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.TermQuery;\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.Explicit;\n+import org.elasticsearch.common.geo.GeometryParser;\n+import org.elasticsearch.common.geo.builders.ShapeBuilder;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.support.XContentMapValues;\n+import org.elasticsearch.geometry.Geometry;\n+import org.elasticsearch.index.fielddata.IndexFieldData;\n+import org.elasticsearch.index.mapper.AbstractGeometryFieldMapper;\n+import org.elasticsearch.index.mapper.FieldNamesFieldMapper;\n+import org.elasticsearch.index.mapper.GeoShapeIndexer;\n+import org.elasticsearch.index.mapper.LegacyGeoShapeFieldMapper;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+import org.elasticsearch.index.mapper.Mapper;\n+import org.elasticsearch.index.mapper.MapperParsingException;\n+import org.elasticsearch.index.mapper.ParseContext;\n+import org.elasticsearch.index.mapper.TypeParsers;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.index.query.QueryShardException;\n+import org.elasticsearch.index.query.VectorGeoShapeQueryProcessor;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Extension of {@link org.elasticsearch.index.mapper.GeoShapeFieldMapper} that supports docValues\n+ *\n+ * FieldMapper for indexing {@link LatLonShape}s.\n+ * <p>\n+ * Currently Shapes can only be indexed and can only be queried using\n+ * {@link org.elasticsearch.index.query.GeoShapeQueryBuilder}, consequently\n+ * a lot of behavior in this Mapper is disabled.\n+ * <p>\n+ * Format supported:\n+ * <p>\n+ * \"field\" : {\n+ * \"type\" : \"polygon\",\n+ * \"coordinates\" : [\n+ * [ [100.0, 0.0], [101.0, 0.0], [101.0, 1.0], [100.0, 1.0], [100.0, 0.0] ]\n+ * ]\n+ * }\n+ * <p>\n+ * or:\n+ * <p>\n+ * \"field\" : \"POLYGON ((100.0 0.0, 101.0 0.0, 101.0 1.0, 100.0 1.0, 100.0 0.0))\n+ */\n+public class GeoShapeWithDocValuesFieldMapper extends AbstractGeometryFieldMapper<Geometry, Geometry> {\n+    public static final String CONTENT_TYPE = \"geo_shape\";\n+\n+\n+    private Explicit<Boolean> docValues;\n+\n+    @Override\n+    public void doXContentBody(XContentBuilder builder, boolean includeDefaults, Params params) throws IOException {\n+        super.doXContentBody(builder, includeDefaults, params);\n+        if (includeDefaults || docValues.explicit()) {\n+            builder.field(TypeParsers.DOC_VALUES, docValues.value());\n+        }\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    public static class Builder extends AbstractGeometryFieldMapper.Builder<AbstractGeometryFieldMapper.Builder,\n+            GeoShapeWithDocValuesFieldMapper> {\n+        public Builder(String name) {\n+            super (name, new GeoShapeWithDocValuesFieldType(), new GeoShapeWithDocValuesFieldType());\n+        }\n+\n+        @Override\n+        public GeoShapeWithDocValuesFieldMapper build(BuilderContext context) {\n+            setupFieldType(context);\n+            return new GeoShapeWithDocValuesFieldMapper(name, fieldType, defaultFieldType, ignoreMalformed(context), coerce(context),\n+                ignoreZValue(), docValues(), context.indexSettings(),\n+                multiFieldsBuilder.build(this, context), copyTo);\n+        }\n+\n+        @Override\n+        public boolean defaultDocValues(Version indexCreated) {\n+            return Version.V_8_0_0.onOrBefore(indexCreated);\n+        }\n+\n+        protected Explicit<Boolean> docValues() {\n+            if (docValuesSet && fieldType.hasDocValues()) {\n+                return new Explicit<>(true, true);\n+            } else if (docValuesSet) {\n+                return new Explicit<>(false, true);\n+            }\n+            return new Explicit<>(fieldType.hasDocValues(), false);\n+        }\n+\n+        protected void setupFieldType(BuilderContext context) {\n+            super.setupFieldType(context);\n+\n+            GeoShapeWithDocValuesFieldType fieldType = (GeoShapeWithDocValuesFieldType)fieldType();\n+            boolean orientation = fieldType.orientation() == ShapeBuilder.Orientation.RIGHT;\n+\n+            GeometryParser geometryParser = new GeometryParser(orientation, coerce(context).value(), ignoreZValue().value());\n+\n+            fieldType.setGeometryIndexer(new GeoShapeIndexer(orientation, fieldType.name()) {\n+                @Override\n+                public List<IndexableField> indexShape(ParseContext context, Geometry shape) {\n+                    List<IndexableField> fields = super.indexShape(context, shape);\n+                    if (fieldType().hasDocValues()) {\n+                        CentroidCalculator calculator = new CentroidCalculator(shape);\n+                        final byte[] scratch = new byte[7 * Integer.BYTES];\n+                        // doc values are generated from the indexed fields.\n+                        ShapeField.DecodedTriangle[] triangles = new ShapeField.DecodedTriangle[fields.size()];\n+                        for (int i = 0; i < fields.size(); i++) {\n+                            BytesRef bytesRef = fields.get(i).binaryValue();\n+                            assert bytesRef.length == 7 * Integer.BYTES;\n+                            System.arraycopy(bytesRef.bytes, bytesRef.offset, scratch, 0, 7 * Integer.BYTES);\n+                            ShapeField.decodeTriangle(scratch, triangles[i] = new ShapeField.DecodedTriangle());\n+                        }\n+                        BinaryGeoShapeDocValuesField docValuesField =\n+                            (BinaryGeoShapeDocValuesField) context.doc().getByKey(name);\n+                        if (docValuesField == null) {\n+                            docValuesField = new BinaryGeoShapeDocValuesField(name, triangles, calculator);\n+                            context.doc().addWithKey(name, docValuesField);\n+                        } else {\n+                            docValuesField.add(triangles, calculator);\n+                        }\n+                    }\n+                    return fields;\n+                }\n+            });\n+            fieldType.setGeometryParser( (parser, mapper) -> geometryParser.parse(parser));\n+            fieldType.setGeometryQueryBuilder(new VectorGeoShapeQueryProcessor());\n+        }\n+    }\n+\n+    public static final class GeoShapeWithDocValuesFieldType extends AbstractGeometryFieldType<Geometry, Geometry> {\n+        public GeoShapeWithDocValuesFieldType() {\n+            super();\n+        }\n+\n+        protected GeoShapeWithDocValuesFieldType(GeoShapeWithDocValuesFieldType ref) {\n+            super(ref);\n+        }\n+\n+        public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName) {\n+            failIfNoDocValues();\n+            return new AbstractLatLonShapeDVIndexFieldData.Builder();\n+        }\n+\n+        @Override\n+        public Query existsQuery(QueryShardContext context) {\n+            if (hasDocValues()) {\n+                return new DocValuesFieldExistsQuery(name());\n+            } else {\n+                return new TermQuery(new Term(FieldNamesFieldMapper.NAME, name()));\n+            }\n+        }\n+\n+        @Override\n+        public Query termQuery(Object value, QueryShardContext context) {\n+            throw new QueryShardException(context, \"Geo fields do not support exact searching, use dedicated geo queries instead: [\"\n+                + name() + \"]\");\n+        }\n+\n+        @Override\n+        public GeoShapeWithDocValuesFieldType clone() {\n+            return new GeoShapeWithDocValuesFieldType(this);\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return CONTENT_TYPE;\n+        }\n+    }\n+\n+    public static final class TypeParser extends AbstractGeometryFieldMapper.TypeParser {\n+\n+        @Override\n+        @SuppressWarnings(\"rawtypes\")\n+        protected AbstractGeometryFieldMapper.Builder newBuilder(String name, Map<String, Object> params) {\n+            if (params.containsKey(DEPRECATED_PARAMETERS_KEY)) {\n+                return new LegacyGeoShapeFieldMapper.Builder(name,\n+                    (LegacyGeoShapeFieldMapper.DeprecatedParameters)params.get(DEPRECATED_PARAMETERS_KEY));\n+            }\n+            return new GeoShapeWithDocValuesFieldMapper.Builder(name);\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"rawtypes\")\n+        public Mapper.Builder parse(String name, Map<String, Object> node, ParserContext parserContext) throws MapperParsingException {\n+            Map<String, Object> params = new HashMap<>();\n+            AbstractGeometryFieldMapper.Builder builder = (AbstractGeometryFieldMapper.Builder) super.parse(name, node, parserContext);\n+            for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(); iterator.hasNext();) {\n+                Map.Entry<String, Object> entry = iterator.next();\n+                String fieldName = entry.getKey();\n+                Object fieldNode = entry.getValue();\n+                if (TypeParsers.DOC_VALUES.equals(fieldName)) {\n+                    params.put(TypeParsers.DOC_VALUES, XContentMapValues.nodeBooleanValue(fieldNode, name + \".\" + TypeParsers.DOC_VALUES));\n+                    iterator.remove();\n+                }\n+            }\n+\n+            if (params.containsKey(TypeParsers.DOC_VALUES)) {\n+                builder.docValues((Boolean) params.get(TypeParsers.DOC_VALUES));\n+            }\n+            return builder;\n+        }\n+    }\n+\n+    public GeoShapeWithDocValuesFieldMapper(String simpleName, MappedFieldType fieldType, MappedFieldType defaultFieldType,\n+                                            Explicit<Boolean> ignoreMalformed, Explicit<Boolean> coerce,\n+                                            Explicit<Boolean> ignoreZValue, Explicit<Boolean> docValues, Settings indexSettings,\n+                                            MultiFields multiFields, CopyTo copyTo) {\n+        super(simpleName, fieldType, defaultFieldType, ignoreMalformed, coerce, ignoreZValue, indexSettings,\n+            multiFields, copyTo);\n+        this.docValues = docValues;\n+    }\n+\n+    @Override\n+    protected void doMerge(Mapper mergeWith) {\n+        if (mergeWith instanceof LegacyGeoShapeFieldMapper) {\n+            LegacyGeoShapeFieldMapper legacy = (LegacyGeoShapeFieldMapper) mergeWith;\n+            throw new IllegalArgumentException(\"[\" + fieldType().name() + \"] with field mapper [\" + fieldType().typeName() + \"] \" +\n+                \"using [BKD] strategy cannot be merged with \" + \"[\" + legacy.fieldType().typeName() + \"] with [\" +\n+                legacy.fieldType().strategy() + \"] strategy\");\n+        }\n+        super.doMerge(mergeWith);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY1MDA5MA=="}, "originalCommit": {"oid": "12d6a6cdd7b8adbc1bbf910efdfef7f18ef74591"}, "originalPosition": 241}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE0MjM4MQ==", "bodyText": "After speaking with the team, we came to the conclusion that since we do not have testing for it, we do not support flavor switches from one distribution to another. This is to mean that I should not need to support the scenario where one indexes documents with the geo-module GeoShapeFieldMapper.\nTo better understand the behavior, I did the following\n\nstart ES-OSS 8.0 and index one document with a geo_shape field (POINT (-77.03653 38.897676))\nrestart cluster in ES-Default 8.0\nindex new document (POINT(54.99, -10.89)) with geo_shape and run a geo_bounds aggregation and a query.\n\nQueries work well, the aggregation fails with the following exception:\n{\n    \"error\": {\n        \"root_cause\": [\n            {\n                \"type\": \"illegal_state_exception\",\n                \"reason\": \"unexpected docvalues type NONE for field 'location' (expected one of [BINARY, SORTED]). Re-index with correct docvalues type.\"\n            }\n        ],\n        \"type\": \"search_phase_execution_exception\",\n        \"reason\": \"all shards failed\",\n        \"phase\": \"query\",\n        \"grouped\": true,\n        \"failed_shards\": [\n            {\n                \"shard\": 0,\n                \"index\": \"example\",\n                \"node\": \"6ht3ufNbTR-mdcgSDu6ZGQ\",\n                \"reason\": {\n                    \"type\": \"illegal_state_exception\",\n                    \"reason\": \"unexpected docvalues type NONE for field 'location' (expected one of [BINARY, SORTED]). Re-index with correct docvalues type.\"\n                }\n            }\n        ],\n        \"caused_by\": {\n            \"type\": \"illegal_state_exception\",\n            \"reason\": \"unexpected docvalues type NONE for field 'location' (expected one of [BINARY, SORTED]). Re-index with correct docvalues type.\",\n            \"caused_by\": {\n                \"type\": \"illegal_state_exception\",\n                \"reason\": \"unexpected docvalues type NONE for field 'location' (expected one of [BINARY, SORTED]). Re-index with correct docvalues type.\"\n            }\n        }\n    },\n    \"status\": 500\n}\n\n\nI force-merge the index and re-run the aggregation and the aggregation succeeds with an aggregation over the documents that were indexed with doc-values and ignores those that don't have doc values fields.\n\n{\n    \"took\": 1,\n    \"timed_out\": false,\n    \"_shards\": {\n        \"total\": 1,\n        \"successful\": 1,\n        \"skipped\": 0,\n        \"failed\": 0\n    },\n    \"hits\": {\n        \"total\": {\n            \"value\": 2,\n            \"relation\": \"eq\"\n        },\n        \"max_score\": null,\n        \"hits\": []\n    },\n    \"aggregations\": {\n        \"viewport\": {\n            \"bounds\": {\n                \"top_left\": {\n                    \"lat\": -10.897000003606081,\n                    \"lon\": 54.999999990686774\n                },\n                \"bottom_right\": {\n                    \"lat\": -10.897000003606081,\n                    \"lon\": 54.999999990686774\n                }\n            }\n        }\n    }\n}\n\nSo, from my understanding, the merging is successful, but aggregations over geo_shape fields who have whole segments without any doc-values will fail.\ndoes this reflect your intuition?", "url": "https://github.com/elastic/elasticsearch/pull/55037#discussion_r409142381", "createdAt": "2020-04-15T21:24:03Z", "author": {"login": "talevy"}, "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/mapper/GeoShapeWithDocValuesFieldMapper.java", "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.spatial.index.mapper;\n+\n+import org.apache.lucene.document.LatLonShape;\n+import org.apache.lucene.document.ShapeField;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.DocValuesFieldExistsQuery;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.TermQuery;\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.Explicit;\n+import org.elasticsearch.common.geo.GeometryParser;\n+import org.elasticsearch.common.geo.builders.ShapeBuilder;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.support.XContentMapValues;\n+import org.elasticsearch.geometry.Geometry;\n+import org.elasticsearch.index.fielddata.IndexFieldData;\n+import org.elasticsearch.index.mapper.AbstractGeometryFieldMapper;\n+import org.elasticsearch.index.mapper.FieldNamesFieldMapper;\n+import org.elasticsearch.index.mapper.GeoShapeIndexer;\n+import org.elasticsearch.index.mapper.LegacyGeoShapeFieldMapper;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+import org.elasticsearch.index.mapper.Mapper;\n+import org.elasticsearch.index.mapper.MapperParsingException;\n+import org.elasticsearch.index.mapper.ParseContext;\n+import org.elasticsearch.index.mapper.TypeParsers;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.index.query.QueryShardException;\n+import org.elasticsearch.index.query.VectorGeoShapeQueryProcessor;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Extension of {@link org.elasticsearch.index.mapper.GeoShapeFieldMapper} that supports docValues\n+ *\n+ * FieldMapper for indexing {@link LatLonShape}s.\n+ * <p>\n+ * Currently Shapes can only be indexed and can only be queried using\n+ * {@link org.elasticsearch.index.query.GeoShapeQueryBuilder}, consequently\n+ * a lot of behavior in this Mapper is disabled.\n+ * <p>\n+ * Format supported:\n+ * <p>\n+ * \"field\" : {\n+ * \"type\" : \"polygon\",\n+ * \"coordinates\" : [\n+ * [ [100.0, 0.0], [101.0, 0.0], [101.0, 1.0], [100.0, 1.0], [100.0, 0.0] ]\n+ * ]\n+ * }\n+ * <p>\n+ * or:\n+ * <p>\n+ * \"field\" : \"POLYGON ((100.0 0.0, 101.0 0.0, 101.0 1.0, 100.0 1.0, 100.0 0.0))\n+ */\n+public class GeoShapeWithDocValuesFieldMapper extends AbstractGeometryFieldMapper<Geometry, Geometry> {\n+    public static final String CONTENT_TYPE = \"geo_shape\";\n+\n+\n+    private Explicit<Boolean> docValues;\n+\n+    @Override\n+    public void doXContentBody(XContentBuilder builder, boolean includeDefaults, Params params) throws IOException {\n+        super.doXContentBody(builder, includeDefaults, params);\n+        if (includeDefaults || docValues.explicit()) {\n+            builder.field(TypeParsers.DOC_VALUES, docValues.value());\n+        }\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    public static class Builder extends AbstractGeometryFieldMapper.Builder<AbstractGeometryFieldMapper.Builder,\n+            GeoShapeWithDocValuesFieldMapper> {\n+        public Builder(String name) {\n+            super (name, new GeoShapeWithDocValuesFieldType(), new GeoShapeWithDocValuesFieldType());\n+        }\n+\n+        @Override\n+        public GeoShapeWithDocValuesFieldMapper build(BuilderContext context) {\n+            setupFieldType(context);\n+            return new GeoShapeWithDocValuesFieldMapper(name, fieldType, defaultFieldType, ignoreMalformed(context), coerce(context),\n+                ignoreZValue(), docValues(), context.indexSettings(),\n+                multiFieldsBuilder.build(this, context), copyTo);\n+        }\n+\n+        @Override\n+        public boolean defaultDocValues(Version indexCreated) {\n+            return Version.V_8_0_0.onOrBefore(indexCreated);\n+        }\n+\n+        protected Explicit<Boolean> docValues() {\n+            if (docValuesSet && fieldType.hasDocValues()) {\n+                return new Explicit<>(true, true);\n+            } else if (docValuesSet) {\n+                return new Explicit<>(false, true);\n+            }\n+            return new Explicit<>(fieldType.hasDocValues(), false);\n+        }\n+\n+        protected void setupFieldType(BuilderContext context) {\n+            super.setupFieldType(context);\n+\n+            GeoShapeWithDocValuesFieldType fieldType = (GeoShapeWithDocValuesFieldType)fieldType();\n+            boolean orientation = fieldType.orientation() == ShapeBuilder.Orientation.RIGHT;\n+\n+            GeometryParser geometryParser = new GeometryParser(orientation, coerce(context).value(), ignoreZValue().value());\n+\n+            fieldType.setGeometryIndexer(new GeoShapeIndexer(orientation, fieldType.name()) {\n+                @Override\n+                public List<IndexableField> indexShape(ParseContext context, Geometry shape) {\n+                    List<IndexableField> fields = super.indexShape(context, shape);\n+                    if (fieldType().hasDocValues()) {\n+                        CentroidCalculator calculator = new CentroidCalculator(shape);\n+                        final byte[] scratch = new byte[7 * Integer.BYTES];\n+                        // doc values are generated from the indexed fields.\n+                        ShapeField.DecodedTriangle[] triangles = new ShapeField.DecodedTriangle[fields.size()];\n+                        for (int i = 0; i < fields.size(); i++) {\n+                            BytesRef bytesRef = fields.get(i).binaryValue();\n+                            assert bytesRef.length == 7 * Integer.BYTES;\n+                            System.arraycopy(bytesRef.bytes, bytesRef.offset, scratch, 0, 7 * Integer.BYTES);\n+                            ShapeField.decodeTriangle(scratch, triangles[i] = new ShapeField.DecodedTriangle());\n+                        }\n+                        BinaryGeoShapeDocValuesField docValuesField =\n+                            (BinaryGeoShapeDocValuesField) context.doc().getByKey(name);\n+                        if (docValuesField == null) {\n+                            docValuesField = new BinaryGeoShapeDocValuesField(name, triangles, calculator);\n+                            context.doc().addWithKey(name, docValuesField);\n+                        } else {\n+                            docValuesField.add(triangles, calculator);\n+                        }\n+                    }\n+                    return fields;\n+                }\n+            });\n+            fieldType.setGeometryParser( (parser, mapper) -> geometryParser.parse(parser));\n+            fieldType.setGeometryQueryBuilder(new VectorGeoShapeQueryProcessor());\n+        }\n+    }\n+\n+    public static final class GeoShapeWithDocValuesFieldType extends AbstractGeometryFieldType<Geometry, Geometry> {\n+        public GeoShapeWithDocValuesFieldType() {\n+            super();\n+        }\n+\n+        protected GeoShapeWithDocValuesFieldType(GeoShapeWithDocValuesFieldType ref) {\n+            super(ref);\n+        }\n+\n+        public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName) {\n+            failIfNoDocValues();\n+            return new AbstractLatLonShapeDVIndexFieldData.Builder();\n+        }\n+\n+        @Override\n+        public Query existsQuery(QueryShardContext context) {\n+            if (hasDocValues()) {\n+                return new DocValuesFieldExistsQuery(name());\n+            } else {\n+                return new TermQuery(new Term(FieldNamesFieldMapper.NAME, name()));\n+            }\n+        }\n+\n+        @Override\n+        public Query termQuery(Object value, QueryShardContext context) {\n+            throw new QueryShardException(context, \"Geo fields do not support exact searching, use dedicated geo queries instead: [\"\n+                + name() + \"]\");\n+        }\n+\n+        @Override\n+        public GeoShapeWithDocValuesFieldType clone() {\n+            return new GeoShapeWithDocValuesFieldType(this);\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return CONTENT_TYPE;\n+        }\n+    }\n+\n+    public static final class TypeParser extends AbstractGeometryFieldMapper.TypeParser {\n+\n+        @Override\n+        @SuppressWarnings(\"rawtypes\")\n+        protected AbstractGeometryFieldMapper.Builder newBuilder(String name, Map<String, Object> params) {\n+            if (params.containsKey(DEPRECATED_PARAMETERS_KEY)) {\n+                return new LegacyGeoShapeFieldMapper.Builder(name,\n+                    (LegacyGeoShapeFieldMapper.DeprecatedParameters)params.get(DEPRECATED_PARAMETERS_KEY));\n+            }\n+            return new GeoShapeWithDocValuesFieldMapper.Builder(name);\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"rawtypes\")\n+        public Mapper.Builder parse(String name, Map<String, Object> node, ParserContext parserContext) throws MapperParsingException {\n+            Map<String, Object> params = new HashMap<>();\n+            AbstractGeometryFieldMapper.Builder builder = (AbstractGeometryFieldMapper.Builder) super.parse(name, node, parserContext);\n+            for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(); iterator.hasNext();) {\n+                Map.Entry<String, Object> entry = iterator.next();\n+                String fieldName = entry.getKey();\n+                Object fieldNode = entry.getValue();\n+                if (TypeParsers.DOC_VALUES.equals(fieldName)) {\n+                    params.put(TypeParsers.DOC_VALUES, XContentMapValues.nodeBooleanValue(fieldNode, name + \".\" + TypeParsers.DOC_VALUES));\n+                    iterator.remove();\n+                }\n+            }\n+\n+            if (params.containsKey(TypeParsers.DOC_VALUES)) {\n+                builder.docValues((Boolean) params.get(TypeParsers.DOC_VALUES));\n+            }\n+            return builder;\n+        }\n+    }\n+\n+    public GeoShapeWithDocValuesFieldMapper(String simpleName, MappedFieldType fieldType, MappedFieldType defaultFieldType,\n+                                            Explicit<Boolean> ignoreMalformed, Explicit<Boolean> coerce,\n+                                            Explicit<Boolean> ignoreZValue, Explicit<Boolean> docValues, Settings indexSettings,\n+                                            MultiFields multiFields, CopyTo copyTo) {\n+        super(simpleName, fieldType, defaultFieldType, ignoreMalformed, coerce, ignoreZValue, indexSettings,\n+            multiFields, copyTo);\n+        this.docValues = docValues;\n+    }\n+\n+    @Override\n+    protected void doMerge(Mapper mergeWith) {\n+        if (mergeWith instanceof LegacyGeoShapeFieldMapper) {\n+            LegacyGeoShapeFieldMapper legacy = (LegacyGeoShapeFieldMapper) mergeWith;\n+            throw new IllegalArgumentException(\"[\" + fieldType().name() + \"] with field mapper [\" + fieldType().typeName() + \"] \" +\n+                \"using [BKD] strategy cannot be merged with \" + \"[\" + legacy.fieldType().typeName() + \"] with [\" +\n+                legacy.fieldType().strategy() + \"] strategy\");\n+        }\n+        super.doMerge(mergeWith);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY1MDA5MA=="}, "originalCommit": {"oid": "12d6a6cdd7b8adbc1bbf910efdfef7f18ef74591"}, "originalPosition": 241}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE1MjIxOQ==", "bodyText": "I've also changed the code such that there is more inherited from GeoShapeFieldMapper, so this copied merging code is no longer present", "url": "https://github.com/elastic/elasticsearch/pull/55037#discussion_r409152219", "createdAt": "2020-04-15T21:44:32Z", "author": {"login": "talevy"}, "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/mapper/GeoShapeWithDocValuesFieldMapper.java", "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.spatial.index.mapper;\n+\n+import org.apache.lucene.document.LatLonShape;\n+import org.apache.lucene.document.ShapeField;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.DocValuesFieldExistsQuery;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.TermQuery;\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.Explicit;\n+import org.elasticsearch.common.geo.GeometryParser;\n+import org.elasticsearch.common.geo.builders.ShapeBuilder;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.support.XContentMapValues;\n+import org.elasticsearch.geometry.Geometry;\n+import org.elasticsearch.index.fielddata.IndexFieldData;\n+import org.elasticsearch.index.mapper.AbstractGeometryFieldMapper;\n+import org.elasticsearch.index.mapper.FieldNamesFieldMapper;\n+import org.elasticsearch.index.mapper.GeoShapeIndexer;\n+import org.elasticsearch.index.mapper.LegacyGeoShapeFieldMapper;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+import org.elasticsearch.index.mapper.Mapper;\n+import org.elasticsearch.index.mapper.MapperParsingException;\n+import org.elasticsearch.index.mapper.ParseContext;\n+import org.elasticsearch.index.mapper.TypeParsers;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.index.query.QueryShardException;\n+import org.elasticsearch.index.query.VectorGeoShapeQueryProcessor;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Extension of {@link org.elasticsearch.index.mapper.GeoShapeFieldMapper} that supports docValues\n+ *\n+ * FieldMapper for indexing {@link LatLonShape}s.\n+ * <p>\n+ * Currently Shapes can only be indexed and can only be queried using\n+ * {@link org.elasticsearch.index.query.GeoShapeQueryBuilder}, consequently\n+ * a lot of behavior in this Mapper is disabled.\n+ * <p>\n+ * Format supported:\n+ * <p>\n+ * \"field\" : {\n+ * \"type\" : \"polygon\",\n+ * \"coordinates\" : [\n+ * [ [100.0, 0.0], [101.0, 0.0], [101.0, 1.0], [100.0, 1.0], [100.0, 0.0] ]\n+ * ]\n+ * }\n+ * <p>\n+ * or:\n+ * <p>\n+ * \"field\" : \"POLYGON ((100.0 0.0, 101.0 0.0, 101.0 1.0, 100.0 1.0, 100.0 0.0))\n+ */\n+public class GeoShapeWithDocValuesFieldMapper extends AbstractGeometryFieldMapper<Geometry, Geometry> {\n+    public static final String CONTENT_TYPE = \"geo_shape\";\n+\n+\n+    private Explicit<Boolean> docValues;\n+\n+    @Override\n+    public void doXContentBody(XContentBuilder builder, boolean includeDefaults, Params params) throws IOException {\n+        super.doXContentBody(builder, includeDefaults, params);\n+        if (includeDefaults || docValues.explicit()) {\n+            builder.field(TypeParsers.DOC_VALUES, docValues.value());\n+        }\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    public static class Builder extends AbstractGeometryFieldMapper.Builder<AbstractGeometryFieldMapper.Builder,\n+            GeoShapeWithDocValuesFieldMapper> {\n+        public Builder(String name) {\n+            super (name, new GeoShapeWithDocValuesFieldType(), new GeoShapeWithDocValuesFieldType());\n+        }\n+\n+        @Override\n+        public GeoShapeWithDocValuesFieldMapper build(BuilderContext context) {\n+            setupFieldType(context);\n+            return new GeoShapeWithDocValuesFieldMapper(name, fieldType, defaultFieldType, ignoreMalformed(context), coerce(context),\n+                ignoreZValue(), docValues(), context.indexSettings(),\n+                multiFieldsBuilder.build(this, context), copyTo);\n+        }\n+\n+        @Override\n+        public boolean defaultDocValues(Version indexCreated) {\n+            return Version.V_8_0_0.onOrBefore(indexCreated);\n+        }\n+\n+        protected Explicit<Boolean> docValues() {\n+            if (docValuesSet && fieldType.hasDocValues()) {\n+                return new Explicit<>(true, true);\n+            } else if (docValuesSet) {\n+                return new Explicit<>(false, true);\n+            }\n+            return new Explicit<>(fieldType.hasDocValues(), false);\n+        }\n+\n+        protected void setupFieldType(BuilderContext context) {\n+            super.setupFieldType(context);\n+\n+            GeoShapeWithDocValuesFieldType fieldType = (GeoShapeWithDocValuesFieldType)fieldType();\n+            boolean orientation = fieldType.orientation() == ShapeBuilder.Orientation.RIGHT;\n+\n+            GeometryParser geometryParser = new GeometryParser(orientation, coerce(context).value(), ignoreZValue().value());\n+\n+            fieldType.setGeometryIndexer(new GeoShapeIndexer(orientation, fieldType.name()) {\n+                @Override\n+                public List<IndexableField> indexShape(ParseContext context, Geometry shape) {\n+                    List<IndexableField> fields = super.indexShape(context, shape);\n+                    if (fieldType().hasDocValues()) {\n+                        CentroidCalculator calculator = new CentroidCalculator(shape);\n+                        final byte[] scratch = new byte[7 * Integer.BYTES];\n+                        // doc values are generated from the indexed fields.\n+                        ShapeField.DecodedTriangle[] triangles = new ShapeField.DecodedTriangle[fields.size()];\n+                        for (int i = 0; i < fields.size(); i++) {\n+                            BytesRef bytesRef = fields.get(i).binaryValue();\n+                            assert bytesRef.length == 7 * Integer.BYTES;\n+                            System.arraycopy(bytesRef.bytes, bytesRef.offset, scratch, 0, 7 * Integer.BYTES);\n+                            ShapeField.decodeTriangle(scratch, triangles[i] = new ShapeField.DecodedTriangle());\n+                        }\n+                        BinaryGeoShapeDocValuesField docValuesField =\n+                            (BinaryGeoShapeDocValuesField) context.doc().getByKey(name);\n+                        if (docValuesField == null) {\n+                            docValuesField = new BinaryGeoShapeDocValuesField(name, triangles, calculator);\n+                            context.doc().addWithKey(name, docValuesField);\n+                        } else {\n+                            docValuesField.add(triangles, calculator);\n+                        }\n+                    }\n+                    return fields;\n+                }\n+            });\n+            fieldType.setGeometryParser( (parser, mapper) -> geometryParser.parse(parser));\n+            fieldType.setGeometryQueryBuilder(new VectorGeoShapeQueryProcessor());\n+        }\n+    }\n+\n+    public static final class GeoShapeWithDocValuesFieldType extends AbstractGeometryFieldType<Geometry, Geometry> {\n+        public GeoShapeWithDocValuesFieldType() {\n+            super();\n+        }\n+\n+        protected GeoShapeWithDocValuesFieldType(GeoShapeWithDocValuesFieldType ref) {\n+            super(ref);\n+        }\n+\n+        public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName) {\n+            failIfNoDocValues();\n+            return new AbstractLatLonShapeDVIndexFieldData.Builder();\n+        }\n+\n+        @Override\n+        public Query existsQuery(QueryShardContext context) {\n+            if (hasDocValues()) {\n+                return new DocValuesFieldExistsQuery(name());\n+            } else {\n+                return new TermQuery(new Term(FieldNamesFieldMapper.NAME, name()));\n+            }\n+        }\n+\n+        @Override\n+        public Query termQuery(Object value, QueryShardContext context) {\n+            throw new QueryShardException(context, \"Geo fields do not support exact searching, use dedicated geo queries instead: [\"\n+                + name() + \"]\");\n+        }\n+\n+        @Override\n+        public GeoShapeWithDocValuesFieldType clone() {\n+            return new GeoShapeWithDocValuesFieldType(this);\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return CONTENT_TYPE;\n+        }\n+    }\n+\n+    public static final class TypeParser extends AbstractGeometryFieldMapper.TypeParser {\n+\n+        @Override\n+        @SuppressWarnings(\"rawtypes\")\n+        protected AbstractGeometryFieldMapper.Builder newBuilder(String name, Map<String, Object> params) {\n+            if (params.containsKey(DEPRECATED_PARAMETERS_KEY)) {\n+                return new LegacyGeoShapeFieldMapper.Builder(name,\n+                    (LegacyGeoShapeFieldMapper.DeprecatedParameters)params.get(DEPRECATED_PARAMETERS_KEY));\n+            }\n+            return new GeoShapeWithDocValuesFieldMapper.Builder(name);\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"rawtypes\")\n+        public Mapper.Builder parse(String name, Map<String, Object> node, ParserContext parserContext) throws MapperParsingException {\n+            Map<String, Object> params = new HashMap<>();\n+            AbstractGeometryFieldMapper.Builder builder = (AbstractGeometryFieldMapper.Builder) super.parse(name, node, parserContext);\n+            for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(); iterator.hasNext();) {\n+                Map.Entry<String, Object> entry = iterator.next();\n+                String fieldName = entry.getKey();\n+                Object fieldNode = entry.getValue();\n+                if (TypeParsers.DOC_VALUES.equals(fieldName)) {\n+                    params.put(TypeParsers.DOC_VALUES, XContentMapValues.nodeBooleanValue(fieldNode, name + \".\" + TypeParsers.DOC_VALUES));\n+                    iterator.remove();\n+                }\n+            }\n+\n+            if (params.containsKey(TypeParsers.DOC_VALUES)) {\n+                builder.docValues((Boolean) params.get(TypeParsers.DOC_VALUES));\n+            }\n+            return builder;\n+        }\n+    }\n+\n+    public GeoShapeWithDocValuesFieldMapper(String simpleName, MappedFieldType fieldType, MappedFieldType defaultFieldType,\n+                                            Explicit<Boolean> ignoreMalformed, Explicit<Boolean> coerce,\n+                                            Explicit<Boolean> ignoreZValue, Explicit<Boolean> docValues, Settings indexSettings,\n+                                            MultiFields multiFields, CopyTo copyTo) {\n+        super(simpleName, fieldType, defaultFieldType, ignoreMalformed, coerce, ignoreZValue, indexSettings,\n+            multiFields, copyTo);\n+        this.docValues = docValues;\n+    }\n+\n+    @Override\n+    protected void doMerge(Mapper mergeWith) {\n+        if (mergeWith instanceof LegacyGeoShapeFieldMapper) {\n+            LegacyGeoShapeFieldMapper legacy = (LegacyGeoShapeFieldMapper) mergeWith;\n+            throw new IllegalArgumentException(\"[\" + fieldType().name() + \"] with field mapper [\" + fieldType().typeName() + \"] \" +\n+                \"using [BKD] strategy cannot be merged with \" + \"[\" + legacy.fieldType().typeName() + \"] with [\" +\n+                legacy.fieldType().strategy() + \"] strategy\");\n+        }\n+        super.doMerge(mergeWith);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY1MDA5MA=="}, "originalCommit": {"oid": "12d6a6cdd7b8adbc1bbf910efdfef7f18ef74591"}, "originalPosition": 241}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTU0MTczMQ==", "bodyText": "umm, I was expecting the geo_shape field to have docvalues == false so even if you index one more point, it should not generate doc values. In that sense a user would need to reindex the data from OSS to Default distribution in order to have doc values.", "url": "https://github.com/elastic/elasticsearch/pull/55037#discussion_r409541731", "createdAt": "2020-04-16T13:08:58Z", "author": {"login": "iverase"}, "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/mapper/GeoShapeWithDocValuesFieldMapper.java", "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.spatial.index.mapper;\n+\n+import org.apache.lucene.document.LatLonShape;\n+import org.apache.lucene.document.ShapeField;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.DocValuesFieldExistsQuery;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.TermQuery;\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.Explicit;\n+import org.elasticsearch.common.geo.GeometryParser;\n+import org.elasticsearch.common.geo.builders.ShapeBuilder;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.support.XContentMapValues;\n+import org.elasticsearch.geometry.Geometry;\n+import org.elasticsearch.index.fielddata.IndexFieldData;\n+import org.elasticsearch.index.mapper.AbstractGeometryFieldMapper;\n+import org.elasticsearch.index.mapper.FieldNamesFieldMapper;\n+import org.elasticsearch.index.mapper.GeoShapeIndexer;\n+import org.elasticsearch.index.mapper.LegacyGeoShapeFieldMapper;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+import org.elasticsearch.index.mapper.Mapper;\n+import org.elasticsearch.index.mapper.MapperParsingException;\n+import org.elasticsearch.index.mapper.ParseContext;\n+import org.elasticsearch.index.mapper.TypeParsers;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.index.query.QueryShardException;\n+import org.elasticsearch.index.query.VectorGeoShapeQueryProcessor;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Extension of {@link org.elasticsearch.index.mapper.GeoShapeFieldMapper} that supports docValues\n+ *\n+ * FieldMapper for indexing {@link LatLonShape}s.\n+ * <p>\n+ * Currently Shapes can only be indexed and can only be queried using\n+ * {@link org.elasticsearch.index.query.GeoShapeQueryBuilder}, consequently\n+ * a lot of behavior in this Mapper is disabled.\n+ * <p>\n+ * Format supported:\n+ * <p>\n+ * \"field\" : {\n+ * \"type\" : \"polygon\",\n+ * \"coordinates\" : [\n+ * [ [100.0, 0.0], [101.0, 0.0], [101.0, 1.0], [100.0, 1.0], [100.0, 0.0] ]\n+ * ]\n+ * }\n+ * <p>\n+ * or:\n+ * <p>\n+ * \"field\" : \"POLYGON ((100.0 0.0, 101.0 0.0, 101.0 1.0, 100.0 1.0, 100.0 0.0))\n+ */\n+public class GeoShapeWithDocValuesFieldMapper extends AbstractGeometryFieldMapper<Geometry, Geometry> {\n+    public static final String CONTENT_TYPE = \"geo_shape\";\n+\n+\n+    private Explicit<Boolean> docValues;\n+\n+    @Override\n+    public void doXContentBody(XContentBuilder builder, boolean includeDefaults, Params params) throws IOException {\n+        super.doXContentBody(builder, includeDefaults, params);\n+        if (includeDefaults || docValues.explicit()) {\n+            builder.field(TypeParsers.DOC_VALUES, docValues.value());\n+        }\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    public static class Builder extends AbstractGeometryFieldMapper.Builder<AbstractGeometryFieldMapper.Builder,\n+            GeoShapeWithDocValuesFieldMapper> {\n+        public Builder(String name) {\n+            super (name, new GeoShapeWithDocValuesFieldType(), new GeoShapeWithDocValuesFieldType());\n+        }\n+\n+        @Override\n+        public GeoShapeWithDocValuesFieldMapper build(BuilderContext context) {\n+            setupFieldType(context);\n+            return new GeoShapeWithDocValuesFieldMapper(name, fieldType, defaultFieldType, ignoreMalformed(context), coerce(context),\n+                ignoreZValue(), docValues(), context.indexSettings(),\n+                multiFieldsBuilder.build(this, context), copyTo);\n+        }\n+\n+        @Override\n+        public boolean defaultDocValues(Version indexCreated) {\n+            return Version.V_8_0_0.onOrBefore(indexCreated);\n+        }\n+\n+        protected Explicit<Boolean> docValues() {\n+            if (docValuesSet && fieldType.hasDocValues()) {\n+                return new Explicit<>(true, true);\n+            } else if (docValuesSet) {\n+                return new Explicit<>(false, true);\n+            }\n+            return new Explicit<>(fieldType.hasDocValues(), false);\n+        }\n+\n+        protected void setupFieldType(BuilderContext context) {\n+            super.setupFieldType(context);\n+\n+            GeoShapeWithDocValuesFieldType fieldType = (GeoShapeWithDocValuesFieldType)fieldType();\n+            boolean orientation = fieldType.orientation() == ShapeBuilder.Orientation.RIGHT;\n+\n+            GeometryParser geometryParser = new GeometryParser(orientation, coerce(context).value(), ignoreZValue().value());\n+\n+            fieldType.setGeometryIndexer(new GeoShapeIndexer(orientation, fieldType.name()) {\n+                @Override\n+                public List<IndexableField> indexShape(ParseContext context, Geometry shape) {\n+                    List<IndexableField> fields = super.indexShape(context, shape);\n+                    if (fieldType().hasDocValues()) {\n+                        CentroidCalculator calculator = new CentroidCalculator(shape);\n+                        final byte[] scratch = new byte[7 * Integer.BYTES];\n+                        // doc values are generated from the indexed fields.\n+                        ShapeField.DecodedTriangle[] triangles = new ShapeField.DecodedTriangle[fields.size()];\n+                        for (int i = 0; i < fields.size(); i++) {\n+                            BytesRef bytesRef = fields.get(i).binaryValue();\n+                            assert bytesRef.length == 7 * Integer.BYTES;\n+                            System.arraycopy(bytesRef.bytes, bytesRef.offset, scratch, 0, 7 * Integer.BYTES);\n+                            ShapeField.decodeTriangle(scratch, triangles[i] = new ShapeField.DecodedTriangle());\n+                        }\n+                        BinaryGeoShapeDocValuesField docValuesField =\n+                            (BinaryGeoShapeDocValuesField) context.doc().getByKey(name);\n+                        if (docValuesField == null) {\n+                            docValuesField = new BinaryGeoShapeDocValuesField(name, triangles, calculator);\n+                            context.doc().addWithKey(name, docValuesField);\n+                        } else {\n+                            docValuesField.add(triangles, calculator);\n+                        }\n+                    }\n+                    return fields;\n+                }\n+            });\n+            fieldType.setGeometryParser( (parser, mapper) -> geometryParser.parse(parser));\n+            fieldType.setGeometryQueryBuilder(new VectorGeoShapeQueryProcessor());\n+        }\n+    }\n+\n+    public static final class GeoShapeWithDocValuesFieldType extends AbstractGeometryFieldType<Geometry, Geometry> {\n+        public GeoShapeWithDocValuesFieldType() {\n+            super();\n+        }\n+\n+        protected GeoShapeWithDocValuesFieldType(GeoShapeWithDocValuesFieldType ref) {\n+            super(ref);\n+        }\n+\n+        public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName) {\n+            failIfNoDocValues();\n+            return new AbstractLatLonShapeDVIndexFieldData.Builder();\n+        }\n+\n+        @Override\n+        public Query existsQuery(QueryShardContext context) {\n+            if (hasDocValues()) {\n+                return new DocValuesFieldExistsQuery(name());\n+            } else {\n+                return new TermQuery(new Term(FieldNamesFieldMapper.NAME, name()));\n+            }\n+        }\n+\n+        @Override\n+        public Query termQuery(Object value, QueryShardContext context) {\n+            throw new QueryShardException(context, \"Geo fields do not support exact searching, use dedicated geo queries instead: [\"\n+                + name() + \"]\");\n+        }\n+\n+        @Override\n+        public GeoShapeWithDocValuesFieldType clone() {\n+            return new GeoShapeWithDocValuesFieldType(this);\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return CONTENT_TYPE;\n+        }\n+    }\n+\n+    public static final class TypeParser extends AbstractGeometryFieldMapper.TypeParser {\n+\n+        @Override\n+        @SuppressWarnings(\"rawtypes\")\n+        protected AbstractGeometryFieldMapper.Builder newBuilder(String name, Map<String, Object> params) {\n+            if (params.containsKey(DEPRECATED_PARAMETERS_KEY)) {\n+                return new LegacyGeoShapeFieldMapper.Builder(name,\n+                    (LegacyGeoShapeFieldMapper.DeprecatedParameters)params.get(DEPRECATED_PARAMETERS_KEY));\n+            }\n+            return new GeoShapeWithDocValuesFieldMapper.Builder(name);\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"rawtypes\")\n+        public Mapper.Builder parse(String name, Map<String, Object> node, ParserContext parserContext) throws MapperParsingException {\n+            Map<String, Object> params = new HashMap<>();\n+            AbstractGeometryFieldMapper.Builder builder = (AbstractGeometryFieldMapper.Builder) super.parse(name, node, parserContext);\n+            for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(); iterator.hasNext();) {\n+                Map.Entry<String, Object> entry = iterator.next();\n+                String fieldName = entry.getKey();\n+                Object fieldNode = entry.getValue();\n+                if (TypeParsers.DOC_VALUES.equals(fieldName)) {\n+                    params.put(TypeParsers.DOC_VALUES, XContentMapValues.nodeBooleanValue(fieldNode, name + \".\" + TypeParsers.DOC_VALUES));\n+                    iterator.remove();\n+                }\n+            }\n+\n+            if (params.containsKey(TypeParsers.DOC_VALUES)) {\n+                builder.docValues((Boolean) params.get(TypeParsers.DOC_VALUES));\n+            }\n+            return builder;\n+        }\n+    }\n+\n+    public GeoShapeWithDocValuesFieldMapper(String simpleName, MappedFieldType fieldType, MappedFieldType defaultFieldType,\n+                                            Explicit<Boolean> ignoreMalformed, Explicit<Boolean> coerce,\n+                                            Explicit<Boolean> ignoreZValue, Explicit<Boolean> docValues, Settings indexSettings,\n+                                            MultiFields multiFields, CopyTo copyTo) {\n+        super(simpleName, fieldType, defaultFieldType, ignoreMalformed, coerce, ignoreZValue, indexSettings,\n+            multiFields, copyTo);\n+        this.docValues = docValues;\n+    }\n+\n+    @Override\n+    protected void doMerge(Mapper mergeWith) {\n+        if (mergeWith instanceof LegacyGeoShapeFieldMapper) {\n+            LegacyGeoShapeFieldMapper legacy = (LegacyGeoShapeFieldMapper) mergeWith;\n+            throw new IllegalArgumentException(\"[\" + fieldType().name() + \"] with field mapper [\" + fieldType().typeName() + \"] \" +\n+                \"using [BKD] strategy cannot be merged with \" + \"[\" + legacy.fieldType().typeName() + \"] with [\" +\n+                legacy.fieldType().strategy() + \"] strategy\");\n+        }\n+        super.doMerge(mergeWith);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY1MDA5MA=="}, "originalCommit": {"oid": "12d6a6cdd7b8adbc1bbf910efdfef7f18ef74591"}, "originalPosition": 241}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTYxOTUzOA==", "bodyText": "The intention is to have doc-values default to true. This presents a problem for existing indices since we cannot determine whether an index of a specific version was created using the OSS geo_shape field or the Default one.\nThat is why I asked whether we support the switching-flavors case. It is an inconvenient behavior that I'm happy to discuss further. It is just that a lack of the doc-values field implies that the default should be respected, which is true.\nOne solution is to not have an implicit doc-values setting, and always inject the parameter into a newly created mapping. that way if it is not present, it can be assumed to be false. It is slightly different from the existing behavior of Explicit settings.", "url": "https://github.com/elastic/elasticsearch/pull/55037#discussion_r409619538", "createdAt": "2020-04-16T14:50:57Z", "author": {"login": "talevy"}, "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/mapper/GeoShapeWithDocValuesFieldMapper.java", "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.spatial.index.mapper;\n+\n+import org.apache.lucene.document.LatLonShape;\n+import org.apache.lucene.document.ShapeField;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.DocValuesFieldExistsQuery;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.TermQuery;\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.Explicit;\n+import org.elasticsearch.common.geo.GeometryParser;\n+import org.elasticsearch.common.geo.builders.ShapeBuilder;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.support.XContentMapValues;\n+import org.elasticsearch.geometry.Geometry;\n+import org.elasticsearch.index.fielddata.IndexFieldData;\n+import org.elasticsearch.index.mapper.AbstractGeometryFieldMapper;\n+import org.elasticsearch.index.mapper.FieldNamesFieldMapper;\n+import org.elasticsearch.index.mapper.GeoShapeIndexer;\n+import org.elasticsearch.index.mapper.LegacyGeoShapeFieldMapper;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+import org.elasticsearch.index.mapper.Mapper;\n+import org.elasticsearch.index.mapper.MapperParsingException;\n+import org.elasticsearch.index.mapper.ParseContext;\n+import org.elasticsearch.index.mapper.TypeParsers;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.index.query.QueryShardException;\n+import org.elasticsearch.index.query.VectorGeoShapeQueryProcessor;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Extension of {@link org.elasticsearch.index.mapper.GeoShapeFieldMapper} that supports docValues\n+ *\n+ * FieldMapper for indexing {@link LatLonShape}s.\n+ * <p>\n+ * Currently Shapes can only be indexed and can only be queried using\n+ * {@link org.elasticsearch.index.query.GeoShapeQueryBuilder}, consequently\n+ * a lot of behavior in this Mapper is disabled.\n+ * <p>\n+ * Format supported:\n+ * <p>\n+ * \"field\" : {\n+ * \"type\" : \"polygon\",\n+ * \"coordinates\" : [\n+ * [ [100.0, 0.0], [101.0, 0.0], [101.0, 1.0], [100.0, 1.0], [100.0, 0.0] ]\n+ * ]\n+ * }\n+ * <p>\n+ * or:\n+ * <p>\n+ * \"field\" : \"POLYGON ((100.0 0.0, 101.0 0.0, 101.0 1.0, 100.0 1.0, 100.0 0.0))\n+ */\n+public class GeoShapeWithDocValuesFieldMapper extends AbstractGeometryFieldMapper<Geometry, Geometry> {\n+    public static final String CONTENT_TYPE = \"geo_shape\";\n+\n+\n+    private Explicit<Boolean> docValues;\n+\n+    @Override\n+    public void doXContentBody(XContentBuilder builder, boolean includeDefaults, Params params) throws IOException {\n+        super.doXContentBody(builder, includeDefaults, params);\n+        if (includeDefaults || docValues.explicit()) {\n+            builder.field(TypeParsers.DOC_VALUES, docValues.value());\n+        }\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    public static class Builder extends AbstractGeometryFieldMapper.Builder<AbstractGeometryFieldMapper.Builder,\n+            GeoShapeWithDocValuesFieldMapper> {\n+        public Builder(String name) {\n+            super (name, new GeoShapeWithDocValuesFieldType(), new GeoShapeWithDocValuesFieldType());\n+        }\n+\n+        @Override\n+        public GeoShapeWithDocValuesFieldMapper build(BuilderContext context) {\n+            setupFieldType(context);\n+            return new GeoShapeWithDocValuesFieldMapper(name, fieldType, defaultFieldType, ignoreMalformed(context), coerce(context),\n+                ignoreZValue(), docValues(), context.indexSettings(),\n+                multiFieldsBuilder.build(this, context), copyTo);\n+        }\n+\n+        @Override\n+        public boolean defaultDocValues(Version indexCreated) {\n+            return Version.V_8_0_0.onOrBefore(indexCreated);\n+        }\n+\n+        protected Explicit<Boolean> docValues() {\n+            if (docValuesSet && fieldType.hasDocValues()) {\n+                return new Explicit<>(true, true);\n+            } else if (docValuesSet) {\n+                return new Explicit<>(false, true);\n+            }\n+            return new Explicit<>(fieldType.hasDocValues(), false);\n+        }\n+\n+        protected void setupFieldType(BuilderContext context) {\n+            super.setupFieldType(context);\n+\n+            GeoShapeWithDocValuesFieldType fieldType = (GeoShapeWithDocValuesFieldType)fieldType();\n+            boolean orientation = fieldType.orientation() == ShapeBuilder.Orientation.RIGHT;\n+\n+            GeometryParser geometryParser = new GeometryParser(orientation, coerce(context).value(), ignoreZValue().value());\n+\n+            fieldType.setGeometryIndexer(new GeoShapeIndexer(orientation, fieldType.name()) {\n+                @Override\n+                public List<IndexableField> indexShape(ParseContext context, Geometry shape) {\n+                    List<IndexableField> fields = super.indexShape(context, shape);\n+                    if (fieldType().hasDocValues()) {\n+                        CentroidCalculator calculator = new CentroidCalculator(shape);\n+                        final byte[] scratch = new byte[7 * Integer.BYTES];\n+                        // doc values are generated from the indexed fields.\n+                        ShapeField.DecodedTriangle[] triangles = new ShapeField.DecodedTriangle[fields.size()];\n+                        for (int i = 0; i < fields.size(); i++) {\n+                            BytesRef bytesRef = fields.get(i).binaryValue();\n+                            assert bytesRef.length == 7 * Integer.BYTES;\n+                            System.arraycopy(bytesRef.bytes, bytesRef.offset, scratch, 0, 7 * Integer.BYTES);\n+                            ShapeField.decodeTriangle(scratch, triangles[i] = new ShapeField.DecodedTriangle());\n+                        }\n+                        BinaryGeoShapeDocValuesField docValuesField =\n+                            (BinaryGeoShapeDocValuesField) context.doc().getByKey(name);\n+                        if (docValuesField == null) {\n+                            docValuesField = new BinaryGeoShapeDocValuesField(name, triangles, calculator);\n+                            context.doc().addWithKey(name, docValuesField);\n+                        } else {\n+                            docValuesField.add(triangles, calculator);\n+                        }\n+                    }\n+                    return fields;\n+                }\n+            });\n+            fieldType.setGeometryParser( (parser, mapper) -> geometryParser.parse(parser));\n+            fieldType.setGeometryQueryBuilder(new VectorGeoShapeQueryProcessor());\n+        }\n+    }\n+\n+    public static final class GeoShapeWithDocValuesFieldType extends AbstractGeometryFieldType<Geometry, Geometry> {\n+        public GeoShapeWithDocValuesFieldType() {\n+            super();\n+        }\n+\n+        protected GeoShapeWithDocValuesFieldType(GeoShapeWithDocValuesFieldType ref) {\n+            super(ref);\n+        }\n+\n+        public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName) {\n+            failIfNoDocValues();\n+            return new AbstractLatLonShapeDVIndexFieldData.Builder();\n+        }\n+\n+        @Override\n+        public Query existsQuery(QueryShardContext context) {\n+            if (hasDocValues()) {\n+                return new DocValuesFieldExistsQuery(name());\n+            } else {\n+                return new TermQuery(new Term(FieldNamesFieldMapper.NAME, name()));\n+            }\n+        }\n+\n+        @Override\n+        public Query termQuery(Object value, QueryShardContext context) {\n+            throw new QueryShardException(context, \"Geo fields do not support exact searching, use dedicated geo queries instead: [\"\n+                + name() + \"]\");\n+        }\n+\n+        @Override\n+        public GeoShapeWithDocValuesFieldType clone() {\n+            return new GeoShapeWithDocValuesFieldType(this);\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return CONTENT_TYPE;\n+        }\n+    }\n+\n+    public static final class TypeParser extends AbstractGeometryFieldMapper.TypeParser {\n+\n+        @Override\n+        @SuppressWarnings(\"rawtypes\")\n+        protected AbstractGeometryFieldMapper.Builder newBuilder(String name, Map<String, Object> params) {\n+            if (params.containsKey(DEPRECATED_PARAMETERS_KEY)) {\n+                return new LegacyGeoShapeFieldMapper.Builder(name,\n+                    (LegacyGeoShapeFieldMapper.DeprecatedParameters)params.get(DEPRECATED_PARAMETERS_KEY));\n+            }\n+            return new GeoShapeWithDocValuesFieldMapper.Builder(name);\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"rawtypes\")\n+        public Mapper.Builder parse(String name, Map<String, Object> node, ParserContext parserContext) throws MapperParsingException {\n+            Map<String, Object> params = new HashMap<>();\n+            AbstractGeometryFieldMapper.Builder builder = (AbstractGeometryFieldMapper.Builder) super.parse(name, node, parserContext);\n+            for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(); iterator.hasNext();) {\n+                Map.Entry<String, Object> entry = iterator.next();\n+                String fieldName = entry.getKey();\n+                Object fieldNode = entry.getValue();\n+                if (TypeParsers.DOC_VALUES.equals(fieldName)) {\n+                    params.put(TypeParsers.DOC_VALUES, XContentMapValues.nodeBooleanValue(fieldNode, name + \".\" + TypeParsers.DOC_VALUES));\n+                    iterator.remove();\n+                }\n+            }\n+\n+            if (params.containsKey(TypeParsers.DOC_VALUES)) {\n+                builder.docValues((Boolean) params.get(TypeParsers.DOC_VALUES));\n+            }\n+            return builder;\n+        }\n+    }\n+\n+    public GeoShapeWithDocValuesFieldMapper(String simpleName, MappedFieldType fieldType, MappedFieldType defaultFieldType,\n+                                            Explicit<Boolean> ignoreMalformed, Explicit<Boolean> coerce,\n+                                            Explicit<Boolean> ignoreZValue, Explicit<Boolean> docValues, Settings indexSettings,\n+                                            MultiFields multiFields, CopyTo copyTo) {\n+        super(simpleName, fieldType, defaultFieldType, ignoreMalformed, coerce, ignoreZValue, indexSettings,\n+            multiFields, copyTo);\n+        this.docValues = docValues;\n+    }\n+\n+    @Override\n+    protected void doMerge(Mapper mergeWith) {\n+        if (mergeWith instanceof LegacyGeoShapeFieldMapper) {\n+            LegacyGeoShapeFieldMapper legacy = (LegacyGeoShapeFieldMapper) mergeWith;\n+            throw new IllegalArgumentException(\"[\" + fieldType().name() + \"] with field mapper [\" + fieldType().typeName() + \"] \" +\n+                \"using [BKD] strategy cannot be merged with \" + \"[\" + legacy.fieldType().typeName() + \"] with [\" +\n+                legacy.fieldType().strategy() + \"] strategy\");\n+        }\n+        super.doMerge(mergeWith);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY1MDA5MA=="}, "originalCommit": {"oid": "12d6a6cdd7b8adbc1bbf910efdfef7f18ef74591"}, "originalPosition": 241}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY0Mzg3NA==", "bodyText": "I discuss this with Tal offline and we agree this behaviour is acceptable as we do not really support moving from OSS to Default distribution. The recommendation to users would be to reindex in the case they want to run aggregations.", "url": "https://github.com/elastic/elasticsearch/pull/55037#discussion_r409643874", "createdAt": "2020-04-16T15:22:54Z", "author": {"login": "iverase"}, "path": "x-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/index/mapper/GeoShapeWithDocValuesFieldMapper.java", "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.spatial.index.mapper;\n+\n+import org.apache.lucene.document.LatLonShape;\n+import org.apache.lucene.document.ShapeField;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.DocValuesFieldExistsQuery;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.TermQuery;\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.Explicit;\n+import org.elasticsearch.common.geo.GeometryParser;\n+import org.elasticsearch.common.geo.builders.ShapeBuilder;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.support.XContentMapValues;\n+import org.elasticsearch.geometry.Geometry;\n+import org.elasticsearch.index.fielddata.IndexFieldData;\n+import org.elasticsearch.index.mapper.AbstractGeometryFieldMapper;\n+import org.elasticsearch.index.mapper.FieldNamesFieldMapper;\n+import org.elasticsearch.index.mapper.GeoShapeIndexer;\n+import org.elasticsearch.index.mapper.LegacyGeoShapeFieldMapper;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+import org.elasticsearch.index.mapper.Mapper;\n+import org.elasticsearch.index.mapper.MapperParsingException;\n+import org.elasticsearch.index.mapper.ParseContext;\n+import org.elasticsearch.index.mapper.TypeParsers;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.index.query.QueryShardException;\n+import org.elasticsearch.index.query.VectorGeoShapeQueryProcessor;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Extension of {@link org.elasticsearch.index.mapper.GeoShapeFieldMapper} that supports docValues\n+ *\n+ * FieldMapper for indexing {@link LatLonShape}s.\n+ * <p>\n+ * Currently Shapes can only be indexed and can only be queried using\n+ * {@link org.elasticsearch.index.query.GeoShapeQueryBuilder}, consequently\n+ * a lot of behavior in this Mapper is disabled.\n+ * <p>\n+ * Format supported:\n+ * <p>\n+ * \"field\" : {\n+ * \"type\" : \"polygon\",\n+ * \"coordinates\" : [\n+ * [ [100.0, 0.0], [101.0, 0.0], [101.0, 1.0], [100.0, 1.0], [100.0, 0.0] ]\n+ * ]\n+ * }\n+ * <p>\n+ * or:\n+ * <p>\n+ * \"field\" : \"POLYGON ((100.0 0.0, 101.0 0.0, 101.0 1.0, 100.0 1.0, 100.0 0.0))\n+ */\n+public class GeoShapeWithDocValuesFieldMapper extends AbstractGeometryFieldMapper<Geometry, Geometry> {\n+    public static final String CONTENT_TYPE = \"geo_shape\";\n+\n+\n+    private Explicit<Boolean> docValues;\n+\n+    @Override\n+    public void doXContentBody(XContentBuilder builder, boolean includeDefaults, Params params) throws IOException {\n+        super.doXContentBody(builder, includeDefaults, params);\n+        if (includeDefaults || docValues.explicit()) {\n+            builder.field(TypeParsers.DOC_VALUES, docValues.value());\n+        }\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    public static class Builder extends AbstractGeometryFieldMapper.Builder<AbstractGeometryFieldMapper.Builder,\n+            GeoShapeWithDocValuesFieldMapper> {\n+        public Builder(String name) {\n+            super (name, new GeoShapeWithDocValuesFieldType(), new GeoShapeWithDocValuesFieldType());\n+        }\n+\n+        @Override\n+        public GeoShapeWithDocValuesFieldMapper build(BuilderContext context) {\n+            setupFieldType(context);\n+            return new GeoShapeWithDocValuesFieldMapper(name, fieldType, defaultFieldType, ignoreMalformed(context), coerce(context),\n+                ignoreZValue(), docValues(), context.indexSettings(),\n+                multiFieldsBuilder.build(this, context), copyTo);\n+        }\n+\n+        @Override\n+        public boolean defaultDocValues(Version indexCreated) {\n+            return Version.V_8_0_0.onOrBefore(indexCreated);\n+        }\n+\n+        protected Explicit<Boolean> docValues() {\n+            if (docValuesSet && fieldType.hasDocValues()) {\n+                return new Explicit<>(true, true);\n+            } else if (docValuesSet) {\n+                return new Explicit<>(false, true);\n+            }\n+            return new Explicit<>(fieldType.hasDocValues(), false);\n+        }\n+\n+        protected void setupFieldType(BuilderContext context) {\n+            super.setupFieldType(context);\n+\n+            GeoShapeWithDocValuesFieldType fieldType = (GeoShapeWithDocValuesFieldType)fieldType();\n+            boolean orientation = fieldType.orientation() == ShapeBuilder.Orientation.RIGHT;\n+\n+            GeometryParser geometryParser = new GeometryParser(orientation, coerce(context).value(), ignoreZValue().value());\n+\n+            fieldType.setGeometryIndexer(new GeoShapeIndexer(orientation, fieldType.name()) {\n+                @Override\n+                public List<IndexableField> indexShape(ParseContext context, Geometry shape) {\n+                    List<IndexableField> fields = super.indexShape(context, shape);\n+                    if (fieldType().hasDocValues()) {\n+                        CentroidCalculator calculator = new CentroidCalculator(shape);\n+                        final byte[] scratch = new byte[7 * Integer.BYTES];\n+                        // doc values are generated from the indexed fields.\n+                        ShapeField.DecodedTriangle[] triangles = new ShapeField.DecodedTriangle[fields.size()];\n+                        for (int i = 0; i < fields.size(); i++) {\n+                            BytesRef bytesRef = fields.get(i).binaryValue();\n+                            assert bytesRef.length == 7 * Integer.BYTES;\n+                            System.arraycopy(bytesRef.bytes, bytesRef.offset, scratch, 0, 7 * Integer.BYTES);\n+                            ShapeField.decodeTriangle(scratch, triangles[i] = new ShapeField.DecodedTriangle());\n+                        }\n+                        BinaryGeoShapeDocValuesField docValuesField =\n+                            (BinaryGeoShapeDocValuesField) context.doc().getByKey(name);\n+                        if (docValuesField == null) {\n+                            docValuesField = new BinaryGeoShapeDocValuesField(name, triangles, calculator);\n+                            context.doc().addWithKey(name, docValuesField);\n+                        } else {\n+                            docValuesField.add(triangles, calculator);\n+                        }\n+                    }\n+                    return fields;\n+                }\n+            });\n+            fieldType.setGeometryParser( (parser, mapper) -> geometryParser.parse(parser));\n+            fieldType.setGeometryQueryBuilder(new VectorGeoShapeQueryProcessor());\n+        }\n+    }\n+\n+    public static final class GeoShapeWithDocValuesFieldType extends AbstractGeometryFieldType<Geometry, Geometry> {\n+        public GeoShapeWithDocValuesFieldType() {\n+            super();\n+        }\n+\n+        protected GeoShapeWithDocValuesFieldType(GeoShapeWithDocValuesFieldType ref) {\n+            super(ref);\n+        }\n+\n+        public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName) {\n+            failIfNoDocValues();\n+            return new AbstractLatLonShapeDVIndexFieldData.Builder();\n+        }\n+\n+        @Override\n+        public Query existsQuery(QueryShardContext context) {\n+            if (hasDocValues()) {\n+                return new DocValuesFieldExistsQuery(name());\n+            } else {\n+                return new TermQuery(new Term(FieldNamesFieldMapper.NAME, name()));\n+            }\n+        }\n+\n+        @Override\n+        public Query termQuery(Object value, QueryShardContext context) {\n+            throw new QueryShardException(context, \"Geo fields do not support exact searching, use dedicated geo queries instead: [\"\n+                + name() + \"]\");\n+        }\n+\n+        @Override\n+        public GeoShapeWithDocValuesFieldType clone() {\n+            return new GeoShapeWithDocValuesFieldType(this);\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return CONTENT_TYPE;\n+        }\n+    }\n+\n+    public static final class TypeParser extends AbstractGeometryFieldMapper.TypeParser {\n+\n+        @Override\n+        @SuppressWarnings(\"rawtypes\")\n+        protected AbstractGeometryFieldMapper.Builder newBuilder(String name, Map<String, Object> params) {\n+            if (params.containsKey(DEPRECATED_PARAMETERS_KEY)) {\n+                return new LegacyGeoShapeFieldMapper.Builder(name,\n+                    (LegacyGeoShapeFieldMapper.DeprecatedParameters)params.get(DEPRECATED_PARAMETERS_KEY));\n+            }\n+            return new GeoShapeWithDocValuesFieldMapper.Builder(name);\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"rawtypes\")\n+        public Mapper.Builder parse(String name, Map<String, Object> node, ParserContext parserContext) throws MapperParsingException {\n+            Map<String, Object> params = new HashMap<>();\n+            AbstractGeometryFieldMapper.Builder builder = (AbstractGeometryFieldMapper.Builder) super.parse(name, node, parserContext);\n+            for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(); iterator.hasNext();) {\n+                Map.Entry<String, Object> entry = iterator.next();\n+                String fieldName = entry.getKey();\n+                Object fieldNode = entry.getValue();\n+                if (TypeParsers.DOC_VALUES.equals(fieldName)) {\n+                    params.put(TypeParsers.DOC_VALUES, XContentMapValues.nodeBooleanValue(fieldNode, name + \".\" + TypeParsers.DOC_VALUES));\n+                    iterator.remove();\n+                }\n+            }\n+\n+            if (params.containsKey(TypeParsers.DOC_VALUES)) {\n+                builder.docValues((Boolean) params.get(TypeParsers.DOC_VALUES));\n+            }\n+            return builder;\n+        }\n+    }\n+\n+    public GeoShapeWithDocValuesFieldMapper(String simpleName, MappedFieldType fieldType, MappedFieldType defaultFieldType,\n+                                            Explicit<Boolean> ignoreMalformed, Explicit<Boolean> coerce,\n+                                            Explicit<Boolean> ignoreZValue, Explicit<Boolean> docValues, Settings indexSettings,\n+                                            MultiFields multiFields, CopyTo copyTo) {\n+        super(simpleName, fieldType, defaultFieldType, ignoreMalformed, coerce, ignoreZValue, indexSettings,\n+            multiFields, copyTo);\n+        this.docValues = docValues;\n+    }\n+\n+    @Override\n+    protected void doMerge(Mapper mergeWith) {\n+        if (mergeWith instanceof LegacyGeoShapeFieldMapper) {\n+            LegacyGeoShapeFieldMapper legacy = (LegacyGeoShapeFieldMapper) mergeWith;\n+            throw new IllegalArgumentException(\"[\" + fieldType().name() + \"] with field mapper [\" + fieldType().typeName() + \"] \" +\n+                \"using [BKD] strategy cannot be merged with \" + \"[\" + legacy.fieldType().typeName() + \"] with [\" +\n+                legacy.fieldType().strategy() + \"] strategy\");\n+        }\n+        super.doMerge(mergeWith);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY1MDA5MA=="}, "originalCommit": {"oid": "12d6a6cdd7b8adbc1bbf910efdfef7f18ef74591"}, "originalPosition": 241}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1087, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}