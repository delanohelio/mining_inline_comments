{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM5Njc0NjU4", "number": 66273, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwNjoyMDo1OFrOFFarxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNjozMzo1OFrOFFr-Ww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxMjI0Mzg4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/persistence/TransformIndex.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwNjoyMDo1OVrOIF6x3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNDowMjowNVrOIGMYag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzA3NjgzMQ==", "bodyText": "Tests show this doesn't work when there are object fields mixed with multi-fields.\nI need to rethink this solution.", "url": "https://github.com/elastic/elasticsearch/pull/66273#discussion_r543076831", "createdAt": "2020-12-15T06:20:59Z", "author": {"login": "przemekwitek"}, "path": "x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/persistence/TransformIndex.java", "diffHunk": "@@ -134,10 +134,28 @@ private static Settings createSettings() {\n      * }\n      * @param mappings A Map of the form {\"fieldName\": \"fieldType\"}\n      */\n-    private static Map<String, Object> createMappingsFromStringMap(Map<String, String> mappings) {\n+    static Map<String, Object> createMappingsFromStringMap(Map<String, String> mappings) {\n         Map<String, Object> fieldMappings = new HashMap<>();\n-        mappings.forEach((k, v) -> fieldMappings.put(k, Map.of(\"type\", v)));\n-\n+        for (Map.Entry<String, String> entry : mappings.entrySet()) {\n+            String[] parts = entry.getKey().split(\"\\\\.\");\n+            Map<String, Object> current = fieldMappings;\n+            current = diveInto(current, parts[0]);\n+            for (int j = 1; j < parts.length; ++j) {\n+                current = diveInto(current, \"fields\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2e38ed7c7fd49a62ac3efa1a88b44186827fa52"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzM2NTIyNg==", "bodyText": "Ok, I've fixed it.\nStill, I have the impression that there should be an easier way of reconciling individual mappings into the new index creation request. But that's what I have for now.", "url": "https://github.com/elastic/elasticsearch/pull/66273#discussion_r543365226", "createdAt": "2020-12-15T14:02:05Z", "author": {"login": "przemekwitek"}, "path": "x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/persistence/TransformIndex.java", "diffHunk": "@@ -134,10 +134,28 @@ private static Settings createSettings() {\n      * }\n      * @param mappings A Map of the form {\"fieldName\": \"fieldType\"}\n      */\n-    private static Map<String, Object> createMappingsFromStringMap(Map<String, String> mappings) {\n+    static Map<String, Object> createMappingsFromStringMap(Map<String, String> mappings) {\n         Map<String, Object> fieldMappings = new HashMap<>();\n-        mappings.forEach((k, v) -> fieldMappings.put(k, Map.of(\"type\", v)));\n-\n+        for (Map.Entry<String, String> entry : mappings.entrySet()) {\n+            String[] parts = entry.getKey().split(\"\\\\.\");\n+            Map<String, Object> current = fieldMappings;\n+            current = diveInto(current, parts[0]);\n+            for (int j = 1; j < parts.length; ++j) {\n+                current = diveInto(current, \"fields\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzA3NjgzMQ=="}, "originalCommit": {"oid": "e2e38ed7c7fd49a62ac3efa1a88b44186827fa52"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNTA3Njc1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/persistence/TransformIndex.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNjozMzo1OFrOIGUhaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwNjozODoxOVrOIG1CNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ5ODYwMA==", "bodyText": "nit: I am not a big fan of using regex if there is no reason. Arguably its java's fault. A potential alternative: the tokenize methods in org.elasticsearch.common.Strings", "url": "https://github.com/elastic/elasticsearch/pull/66273#discussion_r543498600", "createdAt": "2020-12-15T16:33:58Z", "author": {"login": "hendrikmuhs"}, "path": "x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/persistence/TransformIndex.java", "diffHunk": "@@ -134,10 +148,28 @@ private static Settings createSettings() {\n      * }\n      * @param mappings A Map of the form {\"fieldName\": \"fieldType\"}\n      */\n-    private static Map<String, Object> createMappingsFromStringMap(Map<String, String> mappings) {\n+    static Map<String, Object> createMappingsFromStringMap(Map<String, String> mappings) {\n+        List<Map.Entry<String, String>> sortedMappingsEntries = new ArrayList<>(mappings.entrySet());\n+        // We sort the entry list to make sure that for each (parent, parent.child) pair, parent entry will be processed before child entry.\n+        sortedMappingsEntries.sort(comparingByKey());\n         Map<String, Object> fieldMappings = new HashMap<>();\n-        mappings.forEach((k, v) -> fieldMappings.put(k, Map.of(\"type\", v)));\n-\n+        for (Map.Entry<String, String> entry : sortedMappingsEntries) {\n+            String[] parts = entry.getKey().split(\"\\\\.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5dca6cd23e4af96f23cc246ed49b64bf04030e01"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDAzMTI4NA==", "bodyText": "Arguably its java's fault.\n\nUnfortunately I couldn't find a non-regex version of split() method.\n\nA potential alternative: the tokenize methods in org.elasticsearch.common.Strings\n\nThanks! I've used Strings.tokenizeToStringArray method.", "url": "https://github.com/elastic/elasticsearch/pull/66273#discussion_r544031284", "createdAt": "2020-12-16T06:38:19Z", "author": {"login": "przemekwitek"}, "path": "x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/persistence/TransformIndex.java", "diffHunk": "@@ -134,10 +148,28 @@ private static Settings createSettings() {\n      * }\n      * @param mappings A Map of the form {\"fieldName\": \"fieldType\"}\n      */\n-    private static Map<String, Object> createMappingsFromStringMap(Map<String, String> mappings) {\n+    static Map<String, Object> createMappingsFromStringMap(Map<String, String> mappings) {\n+        List<Map.Entry<String, String>> sortedMappingsEntries = new ArrayList<>(mappings.entrySet());\n+        // We sort the entry list to make sure that for each (parent, parent.child) pair, parent entry will be processed before child entry.\n+        sortedMappingsEntries.sort(comparingByKey());\n         Map<String, Object> fieldMappings = new HashMap<>();\n-        mappings.forEach((k, v) -> fieldMappings.put(k, Map.of(\"type\", v)));\n-\n+        for (Map.Entry<String, String> entry : sortedMappingsEntries) {\n+            String[] parts = entry.getKey().split(\"\\\\.\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ5ODYwMA=="}, "originalCommit": {"oid": "5dca6cd23e4af96f23cc246ed49b64bf04030e01"}, "originalPosition": 48}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4674, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}