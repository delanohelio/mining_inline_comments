{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMxOTUyMTk2", "number": 57892, "title": "Save memory when parent and child are not on top", "bodyText": "Reworks the parent and child aggregation are not at the top level\nusing the optimization from #55873. Instead of wrapping all\nnon-top-level parent and child aggregators we now handle being a\nchild aggregator in the aggregator, specifically by adding recording\nwhich global ordinals show up in the parent and then checking if they\nmatch the child.", "createdAt": "2020-06-09T17:13:58Z", "url": "https://github.com/elastic/elasticsearch/pull/57892", "merged": true, "mergeCommit": {"oid": "3adbe5b106e0d124dce896d9d8b2a63ec4c70a53"}, "closed": true, "closedAt": "2020-06-10T17:27:39Z", "author": {"login": "nik9000"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcpoJwPAH2gAyNDMxOTUyMTk2OjY2MjJhNTNhNjA5OGQzOTk0YTE2Mjk0NDA3YjBkZTY2YzExZmQyYjc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcp8hetgFqTQyODI0NTg1MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "6622a53a6098d3994a16294407b0de66c11fd2b7", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/6622a53a6098d3994a16294407b0de66c11fd2b7", "committedDate": "2020-06-09T17:03:50Z", "message": "Save memory when parent and child are not on top\n\nReworks the `parent` and `child` aggregation are not at the top level\nusing the optimization from #55873. Instead of wrapping all\nnon-top-level `parent` and `child` aggregators we now handle being a\nchild aggregator in the aggregator, specifically by adding recording\nwhich global ordinals show up in the parent and then checking if they\nmatch the child."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3Mzc1Nzcy", "url": "https://github.com/elastic/elasticsearch/pull/57892#pullrequestreview-427375772", "createdAt": "2020-06-09T17:14:56Z", "commit": {"oid": "6622a53a6098d3994a16294407b0de66c11fd2b7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNzoxNDo1NlrOGhUcTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNzoxNDo1NlrOGhUcTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzU5MTExNw==", "bodyText": "This is pretty much the algorithm that we used to use. It ain't perfect, but it gets the job done.", "url": "https://github.com/elastic/elasticsearch/pull/57892#discussion_r437591117", "createdAt": "2020-06-09T17:14:56Z", "author": {"login": "nik9000"}, "path": "modules/parent-join/src/main/java/org/elasticsearch/join/aggregations/ParentJoinAggregator.java", "diffHunk": "@@ -137,11 +138,21 @@ public int docID() {\n                 if (liveDocs != null && liveDocs.get(docId) == false) {\n                     continue;\n                 }\n-                if (globalOrdinals.advanceExact(docId)) {\n-                    int globalOrdinal = (int) globalOrdinals.nextOrd();\n-                    assert globalOrdinal != -1 && globalOrdinals.nextOrd() == SortedSetDocValues.NO_MORE_ORDS;\n-                    if (collectionStrategy.existsGlobalOrdinal(globalOrdinal)) {\n-                        collectBucket(sub, docId, 0);\n+                if (false == globalOrdinals.advanceExact(docId)) {\n+                    continue;\n+                }\n+                int globalOrdinal = (int) globalOrdinals.nextOrd();\n+                assert globalOrdinal != -1 && globalOrdinals.nextOrd() == SortedSetDocValues.NO_MORE_ORDS;\n+                /*\n+                 * Check if we contain every ordinal. It's almost certainly be\n+                 * faster to replay all the matching ordinals and filter them down\n+                 * to just those listed in ordsToCollect, but we don't have a data\n+                 * structure that maps a primitive long to a list of primitive\n+                 * longs. \n+                 */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6622a53a6098d3994a16294407b0de66c11fd2b7"}, "originalPosition": 77}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "48cbdb3e3b95bc975d4fac9a484f63d1e6a9ac99", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/48cbdb3e3b95bc975d4fac9a484f63d1e6a9ac99", "committedDate": "2020-06-09T17:33:53Z", "message": "Ooops test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bab03b6fe2b345bf399ee1544227b8c524829442", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/bab03b6fe2b345bf399ee1544227b8c524829442", "committedDate": "2020-06-09T20:18:03Z", "message": "Woops"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI4MjQ1ODUw", "url": "https://github.com/elastic/elasticsearch/pull/57892#pullrequestreview-428245850", "createdAt": "2020-06-10T16:47:04Z", "commit": {"oid": "bab03b6fe2b345bf399ee1544227b8c524829442"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNjo0NzowNFrOGh9vZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNjo0NzowNFrOGh9vZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI2Nzc1MQ==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/elastic/elasticsearch/pull/57892#discussion_r438267751", "createdAt": "2020-06-10T16:47:04Z", "author": {"login": "talevy"}, "path": "modules/parent-join/src/main/java/org/elasticsearch/join/aggregations/ParentJoinAggregator.java", "diffHunk": "@@ -137,11 +138,21 @@ public int docID() {\n                 if (liveDocs != null && liveDocs.get(docId) == false) {\n                     continue;\n                 }\n-                if (globalOrdinals.advanceExact(docId)) {\n-                    int globalOrdinal = (int) globalOrdinals.nextOrd();\n-                    assert globalOrdinal != -1 && globalOrdinals.nextOrd() == SortedSetDocValues.NO_MORE_ORDS;\n-                    if (collectionStrategy.existsGlobalOrdinal(globalOrdinal)) {\n-                        collectBucket(sub, docId, 0);\n+                if (false == globalOrdinals.advanceExact(docId)) {\n+                    continue;\n+                }\n+                int globalOrdinal = (int) globalOrdinals.nextOrd();\n+                assert globalOrdinal != -1 && globalOrdinals.nextOrd() == SortedSetDocValues.NO_MORE_ORDS;\n+                /*\n+                 * Check if we contain every ordinal. It's almost certainly be\n+                 * faster to replay all the matching ordinals and filter them down\n+                 * to just those listed in ordsToCollect, but we don't have a data\n+                 * structure that maps a primitive long to a list of primitive\n+                 * longs. \n+                 */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzU5MTExNw=="}, "originalCommit": {"oid": "6622a53a6098d3994a16294407b0de66c11fd2b7"}, "originalPosition": 77}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 711, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}