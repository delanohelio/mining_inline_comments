{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ4MjAyOTc1", "number": 59396, "title": "Adds write_index_only option to put mapping API", "bodyText": "Adds a write_index_only option to the put mapping API that defaults to false. When false, the put mapping API applies any mapping changes to all the indices to which any specified data streams and aliases expand. When true, the put mapping API will apply the changes only to the write index for any specified data streams and aliases.\nRelates to #53100", "createdAt": "2020-07-13T11:45:30Z", "url": "https://github.com/elastic/elasticsearch/pull/59396", "merged": true, "mergeCommit": {"oid": "1d3a723f68212b94bbae8a1b1ccad953dd1cc0bc"}, "closed": true, "closedAt": "2020-07-14T13:25:11Z", "author": {"login": "danhermann"}, "timelineItems": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc0f1piAH2gAyNDQ4MjAyOTc1OjYwMzQ3MjA1MmRhZGJhZGJmOGU1NWE5OGU5M2U0NzlmYTU1ODFhMmU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc0gX82AH2gAyNDQ4MjAyOTc1OjVkYjE1ZWZlMDEyNmJlYmYxZTc4NDRmNzM0MDg3MjA2OWY3NjI4NzQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "603472052dadbadbf8e55a98e93e479fa5581a2e", "author": {"user": {"login": "danhermann", "name": "Dan Hermann"}}, "url": "https://github.com/elastic/elasticsearch/commit/603472052dadbadbf8e55a98e93e479fa5581a2e", "committedDate": "2020-07-13T11:35:48Z", "message": "Adds write_index_only options to put mappings API"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3MTc4MzU3", "url": "https://github.com/elastic/elasticsearch/pull/59396#pullrequestreview-447178357", "createdAt": "2020-07-13T11:49:10Z", "commit": {"oid": "603472052dadbadbf8e55a98e93e479fa5581a2e"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxMTo1MDo1MVrOGwlMsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxMjowMDo1MVrOGwlf-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU5NDI4OA==", "bodyText": "I think we need to add this parameter to rest spec as well?", "url": "https://github.com/elastic/elasticsearch/pull/59396#discussion_r453594288", "createdAt": "2020-07-13T11:50:51Z", "author": {"login": "martijnvg"}, "path": "server/src/main/java/org/elasticsearch/rest/action/admin/indices/RestPutMappingAction.java", "diffHunk": "@@ -67,6 +67,7 @@ public RestChannelConsumer prepareRequest(final RestRequest request, final NodeC\n         putMappingRequest.timeout(request.paramAsTime(\"timeout\", putMappingRequest.timeout()));\n         putMappingRequest.masterNodeTimeout(request.paramAsTime(\"master_timeout\", putMappingRequest.masterNodeTimeout()));\n         putMappingRequest.indicesOptions(IndicesOptions.fromRequest(request, putMappingRequest.indicesOptions()));\n+        putMappingRequest.writeIndexOnly(request.paramAsBoolean(\"write_index_only\", false));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "603472052dadbadbf8e55a98e93e479fa5581a2e"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU5OTIyNQ==", "bodyText": "I think this test fails? since index2 is write index?", "url": "https://github.com/elastic/elasticsearch/pull/59396#discussion_r453599225", "createdAt": "2020-07-13T12:00:51Z", "author": {"login": "martijnvg"}, "path": "server/src/test/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingRequestTests.java", "diffHunk": "@@ -59,4 +75,122 @@ public void testBuildFromSimplifiedDef() {\n                 () -> PutMappingRequest.simpleMapping(\"only_field\"));\n         assertEquals(\"mapping source must be pairs of fieldnames and properties definition.\", e.getMessage());\n     }\n+\n+    public void testResolveIndicesWithWriteIndexOnlyAndDataStreamsAndWriteAliases() {\n+        String[] dataStreamNames = {\"foo\", \"bar\", \"baz\"};\n+        List<Tuple<String, Integer>> dsMetadata = List.of(\n+            tuple(dataStreamNames[0], randomIntBetween(1, 3)),\n+            tuple(dataStreamNames[1], randomIntBetween(1, 3)),\n+            tuple(dataStreamNames[2], randomIntBetween(1, 3)));\n+\n+        ClusterState cs = DeleteDataStreamRequestTests.getClusterStateWithDataStreams(dsMetadata, List.of(\"index1\", \"index2\", \"index3\"));\n+        cs = addAliases(cs, List.of(\n+            tuple(\"alias1\", List.of(tuple(\"index1\", false), tuple(\"index2\", true))),\n+            tuple(\"alias2\", List.of(tuple(\"index2\", false), tuple(\"index3\", true)))\n+        ));\n+        PutMappingRequest request = new PutMappingRequest().indices(\"foo\", \"alias1\", \"alias2\").writeIndexOnly(true);\n+        Index[] indices = TransportPutMappingAction.resolveIndices(cs, request, new IndexNameExpressionResolver());\n+        List<String> indexNames = Arrays.stream(indices).map(Index::getName).collect(Collectors.toList());\n+        IndexAbstraction expectedDs = cs.metadata().getIndicesLookup().get(\"foo\");\n+        // should resolve the data stream and each alias to their respective write indices\n+        assertThat(indexNames, containsInAnyOrder(expectedDs.getWriteIndex().getIndex().getName(), \"index2\", \"index3\"));\n+    }\n+\n+    public void testResolveIndicesWithoutWriteIndexOnlyAndDataStreamsAndWriteAliases() {\n+        String[] dataStreamNames = {\"foo\", \"bar\", \"baz\"};\n+        List<Tuple<String, Integer>> dsMetadata = List.of(\n+            tuple(dataStreamNames[0], randomIntBetween(1, 3)),\n+            tuple(dataStreamNames[1], randomIntBetween(1, 3)),\n+            tuple(dataStreamNames[2], randomIntBetween(1, 3)));\n+\n+        ClusterState cs = DeleteDataStreamRequestTests.getClusterStateWithDataStreams(dsMetadata, List.of(\"index1\", \"index2\", \"index3\"));\n+        cs = addAliases(cs, List.of(\n+            tuple(\"alias1\", List.of(tuple(\"index1\", false), tuple(\"index2\", true))),\n+            tuple(\"alias2\", List.of(tuple(\"index2\", false), tuple(\"index3\", true)))\n+        ));\n+        PutMappingRequest request = new PutMappingRequest().indices(\"foo\", \"alias1\", \"alias2\");\n+        Index[] indices = TransportPutMappingAction.resolveIndices(cs, request, new IndexNameExpressionResolver());\n+        List<String> indexNames = Arrays.stream(indices).map(Index::getName).collect(Collectors.toList());\n+        IndexAbstraction expectedDs = cs.metadata().getIndicesLookup().get(\"foo\");\n+        List<String> expectedIndices = expectedDs.getIndices().stream().map(im -> im.getIndex().getName()).collect(Collectors.toList());\n+        expectedIndices.addAll(List.of(\"index1\", \"index2\", \"index3\"));\n+        // should resolve the data stream and each alias to _all_ their respective indices\n+        assertThat(indexNames, containsInAnyOrder(expectedIndices.toArray()));\n+    }\n+\n+    public void testResolveIndicesWithWriteIndexOnlyAndDataStreamAndIndex() {\n+        String[] dataStreamNames = {\"foo\", \"bar\", \"baz\"};\n+        List<Tuple<String, Integer>> dsMetadata = List.of(\n+            tuple(dataStreamNames[0], randomIntBetween(1, 3)),\n+            tuple(dataStreamNames[1], randomIntBetween(1, 3)),\n+            tuple(dataStreamNames[2], randomIntBetween(1, 3)));\n+\n+        ClusterState cs = DeleteDataStreamRequestTests.getClusterStateWithDataStreams(dsMetadata, List.of(\"index1\", \"index2\", \"index3\"));\n+        cs = addAliases(cs, List.of(\n+            tuple(\"alias1\", List.of(tuple(\"index1\", false), tuple(\"index2\", true))),\n+            tuple(\"alias2\", List.of(tuple(\"index2\", false), tuple(\"index3\", true)))\n+        ));\n+        PutMappingRequest request = new PutMappingRequest().indices(\"foo\", \"index3\").writeIndexOnly(true);\n+        Index[] indices = TransportPutMappingAction.resolveIndices(cs, request, new IndexNameExpressionResolver());\n+        List<String> indexNames = Arrays.stream(indices).map(Index::getName).collect(Collectors.toList());\n+        IndexAbstraction expectedDs = cs.metadata().getIndicesLookup().get(\"foo\");\n+        List<String> expectedIndices = expectedDs.getIndices().stream().map(im -> im.getIndex().getName()).collect(Collectors.toList());\n+        expectedIndices.addAll(List.of(\"index1\", \"index2\", \"index3\"));\n+        // should resolve the data stream and each alias to _all_ their respective indices\n+        assertThat(indexNames, containsInAnyOrder(expectedDs.getWriteIndex().getIndex().getName(), \"index3\"));\n+    }\n+\n+    public void testResolveIndicesWithWriteIndexOnlyAndNoSingleWriteIndex() {\n+        String[] dataStreamNames = {\"foo\", \"bar\", \"baz\"};\n+        List<Tuple<String, Integer>> dsMetadata = List.of(\n+            tuple(dataStreamNames[0], randomIntBetween(1, 3)),\n+            tuple(dataStreamNames[1], randomIntBetween(1, 3)),\n+            tuple(dataStreamNames[2], randomIntBetween(1, 3)));\n+\n+        ClusterState cs = DeleteDataStreamRequestTests.getClusterStateWithDataStreams(dsMetadata, List.of(\"index1\", \"index2\", \"index3\"));\n+        final ClusterState cs2 = addAliases(cs, List.of(\n+            tuple(\"alias1\", List.of(tuple(\"index1\", false), tuple(\"index2\", true))),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "603472052dadbadbf8e55a98e93e479fa5581a2e"}, "originalPosition": 105}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5db15efe0126bebf1e7844f7340872069f762874", "author": {"user": {"login": "danhermann", "name": "Dan Hermann"}}, "url": "https://github.com/elastic/elasticsearch/commit/5db15efe0126bebf1e7844f7340872069f762874", "committedDate": "2020-07-13T12:13:16Z", "message": "add parameter to rest spec"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4527, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}