{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMxMzYwODI5", "number": 65794, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNToxNDoxMlrOFATVdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxMTo1MTozNVrOFAw7Ew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1ODYxMTEwOnYy", "diffSide": "RIGHT", "path": "docs/reference/eql/syntax.asciidoc", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNToxNDoxMlrOH-hSGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNToxNjowN1rOH-hYOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMxOTA2NQ==", "bodyText": "is _id sorted by default? i can't remember how it fits into the sequence ordering. i think this is right, just want to double check", "url": "https://github.com/elastic/elasticsearch/pull/65794#discussion_r535319065", "createdAt": "2020-12-03T15:14:12Z", "author": {"login": "rw-access"}, "path": "docs/reference/eql/syntax.asciidoc", "diffHunk": "@@ -771,3 +771,126 @@ three double quotes (`\"\"\"`) instead.\n *** {eql-ref}/pipes.html#sort[`sort`]\n *** {eql-ref}/pipes.html#unique[`unique`]\n *** {eql-ref}/pipes.html#unique-count[`unique_count`]\n+\n+[discrete]\n+[[eql-how-sequence-queries-handle-matches]]\n+==== How sequence queries handle matches\n+\n+<<eql-sequences,Sequence queries>> don't find all potential matches for a\n+sequence. This approach would be too slow and costly for large event data sets.\n+Instead, a sequence query handles pending sequence matches as a\n+{wikipedia}/Finite-state_machine[state machine]:\n+\n+* Each event item in the sequence query is a state in the machine.\n+* Only one pending sequence can be in each state at a time.\n+* If two pending sequences are in the same state at the same time, the most\n+recent sequence overwrites the older one.\n+* If the query includes <<eql-by-keyword,`by` fields>>, the query uses a\n+separate state machine for each unique `by` field value.\n+\n+.*Example* \n+[%collapsible]\n+====\n+A data set contains the following `process` events in ascending chronological\n+order:\n+\n+[source,js]\n+----\n+{ \"index\" : { \"_id\" : \"1\" } }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bda543777a50649fa014e9d12964b239b7c3da75"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMxOTYxNw==", "bodyText": "A data set contains the following process events in ascending chronological\norder: ...\n\nah, this is more of an abstraction and deliberately not filled in .... in that case i think we're good", "url": "https://github.com/elastic/elasticsearch/pull/65794#discussion_r535319617", "createdAt": "2020-12-03T15:14:50Z", "author": {"login": "rw-access"}, "path": "docs/reference/eql/syntax.asciidoc", "diffHunk": "@@ -771,3 +771,126 @@ three double quotes (`\"\"\"`) instead.\n *** {eql-ref}/pipes.html#sort[`sort`]\n *** {eql-ref}/pipes.html#unique[`unique`]\n *** {eql-ref}/pipes.html#unique-count[`unique_count`]\n+\n+[discrete]\n+[[eql-how-sequence-queries-handle-matches]]\n+==== How sequence queries handle matches\n+\n+<<eql-sequences,Sequence queries>> don't find all potential matches for a\n+sequence. This approach would be too slow and costly for large event data sets.\n+Instead, a sequence query handles pending sequence matches as a\n+{wikipedia}/Finite-state_machine[state machine]:\n+\n+* Each event item in the sequence query is a state in the machine.\n+* Only one pending sequence can be in each state at a time.\n+* If two pending sequences are in the same state at the same time, the most\n+recent sequence overwrites the older one.\n+* If the query includes <<eql-by-keyword,`by` fields>>, the query uses a\n+separate state machine for each unique `by` field value.\n+\n+.*Example* \n+[%collapsible]\n+====\n+A data set contains the following `process` events in ascending chronological\n+order:\n+\n+[source,js]\n+----\n+{ \"index\" : { \"_id\" : \"1\" } }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMxOTA2NQ=="}, "originalCommit": {"oid": "bda543777a50649fa014e9d12964b239b7c3da75"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMyMDYzMw==", "bodyText": "Yeah. I originally included the @timestamp but it looked kinda noisy.", "url": "https://github.com/elastic/elasticsearch/pull/65794#discussion_r535320633", "createdAt": "2020-12-03T15:16:07Z", "author": {"login": "jrodewig"}, "path": "docs/reference/eql/syntax.asciidoc", "diffHunk": "@@ -771,3 +771,126 @@ three double quotes (`\"\"\"`) instead.\n *** {eql-ref}/pipes.html#sort[`sort`]\n *** {eql-ref}/pipes.html#unique[`unique`]\n *** {eql-ref}/pipes.html#unique-count[`unique_count`]\n+\n+[discrete]\n+[[eql-how-sequence-queries-handle-matches]]\n+==== How sequence queries handle matches\n+\n+<<eql-sequences,Sequence queries>> don't find all potential matches for a\n+sequence. This approach would be too slow and costly for large event data sets.\n+Instead, a sequence query handles pending sequence matches as a\n+{wikipedia}/Finite-state_machine[state machine]:\n+\n+* Each event item in the sequence query is a state in the machine.\n+* Only one pending sequence can be in each state at a time.\n+* If two pending sequences are in the same state at the same time, the most\n+recent sequence overwrites the older one.\n+* If the query includes <<eql-by-keyword,`by` fields>>, the query uses a\n+separate state machine for each unique `by` field value.\n+\n+.*Example* \n+[%collapsible]\n+====\n+A data set contains the following `process` events in ascending chronological\n+order:\n+\n+[source,js]\n+----\n+{ \"index\" : { \"_id\" : \"1\" } }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMxOTA2NQ=="}, "originalCommit": {"oid": "bda543777a50649fa014e9d12964b239b7c3da75"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1ODYzMTkyOnYy", "diffSide": "RIGHT", "path": "docs/reference/eql/syntax.asciidoc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNToxODoxN1rOH-he_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNToyMDowNFrOH-hkkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMyMjM2NQ==", "bodyText": "I'm not 100% sure if \"doesn't match state A\" will be immediately clear to users reading the docs.\nI'm wondering if we could say something more like this:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            // Nothing happens. This event doesn't match state A for the \"elkbee\" user.\n          \n          \n            \n            // Nothing happens. The \"elkbee\" user has no pending sequence to move from state A to state B", "url": "https://github.com/elastic/elasticsearch/pull/65794#discussion_r535322365", "createdAt": "2020-12-03T15:18:17Z", "author": {"login": "rw-access"}, "path": "docs/reference/eql/syntax.asciidoc", "diffHunk": "@@ -771,3 +771,126 @@ three double quotes (`\"\"\"`) instead.\n *** {eql-ref}/pipes.html#sort[`sort`]\n *** {eql-ref}/pipes.html#unique[`unique`]\n *** {eql-ref}/pipes.html#unique-count[`unique_count`]\n+\n+[discrete]\n+[[eql-how-sequence-queries-handle-matches]]\n+==== How sequence queries handle matches\n+\n+<<eql-sequences,Sequence queries>> don't find all potential matches for a\n+sequence. This approach would be too slow and costly for large event data sets.\n+Instead, a sequence query handles pending sequence matches as a\n+{wikipedia}/Finite-state_machine[state machine]:\n+\n+* Each event item in the sequence query is a state in the machine.\n+* Only one pending sequence can be in each state at a time.\n+* If two pending sequences are in the same state at the same time, the most\n+recent sequence overwrites the older one.\n+* If the query includes <<eql-by-keyword,`by` fields>>, the query uses a\n+separate state machine for each unique `by` field value.\n+\n+.*Example* \n+[%collapsible]\n+====\n+A data set contains the following `process` events in ascending chronological\n+order:\n+\n+[source,js]\n+----\n+{ \"index\" : { \"_id\" : \"1\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"2\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"3\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"4\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"5\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"6\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"7\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"8\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"9\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"ifconfig\" }, ...}\n+{ \"index\" : { \"_id\" : \"10\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"ifconfig\" }, ...}\n+{ \"index\" : { \"_id\" : \"11\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"ifconfig\" }, ...}\n+----\n+// NOTCONSOLE\n+\n+An EQL sequence query searches the data set:\n+\n+[source,eql]\n+----\n+sequence by user.name\n+  [process where process.name == \"whoami\"]\n+  [process where process.name == \"hostname\"]\n+  [process where process.name == \"ifconfig\"]\n+----\n+\n+The query's event items correspond to the following states:\n+\n+* State A:  `[process where process.name == \"whoami\"]`\n+* State B:  `[process where process.name == \"hostname\"]`\n+* Complete: `[process where process.name == \"ifconfig\"]`\n+\n+To find matching sequences, the query uses separate state machines for each\n+unique `user.name` value. Pending sequence matches move through each machine's\n+states as follows:\n+\n+[source,txt]\n+----\n+{ \"index\" : { \"_id\" : \"1\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+// Creates sequence [1] in state A for the \"root\" user.\n+\n+{ \"index\" : { \"_id\" : \"2\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+// Creates sequence [2] in state A for \"root\", overwriting sequence [1].\n+\n+{ \"index\" : { \"_id\" : \"3\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+// Nothing happens. This event doesn't match state A for the \"elkbee\" user.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bda543777a50649fa014e9d12964b239b7c3da75"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMyMzc5Mg==", "bodyText": "Thanks for raising this. I incorporated your change with a minor update.", "url": "https://github.com/elastic/elasticsearch/pull/65794#discussion_r535323792", "createdAt": "2020-12-03T15:20:04Z", "author": {"login": "jrodewig"}, "path": "docs/reference/eql/syntax.asciidoc", "diffHunk": "@@ -771,3 +771,126 @@ three double quotes (`\"\"\"`) instead.\n *** {eql-ref}/pipes.html#sort[`sort`]\n *** {eql-ref}/pipes.html#unique[`unique`]\n *** {eql-ref}/pipes.html#unique-count[`unique_count`]\n+\n+[discrete]\n+[[eql-how-sequence-queries-handle-matches]]\n+==== How sequence queries handle matches\n+\n+<<eql-sequences,Sequence queries>> don't find all potential matches for a\n+sequence. This approach would be too slow and costly for large event data sets.\n+Instead, a sequence query handles pending sequence matches as a\n+{wikipedia}/Finite-state_machine[state machine]:\n+\n+* Each event item in the sequence query is a state in the machine.\n+* Only one pending sequence can be in each state at a time.\n+* If two pending sequences are in the same state at the same time, the most\n+recent sequence overwrites the older one.\n+* If the query includes <<eql-by-keyword,`by` fields>>, the query uses a\n+separate state machine for each unique `by` field value.\n+\n+.*Example* \n+[%collapsible]\n+====\n+A data set contains the following `process` events in ascending chronological\n+order:\n+\n+[source,js]\n+----\n+{ \"index\" : { \"_id\" : \"1\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"2\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"3\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"4\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"5\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"6\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"7\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"8\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"9\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"ifconfig\" }, ...}\n+{ \"index\" : { \"_id\" : \"10\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"ifconfig\" }, ...}\n+{ \"index\" : { \"_id\" : \"11\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"ifconfig\" }, ...}\n+----\n+// NOTCONSOLE\n+\n+An EQL sequence query searches the data set:\n+\n+[source,eql]\n+----\n+sequence by user.name\n+  [process where process.name == \"whoami\"]\n+  [process where process.name == \"hostname\"]\n+  [process where process.name == \"ifconfig\"]\n+----\n+\n+The query's event items correspond to the following states:\n+\n+* State A:  `[process where process.name == \"whoami\"]`\n+* State B:  `[process where process.name == \"hostname\"]`\n+* Complete: `[process where process.name == \"ifconfig\"]`\n+\n+To find matching sequences, the query uses separate state machines for each\n+unique `user.name` value. Pending sequence matches move through each machine's\n+states as follows:\n+\n+[source,txt]\n+----\n+{ \"index\" : { \"_id\" : \"1\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+// Creates sequence [1] in state A for the \"root\" user.\n+\n+{ \"index\" : { \"_id\" : \"2\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+// Creates sequence [2] in state A for \"root\", overwriting sequence [1].\n+\n+{ \"index\" : { \"_id\" : \"3\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+// Nothing happens. This event doesn't match state A for the \"elkbee\" user.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMyMjM2NQ=="}, "originalCommit": {"oid": "bda543777a50649fa014e9d12964b239b7c3da75"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1ODY1MTM3OnYy", "diffSide": "RIGHT", "path": "docs/reference/eql/syntax.asciidoc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNToyMTo1OVrOH-hq9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNTozMDoxMlrOH-iGOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMyNTQzMQ==", "bodyText": "since this is the first state transition, maybe we could be extra clear that we're moving the pending sequence out of state A, and appending a new event as part of the transition.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            // Sequence [2, 4] moves to state B for \"root\".\n          \n          \n            \n            // Sequence [2] moves out of state A for \"root\". State B for \"root\" now contains [2, 4]\n          \n          \n            \n            \n          \n      \n    \n    \n  \n\nI recently was walking through the algorithm with another engineer and I think these were some of the points of confusion", "url": "https://github.com/elastic/elasticsearch/pull/65794#discussion_r535325431", "createdAt": "2020-12-03T15:21:59Z", "author": {"login": "rw-access"}, "path": "docs/reference/eql/syntax.asciidoc", "diffHunk": "@@ -771,3 +771,126 @@ three double quotes (`\"\"\"`) instead.\n *** {eql-ref}/pipes.html#sort[`sort`]\n *** {eql-ref}/pipes.html#unique[`unique`]\n *** {eql-ref}/pipes.html#unique-count[`unique_count`]\n+\n+[discrete]\n+[[eql-how-sequence-queries-handle-matches]]\n+==== How sequence queries handle matches\n+\n+<<eql-sequences,Sequence queries>> don't find all potential matches for a\n+sequence. This approach would be too slow and costly for large event data sets.\n+Instead, a sequence query handles pending sequence matches as a\n+{wikipedia}/Finite-state_machine[state machine]:\n+\n+* Each event item in the sequence query is a state in the machine.\n+* Only one pending sequence can be in each state at a time.\n+* If two pending sequences are in the same state at the same time, the most\n+recent sequence overwrites the older one.\n+* If the query includes <<eql-by-keyword,`by` fields>>, the query uses a\n+separate state machine for each unique `by` field value.\n+\n+.*Example* \n+[%collapsible]\n+====\n+A data set contains the following `process` events in ascending chronological\n+order:\n+\n+[source,js]\n+----\n+{ \"index\" : { \"_id\" : \"1\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"2\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"3\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"4\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"5\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"6\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"7\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"8\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"9\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"ifconfig\" }, ...}\n+{ \"index\" : { \"_id\" : \"10\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"ifconfig\" }, ...}\n+{ \"index\" : { \"_id\" : \"11\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"ifconfig\" }, ...}\n+----\n+// NOTCONSOLE\n+\n+An EQL sequence query searches the data set:\n+\n+[source,eql]\n+----\n+sequence by user.name\n+  [process where process.name == \"whoami\"]\n+  [process where process.name == \"hostname\"]\n+  [process where process.name == \"ifconfig\"]\n+----\n+\n+The query's event items correspond to the following states:\n+\n+* State A:  `[process where process.name == \"whoami\"]`\n+* State B:  `[process where process.name == \"hostname\"]`\n+* Complete: `[process where process.name == \"ifconfig\"]`\n+\n+To find matching sequences, the query uses separate state machines for each\n+unique `user.name` value. Pending sequence matches move through each machine's\n+states as follows:\n+\n+[source,txt]\n+----\n+{ \"index\" : { \"_id\" : \"1\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+// Creates sequence [1] in state A for the \"root\" user.\n+\n+{ \"index\" : { \"_id\" : \"2\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+// Creates sequence [2] in state A for \"root\", overwriting sequence [1].\n+\n+{ \"index\" : { \"_id\" : \"3\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+// Nothing happens. This event doesn't match state A for the \"elkbee\" user.\n+\n+{ \"index\" : { \"_id\" : \"4\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+// Sequence [2, 4] moves to state B for \"root\".", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bda543777a50649fa014e9d12964b239b7c3da75"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMzMjQwOQ==", "bodyText": "// root: B=[2,4]", "url": "https://github.com/elastic/elasticsearch/pull/65794#discussion_r535332409", "createdAt": "2020-12-03T15:30:12Z", "author": {"login": "rw-access"}, "path": "docs/reference/eql/syntax.asciidoc", "diffHunk": "@@ -771,3 +771,126 @@ three double quotes (`\"\"\"`) instead.\n *** {eql-ref}/pipes.html#sort[`sort`]\n *** {eql-ref}/pipes.html#unique[`unique`]\n *** {eql-ref}/pipes.html#unique-count[`unique_count`]\n+\n+[discrete]\n+[[eql-how-sequence-queries-handle-matches]]\n+==== How sequence queries handle matches\n+\n+<<eql-sequences,Sequence queries>> don't find all potential matches for a\n+sequence. This approach would be too slow and costly for large event data sets.\n+Instead, a sequence query handles pending sequence matches as a\n+{wikipedia}/Finite-state_machine[state machine]:\n+\n+* Each event item in the sequence query is a state in the machine.\n+* Only one pending sequence can be in each state at a time.\n+* If two pending sequences are in the same state at the same time, the most\n+recent sequence overwrites the older one.\n+* If the query includes <<eql-by-keyword,`by` fields>>, the query uses a\n+separate state machine for each unique `by` field value.\n+\n+.*Example* \n+[%collapsible]\n+====\n+A data set contains the following `process` events in ascending chronological\n+order:\n+\n+[source,js]\n+----\n+{ \"index\" : { \"_id\" : \"1\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"2\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"3\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"4\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"5\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"6\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"7\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"8\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"9\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"ifconfig\" }, ...}\n+{ \"index\" : { \"_id\" : \"10\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"ifconfig\" }, ...}\n+{ \"index\" : { \"_id\" : \"11\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"ifconfig\" }, ...}\n+----\n+// NOTCONSOLE\n+\n+An EQL sequence query searches the data set:\n+\n+[source,eql]\n+----\n+sequence by user.name\n+  [process where process.name == \"whoami\"]\n+  [process where process.name == \"hostname\"]\n+  [process where process.name == \"ifconfig\"]\n+----\n+\n+The query's event items correspond to the following states:\n+\n+* State A:  `[process where process.name == \"whoami\"]`\n+* State B:  `[process where process.name == \"hostname\"]`\n+* Complete: `[process where process.name == \"ifconfig\"]`\n+\n+To find matching sequences, the query uses separate state machines for each\n+unique `user.name` value. Pending sequence matches move through each machine's\n+states as follows:\n+\n+[source,txt]\n+----\n+{ \"index\" : { \"_id\" : \"1\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+// Creates sequence [1] in state A for the \"root\" user.\n+\n+{ \"index\" : { \"_id\" : \"2\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+// Creates sequence [2] in state A for \"root\", overwriting sequence [1].\n+\n+{ \"index\" : { \"_id\" : \"3\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+// Nothing happens. This event doesn't match state A for the \"elkbee\" user.\n+\n+{ \"index\" : { \"_id\" : \"4\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+// Sequence [2, 4] moves to state B for \"root\".", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMyNTQzMQ=="}, "originalCommit": {"oid": "bda543777a50649fa014e9d12964b239b7c3da75"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1ODY4MzYzOnYy", "diffSide": "RIGHT", "path": "docs/reference/eql/syntax.asciidoc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNToyNzo0OVrOH-h-VQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNTo0NToxNlrOH-jIjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMzMDM4OQ==", "bodyText": "Do you think it could make sense to change the query so the ordering is more obvious?\nLike process.name == \"process1\", process.name == \"process2\", etc. It makes it a little bit more clear what's happening, because it's not totally easy to remember which command matches which state. Unfortunately it does make the dataset more abstract.\nWhat about a middle ground, like...\n\nattrib -> state A\nbash -> state B\ncat  -> state C", "url": "https://github.com/elastic/elasticsearch/pull/65794#discussion_r535330389", "createdAt": "2020-12-03T15:27:49Z", "author": {"login": "rw-access"}, "path": "docs/reference/eql/syntax.asciidoc", "diffHunk": "@@ -771,3 +771,126 @@ three double quotes (`\"\"\"`) instead.\n *** {eql-ref}/pipes.html#sort[`sort`]\n *** {eql-ref}/pipes.html#unique[`unique`]\n *** {eql-ref}/pipes.html#unique-count[`unique_count`]\n+\n+[discrete]\n+[[eql-how-sequence-queries-handle-matches]]\n+==== How sequence queries handle matches\n+\n+<<eql-sequences,Sequence queries>> don't find all potential matches for a\n+sequence. This approach would be too slow and costly for large event data sets.\n+Instead, a sequence query handles pending sequence matches as a\n+{wikipedia}/Finite-state_machine[state machine]:\n+\n+* Each event item in the sequence query is a state in the machine.\n+* Only one pending sequence can be in each state at a time.\n+* If two pending sequences are in the same state at the same time, the most\n+recent sequence overwrites the older one.\n+* If the query includes <<eql-by-keyword,`by` fields>>, the query uses a\n+separate state machine for each unique `by` field value.\n+\n+.*Example* \n+[%collapsible]\n+====\n+A data set contains the following `process` events in ascending chronological\n+order:\n+\n+[source,js]\n+----\n+{ \"index\" : { \"_id\" : \"1\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"2\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"3\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"4\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"5\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"6\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"7\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"8\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"9\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"ifconfig\" }, ...}\n+{ \"index\" : { \"_id\" : \"10\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"ifconfig\" }, ...}\n+{ \"index\" : { \"_id\" : \"11\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"ifconfig\" }, ...}\n+----\n+// NOTCONSOLE\n+\n+An EQL sequence query searches the data set:\n+\n+[source,eql]\n+----\n+sequence by user.name\n+  [process where process.name == \"whoami\"]\n+  [process where process.name == \"hostname\"]\n+  [process where process.name == \"ifconfig\"]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bda543777a50649fa014e9d12964b239b7c3da75"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM0OTM5MQ==", "bodyText": "I like the middle ground idea. Pretty clever. I swapped out the process.name values for those with 9066d78. Let me know if you think they work.", "url": "https://github.com/elastic/elasticsearch/pull/65794#discussion_r535349391", "createdAt": "2020-12-03T15:45:16Z", "author": {"login": "jrodewig"}, "path": "docs/reference/eql/syntax.asciidoc", "diffHunk": "@@ -771,3 +771,126 @@ three double quotes (`\"\"\"`) instead.\n *** {eql-ref}/pipes.html#sort[`sort`]\n *** {eql-ref}/pipes.html#unique[`unique`]\n *** {eql-ref}/pipes.html#unique-count[`unique_count`]\n+\n+[discrete]\n+[[eql-how-sequence-queries-handle-matches]]\n+==== How sequence queries handle matches\n+\n+<<eql-sequences,Sequence queries>> don't find all potential matches for a\n+sequence. This approach would be too slow and costly for large event data sets.\n+Instead, a sequence query handles pending sequence matches as a\n+{wikipedia}/Finite-state_machine[state machine]:\n+\n+* Each event item in the sequence query is a state in the machine.\n+* Only one pending sequence can be in each state at a time.\n+* If two pending sequences are in the same state at the same time, the most\n+recent sequence overwrites the older one.\n+* If the query includes <<eql-by-keyword,`by` fields>>, the query uses a\n+separate state machine for each unique `by` field value.\n+\n+.*Example* \n+[%collapsible]\n+====\n+A data set contains the following `process` events in ascending chronological\n+order:\n+\n+[source,js]\n+----\n+{ \"index\" : { \"_id\" : \"1\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"2\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"3\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"4\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"5\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"6\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"7\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"8\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"9\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"ifconfig\" }, ...}\n+{ \"index\" : { \"_id\" : \"10\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"ifconfig\" }, ...}\n+{ \"index\" : { \"_id\" : \"11\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"ifconfig\" }, ...}\n+----\n+// NOTCONSOLE\n+\n+An EQL sequence query searches the data set:\n+\n+[source,eql]\n+----\n+sequence by user.name\n+  [process where process.name == \"whoami\"]\n+  [process where process.name == \"hostname\"]\n+  [process where process.name == \"ifconfig\"]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMzMDM4OQ=="}, "originalCommit": {"oid": "bda543777a50649fa014e9d12964b239b7c3da75"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1ODY5MzUzOnYy", "diffSide": "RIGHT", "path": "docs/reference/eql/syntax.asciidoc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNToyOTo0M1rOH-iEiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNTo0NjoyNFrOH-jNAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMzMTk3Nw==", "bodyText": "I'm also wondering if a visual representation could make it more digestible. Could be in addition to what's already there\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            // Creates sequence [1] in state A for the \"root\" user.\n          \n          \n            \n            // Creates sequence [1] in state A for the \"root\" user.\n          \n          \n            \n            //\n          \n          \n            \n            // root: A=[1]", "url": "https://github.com/elastic/elasticsearch/pull/65794#discussion_r535331977", "createdAt": "2020-12-03T15:29:43Z", "author": {"login": "rw-access"}, "path": "docs/reference/eql/syntax.asciidoc", "diffHunk": "@@ -771,3 +771,126 @@ three double quotes (`\"\"\"`) instead.\n *** {eql-ref}/pipes.html#sort[`sort`]\n *** {eql-ref}/pipes.html#unique[`unique`]\n *** {eql-ref}/pipes.html#unique-count[`unique_count`]\n+\n+[discrete]\n+[[eql-how-sequence-queries-handle-matches]]\n+==== How sequence queries handle matches\n+\n+<<eql-sequences,Sequence queries>> don't find all potential matches for a\n+sequence. This approach would be too slow and costly for large event data sets.\n+Instead, a sequence query handles pending sequence matches as a\n+{wikipedia}/Finite-state_machine[state machine]:\n+\n+* Each event item in the sequence query is a state in the machine.\n+* Only one pending sequence can be in each state at a time.\n+* If two pending sequences are in the same state at the same time, the most\n+recent sequence overwrites the older one.\n+* If the query includes <<eql-by-keyword,`by` fields>>, the query uses a\n+separate state machine for each unique `by` field value.\n+\n+.*Example* \n+[%collapsible]\n+====\n+A data set contains the following `process` events in ascending chronological\n+order:\n+\n+[source,js]\n+----\n+{ \"index\" : { \"_id\" : \"1\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"2\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"3\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"4\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"5\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"6\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"7\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"8\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"9\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"ifconfig\" }, ...}\n+{ \"index\" : { \"_id\" : \"10\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"ifconfig\" }, ...}\n+{ \"index\" : { \"_id\" : \"11\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"ifconfig\" }, ...}\n+----\n+// NOTCONSOLE\n+\n+An EQL sequence query searches the data set:\n+\n+[source,eql]\n+----\n+sequence by user.name\n+  [process where process.name == \"whoami\"]\n+  [process where process.name == \"hostname\"]\n+  [process where process.name == \"ifconfig\"]\n+----\n+\n+The query's event items correspond to the following states:\n+\n+* State A:  `[process where process.name == \"whoami\"]`\n+* State B:  `[process where process.name == \"hostname\"]`\n+* Complete: `[process where process.name == \"ifconfig\"]`\n+\n+To find matching sequences, the query uses separate state machines for each\n+unique `user.name` value. Pending sequence matches move through each machine's\n+states as follows:\n+\n+[source,txt]\n+----\n+{ \"index\" : { \"_id\" : \"1\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+// Creates sequence [1] in state A for the \"root\" user.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bda543777a50649fa014e9d12964b239b7c3da75"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM1MDUyOA==", "bodyText": "+1. This is a great idea. Added with 9066d78.", "url": "https://github.com/elastic/elasticsearch/pull/65794#discussion_r535350528", "createdAt": "2020-12-03T15:46:24Z", "author": {"login": "jrodewig"}, "path": "docs/reference/eql/syntax.asciidoc", "diffHunk": "@@ -771,3 +771,126 @@ three double quotes (`\"\"\"`) instead.\n *** {eql-ref}/pipes.html#sort[`sort`]\n *** {eql-ref}/pipes.html#unique[`unique`]\n *** {eql-ref}/pipes.html#unique-count[`unique_count`]\n+\n+[discrete]\n+[[eql-how-sequence-queries-handle-matches]]\n+==== How sequence queries handle matches\n+\n+<<eql-sequences,Sequence queries>> don't find all potential matches for a\n+sequence. This approach would be too slow and costly for large event data sets.\n+Instead, a sequence query handles pending sequence matches as a\n+{wikipedia}/Finite-state_machine[state machine]:\n+\n+* Each event item in the sequence query is a state in the machine.\n+* Only one pending sequence can be in each state at a time.\n+* If two pending sequences are in the same state at the same time, the most\n+recent sequence overwrites the older one.\n+* If the query includes <<eql-by-keyword,`by` fields>>, the query uses a\n+separate state machine for each unique `by` field value.\n+\n+.*Example* \n+[%collapsible]\n+====\n+A data set contains the following `process` events in ascending chronological\n+order:\n+\n+[source,js]\n+----\n+{ \"index\" : { \"_id\" : \"1\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"2\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"3\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"4\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"5\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"6\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"7\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"8\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"9\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"ifconfig\" }, ...}\n+{ \"index\" : { \"_id\" : \"10\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"ifconfig\" }, ...}\n+{ \"index\" : { \"_id\" : \"11\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"ifconfig\" }, ...}\n+----\n+// NOTCONSOLE\n+\n+An EQL sequence query searches the data set:\n+\n+[source,eql]\n+----\n+sequence by user.name\n+  [process where process.name == \"whoami\"]\n+  [process where process.name == \"hostname\"]\n+  [process where process.name == \"ifconfig\"]\n+----\n+\n+The query's event items correspond to the following states:\n+\n+* State A:  `[process where process.name == \"whoami\"]`\n+* State B:  `[process where process.name == \"hostname\"]`\n+* Complete: `[process where process.name == \"ifconfig\"]`\n+\n+To find matching sequences, the query uses separate state machines for each\n+unique `user.name` value. Pending sequence matches move through each machine's\n+states as follows:\n+\n+[source,txt]\n+----\n+{ \"index\" : { \"_id\" : \"1\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+// Creates sequence [1] in state A for the \"root\" user.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMzMTk3Nw=="}, "originalCommit": {"oid": "bda543777a50649fa014e9d12964b239b7c3da75"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1ODY5NDkyOnYy", "diffSide": "RIGHT", "path": "docs/reference/eql/syntax.asciidoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNToyOTo1OVrOH-iFbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNToyOTo1OVrOH-iFbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMzMjIwNg==", "bodyText": "// root: A=[2]\n```", "url": "https://github.com/elastic/elasticsearch/pull/65794#discussion_r535332206", "createdAt": "2020-12-03T15:29:59Z", "author": {"login": "rw-access"}, "path": "docs/reference/eql/syntax.asciidoc", "diffHunk": "@@ -771,3 +771,126 @@ three double quotes (`\"\"\"`) instead.\n *** {eql-ref}/pipes.html#sort[`sort`]\n *** {eql-ref}/pipes.html#unique[`unique`]\n *** {eql-ref}/pipes.html#unique-count[`unique_count`]\n+\n+[discrete]\n+[[eql-how-sequence-queries-handle-matches]]\n+==== How sequence queries handle matches\n+\n+<<eql-sequences,Sequence queries>> don't find all potential matches for a\n+sequence. This approach would be too slow and costly for large event data sets.\n+Instead, a sequence query handles pending sequence matches as a\n+{wikipedia}/Finite-state_machine[state machine]:\n+\n+* Each event item in the sequence query is a state in the machine.\n+* Only one pending sequence can be in each state at a time.\n+* If two pending sequences are in the same state at the same time, the most\n+recent sequence overwrites the older one.\n+* If the query includes <<eql-by-keyword,`by` fields>>, the query uses a\n+separate state machine for each unique `by` field value.\n+\n+.*Example* \n+[%collapsible]\n+====\n+A data set contains the following `process` events in ascending chronological\n+order:\n+\n+[source,js]\n+----\n+{ \"index\" : { \"_id\" : \"1\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"2\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"3\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"4\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"5\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"6\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"7\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+{ \"index\" : { \"_id\" : \"8\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"hostname\" }, ...}\n+{ \"index\" : { \"_id\" : \"9\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"ifconfig\" }, ...}\n+{ \"index\" : { \"_id\" : \"10\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"ifconfig\" }, ...}\n+{ \"index\" : { \"_id\" : \"11\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"ifconfig\" }, ...}\n+----\n+// NOTCONSOLE\n+\n+An EQL sequence query searches the data set:\n+\n+[source,eql]\n+----\n+sequence by user.name\n+  [process where process.name == \"whoami\"]\n+  [process where process.name == \"hostname\"]\n+  [process where process.name == \"ifconfig\"]\n+----\n+\n+The query's event items correspond to the following states:\n+\n+* State A:  `[process where process.name == \"whoami\"]`\n+* State B:  `[process where process.name == \"hostname\"]`\n+* Complete: `[process where process.name == \"ifconfig\"]`\n+\n+To find matching sequences, the query uses separate state machines for each\n+unique `user.name` value. Pending sequence matches move through each machine's\n+states as follows:\n+\n+[source,txt]\n+----\n+{ \"index\" : { \"_id\" : \"1\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+// Creates sequence [1] in state A for the \"root\" user.\n+\n+{ \"index\" : { \"_id\" : \"2\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"whoami\" }, ...}\n+// Creates sequence [2] in state A for \"root\", overwriting sequence [1].", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bda543777a50649fa014e9d12964b239b7c3da75"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2MzQ1ODc1OnYy", "diffSide": "RIGHT", "path": "docs/reference/eql/syntax.asciidoc", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxMTo1MTozNVrOH_Nj-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNDozODoxN1rOH_TrQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA0NDUzNw==", "bodyText": "This can be a follow-up ticket; having a visual representation of the events, the potential sequences and the final sequences helps a lot in understanding how this works vs just the test description.\nIt doesn't have to be something fancy, a basic diagram or even ascii art would go a long way.", "url": "https://github.com/elastic/elasticsearch/pull/65794#discussion_r536044537", "createdAt": "2020-12-04T11:51:35Z", "author": {"login": "costin"}, "path": "docs/reference/eql/syntax.asciidoc", "diffHunk": "@@ -771,3 +771,147 @@ three double quotes (`\"\"\"`) instead.\n *** {eql-ref}/pipes.html#sort[`sort`]\n *** {eql-ref}/pipes.html#unique[`unique`]\n *** {eql-ref}/pipes.html#unique-count[`unique_count`]\n+\n+[discrete]\n+[[eql-how-sequence-queries-handle-matches]]\n+==== How sequence queries handle matches\n+\n+<<eql-sequences,Sequence queries>> don't find all potential matches for a\n+sequence. This approach would be too slow and costly for large event data sets.\n+Instead, a sequence query handles pending sequence matches as a\n+{wikipedia}/Finite-state_machine[state machine]:\n+\n+* Each event item in the sequence query is a state in the machine.\n+* Only one pending sequence can be in each state at a time.\n+* If two pending sequences are in the same state at the same time, the most\n+recent sequence overwrites the older one.\n+* If the query includes <<eql-by-keyword,`by` fields>>, the query uses a\n+separate state machine for each unique `by` field value.\n+\n+.*Example* \n+[%collapsible]\n+====\n+A data set contains the following `process` events in ascending chronological\n+order:\n+\n+[source,js]\n+----\n+{ \"index\" : { \"_id\" : \"1\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"attrib\" }, ...}\n+{ \"index\" : { \"_id\" : \"2\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"attrib\" }, ...}\n+{ \"index\" : { \"_id\" : \"3\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"bash\" }, ...}\n+{ \"index\" : { \"_id\" : \"4\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"bash\" }, ...}\n+{ \"index\" : { \"_id\" : \"5\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"bash\" }, ...}\n+{ \"index\" : { \"_id\" : \"6\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"attrib\" }, ...}\n+{ \"index\" : { \"_id\" : \"7\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"attrib\" }, ...}\n+{ \"index\" : { \"_id\" : \"8\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"bash\" }, ...}\n+{ \"index\" : { \"_id\" : \"9\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"cat\" }, ...}\n+{ \"index\" : { \"_id\" : \"10\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"cat\" }, ...}\n+{ \"index\" : { \"_id\" : \"11\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"cat\" }, ...}\n+----\n+// NOTCONSOLE\n+\n+An EQL sequence query searches the data set:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9066d7887b64ef6d21524debeee87580ee2f959d"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE0MTk2Ng==", "bodyText": "Sounds good. I'll get this merged in and work on adding some diagrams as part of a separate PR.", "url": "https://github.com/elastic/elasticsearch/pull/65794#discussion_r536141966", "createdAt": "2020-12-04T14:34:09Z", "author": {"login": "jrodewig"}, "path": "docs/reference/eql/syntax.asciidoc", "diffHunk": "@@ -771,3 +771,147 @@ three double quotes (`\"\"\"`) instead.\n *** {eql-ref}/pipes.html#sort[`sort`]\n *** {eql-ref}/pipes.html#unique[`unique`]\n *** {eql-ref}/pipes.html#unique-count[`unique_count`]\n+\n+[discrete]\n+[[eql-how-sequence-queries-handle-matches]]\n+==== How sequence queries handle matches\n+\n+<<eql-sequences,Sequence queries>> don't find all potential matches for a\n+sequence. This approach would be too slow and costly for large event data sets.\n+Instead, a sequence query handles pending sequence matches as a\n+{wikipedia}/Finite-state_machine[state machine]:\n+\n+* Each event item in the sequence query is a state in the machine.\n+* Only one pending sequence can be in each state at a time.\n+* If two pending sequences are in the same state at the same time, the most\n+recent sequence overwrites the older one.\n+* If the query includes <<eql-by-keyword,`by` fields>>, the query uses a\n+separate state machine for each unique `by` field value.\n+\n+.*Example* \n+[%collapsible]\n+====\n+A data set contains the following `process` events in ascending chronological\n+order:\n+\n+[source,js]\n+----\n+{ \"index\" : { \"_id\" : \"1\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"attrib\" }, ...}\n+{ \"index\" : { \"_id\" : \"2\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"attrib\" }, ...}\n+{ \"index\" : { \"_id\" : \"3\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"bash\" }, ...}\n+{ \"index\" : { \"_id\" : \"4\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"bash\" }, ...}\n+{ \"index\" : { \"_id\" : \"5\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"bash\" }, ...}\n+{ \"index\" : { \"_id\" : \"6\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"attrib\" }, ...}\n+{ \"index\" : { \"_id\" : \"7\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"attrib\" }, ...}\n+{ \"index\" : { \"_id\" : \"8\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"bash\" }, ...}\n+{ \"index\" : { \"_id\" : \"9\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"cat\" }, ...}\n+{ \"index\" : { \"_id\" : \"10\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"cat\" }, ...}\n+{ \"index\" : { \"_id\" : \"11\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"cat\" }, ...}\n+----\n+// NOTCONSOLE\n+\n+An EQL sequence query searches the data set:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA0NDUzNw=="}, "originalCommit": {"oid": "9066d7887b64ef6d21524debeee87580ee2f959d"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE0NDcwNg==", "bodyText": "Related issue: #65888", "url": "https://github.com/elastic/elasticsearch/pull/65794#discussion_r536144706", "createdAt": "2020-12-04T14:38:17Z", "author": {"login": "jrodewig"}, "path": "docs/reference/eql/syntax.asciidoc", "diffHunk": "@@ -771,3 +771,147 @@ three double quotes (`\"\"\"`) instead.\n *** {eql-ref}/pipes.html#sort[`sort`]\n *** {eql-ref}/pipes.html#unique[`unique`]\n *** {eql-ref}/pipes.html#unique-count[`unique_count`]\n+\n+[discrete]\n+[[eql-how-sequence-queries-handle-matches]]\n+==== How sequence queries handle matches\n+\n+<<eql-sequences,Sequence queries>> don't find all potential matches for a\n+sequence. This approach would be too slow and costly for large event data sets.\n+Instead, a sequence query handles pending sequence matches as a\n+{wikipedia}/Finite-state_machine[state machine]:\n+\n+* Each event item in the sequence query is a state in the machine.\n+* Only one pending sequence can be in each state at a time.\n+* If two pending sequences are in the same state at the same time, the most\n+recent sequence overwrites the older one.\n+* If the query includes <<eql-by-keyword,`by` fields>>, the query uses a\n+separate state machine for each unique `by` field value.\n+\n+.*Example* \n+[%collapsible]\n+====\n+A data set contains the following `process` events in ascending chronological\n+order:\n+\n+[source,js]\n+----\n+{ \"index\" : { \"_id\" : \"1\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"attrib\" }, ...}\n+{ \"index\" : { \"_id\" : \"2\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"attrib\" }, ...}\n+{ \"index\" : { \"_id\" : \"3\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"bash\" }, ...}\n+{ \"index\" : { \"_id\" : \"4\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"bash\" }, ...}\n+{ \"index\" : { \"_id\" : \"5\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"bash\" }, ...}\n+{ \"index\" : { \"_id\" : \"6\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"attrib\" }, ...}\n+{ \"index\" : { \"_id\" : \"7\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"attrib\" }, ...}\n+{ \"index\" : { \"_id\" : \"8\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"bash\" }, ...}\n+{ \"index\" : { \"_id\" : \"9\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"cat\" }, ...}\n+{ \"index\" : { \"_id\" : \"10\" } }\n+{ \"user\": { \"name\": \"elkbee\" }, \"process\": { \"name\": \"cat\" }, ...}\n+{ \"index\" : { \"_id\" : \"11\" } }\n+{ \"user\": { \"name\": \"root\" }, \"process\": { \"name\": \"cat\" }, ...}\n+----\n+// NOTCONSOLE\n+\n+An EQL sequence query searches the data set:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA0NDUzNw=="}, "originalCommit": {"oid": "9066d7887b64ef6d21524debeee87580ee2f959d"}, "originalPosition": 54}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1831, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}