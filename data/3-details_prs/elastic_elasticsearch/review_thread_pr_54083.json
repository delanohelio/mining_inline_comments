{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkyOTc4MTYw", "number": 54083, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxNToxMDowNVrODrQiLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMToyNjozNlrODrmgVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2Njg2MjU0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/datastream/CreateDataStreamAction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxNToxMDowNVrOF7fykg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxNToxMDowNVrOF7fykg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzkzMTE1NA==", "bodyText": "I think MetaDataCreateIndexService.validateIndexName() or MetaDataCreateIndexService.validateIndexOrAliasName() could be reused?", "url": "https://github.com/elastic/elasticsearch/pull/54083#discussion_r397931154", "createdAt": "2020-03-25T15:10:05Z", "author": {"login": "martijnvg"}, "path": "server/src/main/java/org/elasticsearch/action/admin/indices/datastream/CreateDataStreamAction.java", "diffHunk": "@@ -161,15 +165,63 @@ public void clusterStateProcessed(String source, ClusterState oldState, ClusterS\n         }\n \n         static ClusterState createDataStream(ClusterState currentState, Request request) {\n+            List<String> validationErrors = new ArrayList<>();\n             if (currentState.metaData().dataStreams().containsKey(request.name)) {\n-                throw new IllegalArgumentException(\"data_stream [\" + request.name + \"] already exists\");\n+                validationErrors.add(\"data_stream [\" + request.name + \"] already exists\");\n             }\n \n-            MetaData.Builder builder = MetaData.builder(currentState.metaData()).put(\n-                new DataStream(request.name, request.timestampFieldName, Collections.emptyList()));\n+            validationErrors.addAll(validateDataStreamName(request.name));\n \n-            logger.info(\"adding data stream [{}]\", request.name);\n-            return ClusterState.builder(currentState).metaData(builder).build();\n+            if (currentState.metaData().hasIndex(request.name)) {\n+                validationErrors.add(\"data_stream [\" + request.name + \"] conflicts with existing index\");\n+            }\n+\n+            if (currentState.metaData().hasAlias(request.name)) {\n+                validationErrors.add(\"data_stream [\" + request.name + \"] conflicts with existing alias\");\n+            }\n+\n+            final String backingIndexPrefix = (request.name.startsWith(\".\") ? \"\" : \".\") + request.name + \"-\";\n+            for (String indexName : currentState.metaData().getConcreteAllIndices()) {\n+                if (indexName.startsWith(backingIndexPrefix)) {\n+                    validationErrors.add(\n+                        \"data_stream [\" + request.name + \"] could create backing indices that conflict with existing indices\");\n+                    break;\n+                }\n+            }\n+\n+            if (validationErrors.isEmpty()) {\n+                MetaData.Builder builder = MetaData.builder(currentState.metaData()).put(\n+                    new DataStream(request.name, request.timestampFieldName, Collections.emptyList()));\n+                logger.info(\"adding data stream [{}]\", request.name);\n+                return ClusterState.builder(currentState).metaData(builder).build();\n+            } else {\n+                ValidationException ex = new ValidationException();\n+                ex.addValidationErrors(validationErrors);\n+                throw new IllegalArgumentException(ex);\n+            }\n+        }\n+\n+        private static List<String> validateDataStreamName(String name) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43c52a7a64229116a74979dfffe37ec478a9db24"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2NzUyOTg4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetaData.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxNzozMTowMlrOF7mbQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxOTo0Nzo0NFrOF7romQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODAzOTg3NA==", "bodyText": "I'm not thrilled with this nested loop that will run in a cluster state update thread, but I think we need to validate against potential backing index conflicts.", "url": "https://github.com/elastic/elasticsearch/pull/54083#discussion_r398039874", "createdAt": "2020-03-25T17:31:02Z", "author": {"login": "danhermann"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetaData.java", "diffHunk": "@@ -1315,20 +1315,36 @@ public MetaData build() {\n                 // iterate again and constructs a helpful message\n                 ArrayList<String> duplicates = new ArrayList<>();\n                 for (ObjectCursor<IndexMetaData> cursor : indices.values()) {\n-                    for (String alias: duplicateAliasesIndices) {\n+                    for (String alias : duplicateAliasesIndices) {\n                         if (cursor.value.getAliases().containsKey(alias)) {\n                             duplicates.add(alias + \" (alias of \" + cursor.value.getIndex() + \")\");\n                         }\n                     }\n                 }\n                 assert duplicates.size() > 0;\n                 throw new IllegalStateException(\"index and alias names need to be unique, but the following duplicates were found [\"\n-                    + Strings.collectionToCommaDelimitedString(duplicates)+ \"]\");\n+                    + Strings.collectionToCommaDelimitedString(duplicates) + \"]\");\n \n             }\n \n             SortedMap<String, AliasOrIndex> aliasAndIndexLookup = Collections.unmodifiableSortedMap(buildAliasAndIndexLookup());\n \n+            DataStreamMetadata dsMetadata = (DataStreamMetadata) customs.get(DataStreamMetadata.TYPE);\n+            if (dsMetadata != null) {\n+                for (DataStream ds : dsMetadata.dataStreams().values()) {\n+                    if (aliasAndIndexLookup.containsKey(ds.getName())) {\n+                        throw new IllegalStateException(\"data stream [\" + ds.getName() + \"] conflicts with existing index or alias\");\n+                    }\n+\n+                    final String backingIndexPrefix = (ds.getName().startsWith(\".\") ? \"\" : \".\") + ds.getName() + \"-\";\n+                    for (String indexName : allIndices) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2e4483604386c43d7b19a5b768d65917bec9d19"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODExODY4MQ==", "bodyText": "I think we don't have to iterate over all indices and can reuse aliasAndIndexLookup sorted map.\nIf we use: aliasAndIndexLookup.subMap(...) then this returns all aliases / indices that share the\nsame prefix are returned and we can check if it is empty and if not throw an error.\nThis method is also used in the WildcardExpressionResolver#suffixWildcard(...) method.", "url": "https://github.com/elastic/elasticsearch/pull/54083#discussion_r398118681", "createdAt": "2020-03-25T19:35:48Z", "author": {"login": "martijnvg"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetaData.java", "diffHunk": "@@ -1315,20 +1315,36 @@ public MetaData build() {\n                 // iterate again and constructs a helpful message\n                 ArrayList<String> duplicates = new ArrayList<>();\n                 for (ObjectCursor<IndexMetaData> cursor : indices.values()) {\n-                    for (String alias: duplicateAliasesIndices) {\n+                    for (String alias : duplicateAliasesIndices) {\n                         if (cursor.value.getAliases().containsKey(alias)) {\n                             duplicates.add(alias + \" (alias of \" + cursor.value.getIndex() + \")\");\n                         }\n                     }\n                 }\n                 assert duplicates.size() > 0;\n                 throw new IllegalStateException(\"index and alias names need to be unique, but the following duplicates were found [\"\n-                    + Strings.collectionToCommaDelimitedString(duplicates)+ \"]\");\n+                    + Strings.collectionToCommaDelimitedString(duplicates) + \"]\");\n \n             }\n \n             SortedMap<String, AliasOrIndex> aliasAndIndexLookup = Collections.unmodifiableSortedMap(buildAliasAndIndexLookup());\n \n+            DataStreamMetadata dsMetadata = (DataStreamMetadata) customs.get(DataStreamMetadata.TYPE);\n+            if (dsMetadata != null) {\n+                for (DataStream ds : dsMetadata.dataStreams().values()) {\n+                    if (aliasAndIndexLookup.containsKey(ds.getName())) {\n+                        throw new IllegalStateException(\"data stream [\" + ds.getName() + \"] conflicts with existing index or alias\");\n+                    }\n+\n+                    final String backingIndexPrefix = (ds.getName().startsWith(\".\") ? \"\" : \".\") + ds.getName() + \"-\";\n+                    for (String indexName : allIndices) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODAzOTg3NA=="}, "originalCommit": {"oid": "b2e4483604386c43d7b19a5b768d65917bec9d19"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODEyNTIwOQ==", "bodyText": "maybe also move this logic into a private method?", "url": "https://github.com/elastic/elasticsearch/pull/54083#discussion_r398125209", "createdAt": "2020-03-25T19:47:44Z", "author": {"login": "martijnvg"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetaData.java", "diffHunk": "@@ -1315,20 +1315,36 @@ public MetaData build() {\n                 // iterate again and constructs a helpful message\n                 ArrayList<String> duplicates = new ArrayList<>();\n                 for (ObjectCursor<IndexMetaData> cursor : indices.values()) {\n-                    for (String alias: duplicateAliasesIndices) {\n+                    for (String alias : duplicateAliasesIndices) {\n                         if (cursor.value.getAliases().containsKey(alias)) {\n                             duplicates.add(alias + \" (alias of \" + cursor.value.getIndex() + \")\");\n                         }\n                     }\n                 }\n                 assert duplicates.size() > 0;\n                 throw new IllegalStateException(\"index and alias names need to be unique, but the following duplicates were found [\"\n-                    + Strings.collectionToCommaDelimitedString(duplicates)+ \"]\");\n+                    + Strings.collectionToCommaDelimitedString(duplicates) + \"]\");\n \n             }\n \n             SortedMap<String, AliasOrIndex> aliasAndIndexLookup = Collections.unmodifiableSortedMap(buildAliasAndIndexLookup());\n \n+            DataStreamMetadata dsMetadata = (DataStreamMetadata) customs.get(DataStreamMetadata.TYPE);\n+            if (dsMetadata != null) {\n+                for (DataStream ds : dsMetadata.dataStreams().values()) {\n+                    if (aliasAndIndexLookup.containsKey(ds.getName())) {\n+                        throw new IllegalStateException(\"data stream [\" + ds.getName() + \"] conflicts with existing index or alias\");\n+                    }\n+\n+                    final String backingIndexPrefix = (ds.getName().startsWith(\".\") ? \"\" : \".\") + ds.getName() + \"-\";\n+                    for (String indexName : allIndices) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODAzOTg3NA=="}, "originalCommit": {"oid": "b2e4483604386c43d7b19a5b768d65917bec9d19"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2ODM3NzQ2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetaData.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQyMToxOTo0MFrOF7uxPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQyMToxOTo0MFrOF7uxPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODE3NjU3NA==", "bodyText": "nit: a backing index could also conflict with an alias (or data stream in the future)", "url": "https://github.com/elastic/elasticsearch/pull/54083#discussion_r398176574", "createdAt": "2020-03-25T21:19:40Z", "author": {"login": "martijnvg"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetaData.java", "diffHunk": "@@ -1371,6 +1372,25 @@ public MetaData build() {\n             return aliasAndIndexLookup;\n         }\n \n+        private void validateDataStreams(SortedMap<String, AliasOrIndex> aliasAndIndexLookup) {\n+            DataStreamMetadata dsMetadata = (DataStreamMetadata) customs.get(DataStreamMetadata.TYPE);\n+            if (dsMetadata != null) {\n+                for (DataStream ds : dsMetadata.dataStreams().values()) {\n+                    if (aliasAndIndexLookup.containsKey(ds.getName())) {\n+                        throw new IllegalStateException(\"data stream [\" + ds.getName() + \"] conflicts with existing index or alias\");\n+                    }\n+\n+                    final String backingIndexPrefixFrom = (ds.getName().startsWith(\".\") ? \"\" : \".\") + ds.getName() + \"-\";\n+                    final String backingIndexPrefixTo = (ds.getName().startsWith(\".\") ? \"\" : \".\") + ds.getName() + \".\";\n+                    SortedMap<?, ?> map = aliasAndIndexLookup.subMap(backingIndexPrefixFrom, backingIndexPrefixTo);\n+                    if (map.size() != 0) {\n+                        throw new IllegalStateException(\n+                            \"data stream [\" + ds.getName() + \"] could create backing indices that conflict with existing indices\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b67088e0a4aafb983045c0a2f1e3048561e712a4"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3MDQyNzEzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetaData.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMToxNzowNFrOF8CH1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMToxNzowNFrOF8CH1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQ5MzY1Mg==", "bodyText": "Should we include the list of conflicting names in the message or at least the first few?", "url": "https://github.com/elastic/elasticsearch/pull/54083#discussion_r398493652", "createdAt": "2020-03-26T11:17:04Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetaData.java", "diffHunk": "@@ -1371,6 +1372,23 @@ public MetaData build() {\n             return aliasAndIndexLookup;\n         }\n \n+        private void validateDataStreams(SortedMap<String, AliasOrIndex> aliasAndIndexLookup) {\n+            DataStreamMetadata dsMetadata = (DataStreamMetadata) customs.get(DataStreamMetadata.TYPE);\n+            if (dsMetadata != null) {\n+                for (DataStream ds : dsMetadata.dataStreams().values()) {\n+                    if (aliasAndIndexLookup.containsKey(ds.getName())) {\n+                        throw new IllegalStateException(\"data stream [\" + ds.getName() + \"] conflicts with existing index or alias\");\n+                    }\n+\n+                    SortedMap<?, ?> map = aliasAndIndexLookup.subMap(ds.getName() + \"-\", ds.getName() + \".\"); // '.' is the char after '-'\n+                    if (map.size() != 0) {\n+                        throw new IllegalStateException(\"data stream [\" + ds.getName() +\n+                            \"] could create backing indices that conflict with existing indices or aliases\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b56ebf39343226d2083bd08afe357b8e300f6e4"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3MDQzNTE2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/datastream/CreateDataStreamAction.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMToxOToyNVrOF8CM4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMToxOToyNVrOF8CM4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQ5NDk0NQ==", "bodyText": "Should we rename the method to either \"validateIndexSpaceName\" or \"validateAbstractIndexName\"? Can be done in a follow-up when the naming discussion is clarified.", "url": "https://github.com/elastic/elasticsearch/pull/54083#discussion_r398494945", "createdAt": "2020-03-26T11:19:25Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/action/admin/indices/datastream/CreateDataStreamAction.java", "diffHunk": "@@ -165,9 +166,11 @@ static ClusterState createDataStream(ClusterState currentState, Request request)\n                 throw new IllegalArgumentException(\"data_stream [\" + request.name + \"] already exists\");\n             }\n \n+            MetaDataCreateIndexService.validateIndexOrAliasName(request.name,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b56ebf39343226d2083bd08afe357b8e300f6e4"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3MDQ2MjI5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/datastream/CreateDataStreamAction.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMToyNjozNlrOF8Cc_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQyMDozMzo1NlrOF8ZS4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQ5OTA2OA==", "bodyText": "The other usages of validateIndexOrAliasName throw a dedicated exception. I am not entirely sure if IllegalArgumentException results in the same RestStatus and message handling. Could we add this to the rest test suite?", "url": "https://github.com/elastic/elasticsearch/pull/54083#discussion_r398499068", "createdAt": "2020-03-26T11:26:36Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/action/admin/indices/datastream/CreateDataStreamAction.java", "diffHunk": "@@ -165,9 +166,11 @@ static ClusterState createDataStream(ClusterState currentState, Request request)\n                 throw new IllegalArgumentException(\"data_stream [\" + request.name + \"] already exists\");\n             }\n \n+            MetaDataCreateIndexService.validateIndexOrAliasName(request.name,\n+                (s1, s2) -> new IllegalArgumentException(\"data_stream [\" + s1 + \"] \" + s2));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b56ebf39343226d2083bd08afe357b8e300f6e4"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODg3MzMxMw==", "bodyText": "Added a REST test to enforce that the same HTTP 400 response code is returned.", "url": "https://github.com/elastic/elasticsearch/pull/54083#discussion_r398873313", "createdAt": "2020-03-26T20:33:56Z", "author": {"login": "danhermann"}, "path": "server/src/main/java/org/elasticsearch/action/admin/indices/datastream/CreateDataStreamAction.java", "diffHunk": "@@ -165,9 +166,11 @@ static ClusterState createDataStream(ClusterState currentState, Request request)\n                 throw new IllegalArgumentException(\"data_stream [\" + request.name + \"] already exists\");\n             }\n \n+            MetaDataCreateIndexService.validateIndexOrAliasName(request.name,\n+                (s1, s2) -> new IllegalArgumentException(\"data_stream [\" + s1 + \"] \" + s2));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQ5OTA2OA=="}, "originalCommit": {"oid": "3b56ebf39343226d2083bd08afe357b8e300f6e4"}, "originalPosition": 13}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4165, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}