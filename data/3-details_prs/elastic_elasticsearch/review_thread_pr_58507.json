{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM5MzM5NTQ4", "number": 58507, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxOToyMzoyMlrOEI5N6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzoxNjozN1rOERisSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3NzYxNTE0OnYy", "diffSide": "RIGHT", "path": "test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxOToyMzoyMlrOGpIrUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNjo1NDo1M1rOGsV7rQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTc4Njk2MQ==", "bodyText": "I think Optional prefers things to look like:\nRandomIndexWriter indexWriter = indexWriterConfg.map(c -> new RandomIndexWriter(random(), directory, c).orElseGet(() -> new RandomIndexWriter(random(), directory);", "url": "https://github.com/elastic/elasticsearch/pull/58507#discussion_r445786961", "createdAt": "2020-06-25T19:23:22Z", "author": {"login": "nik9000"}, "path": "test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java", "diffHunk": "@@ -535,13 +537,27 @@ protected void doAssertReducedMultiBucketConsumer(Aggregation agg, MultiBucketCo\n     }\n \n     protected <T extends AggregationBuilder, V extends InternalAggregation> void testCase(\n-            T aggregationBuilder,\n-            Query query,\n-            CheckedConsumer<RandomIndexWriter, IOException> buildIndex,\n-            Consumer<V> verify,\n-            MappedFieldType... fieldTypes) throws IOException {\n+        T aggregationBuilder,\n+        Query query,\n+        CheckedConsumer<RandomIndexWriter, IOException> buildIndex,\n+        Consumer<V> verify,\n+        MappedFieldType... fieldTypes) throws IOException {\n+        testCase(aggregationBuilder, Optional.empty(), query, buildIndex, verify, fieldTypes);\n+    }\n+\n+    protected <T extends AggregationBuilder, V extends InternalAggregation> void testCase(\n+        T aggregationBuilder,\n+        Optional<IndexWriterConfig> indexWriterConfig, Query query,\n+        CheckedConsumer<RandomIndexWriter, IOException> buildIndex,\n+        Consumer<V> verify,\n+        MappedFieldType... fieldTypes) throws IOException {\n         try (Directory directory = newDirectory()) {\n-            RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory);\n+            RandomIndexWriter indexWriter;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3223032d5192f0702f41a52ea8e8ab18eaaa4009"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE0OTg2OQ==", "bodyText": "Yeah, I agree that's what Optional would like this to look like.  Unfortunately, new RandomIndexWriter can throw an IOException, and the lambda Optional#map and friends expect is declared to not throw.  I could do something to wrap and throw an unchecked exception, but I think it'd be less clear than just using the if/else block.  Open to suggestions if you know a way to do this that isn't terrible.", "url": "https://github.com/elastic/elasticsearch/pull/58507#discussion_r449149869", "createdAt": "2020-07-02T16:54:53Z", "author": {"login": "not-napoleon"}, "path": "test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java", "diffHunk": "@@ -535,13 +537,27 @@ protected void doAssertReducedMultiBucketConsumer(Aggregation agg, MultiBucketCo\n     }\n \n     protected <T extends AggregationBuilder, V extends InternalAggregation> void testCase(\n-            T aggregationBuilder,\n-            Query query,\n-            CheckedConsumer<RandomIndexWriter, IOException> buildIndex,\n-            Consumer<V> verify,\n-            MappedFieldType... fieldTypes) throws IOException {\n+        T aggregationBuilder,\n+        Query query,\n+        CheckedConsumer<RandomIndexWriter, IOException> buildIndex,\n+        Consumer<V> verify,\n+        MappedFieldType... fieldTypes) throws IOException {\n+        testCase(aggregationBuilder, Optional.empty(), query, buildIndex, verify, fieldTypes);\n+    }\n+\n+    protected <T extends AggregationBuilder, V extends InternalAggregation> void testCase(\n+        T aggregationBuilder,\n+        Optional<IndexWriterConfig> indexWriterConfig, Query query,\n+        CheckedConsumer<RandomIndexWriter, IOException> buildIndex,\n+        Consumer<V> verify,\n+        MappedFieldType... fieldTypes) throws IOException {\n         try (Directory directory = newDirectory()) {\n-            RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory);\n+            RandomIndexWriter indexWriter;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTc4Njk2MQ=="}, "originalCommit": {"oid": "3223032d5192f0702f41a52ea8e8ab18eaaa4009"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3NzYyMTkwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/wildcard/src/test/java/org/elasticsearch/xpack/wildcard/mapper/WildcardFieldAggregationTests.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxOToyNTozNFrOGpIvhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxOToyNTozNFrOGpIvhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTc4ODAzNg==", "bodyText": "This says \"when I don't tell you what analyzer to use then use the wildcard analyzer\". I believe Elasticsearch always sets the analyzer. The wildcard field mapper looks like it does. I don't think either test needs this.", "url": "https://github.com/elastic/elasticsearch/pull/58507#discussion_r445788036", "createdAt": "2020-06-25T19:25:34Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/wildcard/src/test/java/org/elasticsearch/xpack/wildcard/mapper/WildcardFieldAggregationTests.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.wildcard.mapper;\n+\n+import org.apache.lucene.document.Document;\n+import org.apache.lucene.index.IndexWriterConfig;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.index.RandomIndexWriter;\n+import org.apache.lucene.search.MatchAllDocsQuery;\n+import org.elasticsearch.index.mapper.ContentPath;\n+import org.elasticsearch.index.mapper.Mapper;\n+import org.elasticsearch.index.mapper.ParseContext;\n+import org.elasticsearch.search.aggregations.AggregatorTestCase;\n+import org.elasticsearch.search.aggregations.BucketOrder;\n+import org.elasticsearch.search.aggregations.bucket.composite.CompositeAggregationBuilder;\n+import org.elasticsearch.search.aggregations.bucket.composite.InternalComposite;\n+import org.elasticsearch.search.aggregations.bucket.composite.TermsValuesSourceBuilder;\n+import org.elasticsearch.search.aggregations.bucket.terms.StringTerms;\n+import org.elasticsearch.search.aggregations.bucket.terms.TermsAggregationBuilder;\n+import org.elasticsearch.search.aggregations.support.AggregationInspectionHelper;\n+import org.junit.Before;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+public class WildcardFieldAggregationTests extends AggregatorTestCase {\n+    private static final String WILDCARD_FIELD_NAME = \"wildcard_field\";\n+    private static final int MAX_FIELD_LENGTH = 30;\n+\n+    private Optional<IndexWriterConfig> iwc;\n+    private WildcardFieldMapper wildcardFieldMapper;\n+    private WildcardFieldMapper.WildcardFieldType wildcardFieldType;\n+\n+\n+    @Before\n+    public void setup() {\n+        // These settings are lifted out of WildcardFieldMapperTests\n+        IndexWriterConfig iwc = newIndexWriterConfig(WildcardFieldMapper.WILDCARD_ANALYZER);\n+        iwc.setMergePolicy(newTieredMergePolicy(random()));\n+        this.iwc = Optional.of(iwc);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3223032d5192f0702f41a52ea8e8ab18eaaa4009"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3NzY1Mjk5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/wildcard/src/test/java/org/elasticsearch/xpack/wildcard/mapper/WildcardFieldAggregationTests.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxOTozNjowOVrOGpJDOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxOTozNjowOVrOGpJDOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTc5MzA4MA==", "bodyText": "(StringTerms results) -> should do the same thing with a little less ceremony.", "url": "https://github.com/elastic/elasticsearch/pull/58507#discussion_r445793080", "createdAt": "2020-06-25T19:36:09Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/wildcard/src/test/java/org/elasticsearch/xpack/wildcard/mapper/WildcardFieldAggregationTests.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.wildcard.mapper;\n+\n+import org.apache.lucene.document.Document;\n+import org.apache.lucene.index.IndexWriterConfig;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.index.RandomIndexWriter;\n+import org.apache.lucene.search.MatchAllDocsQuery;\n+import org.elasticsearch.index.mapper.ContentPath;\n+import org.elasticsearch.index.mapper.Mapper;\n+import org.elasticsearch.index.mapper.ParseContext;\n+import org.elasticsearch.search.aggregations.AggregatorTestCase;\n+import org.elasticsearch.search.aggregations.BucketOrder;\n+import org.elasticsearch.search.aggregations.bucket.composite.CompositeAggregationBuilder;\n+import org.elasticsearch.search.aggregations.bucket.composite.InternalComposite;\n+import org.elasticsearch.search.aggregations.bucket.composite.TermsValuesSourceBuilder;\n+import org.elasticsearch.search.aggregations.bucket.terms.StringTerms;\n+import org.elasticsearch.search.aggregations.bucket.terms.TermsAggregationBuilder;\n+import org.elasticsearch.search.aggregations.support.AggregationInspectionHelper;\n+import org.junit.Before;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+public class WildcardFieldAggregationTests extends AggregatorTestCase {\n+    private static final String WILDCARD_FIELD_NAME = \"wildcard_field\";\n+    private static final int MAX_FIELD_LENGTH = 30;\n+\n+    private Optional<IndexWriterConfig> iwc;\n+    private WildcardFieldMapper wildcardFieldMapper;\n+    private WildcardFieldMapper.WildcardFieldType wildcardFieldType;\n+\n+\n+    @Before\n+    public void setup() {\n+        // These settings are lifted out of WildcardFieldMapperTests\n+        IndexWriterConfig iwc = newIndexWriterConfig(WildcardFieldMapper.WILDCARD_ANALYZER);\n+        iwc.setMergePolicy(newTieredMergePolicy(random()));\n+        this.iwc = Optional.of(iwc);\n+\n+        WildcardFieldMapper.Builder builder = new WildcardFieldMapper.Builder(WILDCARD_FIELD_NAME);\n+        builder.ignoreAbove(MAX_FIELD_LENGTH);\n+        wildcardFieldMapper = builder.build(new Mapper.BuilderContext(createIndexSettings().getSettings(), new ContentPath(0)));\n+\n+        wildcardFieldType = wildcardFieldMapper.fieldType();\n+    }\n+\n+    private void addFields(ParseContext.Document parseDoc, Document doc, String docContent) throws IOException {\n+        ArrayList<IndexableField> fields = new ArrayList<>();\n+        wildcardFieldMapper.createFields(docContent, parseDoc, fields);\n+\n+        for (IndexableField indexableField : fields) {\n+            doc.add(indexableField);\n+        }\n+    }\n+\n+    private void indexDoc(ParseContext.Document parseDoc, Document doc, RandomIndexWriter iw) throws IOException {\n+        IndexableField field = parseDoc.getByKey(wildcardFieldMapper.name());\n+        if (field != null) {\n+            doc.add(field);\n+        }\n+        iw.addDocument(doc);\n+    }\n+\n+    private void indexStrings(RandomIndexWriter iw, String... values) throws IOException {\n+        Document doc = new Document();\n+        ParseContext.Document parseDoc = new ParseContext.Document();\n+        for (String value : values) {\n+            addFields(parseDoc, doc, value);\n+        }\n+        indexDoc(parseDoc, doc, iw);\n+    }\n+\n+    public void testTermsAggregation() throws IOException {\n+        TermsAggregationBuilder aggregationBuilder = new TermsAggregationBuilder(\"_name\")\n+            .field(WILDCARD_FIELD_NAME)\n+            .order(BucketOrder.key(true));\n+\n+        testCase(aggregationBuilder,\n+            iwc, new MatchAllDocsQuery(),\n+            iw -> {\n+                indexStrings(iw, \"a\");\n+                indexStrings(iw, \"a\");\n+                indexStrings(iw, \"b\");\n+                indexStrings(iw, \"b\");\n+                indexStrings(iw, \"b\");\n+                indexStrings(iw, \"c\");\n+            },\n+            (Consumer<StringTerms>) result -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3223032d5192f0702f41a52ea8e8ab18eaaa4009"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3NzY1NjU2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/wildcard/src/test/java/org/elasticsearch/xpack/wildcard/mapper/WildcardFieldAggregationTests.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxOTozNzoxOFrOGpJFdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxOTozNzoxOFrOGpJFdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTc5MzY1Mg==", "bodyText": "Could you try running with aggregateAfter set? I think that'd be useful to make sure works as well.", "url": "https://github.com/elastic/elasticsearch/pull/58507#discussion_r445793652", "createdAt": "2020-06-25T19:37:18Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/wildcard/src/test/java/org/elasticsearch/xpack/wildcard/mapper/WildcardFieldAggregationTests.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.wildcard.mapper;\n+\n+import org.apache.lucene.document.Document;\n+import org.apache.lucene.index.IndexWriterConfig;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.index.RandomIndexWriter;\n+import org.apache.lucene.search.MatchAllDocsQuery;\n+import org.elasticsearch.index.mapper.ContentPath;\n+import org.elasticsearch.index.mapper.Mapper;\n+import org.elasticsearch.index.mapper.ParseContext;\n+import org.elasticsearch.search.aggregations.AggregatorTestCase;\n+import org.elasticsearch.search.aggregations.BucketOrder;\n+import org.elasticsearch.search.aggregations.bucket.composite.CompositeAggregationBuilder;\n+import org.elasticsearch.search.aggregations.bucket.composite.InternalComposite;\n+import org.elasticsearch.search.aggregations.bucket.composite.TermsValuesSourceBuilder;\n+import org.elasticsearch.search.aggregations.bucket.terms.StringTerms;\n+import org.elasticsearch.search.aggregations.bucket.terms.TermsAggregationBuilder;\n+import org.elasticsearch.search.aggregations.support.AggregationInspectionHelper;\n+import org.junit.Before;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+public class WildcardFieldAggregationTests extends AggregatorTestCase {\n+    private static final String WILDCARD_FIELD_NAME = \"wildcard_field\";\n+    private static final int MAX_FIELD_LENGTH = 30;\n+\n+    private Optional<IndexWriterConfig> iwc;\n+    private WildcardFieldMapper wildcardFieldMapper;\n+    private WildcardFieldMapper.WildcardFieldType wildcardFieldType;\n+\n+\n+    @Before\n+    public void setup() {\n+        // These settings are lifted out of WildcardFieldMapperTests\n+        IndexWriterConfig iwc = newIndexWriterConfig(WildcardFieldMapper.WILDCARD_ANALYZER);\n+        iwc.setMergePolicy(newTieredMergePolicy(random()));\n+        this.iwc = Optional.of(iwc);\n+\n+        WildcardFieldMapper.Builder builder = new WildcardFieldMapper.Builder(WILDCARD_FIELD_NAME);\n+        builder.ignoreAbove(MAX_FIELD_LENGTH);\n+        wildcardFieldMapper = builder.build(new Mapper.BuilderContext(createIndexSettings().getSettings(), new ContentPath(0)));\n+\n+        wildcardFieldType = wildcardFieldMapper.fieldType();\n+    }\n+\n+    private void addFields(ParseContext.Document parseDoc, Document doc, String docContent) throws IOException {\n+        ArrayList<IndexableField> fields = new ArrayList<>();\n+        wildcardFieldMapper.createFields(docContent, parseDoc, fields);\n+\n+        for (IndexableField indexableField : fields) {\n+            doc.add(indexableField);\n+        }\n+    }\n+\n+    private void indexDoc(ParseContext.Document parseDoc, Document doc, RandomIndexWriter iw) throws IOException {\n+        IndexableField field = parseDoc.getByKey(wildcardFieldMapper.name());\n+        if (field != null) {\n+            doc.add(field);\n+        }\n+        iw.addDocument(doc);\n+    }\n+\n+    private void indexStrings(RandomIndexWriter iw, String... values) throws IOException {\n+        Document doc = new Document();\n+        ParseContext.Document parseDoc = new ParseContext.Document();\n+        for (String value : values) {\n+            addFields(parseDoc, doc, value);\n+        }\n+        indexDoc(parseDoc, doc, iw);\n+    }\n+\n+    public void testTermsAggregation() throws IOException {\n+        TermsAggregationBuilder aggregationBuilder = new TermsAggregationBuilder(\"_name\")\n+            .field(WILDCARD_FIELD_NAME)\n+            .order(BucketOrder.key(true));\n+\n+        testCase(aggregationBuilder,\n+            iwc, new MatchAllDocsQuery(),\n+            iw -> {\n+                indexStrings(iw, \"a\");\n+                indexStrings(iw, \"a\");\n+                indexStrings(iw, \"b\");\n+                indexStrings(iw, \"b\");\n+                indexStrings(iw, \"b\");\n+                indexStrings(iw, \"c\");\n+            },\n+            (Consumer<StringTerms>) result -> {\n+                assertTrue(AggregationInspectionHelper.hasValue(result));\n+\n+                assertEquals(3, result.getBuckets().size());\n+                assertEquals(\"a\", result.getBuckets().get(0).getKeyAsString());\n+                assertEquals(2L, result.getBuckets().get(0).getDocCount());\n+                assertEquals(\"b\", result.getBuckets().get(1).getKeyAsString());\n+                assertEquals(3L, result.getBuckets().get(1).getDocCount());\n+                assertEquals(\"c\", result.getBuckets().get(2).getKeyAsString());\n+                assertEquals(1L, result.getBuckets().get(2).getDocCount());\n+            },\n+            wildcardFieldType);\n+    }\n+\n+    public void testCompositeTermsAggregation() throws IOException {\n+        CompositeAggregationBuilder aggregationBuilder = new CompositeAggregationBuilder(\n+            \"name\",\n+            List.of(\n+                new TermsValuesSourceBuilder(\"terms_key\").field(WILDCARD_FIELD_NAME)\n+            )\n+        );\n+\n+        testCase(aggregationBuilder,\n+            iwc, new MatchAllDocsQuery(),\n+            iw -> {\n+                indexStrings(iw, \"a\");\n+                indexStrings(iw, \"c\");\n+                indexStrings(iw, \"a\");\n+                indexStrings(iw, \"d\");\n+                indexStrings(iw, \"c\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3223032d5192f0702f41a52ea8e8ab18eaaa4009"}, "originalPosition": 126}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2ODI5NjQwOnYy", "diffSide": "RIGHT", "path": "test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzoxNjozN1rOG2UEBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzoxNjozN1rOG2UEBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYwNDk5OA==", "bodyText": "Maybe revert this bit too?", "url": "https://github.com/elastic/elasticsearch/pull/58507#discussion_r459604998", "createdAt": "2020-07-23T17:16:37Z", "author": {"login": "nik9000"}, "path": "test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java", "diffHunk": "@@ -547,13 +547,14 @@ protected void doAssertReducedMultiBucketConsumer(Aggregation agg, MultiBucketCo\n     }\n \n     protected <T extends AggregationBuilder, V extends InternalAggregation> void testCase(\n-            T aggregationBuilder,\n-            Query query,\n-            CheckedConsumer<RandomIndexWriter, IOException> buildIndex,\n-            Consumer<V> verify,\n-            MappedFieldType... fieldTypes) throws IOException {\n+        T aggregationBuilder,\n+        Query query,\n+        CheckedConsumer<RandomIndexWriter, IOException> buildIndex,\n+        Consumer<V> verify,\n+        MappedFieldType... fieldTypes) throws IOException {\n         try (Directory directory = newDirectory()) {\n-            RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory);\n+            RandomIndexWriter indexWriter;\n+            indexWriter = new RandomIndexWriter(random(), directory);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f6640aa143b93ba13f98e7fa702c42f22e9a6ef"}, "originalPosition": 17}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1413, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}