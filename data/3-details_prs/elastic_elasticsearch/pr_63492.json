{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk5OTYyNDEx", "number": 63492, "title": "InternalSnapshotsInfoService should also removed failed snapshot shard size infos", "bodyText": "Relates #61906 (comment)", "createdAt": "2020-10-08T14:23:04Z", "url": "https://github.com/elastic/elasticsearch/pull/63492", "merged": true, "mergeCommit": {"oid": "b8e5d7c0fb4b17c0179b2973276577ba06ac6648"}, "closed": true, "closedAt": "2020-10-13T07:39:25Z", "author": {"login": "tlrx"}, "timelineItems": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdQiT6qgH2gAyNDk5OTYyNDExOmQ1NjgwODQ5NTg1NzBiNWYzNjZmY2Q2M2MwNzJlMTE0OWNmNjIyZDA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdRyPTbgH2gAyNDk5OTYyNDExOjRkNjZiMTljMDQwMTAwNWQ1NGNiMDg0MzUzOWI5MzY1NGY3NjYwYWM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "d568084958570b5f366fcd63c072e1149cf622d0", "author": {"user": {"login": "tlrx", "name": "Tanguy Leroux"}}, "url": "https://github.com/elastic/elasticsearch/commit/d568084958570b5f366fcd63c072e1149cf622d0", "committedDate": "2020-10-08T14:18:33Z", "message": "Also clean up failed shards"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0ODU0MDM0", "url": "https://github.com/elastic/elasticsearch/pull/63492#pullrequestreview-504854034", "createdAt": "2020-10-08T14:37:48Z", "commit": {"oid": "d568084958570b5f366fcd63c072e1149cf622d0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxNDozNzo0OFrOHeh2OA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxNDozNzo0OFrOHeh2OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc3Mzg4MA==", "bodyText": "I made these changes so that the cluster state is better in line with a real cluster state containing an index to restore. Also, it allows to use an AllocationService to update the cluster state in order to initialize or start shards.", "url": "https://github.com/elastic/elasticsearch/pull/63492#discussion_r501773880", "createdAt": "2020-10-08T14:37:48Z", "author": {"login": "tlrx"}, "path": "server/src/test/java/org/elasticsearch/snapshots/InternalSnapshotsInfoServiceTests.java", "diffHunk": "@@ -326,24 +385,28 @@ private ClusterState addUnassignedShards(final ClusterState currentState, String\n             new IndexId(indexName, UUIDs.randomBase64UUID(random()))\n         );\n \n-        final Index index = metadata.get(indexName).getIndex();\n-        final IndexRoutingTable.Builder indexRoutingTable = IndexRoutingTable.builder(index);\n-        for (int primary = 0; primary < numberOfShards; primary++) {\n-            final ShardId shardId = new ShardId(index, primary);\n+        final IndexMetadata indexMetadata = metadata.get(indexName);\n+        final Index index = indexMetadata.getIndex();\n \n-            final IndexShardRoutingTable.Builder indexShards = new IndexShardRoutingTable.Builder(shardId);\n-            indexShards.addShard(TestShardRouting.newShardRouting(shardId, null, true, ShardRoutingState.UNASSIGNED, recoverySource));\n-            for (int replica = 0; replica < metadata.get(indexName).getNumberOfReplicas(); replica++) {\n-                indexShards.addShard(TestShardRouting.newShardRouting(shardId, null, false, ShardRoutingState.UNASSIGNED,\n-                    RecoverySource.PeerRecoverySource.INSTANCE));\n-            }\n-            indexRoutingTable.addIndexShard(indexShards.build());\n+        final RoutingTable.Builder routingTable = RoutingTable.builder(currentState.routingTable());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d568084958570b5f366fcd63c072e1149cf622d0"}, "originalPosition": 141}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2NDE4MjI2", "url": "https://github.com/elastic/elasticsearch/pull/63492#pullrequestreview-506418226", "createdAt": "2020-10-12T08:49:48Z", "commit": {"oid": "d568084958570b5f366fcd63c072e1149cf622d0"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwODo0OTo0OFrOHf1F0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwODo1Mzo1OFrOHf1P6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzEzNzc0NA==", "bodyText": "TYPO: are cleaned up", "url": "https://github.com/elastic/elasticsearch/pull/63492#discussion_r503137744", "createdAt": "2020-10-12T08:49:48Z", "author": {"login": "original-brownbear"}, "path": "server/src/test/java/org/elasticsearch/snapshots/InternalSnapshotsInfoServiceTests.java", "diffHunk": "@@ -275,6 +281,54 @@ public IndexShardSnapshotStatus getShardSnapshotStatus(SnapshotId snapshotId, In\n         });\n     }\n \n+    public void testCleanUpSnapshotShardSizes() throws Exception {\n+        final Repository mockRepository = new FilterRepository(mock(Repository.class)) {\n+            @Override\n+            public IndexShardSnapshotStatus getShardSnapshotStatus(SnapshotId snapshotId, IndexId indexId, ShardId shardId) {\n+                if (randomBoolean()) {\n+                    throw new SnapshotException(new Snapshot(\"_repo\", snapshotId), \"simulated\");\n+                } else {\n+                    return IndexShardSnapshotStatus.newDone(0L, 0L, 0, 0, 0L, randomNonNegativeLong(), null);\n+                }\n+            }\n+        };\n+        when(repositoriesService.repository(\"_repo\")).thenReturn(mockRepository);\n+\n+        final InternalSnapshotsInfoService snapshotsInfoService =\n+            new InternalSnapshotsInfoService(Settings.EMPTY, clusterService, () -> repositoriesService, () -> rerouteService);\n+\n+        final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        final int nbShards = randomIntBetween(1, 10);\n+\n+        applyClusterState(\"new snapshot restore for index \" + indexName,\n+            clusterState -> addUnassignedShards(clusterState, indexName, nbShards));\n+\n+        // waiting for snapshot shard size fetches to be executed, as we want to verify that they are clean up", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d568084958570b5f366fcd63c072e1149cf622d0"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzE0MDMyOA==", "bodyText": "NIT: you can save the conditional here by using:\nfinal RestoreInProgress.Builder restores = new RestoreInProgress.Builder(currentState.custom(RestoreInProgress.TYPE, RestoreInProgress.EMPTY))", "url": "https://github.com/elastic/elasticsearch/pull/63492#discussion_r503140328", "createdAt": "2020-10-12T08:53:58Z", "author": {"login": "original-brownbear"}, "path": "server/src/test/java/org/elasticsearch/snapshots/InternalSnapshotsInfoServiceTests.java", "diffHunk": "@@ -326,24 +385,28 @@ private ClusterState addUnassignedShards(final ClusterState currentState, String\n             new IndexId(indexName, UUIDs.randomBase64UUID(random()))\n         );\n \n-        final Index index = metadata.get(indexName).getIndex();\n-        final IndexRoutingTable.Builder indexRoutingTable = IndexRoutingTable.builder(index);\n-        for (int primary = 0; primary < numberOfShards; primary++) {\n-            final ShardId shardId = new ShardId(index, primary);\n+        final IndexMetadata indexMetadata = metadata.get(indexName);\n+        final Index index = indexMetadata.getIndex();\n \n-            final IndexShardRoutingTable.Builder indexShards = new IndexShardRoutingTable.Builder(shardId);\n-            indexShards.addShard(TestShardRouting.newShardRouting(shardId, null, true, ShardRoutingState.UNASSIGNED, recoverySource));\n-            for (int replica = 0; replica < metadata.get(indexName).getNumberOfReplicas(); replica++) {\n-                indexShards.addShard(TestShardRouting.newShardRouting(shardId, null, false, ShardRoutingState.UNASSIGNED,\n-                    RecoverySource.PeerRecoverySource.INSTANCE));\n-            }\n-            indexRoutingTable.addIndexShard(indexShards.build());\n+        final RoutingTable.Builder routingTable = RoutingTable.builder(currentState.routingTable());\n+        routingTable.add(IndexRoutingTable.builder(index).initializeAsNewRestore(indexMetadata, recoverySource, new IntHashSet()).build());\n+\n+        final RestoreInProgress.Builder restores;\n+        if (currentState.custom(RestoreInProgress.TYPE) != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d568084958570b5f366fcd63c072e1149cf622d0"}, "originalPosition": 145}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4d66b19c0401005d54cb0843539b93654f7660ac", "author": {"user": {"login": "tlrx", "name": "Tanguy Leroux"}}, "url": "https://github.com/elastic/elasticsearch/commit/4d66b19c0401005d54cb0843539b93654f7660ac", "committedDate": "2020-10-12T11:25:55Z", "message": "feedback"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4233, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}