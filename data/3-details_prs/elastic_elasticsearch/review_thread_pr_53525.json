{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg3NTI3OTQ3", "number": 53525, "reviewThreads": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwOToyODowNFrODnxAVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwMDoyNTo0NlrODoi01g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMDIzOTU2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwOToyODowNFrOF18zwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwOToyODowNFrOF18zwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjExNTEzNg==", "bodyText": "The IndicesOption depends on whether includeFrozen is true or not.", "url": "https://github.com/elastic/elasticsearch/pull/53525#discussion_r392115136", "createdAt": "2020-03-13T09:28:04Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "diffHunk": "@@ -460,15 +463,31 @@ public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, bo\n         FieldCapabilitiesRequest fieldRequest = createFieldCapsRequest(indexWildcard, includeFrozen);\n         client.fieldCaps(fieldRequest,\n                 ActionListener.wrap(\n-                        response -> listener.onResponse(\n-                                separateMappings(typeRegistry, indexWildcard, javaRegex, response.getIndices(), response.get())),\n+                        response -> {\n+                            String[] indicesList = response.getIndices();\n+                            GetAliasesRequest aliasRequest = new GetAliasesRequest()\n+                                    .local(true)\n+                                    .aliases(\"*\")\n+                                    .indices(indicesList)\n+                                    .indicesOptions(IndicesOptions.lenientExpandOpen());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3aa01f30490b36d998aa965c3c23acb32e8717da"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMDI0Mzk1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwOToyOToyN1rOF182pA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwOToyOToyN1rOF182pA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjExNTg3Ng==", "bodyText": "Maybe use static imports on ActionListener to make the code a bit more readable.", "url": "https://github.com/elastic/elasticsearch/pull/53525#discussion_r392115876", "createdAt": "2020-03-13T09:29:27Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "diffHunk": "@@ -460,15 +463,31 @@ public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, bo\n         FieldCapabilitiesRequest fieldRequest = createFieldCapsRequest(indexWildcard, includeFrozen);\n         client.fieldCaps(fieldRequest,\n                 ActionListener.wrap(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3aa01f30490b36d998aa965c3c23acb32e8717da"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMDI1MjAwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwOTozMjowM1rOF187mw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwOTozMjowM1rOF187mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjExNzE0Nw==", "bodyText": "Small nit - maybe it makes sense to extract this method into a separate one - it's not reusable but it might make the call easier to read:\nclient.fieldCaps(fieldRequest, wrap(response -> getIndexAliases(response, wrap(aliases -> ...))", "url": "https://github.com/elastic/elasticsearch/pull/53525#discussion_r392117147", "createdAt": "2020-03-13T09:32:03Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "diffHunk": "@@ -460,15 +463,31 @@ public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, bo\n         FieldCapabilitiesRequest fieldRequest = createFieldCapsRequest(indexWildcard, includeFrozen);\n         client.fieldCaps(fieldRequest,\n                 ActionListener.wrap(\n-                        response -> listener.onResponse(\n-                                separateMappings(typeRegistry, indexWildcard, javaRegex, response.getIndices(), response.get())),\n+                        response -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3aa01f30490b36d998aa965c3c23acb32e8717da"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMDI1MzY2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwOTozMjo0NVrOF188tA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwOTozMjo0NVrOF188tA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjExNzQyOA==", "bodyText": "Why use ImmutableOpenMap instead of Map ?", "url": "https://github.com/elastic/elasticsearch/pull/53525#discussion_r392117428", "createdAt": "2020-03-13T09:32:45Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "diffHunk": "@@ -481,16 +500,26 @@ public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, bo\n      * each field.\n      */\n     private static List<EsIndex> buildIndices(DataTypeRegistry typeRegistry, String[] indexNames, String javaRegex,\n-            Map<String, Map<String, FieldCapabilities>> fieldCaps,\n+            Map<String, Map<String, FieldCapabilities>> fieldCaps, ImmutableOpenMap<String, List<AliasMetaData>> aliases,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3aa01f30490b36d998aa965c3c23acb32e8717da"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMDI1NTA5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwOTozMzowOFrOF189gw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxNjo1NTowMlrOF2LSuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjExNzYzNQ==", "bodyText": "What was wrong with Map ?", "url": "https://github.com/elastic/elasticsearch/pull/53525#discussion_r392117635", "createdAt": "2020-03-13T09:33:08Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "diffHunk": "@@ -460,15 +463,31 @@ public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, bo\n         FieldCapabilitiesRequest fieldRequest = createFieldCapsRequest(indexWildcard, includeFrozen);\n         client.fieldCaps(fieldRequest,\n                 ActionListener.wrap(\n-                        response -> listener.onResponse(\n-                                separateMappings(typeRegistry, indexWildcard, javaRegex, response.getIndices(), response.get())),\n+                        response -> {\n+                            String[] indicesList = response.getIndices();\n+                            GetAliasesRequest aliasRequest = new GetAliasesRequest()\n+                                    .local(true)\n+                                    .aliases(\"*\")\n+                                    .indices(indicesList)\n+                                    .indicesOptions(IndicesOptions.lenientExpandOpen());\n+                            client.admin().indices().getAliases(aliasRequest, wrap(aliases ->\n+                                listener.onResponse(separateMappings(typeRegistry, javaRegex, indicesList, response.get(),\n+                                        aliases.getAliases())),\n+                                ex -> {\n+                                    if (ex instanceof IndexNotFoundException || ex instanceof ElasticsearchSecurityException) {\n+                                        listener.onResponse(separateMappings(typeRegistry, javaRegex, indicesList, response.get(), null));\n+                                    } else {\n+                                        listener.onFailure(ex);\n+                                    }\n+                                }));\n+                        },\n                         listener::onFailure));\n \n     }\n     \n-    public static List<EsIndex> separateMappings(DataTypeRegistry typeRegistry, String indexPattern, String javaRegex, String[] indexNames,\n-            Map<String, Map<String, FieldCapabilities>> fieldCaps) {\n-        return buildIndices(typeRegistry, indexNames, javaRegex, fieldCaps, Function.identity(), (s, cap) -> null);\n+    public static List<EsIndex> separateMappings(DataTypeRegistry typeRegistry, String javaRegex, String[] indexNames,\n+            Map<String, Map<String, FieldCapabilities>> fieldCaps, ImmutableOpenMap<String, List<AliasMetaData>> aliases) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3aa01f30490b36d998aa965c3c23acb32e8717da"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM1MjQ0Mw==", "bodyText": "ImmutableOpenMap is not actually a java.util.Map.", "url": "https://github.com/elastic/elasticsearch/pull/53525#discussion_r392352443", "createdAt": "2020-03-13T16:55:02Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "diffHunk": "@@ -460,15 +463,31 @@ public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, bo\n         FieldCapabilitiesRequest fieldRequest = createFieldCapsRequest(indexWildcard, includeFrozen);\n         client.fieldCaps(fieldRequest,\n                 ActionListener.wrap(\n-                        response -> listener.onResponse(\n-                                separateMappings(typeRegistry, indexWildcard, javaRegex, response.getIndices(), response.get())),\n+                        response -> {\n+                            String[] indicesList = response.getIndices();\n+                            GetAliasesRequest aliasRequest = new GetAliasesRequest()\n+                                    .local(true)\n+                                    .aliases(\"*\")\n+                                    .indices(indicesList)\n+                                    .indicesOptions(IndicesOptions.lenientExpandOpen());\n+                            client.admin().indices().getAliases(aliasRequest, wrap(aliases ->\n+                                listener.onResponse(separateMappings(typeRegistry, javaRegex, indicesList, response.get(),\n+                                        aliases.getAliases())),\n+                                ex -> {\n+                                    if (ex instanceof IndexNotFoundException || ex instanceof ElasticsearchSecurityException) {\n+                                        listener.onResponse(separateMappings(typeRegistry, javaRegex, indicesList, response.get(), null));\n+                                    } else {\n+                                        listener.onFailure(ex);\n+                                    }\n+                                }));\n+                        },\n                         listener::onFailure));\n \n     }\n     \n-    public static List<EsIndex> separateMappings(DataTypeRegistry typeRegistry, String indexPattern, String javaRegex, String[] indexNames,\n-            Map<String, Map<String, FieldCapabilities>> fieldCaps) {\n-        return buildIndices(typeRegistry, indexNames, javaRegex, fieldCaps, Function.identity(), (s, cap) -> null);\n+    public static List<EsIndex> separateMappings(DataTypeRegistry typeRegistry, String javaRegex, String[] indexNames,\n+            Map<String, Map<String, FieldCapabilities>> fieldCaps, ImmutableOpenMap<String, List<AliasMetaData>> aliases) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjExNzYzNQ=="}, "originalCommit": {"oid": "3aa01f30490b36d998aa965c3c23acb32e8717da"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMDI2MTQ1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwOTozNToxNVrOF19Bmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwOTozNToxNVrOF19Bmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjExODY4Mw==", "bodyText": "The size is incorrect - use CollectionUtils.mapSize", "url": "https://github.com/elastic/elasticsearch/pull/53525#discussion_r392118683", "createdAt": "2020-03-13T09:35:15Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "diffHunk": "@@ -481,16 +500,26 @@ public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, bo\n      * each field.\n      */\n     private static List<EsIndex> buildIndices(DataTypeRegistry typeRegistry, String[] indexNames, String javaRegex,\n-            Map<String, Map<String, FieldCapabilities>> fieldCaps,\n+            Map<String, Map<String, FieldCapabilities>> fieldCaps, ImmutableOpenMap<String, List<AliasMetaData>> aliases,\n             Function<String, String> indexNameProcessor,\n             BiFunction<String, Map<String, FieldCapabilities>, InvalidMappedField> validityVerifier) {\n \n-        if (indexNames == null || indexNames.length == 0) {\n+        if ((indexNames == null || indexNames.length == 0) && (aliases == null || aliases.size() == 0)) {\n             return emptyList();\n         }\n \n-        final List<String> resolvedIndices = asList(indexNames);\n-        Map<String, Fields> indices = new LinkedHashMap<>(resolvedIndices.size());\n+        Set<String> resolvedAliases = new LinkedHashSet<>();\n+        if (aliases != null) {\n+            Iterator<ObjectObjectCursor<String, List<AliasMetaData>>> iterator = aliases.iterator();\n+            while (iterator.hasNext()) {\n+                for(AliasMetaData alias : iterator.next().value) {\n+                    resolvedAliases.add(alias.getAlias());\n+                }\n+            }\n+        }\n+\n+        List<String> resolvedIndices = new ArrayList<>(asList(indexNames));\n+        Map<String, Fields> indices = new LinkedHashMap<>(resolvedIndices.size() + resolvedAliases.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3aa01f30490b36d998aa965c3c23acb32e8717da"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMDI2NDI4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwOTozNjowOFrOF19DUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxNjo1NDozMFrOF2LReQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjExOTEyMg==", "bodyText": "Is it okay to put all aliases in the same map?", "url": "https://github.com/elastic/elasticsearch/pull/53525#discussion_r392119122", "createdAt": "2020-03-13T09:36:08Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "diffHunk": "@@ -481,16 +500,26 @@ public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, bo\n      * each field.\n      */\n     private static List<EsIndex> buildIndices(DataTypeRegistry typeRegistry, String[] indexNames, String javaRegex,\n-            Map<String, Map<String, FieldCapabilities>> fieldCaps,\n+            Map<String, Map<String, FieldCapabilities>> fieldCaps, ImmutableOpenMap<String, List<AliasMetaData>> aliases,\n             Function<String, String> indexNameProcessor,\n             BiFunction<String, Map<String, FieldCapabilities>, InvalidMappedField> validityVerifier) {\n \n-        if (indexNames == null || indexNames.length == 0) {\n+        if ((indexNames == null || indexNames.length == 0) && (aliases == null || aliases.size() == 0)) {\n             return emptyList();\n         }\n \n-        final List<String> resolvedIndices = asList(indexNames);\n-        Map<String, Fields> indices = new LinkedHashMap<>(resolvedIndices.size());\n+        Set<String> resolvedAliases = new LinkedHashSet<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3aa01f30490b36d998aa965c3c23acb32e8717da"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM1MjEyMQ==", "bodyText": "With this I wanted to count them and create a list of indices and aliases appropriately sized.", "url": "https://github.com/elastic/elasticsearch/pull/53525#discussion_r392352121", "createdAt": "2020-03-13T16:54:30Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "diffHunk": "@@ -481,16 +500,26 @@ public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, bo\n      * each field.\n      */\n     private static List<EsIndex> buildIndices(DataTypeRegistry typeRegistry, String[] indexNames, String javaRegex,\n-            Map<String, Map<String, FieldCapabilities>> fieldCaps,\n+            Map<String, Map<String, FieldCapabilities>> fieldCaps, ImmutableOpenMap<String, List<AliasMetaData>> aliases,\n             Function<String, String> indexNameProcessor,\n             BiFunction<String, Map<String, FieldCapabilities>, InvalidMappedField> validityVerifier) {\n \n-        if (indexNames == null || indexNames.length == 0) {\n+        if ((indexNames == null || indexNames.length == 0) && (aliases == null || aliases.size() == 0)) {\n             return emptyList();\n         }\n \n-        final List<String> resolvedIndices = asList(indexNames);\n-        Map<String, Fields> indices = new LinkedHashMap<>(resolvedIndices.size());\n+        Set<String> resolvedAliases = new LinkedHashSet<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjExOTEyMg=="}, "originalCommit": {"oid": "3aa01f30490b36d998aa965c3c23acb32e8717da"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMDI3NjA2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwOTozOTo1OFrOF19Kgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNjo0MjoyNFrOF28pEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjEyMDk2Mg==", "bodyText": "this creates a HashSet regardless of the key presence - better to do the check", "url": "https://github.com/elastic/elasticsearch/pull/53525#discussion_r392120962", "createdAt": "2020-03-13T09:39:58Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "diffHunk": "@@ -590,4 +646,134 @@ public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, bo\n         foundIndices.sort(Comparator.comparing(EsIndex::name));\n         return foundIndices;\n     }\n+\n+\n+    /*\n+     * Checks if the field is valid (same type and same capabilities - searchable/aggregatable) across indices belonging to a list\n+     * of aliases.\n+     * A field can look like the example below (generated by field_caps API).\n+     *   \"name\": {\n+     *       \"text\": {\n+     *           \"type\": \"text\",\n+     *           \"searchable\": false,\n+     *           \"aggregatable\": false,\n+     *           \"indices\": [\n+     *               \"bar\",\n+     *               \"foo\"\n+     *           ],\n+     *           \"non_searchable_indices\": [\n+     *               \"foo\"\n+     *           ]\n+     *       },\n+     *       \"keyword\": {\n+     *           \"type\": \"keyword\",\n+     *           \"searchable\": false,\n+     *           \"aggregatable\": true,\n+     *           \"non_aggregatable_indices\": [\n+     *               \"bar\", \"baz\"\n+     *           ]\n+     *       }\n+     *   }\n+     */\n+    private static Map<String, InvalidMappedField> getInvalidFieldsForAliases(String fieldName, Map<String, FieldCapabilities> types,\n+            ImmutableOpenMap<String, List<AliasMetaData>> aliases) {\n+        if (aliases == null || aliases.isEmpty()) {\n+            return emptyMap();\n+        }\n+        Map<String, InvalidMappedField> invalidFields = new HashMap<>();\n+        Map<String, Set<String>> typesErrors = new HashMap<>();\n+        Map<String, Set<String>> aliasToIndices = new HashMap<>(); // map with aliases and their list of indices\n+        \n+        Iterator<ObjectObjectCursor<String, List<AliasMetaData>>> iter = aliases.iterator();\n+        while (iter.hasNext()) {\n+            ObjectObjectCursor<String, List<AliasMetaData>> index = iter.next();\n+            for (AliasMetaData aliasMetaData : index.value) {\n+                String aliasName = aliasMetaData.alias();\n+                typesErrors.putIfAbsent(aliasName, new HashSet<>());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3aa01f30490b36d998aa965c3c23acb32e8717da"}, "originalPosition": 251}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzAyNzczMQ==", "bodyText": "Actually, this was intended like this.  See this line where the field type for this field belonging to this alias is added to the list of unique field types.  And here the size of the set is checked to see if there is more than one field type across all indices belonging to this alias. If there is more than one field type, then the field is considered \"invalid\" for this alias.", "url": "https://github.com/elastic/elasticsearch/pull/53525#discussion_r393027731", "createdAt": "2020-03-16T13:38:01Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "diffHunk": "@@ -590,4 +646,134 @@ public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, bo\n         foundIndices.sort(Comparator.comparing(EsIndex::name));\n         return foundIndices;\n     }\n+\n+\n+    /*\n+     * Checks if the field is valid (same type and same capabilities - searchable/aggregatable) across indices belonging to a list\n+     * of aliases.\n+     * A field can look like the example below (generated by field_caps API).\n+     *   \"name\": {\n+     *       \"text\": {\n+     *           \"type\": \"text\",\n+     *           \"searchable\": false,\n+     *           \"aggregatable\": false,\n+     *           \"indices\": [\n+     *               \"bar\",\n+     *               \"foo\"\n+     *           ],\n+     *           \"non_searchable_indices\": [\n+     *               \"foo\"\n+     *           ]\n+     *       },\n+     *       \"keyword\": {\n+     *           \"type\": \"keyword\",\n+     *           \"searchable\": false,\n+     *           \"aggregatable\": true,\n+     *           \"non_aggregatable_indices\": [\n+     *               \"bar\", \"baz\"\n+     *           ]\n+     *       }\n+     *   }\n+     */\n+    private static Map<String, InvalidMappedField> getInvalidFieldsForAliases(String fieldName, Map<String, FieldCapabilities> types,\n+            ImmutableOpenMap<String, List<AliasMetaData>> aliases) {\n+        if (aliases == null || aliases.isEmpty()) {\n+            return emptyMap();\n+        }\n+        Map<String, InvalidMappedField> invalidFields = new HashMap<>();\n+        Map<String, Set<String>> typesErrors = new HashMap<>();\n+        Map<String, Set<String>> aliasToIndices = new HashMap<>(); // map with aliases and their list of indices\n+        \n+        Iterator<ObjectObjectCursor<String, List<AliasMetaData>>> iter = aliases.iterator();\n+        while (iter.hasNext()) {\n+            ObjectObjectCursor<String, List<AliasMetaData>> index = iter.next();\n+            for (AliasMetaData aliasMetaData : index.value) {\n+                String aliasName = aliasMetaData.alias();\n+                typesErrors.putIfAbsent(aliasName, new HashSet<>());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjEyMDk2Mg=="}, "originalCommit": {"oid": "3aa01f30490b36d998aa965c3c23acb32e8717da"}, "originalPosition": 251}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA5NzIxNw==", "bodyText": "I don't follow - putIfAbsent does if (key == null) put(key, value) - I'm pointing out that a new HashSet is created every time.\nWhat I'm suggesting:\nif (key == null) {\n   put(key, new HashSet())\n}", "url": "https://github.com/elastic/elasticsearch/pull/53525#discussion_r393097217", "createdAt": "2020-03-16T15:10:51Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "diffHunk": "@@ -590,4 +646,134 @@ public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, bo\n         foundIndices.sort(Comparator.comparing(EsIndex::name));\n         return foundIndices;\n     }\n+\n+\n+    /*\n+     * Checks if the field is valid (same type and same capabilities - searchable/aggregatable) across indices belonging to a list\n+     * of aliases.\n+     * A field can look like the example below (generated by field_caps API).\n+     *   \"name\": {\n+     *       \"text\": {\n+     *           \"type\": \"text\",\n+     *           \"searchable\": false,\n+     *           \"aggregatable\": false,\n+     *           \"indices\": [\n+     *               \"bar\",\n+     *               \"foo\"\n+     *           ],\n+     *           \"non_searchable_indices\": [\n+     *               \"foo\"\n+     *           ]\n+     *       },\n+     *       \"keyword\": {\n+     *           \"type\": \"keyword\",\n+     *           \"searchable\": false,\n+     *           \"aggregatable\": true,\n+     *           \"non_aggregatable_indices\": [\n+     *               \"bar\", \"baz\"\n+     *           ]\n+     *       }\n+     *   }\n+     */\n+    private static Map<String, InvalidMappedField> getInvalidFieldsForAliases(String fieldName, Map<String, FieldCapabilities> types,\n+            ImmutableOpenMap<String, List<AliasMetaData>> aliases) {\n+        if (aliases == null || aliases.isEmpty()) {\n+            return emptyMap();\n+        }\n+        Map<String, InvalidMappedField> invalidFields = new HashMap<>();\n+        Map<String, Set<String>> typesErrors = new HashMap<>();\n+        Map<String, Set<String>> aliasToIndices = new HashMap<>(); // map with aliases and their list of indices\n+        \n+        Iterator<ObjectObjectCursor<String, List<AliasMetaData>>> iter = aliases.iterator();\n+        while (iter.hasNext()) {\n+            ObjectObjectCursor<String, List<AliasMetaData>> index = iter.next();\n+            for (AliasMetaData aliasMetaData : index.value) {\n+                String aliasName = aliasMetaData.alias();\n+                typesErrors.putIfAbsent(aliasName, new HashSet<>());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjEyMDk2Mg=="}, "originalCommit": {"oid": "3aa01f30490b36d998aa965c3c23acb32e8717da"}, "originalPosition": 251}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE2MDk3Nw==", "bodyText": "I am aware of the putIfAbsent functionality. I think I can simplify the logic a bit.", "url": "https://github.com/elastic/elasticsearch/pull/53525#discussion_r393160977", "createdAt": "2020-03-16T16:42:24Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "diffHunk": "@@ -590,4 +646,134 @@ public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, bo\n         foundIndices.sort(Comparator.comparing(EsIndex::name));\n         return foundIndices;\n     }\n+\n+\n+    /*\n+     * Checks if the field is valid (same type and same capabilities - searchable/aggregatable) across indices belonging to a list\n+     * of aliases.\n+     * A field can look like the example below (generated by field_caps API).\n+     *   \"name\": {\n+     *       \"text\": {\n+     *           \"type\": \"text\",\n+     *           \"searchable\": false,\n+     *           \"aggregatable\": false,\n+     *           \"indices\": [\n+     *               \"bar\",\n+     *               \"foo\"\n+     *           ],\n+     *           \"non_searchable_indices\": [\n+     *               \"foo\"\n+     *           ]\n+     *       },\n+     *       \"keyword\": {\n+     *           \"type\": \"keyword\",\n+     *           \"searchable\": false,\n+     *           \"aggregatable\": true,\n+     *           \"non_aggregatable_indices\": [\n+     *               \"bar\", \"baz\"\n+     *           ]\n+     *       }\n+     *   }\n+     */\n+    private static Map<String, InvalidMappedField> getInvalidFieldsForAliases(String fieldName, Map<String, FieldCapabilities> types,\n+            ImmutableOpenMap<String, List<AliasMetaData>> aliases) {\n+        if (aliases == null || aliases.isEmpty()) {\n+            return emptyMap();\n+        }\n+        Map<String, InvalidMappedField> invalidFields = new HashMap<>();\n+        Map<String, Set<String>> typesErrors = new HashMap<>();\n+        Map<String, Set<String>> aliasToIndices = new HashMap<>(); // map with aliases and their list of indices\n+        \n+        Iterator<ObjectObjectCursor<String, List<AliasMetaData>>> iter = aliases.iterator();\n+        while (iter.hasNext()) {\n+            ObjectObjectCursor<String, List<AliasMetaData>> index = iter.next();\n+            for (AliasMetaData aliasMetaData : index.value) {\n+                String aliasName = aliasMetaData.alias();\n+                typesErrors.putIfAbsent(aliasName, new HashSet<>());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjEyMDk2Mg=="}, "originalCommit": {"oid": "3aa01f30490b36d998aa965c3c23acb32e8717da"}, "originalPosition": 251}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNzY0NzY0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxOToyMzo1NVrOF3CuSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxOToyMzo1NVrOF3CuSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI2MDYxOQ==", "bodyText": "nit: s/accross/across.", "url": "https://github.com/elastic/elasticsearch/pull/53525#discussion_r393260619", "createdAt": "2020-03-16T19:23:55Z", "author": {"login": "bpintea"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "diffHunk": "@@ -605,4 +662,141 @@ public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, bo\n         foundIndices.sort(Comparator.comparing(EsIndex::name));\n         return foundIndices;\n     }\n+\n+\n+    /*\n+     * Checks if the field is valid (same type and same capabilities - searchable/aggregatable) across indices belonging to a list\n+     * of aliases.\n+     * A field can look like the example below (generated by field_caps API).\n+     *   \"name\": {\n+     *       \"text\": {\n+     *           \"type\": \"text\",\n+     *           \"searchable\": false,\n+     *           \"aggregatable\": false,\n+     *           \"indices\": [\n+     *               \"bar\",\n+     *               \"foo\"\n+     *           ],\n+     *           \"non_searchable_indices\": [\n+     *               \"foo\"\n+     *           ]\n+     *       },\n+     *       \"keyword\": {\n+     *           \"type\": \"keyword\",\n+     *           \"searchable\": false,\n+     *           \"aggregatable\": true,\n+     *           \"non_aggregatable_indices\": [\n+     *               \"bar\", \"baz\"\n+     *           ]\n+     *       }\n+     *   }\n+     */\n+    private static Map<String, InvalidMappedField> getInvalidFieldsForAliases(String fieldName, Map<String, FieldCapabilities> types,\n+            ImmutableOpenMap<String, List<AliasMetaData>> aliases) {\n+        if (aliases == null || aliases.isEmpty()) {\n+            return emptyMap();\n+        }\n+        Map<String, InvalidMappedField> invalidFields = new HashMap<>();\n+        Map<String, Set<String>> typesErrors = new HashMap<>(); // map holding aliases and a list of unique field types accross its indices", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf8df94ecfcbd9a66f9e9077c7a2886dfc671331"}, "originalPosition": 252}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzODA2OTcwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQyMTo0OTo0MlrOF3G6EA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwNTo0MTo1OFrOF3Olxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMyOTE2OA==", "bodyText": "Use org.elasticsearch.common.util.CollectionUtils.isEmpty instead.", "url": "https://github.com/elastic/elasticsearch/pull/53525#discussion_r393329168", "createdAt": "2020-03-16T21:49:42Z", "author": {"login": "costin"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "diffHunk": "@@ -496,16 +515,27 @@ public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, bo\n      * each field.\n      */\n     private static List<EsIndex> buildIndices(DataTypeRegistry typeRegistry, String[] indexNames, String javaRegex,\n-            Map<String, Map<String, FieldCapabilities>> fieldCaps,\n+            Map<String, Map<String, FieldCapabilities>> fieldCaps, ImmutableOpenMap<String, List<AliasMetaData>> aliases,\n             Function<String, String> indexNameProcessor,\n             BiFunction<String, Map<String, FieldCapabilities>, InvalidMappedField> validityVerifier) {\n \n-        if (indexNames == null || indexNames.length == 0) {\n+        if ((indexNames == null || indexNames.length == 0) && (aliases == null || aliases.size() == 0)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf8df94ecfcbd9a66f9e9077c7a2886dfc671331"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ1NTA0Nw==", "bodyText": "That's not possible unfortunately, because aliases is an ImmutableOpenMap, which is not a Collection.", "url": "https://github.com/elastic/elasticsearch/pull/53525#discussion_r393455047", "createdAt": "2020-03-17T05:41:58Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "diffHunk": "@@ -496,16 +515,27 @@ public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, bo\n      * each field.\n      */\n     private static List<EsIndex> buildIndices(DataTypeRegistry typeRegistry, String[] indexNames, String javaRegex,\n-            Map<String, Map<String, FieldCapabilities>> fieldCaps,\n+            Map<String, Map<String, FieldCapabilities>> fieldCaps, ImmutableOpenMap<String, List<AliasMetaData>> aliases,\n             Function<String, String> indexNameProcessor,\n             BiFunction<String, Map<String, FieldCapabilities>, InvalidMappedField> validityVerifier) {\n \n-        if (indexNames == null || indexNames.length == 0) {\n+        if ((indexNames == null || indexNames.length == 0) && (aliases == null || aliases.size() == 0)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMyOTE2OA=="}, "originalCommit": {"oid": "bf8df94ecfcbd9a66f9e9077c7a2886dfc671331"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzODM4MzE5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwMDoxMzoyMlrOF3J66A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwMDoxMzoyMlrOF3J66A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM3ODUzNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            for(AliasMetaData alias : iterator.next().value) {\n          \n          \n            \n                            for (AliasMetaData alias : iterator.next().value) {", "url": "https://github.com/elastic/elasticsearch/pull/53525#discussion_r393378536", "createdAt": "2020-03-17T00:13:22Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "diffHunk": "@@ -496,16 +515,27 @@ public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, bo\n      * each field.\n      */\n     private static List<EsIndex> buildIndices(DataTypeRegistry typeRegistry, String[] indexNames, String javaRegex,\n-            Map<String, Map<String, FieldCapabilities>> fieldCaps,\n+            Map<String, Map<String, FieldCapabilities>> fieldCaps, ImmutableOpenMap<String, List<AliasMetaData>> aliases,\n             Function<String, String> indexNameProcessor,\n             BiFunction<String, Map<String, FieldCapabilities>, InvalidMappedField> validityVerifier) {\n \n-        if (indexNames == null || indexNames.length == 0) {\n+        if ((indexNames == null || indexNames.length == 0) && (aliases == null || aliases.size() == 0)) {\n             return emptyList();\n         }\n \n-        final List<String> resolvedIndices = asList(indexNames);\n-        Map<String, Fields> indices = new LinkedHashMap<>(resolvedIndices.size());\n+        Set<String> resolvedAliases = new HashSet<>();\n+        if (aliases != null) {\n+            Iterator<ObjectObjectCursor<String, List<AliasMetaData>>> iterator = aliases.iterator();\n+            while (iterator.hasNext()) {\n+                for(AliasMetaData alias : iterator.next().value) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf8df94ecfcbd9a66f9e9077c7a2886dfc671331"}, "originalPosition": 113}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzODQwMjE0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwMDoyNTo0NlrOF3KGEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwMDoyNTo0NlrOF3KGEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM4MTM5NA==", "bodyText": "Can it be simply <>?\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            aliasToIndices.putIfAbsent(aliasName, new HashSet<String>());\n          \n          \n            \n                            aliasToIndices.putIfAbsent(aliasName, new HashSet<>());", "url": "https://github.com/elastic/elasticsearch/pull/53525#discussion_r393381394", "createdAt": "2020-03-17T00:25:46Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "diffHunk": "@@ -605,4 +662,141 @@ public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, bo\n         foundIndices.sort(Comparator.comparing(EsIndex::name));\n         return foundIndices;\n     }\n+\n+\n+    /*\n+     * Checks if the field is valid (same type and same capabilities - searchable/aggregatable) across indices belonging to a list\n+     * of aliases.\n+     * A field can look like the example below (generated by field_caps API).\n+     *   \"name\": {\n+     *       \"text\": {\n+     *           \"type\": \"text\",\n+     *           \"searchable\": false,\n+     *           \"aggregatable\": false,\n+     *           \"indices\": [\n+     *               \"bar\",\n+     *               \"foo\"\n+     *           ],\n+     *           \"non_searchable_indices\": [\n+     *               \"foo\"\n+     *           ]\n+     *       },\n+     *       \"keyword\": {\n+     *           \"type\": \"keyword\",\n+     *           \"searchable\": false,\n+     *           \"aggregatable\": true,\n+     *           \"non_aggregatable_indices\": [\n+     *               \"bar\", \"baz\"\n+     *           ]\n+     *       }\n+     *   }\n+     */\n+    private static Map<String, InvalidMappedField> getInvalidFieldsForAliases(String fieldName, Map<String, FieldCapabilities> types,\n+            ImmutableOpenMap<String, List<AliasMetaData>> aliases) {\n+        if (aliases == null || aliases.isEmpty()) {\n+            return emptyMap();\n+        }\n+        Map<String, InvalidMappedField> invalidFields = new HashMap<>();\n+        Map<String, Set<String>> typesErrors = new HashMap<>(); // map holding aliases and a list of unique field types accross its indices\n+        Map<String, Set<String>> aliasToIndices = new HashMap<>(); // map with aliases and their list of indices\n+        \n+        Iterator<ObjectObjectCursor<String, List<AliasMetaData>>> iter = aliases.iterator();\n+        while (iter.hasNext()) {\n+            ObjectObjectCursor<String, List<AliasMetaData>> index = iter.next();\n+            for (AliasMetaData aliasMetaData : index.value) {\n+                String aliasName = aliasMetaData.alias();\n+                aliasToIndices.putIfAbsent(aliasName, new HashSet<String>());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf8df94ecfcbd9a66f9e9077c7a2886dfc671331"}, "originalPosition": 260}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3235, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}