{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA5MDQ4OTg0", "number": 64098, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxMjo0NTowMlrOE7CMDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxMzowNzoxMVrOE7CttQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwMzM3Mjk0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/indices/recovery/PeerRecoveryTargetService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxMjo0NTowMlrOH2cgYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxMzo0NDo0OFrOH2fQbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjg1MjE5NA==", "bodyText": "This is pretty much the following, right?\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                            ActionListener.wrap(\n          \n          \n            \n                                            ActionListener.map(new ChannelActionListener<>(channel, Actions.HANDOFF_PRIMARY_CONTEXT, request), \n          \n          \n            \n                                                    v -> TransportResponse.Empty.INSTANCE),", "url": "https://github.com/elastic/elasticsearch/pull/64098#discussion_r526852194", "createdAt": "2020-11-19T12:45:02Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/indices/recovery/PeerRecoveryTargetService.java", "diffHunk": "@@ -311,10 +311,27 @@ public void messageReceived(RecoveryFinalizeRecoveryRequest request, TransportCh\n         @Override\n         public void messageReceived(final RecoveryHandoffPrimaryContextRequest request, final TransportChannel channel,\n                                     Task task) throws Exception {\n-            try (RecoveryRef recoveryRef = onGoingRecoveries.getRecoverySafe(request.recoveryId(), request.shardId())) {\n-                recoveryRef.target().handoffPrimaryContext(request.primaryContext());\n+            final RecoveryRef recoveryRef = onGoingRecoveries.getRecoverySafe(request.recoveryId(), request.shardId());\n+            boolean success = false;\n+            try {\n+                recoveryRef.target().handoffPrimaryContext(request.primaryContext(),\n+                        ActionListener.runBefore(\n+                                ActionListener.wrap(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e55c33bf2338eb2ce901a55c27cd7beaa1bc9dbd"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjg5NzI2Mg==", "bodyText": "Right :) much nicer", "url": "https://github.com/elastic/elasticsearch/pull/64098#discussion_r526897262", "createdAt": "2020-11-19T13:44:48Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/indices/recovery/PeerRecoveryTargetService.java", "diffHunk": "@@ -311,10 +311,27 @@ public void messageReceived(RecoveryFinalizeRecoveryRequest request, TransportCh\n         @Override\n         public void messageReceived(final RecoveryHandoffPrimaryContextRequest request, final TransportChannel channel,\n                                     Task task) throws Exception {\n-            try (RecoveryRef recoveryRef = onGoingRecoveries.getRecoverySafe(request.recoveryId(), request.shardId())) {\n-                recoveryRef.target().handoffPrimaryContext(request.primaryContext());\n+            final RecoveryRef recoveryRef = onGoingRecoveries.getRecoverySafe(request.recoveryId(), request.shardId());\n+            boolean success = false;\n+            try {\n+                recoveryRef.target().handoffPrimaryContext(request.primaryContext(),\n+                        ActionListener.runBefore(\n+                                ActionListener.wrap(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjg1MjE5NA=="}, "originalCommit": {"oid": "e55c33bf2338eb2ce901a55c27cd7beaa1bc9dbd"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwMzQwNjEyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/shard/IndexShard.java", "isResolved": false, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxMjo1Mzo0MFrOH2c1BQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxNDoyNDowMFrOH4Pn3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjg1NzQ3Nw==", "bodyText": "This forks a new thread which blocks, pending acquiring all the permits, but that means we are now blocking outside the scope of the CancellableThreads so will no longer interrupt this wait if the recovery is cancelled.", "url": "https://github.com/elastic/elasticsearch/pull/64098#discussion_r526857477", "createdAt": "2020-11-19T12:53:40Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/index/shard/IndexShard.java", "diffHunk": "@@ -659,49 +659,94 @@ public IndexShardState markAsRecovering(String reason, RecoveryState recoverySta\n \n     /**\n      * Completes the relocation. Operations are blocked and current operations are drained before changing state to relocated. The provided\n-     * {@link Runnable} is executed after all operations are successfully blocked.\n+     * {@link BiConsumer} is executed after all operations are successfully blocked.\n      *\n-     * @param consumer a {@link Runnable} that is executed after operations are blocked\n+     * @param consumer a {@link BiConsumer} that is executed after operations are blocked and that consumes the primary context as well as\n+     *                 a listener to resolve once it finished\n+     * @param listener listener to resolve once this method actions including executing {@code consumer} in the non-failure case complete\n      * @throws IllegalIndexShardStateException if the shard is not relocating due to concurrent cancellation\n      * @throws IllegalStateException           if the relocation target is no longer part of the replication group\n-     * @throws InterruptedException            if blocking operations is interrupted\n      */\n-    public void relocated(final String targetAllocationId, final Consumer<ReplicationTracker.PrimaryContext> consumer)\n-        throws IllegalIndexShardStateException, IllegalStateException, InterruptedException {\n+    public void relocated(final String targetAllocationId,\n+                          final BiConsumer<ReplicationTracker.PrimaryContext, ActionListener<Void>> consumer,\n+                          final ActionListener<Void> listener)\n+            throws IllegalIndexShardStateException, IllegalStateException {\n         assert shardRouting.primary() : \"only primaries can be marked as relocated: \" + shardRouting;\n         try (Releasable forceRefreshes = refreshListeners.forceRefreshes()) {\n-            indexShardOperationPermits.blockOperations(30, TimeUnit.MINUTES, () -> {\n-                forceRefreshes.close();\n-                // no shard operation permits are being held here, move state from started to relocated\n-                assert indexShardOperationPermits.getActiveOperationsCount() == OPERATIONS_BLOCKED :\n-                        \"in-flight operations in progress while moving shard state to relocated\";\n-                /*\n-                 * We should not invoke the runnable under the mutex as the expected implementation is to handoff the primary context via a\n-                 * network operation. Doing this under the mutex can implicitly block the cluster state update thread on network operations.\n-                 */\n-                verifyRelocatingState();\n-                final ReplicationTracker.PrimaryContext primaryContext = replicationTracker.startRelocationHandoff(targetAllocationId);\n-                try {\n-                    consumer.accept(primaryContext);\n-                    synchronized (mutex) {\n+            indexShardOperationPermits.asyncBlockOperations(new ActionListener<>() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e55c33bf2338eb2ce901a55c27cd7beaa1bc9dbd"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjkwMjU2MA==", "bodyText": "Also I think this was the last (non-test) usage of IndexShardOperationPermits#blockOperations so we can drop that method now.", "url": "https://github.com/elastic/elasticsearch/pull/64098#discussion_r526902560", "createdAt": "2020-11-19T13:52:22Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/index/shard/IndexShard.java", "diffHunk": "@@ -659,49 +659,94 @@ public IndexShardState markAsRecovering(String reason, RecoveryState recoverySta\n \n     /**\n      * Completes the relocation. Operations are blocked and current operations are drained before changing state to relocated. The provided\n-     * {@link Runnable} is executed after all operations are successfully blocked.\n+     * {@link BiConsumer} is executed after all operations are successfully blocked.\n      *\n-     * @param consumer a {@link Runnable} that is executed after operations are blocked\n+     * @param consumer a {@link BiConsumer} that is executed after operations are blocked and that consumes the primary context as well as\n+     *                 a listener to resolve once it finished\n+     * @param listener listener to resolve once this method actions including executing {@code consumer} in the non-failure case complete\n      * @throws IllegalIndexShardStateException if the shard is not relocating due to concurrent cancellation\n      * @throws IllegalStateException           if the relocation target is no longer part of the replication group\n-     * @throws InterruptedException            if blocking operations is interrupted\n      */\n-    public void relocated(final String targetAllocationId, final Consumer<ReplicationTracker.PrimaryContext> consumer)\n-        throws IllegalIndexShardStateException, IllegalStateException, InterruptedException {\n+    public void relocated(final String targetAllocationId,\n+                          final BiConsumer<ReplicationTracker.PrimaryContext, ActionListener<Void>> consumer,\n+                          final ActionListener<Void> listener)\n+            throws IllegalIndexShardStateException, IllegalStateException {\n         assert shardRouting.primary() : \"only primaries can be marked as relocated: \" + shardRouting;\n         try (Releasable forceRefreshes = refreshListeners.forceRefreshes()) {\n-            indexShardOperationPermits.blockOperations(30, TimeUnit.MINUTES, () -> {\n-                forceRefreshes.close();\n-                // no shard operation permits are being held here, move state from started to relocated\n-                assert indexShardOperationPermits.getActiveOperationsCount() == OPERATIONS_BLOCKED :\n-                        \"in-flight operations in progress while moving shard state to relocated\";\n-                /*\n-                 * We should not invoke the runnable under the mutex as the expected implementation is to handoff the primary context via a\n-                 * network operation. Doing this under the mutex can implicitly block the cluster state update thread on network operations.\n-                 */\n-                verifyRelocatingState();\n-                final ReplicationTracker.PrimaryContext primaryContext = replicationTracker.startRelocationHandoff(targetAllocationId);\n-                try {\n-                    consumer.accept(primaryContext);\n-                    synchronized (mutex) {\n+            indexShardOperationPermits.asyncBlockOperations(new ActionListener<>() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjg1NzQ3Nw=="}, "originalCommit": {"oid": "e55c33bf2338eb2ce901a55c27cd7beaa1bc9dbd"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjkxOTMzMg==", "bodyText": "Right on both points, uff let me try and find a clean way of resolving the first point  :)", "url": "https://github.com/elastic/elasticsearch/pull/64098#discussion_r526919332", "createdAt": "2020-11-19T14:15:55Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/index/shard/IndexShard.java", "diffHunk": "@@ -659,49 +659,94 @@ public IndexShardState markAsRecovering(String reason, RecoveryState recoverySta\n \n     /**\n      * Completes the relocation. Operations are blocked and current operations are drained before changing state to relocated. The provided\n-     * {@link Runnable} is executed after all operations are successfully blocked.\n+     * {@link BiConsumer} is executed after all operations are successfully blocked.\n      *\n-     * @param consumer a {@link Runnable} that is executed after operations are blocked\n+     * @param consumer a {@link BiConsumer} that is executed after operations are blocked and that consumes the primary context as well as\n+     *                 a listener to resolve once it finished\n+     * @param listener listener to resolve once this method actions including executing {@code consumer} in the non-failure case complete\n      * @throws IllegalIndexShardStateException if the shard is not relocating due to concurrent cancellation\n      * @throws IllegalStateException           if the relocation target is no longer part of the replication group\n-     * @throws InterruptedException            if blocking operations is interrupted\n      */\n-    public void relocated(final String targetAllocationId, final Consumer<ReplicationTracker.PrimaryContext> consumer)\n-        throws IllegalIndexShardStateException, IllegalStateException, InterruptedException {\n+    public void relocated(final String targetAllocationId,\n+                          final BiConsumer<ReplicationTracker.PrimaryContext, ActionListener<Void>> consumer,\n+                          final ActionListener<Void> listener)\n+            throws IllegalIndexShardStateException, IllegalStateException {\n         assert shardRouting.primary() : \"only primaries can be marked as relocated: \" + shardRouting;\n         try (Releasable forceRefreshes = refreshListeners.forceRefreshes()) {\n-            indexShardOperationPermits.blockOperations(30, TimeUnit.MINUTES, () -> {\n-                forceRefreshes.close();\n-                // no shard operation permits are being held here, move state from started to relocated\n-                assert indexShardOperationPermits.getActiveOperationsCount() == OPERATIONS_BLOCKED :\n-                        \"in-flight operations in progress while moving shard state to relocated\";\n-                /*\n-                 * We should not invoke the runnable under the mutex as the expected implementation is to handoff the primary context via a\n-                 * network operation. Doing this under the mutex can implicitly block the cluster state update thread on network operations.\n-                 */\n-                verifyRelocatingState();\n-                final ReplicationTracker.PrimaryContext primaryContext = replicationTracker.startRelocationHandoff(targetAllocationId);\n-                try {\n-                    consumer.accept(primaryContext);\n-                    synchronized (mutex) {\n+            indexShardOperationPermits.asyncBlockOperations(new ActionListener<>() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjg1NzQ3Nw=="}, "originalCommit": {"oid": "e55c33bf2338eb2ce901a55c27cd7beaa1bc9dbd"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODM4OTE0Mw==", "bodyText": "How about this: 9cdb46b , this was the shortest change I could find to having the API we need for running the waiting under cancellable threads. Would also allow for cleanly removing IndexShardOperationPermits#blockOperations by using SAME for those in a follow-up.\nLet me know what you think :)", "url": "https://github.com/elastic/elasticsearch/pull/64098#discussion_r528389143", "createdAt": "2020-11-22T18:57:29Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/index/shard/IndexShard.java", "diffHunk": "@@ -659,49 +659,94 @@ public IndexShardState markAsRecovering(String reason, RecoveryState recoverySta\n \n     /**\n      * Completes the relocation. Operations are blocked and current operations are drained before changing state to relocated. The provided\n-     * {@link Runnable} is executed after all operations are successfully blocked.\n+     * {@link BiConsumer} is executed after all operations are successfully blocked.\n      *\n-     * @param consumer a {@link Runnable} that is executed after operations are blocked\n+     * @param consumer a {@link BiConsumer} that is executed after operations are blocked and that consumes the primary context as well as\n+     *                 a listener to resolve once it finished\n+     * @param listener listener to resolve once this method actions including executing {@code consumer} in the non-failure case complete\n      * @throws IllegalIndexShardStateException if the shard is not relocating due to concurrent cancellation\n      * @throws IllegalStateException           if the relocation target is no longer part of the replication group\n-     * @throws InterruptedException            if blocking operations is interrupted\n      */\n-    public void relocated(final String targetAllocationId, final Consumer<ReplicationTracker.PrimaryContext> consumer)\n-        throws IllegalIndexShardStateException, IllegalStateException, InterruptedException {\n+    public void relocated(final String targetAllocationId,\n+                          final BiConsumer<ReplicationTracker.PrimaryContext, ActionListener<Void>> consumer,\n+                          final ActionListener<Void> listener)\n+            throws IllegalIndexShardStateException, IllegalStateException {\n         assert shardRouting.primary() : \"only primaries can be marked as relocated: \" + shardRouting;\n         try (Releasable forceRefreshes = refreshListeners.forceRefreshes()) {\n-            indexShardOperationPermits.blockOperations(30, TimeUnit.MINUTES, () -> {\n-                forceRefreshes.close();\n-                // no shard operation permits are being held here, move state from started to relocated\n-                assert indexShardOperationPermits.getActiveOperationsCount() == OPERATIONS_BLOCKED :\n-                        \"in-flight operations in progress while moving shard state to relocated\";\n-                /*\n-                 * We should not invoke the runnable under the mutex as the expected implementation is to handoff the primary context via a\n-                 * network operation. Doing this under the mutex can implicitly block the cluster state update thread on network operations.\n-                 */\n-                verifyRelocatingState();\n-                final ReplicationTracker.PrimaryContext primaryContext = replicationTracker.startRelocationHandoff(targetAllocationId);\n-                try {\n-                    consumer.accept(primaryContext);\n-                    synchronized (mutex) {\n+            indexShardOperationPermits.asyncBlockOperations(new ActionListener<>() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjg1NzQ3Nw=="}, "originalCommit": {"oid": "e55c33bf2338eb2ce901a55c27cd7beaa1bc9dbd"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODU5Nzk3Mw==", "bodyText": "This seems rather to defeat the purpose of this change, since this is still a place that primary relocation still blocks.\nMaking handoffPrimaryContext async is a step in the right direction for sure, but IMO we should just continue to use ISOP#blockOperations here.", "url": "https://github.com/elastic/elasticsearch/pull/64098#discussion_r528597973", "createdAt": "2020-11-23T10:20:51Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/index/shard/IndexShard.java", "diffHunk": "@@ -659,49 +659,94 @@ public IndexShardState markAsRecovering(String reason, RecoveryState recoverySta\n \n     /**\n      * Completes the relocation. Operations are blocked and current operations are drained before changing state to relocated. The provided\n-     * {@link Runnable} is executed after all operations are successfully blocked.\n+     * {@link BiConsumer} is executed after all operations are successfully blocked.\n      *\n-     * @param consumer a {@link Runnable} that is executed after operations are blocked\n+     * @param consumer a {@link BiConsumer} that is executed after operations are blocked and that consumes the primary context as well as\n+     *                 a listener to resolve once it finished\n+     * @param listener listener to resolve once this method actions including executing {@code consumer} in the non-failure case complete\n      * @throws IllegalIndexShardStateException if the shard is not relocating due to concurrent cancellation\n      * @throws IllegalStateException           if the relocation target is no longer part of the replication group\n-     * @throws InterruptedException            if blocking operations is interrupted\n      */\n-    public void relocated(final String targetAllocationId, final Consumer<ReplicationTracker.PrimaryContext> consumer)\n-        throws IllegalIndexShardStateException, IllegalStateException, InterruptedException {\n+    public void relocated(final String targetAllocationId,\n+                          final BiConsumer<ReplicationTracker.PrimaryContext, ActionListener<Void>> consumer,\n+                          final ActionListener<Void> listener)\n+            throws IllegalIndexShardStateException, IllegalStateException {\n         assert shardRouting.primary() : \"only primaries can be marked as relocated: \" + shardRouting;\n         try (Releasable forceRefreshes = refreshListeners.forceRefreshes()) {\n-            indexShardOperationPermits.blockOperations(30, TimeUnit.MINUTES, () -> {\n-                forceRefreshes.close();\n-                // no shard operation permits are being held here, move state from started to relocated\n-                assert indexShardOperationPermits.getActiveOperationsCount() == OPERATIONS_BLOCKED :\n-                        \"in-flight operations in progress while moving shard state to relocated\";\n-                /*\n-                 * We should not invoke the runnable under the mutex as the expected implementation is to handoff the primary context via a\n-                 * network operation. Doing this under the mutex can implicitly block the cluster state update thread on network operations.\n-                 */\n-                verifyRelocatingState();\n-                final ReplicationTracker.PrimaryContext primaryContext = replicationTracker.startRelocationHandoff(targetAllocationId);\n-                try {\n-                    consumer.accept(primaryContext);\n-                    synchronized (mutex) {\n+            indexShardOperationPermits.asyncBlockOperations(new ActionListener<>() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjg1NzQ3Nw=="}, "originalCommit": {"oid": "e55c33bf2338eb2ce901a55c27cd7beaa1bc9dbd"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYzODU2Nw==", "bodyText": "Making handoffPrimaryContext async is a step in the right direction for sure, but IMO we should just continue to use ISOP#blockOperations here.\n\nWe can't use the blocking API here if we want to async send the transport request because the blocking API does not give us access to the Releasable on the permits that we have to hold until we are done with org.elasticsearch.indices.recovery.RecoveryTargetHandler#handoffPrimaryContext => I figured this change is easier than refactoring the blocking variant. Maybe we can even find a way to not burn a thread for the acquiring of all the permits in some future follow-up, at least we already have a reasonable API for this with this approach?", "url": "https://github.com/elastic/elasticsearch/pull/64098#discussion_r528638567", "createdAt": "2020-11-23T11:33:31Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/index/shard/IndexShard.java", "diffHunk": "@@ -659,49 +659,94 @@ public IndexShardState markAsRecovering(String reason, RecoveryState recoverySta\n \n     /**\n      * Completes the relocation. Operations are blocked and current operations are drained before changing state to relocated. The provided\n-     * {@link Runnable} is executed after all operations are successfully blocked.\n+     * {@link BiConsumer} is executed after all operations are successfully blocked.\n      *\n-     * @param consumer a {@link Runnable} that is executed after operations are blocked\n+     * @param consumer a {@link BiConsumer} that is executed after operations are blocked and that consumes the primary context as well as\n+     *                 a listener to resolve once it finished\n+     * @param listener listener to resolve once this method actions including executing {@code consumer} in the non-failure case complete\n      * @throws IllegalIndexShardStateException if the shard is not relocating due to concurrent cancellation\n      * @throws IllegalStateException           if the relocation target is no longer part of the replication group\n-     * @throws InterruptedException            if blocking operations is interrupted\n      */\n-    public void relocated(final String targetAllocationId, final Consumer<ReplicationTracker.PrimaryContext> consumer)\n-        throws IllegalIndexShardStateException, IllegalStateException, InterruptedException {\n+    public void relocated(final String targetAllocationId,\n+                          final BiConsumer<ReplicationTracker.PrimaryContext, ActionListener<Void>> consumer,\n+                          final ActionListener<Void> listener)\n+            throws IllegalIndexShardStateException, IllegalStateException {\n         assert shardRouting.primary() : \"only primaries can be marked as relocated: \" + shardRouting;\n         try (Releasable forceRefreshes = refreshListeners.forceRefreshes()) {\n-            indexShardOperationPermits.blockOperations(30, TimeUnit.MINUTES, () -> {\n-                forceRefreshes.close();\n-                // no shard operation permits are being held here, move state from started to relocated\n-                assert indexShardOperationPermits.getActiveOperationsCount() == OPERATIONS_BLOCKED :\n-                        \"in-flight operations in progress while moving shard state to relocated\";\n-                /*\n-                 * We should not invoke the runnable under the mutex as the expected implementation is to handoff the primary context via a\n-                 * network operation. Doing this under the mutex can implicitly block the cluster state update thread on network operations.\n-                 */\n-                verifyRelocatingState();\n-                final ReplicationTracker.PrimaryContext primaryContext = replicationTracker.startRelocationHandoff(targetAllocationId);\n-                try {\n-                    consumer.accept(primaryContext);\n-                    synchronized (mutex) {\n+            indexShardOperationPermits.asyncBlockOperations(new ActionListener<>() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjg1NzQ3Nw=="}, "originalCommit": {"oid": "e55c33bf2338eb2ce901a55c27cd7beaa1bc9dbd"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODczODI3MA==", "bodyText": "Aha I see, that makes sense then.", "url": "https://github.com/elastic/elasticsearch/pull/64098#discussion_r528738270", "createdAt": "2020-11-23T14:24:00Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/index/shard/IndexShard.java", "diffHunk": "@@ -659,49 +659,94 @@ public IndexShardState markAsRecovering(String reason, RecoveryState recoverySta\n \n     /**\n      * Completes the relocation. Operations are blocked and current operations are drained before changing state to relocated. The provided\n-     * {@link Runnable} is executed after all operations are successfully blocked.\n+     * {@link BiConsumer} is executed after all operations are successfully blocked.\n      *\n-     * @param consumer a {@link Runnable} that is executed after operations are blocked\n+     * @param consumer a {@link BiConsumer} that is executed after operations are blocked and that consumes the primary context as well as\n+     *                 a listener to resolve once it finished\n+     * @param listener listener to resolve once this method actions including executing {@code consumer} in the non-failure case complete\n      * @throws IllegalIndexShardStateException if the shard is not relocating due to concurrent cancellation\n      * @throws IllegalStateException           if the relocation target is no longer part of the replication group\n-     * @throws InterruptedException            if blocking operations is interrupted\n      */\n-    public void relocated(final String targetAllocationId, final Consumer<ReplicationTracker.PrimaryContext> consumer)\n-        throws IllegalIndexShardStateException, IllegalStateException, InterruptedException {\n+    public void relocated(final String targetAllocationId,\n+                          final BiConsumer<ReplicationTracker.PrimaryContext, ActionListener<Void>> consumer,\n+                          final ActionListener<Void> listener)\n+            throws IllegalIndexShardStateException, IllegalStateException {\n         assert shardRouting.primary() : \"only primaries can be marked as relocated: \" + shardRouting;\n         try (Releasable forceRefreshes = refreshListeners.forceRefreshes()) {\n-            indexShardOperationPermits.blockOperations(30, TimeUnit.MINUTES, () -> {\n-                forceRefreshes.close();\n-                // no shard operation permits are being held here, move state from started to relocated\n-                assert indexShardOperationPermits.getActiveOperationsCount() == OPERATIONS_BLOCKED :\n-                        \"in-flight operations in progress while moving shard state to relocated\";\n-                /*\n-                 * We should not invoke the runnable under the mutex as the expected implementation is to handoff the primary context via a\n-                 * network operation. Doing this under the mutex can implicitly block the cluster state update thread on network operations.\n-                 */\n-                verifyRelocatingState();\n-                final ReplicationTracker.PrimaryContext primaryContext = replicationTracker.startRelocationHandoff(targetAllocationId);\n-                try {\n-                    consumer.accept(primaryContext);\n-                    synchronized (mutex) {\n+            indexShardOperationPermits.asyncBlockOperations(new ActionListener<>() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjg1NzQ3Nw=="}, "originalCommit": {"oid": "e55c33bf2338eb2ce901a55c27cd7beaa1bc9dbd"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwMzQxMjc5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/shard/IndexShard.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxMjo1NToyMlrOH2c5Dg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxMzo0NzoyNFrOH2fXcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjg1ODUxMA==", "bodyText": "We used to wait for 30 minutes to acquire all the permits -- I don't think 30 seconds is enough in general.", "url": "https://github.com/elastic/elasticsearch/pull/64098#discussion_r526858510", "createdAt": "2020-11-19T12:55:22Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/index/shard/IndexShard.java", "diffHunk": "@@ -659,49 +659,94 @@ public IndexShardState markAsRecovering(String reason, RecoveryState recoverySta\n \n     /**\n      * Completes the relocation. Operations are blocked and current operations are drained before changing state to relocated. The provided\n-     * {@link Runnable} is executed after all operations are successfully blocked.\n+     * {@link BiConsumer} is executed after all operations are successfully blocked.\n      *\n-     * @param consumer a {@link Runnable} that is executed after operations are blocked\n+     * @param consumer a {@link BiConsumer} that is executed after operations are blocked and that consumes the primary context as well as\n+     *                 a listener to resolve once it finished\n+     * @param listener listener to resolve once this method actions including executing {@code consumer} in the non-failure case complete\n      * @throws IllegalIndexShardStateException if the shard is not relocating due to concurrent cancellation\n      * @throws IllegalStateException           if the relocation target is no longer part of the replication group\n-     * @throws InterruptedException            if blocking operations is interrupted\n      */\n-    public void relocated(final String targetAllocationId, final Consumer<ReplicationTracker.PrimaryContext> consumer)\n-        throws IllegalIndexShardStateException, IllegalStateException, InterruptedException {\n+    public void relocated(final String targetAllocationId,\n+                          final BiConsumer<ReplicationTracker.PrimaryContext, ActionListener<Void>> consumer,\n+                          final ActionListener<Void> listener)\n+            throws IllegalIndexShardStateException, IllegalStateException {\n         assert shardRouting.primary() : \"only primaries can be marked as relocated: \" + shardRouting;\n         try (Releasable forceRefreshes = refreshListeners.forceRefreshes()) {\n-            indexShardOperationPermits.blockOperations(30, TimeUnit.MINUTES, () -> {\n-                forceRefreshes.close();\n-                // no shard operation permits are being held here, move state from started to relocated\n-                assert indexShardOperationPermits.getActiveOperationsCount() == OPERATIONS_BLOCKED :\n-                        \"in-flight operations in progress while moving shard state to relocated\";\n-                /*\n-                 * We should not invoke the runnable under the mutex as the expected implementation is to handoff the primary context via a\n-                 * network operation. Doing this under the mutex can implicitly block the cluster state update thread on network operations.\n-                 */\n-                verifyRelocatingState();\n-                final ReplicationTracker.PrimaryContext primaryContext = replicationTracker.startRelocationHandoff(targetAllocationId);\n-                try {\n-                    consumer.accept(primaryContext);\n-                    synchronized (mutex) {\n+            indexShardOperationPermits.asyncBlockOperations(new ActionListener<>() {\n+                @Override\n+                public void onResponse(Releasable releasable) {\n+                    boolean success = false;\n+                    try {\n+                        forceRefreshes.close();\n+                        // no shard operation permits are being held here, move state from started to relocated\n+                        assert indexShardOperationPermits.getActiveOperationsCount() == OPERATIONS_BLOCKED :\n+                                \"in-flight operations in progress while moving shard state to relocated\";\n+                        /*\n+                         * We should not invoke the runnable under the mutex as the expected implementation is to handoff the primary\n+                         * context via a network operation. Doing this under the mutex can implicitly block the cluster state update thread\n+                         * on network operations.\n+                         */\n                         verifyRelocatingState();\n-                        replicationTracker.completeRelocationHandoff(); // make changes to primaryMode and relocated flag only under mutex\n+                        final ReplicationTracker.PrimaryContext primaryContext =\n+                                replicationTracker.startRelocationHandoff(targetAllocationId);\n+                        // make sure we release all permits before we resolve the final listener\n+                        final ActionListener<Void> wrappedInnerListener = ActionListener.runBefore(listener, releasable::close);\n+                        final ActionListener<Void> wrappedListener = new ActionListener<>() {\n+                            @Override\n+                            public void onResponse(Void unused) {\n+                                try {\n+                                    // make changes to primaryMode and relocated flag only under mutex\n+                                    synchronized (mutex) {\n+                                        verifyRelocatingState();\n+                                        replicationTracker.completeRelocationHandoff();\n+                                    }\n+                                    wrappedInnerListener.onResponse(null);\n+                                } catch (Exception e) {\n+                                    onFailure(e);\n+                                }\n+                            }\n+\n+                            @Override\n+                            public void onFailure(Exception e) {\n+                                try {\n+                                    replicationTracker.abortRelocationHandoff();\n+                                } catch (final Exception inner) {\n+                                    e.addSuppressed(inner);\n+                                }\n+                                wrappedInnerListener.onFailure(e);\n+                            }\n+                        };\n+                        try {\n+                            consumer.accept(primaryContext, wrappedListener);\n+                        } catch (final Exception e) {\n+                            wrappedListener.onFailure(e);\n+                        }\n+                        success = true;\n+                    } catch (Exception e) {\n+                        listener.onFailure(e);\n+                    } finally {\n+                        if (success == false) {\n+                            releasable.close();\n+                        }\n                     }\n-                } catch (final Exception e) {\n-                    try {\n-                        replicationTracker.abortRelocationHandoff();\n-                    } catch (final Exception inner) {\n-                        e.addSuppressed(inner);\n+                }\n+\n+                @Override\n+                public void onFailure(Exception e) {\n+                    if (e instanceof TimeoutException) {\n+                        logger.warn(\"timed out waiting for relocation hand-off to complete\");\n+                        // This is really bad as ongoing replication operations are preventing this shard from completing relocation\n+                        // hand-off.\n+                        // Fail primary relocation source and target shards.\n+                        failShard(\"timed out waiting for relocation hand-off to complete\", null);\n+                        listener.onFailure(\n+                                new IndexShardClosedException(shardId(), \"timed out waiting for relocation hand-off to complete\"));\n+                    } else {\n+                        listener.onFailure(e);\n                     }\n-                    throw e;\n                 }\n-            });\n-        } catch (TimeoutException e) {\n-            logger.warn(\"timed out waiting for relocation hand-off to complete\");\n-            // This is really bad as ongoing replication operations are preventing this shard from completing relocation hand-off.\n-            // Fail primary relocation source and target shards.\n-            failShard(\"timed out waiting for relocation hand-off to complete\", null);\n-            throw new IndexShardClosedException(shardId(), \"timed out waiting for relocation hand-off to complete\");\n+            }, 30L, TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e55c33bf2338eb2ce901a55c27cd7beaa1bc9dbd"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjg5OTA1OA==", "bodyText": "\ud83e\udd26 sorry about that, thanks for catching this", "url": "https://github.com/elastic/elasticsearch/pull/64098#discussion_r526899058", "createdAt": "2020-11-19T13:47:24Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/index/shard/IndexShard.java", "diffHunk": "@@ -659,49 +659,94 @@ public IndexShardState markAsRecovering(String reason, RecoveryState recoverySta\n \n     /**\n      * Completes the relocation. Operations are blocked and current operations are drained before changing state to relocated. The provided\n-     * {@link Runnable} is executed after all operations are successfully blocked.\n+     * {@link BiConsumer} is executed after all operations are successfully blocked.\n      *\n-     * @param consumer a {@link Runnable} that is executed after operations are blocked\n+     * @param consumer a {@link BiConsumer} that is executed after operations are blocked and that consumes the primary context as well as\n+     *                 a listener to resolve once it finished\n+     * @param listener listener to resolve once this method actions including executing {@code consumer} in the non-failure case complete\n      * @throws IllegalIndexShardStateException if the shard is not relocating due to concurrent cancellation\n      * @throws IllegalStateException           if the relocation target is no longer part of the replication group\n-     * @throws InterruptedException            if blocking operations is interrupted\n      */\n-    public void relocated(final String targetAllocationId, final Consumer<ReplicationTracker.PrimaryContext> consumer)\n-        throws IllegalIndexShardStateException, IllegalStateException, InterruptedException {\n+    public void relocated(final String targetAllocationId,\n+                          final BiConsumer<ReplicationTracker.PrimaryContext, ActionListener<Void>> consumer,\n+                          final ActionListener<Void> listener)\n+            throws IllegalIndexShardStateException, IllegalStateException {\n         assert shardRouting.primary() : \"only primaries can be marked as relocated: \" + shardRouting;\n         try (Releasable forceRefreshes = refreshListeners.forceRefreshes()) {\n-            indexShardOperationPermits.blockOperations(30, TimeUnit.MINUTES, () -> {\n-                forceRefreshes.close();\n-                // no shard operation permits are being held here, move state from started to relocated\n-                assert indexShardOperationPermits.getActiveOperationsCount() == OPERATIONS_BLOCKED :\n-                        \"in-flight operations in progress while moving shard state to relocated\";\n-                /*\n-                 * We should not invoke the runnable under the mutex as the expected implementation is to handoff the primary context via a\n-                 * network operation. Doing this under the mutex can implicitly block the cluster state update thread on network operations.\n-                 */\n-                verifyRelocatingState();\n-                final ReplicationTracker.PrimaryContext primaryContext = replicationTracker.startRelocationHandoff(targetAllocationId);\n-                try {\n-                    consumer.accept(primaryContext);\n-                    synchronized (mutex) {\n+            indexShardOperationPermits.asyncBlockOperations(new ActionListener<>() {\n+                @Override\n+                public void onResponse(Releasable releasable) {\n+                    boolean success = false;\n+                    try {\n+                        forceRefreshes.close();\n+                        // no shard operation permits are being held here, move state from started to relocated\n+                        assert indexShardOperationPermits.getActiveOperationsCount() == OPERATIONS_BLOCKED :\n+                                \"in-flight operations in progress while moving shard state to relocated\";\n+                        /*\n+                         * We should not invoke the runnable under the mutex as the expected implementation is to handoff the primary\n+                         * context via a network operation. Doing this under the mutex can implicitly block the cluster state update thread\n+                         * on network operations.\n+                         */\n                         verifyRelocatingState();\n-                        replicationTracker.completeRelocationHandoff(); // make changes to primaryMode and relocated flag only under mutex\n+                        final ReplicationTracker.PrimaryContext primaryContext =\n+                                replicationTracker.startRelocationHandoff(targetAllocationId);\n+                        // make sure we release all permits before we resolve the final listener\n+                        final ActionListener<Void> wrappedInnerListener = ActionListener.runBefore(listener, releasable::close);\n+                        final ActionListener<Void> wrappedListener = new ActionListener<>() {\n+                            @Override\n+                            public void onResponse(Void unused) {\n+                                try {\n+                                    // make changes to primaryMode and relocated flag only under mutex\n+                                    synchronized (mutex) {\n+                                        verifyRelocatingState();\n+                                        replicationTracker.completeRelocationHandoff();\n+                                    }\n+                                    wrappedInnerListener.onResponse(null);\n+                                } catch (Exception e) {\n+                                    onFailure(e);\n+                                }\n+                            }\n+\n+                            @Override\n+                            public void onFailure(Exception e) {\n+                                try {\n+                                    replicationTracker.abortRelocationHandoff();\n+                                } catch (final Exception inner) {\n+                                    e.addSuppressed(inner);\n+                                }\n+                                wrappedInnerListener.onFailure(e);\n+                            }\n+                        };\n+                        try {\n+                            consumer.accept(primaryContext, wrappedListener);\n+                        } catch (final Exception e) {\n+                            wrappedListener.onFailure(e);\n+                        }\n+                        success = true;\n+                    } catch (Exception e) {\n+                        listener.onFailure(e);\n+                    } finally {\n+                        if (success == false) {\n+                            releasable.close();\n+                        }\n                     }\n-                } catch (final Exception e) {\n-                    try {\n-                        replicationTracker.abortRelocationHandoff();\n-                    } catch (final Exception inner) {\n-                        e.addSuppressed(inner);\n+                }\n+\n+                @Override\n+                public void onFailure(Exception e) {\n+                    if (e instanceof TimeoutException) {\n+                        logger.warn(\"timed out waiting for relocation hand-off to complete\");\n+                        // This is really bad as ongoing replication operations are preventing this shard from completing relocation\n+                        // hand-off.\n+                        // Fail primary relocation source and target shards.\n+                        failShard(\"timed out waiting for relocation hand-off to complete\", null);\n+                        listener.onFailure(\n+                                new IndexShardClosedException(shardId(), \"timed out waiting for relocation hand-off to complete\"));\n+                    } else {\n+                        listener.onFailure(e);\n                     }\n-                    throw e;\n                 }\n-            });\n-        } catch (TimeoutException e) {\n-            logger.warn(\"timed out waiting for relocation hand-off to complete\");\n-            // This is really bad as ongoing replication operations are preventing this shard from completing relocation hand-off.\n-            // Fail primary relocation source and target shards.\n-            failShard(\"timed out waiting for relocation hand-off to complete\", null);\n-            throw new IndexShardClosedException(shardId(), \"timed out waiting for relocation hand-off to complete\");\n+            }, 30L, TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjg1ODUxMA=="}, "originalCommit": {"oid": "e55c33bf2338eb2ce901a55c27cd7beaa1bc9dbd"}, "originalPosition": 124}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwMzQzNzgxOnYy", "diffSide": "RIGHT", "path": "test/framework/src/main/java/org/elasticsearch/indices/recovery/AsyncRecoveryTarget.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxMzowMTozMFrOH2dIDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxMzo0ODoyMVrOH2fZ1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjg2MjM1MA==", "bodyText": "Wondering why this doesn't use the executor like the other methods in this class.", "url": "https://github.com/elastic/elasticsearch/pull/64098#discussion_r526862350", "createdAt": "2020-11-19T13:01:30Z", "author": {"login": "DaveCTurner"}, "path": "test/framework/src/main/java/org/elasticsearch/indices/recovery/AsyncRecoveryTarget.java", "diffHunk": "@@ -55,8 +55,8 @@ public void finalizeRecovery(long globalCheckpoint, long trimAboveSeqNo, ActionL\n     }\n \n     @Override\n-    public void handoffPrimaryContext(ReplicationTracker.PrimaryContext primaryContext) {\n-        target.handoffPrimaryContext(primaryContext);\n+    public void handoffPrimaryContext(ReplicationTracker.PrimaryContext primaryContext, ActionListener<Void> listener) {\n+        target.handoffPrimaryContext(primaryContext, listener);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e55c33bf2338eb2ce901a55c27cd7beaa1bc9dbd"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjg5OTY2OA==", "bodyText": "Couldn't do that before because we needed a blocking API here, but now that we don't have that any longer I'll make it use the executor as well, no more reason not to :)", "url": "https://github.com/elastic/elasticsearch/pull/64098#discussion_r526899668", "createdAt": "2020-11-19T13:48:21Z", "author": {"login": "original-brownbear"}, "path": "test/framework/src/main/java/org/elasticsearch/indices/recovery/AsyncRecoveryTarget.java", "diffHunk": "@@ -55,8 +55,8 @@ public void finalizeRecovery(long globalCheckpoint, long trimAboveSeqNo, ActionL\n     }\n \n     @Override\n-    public void handoffPrimaryContext(ReplicationTracker.PrimaryContext primaryContext) {\n-        target.handoffPrimaryContext(primaryContext);\n+    public void handoffPrimaryContext(ReplicationTracker.PrimaryContext primaryContext, ActionListener<Void> listener) {\n+        target.handoffPrimaryContext(primaryContext, listener);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjg2MjM1MA=="}, "originalCommit": {"oid": "e55c33bf2338eb2ce901a55c27cd7beaa1bc9dbd"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwMzQ1OTA5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/shard/IndexShard.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxMzowNzoxMVrOH2dVRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxMzo1NDowMlrOH2fplw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjg2NTczNA==", "bodyText": "If listener.onResponse(null) throws an exception in here (e.g. the recovery was cancelled) then we've already closed the releasable, but calling onFailure() in the following catch clause will close it again.", "url": "https://github.com/elastic/elasticsearch/pull/64098#discussion_r526865734", "createdAt": "2020-11-19T13:07:11Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/index/shard/IndexShard.java", "diffHunk": "@@ -659,49 +659,94 @@ public IndexShardState markAsRecovering(String reason, RecoveryState recoverySta\n \n     /**\n      * Completes the relocation. Operations are blocked and current operations are drained before changing state to relocated. The provided\n-     * {@link Runnable} is executed after all operations are successfully blocked.\n+     * {@link BiConsumer} is executed after all operations are successfully blocked.\n      *\n-     * @param consumer a {@link Runnable} that is executed after operations are blocked\n+     * @param consumer a {@link BiConsumer} that is executed after operations are blocked and that consumes the primary context as well as\n+     *                 a listener to resolve once it finished\n+     * @param listener listener to resolve once this method actions including executing {@code consumer} in the non-failure case complete\n      * @throws IllegalIndexShardStateException if the shard is not relocating due to concurrent cancellation\n      * @throws IllegalStateException           if the relocation target is no longer part of the replication group\n-     * @throws InterruptedException            if blocking operations is interrupted\n      */\n-    public void relocated(final String targetAllocationId, final Consumer<ReplicationTracker.PrimaryContext> consumer)\n-        throws IllegalIndexShardStateException, IllegalStateException, InterruptedException {\n+    public void relocated(final String targetAllocationId,\n+                          final BiConsumer<ReplicationTracker.PrimaryContext, ActionListener<Void>> consumer,\n+                          final ActionListener<Void> listener)\n+            throws IllegalIndexShardStateException, IllegalStateException {\n         assert shardRouting.primary() : \"only primaries can be marked as relocated: \" + shardRouting;\n         try (Releasable forceRefreshes = refreshListeners.forceRefreshes()) {\n-            indexShardOperationPermits.blockOperations(30, TimeUnit.MINUTES, () -> {\n-                forceRefreshes.close();\n-                // no shard operation permits are being held here, move state from started to relocated\n-                assert indexShardOperationPermits.getActiveOperationsCount() == OPERATIONS_BLOCKED :\n-                        \"in-flight operations in progress while moving shard state to relocated\";\n-                /*\n-                 * We should not invoke the runnable under the mutex as the expected implementation is to handoff the primary context via a\n-                 * network operation. Doing this under the mutex can implicitly block the cluster state update thread on network operations.\n-                 */\n-                verifyRelocatingState();\n-                final ReplicationTracker.PrimaryContext primaryContext = replicationTracker.startRelocationHandoff(targetAllocationId);\n-                try {\n-                    consumer.accept(primaryContext);\n-                    synchronized (mutex) {\n+            indexShardOperationPermits.asyncBlockOperations(new ActionListener<>() {\n+                @Override\n+                public void onResponse(Releasable releasable) {\n+                    boolean success = false;\n+                    try {\n+                        forceRefreshes.close();\n+                        // no shard operation permits are being held here, move state from started to relocated\n+                        assert indexShardOperationPermits.getActiveOperationsCount() == OPERATIONS_BLOCKED :\n+                                \"in-flight operations in progress while moving shard state to relocated\";\n+                        /*\n+                         * We should not invoke the runnable under the mutex as the expected implementation is to handoff the primary\n+                         * context via a network operation. Doing this under the mutex can implicitly block the cluster state update thread\n+                         * on network operations.\n+                         */\n                         verifyRelocatingState();\n-                        replicationTracker.completeRelocationHandoff(); // make changes to primaryMode and relocated flag only under mutex\n+                        final ReplicationTracker.PrimaryContext primaryContext =\n+                                replicationTracker.startRelocationHandoff(targetAllocationId);\n+                        // make sure we release all permits before we resolve the final listener\n+                        final ActionListener<Void> wrappedInnerListener = ActionListener.runBefore(listener, releasable::close);\n+                        final ActionListener<Void> wrappedListener = new ActionListener<>() {\n+                            @Override\n+                            public void onResponse(Void unused) {\n+                                try {\n+                                    // make changes to primaryMode and relocated flag only under mutex\n+                                    synchronized (mutex) {\n+                                        verifyRelocatingState();\n+                                        replicationTracker.completeRelocationHandoff();\n+                                    }\n+                                    wrappedInnerListener.onResponse(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e55c33bf2338eb2ce901a55c27cd7beaa1bc9dbd"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjkwMzcwMw==", "bodyText": "Yea I thought about that, but it turns out the Releasable is made up of two RunOnce basically so I figured it was ok. This is really subtle though ... I'll wrap it again, optimizing away on AtomicBoolean isn't worth it :)", "url": "https://github.com/elastic/elasticsearch/pull/64098#discussion_r526903703", "createdAt": "2020-11-19T13:54:02Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/index/shard/IndexShard.java", "diffHunk": "@@ -659,49 +659,94 @@ public IndexShardState markAsRecovering(String reason, RecoveryState recoverySta\n \n     /**\n      * Completes the relocation. Operations are blocked and current operations are drained before changing state to relocated. The provided\n-     * {@link Runnable} is executed after all operations are successfully blocked.\n+     * {@link BiConsumer} is executed after all operations are successfully blocked.\n      *\n-     * @param consumer a {@link Runnable} that is executed after operations are blocked\n+     * @param consumer a {@link BiConsumer} that is executed after operations are blocked and that consumes the primary context as well as\n+     *                 a listener to resolve once it finished\n+     * @param listener listener to resolve once this method actions including executing {@code consumer} in the non-failure case complete\n      * @throws IllegalIndexShardStateException if the shard is not relocating due to concurrent cancellation\n      * @throws IllegalStateException           if the relocation target is no longer part of the replication group\n-     * @throws InterruptedException            if blocking operations is interrupted\n      */\n-    public void relocated(final String targetAllocationId, final Consumer<ReplicationTracker.PrimaryContext> consumer)\n-        throws IllegalIndexShardStateException, IllegalStateException, InterruptedException {\n+    public void relocated(final String targetAllocationId,\n+                          final BiConsumer<ReplicationTracker.PrimaryContext, ActionListener<Void>> consumer,\n+                          final ActionListener<Void> listener)\n+            throws IllegalIndexShardStateException, IllegalStateException {\n         assert shardRouting.primary() : \"only primaries can be marked as relocated: \" + shardRouting;\n         try (Releasable forceRefreshes = refreshListeners.forceRefreshes()) {\n-            indexShardOperationPermits.blockOperations(30, TimeUnit.MINUTES, () -> {\n-                forceRefreshes.close();\n-                // no shard operation permits are being held here, move state from started to relocated\n-                assert indexShardOperationPermits.getActiveOperationsCount() == OPERATIONS_BLOCKED :\n-                        \"in-flight operations in progress while moving shard state to relocated\";\n-                /*\n-                 * We should not invoke the runnable under the mutex as the expected implementation is to handoff the primary context via a\n-                 * network operation. Doing this under the mutex can implicitly block the cluster state update thread on network operations.\n-                 */\n-                verifyRelocatingState();\n-                final ReplicationTracker.PrimaryContext primaryContext = replicationTracker.startRelocationHandoff(targetAllocationId);\n-                try {\n-                    consumer.accept(primaryContext);\n-                    synchronized (mutex) {\n+            indexShardOperationPermits.asyncBlockOperations(new ActionListener<>() {\n+                @Override\n+                public void onResponse(Releasable releasable) {\n+                    boolean success = false;\n+                    try {\n+                        forceRefreshes.close();\n+                        // no shard operation permits are being held here, move state from started to relocated\n+                        assert indexShardOperationPermits.getActiveOperationsCount() == OPERATIONS_BLOCKED :\n+                                \"in-flight operations in progress while moving shard state to relocated\";\n+                        /*\n+                         * We should not invoke the runnable under the mutex as the expected implementation is to handoff the primary\n+                         * context via a network operation. Doing this under the mutex can implicitly block the cluster state update thread\n+                         * on network operations.\n+                         */\n                         verifyRelocatingState();\n-                        replicationTracker.completeRelocationHandoff(); // make changes to primaryMode and relocated flag only under mutex\n+                        final ReplicationTracker.PrimaryContext primaryContext =\n+                                replicationTracker.startRelocationHandoff(targetAllocationId);\n+                        // make sure we release all permits before we resolve the final listener\n+                        final ActionListener<Void> wrappedInnerListener = ActionListener.runBefore(listener, releasable::close);\n+                        final ActionListener<Void> wrappedListener = new ActionListener<>() {\n+                            @Override\n+                            public void onResponse(Void unused) {\n+                                try {\n+                                    // make changes to primaryMode and relocated flag only under mutex\n+                                    synchronized (mutex) {\n+                                        verifyRelocatingState();\n+                                        replicationTracker.completeRelocationHandoff();\n+                                    }\n+                                    wrappedInnerListener.onResponse(null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjg2NTczNA=="}, "originalCommit": {"oid": "e55c33bf2338eb2ce901a55c27cd7beaa1bc9dbd"}, "originalPosition": 66}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4300, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}