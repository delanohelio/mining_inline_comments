{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA2Mjk4NzA0", "number": 55493, "title": "Make ValuesSourceRegistry immutable after initilization", "bodyText": "This PR separates out the registration methods from the read methods on ValuesSourceRegistry, putting the former into a new builder class.  The various methods called from SearchModule to register aggregators now accept a ValuesSourceRegistryBuilder, and later uses in ValuesSourceConfig &c still use the main ValuesSourceRegistry class.  SearchModule, after registering all core & plugin aggregations, constructs an immutable ValuesSourceRegistry from the builder, which it then stores and hands out as needed.\nOnce again, we jump through some hoops in building the immutable data structure in order to use the Java 9+ immutable collections, which use less memory and have (marginally) better access performance than the older unmodifiable wrappers.  (The backport will use the unmodifiable wrappers, because of java version compatibility).", "createdAt": "2020-04-20T20:57:45Z", "url": "https://github.com/elastic/elasticsearch/pull/55493", "merged": true, "mergeCommit": {"oid": "85a160f46d1bd0dbee451a03ebed2b23cb87144f"}, "closed": true, "closedAt": "2020-04-23T15:54:09Z", "author": {"login": "not-napoleon"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcYTAkegH2gAyNDA2Mjk4NzA0OjgzNWNmMWI4YjA4MWEwOTAwZmU3OGYwMDE4OWRmNDBhYjg3NDRiNjM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcadpxPgH2gAyNDA2Mjk4NzA0OjA1NjEzZjQ4YTU0MDIwODUyM2I5NTFkMmM4NzIzZjUyM2YzMWEwMjQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "835cf1b8b081a0900fe78f00189df40ab8744b63", "author": {"user": {"login": "not-napoleon", "name": "Mark Tozzi"}}, "url": "https://github.com/elastic/elasticsearch/commit/835cf1b8b081a0900fe78f00189df40ab8744b63", "committedDate": "2020-04-16T20:49:05Z", "message": "Registry builder"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5f126737b9d45fac31a9db9abf6032a68903af33", "author": {"user": {"login": "not-napoleon", "name": "Mark Tozzi"}}, "url": "https://github.com/elastic/elasticsearch/commit/5f126737b9d45fac31a9db9abf6032a68903af33", "committedDate": "2020-04-17T16:54:54Z", "message": "Merge branch 'master' into vs-refactor-immutable-registry"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "229fde712ca5d00a9405e0497045c3aa08bdbb2a", "author": {"user": {"login": "not-napoleon", "name": "Mark Tozzi"}}, "url": "https://github.com/elastic/elasticsearch/commit/229fde712ca5d00a9405e0497045c3aa08bdbb2a", "committedDate": "2020-04-20T15:17:36Z", "message": "Production design, still need to plumb through to tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "429c21d36f8ef446c7e006e49d09416131afb7da", "author": {"user": {"login": "not-napoleon", "name": "Mark Tozzi"}}, "url": "https://github.com/elastic/elasticsearch/commit/429c21d36f8ef446c7e006e49d09416131afb7da", "committedDate": "2020-04-20T20:11:06Z", "message": "Fix test aggregator loading"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bbf6315307642b0e3e8ffcd239032b167956f901", "author": {"user": {"login": "not-napoleon", "name": "Mark Tozzi"}}, "url": "https://github.com/elastic/elasticsearch/commit/bbf6315307642b0e3e8ffcd239032b167956f901", "committedDate": "2020-04-20T20:47:18Z", "message": "Copy to immutable data structures at build time"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3MzEzNDk0", "url": "https://github.com/elastic/elasticsearch/pull/55493#pullrequestreview-397313494", "createdAt": "2020-04-21T13:10:50Z", "commit": {"oid": "bbf6315307642b0e3e8ffcd239032b167956f901"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMzoxMDo1MFrOGJE5RQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMzoxNzoyNVrOGJFM1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE3MDU2NQ==", "bodyText": "ValuesSourceRegistry.Builder?", "url": "https://github.com/elastic/elasticsearch/pull/55493#discussion_r412170565", "createdAt": "2020-04-21T13:10:50Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/plugins/SearchPlugin.java", "diffHunk": "@@ -117,8 +117,9 @@\n     /**\n      * Allows plugins to register new aggregations using aggregation names that are already defined\n      * in Core, as long as the new aggregations target different ValuesSourceTypes\n+     * @return A list of the new registrar functions\n      */\n-    default List<Consumer<ValuesSourceRegistry>> getBareAggregatorRegistrar() {\n+    default List<Consumer<ValuesSourceRegistry.ValuesSourceRegistryBuilder>> getBareAggregatorRegistrar() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbf6315307642b0e3e8ffcd239032b167956f901"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE3MjMxMQ==", "bodyText": "Rename method to extendAggregations or something? Also, now that I'm looking at it, why return a list instead of just a method? Or even just:\ndefault void extendAggregations(ValuesSourceRegistry.Builder builder) {}\n\n?\nI know it doesn't line up with the other \"return lists of stuff\" methods on these classes but ValuesSourceRegistry is a different animal anyway.", "url": "https://github.com/elastic/elasticsearch/pull/55493#discussion_r412172311", "createdAt": "2020-04-21T13:13:07Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/plugins/SearchPlugin.java", "diffHunk": "@@ -117,8 +117,9 @@\n     /**\n      * Allows plugins to register new aggregations using aggregation names that are already defined\n      * in Core, as long as the new aggregations target different ValuesSourceTypes\n+     * @return A list of the new registrar functions\n      */\n-    default List<Consumer<ValuesSourceRegistry>> getBareAggregatorRegistrar() {\n+    default List<Consumer<ValuesSourceRegistry.ValuesSourceRegistryBuilder>> getBareAggregatorRegistrar() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE3MDU2NQ=="}, "originalCommit": {"oid": "bbf6315307642b0e3e8ffcd239032b167956f901"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE3Mzg2OQ==", "bodyText": "Maybe it isn't worth having the method named registerBareAggregatorRegistrar now.", "url": "https://github.com/elastic/elasticsearch/pull/55493#discussion_r412173869", "createdAt": "2020-04-21T13:15:16Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/search/SearchModule.java", "diffHunk": "@@ -322,144 +321,150 @@ public ValuesSourceRegistry getValuesSourceRegistry() {\n         return highlighters;\n     }\n \n-    private void registerAggregations(List<SearchPlugin> plugins) {\n+    private ValuesSourceRegistry registerAggregations(List<SearchPlugin> plugins) {\n+        ValuesSourceRegistry.ValuesSourceRegistryBuilder builder = new ValuesSourceRegistry.ValuesSourceRegistryBuilder();\n+\n         registerAggregation(new AggregationSpec(AvgAggregationBuilder.NAME, AvgAggregationBuilder::new, AvgAggregationBuilder.PARSER)\n             .addResultReader(InternalAvg::new)\n-            .setAggregatorRegistrar(AvgAggregationBuilder::registerAggregators));\n+            .setAggregatorRegistrar(AvgAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(WeightedAvgAggregationBuilder.NAME, WeightedAvgAggregationBuilder::new,\n-            WeightedAvgAggregationBuilder.PARSER).addResultReader(InternalWeightedAvg::new));\n+            WeightedAvgAggregationBuilder.PARSER).addResultReader(InternalWeightedAvg::new), builder);\n         registerAggregation(new AggregationSpec(SumAggregationBuilder.NAME, SumAggregationBuilder::new, SumAggregationBuilder.PARSER)\n             .addResultReader(InternalSum::new)\n-            .setAggregatorRegistrar(SumAggregationBuilder::registerAggregators));\n+            .setAggregatorRegistrar(SumAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(MinAggregationBuilder.NAME, MinAggregationBuilder::new, MinAggregationBuilder.PARSER)\n             .addResultReader(InternalMin::new)\n-            .setAggregatorRegistrar(MinAggregationBuilder::registerAggregators));\n+            .setAggregatorRegistrar(MinAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(MaxAggregationBuilder.NAME, MaxAggregationBuilder::new, MaxAggregationBuilder.PARSER)\n             .addResultReader(InternalMax::new)\n-            .setAggregatorRegistrar(MaxAggregationBuilder::registerAggregators));\n+            .setAggregatorRegistrar(MaxAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(StatsAggregationBuilder.NAME, StatsAggregationBuilder::new, StatsAggregationBuilder.PARSER)\n             .addResultReader(InternalStats::new)\n-            .setAggregatorRegistrar(StatsAggregationBuilder::registerAggregators));\n+            .setAggregatorRegistrar(StatsAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(ExtendedStatsAggregationBuilder.NAME, ExtendedStatsAggregationBuilder::new,\n             ExtendedStatsAggregationBuilder.PARSER)\n                 .addResultReader(InternalExtendedStats::new)\n-                .setAggregatorRegistrar(ExtendedStatsAggregationBuilder::registerAggregators));\n+                .setAggregatorRegistrar(ExtendedStatsAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(ValueCountAggregationBuilder.NAME, ValueCountAggregationBuilder::new,\n             ValueCountAggregationBuilder.PARSER)\n                 .addResultReader(InternalValueCount::new)\n-                .setAggregatorRegistrar(ValueCountAggregationBuilder::registerAggregators));\n+                .setAggregatorRegistrar(ValueCountAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(PercentilesAggregationBuilder.NAME, PercentilesAggregationBuilder::new,\n             PercentilesAggregationBuilder.PARSER)\n                 .addResultReader(InternalTDigestPercentiles.NAME, InternalTDigestPercentiles::new)\n                 .addResultReader(InternalHDRPercentiles.NAME, InternalHDRPercentiles::new)\n-                .setAggregatorRegistrar(PercentilesAggregationBuilder::registerAggregators));\n+                .setAggregatorRegistrar(PercentilesAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(PercentileRanksAggregationBuilder.NAME, PercentileRanksAggregationBuilder::new,\n             PercentileRanksAggregationBuilder.PARSER)\n                 .addResultReader(InternalTDigestPercentileRanks.NAME, InternalTDigestPercentileRanks::new)\n                 .addResultReader(InternalHDRPercentileRanks.NAME, InternalHDRPercentileRanks::new)\n-                .setAggregatorRegistrar(PercentileRanksAggregationBuilder::registerAggregators));\n+                .setAggregatorRegistrar(PercentileRanksAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(MedianAbsoluteDeviationAggregationBuilder.NAME,\n             MedianAbsoluteDeviationAggregationBuilder::new, MedianAbsoluteDeviationAggregationBuilder.PARSER)\n                 .addResultReader(InternalMedianAbsoluteDeviation::new)\n-                .setAggregatorRegistrar(MedianAbsoluteDeviationAggregationBuilder::registerAggregators));\n+                .setAggregatorRegistrar(MedianAbsoluteDeviationAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(CardinalityAggregationBuilder.NAME, CardinalityAggregationBuilder::new,\n             CardinalityAggregationBuilder.PARSER).addResultReader(InternalCardinality::new)\n-                .setAggregatorRegistrar(CardinalityAggregationBuilder::registerAggregators));\n+                .setAggregatorRegistrar(CardinalityAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(GlobalAggregationBuilder.NAME, GlobalAggregationBuilder::new,\n-                GlobalAggregationBuilder::parse).addResultReader(InternalGlobal::new));\n+                GlobalAggregationBuilder::parse).addResultReader(InternalGlobal::new), builder);\n         registerAggregation(new AggregationSpec(MissingAggregationBuilder.NAME, MissingAggregationBuilder::new,\n                 MissingAggregationBuilder.PARSER)\n                     .addResultReader(InternalMissing::new)\n-                    .setAggregatorRegistrar(MissingAggregationBuilder::registerAggregators));\n+                    .setAggregatorRegistrar(MissingAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(FilterAggregationBuilder.NAME, FilterAggregationBuilder::new,\n-                FilterAggregationBuilder::parse).addResultReader(InternalFilter::new));\n+                FilterAggregationBuilder::parse).addResultReader(InternalFilter::new), builder);\n         registerAggregation(new AggregationSpec(FiltersAggregationBuilder.NAME, FiltersAggregationBuilder::new,\n-                FiltersAggregationBuilder::parse).addResultReader(InternalFilters::new));\n+                FiltersAggregationBuilder::parse).addResultReader(InternalFilters::new), builder);\n         registerAggregation(new AggregationSpec(AdjacencyMatrixAggregationBuilder.NAME, AdjacencyMatrixAggregationBuilder::new,\n-                AdjacencyMatrixAggregationBuilder::parse).addResultReader(InternalAdjacencyMatrix::new));\n+                AdjacencyMatrixAggregationBuilder::parse).addResultReader(InternalAdjacencyMatrix::new), builder);\n         registerAggregation(new AggregationSpec(SamplerAggregationBuilder.NAME, SamplerAggregationBuilder::new,\n                 SamplerAggregationBuilder::parse)\n                     .addResultReader(InternalSampler.NAME, InternalSampler::new)\n-                    .addResultReader(UnmappedSampler.NAME, UnmappedSampler::new));\n+                    .addResultReader(UnmappedSampler.NAME, UnmappedSampler::new),\n+            builder);\n         registerAggregation(new AggregationSpec(DiversifiedAggregationBuilder.NAME, DiversifiedAggregationBuilder::new,\n                 DiversifiedAggregationBuilder.PARSER)\n-                    /* Reuses result readers from SamplerAggregator*/);\n+                    /* Reuses result readers from SamplerAggregator*/, builder);\n         registerAggregation(new AggregationSpec(TermsAggregationBuilder.NAME, TermsAggregationBuilder::new,\n                 TermsAggregationBuilder.PARSER)\n                     .addResultReader(StringTerms.NAME, StringTerms::new)\n                     .addResultReader(UnmappedTerms.NAME, UnmappedTerms::new)\n                     .addResultReader(LongTerms.NAME, LongTerms::new)\n                     .addResultReader(DoubleTerms.NAME, DoubleTerms::new)\n-            .setAggregatorRegistrar(TermsAggregationBuilder::registerAggregators));\n+            .setAggregatorRegistrar(TermsAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(RareTermsAggregationBuilder.NAME, RareTermsAggregationBuilder::new,\n                 RareTermsAggregationBuilder.PARSER)\n                     .addResultReader(StringRareTerms.NAME, StringRareTerms::new)\n                     .addResultReader(UnmappedRareTerms.NAME, UnmappedRareTerms::new)\n                     .addResultReader(LongRareTerms.NAME, LongRareTerms::new)\n-                    .setAggregatorRegistrar(RareTermsAggregationBuilder::registerAggregators));\n+                    .setAggregatorRegistrar(RareTermsAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(SignificantTermsAggregationBuilder.NAME, SignificantTermsAggregationBuilder::new,\n                 SignificantTermsAggregationBuilder::parse)\n                     .addResultReader(SignificantStringTerms.NAME, SignificantStringTerms::new)\n                     .addResultReader(SignificantLongTerms.NAME, SignificantLongTerms::new)\n                     .addResultReader(UnmappedSignificantTerms.NAME, UnmappedSignificantTerms::new)\n-                    .setAggregatorRegistrar(SignificantTermsAggregationBuilder::registerAggregators));\n+                    .setAggregatorRegistrar(SignificantTermsAggregationBuilder::registerAggregators),  builder);\n         registerAggregation(new AggregationSpec(SignificantTextAggregationBuilder.NAME, SignificantTextAggregationBuilder::new,\n-                SignificantTextAggregationBuilder::parse));\n+                SignificantTextAggregationBuilder::parse), builder);\n         registerAggregation(new AggregationSpec(RangeAggregationBuilder.NAME, RangeAggregationBuilder::new,\n                 RangeAggregationBuilder.PARSER)\n                     .addResultReader(InternalRange::new)\n-                    .setAggregatorRegistrar(RangeAggregationBuilder::registerAggregators));\n+                    .setAggregatorRegistrar(RangeAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(DateRangeAggregationBuilder.NAME, DateRangeAggregationBuilder::new,\n                 DateRangeAggregationBuilder.PARSER)\n                     .addResultReader(InternalDateRange::new)\n-                    .setAggregatorRegistrar(DateRangeAggregationBuilder::registerAggregators));\n+                    .setAggregatorRegistrar(DateRangeAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(IpRangeAggregationBuilder.NAME, IpRangeAggregationBuilder::new,\n-                IpRangeAggregationBuilder.PARSER).addResultReader(InternalBinaryRange::new));\n+                IpRangeAggregationBuilder.PARSER).addResultReader(InternalBinaryRange::new), builder);\n         registerAggregation(new AggregationSpec(HistogramAggregationBuilder.NAME, HistogramAggregationBuilder::new,\n                 HistogramAggregationBuilder.PARSER)\n                     .addResultReader(InternalHistogram::new)\n-                    .setAggregatorRegistrar(HistogramAggregationBuilder::registerAggregators));\n+                    .setAggregatorRegistrar(HistogramAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(DateHistogramAggregationBuilder.NAME, DateHistogramAggregationBuilder::new,\n                 DateHistogramAggregationBuilder.PARSER)\n                     .addResultReader(InternalDateHistogram::new)\n-                    .setAggregatorRegistrar(DateHistogramAggregationBuilder::registerAggregators));\n+                    .setAggregatorRegistrar(DateHistogramAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(AutoDateHistogramAggregationBuilder.NAME, AutoDateHistogramAggregationBuilder::new,\n-                AutoDateHistogramAggregationBuilder.PARSER).addResultReader(InternalAutoDateHistogram::new));\n+                AutoDateHistogramAggregationBuilder.PARSER).addResultReader(InternalAutoDateHistogram::new), builder);\n         registerAggregation(new AggregationSpec(GeoDistanceAggregationBuilder.NAME, GeoDistanceAggregationBuilder::new,\n-                GeoDistanceAggregationBuilder::parse).addResultReader(InternalGeoDistance::new));\n+                GeoDistanceAggregationBuilder::parse).addResultReader(InternalGeoDistance::new), builder);\n         registerAggregation(new AggregationSpec(GeoHashGridAggregationBuilder.NAME, GeoHashGridAggregationBuilder::new,\n                 GeoHashGridAggregationBuilder.PARSER)\n                     .addResultReader(InternalGeoHashGrid::new)\n-                    .setAggregatorRegistrar(GeoHashGridAggregationBuilder::registerAggregators));\n+                    .setAggregatorRegistrar(GeoHashGridAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(GeoTileGridAggregationBuilder.NAME, GeoTileGridAggregationBuilder::new,\n                 GeoTileGridAggregationBuilder.PARSER)\n                     .addResultReader(InternalGeoTileGrid::new)\n-                    .setAggregatorRegistrar(GeoTileGridAggregationBuilder::registerAggregators));\n+                    .setAggregatorRegistrar(GeoTileGridAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(NestedAggregationBuilder.NAME, NestedAggregationBuilder::new,\n-                NestedAggregationBuilder::parse).addResultReader(InternalNested::new));\n+                NestedAggregationBuilder::parse).addResultReader(InternalNested::new), builder);\n         registerAggregation(new AggregationSpec(ReverseNestedAggregationBuilder.NAME, ReverseNestedAggregationBuilder::new,\n-                ReverseNestedAggregationBuilder::parse).addResultReader(InternalReverseNested::new));\n+                ReverseNestedAggregationBuilder::parse).addResultReader(InternalReverseNested::new), builder);\n         registerAggregation(new AggregationSpec(TopHitsAggregationBuilder.NAME, TopHitsAggregationBuilder::new,\n-                TopHitsAggregationBuilder::parse).addResultReader(InternalTopHits::new));\n+                TopHitsAggregationBuilder::parse).addResultReader(InternalTopHits::new), builder);\n         registerAggregation(new AggregationSpec(GeoBoundsAggregationBuilder.NAME, GeoBoundsAggregationBuilder::new,\n                 GeoBoundsAggregationBuilder.PARSER)\n                     .addResultReader(InternalGeoBounds::new)\n-                    .setAggregatorRegistrar(GeoBoundsAggregationBuilder::registerAggregators));\n+                    .setAggregatorRegistrar(GeoBoundsAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(GeoCentroidAggregationBuilder.NAME, GeoCentroidAggregationBuilder::new,\n                 GeoCentroidAggregationBuilder.PARSER)\n                     .addResultReader(InternalGeoCentroid::new)\n-                    .setAggregatorRegistrar(GeoCentroidAggregationBuilder::registerAggregators));\n+                    .setAggregatorRegistrar(GeoCentroidAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(ScriptedMetricAggregationBuilder.NAME, ScriptedMetricAggregationBuilder::new,\n-                ScriptedMetricAggregationBuilder.PARSER).addResultReader(InternalScriptedMetric::new));\n+                ScriptedMetricAggregationBuilder.PARSER).addResultReader(InternalScriptedMetric::new), builder);\n         registerAggregation((new AggregationSpec(CompositeAggregationBuilder.NAME, CompositeAggregationBuilder::new,\n-                CompositeAggregationBuilder.PARSER).addResultReader(InternalComposite::new)));\n-        registerFromPlugin(plugins, SearchPlugin::getAggregations, this::registerAggregation);\n+                CompositeAggregationBuilder.PARSER).addResultReader(InternalComposite::new)), builder);\n+        registerFromPlugin(plugins, SearchPlugin::getAggregations, (agg) -> this.registerAggregation(agg, builder));\n \n         // after aggs have been registered, see if there are any new VSTypes that need to be linked to core fields\n-        registerFromPlugin(plugins, SearchPlugin::getBareAggregatorRegistrar, this::registerBareAggregatorRegistrar);\n+        registerFromPlugin(plugins, SearchPlugin::getBareAggregatorRegistrar,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbf6315307642b0e3e8ffcd239032b167956f901"}, "originalPosition": 200}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE3Mzk1NQ==", "bodyText": "Just use the lambda.", "url": "https://github.com/elastic/elasticsearch/pull/55493#discussion_r412173955", "createdAt": "2020-04-21T13:15:24Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/search/SearchModule.java", "diffHunk": "@@ -322,144 +321,150 @@ public ValuesSourceRegistry getValuesSourceRegistry() {\n         return highlighters;\n     }\n \n-    private void registerAggregations(List<SearchPlugin> plugins) {\n+    private ValuesSourceRegistry registerAggregations(List<SearchPlugin> plugins) {\n+        ValuesSourceRegistry.ValuesSourceRegistryBuilder builder = new ValuesSourceRegistry.ValuesSourceRegistryBuilder();\n+\n         registerAggregation(new AggregationSpec(AvgAggregationBuilder.NAME, AvgAggregationBuilder::new, AvgAggregationBuilder.PARSER)\n             .addResultReader(InternalAvg::new)\n-            .setAggregatorRegistrar(AvgAggregationBuilder::registerAggregators));\n+            .setAggregatorRegistrar(AvgAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(WeightedAvgAggregationBuilder.NAME, WeightedAvgAggregationBuilder::new,\n-            WeightedAvgAggregationBuilder.PARSER).addResultReader(InternalWeightedAvg::new));\n+            WeightedAvgAggregationBuilder.PARSER).addResultReader(InternalWeightedAvg::new), builder);\n         registerAggregation(new AggregationSpec(SumAggregationBuilder.NAME, SumAggregationBuilder::new, SumAggregationBuilder.PARSER)\n             .addResultReader(InternalSum::new)\n-            .setAggregatorRegistrar(SumAggregationBuilder::registerAggregators));\n+            .setAggregatorRegistrar(SumAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(MinAggregationBuilder.NAME, MinAggregationBuilder::new, MinAggregationBuilder.PARSER)\n             .addResultReader(InternalMin::new)\n-            .setAggregatorRegistrar(MinAggregationBuilder::registerAggregators));\n+            .setAggregatorRegistrar(MinAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(MaxAggregationBuilder.NAME, MaxAggregationBuilder::new, MaxAggregationBuilder.PARSER)\n             .addResultReader(InternalMax::new)\n-            .setAggregatorRegistrar(MaxAggregationBuilder::registerAggregators));\n+            .setAggregatorRegistrar(MaxAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(StatsAggregationBuilder.NAME, StatsAggregationBuilder::new, StatsAggregationBuilder.PARSER)\n             .addResultReader(InternalStats::new)\n-            .setAggregatorRegistrar(StatsAggregationBuilder::registerAggregators));\n+            .setAggregatorRegistrar(StatsAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(ExtendedStatsAggregationBuilder.NAME, ExtendedStatsAggregationBuilder::new,\n             ExtendedStatsAggregationBuilder.PARSER)\n                 .addResultReader(InternalExtendedStats::new)\n-                .setAggregatorRegistrar(ExtendedStatsAggregationBuilder::registerAggregators));\n+                .setAggregatorRegistrar(ExtendedStatsAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(ValueCountAggregationBuilder.NAME, ValueCountAggregationBuilder::new,\n             ValueCountAggregationBuilder.PARSER)\n                 .addResultReader(InternalValueCount::new)\n-                .setAggregatorRegistrar(ValueCountAggregationBuilder::registerAggregators));\n+                .setAggregatorRegistrar(ValueCountAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(PercentilesAggregationBuilder.NAME, PercentilesAggregationBuilder::new,\n             PercentilesAggregationBuilder.PARSER)\n                 .addResultReader(InternalTDigestPercentiles.NAME, InternalTDigestPercentiles::new)\n                 .addResultReader(InternalHDRPercentiles.NAME, InternalHDRPercentiles::new)\n-                .setAggregatorRegistrar(PercentilesAggregationBuilder::registerAggregators));\n+                .setAggregatorRegistrar(PercentilesAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(PercentileRanksAggregationBuilder.NAME, PercentileRanksAggregationBuilder::new,\n             PercentileRanksAggregationBuilder.PARSER)\n                 .addResultReader(InternalTDigestPercentileRanks.NAME, InternalTDigestPercentileRanks::new)\n                 .addResultReader(InternalHDRPercentileRanks.NAME, InternalHDRPercentileRanks::new)\n-                .setAggregatorRegistrar(PercentileRanksAggregationBuilder::registerAggregators));\n+                .setAggregatorRegistrar(PercentileRanksAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(MedianAbsoluteDeviationAggregationBuilder.NAME,\n             MedianAbsoluteDeviationAggregationBuilder::new, MedianAbsoluteDeviationAggregationBuilder.PARSER)\n                 .addResultReader(InternalMedianAbsoluteDeviation::new)\n-                .setAggregatorRegistrar(MedianAbsoluteDeviationAggregationBuilder::registerAggregators));\n+                .setAggregatorRegistrar(MedianAbsoluteDeviationAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(CardinalityAggregationBuilder.NAME, CardinalityAggregationBuilder::new,\n             CardinalityAggregationBuilder.PARSER).addResultReader(InternalCardinality::new)\n-                .setAggregatorRegistrar(CardinalityAggregationBuilder::registerAggregators));\n+                .setAggregatorRegistrar(CardinalityAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(GlobalAggregationBuilder.NAME, GlobalAggregationBuilder::new,\n-                GlobalAggregationBuilder::parse).addResultReader(InternalGlobal::new));\n+                GlobalAggregationBuilder::parse).addResultReader(InternalGlobal::new), builder);\n         registerAggregation(new AggregationSpec(MissingAggregationBuilder.NAME, MissingAggregationBuilder::new,\n                 MissingAggregationBuilder.PARSER)\n                     .addResultReader(InternalMissing::new)\n-                    .setAggregatorRegistrar(MissingAggregationBuilder::registerAggregators));\n+                    .setAggregatorRegistrar(MissingAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(FilterAggregationBuilder.NAME, FilterAggregationBuilder::new,\n-                FilterAggregationBuilder::parse).addResultReader(InternalFilter::new));\n+                FilterAggregationBuilder::parse).addResultReader(InternalFilter::new), builder);\n         registerAggregation(new AggregationSpec(FiltersAggregationBuilder.NAME, FiltersAggregationBuilder::new,\n-                FiltersAggregationBuilder::parse).addResultReader(InternalFilters::new));\n+                FiltersAggregationBuilder::parse).addResultReader(InternalFilters::new), builder);\n         registerAggregation(new AggregationSpec(AdjacencyMatrixAggregationBuilder.NAME, AdjacencyMatrixAggregationBuilder::new,\n-                AdjacencyMatrixAggregationBuilder::parse).addResultReader(InternalAdjacencyMatrix::new));\n+                AdjacencyMatrixAggregationBuilder::parse).addResultReader(InternalAdjacencyMatrix::new), builder);\n         registerAggregation(new AggregationSpec(SamplerAggregationBuilder.NAME, SamplerAggregationBuilder::new,\n                 SamplerAggregationBuilder::parse)\n                     .addResultReader(InternalSampler.NAME, InternalSampler::new)\n-                    .addResultReader(UnmappedSampler.NAME, UnmappedSampler::new));\n+                    .addResultReader(UnmappedSampler.NAME, UnmappedSampler::new),\n+            builder);\n         registerAggregation(new AggregationSpec(DiversifiedAggregationBuilder.NAME, DiversifiedAggregationBuilder::new,\n                 DiversifiedAggregationBuilder.PARSER)\n-                    /* Reuses result readers from SamplerAggregator*/);\n+                    /* Reuses result readers from SamplerAggregator*/, builder);\n         registerAggregation(new AggregationSpec(TermsAggregationBuilder.NAME, TermsAggregationBuilder::new,\n                 TermsAggregationBuilder.PARSER)\n                     .addResultReader(StringTerms.NAME, StringTerms::new)\n                     .addResultReader(UnmappedTerms.NAME, UnmappedTerms::new)\n                     .addResultReader(LongTerms.NAME, LongTerms::new)\n                     .addResultReader(DoubleTerms.NAME, DoubleTerms::new)\n-            .setAggregatorRegistrar(TermsAggregationBuilder::registerAggregators));\n+            .setAggregatorRegistrar(TermsAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(RareTermsAggregationBuilder.NAME, RareTermsAggregationBuilder::new,\n                 RareTermsAggregationBuilder.PARSER)\n                     .addResultReader(StringRareTerms.NAME, StringRareTerms::new)\n                     .addResultReader(UnmappedRareTerms.NAME, UnmappedRareTerms::new)\n                     .addResultReader(LongRareTerms.NAME, LongRareTerms::new)\n-                    .setAggregatorRegistrar(RareTermsAggregationBuilder::registerAggregators));\n+                    .setAggregatorRegistrar(RareTermsAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(SignificantTermsAggregationBuilder.NAME, SignificantTermsAggregationBuilder::new,\n                 SignificantTermsAggregationBuilder::parse)\n                     .addResultReader(SignificantStringTerms.NAME, SignificantStringTerms::new)\n                     .addResultReader(SignificantLongTerms.NAME, SignificantLongTerms::new)\n                     .addResultReader(UnmappedSignificantTerms.NAME, UnmappedSignificantTerms::new)\n-                    .setAggregatorRegistrar(SignificantTermsAggregationBuilder::registerAggregators));\n+                    .setAggregatorRegistrar(SignificantTermsAggregationBuilder::registerAggregators),  builder);\n         registerAggregation(new AggregationSpec(SignificantTextAggregationBuilder.NAME, SignificantTextAggregationBuilder::new,\n-                SignificantTextAggregationBuilder::parse));\n+                SignificantTextAggregationBuilder::parse), builder);\n         registerAggregation(new AggregationSpec(RangeAggregationBuilder.NAME, RangeAggregationBuilder::new,\n                 RangeAggregationBuilder.PARSER)\n                     .addResultReader(InternalRange::new)\n-                    .setAggregatorRegistrar(RangeAggregationBuilder::registerAggregators));\n+                    .setAggregatorRegistrar(RangeAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(DateRangeAggregationBuilder.NAME, DateRangeAggregationBuilder::new,\n                 DateRangeAggregationBuilder.PARSER)\n                     .addResultReader(InternalDateRange::new)\n-                    .setAggregatorRegistrar(DateRangeAggregationBuilder::registerAggregators));\n+                    .setAggregatorRegistrar(DateRangeAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(IpRangeAggregationBuilder.NAME, IpRangeAggregationBuilder::new,\n-                IpRangeAggregationBuilder.PARSER).addResultReader(InternalBinaryRange::new));\n+                IpRangeAggregationBuilder.PARSER).addResultReader(InternalBinaryRange::new), builder);\n         registerAggregation(new AggregationSpec(HistogramAggregationBuilder.NAME, HistogramAggregationBuilder::new,\n                 HistogramAggregationBuilder.PARSER)\n                     .addResultReader(InternalHistogram::new)\n-                    .setAggregatorRegistrar(HistogramAggregationBuilder::registerAggregators));\n+                    .setAggregatorRegistrar(HistogramAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(DateHistogramAggregationBuilder.NAME, DateHistogramAggregationBuilder::new,\n                 DateHistogramAggregationBuilder.PARSER)\n                     .addResultReader(InternalDateHistogram::new)\n-                    .setAggregatorRegistrar(DateHistogramAggregationBuilder::registerAggregators));\n+                    .setAggregatorRegistrar(DateHistogramAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(AutoDateHistogramAggregationBuilder.NAME, AutoDateHistogramAggregationBuilder::new,\n-                AutoDateHistogramAggregationBuilder.PARSER).addResultReader(InternalAutoDateHistogram::new));\n+                AutoDateHistogramAggregationBuilder.PARSER).addResultReader(InternalAutoDateHistogram::new), builder);\n         registerAggregation(new AggregationSpec(GeoDistanceAggregationBuilder.NAME, GeoDistanceAggregationBuilder::new,\n-                GeoDistanceAggregationBuilder::parse).addResultReader(InternalGeoDistance::new));\n+                GeoDistanceAggregationBuilder::parse).addResultReader(InternalGeoDistance::new), builder);\n         registerAggregation(new AggregationSpec(GeoHashGridAggregationBuilder.NAME, GeoHashGridAggregationBuilder::new,\n                 GeoHashGridAggregationBuilder.PARSER)\n                     .addResultReader(InternalGeoHashGrid::new)\n-                    .setAggregatorRegistrar(GeoHashGridAggregationBuilder::registerAggregators));\n+                    .setAggregatorRegistrar(GeoHashGridAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(GeoTileGridAggregationBuilder.NAME, GeoTileGridAggregationBuilder::new,\n                 GeoTileGridAggregationBuilder.PARSER)\n                     .addResultReader(InternalGeoTileGrid::new)\n-                    .setAggregatorRegistrar(GeoTileGridAggregationBuilder::registerAggregators));\n+                    .setAggregatorRegistrar(GeoTileGridAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(NestedAggregationBuilder.NAME, NestedAggregationBuilder::new,\n-                NestedAggregationBuilder::parse).addResultReader(InternalNested::new));\n+                NestedAggregationBuilder::parse).addResultReader(InternalNested::new), builder);\n         registerAggregation(new AggregationSpec(ReverseNestedAggregationBuilder.NAME, ReverseNestedAggregationBuilder::new,\n-                ReverseNestedAggregationBuilder::parse).addResultReader(InternalReverseNested::new));\n+                ReverseNestedAggregationBuilder::parse).addResultReader(InternalReverseNested::new), builder);\n         registerAggregation(new AggregationSpec(TopHitsAggregationBuilder.NAME, TopHitsAggregationBuilder::new,\n-                TopHitsAggregationBuilder::parse).addResultReader(InternalTopHits::new));\n+                TopHitsAggregationBuilder::parse).addResultReader(InternalTopHits::new), builder);\n         registerAggregation(new AggregationSpec(GeoBoundsAggregationBuilder.NAME, GeoBoundsAggregationBuilder::new,\n                 GeoBoundsAggregationBuilder.PARSER)\n                     .addResultReader(InternalGeoBounds::new)\n-                    .setAggregatorRegistrar(GeoBoundsAggregationBuilder::registerAggregators));\n+                    .setAggregatorRegistrar(GeoBoundsAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(GeoCentroidAggregationBuilder.NAME, GeoCentroidAggregationBuilder::new,\n                 GeoCentroidAggregationBuilder.PARSER)\n                     .addResultReader(InternalGeoCentroid::new)\n-                    .setAggregatorRegistrar(GeoCentroidAggregationBuilder::registerAggregators));\n+                    .setAggregatorRegistrar(GeoCentroidAggregationBuilder::registerAggregators), builder);\n         registerAggregation(new AggregationSpec(ScriptedMetricAggregationBuilder.NAME, ScriptedMetricAggregationBuilder::new,\n-                ScriptedMetricAggregationBuilder.PARSER).addResultReader(InternalScriptedMetric::new));\n+                ScriptedMetricAggregationBuilder.PARSER).addResultReader(InternalScriptedMetric::new), builder);\n         registerAggregation((new AggregationSpec(CompositeAggregationBuilder.NAME, CompositeAggregationBuilder::new,\n-                CompositeAggregationBuilder.PARSER).addResultReader(InternalComposite::new)));\n-        registerFromPlugin(plugins, SearchPlugin::getAggregations, this::registerAggregation);\n+                CompositeAggregationBuilder.PARSER).addResultReader(InternalComposite::new)), builder);\n+        registerFromPlugin(plugins, SearchPlugin::getAggregations, (agg) -> this.registerAggregation(agg, builder));\n \n         // after aggs have been registered, see if there are any new VSTypes that need to be linked to core fields\n-        registerFromPlugin(plugins, SearchPlugin::getBareAggregatorRegistrar, this::registerBareAggregatorRegistrar);\n+        registerFromPlugin(plugins, SearchPlugin::getBareAggregatorRegistrar,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE3Mzg2OQ=="}, "originalCommit": {"oid": "bbf6315307642b0e3e8ffcd239032b167956f901"}, "originalPosition": 200}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE3NDYzNQ==", "bodyText": "I don't think it needs to be synchronized any more because we do all plugin building in one thread.", "url": "https://github.com/elastic/elasticsearch/pull/55493#discussion_r412174635", "createdAt": "2020-04-21T13:16:14Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/support/ValuesSourceRegistry.java", "diffHunk": "@@ -39,79 +41,101 @@\n  *\n  */\n public class ValuesSourceRegistry {\n-    // Maps Aggregation names to (ValuesSourceType, Supplier) pairs, keyed by ValuesSourceType\n-    private Map<String, List<Map.Entry<Predicate<ValuesSourceType>, AggregatorSupplier>>> aggregatorRegistry = Map.of();\n-\n-    /**\n-     * Register a ValuesSource to Aggregator mapping.\n-     *\n-     * Threading behavior notes: This call is both synchronized and expensive. It copies the entire existing mapping structure each\n-     * time it is invoked.  We expect that register will be called a small number of times during startup only (as plugins are being\n-     * registered) and we can tolerate the cost at that time.  Once all plugins are registered, we should never need to call register\n-     * again.  Comparatively, we expect to do many reads from the registry data structures, and those reads may be interleaved on\n-     * different worker threads.  Thus we want to optimize the read case to be thread safe and fast, which the immutable\n-     * collections do well.  Using immutable collections requires a copy on write mechanic, thus the somewhat non-intuitive\n-     * implementation of this method.\n-     * @param aggregationName The name of the family of aggregations, typically found via {@link ValuesSourceAggregationBuilder#getType()}\n-     * @param appliesTo A predicate which accepts the resolved {@link ValuesSourceType} and decides if the given aggregator can be applied\n-     *                  to that type.\n-     * @param aggregatorSupplier An Aggregation-specific specialization of AggregatorSupplier which will construct the mapped aggregator\n-     */\n-    public synchronized void register(String aggregationName, Predicate<ValuesSourceType> appliesTo,\n-                                      AggregatorSupplier aggregatorSupplier) {\n-        AbstractMap.SimpleEntry[] mappings;\n-        if (aggregatorRegistry.containsKey(aggregationName)) {\n-            List currentMappings = aggregatorRegistry.get(aggregationName);\n-            mappings = (AbstractMap.SimpleEntry[]) currentMappings.toArray(new AbstractMap.SimpleEntry[currentMappings.size() + 1]);\n-        } else {\n-            mappings = new AbstractMap.SimpleEntry[1];\n+    public static class ValuesSourceRegistryBuilder {\n+        private Map<String, List<Map.Entry<Predicate<ValuesSourceType>, AggregatorSupplier>>> aggregatorRegistry = new HashMap<>();\n+        /**\n+         * Register a ValuesSource to Aggregator mapping.\n+         *\n+         * Threading behavior notes: This call is both synchronized and expensive. It copies the entire existing mapping structure each\n+         * time it is invoked.  We expect that register will be called a small number of times during startup only (as plugins are being\n+         * registered) and we can tolerate the cost at that time.  Once all plugins are registered, we should never need to call register\n+         * again.  Comparatively, we expect to do many reads from the registry data structures, and those reads may be interleaved on\n+         * different worker threads.  Thus we want to optimize the read case to be thread safe and fast, which the immutable\n+         * collections do well.  Using immutable collections requires a copy on write mechanic, thus the somewhat non-intuitive\n+         * implementation of this method.\n+         * @param aggregationName The name of the family of aggregations, typically found via\n+         *                        {@link ValuesSourceAggregationBuilder#getType()}\n+         * @param appliesTo A predicate which accepts the resolved {@link ValuesSourceType} and decides if the given aggregator can be\n+         *                  applied to that type.\n+         * @param aggregatorSupplier An Aggregation-specific specialization of AggregatorSupplier which will construct the mapped aggregator\n+         */\n+        public synchronized void register(String aggregationName, Predicate<ValuesSourceType> appliesTo,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbf6315307642b0e3e8ffcd239032b167956f901"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE3NTU3NA==", "bodyText": "I think your import order config is a bit confused here. I believe we usually put static last. Not a big deal, but it makes the diff bigger.", "url": "https://github.com/elastic/elasticsearch/pull/55493#discussion_r412175574", "createdAt": "2020-04-21T13:17:25Z", "author": {"login": "nik9000"}, "path": "test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java", "diffHunk": "@@ -18,6 +18,26 @@\n  */\n package org.elasticsearch.search.aggregations;\n \n+import static org.elasticsearch.test.InternalAggregationTestCase.DEFAULT_MAX_BUCKETS;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbf6315307642b0e3e8ffcd239032b167956f901"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "85f1b3013ae3037781eeda1d3445d3e3cb49787e", "author": {"user": {"login": "not-napoleon", "name": "Mark Tozzi"}}, "url": "https://github.com/elastic/elasticsearch/commit/85f1b3013ae3037781eeda1d3445d3e3cb49787e", "committedDate": "2020-04-21T16:24:13Z", "message": "Rename ValuesSourceRegistryBuilder -> Builder"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6b3cff655c8edb6e4c7d646b875e43225a2923b9", "author": {"user": {"login": "not-napoleon", "name": "Mark Tozzi"}}, "url": "https://github.com/elastic/elasticsearch/commit/6b3cff655c8edb6e4c7d646b875e43225a2923b9", "committedDate": "2020-04-22T19:02:54Z", "message": "fix checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fe58b1ff20b9497871385eb29c044192dda9e8a8", "author": {"user": {"login": "not-napoleon", "name": "Mark Tozzi"}}, "url": "https://github.com/elastic/elasticsearch/commit/fe58b1ff20b9497871385eb29c044192dda9e8a8", "committedDate": "2020-04-22T20:19:20Z", "message": "Make register private and not synchronized"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b063ae419b53ad9ab9a891846a3d3f714cc68972", "author": {"user": {"login": "not-napoleon", "name": "Mark Tozzi"}}, "url": "https://github.com/elastic/elasticsearch/commit/b063ae419b53ad9ab9a891846a3d3f714cc68972", "committedDate": "2020-04-22T20:19:24Z", "message": "Merge branch 'master' into vs-refactor-immutable-registry"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a3164675711e43d087f94e3154be17a86fdad895", "author": {"user": {"login": "not-napoleon", "name": "Mark Tozzi"}}, "url": "https://github.com/elastic/elasticsearch/commit/a3164675711e43d087f94e3154be17a86fdad895", "committedDate": "2020-04-22T21:18:04Z", "message": "Wire up new agg extention"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4NjE5NDMz", "url": "https://github.com/elastic/elasticsearch/pull/55493#pullrequestreview-398619433", "createdAt": "2020-04-22T21:57:36Z", "commit": {"oid": "a3164675711e43d087f94e3154be17a86fdad895"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMTo1NzozNlrOGKNj4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMTo1NzozNlrOGKNj4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM2MTEyMg==", "bodyText": "Is this still relevant ?", "url": "https://github.com/elastic/elasticsearch/pull/55493#discussion_r413361122", "createdAt": "2020-04-22T21:57:36Z", "author": {"login": "alx75"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/support/ValuesSourceRegistry.java", "diffHunk": "@@ -39,79 +41,101 @@\n  *\n  */\n public class ValuesSourceRegistry {\n-    // Maps Aggregation names to (ValuesSourceType, Supplier) pairs, keyed by ValuesSourceType\n-    private Map<String, List<Map.Entry<Predicate<ValuesSourceType>, AggregatorSupplier>>> aggregatorRegistry = Map.of();\n-\n-    /**\n-     * Register a ValuesSource to Aggregator mapping.\n-     *\n-     * Threading behavior notes: This call is both synchronized and expensive. It copies the entire existing mapping structure each\n-     * time it is invoked.  We expect that register will be called a small number of times during startup only (as plugins are being\n-     * registered) and we can tolerate the cost at that time.  Once all plugins are registered, we should never need to call register\n-     * again.  Comparatively, we expect to do many reads from the registry data structures, and those reads may be interleaved on\n-     * different worker threads.  Thus we want to optimize the read case to be thread safe and fast, which the immutable\n-     * collections do well.  Using immutable collections requires a copy on write mechanic, thus the somewhat non-intuitive\n-     * implementation of this method.\n-     * @param aggregationName The name of the family of aggregations, typically found via {@link ValuesSourceAggregationBuilder#getType()}\n-     * @param appliesTo A predicate which accepts the resolved {@link ValuesSourceType} and decides if the given aggregator can be applied\n-     *                  to that type.\n-     * @param aggregatorSupplier An Aggregation-specific specialization of AggregatorSupplier which will construct the mapped aggregator\n-     */\n-    public synchronized void register(String aggregationName, Predicate<ValuesSourceType> appliesTo,\n-                                      AggregatorSupplier aggregatorSupplier) {\n-        AbstractMap.SimpleEntry[] mappings;\n-        if (aggregatorRegistry.containsKey(aggregationName)) {\n-            List currentMappings = aggregatorRegistry.get(aggregationName);\n-            mappings = (AbstractMap.SimpleEntry[]) currentMappings.toArray(new AbstractMap.SimpleEntry[currentMappings.size() + 1]);\n-        } else {\n-            mappings = new AbstractMap.SimpleEntry[1];\n+    public static class Builder {\n+        private Map<String, List<Map.Entry<Predicate<ValuesSourceType>, AggregatorSupplier>>> aggregatorRegistry = new HashMap<>();\n+        /**\n+         * Register a ValuesSource to Aggregator mapping.\n+         *\n+         * Threading behavior notes: This call is both synchronized and expensive. It copies the entire existing mapping structure each", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3164675711e43d087f94e3154be17a86fdad895"}, "originalPosition": 44}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d912671ee9a9b0ff666b9413072150e9fbc60194", "author": {"user": {"login": "not-napoleon", "name": "Mark Tozzi"}}, "url": "https://github.com/elastic/elasticsearch/commit/d912671ee9a9b0ff666b9413072150e9fbc60194", "committedDate": "2020-04-23T13:01:55Z", "message": "Merge branch 'master' into vs-refactor-immutable-registry\n\n Conflicts:\n\tx-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/SpatialPlugin.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "946a6e48c23bddf440539eb75032ce8ecedebacf", "author": {"user": {"login": "not-napoleon", "name": "Mark Tozzi"}}, "url": "https://github.com/elastic/elasticsearch/commit/946a6e48c23bddf440539eb75032ce8ecedebacf", "committedDate": "2020-04-23T13:04:19Z", "message": "Removed no longer relevant javadoc"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk5MTA4OTE1", "url": "https://github.com/elastic/elasticsearch/pull/55493#pullrequestreview-399108915", "createdAt": "2020-04-23T13:44:59Z", "commit": {"oid": "946a6e48c23bddf440539eb75032ce8ecedebacf"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMzo0NDo1OVrOGKozSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMzo0NjowMlrOGKo2Ug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgwNzQzMw==", "bodyText": "\u2764\ufe0f", "url": "https://github.com/elastic/elasticsearch/pull/55493#discussion_r413807433", "createdAt": "2020-04-23T13:44:59Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/metrics/AvgAggregationBuilder.java", "diffHunk": "@@ -81,7 +81,8 @@ protected void innerWriteTo(StreamOutput out) {\n \n     @Override\n     protected AvgAggregatorFactory innerBuild(QueryShardContext queryShardContext, ValuesSourceConfig config,\n-                                              AggregatorFactory parent, Builder subFactoriesBuilder) throws IOException {\n+                                              AggregatorFactory parent,\n+                                              AggregatorFactories.Builder subFactoriesBuilder) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "946a6e48c23bddf440539eb75032ce8ecedebacf"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgwODIxMA==", "bodyText": "Javadoc instead?", "url": "https://github.com/elastic/elasticsearch/pull/55493#discussion_r413808210", "createdAt": "2020-04-23T13:46:02Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/support/ValuesSourceRegistry.java", "diffHunk": "@@ -39,79 +41,94 @@\n  *\n  */\n public class ValuesSourceRegistry {\n-    // Maps Aggregation names to (ValuesSourceType, Supplier) pairs, keyed by ValuesSourceType\n-    private Map<String, List<Map.Entry<Predicate<ValuesSourceType>, AggregatorSupplier>>> aggregatorRegistry = Map.of();\n-\n-    /**\n-     * Register a ValuesSource to Aggregator mapping.\n-     *\n-     * Threading behavior notes: This call is both synchronized and expensive. It copies the entire existing mapping structure each\n-     * time it is invoked.  We expect that register will be called a small number of times during startup only (as plugins are being\n-     * registered) and we can tolerate the cost at that time.  Once all plugins are registered, we should never need to call register\n-     * again.  Comparatively, we expect to do many reads from the registry data structures, and those reads may be interleaved on\n-     * different worker threads.  Thus we want to optimize the read case to be thread safe and fast, which the immutable\n-     * collections do well.  Using immutable collections requires a copy on write mechanic, thus the somewhat non-intuitive\n-     * implementation of this method.\n-     * @param aggregationName The name of the family of aggregations, typically found via {@link ValuesSourceAggregationBuilder#getType()}\n-     * @param appliesTo A predicate which accepts the resolved {@link ValuesSourceType} and decides if the given aggregator can be applied\n-     *                  to that type.\n-     * @param aggregatorSupplier An Aggregation-specific specialization of AggregatorSupplier which will construct the mapped aggregator\n-     */\n-    public synchronized void register(String aggregationName, Predicate<ValuesSourceType> appliesTo,\n-                                      AggregatorSupplier aggregatorSupplier) {\n-        AbstractMap.SimpleEntry[] mappings;\n-        if (aggregatorRegistry.containsKey(aggregationName)) {\n-            List currentMappings = aggregatorRegistry.get(aggregationName);\n-            mappings = (AbstractMap.SimpleEntry[]) currentMappings.toArray(new AbstractMap.SimpleEntry[currentMappings.size() + 1]);\n-        } else {\n-            mappings = new AbstractMap.SimpleEntry[1];\n+    public static class Builder {\n+        private Map<String, List<Map.Entry<Predicate<ValuesSourceType>, AggregatorSupplier>>> aggregatorRegistry = new HashMap<>();\n+        /**\n+         * Register a ValuesSource to Aggregator mapping.\n+         *\n+         * @param aggregationName The name of the family of aggregations, typically found via\n+         *                        {@link ValuesSourceAggregationBuilder#getType()}\n+         * @param appliesTo A predicate which accepts the resolved {@link ValuesSourceType} and decides if the given aggregator can be\n+         *                  applied to that type.\n+         * @param aggregatorSupplier An Aggregation-specific specialization of AggregatorSupplier which will construct the mapped aggregator\n+         */\n+        private void register(String aggregationName, Predicate<ValuesSourceType> appliesTo,\n+                                          AggregatorSupplier aggregatorSupplier) {\n+            if (aggregatorRegistry.containsKey(aggregationName) == false) {\n+                aggregatorRegistry.put(aggregationName, new ArrayList<>());\n+            }\n+            aggregatorRegistry.get(aggregationName).add( new AbstractMap.SimpleEntry<>(appliesTo, aggregatorSupplier));\n         }\n-        mappings[mappings.length - 1] = new AbstractMap.SimpleEntry<>(appliesTo, aggregatorSupplier);\n-        aggregatorRegistry = copyAndAdd(aggregatorRegistry,new AbstractMap.SimpleEntry<>(aggregationName, List.of(mappings)));\n-    }\n \n-    /**\n-     * Register a ValuesSource to Aggregator mapping.  This version provides a convenience method for mappings that only apply to a single\n-     * {@link ValuesSourceType}, to allow passing in the type and auto-wrapping it in a predicate\n-     *  @param aggregationName The name of the family of aggregations, typically found via {@link ValuesSourceAggregationBuilder#getType()}\n-     * @param valuesSourceType The ValuesSourceType this mapping applies to.\n-     * @param aggregatorSupplier An Aggregation-specific specialization of AggregatorSupplier which will construct the mapped aggregator\n-     *                           from the aggregation standard set of parameters\n-     */\n-    public void register(String aggregationName, ValuesSourceType valuesSourceType, AggregatorSupplier aggregatorSupplier) {\n-        register(aggregationName, (candidate) -> valuesSourceType.equals(candidate), aggregatorSupplier);\n-    }\n+        /**\n+         * Register a ValuesSource to Aggregator mapping.  This version provides a convenience method for mappings that only apply to a\n+         * single {@link ValuesSourceType}, to allow passing in the type and auto-wrapping it in a predicate\n+         * @param aggregationName The name of the family of aggregations, typically found via\n+         *                        {@link ValuesSourceAggregationBuilder#getType()}\n+         * @param valuesSourceType The ValuesSourceType this mapping applies to.\n+         * @param aggregatorSupplier An Aggregation-specific specialization of AggregatorSupplier which will construct the mapped aggregator\n+         *                           from the aggregation standard set of parameters\n+         */\n+        public void register(String aggregationName, ValuesSourceType valuesSourceType, AggregatorSupplier aggregatorSupplier) {\n+            register(aggregationName, (candidate) -> valuesSourceType.equals(candidate), aggregatorSupplier);\n+        }\n \n-    /**\n-     * Register a ValuesSource to Aggregator mapping.  This version provides a convenience method for mappings that only apply to a known\n-     * list of {@link ValuesSourceType}, to allow passing in the type and auto-wrapping it in a predicate\n-     *  @param aggregationName The name of the family of aggregations, typically found via {@link ValuesSourceAggregationBuilder#getType()}\n-     * @param valuesSourceTypes The ValuesSourceTypes this mapping applies to.\n-     * @param aggregatorSupplier An Aggregation-specific specialization of AggregatorSupplier which will construct the mapped aggregator\n-     *                           from the aggregation standard set of parameters\n-     */\n-    public void register(String aggregationName, List<ValuesSourceType> valuesSourceTypes, AggregatorSupplier aggregatorSupplier) {\n-        register(aggregationName, (candidate) -> {\n-            for (ValuesSourceType valuesSourceType : valuesSourceTypes) {\n-                if (valuesSourceType.equals(candidate)) {\n-                    return true;\n+        /**\n+         * Register a ValuesSource to Aggregator mapping.  This version provides a convenience method for mappings that only apply to a\n+         * known list of {@link ValuesSourceType}, to allow passing in the type and auto-wrapping it in a predicate\n+         *  @param aggregationName The name of the family of aggregations, typically found via\n+         *                         {@link ValuesSourceAggregationBuilder#getType()}\n+         * @param valuesSourceTypes The ValuesSourceTypes this mapping applies to.\n+         * @param aggregatorSupplier An Aggregation-specific specialization of AggregatorSupplier which will construct the mapped aggregator\n+         *                           from the aggregation standard set of parameters\n+         */\n+        public void register(String aggregationName, List<ValuesSourceType> valuesSourceTypes, AggregatorSupplier aggregatorSupplier) {\n+            register(aggregationName, (candidate) -> {\n+                for (ValuesSourceType valuesSourceType : valuesSourceTypes) {\n+                    if (valuesSourceType.equals(candidate)) {\n+                        return true;\n+                    }\n                 }\n-            }\n-            return false;\n-        }, aggregatorSupplier);\n+                return false;\n+            }, aggregatorSupplier);\n+        }\n+\n+        /**\n+         * Register an aggregator that applies to any values source type.  This is a convenience method for aggregations that do not care at\n+         * all about the types of their inputs.  Aggregations using this version of registration should not make any other registrations, as\n+         * the aggregator registered using this function will be applied in all cases.\n+         *\n+         * @param aggregationName The name of the family of aggregations, typically found via\n+         *                        {@link ValuesSourceAggregationBuilder#getType()}\n+         * @param aggregatorSupplier An Aggregation-specific specialization of AggregatorSupplier which will construct the mapped aggregator\n+         *                           from the aggregation standard set of parameters.\n+         */\n+        public void registerAny(String aggregationName, AggregatorSupplier aggregatorSupplier) {\n+            register(aggregationName, (ignored) -> true, aggregatorSupplier);\n+        }\n+\n+\n+        public ValuesSourceRegistry build() {\n+            return new ValuesSourceRegistry(aggregatorRegistry);\n+        }\n     }\n \n-    /**\n-     * Register an aggregator that applies to any values source type.  This is a convenience method for aggregations that do not care at all\n-     * about the types of their inputs.  Aggregations using this version of registration should not make any other registrations, as the\n-     * aggregator registered using this function will be applied in all cases.\n-     *\n-     * @param aggregationName The name of the family of aggregations, typically found via {@link ValuesSourceAggregationBuilder#getType()}\n-     * @param aggregatorSupplier An Aggregation-specific specialization of AggregatorSupplier which will construct the mapped aggregator\n-     *                           from the aggregation standard set of parameters.\n-     */\n-    public void registerAny(String aggregationName, AggregatorSupplier aggregatorSupplier) {\n-        register(aggregationName, (ignored) -> true, aggregatorSupplier);\n+    // Maps Aggregation names to (ValuesSourceType, Supplier) pairs, keyed by ValuesSourceType", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "946a6e48c23bddf440539eb75032ce8ecedebacf"}, "originalPosition": 152}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "05613f48a540208523b951d2c8723f523f31a024", "author": {"user": {"login": "not-napoleon", "name": "Mark Tozzi"}}, "url": "https://github.com/elastic/elasticsearch/commit/05613f48a540208523b951d2c8723f523f31a024", "committedDate": "2020-04-23T14:20:59Z", "message": "Javadoc"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 595, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}