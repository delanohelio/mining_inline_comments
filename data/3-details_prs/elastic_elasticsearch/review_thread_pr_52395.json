{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc1ODMxMjkw", "number": 52395, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNlQxNTowNjoyNVrODgN7LQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNlQxNTowNjoyNVrODgN7LQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MTA5MTY1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/translog/BufferedChecksumStreamInput.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNlQxNTowNjoyNVrOFqT3FA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNlQxNTowNjoyNVrOFqT3FA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTkwOTkwOA==", "bodyText": "I think even for short this is better than the previous solution. It certainly is when reading from a Netty ByteBuf backed buffer since we save one round of bounds checks.", "url": "https://github.com/elastic/elasticsearch/pull/52395#discussion_r379909908", "createdAt": "2020-02-16T15:06:25Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/index/translog/BufferedChecksumStreamInput.java", "diffHunk": "@@ -70,6 +70,30 @@ public void readBytes(byte[] b, int offset, int len) throws IOException {\n         digest.update(b, offset, len);\n     }\n \n+    private static final ThreadLocal<byte[]> buffer = ThreadLocal.withInitial(() -> new byte[8]);\n+\n+    @Override\n+    public short readShort() throws IOException {\n+        final byte[] buf = buffer.get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc7bb78cd97eef42d9a73045f0bd2085094bf4f6"}, "originalPosition": 8}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3916, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}