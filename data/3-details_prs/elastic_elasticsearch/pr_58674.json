{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQxNDQwNzI5", "number": 58674, "title": "Enhance real memory circuit breaker with G1 GC", "bodyText": "Using G1 GC, Elasticsearch can rarely trigger that heap usage goes above\nthe real memory circuit breaker limit and stays there for an extended\nperiod. This situation will persist until the next young GC. The circuit\nbreaking itself hinders that from occurring in a timely manner since it\nbreaks all request before real work is done.\nThis commit gently nudges G1 to do a young GC and then double checks\nthat heap usage is still above the real memory circuit breaker limit\nbefore throwing the circuit breaker exception.\nRelated to #57202\nReviewers: please also consider whether this should go to 7.8.1.\nThe overhead of triggering the GC is typically 1 ms when no concurrent cycle is running or around 10-20 ms on an 8GB heap and 20-40 ms on a 16GB heap (on my laptop). In addition to this comes a single young GC of 10-30 ms. On a bigger box, I get around 20-70 ms total overhead (time to trigger GC plus GC time) of 20-70 ms on a 30GB heap.", "createdAt": "2020-06-29T14:08:15Z", "url": "https://github.com/elastic/elasticsearch/pull/58674", "merged": true, "mergeCommit": {"oid": "c831f373f60ce1058c5f31fb2bc7c3ebcbb53826"}, "closed": true, "closedAt": "2020-07-13T10:38:19Z", "author": {"login": "henningandersen"}, "timelineItems": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcwBmQIAH2gAyNDQxNDQwNzI5OjA1ZWM5OGEzMmFjM2U1ZGZiNTE2NzI2YmY0OTA0ZjQxMmZjNjI1OTU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc0d8GPAH2gAyNDQxNDQwNzI5OjE0ZTU3NGNiMGUwNjFmOWU1ZTM2N2FiNmFhYWM5OGM0Zjk2MjQwMzk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "05ec98a32ac3e5dfb516726bf4904f412fc62595", "author": {"user": {"login": "henningandersen", "name": "Henning Andersen"}}, "url": "https://github.com/elastic/elasticsearch/commit/05ec98a32ac3e5dfb516726bf4904f412fc62595", "committedDate": "2020-06-29T14:06:08Z", "message": "Enhance real memory circuit breaker with G1 GC\n\nUsing G1 GC, Elasticsearch can rarely trigger that heap usage goes above\nthe real memory circuit breaker limit and stays there for an extended\nperiod. This situation will persist until the next young GC. The circuit\nbreaking itself hinders that from occurring in a timely manner since it\nbreaks all request before real work is done.\n\nThis commit gently nudges G1 to do a young GC and then double checks\nthat heap usage is still above the real memory circuit breaker limit\nbefore throwing the circuit breaker exception.\n\nRelated to #57202"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwMjkxMTg0", "url": "https://github.com/elastic/elasticsearch/pull/58674#pullrequestreview-440291184", "createdAt": "2020-06-30T18:43:58Z", "commit": {"oid": "05ec98a32ac3e5dfb516726bf4904f412fc62595"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxODo0Mzo1OVrOGrJ0Xw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxNDowNzowMlrOGrncRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkwMjgxNQ==", "bodyText": "Maybe name it OverLimitStrategy?", "url": "https://github.com/elastic/elasticsearch/pull/58674#discussion_r447902815", "createdAt": "2020-06-30T18:43:59Z", "author": {"login": "jaymode"}, "path": "server/src/main/java/org/elasticsearch/indices/breaker/HierarchyCircuitBreakerService.java", "diffHunk": "@@ -334,4 +360,113 @@ private CircuitBreaker validateAndCreateBreaker(BreakerSettings breakerSettings)\n                 this,\n                 breakerSettings.getName());\n     }\n+\n+    private static DoubleCheckStrategy createDoubleCheckStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,\n+                                                                 LongSupplier timeSupplier, long minimumInterval) {\n+        if (jvmInfo.useG1GC().equals(\"true\")\n+            // messing with GC is \"dangerous\" so we apply an escape hatch. Not intended to be used.\n+            && Boolean.parseBoolean(System.getProperty(\"es.real_memory_circuit_breaker.g1.double_check.enabled\", \"true\"))) {\n+            return new G1DoubleCheckStrategy(jvmInfo, currentMemoryUsageSupplier, timeSupplier, minimumInterval);\n+        } else {\n+            return memoryUsed -> memoryUsed;\n+        }\n+    }\n+\n+    interface DoubleCheckStrategy {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05ec98a32ac3e5dfb516726bf4904f412fc62595"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkwMzE1NA==", "bodyText": "can you add a link or reference to this calculation?", "url": "https://github.com/elastic/elasticsearch/pull/58674#discussion_r447903154", "createdAt": "2020-06-30T18:44:36Z", "author": {"login": "jaymode"}, "path": "server/src/main/java/org/elasticsearch/indices/breaker/HierarchyCircuitBreakerService.java", "diffHunk": "@@ -334,4 +360,113 @@ private CircuitBreaker validateAndCreateBreaker(BreakerSettings breakerSettings)\n                 this,\n                 breakerSettings.getName());\n     }\n+\n+    private static DoubleCheckStrategy createDoubleCheckStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,\n+                                                                 LongSupplier timeSupplier, long minimumInterval) {\n+        if (jvmInfo.useG1GC().equals(\"true\")\n+            // messing with GC is \"dangerous\" so we apply an escape hatch. Not intended to be used.\n+            && Boolean.parseBoolean(System.getProperty(\"es.real_memory_circuit_breaker.g1.double_check.enabled\", \"true\"))) {\n+            return new G1DoubleCheckStrategy(jvmInfo, currentMemoryUsageSupplier, timeSupplier, minimumInterval);\n+        } else {\n+            return memoryUsed -> memoryUsed;\n+        }\n+    }\n+\n+    interface DoubleCheckStrategy {\n+        MemoryUsage doubleCheck(MemoryUsage memoryUsed);\n+    }\n+\n+    static class G1DoubleCheckStrategy implements DoubleCheckStrategy {\n+        private final long g1RegionSize;\n+        private final LongSupplier currentMemoryUsageSupplier;\n+        private final LongSupplier timeSupplier;\n+\n+        private long lastCheckTime = Long.MIN_VALUE;\n+        private final long minimumInterval;\n+\n+        private long blackHole;\n+        private final Object lock = new Object();\n+\n+        G1DoubleCheckStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,\n+                                     LongSupplier timeSupplier, long minimumInterval) {\n+            assert minimumInterval > 0;\n+            this.currentMemoryUsageSupplier = currentMemoryUsageSupplier;\n+            this.timeSupplier = timeSupplier;\n+            this.minimumInterval = minimumInterval;\n+            long g1RegionSize = jvmInfo.getG1RegionSize();\n+            if (g1RegionSize <= 0) {\n+\n+                this.g1RegionSize = fallbackRegionSize(jvmInfo);\n+            } else {\n+                this.g1RegionSize = g1RegionSize;\n+            }\n+        }\n+\n+        static long fallbackRegionSize(JvmInfo jvmInfo) {\n+            // mimick JDK calculation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05ec98a32ac3e5dfb516726bf4904f412fc62595"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkwODU2NQ==", "bodyText": "unfortunately neither System.currentTimeMillis() nor System.nanoTime() are always monotonic so now could be less than the last checked time so I do not believe that this assert should be here", "url": "https://github.com/elastic/elasticsearch/pull/58674#discussion_r447908565", "createdAt": "2020-06-30T18:53:42Z", "author": {"login": "jaymode"}, "path": "server/src/main/java/org/elasticsearch/indices/breaker/HierarchyCircuitBreakerService.java", "diffHunk": "@@ -334,4 +360,113 @@ private CircuitBreaker validateAndCreateBreaker(BreakerSettings breakerSettings)\n                 this,\n                 breakerSettings.getName());\n     }\n+\n+    private static DoubleCheckStrategy createDoubleCheckStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,\n+                                                                 LongSupplier timeSupplier, long minimumInterval) {\n+        if (jvmInfo.useG1GC().equals(\"true\")\n+            // messing with GC is \"dangerous\" so we apply an escape hatch. Not intended to be used.\n+            && Boolean.parseBoolean(System.getProperty(\"es.real_memory_circuit_breaker.g1.double_check.enabled\", \"true\"))) {\n+            return new G1DoubleCheckStrategy(jvmInfo, currentMemoryUsageSupplier, timeSupplier, minimumInterval);\n+        } else {\n+            return memoryUsed -> memoryUsed;\n+        }\n+    }\n+\n+    interface DoubleCheckStrategy {\n+        MemoryUsage doubleCheck(MemoryUsage memoryUsed);\n+    }\n+\n+    static class G1DoubleCheckStrategy implements DoubleCheckStrategy {\n+        private final long g1RegionSize;\n+        private final LongSupplier currentMemoryUsageSupplier;\n+        private final LongSupplier timeSupplier;\n+\n+        private long lastCheckTime = Long.MIN_VALUE;\n+        private final long minimumInterval;\n+\n+        private long blackHole;\n+        private final Object lock = new Object();\n+\n+        G1DoubleCheckStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,\n+                                     LongSupplier timeSupplier, long minimumInterval) {\n+            assert minimumInterval > 0;\n+            this.currentMemoryUsageSupplier = currentMemoryUsageSupplier;\n+            this.timeSupplier = timeSupplier;\n+            this.minimumInterval = minimumInterval;\n+            long g1RegionSize = jvmInfo.getG1RegionSize();\n+            if (g1RegionSize <= 0) {\n+\n+                this.g1RegionSize = fallbackRegionSize(jvmInfo);\n+            } else {\n+                this.g1RegionSize = g1RegionSize;\n+            }\n+        }\n+\n+        static long fallbackRegionSize(JvmInfo jvmInfo) {\n+            // mimick JDK calculation\n+            long averageHeapSize =\n+                (jvmInfo.getMem().getHeapMax().getBytes() + JvmInfo.jvmInfo().getMem().getHeapMax().getBytes()) / 2;\n+            long regionSize = Long.highestOneBit(averageHeapSize / 2048);\n+            if (regionSize < ByteSizeUnit.MB.toBytes(1)) {\n+                regionSize = ByteSizeUnit.MB.toBytes(1);\n+            } else if (regionSize > ByteSizeUnit.MB.toBytes(32)) {\n+                regionSize = ByteSizeUnit.MB.toBytes(32);\n+            }\n+            return regionSize;\n+        }\n+\n+        @Override\n+        public MemoryUsage doubleCheck(MemoryUsage memoryUsed) {\n+            long maxHeap = JvmInfo.jvmInfo().getMem().getHeapMax().getBytes();\n+            boolean leader;\n+            synchronized (lock) {\n+                leader = timeSupplier.getAsLong() >= lastCheckTime + minimumInterval;\n+                doubleCheckingRealMemoryUsed(leader);\n+                if (leader) {\n+                    logger.info(\"attempting to trigger G1GC due to high heap usage [{}]\", memoryUsed.baseUsage);\n+                    long localBlackHole = 0;\n+                    // number of allocations, corresponding to (approximately) number of free regions + 1\n+                    long allocationCount = (maxHeap - memoryUsed.baseUsage) / g1RegionSize + 1;\n+                    // allocations of half-region size becomes single humongous alloc, thus taking up a full region.\n+                    int allocationSize = (int) (g1RegionSize >> 1);\n+                    long maxUsageObserved = memoryUsed.baseUsage;\n+                    for (long i = 0; i < allocationCount; ++i) {\n+                        long current = currentMemoryUsageSupplier.getAsLong();\n+                        if (current >= maxUsageObserved) {\n+                            maxUsageObserved = current;\n+                        } else {\n+                            // we observed a memory drop, so some GC must have occurred\n+                            break;\n+                        }\n+                        localBlackHole += new byte[allocationSize].hashCode();\n+                    }\n+\n+                    blackHole += localBlackHole;\n+                    logger.trace(\"black hole [{}]\", blackHole);\n+                    long now = timeSupplier.getAsLong();\n+                    assert now > this.lastCheckTime;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05ec98a32ac3e5dfb516726bf4904f412fc62595"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3Nzg2Nw==", "bodyText": "is it possible for this to trigger an OOM?", "url": "https://github.com/elastic/elasticsearch/pull/58674#discussion_r447977867", "createdAt": "2020-06-30T21:04:04Z", "author": {"login": "jaymode"}, "path": "server/src/main/java/org/elasticsearch/indices/breaker/HierarchyCircuitBreakerService.java", "diffHunk": "@@ -334,4 +360,113 @@ private CircuitBreaker validateAndCreateBreaker(BreakerSettings breakerSettings)\n                 this,\n                 breakerSettings.getName());\n     }\n+\n+    private static DoubleCheckStrategy createDoubleCheckStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,\n+                                                                 LongSupplier timeSupplier, long minimumInterval) {\n+        if (jvmInfo.useG1GC().equals(\"true\")\n+            // messing with GC is \"dangerous\" so we apply an escape hatch. Not intended to be used.\n+            && Boolean.parseBoolean(System.getProperty(\"es.real_memory_circuit_breaker.g1.double_check.enabled\", \"true\"))) {\n+            return new G1DoubleCheckStrategy(jvmInfo, currentMemoryUsageSupplier, timeSupplier, minimumInterval);\n+        } else {\n+            return memoryUsed -> memoryUsed;\n+        }\n+    }\n+\n+    interface DoubleCheckStrategy {\n+        MemoryUsage doubleCheck(MemoryUsage memoryUsed);\n+    }\n+\n+    static class G1DoubleCheckStrategy implements DoubleCheckStrategy {\n+        private final long g1RegionSize;\n+        private final LongSupplier currentMemoryUsageSupplier;\n+        private final LongSupplier timeSupplier;\n+\n+        private long lastCheckTime = Long.MIN_VALUE;\n+        private final long minimumInterval;\n+\n+        private long blackHole;\n+        private final Object lock = new Object();\n+\n+        G1DoubleCheckStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,\n+                                     LongSupplier timeSupplier, long minimumInterval) {\n+            assert minimumInterval > 0;\n+            this.currentMemoryUsageSupplier = currentMemoryUsageSupplier;\n+            this.timeSupplier = timeSupplier;\n+            this.minimumInterval = minimumInterval;\n+            long g1RegionSize = jvmInfo.getG1RegionSize();\n+            if (g1RegionSize <= 0) {\n+\n+                this.g1RegionSize = fallbackRegionSize(jvmInfo);\n+            } else {\n+                this.g1RegionSize = g1RegionSize;\n+            }\n+        }\n+\n+        static long fallbackRegionSize(JvmInfo jvmInfo) {\n+            // mimick JDK calculation\n+            long averageHeapSize =\n+                (jvmInfo.getMem().getHeapMax().getBytes() + JvmInfo.jvmInfo().getMem().getHeapMax().getBytes()) / 2;\n+            long regionSize = Long.highestOneBit(averageHeapSize / 2048);\n+            if (regionSize < ByteSizeUnit.MB.toBytes(1)) {\n+                regionSize = ByteSizeUnit.MB.toBytes(1);\n+            } else if (regionSize > ByteSizeUnit.MB.toBytes(32)) {\n+                regionSize = ByteSizeUnit.MB.toBytes(32);\n+            }\n+            return regionSize;\n+        }\n+\n+        @Override\n+        public MemoryUsage doubleCheck(MemoryUsage memoryUsed) {\n+            long maxHeap = JvmInfo.jvmInfo().getMem().getHeapMax().getBytes();\n+            boolean leader;\n+            synchronized (lock) {\n+                leader = timeSupplier.getAsLong() >= lastCheckTime + minimumInterval;\n+                doubleCheckingRealMemoryUsed(leader);\n+                if (leader) {\n+                    logger.info(\"attempting to trigger G1GC due to high heap usage [{}]\", memoryUsed.baseUsage);\n+                    long localBlackHole = 0;\n+                    // number of allocations, corresponding to (approximately) number of free regions + 1\n+                    long allocationCount = (maxHeap - memoryUsed.baseUsage) / g1RegionSize + 1;\n+                    // allocations of half-region size becomes single humongous alloc, thus taking up a full region.\n+                    int allocationSize = (int) (g1RegionSize >> 1);\n+                    long maxUsageObserved = memoryUsed.baseUsage;\n+                    for (long i = 0; i < allocationCount; ++i) {\n+                        long current = currentMemoryUsageSupplier.getAsLong();\n+                        if (current >= maxUsageObserved) {\n+                            maxUsageObserved = current;\n+                        } else {\n+                            // we observed a memory drop, so some GC must have occurred\n+                            break;\n+                        }\n+                        localBlackHole += new byte[allocationSize].hashCode();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05ec98a32ac3e5dfb516726bf4904f412fc62595"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODM4ODE2Nw==", "bodyText": "Any reason to use lock over this?", "url": "https://github.com/elastic/elasticsearch/pull/58674#discussion_r448388167", "createdAt": "2020-07-01T14:07:02Z", "author": {"login": "jaymode"}, "path": "server/src/main/java/org/elasticsearch/indices/breaker/HierarchyCircuitBreakerService.java", "diffHunk": "@@ -334,4 +360,113 @@ private CircuitBreaker validateAndCreateBreaker(BreakerSettings breakerSettings)\n                 this,\n                 breakerSettings.getName());\n     }\n+\n+    private static DoubleCheckStrategy createDoubleCheckStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,\n+                                                                 LongSupplier timeSupplier, long minimumInterval) {\n+        if (jvmInfo.useG1GC().equals(\"true\")\n+            // messing with GC is \"dangerous\" so we apply an escape hatch. Not intended to be used.\n+            && Boolean.parseBoolean(System.getProperty(\"es.real_memory_circuit_breaker.g1.double_check.enabled\", \"true\"))) {\n+            return new G1DoubleCheckStrategy(jvmInfo, currentMemoryUsageSupplier, timeSupplier, minimumInterval);\n+        } else {\n+            return memoryUsed -> memoryUsed;\n+        }\n+    }\n+\n+    interface DoubleCheckStrategy {\n+        MemoryUsage doubleCheck(MemoryUsage memoryUsed);\n+    }\n+\n+    static class G1DoubleCheckStrategy implements DoubleCheckStrategy {\n+        private final long g1RegionSize;\n+        private final LongSupplier currentMemoryUsageSupplier;\n+        private final LongSupplier timeSupplier;\n+\n+        private long lastCheckTime = Long.MIN_VALUE;\n+        private final long minimumInterval;\n+\n+        private long blackHole;\n+        private final Object lock = new Object();\n+\n+        G1DoubleCheckStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,\n+                                     LongSupplier timeSupplier, long minimumInterval) {\n+            assert minimumInterval > 0;\n+            this.currentMemoryUsageSupplier = currentMemoryUsageSupplier;\n+            this.timeSupplier = timeSupplier;\n+            this.minimumInterval = minimumInterval;\n+            long g1RegionSize = jvmInfo.getG1RegionSize();\n+            if (g1RegionSize <= 0) {\n+\n+                this.g1RegionSize = fallbackRegionSize(jvmInfo);\n+            } else {\n+                this.g1RegionSize = g1RegionSize;\n+            }\n+        }\n+\n+        static long fallbackRegionSize(JvmInfo jvmInfo) {\n+            // mimick JDK calculation\n+            long averageHeapSize =\n+                (jvmInfo.getMem().getHeapMax().getBytes() + JvmInfo.jvmInfo().getMem().getHeapMax().getBytes()) / 2;\n+            long regionSize = Long.highestOneBit(averageHeapSize / 2048);\n+            if (regionSize < ByteSizeUnit.MB.toBytes(1)) {\n+                regionSize = ByteSizeUnit.MB.toBytes(1);\n+            } else if (regionSize > ByteSizeUnit.MB.toBytes(32)) {\n+                regionSize = ByteSizeUnit.MB.toBytes(32);\n+            }\n+            return regionSize;\n+        }\n+\n+        @Override\n+        public MemoryUsage doubleCheck(MemoryUsage memoryUsed) {\n+            long maxHeap = JvmInfo.jvmInfo().getMem().getHeapMax().getBytes();\n+            boolean leader;\n+            synchronized (lock) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05ec98a32ac3e5dfb516726bf4904f412fc62595"}, "originalPosition": 151}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b6b565aee012e8bb5ca204b832a4995a3144475d", "author": {"user": {"login": "henningandersen", "name": "Henning Andersen"}}, "url": "https://github.com/elastic/elasticsearch/commit/b6b565aee012e8bb5ca204b832a4995a3144475d", "committedDate": "2020-07-01T19:34:59Z", "message": "Time not monotonic."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c8ac1af58e5edc9d2f718070e8da846912d0010f", "author": {"user": {"login": "henningandersen", "name": "Henning Andersen"}}, "url": "https://github.com/elastic/elasticsearch/commit/c8ac1af58e5edc9d2f718070e8da846912d0010f", "committedDate": "2020-07-01T19:45:21Z", "message": "Add link to JDK G1 region size calculation."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1d007ca5fbd148887449a9c794d37eb46c57184f", "author": {"user": {"login": "henningandersen", "name": "Henning Andersen"}}, "url": "https://github.com/elastic/elasticsearch/commit/1d007ca5fbd148887449a9c794d37eb46c57184f", "committedDate": "2020-07-01T19:53:47Z", "message": "Rename to \"over limit\" rather than \"double check\""}}, {"__typename": "PullRequestCommit", "commit": {"oid": "66d642dd32bc3f92510a94ecfba3da12b2cd3f86", "author": {"user": {"login": "henningandersen", "name": "Henning Andersen"}}, "url": "https://github.com/elastic/elasticsearch/commit/66d642dd32bc3f92510a94ecfba3da12b2cd3f86", "committedDate": "2020-07-01T20:59:16Z", "message": "Merge remote-tracking branch 'origin/master' into enhance_g1_circuit_breaking"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzMjU2NjM3", "url": "https://github.com/elastic/elasticsearch/pull/58674#pullrequestreview-443256637", "createdAt": "2020-07-06T17:00:41Z", "commit": {"oid": "66d642dd32bc3f92510a94ecfba3da12b2cd3f86"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxNzowMDo0MVrOGtfxOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxNzowMToyNFrOGtfylA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM1OTYxMA==", "bodyText": "Since this appears to be a consistent value, maybe we just keep it as a final long that is a class member.", "url": "https://github.com/elastic/elasticsearch/pull/58674#discussion_r450359610", "createdAt": "2020-07-06T17:00:41Z", "author": {"login": "jaymode"}, "path": "server/src/main/java/org/elasticsearch/indices/breaker/HierarchyCircuitBreakerService.java", "diffHunk": "@@ -334,4 +360,116 @@ private CircuitBreaker validateAndCreateBreaker(BreakerSettings breakerSettings)\n                 this,\n                 breakerSettings.getName());\n     }\n+\n+    private static OverLimitStrategy createDoubleCheckStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,\n+                                                               LongSupplier timeSupplier, long minimumInterval) {\n+        if (jvmInfo.useG1GC().equals(\"true\")\n+            // messing with GC is \"dangerous\" so we apply an escape hatch. Not intended to be used.\n+            && Boolean.parseBoolean(System.getProperty(\"es.real_memory_circuit_breaker.g1.double_check.enabled\", \"true\"))) {\n+            return new G1OverLimitStrategy(jvmInfo, currentMemoryUsageSupplier, timeSupplier, minimumInterval);\n+        } else {\n+            return memoryUsed -> memoryUsed;\n+        }\n+    }\n+\n+    interface OverLimitStrategy {\n+        MemoryUsage overLimit(MemoryUsage memoryUsed);\n+    }\n+\n+    static class G1OverLimitStrategy implements OverLimitStrategy {\n+        private final long g1RegionSize;\n+        private final LongSupplier currentMemoryUsageSupplier;\n+        private final LongSupplier timeSupplier;\n+\n+        private long lastCheckTime = Long.MIN_VALUE;\n+        private final long minimumInterval;\n+\n+        private long blackHole;\n+        private final Object lock = new Object();\n+\n+        G1OverLimitStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,\n+                            LongSupplier timeSupplier, long minimumInterval) {\n+            assert minimumInterval > 0;\n+            this.currentMemoryUsageSupplier = currentMemoryUsageSupplier;\n+            this.timeSupplier = timeSupplier;\n+            this.minimumInterval = minimumInterval;\n+            long g1RegionSize = jvmInfo.getG1RegionSize();\n+            if (g1RegionSize <= 0) {\n+\n+                this.g1RegionSize = fallbackRegionSize(jvmInfo);\n+            } else {\n+                this.g1RegionSize = g1RegionSize;\n+            }\n+        }\n+\n+        static long fallbackRegionSize(JvmInfo jvmInfo) {\n+            // mimick JDK calculation based on JDK 14 source:\n+            // https://hg.openjdk.java.net/jdk/jdk14/file/6c954123ee8d/src/hotspot/share/gc/g1/heapRegion.cpp#l65\n+            // notice that newer JDKs will have a slight variant only considering max-heap:\n+            // https://hg.openjdk.java.net/jdk/jdk/file/e7d0ec2d06e8/src/hotspot/share/gc/g1/heapRegion.cpp#l67\n+            // based on this JDK \"bug\":\n+            // https://bugs.openjdk.java.net/browse/JDK-8241670\n+            long averageHeapSize =\n+                (jvmInfo.getMem().getHeapMax().getBytes() + JvmInfo.jvmInfo().getMem().getHeapMax().getBytes()) / 2;\n+            long regionSize = Long.highestOneBit(averageHeapSize / 2048);\n+            if (regionSize < ByteSizeUnit.MB.toBytes(1)) {\n+                regionSize = ByteSizeUnit.MB.toBytes(1);\n+            } else if (regionSize > ByteSizeUnit.MB.toBytes(32)) {\n+                regionSize = ByteSizeUnit.MB.toBytes(32);\n+            }\n+            return regionSize;\n+        }\n+\n+        @Override\n+        public MemoryUsage overLimit(MemoryUsage memoryUsed) {\n+            long maxHeap = JvmInfo.jvmInfo().getMem().getHeapMax().getBytes();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66d642dd32bc3f92510a94ecfba3da12b2cd3f86"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM1OTk1Ng==", "bodyText": "I'm fine with it; just curious.", "url": "https://github.com/elastic/elasticsearch/pull/58674#discussion_r450359956", "createdAt": "2020-07-06T17:01:24Z", "author": {"login": "jaymode"}, "path": "server/src/main/java/org/elasticsearch/indices/breaker/HierarchyCircuitBreakerService.java", "diffHunk": "@@ -334,4 +360,113 @@ private CircuitBreaker validateAndCreateBreaker(BreakerSettings breakerSettings)\n                 this,\n                 breakerSettings.getName());\n     }\n+\n+    private static DoubleCheckStrategy createDoubleCheckStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,\n+                                                                 LongSupplier timeSupplier, long minimumInterval) {\n+        if (jvmInfo.useG1GC().equals(\"true\")\n+            // messing with GC is \"dangerous\" so we apply an escape hatch. Not intended to be used.\n+            && Boolean.parseBoolean(System.getProperty(\"es.real_memory_circuit_breaker.g1.double_check.enabled\", \"true\"))) {\n+            return new G1DoubleCheckStrategy(jvmInfo, currentMemoryUsageSupplier, timeSupplier, minimumInterval);\n+        } else {\n+            return memoryUsed -> memoryUsed;\n+        }\n+    }\n+\n+    interface DoubleCheckStrategy {\n+        MemoryUsage doubleCheck(MemoryUsage memoryUsed);\n+    }\n+\n+    static class G1DoubleCheckStrategy implements DoubleCheckStrategy {\n+        private final long g1RegionSize;\n+        private final LongSupplier currentMemoryUsageSupplier;\n+        private final LongSupplier timeSupplier;\n+\n+        private long lastCheckTime = Long.MIN_VALUE;\n+        private final long minimumInterval;\n+\n+        private long blackHole;\n+        private final Object lock = new Object();\n+\n+        G1DoubleCheckStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,\n+                                     LongSupplier timeSupplier, long minimumInterval) {\n+            assert minimumInterval > 0;\n+            this.currentMemoryUsageSupplier = currentMemoryUsageSupplier;\n+            this.timeSupplier = timeSupplier;\n+            this.minimumInterval = minimumInterval;\n+            long g1RegionSize = jvmInfo.getG1RegionSize();\n+            if (g1RegionSize <= 0) {\n+\n+                this.g1RegionSize = fallbackRegionSize(jvmInfo);\n+            } else {\n+                this.g1RegionSize = g1RegionSize;\n+            }\n+        }\n+\n+        static long fallbackRegionSize(JvmInfo jvmInfo) {\n+            // mimick JDK calculation\n+            long averageHeapSize =\n+                (jvmInfo.getMem().getHeapMax().getBytes() + JvmInfo.jvmInfo().getMem().getHeapMax().getBytes()) / 2;\n+            long regionSize = Long.highestOneBit(averageHeapSize / 2048);\n+            if (regionSize < ByteSizeUnit.MB.toBytes(1)) {\n+                regionSize = ByteSizeUnit.MB.toBytes(1);\n+            } else if (regionSize > ByteSizeUnit.MB.toBytes(32)) {\n+                regionSize = ByteSizeUnit.MB.toBytes(32);\n+            }\n+            return regionSize;\n+        }\n+\n+        @Override\n+        public MemoryUsage doubleCheck(MemoryUsage memoryUsed) {\n+            long maxHeap = JvmInfo.jvmInfo().getMem().getHeapMax().getBytes();\n+            boolean leader;\n+            synchronized (lock) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODM4ODE2Nw=="}, "originalCommit": {"oid": "05ec98a32ac3e5dfb516726bf4904f412fc62595"}, "originalPosition": 151}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3eacf32b9ad90fa5029ca55c31b8e90a233d389e", "author": {"user": {"login": "henningandersen", "name": "Henning Andersen"}}, "url": "https://github.com/elastic/elasticsearch/commit/3eacf32b9ad90fa5029ca55c31b8e90a233d389e", "committedDate": "2020-07-07T13:47:48Z", "message": "Keep maxHeap in field."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "addeede803b72a12f01a5218b48838a75e763b3e", "author": {"user": {"login": "henningandersen", "name": "Henning Andersen"}}, "url": "https://github.com/elastic/elasticsearch/commit/addeede803b72a12f01a5218b48838a75e763b3e", "committedDate": "2020-07-07T14:00:30Z", "message": "Improved logging."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0MDM0MjAx", "url": "https://github.com/elastic/elasticsearch/pull/58674#pullrequestreview-444034201", "createdAt": "2020-07-07T16:00:21Z", "commit": {"oid": "66d642dd32bc3f92510a94ecfba3da12b2cd3f86"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNjowMDoyMlrOGuFTUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNjoyMTo0M1rOGuGJQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk3NDU0Nw==", "bodyText": "Maybe the method call can be replaced with overLimitStrategy.apply(memoryUsed) and the construction of the OverLimitStrategy will be responsible for handling the behavior of what to do?", "url": "https://github.com/elastic/elasticsearch/pull/58674#discussion_r450974547", "createdAt": "2020-07-07T16:00:22Z", "author": {"login": "jaymode"}, "path": "server/src/main/java/org/elasticsearch/indices/breaker/HierarchyCircuitBreakerService.java", "diffHunk": "@@ -290,7 +308,7 @@ public long getParentLimit() {\n     public void checkParentLimit(long newBytesReserved, String label) throws CircuitBreakingException {\n         final MemoryUsage memoryUsed = memoryUsed(newBytesReserved);\n         long parentLimit = this.parentSettings.getLimit();\n-        if (memoryUsed.totalUsage > parentLimit) {\n+        if (memoryUsed.totalUsage > parentLimit && doubleCheckMemoryUsed(memoryUsed).totalUsage > parentLimit) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66d642dd32bc3f92510a94ecfba3da12b2cd3f86"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk4NTI5MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static OverLimitStrategy createDoubleCheckStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,\n          \n          \n            \n                private static OverLimitStrategy createOverLimitStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,", "url": "https://github.com/elastic/elasticsearch/pull/58674#discussion_r450985291", "createdAt": "2020-07-07T16:16:47Z", "author": {"login": "jaymode"}, "path": "server/src/main/java/org/elasticsearch/indices/breaker/HierarchyCircuitBreakerService.java", "diffHunk": "@@ -334,4 +360,116 @@ private CircuitBreaker validateAndCreateBreaker(BreakerSettings breakerSettings)\n                 this,\n                 breakerSettings.getName());\n     }\n+\n+    private static OverLimitStrategy createDoubleCheckStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66d642dd32bc3f92510a94ecfba3da12b2cd3f86"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk4NzIxNA==", "bodyText": "In line with an earlier comment, we could pass in trackRealMemoryUsage to this method and add it to this check.", "url": "https://github.com/elastic/elasticsearch/pull/58674#discussion_r450987214", "createdAt": "2020-07-07T16:19:58Z", "author": {"login": "jaymode"}, "path": "server/src/main/java/org/elasticsearch/indices/breaker/HierarchyCircuitBreakerService.java", "diffHunk": "@@ -334,4 +360,116 @@ private CircuitBreaker validateAndCreateBreaker(BreakerSettings breakerSettings)\n                 this,\n                 breakerSettings.getName());\n     }\n+\n+    private static OverLimitStrategy createDoubleCheckStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,\n+                                                               LongSupplier timeSupplier, long minimumInterval) {\n+        if (jvmInfo.useG1GC().equals(\"true\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66d642dd32bc3f92510a94ecfba3da12b2cd3f86"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk4ODM1NA==", "bodyText": "Do you mind using Booleans.parseBoolean(System.getProperty(\"es.real_memory_circuit_breaker.g1.double_check.enabled\"), true)? The java Boolean parsing is pretty lenient and I thought it was a forbidden api at some point :|", "url": "https://github.com/elastic/elasticsearch/pull/58674#discussion_r450988354", "createdAt": "2020-07-07T16:21:43Z", "author": {"login": "jaymode"}, "path": "server/src/main/java/org/elasticsearch/indices/breaker/HierarchyCircuitBreakerService.java", "diffHunk": "@@ -334,4 +360,116 @@ private CircuitBreaker validateAndCreateBreaker(BreakerSettings breakerSettings)\n                 this,\n                 breakerSettings.getName());\n     }\n+\n+    private static OverLimitStrategy createDoubleCheckStrategy(JvmInfo jvmInfo, LongSupplier currentMemoryUsageSupplier,\n+                                                               LongSupplier timeSupplier, long minimumInterval) {\n+        if (jvmInfo.useG1GC().equals(\"true\")\n+            // messing with GC is \"dangerous\" so we apply an escape hatch. Not intended to be used.\n+            && Boolean.parseBoolean(System.getProperty(\"es.real_memory_circuit_breaker.g1.double_check.enabled\", \"true\"))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66d642dd32bc3f92510a94ecfba3da12b2cd3f86"}, "originalPosition": 97}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "110925d155e95eefce529507d8540d24da90c996", "author": {"user": {"login": "henningandersen", "name": "Henning Andersen"}}, "url": "https://github.com/elastic/elasticsearch/commit/110925d155e95eefce529507d8540d24da90c996", "committedDate": "2020-07-07T19:04:52Z", "message": "Also check young GC counts."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cfde2a7a4bfd26de50a0f189fff2038af82598ce", "author": {"user": {"login": "henningandersen", "name": "Henning Andersen"}}, "url": "https://github.com/elastic/elasticsearch/commit/cfde2a7a4bfd26de50a0f189fff2038af82598ce", "committedDate": "2020-07-07T19:08:49Z", "message": "Move wiring into createDoubleCheckStrategy."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fea2ddc674d6d7234fc80767c3a2473e0410bc8d", "author": {"user": {"login": "henningandersen", "name": "Henning Andersen"}}, "url": "https://github.com/elastic/elasticsearch/commit/fea2ddc674d6d7234fc80767c3a2473e0410bc8d", "committedDate": "2020-07-07T19:14:01Z", "message": "createOverLimitStrategy naming"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "845dc109955ad5dd2b60f247541de9c0fc328225", "author": {"user": {"login": "henningandersen", "name": "Henning Andersen"}}, "url": "https://github.com/elastic/elasticsearch/commit/845dc109955ad5dd2b60f247541de9c0fc328225", "committedDate": "2020-07-07T19:15:14Z", "message": "Use Booleans.parseBoolean"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3f61f93f6660b32153047b7fb0393b314510d238", "author": {"user": {"login": "henningandersen", "name": "Henning Andersen"}}, "url": "https://github.com/elastic/elasticsearch/commit/3f61f93f6660b32153047b7fb0393b314510d238", "committedDate": "2020-07-07T20:57:38Z", "message": "Always call the over limit strategy\n\nNow determine strategy based on whether real memory usage is\ntracked."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "55a17746c7efd04978dbf6fe1fbb5ded7fbbdc25", "author": {"user": {"login": "henningandersen", "name": "Henning Andersen"}}, "url": "https://github.com/elastic/elasticsearch/commit/55a17746c7efd04978dbf6fe1fbb5ded7fbbdc25", "committedDate": "2020-07-07T21:14:47Z", "message": "Fix test stability\n\nTest would not always trigger the over limit check twice, fixed."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ed460f9e9cbb0b23158c6e731664d109aeb8c548", "author": {"user": {"login": "henningandersen", "name": "Henning Andersen"}}, "url": "https://github.com/elastic/elasticsearch/commit/ed460f9e9cbb0b23158c6e731664d109aeb8c548", "committedDate": "2020-07-07T21:22:07Z", "message": "Improved code formatting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7d148d0374d16f2011e4e44afcccef1b1cc67c6e", "author": {"user": {"login": "henningandersen", "name": "Henning Andersen"}}, "url": "https://github.com/elastic/elasticsearch/commit/7d148d0374d16f2011e4e44afcccef1b1cc67c6e", "committedDate": "2020-07-07T21:23:36Z", "message": "Better field order."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "263f474dc279149e746b7e264c8fd790efc23baf", "author": {"user": {"login": "henningandersen", "name": "Henning Andersen"}}, "url": "https://github.com/elastic/elasticsearch/commit/263f474dc279149e746b7e264c8fd790efc23baf", "committedDate": "2020-07-07T21:25:50Z", "message": "Few line reorderings"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "79bd399eceef4a2766e703d496716d96eddaf790", "author": {"user": {"login": "henningandersen", "name": "Henning Andersen"}}, "url": "https://github.com/elastic/elasticsearch/commit/79bd399eceef4a2766e703d496716d96eddaf790", "committedDate": "2020-07-08T04:54:16Z", "message": "Merge remote-tracking branch 'origin/master' into enhance_g1_circuit_breaking"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "facd321c5a4114d8a5425a5d278faa02bfa1b584", "author": {"user": {"login": "henningandersen", "name": "Henning Andersen"}}, "url": "https://github.com/elastic/elasticsearch/commit/facd321c5a4114d8a5425a5d278faa02bfa1b584", "committedDate": "2020-07-08T06:34:35Z", "message": "Added lock timeout."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2OTAyNDQ3", "url": "https://github.com/elastic/elasticsearch/pull/58674#pullrequestreview-446902447", "createdAt": "2020-07-12T19:05:45Z", "commit": {"oid": "facd321c5a4114d8a5425a5d278faa02bfa1b584"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "14e574cb0e061f9e5e367ab6aaac98c4f9624039", "author": {"user": {"login": "elasticmachine", "name": "Elastic Machine"}}, "url": "https://github.com/elastic/elasticsearch/commit/14e574cb0e061f9e5e367ab6aaac98c4f9624039", "committedDate": "2020-07-13T09:23:02Z", "message": "Merge branch 'master' into enhance_g1_circuit_breaking"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2541, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}