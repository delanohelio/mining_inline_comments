{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI3OTIyNzg1", "number": 65531, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxMDowMToyNVrOE9j_jg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwNzozNTo0OVrOFCxmUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyOTg4MzAyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/indices/recovery/PeerRecoveryTargetService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxMDowMToyNVrOH6UJpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxMDowMToyNVrOH6UJpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDkwOTYwNA==", "bodyText": "This is a bit of a BwC issue I guess. If the hand-off request comes from 7.10 and doesn't wait indefinitely yet then it could timeout on the primary I guess but maybe we can just ignore it since it's so fringe?", "url": "https://github.com/elastic/elasticsearch/pull/65531#discussion_r530909604", "createdAt": "2020-11-26T10:01:25Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/indices/recovery/PeerRecoveryTargetService.java", "diffHunk": "@@ -312,16 +316,23 @@ public void messageReceived(RecoveryFinalizeRecoveryRequest request, TransportCh\n         public void messageReceived(final RecoveryHandoffPrimaryContextRequest request, final TransportChannel channel,\n                                     Task task) throws Exception {\n             final RecoveryRef recoveryRef = onGoingRecoveries.getRecoverySafe(request.recoveryId(), request.shardId());\n+            final List<Releasable> toRelease = new ArrayList<>(2);\n+            toRelease.add(recoveryRef::close);\n             boolean success = false;\n             try {\n+                // Due to relocation conditions on the shard it could take a while for the hand-off to complete so we disable the recovery\n+                // monitor since we don't expect any transport messages from master for the duration of the handoff and activate it again\n+                // after the handoff.\n+                final Releasable disabledMonitor = recoveryRef.target().disableRecoveryMonitor();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74eae5cbbd7a7780e66f20da3b47d6d5883c974d"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyOTkxMDgzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/indices/recovery/RecoveryTarget.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxMDowODoxNVrOH6UakA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxMDowODoxNVrOH6UakA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDkxMzkzNg==", "bodyText": "This is a little low-tech relative to the tricky ref-counting in the IndexShard.  I figured this was ok here since the hand-off request only comes in once (at least judging by the assertions we have in IndexShard) while the other API has a more \"feel\" to it and there are no hard guarantees on the index shard state listener only being invoked once (though the \"loaded\" flag on the directory effectively guarantees we only add one condition for now) and it wasn't that much extra effort since the API was supposed to be non-blocking anyway.", "url": "https://github.com/elastic/elasticsearch/pull/65531#discussion_r530913936", "createdAt": "2020-11-26T10:08:15Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/indices/recovery/RecoveryTarget.java", "diffHunk": "@@ -161,6 +164,26 @@ public void setLastAccessTime() {\n         lastAccessTime = System.nanoTime();\n     }\n \n+    /**\n+     * Set flag to signal to {@link org.elasticsearch.indices.recovery.RecoveriesCollection.RecoveryMonitor} that it must not cancel this\n+     * recovery temporarily. This is used by the primary relocation mechanism to avoid recovery failure in case a long running relocation\n+     * condition was added to the shard via {@link IndexShard#createRelocationDependency()}.\n+     *\n+     * @return releasable that once closed will re-enable liveness checks by the recovery monitor\n+     */\n+    public Releasable disableRecoveryMonitor() {\n+        assert recoveryMonitorEnabled : \"recovery monitor already disabled\";\n+        recoveryMonitorEnabled = false;\n+        return () -> {\n+            setLastAccessTime();\n+            recoveryMonitorEnabled = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74eae5cbbd7a7780e66f20da3b47d6d5883c974d"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0MDU0MjMyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/shard/IndexShard.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxMDowNDo0NlrOH7zz-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxMDowNDo0NlrOH7zz-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQ3NjkyMQ==", "bodyText": "Could we do this outside the synchronized block? Not sure it is important, but simplifies reading the code.", "url": "https://github.com/elastic/elasticsearch/pull/65531#discussion_r532476921", "createdAt": "2020-11-30T10:04:46Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/index/shard/IndexShard.java", "diffHunk": "@@ -457,6 +461,38 @@ public QueryCachingPolicy getQueryCachingPolicy() {\n         return cachingPolicy;\n     }\n \n+    /**\n+     * A ref counter that can be used to delay primary relocation handoff via {@link #createRelocationDependency()}.\n+     */\n+    private final class RelocationCondition extends AbstractRefCounted {\n+\n+        private Runnable asyncActivation;\n+\n+        RelocationCondition(ShardRouting routing) {\n+            super(\"relocation condition for [\" + routing.shardId() + \"][\" + routing.allocationId() + \"]\");\n+        }\n+\n+        @Override\n+        protected void closeInternal() {\n+            synchronized (this) {\n+                if (asyncActivation != null) {\n+                    threadPool.generic().execute(asyncActivation);\n+                }\n+            }\n+        }\n+\n+        // Set the relocation context when receiving it and execute the handoff right away if no more conditions are waiting or create a\n+        // Runnable to execute once all conditions have finished\n+        void receivePrimaryContext(ReplicationTracker.PrimaryContext primaryContext, ActionListener<Void> listener) {\n+            synchronized (this) {\n+                if (decRef()) {\n+                    doActivateWithPrimaryContext(primaryContext, listener);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa8dea685d6e4d5ac5d566e5ffafb20918e01a53"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0MDU2MTQzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/shard/IndexShard.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxMDowOToyNFrOH7z-_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxMDowOToyNFrOH7z-_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQ3OTc0Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * {@link #activateThrottling()}.\n          \n          \n            \n                 * {@link #activateWithPrimaryContext()}.", "url": "https://github.com/elastic/elasticsearch/pull/65531#discussion_r532479743", "createdAt": "2020-11-30T10:09:24Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/index/shard/IndexShard.java", "diffHunk": "@@ -2409,23 +2453,62 @@ assert state() != IndexShardState.POST_RECOVERY && state() != IndexShardState.ST\n         replicationTracker.updateGlobalCheckpointOnReplica(globalCheckpoint, reason);\n     }\n \n+    private RelocationCondition relocationCondition;\n+\n+    /**\n+     * Creates a {@link Runnable} that must be executed before primary relocation to this shard can complete by a call to\n+     * {@link #activateThrottling()}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa8dea685d6e4d5ac5d566e5ffafb20918e01a53"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0MDcyNDQxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/indices/recovery/RecoveriesCollection.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxMDo0ODowMVrOH71gCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxMDo0ODowMVrOH71gCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjUwNDU4NA==", "bodyText": "I think it might be simpler to just fake the progress inside RecoveryTarget by returning System.nanoTime()?", "url": "https://github.com/elastic/elasticsearch/pull/65531#discussion_r532504584", "createdAt": "2020-11-30T10:48:01Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/indices/recovery/RecoveriesCollection.java", "diffHunk": "@@ -275,16 +275,20 @@ protected void doRun() throws Exception {\n                 logger.trace(\"[monitor] no status found for [{}], shutting down\", recoveryId);\n                 return;\n             }\n-            long accessTime = status.lastAccessTime();\n-            if (accessTime == lastSeenAccessTime) {\n-                String message = \"no activity after [\" + checkInterval + \"]\";\n-                failRecovery(recoveryId,\n-                        new RecoveryFailedException(status.state(), message, new ElasticsearchTimeoutException(message)),\n-                        true // to be safe, we don't know what go stuck\n-                );\n-                return;\n+            if (status.isRecoveryMonitorEnabled()) {\n+                long accessTime = status.lastAccessTime();\n+                if (accessTime == lastSeenAccessTime) {\n+                    String message = \"no activity after [\" + checkInterval + \"]\";\n+                    failRecovery(recoveryId,\n+                            new RecoveryFailedException(status.state(), message, new ElasticsearchTimeoutException(message)),\n+                            true // to be safe, we don't know what go stuck\n+                    );\n+                    return;\n+                }\n+                lastSeenAccessTime = accessTime;\n+            } else {\n+                lastSeenAccessTime = System.nanoTime();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa8dea685d6e4d5ac5d566e5ffafb20918e01a53"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NDUwODA2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/internalClusterTest/java/org/elasticsearch/xpack/searchablesnapshots/SearchableSnapshotsRelocationIntegTests.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwNzoyNjoxMVrOICGE6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwOTo1OToyM1rOICMM3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA2NzYyNQ==", "bodyText": "Could we instead find the shard using internalCluster().getInstance(IndicesService.class, node) and assertBusy that it has a pending after cleanup action?", "url": "https://github.com/elastic/elasticsearch/pull/65531#discussion_r539067625", "createdAt": "2020-12-09T07:26:11Z", "author": {"login": "henningandersen"}, "path": "x-pack/plugin/searchable-snapshots/src/internalClusterTest/java/org/elasticsearch/xpack/searchablesnapshots/SearchableSnapshotsRelocationIntegTests.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.searchablesnapshots;\n+\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.indices.recovery.RecoveryState;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.snapshots.mockstore.MockRepository;\n+import org.elasticsearch.test.ESIntegTestCase;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.hamcrest.Matchers;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.CyclicBarrier;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n+\n+@ESIntegTestCase.ClusterScope(scope = ESIntegTestCase.Scope.TEST, numDataNodes = 0)\n+public class SearchableSnapshotsRelocationIntegTests extends BaseSearchableSnapshotsIntegTestCase {\n+\n+    @Override\n+    protected Collection<Class<? extends Plugin>> nodePlugins() {\n+        return List.of(LocalStateSearchableSnapshots.class, MockRepository.Plugin.class);\n+    }\n+\n+    public void testRelocationWaitsForPreWarm() throws Exception {\n+        internalCluster().startMasterOnlyNode();\n+        final String firstDataNode = internalCluster().startDataOnlyNode();\n+        final String index = \"test-idx\";\n+        createIndexWithContent(index, indexSettingsNoReplicas(1).build());\n+        final String repoName = \"test-repo\";\n+        createRepository(repoName, \"mock\");\n+        final String snapshotName = \"test-snapshot\";\n+        createSnapshot(repoName, snapshotName, List.of(index));\n+        assertAcked(client().admin().indices().prepareDelete(index));\n+        final String restoredIndex = mountSnapshot(repoName, snapshotName, index, Settings.EMPTY);\n+        ensureGreen(restoredIndex);\n+        final String secondDataNode = internalCluster().startDataOnlyNode();\n+\n+        final ThreadPool threadPool = internalCluster().getInstance(ThreadPool.class, secondDataNode);\n+        final int preWarmThreads = threadPool.info(SearchableSnapshotsConstants.CACHE_PREWARMING_THREAD_POOL_NAME).getMax();\n+        final Executor executor = threadPool.executor(SearchableSnapshotsConstants.CACHE_PREWARMING_THREAD_POOL_NAME);\n+        final CyclicBarrier barrier = new CyclicBarrier(preWarmThreads + 1);\n+        final CountDownLatch latch = new CountDownLatch(1);\n+        for (int i = 0; i < preWarmThreads; i++) {\n+            executor.execute(() -> {\n+                try {\n+                    barrier.await();\n+                    latch.await();\n+                } catch (Exception e) {\n+                    throw new AssertionError(e);\n+                }\n+            });\n+        }\n+        logger.info(\"--> waiting for prewarm threads to all become blocked\");\n+        barrier.await();\n+\n+        logger.info(\"--> force index [{}] to relocate to [{}]\", index, secondDataNode);\n+        assertAcked(\n+            client().admin()\n+                .indices()\n+                .prepareUpdateSettings(restoredIndex)\n+                .setSettings(\n+                    Settings.builder()\n+                        .put(\n+                            IndexMetadata.INDEX_ROUTING_REQUIRE_GROUP_SETTING.getConcreteSettingForNamespace(\"_name\").getKey(),\n+                            secondDataNode\n+                        )\n+                )\n+        );\n+        assertBusy(() -> {\n+            final List<RecoveryState> recoveryStates = getActiveRestores(restoredIndex);\n+            assertThat(recoveryStates, Matchers.hasSize(1));\n+            final RecoveryState shardRecoveryState = recoveryStates.get(0);\n+            assertEquals(firstDataNode, shardRecoveryState.getSourceNode().getName());\n+            assertEquals(secondDataNode, shardRecoveryState.getTargetNode().getName());\n+        });\n+\n+        logger.info(\"--> sleep for 5s to ensure we are actually stuck at the FINALIZE stage and that the primary has not yet relocated\");\n+        TimeUnit.SECONDS.sleep(5L);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d44b1202f71c204e0e4775e6e463871a20a29f59"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE2Nzk2NQ==", "bodyText": "++ thanks, you actually prevented a likely test failure here as well :) I moved the check for translog stage to a busy assert and then added the check for one clean files condition after. Otherwise we'd only have had 5s to arrive at TRANSLOG now at least we have 10 which should be a little safer.", "url": "https://github.com/elastic/elasticsearch/pull/65531#discussion_r539167965", "createdAt": "2020-12-09T09:59:23Z", "author": {"login": "original-brownbear"}, "path": "x-pack/plugin/searchable-snapshots/src/internalClusterTest/java/org/elasticsearch/xpack/searchablesnapshots/SearchableSnapshotsRelocationIntegTests.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.searchablesnapshots;\n+\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.indices.recovery.RecoveryState;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.snapshots.mockstore.MockRepository;\n+import org.elasticsearch.test.ESIntegTestCase;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.hamcrest.Matchers;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.CyclicBarrier;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n+\n+@ESIntegTestCase.ClusterScope(scope = ESIntegTestCase.Scope.TEST, numDataNodes = 0)\n+public class SearchableSnapshotsRelocationIntegTests extends BaseSearchableSnapshotsIntegTestCase {\n+\n+    @Override\n+    protected Collection<Class<? extends Plugin>> nodePlugins() {\n+        return List.of(LocalStateSearchableSnapshots.class, MockRepository.Plugin.class);\n+    }\n+\n+    public void testRelocationWaitsForPreWarm() throws Exception {\n+        internalCluster().startMasterOnlyNode();\n+        final String firstDataNode = internalCluster().startDataOnlyNode();\n+        final String index = \"test-idx\";\n+        createIndexWithContent(index, indexSettingsNoReplicas(1).build());\n+        final String repoName = \"test-repo\";\n+        createRepository(repoName, \"mock\");\n+        final String snapshotName = \"test-snapshot\";\n+        createSnapshot(repoName, snapshotName, List.of(index));\n+        assertAcked(client().admin().indices().prepareDelete(index));\n+        final String restoredIndex = mountSnapshot(repoName, snapshotName, index, Settings.EMPTY);\n+        ensureGreen(restoredIndex);\n+        final String secondDataNode = internalCluster().startDataOnlyNode();\n+\n+        final ThreadPool threadPool = internalCluster().getInstance(ThreadPool.class, secondDataNode);\n+        final int preWarmThreads = threadPool.info(SearchableSnapshotsConstants.CACHE_PREWARMING_THREAD_POOL_NAME).getMax();\n+        final Executor executor = threadPool.executor(SearchableSnapshotsConstants.CACHE_PREWARMING_THREAD_POOL_NAME);\n+        final CyclicBarrier barrier = new CyclicBarrier(preWarmThreads + 1);\n+        final CountDownLatch latch = new CountDownLatch(1);\n+        for (int i = 0; i < preWarmThreads; i++) {\n+            executor.execute(() -> {\n+                try {\n+                    barrier.await();\n+                    latch.await();\n+                } catch (Exception e) {\n+                    throw new AssertionError(e);\n+                }\n+            });\n+        }\n+        logger.info(\"--> waiting for prewarm threads to all become blocked\");\n+        barrier.await();\n+\n+        logger.info(\"--> force index [{}] to relocate to [{}]\", index, secondDataNode);\n+        assertAcked(\n+            client().admin()\n+                .indices()\n+                .prepareUpdateSettings(restoredIndex)\n+                .setSettings(\n+                    Settings.builder()\n+                        .put(\n+                            IndexMetadata.INDEX_ROUTING_REQUIRE_GROUP_SETTING.getConcreteSettingForNamespace(\"_name\").getKey(),\n+                            secondDataNode\n+                        )\n+                )\n+        );\n+        assertBusy(() -> {\n+            final List<RecoveryState> recoveryStates = getActiveRestores(restoredIndex);\n+            assertThat(recoveryStates, Matchers.hasSize(1));\n+            final RecoveryState shardRecoveryState = recoveryStates.get(0);\n+            assertEquals(firstDataNode, shardRecoveryState.getSourceNode().getName());\n+            assertEquals(secondDataNode, shardRecoveryState.getTargetNode().getName());\n+        });\n+\n+        logger.info(\"--> sleep for 5s to ensure we are actually stuck at the FINALIZE stage and that the primary has not yet relocated\");\n+        TimeUnit.SECONDS.sleep(5L);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA2NzYyNQ=="}, "originalCommit": {"oid": "d44b1202f71c204e0e4775e6e463871a20a29f59"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NDU0MDk3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/index/store/cache/CachedBlobContainerIndexInputTests.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwNzozNTo0OVrOICGXCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwOTo1OToyOVrOICMNLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA3MjI2NA==", "bodyText": "Maybe only do this line randomly to avoid waiting for prewarming before doing all the reads below?", "url": "https://github.com/elastic/elasticsearch/pull/65531#discussion_r539072264", "createdAt": "2020-12-09T07:35:49Z", "author": {"login": "henningandersen"}, "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/index/store/cache/CachedBlobContainerIndexInputTests.java", "diffHunk": "@@ -114,7 +117,9 @@ public void testRandomReads() throws Exception {\n                     )\n                 ) {\n                     RecoveryState recoveryState = createRecoveryState();\n-                    final boolean loaded = directory.loadSnapshot(recoveryState);\n+                    final PlainActionFuture<Void> future = PlainActionFuture.newFuture();\n+                    final boolean loaded = directory.loadSnapshot(recoveryState, future);\n+                    future.get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d44b1202f71c204e0e4775e6e463871a20a29f59"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE2ODA0NQ==", "bodyText": "sure done :)", "url": "https://github.com/elastic/elasticsearch/pull/65531#discussion_r539168045", "createdAt": "2020-12-09T09:59:29Z", "author": {"login": "original-brownbear"}, "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/index/store/cache/CachedBlobContainerIndexInputTests.java", "diffHunk": "@@ -114,7 +117,9 @@ public void testRandomReads() throws Exception {\n                     )\n                 ) {\n                     RecoveryState recoveryState = createRecoveryState();\n-                    final boolean loaded = directory.loadSnapshot(recoveryState);\n+                    final PlainActionFuture<Void> future = PlainActionFuture.newFuture();\n+                    final boolean loaded = directory.loadSnapshot(recoveryState, future);\n+                    future.get();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA3MjI2NA=="}, "originalCommit": {"oid": "d44b1202f71c204e0e4775e6e463871a20a29f59"}, "originalPosition": 25}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1950, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}