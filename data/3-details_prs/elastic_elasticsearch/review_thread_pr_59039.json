{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ0MzkzNDg3", "number": 59039, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwODoxNzowN1rOELlftQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxMDo1MTo1NFrOELowkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwNTg0MTE3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/indices/recovery/RecoveryState.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwODoxNzowOFrOGtNUuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwODoxNzowOFrOGtNUuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA1NzQwMA==", "bodyText": "Think it'd be better to move this to a constructor RecoveryFilesDetails(StreamInput in), and similarly implement RecoveryFileDetails#writeTo instead of implementing the serialization here.", "url": "https://github.com/elastic/elasticsearch/pull/59039#discussion_r450057400", "createdAt": "2020-07-06T08:17:08Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/indices/recovery/RecoveryState.java", "diffHunk": "@@ -716,7 +749,7 @@ public Index(StreamInput in) throws IOException {\n             int size = in.readVInt();\n             for (int i = 0; i < size; i++) {\n                 File file = new File(in);\n-                fileDetails.put(file.name, file);\n+                fileDetails.addFileDetails(file.name, file);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "815be65516cef21bb44dfb7d1efd64479496bd0d"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwNTg0Mjk2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/indices/recovery/RecoveryState.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwODoxNzozNlrOGtNVww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwODoxNzozNlrOGtNVww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA1NzY2Nw==", "bodyText": "This feels like it should belong to RecoveryFilesDetails too?", "url": "https://github.com/elastic/elasticsearch/pull/59039#discussion_r450057667", "createdAt": "2020-07-06T08:17:36Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/indices/recovery/RecoveryState.java", "diffHunk": "@@ -698,9 +699,41 @@ public String toString() {\n         }\n     }\n \n-    public static class Index extends Timer implements ToXContentFragment, Writeable {\n-\n+    public static class RecoveryFilesDetails {\n         private final Map<String, File> fileDetails = new HashMap<>();\n+\n+        public File addFileDetails(String name, File file) {\n+            return fileDetails.put(name, file);\n+        }\n+\n+        public void addRecoveredBytesToFile(String name, long bytes) {\n+            File file = fileDetails.get(name);\n+            file.addRecoveredBytes(bytes);\n+        }\n+\n+        public File get(String name) {\n+            return fileDetails.get(name);\n+        }\n+\n+        public int size() {\n+            return fileDetails.size();\n+        }\n+\n+        public boolean isEmpty() {\n+            return fileDetails.isEmpty();\n+        }\n+\n+        public void clear() {\n+            fileDetails.clear();\n+        }\n+\n+        public Collection<File> values() {\n+            return fileDetails.values();\n+        }\n+    }\n+\n+    public static class Index extends Timer implements ToXContentFragment, Writeable {\n+        private final RecoveryFilesDetails fileDetails = new RecoveryFilesDetails();\n         private boolean fileDetailsComplete;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "815be65516cef21bb44dfb7d1efd64479496bd0d"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwNTg0ODc5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/indices/recovery/RecoveryState.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwODoxOToxM1rOGtNZTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwODoxOToxM1rOGtNZTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA1ODU3NQ==", "bodyText": "This assertion feels like it belongs in RecoveryFileDetails too, as does the one that asserts fileDetailsComplete == false.", "url": "https://github.com/elastic/elasticsearch/pull/59039#discussion_r450058575", "createdAt": "2020-07-06T08:19:13Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/indices/recovery/RecoveryState.java", "diffHunk": "@@ -761,7 +794,7 @@ public synchronized void reset() {\n         public synchronized void addFileDetail(String name, long length, boolean reused) {\n             assert fileDetailsComplete == false : \"addFileDetail for [\" + name + \"] when file details are already complete\";\n             File file = new File(name, length, reused);\n-            File existing = fileDetails.put(name, file);\n+            File existing = fileDetails.addFileDetails(name, file);\n             assert existing == null : \"file [\" + name + \"] is already reported\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "815be65516cef21bb44dfb7d1efd64479496bd0d"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwNTk1Nzc4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/indices/recovery/RecoveryState.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwODo0OTowNVrOGtObgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwODo0OTowNVrOGtObgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA3NTUyMg==", "bodyText": "Can we instantiate the File - and check that it does not previously existed - directly within this method?", "url": "https://github.com/elastic/elasticsearch/pull/59039#discussion_r450075522", "createdAt": "2020-07-06T08:49:05Z", "author": {"login": "tlrx"}, "path": "server/src/main/java/org/elasticsearch/indices/recovery/RecoveryState.java", "diffHunk": "@@ -698,9 +699,41 @@ public String toString() {\n         }\n     }\n \n-    public static class Index extends Timer implements ToXContentFragment, Writeable {\n-\n+    public static class RecoveryFilesDetails {\n         private final Map<String, File> fileDetails = new HashMap<>();\n+\n+        public File addFileDetails(String name, File file) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "815be65516cef21bb44dfb7d1efd64479496bd0d"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwNjM1OTMwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/indices/recovery/RecoveryState.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxMDo0NjowNlrOGtSR0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxMDo0NjowNlrOGtSR0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDEzODU3Nw==", "bodyText": "can we assert that file is not null and prints the name if it is?", "url": "https://github.com/elastic/elasticsearch/pull/59039#discussion_r450138577", "createdAt": "2020-07-06T10:46:06Z", "author": {"login": "tlrx"}, "path": "server/src/main/java/org/elasticsearch/indices/recovery/RecoveryState.java", "diffHunk": "@@ -698,50 +699,123 @@ public String toString() {\n         }\n     }\n \n-    public static class Index extends Timer implements ToXContentFragment, Writeable {\n-\n+    public static class RecoveryFilesDetails implements ToXContentFragment, Writeable {\n         private final Map<String, File> fileDetails = new HashMap<>();\n-        private boolean fileDetailsComplete;\n-\n-        public static final long UNKNOWN = -1L;\n+        private boolean complete;\n \n-        private long sourceThrottlingInNanos = UNKNOWN;\n-        private long targetThrottleTimeInNanos = UNKNOWN;\n-\n-        public Index() {\n+        RecoveryFilesDetails() {\n         }\n \n-        public Index(StreamInput in) throws IOException {\n-            super(in);\n+        RecoveryFilesDetails(StreamInput in) throws IOException {\n             int size = in.readVInt();\n             for (int i = 0; i < size; i++) {\n                 File file = new File(in);\n                 fileDetails.put(file.name, file);\n             }\n             if (in.getVersion().onOrAfter(StoreStats.RESERVED_BYTES_VERSION)) {\n-                fileDetailsComplete = in.readBoolean();\n+                complete = in.readBoolean();\n             } else {\n                 // This flag is used by disk-based allocation to decide whether the remaining bytes measurement is accurate or not; if not\n                 // then it falls back on an estimate. There's only a very short window in which the file details are present but incomplete\n                 // so this is a reasonable approximation, and the stats reported to the disk-based allocator don't hit this code path\n                 // anyway since they always use IndexShard#getRecoveryState which is never transported over the wire.\n-                fileDetailsComplete = fileDetails.isEmpty() == false;\n+                complete = fileDetails.isEmpty() == false;\n             }\n-            sourceThrottlingInNanos = in.readLong();\n-            targetThrottleTimeInNanos = in.readLong();\n         }\n \n         @Override\n-        public synchronized void writeTo(StreamOutput out) throws IOException {\n-            super.writeTo(out);\n-            final File[] files = fileDetails.values().toArray(new File[0]);\n+        public void writeTo(StreamOutput out) throws IOException {\n+            final File[] files = values().toArray(new File[0]);\n             out.writeVInt(files.length);\n             for (File file : files) {\n                 file.writeTo(out);\n             }\n             if (out.getVersion().onOrAfter(StoreStats.RESERVED_BYTES_VERSION)) {\n-                out.writeBoolean(fileDetailsComplete);\n+                out.writeBoolean(complete);\n             }\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+            if (params.paramAsBoolean(\"detailed\", false)) {\n+                builder.startArray(Fields.DETAILS);\n+                for (File file : values()) {\n+                    file.toXContent(builder, params);\n+                }\n+                builder.endArray();\n+            }\n+\n+            return builder;\n+        }\n+\n+        public void addFileDetails(String name, long length, boolean reused) {\n+            addFileDetails(name, new File(name, length, reused));\n+        }\n+\n+        public void addFileDetails(String name, File file) {\n+            assert complete == false : \"addFileDetail for [\" + name + \"] when file details are already complete\";\n+            File existing = fileDetails.put(name, file);\n+            assert existing == null : \"file [\" + name + \"] is already reported\";\n+        }\n+\n+        public void addRecoveredBytesToFile(String name, long bytes) {\n+            File file = fileDetails.get(name);\n+            file.addRecoveredBytes(bytes);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc92cdb4740ea17b003b166f6fb5657f9c06b037"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwNjM2NzI5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/indices/recovery/RecoveryState.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxMDo0OTowNlrOGtSW5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxMDo0OTowNlrOGtSW5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDEzOTg3OQ==", "bodyText": "We're not consistent in the codebase about this, but I'd prefer isComplete() as we have setComplete()", "url": "https://github.com/elastic/elasticsearch/pull/59039#discussion_r450139879", "createdAt": "2020-07-06T10:49:06Z", "author": {"login": "tlrx"}, "path": "server/src/main/java/org/elasticsearch/indices/recovery/RecoveryState.java", "diffHunk": "@@ -698,50 +699,123 @@ public String toString() {\n         }\n     }\n \n-    public static class Index extends Timer implements ToXContentFragment, Writeable {\n-\n+    public static class RecoveryFilesDetails implements ToXContentFragment, Writeable {\n         private final Map<String, File> fileDetails = new HashMap<>();\n-        private boolean fileDetailsComplete;\n-\n-        public static final long UNKNOWN = -1L;\n+        private boolean complete;\n \n-        private long sourceThrottlingInNanos = UNKNOWN;\n-        private long targetThrottleTimeInNanos = UNKNOWN;\n-\n-        public Index() {\n+        RecoveryFilesDetails() {\n         }\n \n-        public Index(StreamInput in) throws IOException {\n-            super(in);\n+        RecoveryFilesDetails(StreamInput in) throws IOException {\n             int size = in.readVInt();\n             for (int i = 0; i < size; i++) {\n                 File file = new File(in);\n                 fileDetails.put(file.name, file);\n             }\n             if (in.getVersion().onOrAfter(StoreStats.RESERVED_BYTES_VERSION)) {\n-                fileDetailsComplete = in.readBoolean();\n+                complete = in.readBoolean();\n             } else {\n                 // This flag is used by disk-based allocation to decide whether the remaining bytes measurement is accurate or not; if not\n                 // then it falls back on an estimate. There's only a very short window in which the file details are present but incomplete\n                 // so this is a reasonable approximation, and the stats reported to the disk-based allocator don't hit this code path\n                 // anyway since they always use IndexShard#getRecoveryState which is never transported over the wire.\n-                fileDetailsComplete = fileDetails.isEmpty() == false;\n+                complete = fileDetails.isEmpty() == false;\n             }\n-            sourceThrottlingInNanos = in.readLong();\n-            targetThrottleTimeInNanos = in.readLong();\n         }\n \n         @Override\n-        public synchronized void writeTo(StreamOutput out) throws IOException {\n-            super.writeTo(out);\n-            final File[] files = fileDetails.values().toArray(new File[0]);\n+        public void writeTo(StreamOutput out) throws IOException {\n+            final File[] files = values().toArray(new File[0]);\n             out.writeVInt(files.length);\n             for (File file : files) {\n                 file.writeTo(out);\n             }\n             if (out.getVersion().onOrAfter(StoreStats.RESERVED_BYTES_VERSION)) {\n-                out.writeBoolean(fileDetailsComplete);\n+                out.writeBoolean(complete);\n             }\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+            if (params.paramAsBoolean(\"detailed\", false)) {\n+                builder.startArray(Fields.DETAILS);\n+                for (File file : values()) {\n+                    file.toXContent(builder, params);\n+                }\n+                builder.endArray();\n+            }\n+\n+            return builder;\n+        }\n+\n+        public void addFileDetails(String name, long length, boolean reused) {\n+            addFileDetails(name, new File(name, length, reused));\n+        }\n+\n+        public void addFileDetails(String name, File file) {\n+            assert complete == false : \"addFileDetail for [\" + name + \"] when file details are already complete\";\n+            File existing = fileDetails.put(name, file);\n+            assert existing == null : \"file [\" + name + \"] is already reported\";\n+        }\n+\n+        public void addRecoveredBytesToFile(String name, long bytes) {\n+            File file = fileDetails.get(name);\n+            file.addRecoveredBytes(bytes);\n+        }\n+\n+        public File get(String name) {\n+            return fileDetails.get(name);\n+        }\n+\n+        public void setComplete() {\n+            complete = true;\n+        }\n+\n+        public int size() {\n+            return fileDetails.size();\n+        }\n+\n+        public boolean isEmpty() {\n+            return fileDetails.isEmpty();\n+        }\n+\n+        public void clear() {\n+            fileDetails.clear();\n+            complete = false;\n+        }\n+\n+        public Collection<File> values() {\n+            return fileDetails.values();\n+        }\n+\n+        public boolean complete() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc92cdb4740ea17b003b166f6fb5657f9c06b037"}, "originalPosition": 120}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwNjM3NTg0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/indices/recovery/RecoveryState.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxMDo1MTo1NFrOGtScLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxMDo1MTo1NFrOGtScLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE0MTIzMA==", "bodyText": "Can we merge the two addFileDetails() together?", "url": "https://github.com/elastic/elasticsearch/pull/59039#discussion_r450141230", "createdAt": "2020-07-06T10:51:54Z", "author": {"login": "tlrx"}, "path": "server/src/main/java/org/elasticsearch/indices/recovery/RecoveryState.java", "diffHunk": "@@ -698,50 +699,123 @@ public String toString() {\n         }\n     }\n \n-    public static class Index extends Timer implements ToXContentFragment, Writeable {\n-\n+    public static class RecoveryFilesDetails implements ToXContentFragment, Writeable {\n         private final Map<String, File> fileDetails = new HashMap<>();\n-        private boolean fileDetailsComplete;\n-\n-        public static final long UNKNOWN = -1L;\n+        private boolean complete;\n \n-        private long sourceThrottlingInNanos = UNKNOWN;\n-        private long targetThrottleTimeInNanos = UNKNOWN;\n-\n-        public Index() {\n+        RecoveryFilesDetails() {\n         }\n \n-        public Index(StreamInput in) throws IOException {\n-            super(in);\n+        RecoveryFilesDetails(StreamInput in) throws IOException {\n             int size = in.readVInt();\n             for (int i = 0; i < size; i++) {\n                 File file = new File(in);\n                 fileDetails.put(file.name, file);\n             }\n             if (in.getVersion().onOrAfter(StoreStats.RESERVED_BYTES_VERSION)) {\n-                fileDetailsComplete = in.readBoolean();\n+                complete = in.readBoolean();\n             } else {\n                 // This flag is used by disk-based allocation to decide whether the remaining bytes measurement is accurate or not; if not\n                 // then it falls back on an estimate. There's only a very short window in which the file details are present but incomplete\n                 // so this is a reasonable approximation, and the stats reported to the disk-based allocator don't hit this code path\n                 // anyway since they always use IndexShard#getRecoveryState which is never transported over the wire.\n-                fileDetailsComplete = fileDetails.isEmpty() == false;\n+                complete = fileDetails.isEmpty() == false;\n             }\n-            sourceThrottlingInNanos = in.readLong();\n-            targetThrottleTimeInNanos = in.readLong();\n         }\n \n         @Override\n-        public synchronized void writeTo(StreamOutput out) throws IOException {\n-            super.writeTo(out);\n-            final File[] files = fileDetails.values().toArray(new File[0]);\n+        public void writeTo(StreamOutput out) throws IOException {\n+            final File[] files = values().toArray(new File[0]);\n             out.writeVInt(files.length);\n             for (File file : files) {\n                 file.writeTo(out);\n             }\n             if (out.getVersion().onOrAfter(StoreStats.RESERVED_BYTES_VERSION)) {\n-                out.writeBoolean(fileDetailsComplete);\n+                out.writeBoolean(complete);\n             }\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+            if (params.paramAsBoolean(\"detailed\", false)) {\n+                builder.startArray(Fields.DETAILS);\n+                for (File file : values()) {\n+                    file.toXContent(builder, params);\n+                }\n+                builder.endArray();\n+            }\n+\n+            return builder;\n+        }\n+\n+        public void addFileDetails(String name, long length, boolean reused) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc92cdb4740ea17b003b166f6fb5657f9c06b037"}, "originalPosition": 80}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2046, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}