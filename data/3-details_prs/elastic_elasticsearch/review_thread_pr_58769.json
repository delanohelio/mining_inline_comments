{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQyMTk5NTQ3", "number": 58769, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxOTo0OTozNlrOEKQMJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxNTozOTowMVrOEKj_Yg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MTg2NDY4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/aggregations/AggregatorBase.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxOTo0OTozNlrOGrMBwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxNDoyMzo1N1rOGroJrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkzOTAxMA==", "bodyText": "Do you think now'd be a good time to change the name? I always thought something like pointReaderIfSafe or something is a little more clear about why you might get null back.\nAnd it isn't so much \"if early termination is applicable\" as \"if there are no filters and the underlying index is in the same order as the values produced by the config\"", "url": "https://github.com/elastic/elasticsearch/pull/58769#discussion_r447939010", "createdAt": "2020-06-30T19:49:36Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/AggregatorBase.java", "diffHunk": "@@ -105,6 +108,22 @@ public ScoreMode scoreMode() {\n         addRequestCircuitBreakerBytes(DEFAULT_WEIGHT);\n     }\n \n+    /**\n+     * Returns a converter for point values if early termination is applicable to\n+     * the context or <code>null</code> otherwise.\n+     *\n+     * @param config The config for the values source metric.\n+     */\n+    public Function<byte[], Number> getPointReaderOrNull(ValuesSourceConfig config) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4eedfa7a48ffd92c502bd7dd74fa5255685c1a7"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkzOTg4Nw==", "bodyText": "Could you make the method final?", "url": "https://github.com/elastic/elasticsearch/pull/58769#discussion_r447939887", "createdAt": "2020-06-30T19:51:24Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/AggregatorBase.java", "diffHunk": "@@ -105,6 +108,22 @@ public ScoreMode scoreMode() {\n         addRequestCircuitBreakerBytes(DEFAULT_WEIGHT);\n     }\n \n+    /**\n+     * Returns a converter for point values if early termination is applicable to\n+     * the context or <code>null</code> otherwise.\n+     *\n+     * @param config The config for the values source metric.\n+     */\n+    public Function<byte[], Number> getPointReaderOrNull(ValuesSourceConfig config) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkzOTAxMA=="}, "originalCommit": {"oid": "c4eedfa7a48ffd92c502bd7dd74fa5255685c1a7"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODM5OTc4OA==", "bodyText": "the underlying index is in the same order as the values produced by the config\n\nOut of curiosity, what in the current logic looks at index ordering?", "url": "https://github.com/elastic/elasticsearch/pull/58769#discussion_r448399788", "createdAt": "2020-07-01T14:23:57Z", "author": {"login": "not-napoleon"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/AggregatorBase.java", "diffHunk": "@@ -105,6 +108,22 @@ public ScoreMode scoreMode() {\n         addRequestCircuitBreakerBytes(DEFAULT_WEIGHT);\n     }\n \n+    /**\n+     * Returns a converter for point values if early termination is applicable to\n+     * the context or <code>null</code> otherwise.\n+     *\n+     * @param config The config for the values source metric.\n+     */\n+    public Function<byte[], Number> getPointReaderOrNull(ValuesSourceConfig config) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkzOTAxMA=="}, "originalCommit": {"oid": "c4eedfa7a48ffd92c502bd7dd74fa5255685c1a7"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MTg3Mzg4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/aggregations/support/ValuesSourceConfig.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxOTo1MjoyOFrOGrMHdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxOTo1MjoyOFrOGrMHdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk0MDQ3MA==", "bodyText": "It's probably worth some javadoc on this one too.", "url": "https://github.com/elastic/elasticsearch/pull/58769#discussion_r447940470", "createdAt": "2020-06-30T19:52:28Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/support/ValuesSourceConfig.java", "diffHunk": "@@ -371,4 +374,24 @@ public ValuesSource getValuesSource() {\n     public boolean hasGlobalOrdinals() {\n         return valuesSource.hasGlobalOrdinals();\n     }\n+\n+    @Nullable\n+    public Function<byte[], Number> getPointReaderOrNull() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4eedfa7a48ffd92c502bd7dd74fa5255685c1a7"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NTEwODgyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/aggregations/support/ValuesSourceType.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxNTozOTowMVrOGrrQNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxODowNToxMlrOGrwN9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ1MDYxMw==", "bodyText": "I'm not convinced this is the right place to add extensibility here.  The other option I'm considering, we could make parsePoint a method on MappedFieldType (or, maybe a method that returns a reference to parsePoint or null, depending on if it's implemented for that field).  That would let us get rid of the instance type checking, and provide a way for plugins that add fields which use CoreVSTs to add custom point readers.", "url": "https://github.com/elastic/elasticsearch/pull/58769#discussion_r448450613", "createdAt": "2020-07-01T15:39:01Z", "author": {"login": "not-napoleon"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/support/ValuesSourceType.java", "diffHunk": "@@ -85,6 +87,15 @@\n     ValuesSource replaceMissing(ValuesSource valuesSource, Object rawMissing, DocValueFormat docValueFormat,\n                                 LongSupplier nowSupplier);\n \n+    /**\n+     * Attempts to return a reader function for the indexed data of this field.  Some aggregations are able to use this as an optimization\n+     * instead of relying on doc values, when the index sort order matches that of the aggregation.\n+     *\n+     * @param fieldType The field type we want to get a reader for\n+     * @return null if we can't get a reader (e.g. because the field is the wrong type), otherwise a point reader function.\n+     */\n+    default Function<byte[], Number> getPointReader(MappedFieldType fieldType) { return null; }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37aa3694a0b0dddc2cdfa693ad0423286bb282a9"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODUzMTk1OA==", "bodyText": "I agree that it should be the MappedFieldType's responsibility. It is built by the FieldMapper which is ultimately the only thing that actually knows how the index was built.", "url": "https://github.com/elastic/elasticsearch/pull/58769#discussion_r448531958", "createdAt": "2020-07-01T18:05:12Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/support/ValuesSourceType.java", "diffHunk": "@@ -85,6 +87,15 @@\n     ValuesSource replaceMissing(ValuesSource valuesSource, Object rawMissing, DocValueFormat docValueFormat,\n                                 LongSupplier nowSupplier);\n \n+    /**\n+     * Attempts to return a reader function for the indexed data of this field.  Some aggregations are able to use this as an optimization\n+     * instead of relying on doc values, when the index sort order matches that of the aggregation.\n+     *\n+     * @param fieldType The field type we want to get a reader for\n+     * @return null if we can't get a reader (e.g. because the field is the wrong type), otherwise a point reader function.\n+     */\n+    default Function<byte[], Number> getPointReader(MappedFieldType fieldType) { return null; }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ1MDYxMw=="}, "originalCommit": {"oid": "37aa3694a0b0dddc2cdfa693ad0423286bb282a9"}, "originalPosition": 24}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2158, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}