{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA5NjAyMzE4", "number": 64113, "reviewThreads": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQwOTo0NTowMVrOFK0v1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNlQxNjoyMDoxN1rOFTKzrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ2ODk0MjkyOnYy", "diffSide": "RIGHT", "path": "server/src/internalClusterTest/java/org/elasticsearch/cluster/settings/ClusterSettingsIT.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQwOTo0NTowMVrOINrKbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQwOTo0NTowMVrOINrKbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIwOTU4MA==", "bodyText": "Nit: prefer Metadata.SETTING_READ_ONLY_SETTING.get(state.getMetadata().transientSettings()) over state.getMetadata().transientSettings().getAsBoolean(Metadata.SETTING_READ_ONLY_SETTING.getKey(), false), and similarly for the next line.", "url": "https://github.com/elastic/elasticsearch/pull/64113#discussion_r551209580", "createdAt": "2021-01-04T09:45:01Z", "author": {"login": "DaveCTurner"}, "path": "server/src/internalClusterTest/java/org/elasticsearch/cluster/settings/ClusterSettingsIT.java", "diffHunk": "@@ -287,7 +289,112 @@ public void testUpdateSettings() {\n         assertThat(clusterService().getClusterSettings().get(INITIAL_RECOVERIES), equalTo(42));\n     }\n \n-    public void testClusterUpdateSettingsWithBlocks() {\n+    public void testRemoveArchiveSettingsWithBlocks() throws Exception {\n+        // set cluster read only or read only allow delete\n+        if (randomBoolean()) {\n+            setClusterReadOnly(true);\n+        } else {\n+            setClusterReadOnlyAllowDelete(true);\n+        }\n+        ClusterState state = client().admin().cluster().prepareState().get().getState();\n+        assertTrue(state.getMetadata().transientSettings().getAsBoolean(Metadata.SETTING_READ_ONLY_SETTING.getKey(), false)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "266d31872e7a3bfd03e920c248c43273b33c45c7"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ2ODk0NTQyOnYy", "diffSide": "RIGHT", "path": "server/src/internalClusterTest/java/org/elasticsearch/cluster/settings/ClusterSettingsIT.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQwOTo0NTozN1rOINrL0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQwOTo0NTozN1rOINrL0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIwOTkzOQ==", "bodyText": "Nit: prefer expectThrows over this pattern.", "url": "https://github.com/elastic/elasticsearch/pull/64113#discussion_r551209939", "createdAt": "2021-01-04T09:45:37Z", "author": {"login": "DaveCTurner"}, "path": "server/src/internalClusterTest/java/org/elasticsearch/cluster/settings/ClusterSettingsIT.java", "diffHunk": "@@ -287,7 +289,112 @@ public void testUpdateSettings() {\n         assertThat(clusterService().getClusterSettings().get(INITIAL_RECOVERIES), equalTo(42));\n     }\n \n-    public void testClusterUpdateSettingsWithBlocks() {\n+    public void testRemoveArchiveSettingsWithBlocks() throws Exception {\n+        // set cluster read only or read only allow delete\n+        if (randomBoolean()) {\n+            setClusterReadOnly(true);\n+        } else {\n+            setClusterReadOnlyAllowDelete(true);\n+        }\n+        ClusterState state = client().admin().cluster().prepareState().get().getState();\n+        assertTrue(state.getMetadata().transientSettings().getAsBoolean(Metadata.SETTING_READ_ONLY_SETTING.getKey(), false)\n+            || state.getMetadata().transientSettings().getAsBoolean(Metadata.SETTING_READ_ONLY_ALLOW_DELETE_SETTING.getKey(), false));\n+\n+        // create archived setting\n+        final Metadata metadata = state.getMetadata();\n+        final Metadata brokenMeta = Metadata.builder(metadata).persistentSettings(Settings.builder()\n+            .put(metadata.persistentSettings()).put(\"this.is.unknown\", true).build()).build();\n+        logger.info(\"brokenMeta[{}]\", brokenMeta.persistentSettings());\n+        restartNodesOnBrokenClusterState(ClusterState.builder(state).metadata(brokenMeta));\n+        ensureGreen(); // wait for state recovery\n+        state = client().admin().cluster().prepareState().get().getState();\n+        assertTrue(state.getMetadata().persistentSettings().getAsBoolean(\"archived.this.is.unknown\", false));\n+\n+        // cannot remove read only block due to archived settings\n+        try {\n+            setClusterReadOnly(false);\n+            setClusterReadOnlyAllowDelete(false);\n+            fail(\"should be blocked by archived settings.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "266d31872e7a3bfd03e920c248c43273b33c45c7"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ2ODk1MzE5OnYy", "diffSide": "RIGHT", "path": "server/src/internalClusterTest/java/org/elasticsearch/cluster/settings/ClusterSettingsIT.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQwOTo0Nzo0OVrOINrQNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQwOTo0Nzo0OVrOINrQNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIxMTA2Mw==", "bodyText": "I think it'd be better to test both of these cases each time: suggest having two top-level test methods that call this method with an argument indicating which branch to take.\nWe should also test the case where both blocks are set.", "url": "https://github.com/elastic/elasticsearch/pull/64113#discussion_r551211063", "createdAt": "2021-01-04T09:47:49Z", "author": {"login": "DaveCTurner"}, "path": "server/src/internalClusterTest/java/org/elasticsearch/cluster/settings/ClusterSettingsIT.java", "diffHunk": "@@ -287,7 +289,112 @@ public void testUpdateSettings() {\n         assertThat(clusterService().getClusterSettings().get(INITIAL_RECOVERIES), equalTo(42));\n     }\n \n-    public void testClusterUpdateSettingsWithBlocks() {\n+    public void testRemoveArchiveSettingsWithBlocks() throws Exception {\n+        // set cluster read only or read only allow delete\n+        if (randomBoolean()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "266d31872e7a3bfd03e920c248c43273b33c45c7"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ2ODk2MzA2OnYy", "diffSide": "RIGHT", "path": "server/src/internalClusterTest/java/org/elasticsearch/cluster/settings/ClusterSettingsIT.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQwOTo1MDoyMlrOINrVqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQwOTo1MDoyMlrOINrVqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIxMjQ1OA==", "bodyText": "Would prefer to remove this as I don't think it'll help in future debugging (but I can be convinced otherwise)", "url": "https://github.com/elastic/elasticsearch/pull/64113#discussion_r551212458", "createdAt": "2021-01-04T09:50:22Z", "author": {"login": "DaveCTurner"}, "path": "server/src/internalClusterTest/java/org/elasticsearch/cluster/settings/ClusterSettingsIT.java", "diffHunk": "@@ -287,7 +289,112 @@ public void testUpdateSettings() {\n         assertThat(clusterService().getClusterSettings().get(INITIAL_RECOVERIES), equalTo(42));\n     }\n \n-    public void testClusterUpdateSettingsWithBlocks() {\n+    public void testRemoveArchiveSettingsWithBlocks() throws Exception {\n+        // set cluster read only or read only allow delete\n+        if (randomBoolean()) {\n+            setClusterReadOnly(true);\n+        } else {\n+            setClusterReadOnlyAllowDelete(true);\n+        }\n+        ClusterState state = client().admin().cluster().prepareState().get().getState();\n+        assertTrue(state.getMetadata().transientSettings().getAsBoolean(Metadata.SETTING_READ_ONLY_SETTING.getKey(), false)\n+            || state.getMetadata().transientSettings().getAsBoolean(Metadata.SETTING_READ_ONLY_ALLOW_DELETE_SETTING.getKey(), false));\n+\n+        // create archived setting\n+        final Metadata metadata = state.getMetadata();\n+        final Metadata brokenMeta = Metadata.builder(metadata).persistentSettings(Settings.builder()\n+            .put(metadata.persistentSettings()).put(\"this.is.unknown\", true).build()).build();\n+        logger.info(\"brokenMeta[{}]\", brokenMeta.persistentSettings());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "266d31872e7a3bfd03e920c248c43273b33c45c7"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ2ODk2NTM4OnYy", "diffSide": "RIGHT", "path": "server/src/internalClusterTest/java/org/elasticsearch/cluster/settings/ClusterSettingsIT.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQwOTo1MToxM1rOINrXGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQwOTo1MToxM1rOINrXGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIxMjgyNA==", "bodyText": "This change seems unnecessary, suggest reverting it?\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void testClusterUpdateSettingsWithBlocks() throws Exception {\n          \n          \n            \n                public void testClusterUpdateSettingsWithBlocks() {", "url": "https://github.com/elastic/elasticsearch/pull/64113#discussion_r551212824", "createdAt": "2021-01-04T09:51:13Z", "author": {"login": "DaveCTurner"}, "path": "server/src/internalClusterTest/java/org/elasticsearch/cluster/settings/ClusterSettingsIT.java", "diffHunk": "@@ -287,7 +289,112 @@ public void testUpdateSettings() {\n         assertThat(clusterService().getClusterSettings().get(INITIAL_RECOVERIES), equalTo(42));\n     }\n \n-    public void testClusterUpdateSettingsWithBlocks() {\n+    public void testRemoveArchiveSettingsWithBlocks() throws Exception {\n+        // set cluster read only or read only allow delete\n+        if (randomBoolean()) {\n+            setClusterReadOnly(true);\n+        } else {\n+            setClusterReadOnlyAllowDelete(true);\n+        }\n+        ClusterState state = client().admin().cluster().prepareState().get().getState();\n+        assertTrue(state.getMetadata().transientSettings().getAsBoolean(Metadata.SETTING_READ_ONLY_SETTING.getKey(), false)\n+            || state.getMetadata().transientSettings().getAsBoolean(Metadata.SETTING_READ_ONLY_ALLOW_DELETE_SETTING.getKey(), false));\n+\n+        // create archived setting\n+        final Metadata metadata = state.getMetadata();\n+        final Metadata brokenMeta = Metadata.builder(metadata).persistentSettings(Settings.builder()\n+            .put(metadata.persistentSettings()).put(\"this.is.unknown\", true).build()).build();\n+        logger.info(\"brokenMeta[{}]\", brokenMeta.persistentSettings());\n+        restartNodesOnBrokenClusterState(ClusterState.builder(state).metadata(brokenMeta));\n+        ensureGreen(); // wait for state recovery\n+        state = client().admin().cluster().prepareState().get().getState();\n+        assertTrue(state.getMetadata().persistentSettings().getAsBoolean(\"archived.this.is.unknown\", false));\n+\n+        // cannot remove read only block due to archived settings\n+        try {\n+            setClusterReadOnly(false);\n+            setClusterReadOnlyAllowDelete(false);\n+            fail(\"should be blocked by archived settings.\");\n+        } catch (IllegalArgumentException ex) {\n+            assertTrue(ex.getMessage().contains(\"unknown setting [archived.this.is.unknown]\"));\n+        }\n+\n+        // fail to clear archived settings with non-archived settings\n+        try {\n+            assertAcked(client().admin().cluster().prepareUpdateSettings()\n+                .setPersistentSettings(Settings.builder().putNull(\"cluster.routing.allocation.enable\"))\n+                .setTransientSettings(Settings.builder().putNull(\"archived.*\")).get());\n+            fail(\"should only can remove archived settings.\");\n+        } catch (ClusterBlockException ex) {\n+            assertTrue(ex.getMessage().contains(\"cluster read-only\"));\n+        }\n+\n+        // fail to clear archived settings due to cluster read only block\n+        try {\n+            assertAcked(client().admin().cluster().prepareUpdateSettings()\n+                .setPersistentSettings(Settings.builder().putNull(\"archived.*\")).get());\n+            fail(\"should fail due to cluster read only block.\");\n+        } catch (ClusterBlockException ex) {\n+            assertTrue(ex.getMessage().contains(\"cluster read-only\"));\n+        }\n+\n+        // fail to clear archived settings with adding cluster block\n+        try {\n+            assertAcked(client().admin().cluster().prepareUpdateSettings()\n+                .setPersistentSettings(Settings.builder()\n+                    .putNull(\"archived.*\")\n+                    .put(Metadata.SETTING_READ_ONLY_SETTING.getKey(), \"true\")).get());\n+            fail(\"should fail due to cluster read only block.\");\n+        } catch (ClusterBlockException ex) {\n+            assertTrue(ex.getMessage().contains(\"cluster read-only\"));\n+        }\n+\n+        // fail to set archived settings to non-null value even with clearing blocks together\n+        try {\n+            assertAcked(client().admin().cluster().prepareUpdateSettings()\n+                .setPersistentSettings(Settings.builder()\n+                    .put(\"archived.this.is.unknown\", \"false\")\n+                    .putNull(Metadata.SETTING_READ_ONLY_SETTING.getKey())\n+                    .putNull(Metadata.SETTING_READ_ONLY_ALLOW_DELETE_SETTING.getKey())).get());\n+            fail(\"should fail due to cluster read only block.\");\n+        } catch (ClusterBlockException ex) {\n+            assertTrue(ex.getMessage().contains(\"cluster read-only\"));\n+        }\n+\n+        // we can clear read-only block with archived settings together\n+        if (randomBoolean()) {\n+            assertAcked(client().admin().cluster().prepareUpdateSettings()\n+                .setPersistentSettings(Settings.builder()\n+                    .putNull(\"archived.*\")\n+                    .putNull(Metadata.SETTING_READ_ONLY_SETTING.getKey())\n+                    .putNull(Metadata.SETTING_READ_ONLY_ALLOW_DELETE_SETTING.getKey()))\n+                .setTransientSettings(Settings.builder()\n+                    .putNull(Metadata.SETTING_READ_ONLY_SETTING.getKey())\n+                    .putNull(Metadata.SETTING_READ_ONLY_ALLOW_DELETE_SETTING.getKey())).get());\n+        } else {\n+            assertAcked(client().admin().cluster().prepareUpdateSettings()\n+                .setPersistentSettings(Settings.builder()\n+                    .putNull(\"archived.*\")\n+                    .put(Metadata.SETTING_READ_ONLY_SETTING.getKey(), \"false\")\n+                    .put(Metadata.SETTING_READ_ONLY_ALLOW_DELETE_SETTING.getKey(), \"false\"))\n+                .setTransientSettings(Settings.builder()\n+                    .put(Metadata.SETTING_READ_ONLY_SETTING.getKey(), \"false\")\n+                    .put(Metadata.SETTING_READ_ONLY_ALLOW_DELETE_SETTING.getKey(), \"false\")).get());\n+        }\n+\n+        state = client().admin().cluster().prepareState().get().getState();\n+        assertFalse(state.getMetadata().transientSettings()\n+            .getAsBoolean(Metadata.SETTING_READ_ONLY_SETTING.getKey(), false));\n+        assertFalse(state.getMetadata().transientSettings()\n+            .getAsBoolean(Metadata.SETTING_READ_ONLY_ALLOW_DELETE_SETTING.getKey(), false));\n+        assertFalse(state.getMetadata().persistentSettings()\n+            .getAsBoolean(Metadata.SETTING_READ_ONLY_SETTING.getKey(), false));\n+        assertFalse(state.getMetadata().persistentSettings()\n+            .getAsBoolean(Metadata.SETTING_READ_ONLY_ALLOW_DELETE_SETTING.getKey(), false));\n+        assertNull(state.getMetadata().persistentSettings().get(\"archived.this.is.unknown\"));\n+    }\n+\n+    public void testClusterUpdateSettingsWithBlocks() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "266d31872e7a3bfd03e920c248c43273b33c45c7"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ2ODk4OTgyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/settings/TransportClusterUpdateSettingsAction.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQwOTo1ODowNVrOINrk-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQwOTo1ODowNVrOINrk-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIxNjM3OQ==", "bodyText": "You can do this outside the loop:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        boolean clearBlockSettings = false;\n          \n          \n            \n                        boolean clearBlockSettings \n          \n          \n            \n                                = clearedBlockAndArchivedSettings.containsKey(Metadata.SETTING_READ_ONLY_SETTING.getKey())\n          \n          \n            \n                                || clearedBlockAndArchivedSettings.containsKey(Metadata.SETTING_READ_ONLY_ALLOW_DELETE_SETTING.getKey());", "url": "https://github.com/elastic/elasticsearch/pull/64113#discussion_r551216379", "createdAt": "2021-01-04T09:58:05Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/settings/TransportClusterUpdateSettingsAction.java", "diffHunk": "@@ -62,22 +68,75 @@ public TransportClusterUpdateSettingsAction(TransportService transportService, C\n         this.clusterSettings = clusterSettings;\n     }\n \n+    /**\n+     skip check block if:\n+     * Only at least one of cluster.blocks.read_only or cluster.blocks.read_only_allow_delete is being cleared (set to null or false).\n+     * Or all of the following are true:\n+     * 1. At least one of cluster.blocks.read_only or cluster.blocks.read_only_allow_delete is being cleared (set to null or false).\n+     * 2. Neither cluster.blocks.read_only nor cluster.blocks.read_only_allow_delete is being set to true.\n+     * 3. The only other settings in this update are archived ones being set to null.\n+     */\n     @Override\n     protected ClusterBlockException checkBlock(ClusterUpdateSettingsRequest request, ClusterState state) {\n-        // allow for dedicated changes to the metadata blocks, so we don't block those to allow to \"re-enable\" it\n-        if (request.transientSettings().size() + request.persistentSettings().size() == 1) {\n-            // only one setting\n-            if (Metadata.SETTING_READ_ONLY_SETTING.exists(request.persistentSettings())\n-                || Metadata.SETTING_READ_ONLY_SETTING.exists(request.transientSettings())\n-                || Metadata.SETTING_READ_ONLY_ALLOW_DELETE_SETTING.exists(request.transientSettings())\n-                || Metadata.SETTING_READ_ONLY_ALLOW_DELETE_SETTING.exists(request.persistentSettings())) {\n-                // one of the settings above as the only setting in the request means - resetting the block!\n+        Map<String, String> clearedBlockAndArchivedSettings = new HashMap<>();\n+        if (checkClearedBlockAndArchivedSettings(request.transientSettings(), clearedBlockAndArchivedSettings)\n+            && checkClearedBlockAndArchivedSettings(request.persistentSettings(), clearedBlockAndArchivedSettings)) {\n+            boolean clearBlockSettings = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "266d31872e7a3bfd03e920c248c43273b33c45c7"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ2ODk5NDU2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/settings/TransportClusterUpdateSettingsAction.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQwOTo1OToxM1rOINrnkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQwOTo1OToxM1rOINrnkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIxNzA0Mg==", "bodyText": "IMO we don't need this, if you drop it then the only difference is the DEBUG log message (and I prefer the more informative log message without it).\nWith this, and my previous comment, we don't need the loop at all, and also don't need to track every setting name/value in the request, just to verify that at least one read-only setting is being adjusted.", "url": "https://github.com/elastic/elasticsearch/pull/64113#discussion_r551217042", "createdAt": "2021-01-04T09:59:13Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/settings/TransportClusterUpdateSettingsAction.java", "diffHunk": "@@ -62,22 +68,75 @@ public TransportClusterUpdateSettingsAction(TransportService transportService, C\n         this.clusterSettings = clusterSettings;\n     }\n \n+    /**\n+     skip check block if:\n+     * Only at least one of cluster.blocks.read_only or cluster.blocks.read_only_allow_delete is being cleared (set to null or false).\n+     * Or all of the following are true:\n+     * 1. At least one of cluster.blocks.read_only or cluster.blocks.read_only_allow_delete is being cleared (set to null or false).\n+     * 2. Neither cluster.blocks.read_only nor cluster.blocks.read_only_allow_delete is being set to true.\n+     * 3. The only other settings in this update are archived ones being set to null.\n+     */\n     @Override\n     protected ClusterBlockException checkBlock(ClusterUpdateSettingsRequest request, ClusterState state) {\n-        // allow for dedicated changes to the metadata blocks, so we don't block those to allow to \"re-enable\" it\n-        if (request.transientSettings().size() + request.persistentSettings().size() == 1) {\n-            // only one setting\n-            if (Metadata.SETTING_READ_ONLY_SETTING.exists(request.persistentSettings())\n-                || Metadata.SETTING_READ_ONLY_SETTING.exists(request.transientSettings())\n-                || Metadata.SETTING_READ_ONLY_ALLOW_DELETE_SETTING.exists(request.transientSettings())\n-                || Metadata.SETTING_READ_ONLY_ALLOW_DELETE_SETTING.exists(request.persistentSettings())) {\n-                // one of the settings above as the only setting in the request means - resetting the block!\n+        Map<String, String> clearedBlockAndArchivedSettings = new HashMap<>();\n+        if (checkClearedBlockAndArchivedSettings(request.transientSettings(), clearedBlockAndArchivedSettings)\n+            && checkClearedBlockAndArchivedSettings(request.persistentSettings(), clearedBlockAndArchivedSettings)) {\n+            boolean clearBlockSettings = false;\n+            boolean clearArchivedSettings = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "266d31872e7a3bfd03e920c248c43273b33c45c7"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU1NjQzMjU1OnYy", "diffSide": "RIGHT", "path": "server/src/internalClusterTest/java/org/elasticsearch/cluster/settings/ClusterSettingsIT.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNlQxNjoxODowOVrOIafBog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNlQxNjoxODowOVrOIafBog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDY0MjIxMA==", "bodyText": "I think here we should set these settings randomly, not just setting the one we care about to true.", "url": "https://github.com/elastic/elasticsearch/pull/64113#discussion_r564642210", "createdAt": "2021-01-26T16:18:09Z", "author": {"login": "DaveCTurner"}, "path": "server/src/internalClusterTest/java/org/elasticsearch/cluster/settings/ClusterSettingsIT.java", "diffHunk": "@@ -287,6 +289,145 @@ public void testUpdateSettings() {\n         assertThat(clusterService().getClusterSettings().get(INITIAL_RECOVERIES), equalTo(42));\n     }\n \n+    public void testRemoveArchiveSettingsWithBlocks() throws Exception {\n+        testRemoveArchiveSettingsWithBlocks(true, false);\n+        testRemoveArchiveSettingsWithBlocks(false, true);\n+        testRemoveArchiveSettingsWithBlocks(true, true);\n+    }\n+\n+    private void testRemoveArchiveSettingsWithBlocks(boolean readOnly, boolean readOnlyAllowDelete) throws Exception {\n+        Settings.Builder settingsBuilder = Settings.builder();\n+        if (readOnly) {\n+            settingsBuilder.put(Metadata.SETTING_READ_ONLY_SETTING.getKey(), \"true\");\n+        }\n+        if (readOnlyAllowDelete) {\n+            settingsBuilder.put(Metadata.SETTING_READ_ONLY_ALLOW_DELETE_SETTING.getKey(), \"true\");\n+        }\n+        assertAcked(client().admin().cluster().prepareUpdateSettings()\n+            .setPersistentSettings(settingsBuilder).setTransientSettings(settingsBuilder).get());\n+\n+        ClusterState state = client().admin().cluster().prepareState().get().getState();\n+        if (readOnly) {\n+            assertTrue(Metadata.SETTING_READ_ONLY_SETTING.get(state.getMetadata().transientSettings()));\n+        }\n+        if (readOnlyAllowDelete) {\n+            assertTrue(Metadata.SETTING_READ_ONLY_ALLOW_DELETE_SETTING.get(state.getMetadata().transientSettings()));\n+        }\n+\n+        // create archived setting\n+        final Metadata metadata = state.getMetadata();\n+        final Metadata brokenMeta = Metadata.builder(metadata).persistentSettings(Settings.builder()\n+            .put(metadata.persistentSettings()).put(\"this.is.unknown\", true).build()).build();\n+        restartNodesOnBrokenClusterState(ClusterState.builder(state).metadata(brokenMeta));\n+        ensureGreen(); // wait for state recovery\n+        state = client().admin().cluster().prepareState().get().getState();\n+        assertTrue(state.getMetadata().persistentSettings().getAsBoolean(\"archived.this.is.unknown\", false));\n+\n+        // cannot remove read only block due to archived settings\n+        final IllegalArgumentException e1 =\n+            expectThrows(\n+                IllegalArgumentException.class,\n+                () -> {\n+                    Settings.Builder builder = Settings.builder();\n+                    if (readOnly) {\n+                        builder.put(Metadata.SETTING_READ_ONLY_SETTING.getKey(), \"false\");\n+                    }\n+                    if (readOnlyAllowDelete) {\n+                        builder.put(Metadata.SETTING_READ_ONLY_ALLOW_DELETE_SETTING.getKey(), \"false\");\n+                    }\n+                    assertAcked(client().admin().cluster().prepareUpdateSettings()\n+                        .setPersistentSettings(builder).setTransientSettings(builder).get());\n+                });\n+        assertTrue(e1.getMessage().contains(\"unknown setting [archived.this.is.unknown]\"));\n+\n+        // fail to clear archived settings with non-archived settings\n+        final ClusterBlockException e2 =\n+            expectThrows(\n+                ClusterBlockException.class,\n+                () -> assertAcked(client().admin().cluster().prepareUpdateSettings()\n+                        .setPersistentSettings(Settings.builder().putNull(\"cluster.routing.allocation.enable\"))\n+                        .setTransientSettings(Settings.builder().putNull(\"archived.*\")).get()));\n+        if (readOnly) {\n+            assertTrue(e2.getMessage().contains(\"cluster read-only (api)\"));\n+        }\n+        if (readOnlyAllowDelete) {\n+            assertTrue(e2.getMessage().contains(\"cluster read-only / allow delete (api)\"));\n+        }\n+\n+        // fail to clear archived settings due to cluster read only block\n+        final ClusterBlockException e3 =\n+            expectThrows(\n+                ClusterBlockException.class,\n+                () -> assertAcked(client().admin().cluster().prepareUpdateSettings()\n+                    .setPersistentSettings(Settings.builder().putNull(\"archived.*\")).get()));\n+        if (readOnly) {\n+            assertTrue(e3.getMessage().contains(\"cluster read-only (api)\"));\n+        }\n+        if (readOnlyAllowDelete) {\n+            assertTrue(e3.getMessage().contains(\"cluster read-only / allow delete (api)\"));\n+        }\n+\n+        // fail to clear archived settings with adding cluster block\n+        final ClusterBlockException e4 =\n+            expectThrows(\n+                ClusterBlockException.class,\n+                () -> {\n+                    Settings.Builder builder = Settings.builder().putNull(\"archived.*\");\n+                    if (readOnly) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "431a6e589ca3ec29c0dd26d2b06824d142eab591"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU1NjQzMzgzOnYy", "diffSide": "RIGHT", "path": "server/src/internalClusterTest/java/org/elasticsearch/cluster/settings/ClusterSettingsIT.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNlQxNjoxODoyMlrOIafCXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNlQxNjoxODoyMlrOIafCXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDY0MjM5Nw==", "bodyText": "We can assert the persistent settings here too?", "url": "https://github.com/elastic/elasticsearch/pull/64113#discussion_r564642397", "createdAt": "2021-01-26T16:18:22Z", "author": {"login": "DaveCTurner"}, "path": "server/src/internalClusterTest/java/org/elasticsearch/cluster/settings/ClusterSettingsIT.java", "diffHunk": "@@ -287,6 +289,145 @@ public void testUpdateSettings() {\n         assertThat(clusterService().getClusterSettings().get(INITIAL_RECOVERIES), equalTo(42));\n     }\n \n+    public void testRemoveArchiveSettingsWithBlocks() throws Exception {\n+        testRemoveArchiveSettingsWithBlocks(true, false);\n+        testRemoveArchiveSettingsWithBlocks(false, true);\n+        testRemoveArchiveSettingsWithBlocks(true, true);\n+    }\n+\n+    private void testRemoveArchiveSettingsWithBlocks(boolean readOnly, boolean readOnlyAllowDelete) throws Exception {\n+        Settings.Builder settingsBuilder = Settings.builder();\n+        if (readOnly) {\n+            settingsBuilder.put(Metadata.SETTING_READ_ONLY_SETTING.getKey(), \"true\");\n+        }\n+        if (readOnlyAllowDelete) {\n+            settingsBuilder.put(Metadata.SETTING_READ_ONLY_ALLOW_DELETE_SETTING.getKey(), \"true\");\n+        }\n+        assertAcked(client().admin().cluster().prepareUpdateSettings()\n+            .setPersistentSettings(settingsBuilder).setTransientSettings(settingsBuilder).get());\n+\n+        ClusterState state = client().admin().cluster().prepareState().get().getState();\n+        if (readOnly) {\n+            assertTrue(Metadata.SETTING_READ_ONLY_SETTING.get(state.getMetadata().transientSettings()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "431a6e589ca3ec29c0dd26d2b06824d142eab591"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU1NjQzNDE1OnYy", "diffSide": "RIGHT", "path": "server/src/internalClusterTest/java/org/elasticsearch/cluster/settings/ClusterSettingsIT.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNlQxNjoxODoyNlrOIafCig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNlQxNjoxODoyNlrOIafCig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDY0MjQ0Mg==", "bodyText": "We can assert the persistent settings here too?", "url": "https://github.com/elastic/elasticsearch/pull/64113#discussion_r564642442", "createdAt": "2021-01-26T16:18:26Z", "author": {"login": "DaveCTurner"}, "path": "server/src/internalClusterTest/java/org/elasticsearch/cluster/settings/ClusterSettingsIT.java", "diffHunk": "@@ -287,6 +289,145 @@ public void testUpdateSettings() {\n         assertThat(clusterService().getClusterSettings().get(INITIAL_RECOVERIES), equalTo(42));\n     }\n \n+    public void testRemoveArchiveSettingsWithBlocks() throws Exception {\n+        testRemoveArchiveSettingsWithBlocks(true, false);\n+        testRemoveArchiveSettingsWithBlocks(false, true);\n+        testRemoveArchiveSettingsWithBlocks(true, true);\n+    }\n+\n+    private void testRemoveArchiveSettingsWithBlocks(boolean readOnly, boolean readOnlyAllowDelete) throws Exception {\n+        Settings.Builder settingsBuilder = Settings.builder();\n+        if (readOnly) {\n+            settingsBuilder.put(Metadata.SETTING_READ_ONLY_SETTING.getKey(), \"true\");\n+        }\n+        if (readOnlyAllowDelete) {\n+            settingsBuilder.put(Metadata.SETTING_READ_ONLY_ALLOW_DELETE_SETTING.getKey(), \"true\");\n+        }\n+        assertAcked(client().admin().cluster().prepareUpdateSettings()\n+            .setPersistentSettings(settingsBuilder).setTransientSettings(settingsBuilder).get());\n+\n+        ClusterState state = client().admin().cluster().prepareState().get().getState();\n+        if (readOnly) {\n+            assertTrue(Metadata.SETTING_READ_ONLY_SETTING.get(state.getMetadata().transientSettings()));\n+        }\n+        if (readOnlyAllowDelete) {\n+            assertTrue(Metadata.SETTING_READ_ONLY_ALLOW_DELETE_SETTING.get(state.getMetadata().transientSettings()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "431a6e589ca3ec29c0dd26d2b06824d142eab591"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU1NjQzNTQ5OnYy", "diffSide": "RIGHT", "path": "server/src/internalClusterTest/java/org/elasticsearch/cluster/settings/ClusterSettingsIT.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNlQxNjoxODo0MFrOIafDcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNlQxNjoxODo0MFrOIafDcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDY0MjY3Mw==", "bodyText": "We could also set this to null.", "url": "https://github.com/elastic/elasticsearch/pull/64113#discussion_r564642673", "createdAt": "2021-01-26T16:18:40Z", "author": {"login": "DaveCTurner"}, "path": "server/src/internalClusterTest/java/org/elasticsearch/cluster/settings/ClusterSettingsIT.java", "diffHunk": "@@ -287,6 +289,145 @@ public void testUpdateSettings() {\n         assertThat(clusterService().getClusterSettings().get(INITIAL_RECOVERIES), equalTo(42));\n     }\n \n+    public void testRemoveArchiveSettingsWithBlocks() throws Exception {\n+        testRemoveArchiveSettingsWithBlocks(true, false);\n+        testRemoveArchiveSettingsWithBlocks(false, true);\n+        testRemoveArchiveSettingsWithBlocks(true, true);\n+    }\n+\n+    private void testRemoveArchiveSettingsWithBlocks(boolean readOnly, boolean readOnlyAllowDelete) throws Exception {\n+        Settings.Builder settingsBuilder = Settings.builder();\n+        if (readOnly) {\n+            settingsBuilder.put(Metadata.SETTING_READ_ONLY_SETTING.getKey(), \"true\");\n+        }\n+        if (readOnlyAllowDelete) {\n+            settingsBuilder.put(Metadata.SETTING_READ_ONLY_ALLOW_DELETE_SETTING.getKey(), \"true\");\n+        }\n+        assertAcked(client().admin().cluster().prepareUpdateSettings()\n+            .setPersistentSettings(settingsBuilder).setTransientSettings(settingsBuilder).get());\n+\n+        ClusterState state = client().admin().cluster().prepareState().get().getState();\n+        if (readOnly) {\n+            assertTrue(Metadata.SETTING_READ_ONLY_SETTING.get(state.getMetadata().transientSettings()));\n+        }\n+        if (readOnlyAllowDelete) {\n+            assertTrue(Metadata.SETTING_READ_ONLY_ALLOW_DELETE_SETTING.get(state.getMetadata().transientSettings()));\n+        }\n+\n+        // create archived setting\n+        final Metadata metadata = state.getMetadata();\n+        final Metadata brokenMeta = Metadata.builder(metadata).persistentSettings(Settings.builder()\n+            .put(metadata.persistentSettings()).put(\"this.is.unknown\", true).build()).build();\n+        restartNodesOnBrokenClusterState(ClusterState.builder(state).metadata(brokenMeta));\n+        ensureGreen(); // wait for state recovery\n+        state = client().admin().cluster().prepareState().get().getState();\n+        assertTrue(state.getMetadata().persistentSettings().getAsBoolean(\"archived.this.is.unknown\", false));\n+\n+        // cannot remove read only block due to archived settings\n+        final IllegalArgumentException e1 =\n+            expectThrows(\n+                IllegalArgumentException.class,\n+                () -> {\n+                    Settings.Builder builder = Settings.builder();\n+                    if (readOnly) {\n+                        builder.put(Metadata.SETTING_READ_ONLY_SETTING.getKey(), \"false\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "431a6e589ca3ec29c0dd26d2b06824d142eab591"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU1NjQzNTY1OnYy", "diffSide": "RIGHT", "path": "server/src/internalClusterTest/java/org/elasticsearch/cluster/settings/ClusterSettingsIT.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNlQxNjoxODo0NFrOIafDmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNlQxNjoxODo0NFrOIafDmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDY0MjcxMw==", "bodyText": "We could also set this to null.", "url": "https://github.com/elastic/elasticsearch/pull/64113#discussion_r564642713", "createdAt": "2021-01-26T16:18:44Z", "author": {"login": "DaveCTurner"}, "path": "server/src/internalClusterTest/java/org/elasticsearch/cluster/settings/ClusterSettingsIT.java", "diffHunk": "@@ -287,6 +289,145 @@ public void testUpdateSettings() {\n         assertThat(clusterService().getClusterSettings().get(INITIAL_RECOVERIES), equalTo(42));\n     }\n \n+    public void testRemoveArchiveSettingsWithBlocks() throws Exception {\n+        testRemoveArchiveSettingsWithBlocks(true, false);\n+        testRemoveArchiveSettingsWithBlocks(false, true);\n+        testRemoveArchiveSettingsWithBlocks(true, true);\n+    }\n+\n+    private void testRemoveArchiveSettingsWithBlocks(boolean readOnly, boolean readOnlyAllowDelete) throws Exception {\n+        Settings.Builder settingsBuilder = Settings.builder();\n+        if (readOnly) {\n+            settingsBuilder.put(Metadata.SETTING_READ_ONLY_SETTING.getKey(), \"true\");\n+        }\n+        if (readOnlyAllowDelete) {\n+            settingsBuilder.put(Metadata.SETTING_READ_ONLY_ALLOW_DELETE_SETTING.getKey(), \"true\");\n+        }\n+        assertAcked(client().admin().cluster().prepareUpdateSettings()\n+            .setPersistentSettings(settingsBuilder).setTransientSettings(settingsBuilder).get());\n+\n+        ClusterState state = client().admin().cluster().prepareState().get().getState();\n+        if (readOnly) {\n+            assertTrue(Metadata.SETTING_READ_ONLY_SETTING.get(state.getMetadata().transientSettings()));\n+        }\n+        if (readOnlyAllowDelete) {\n+            assertTrue(Metadata.SETTING_READ_ONLY_ALLOW_DELETE_SETTING.get(state.getMetadata().transientSettings()));\n+        }\n+\n+        // create archived setting\n+        final Metadata metadata = state.getMetadata();\n+        final Metadata brokenMeta = Metadata.builder(metadata).persistentSettings(Settings.builder()\n+            .put(metadata.persistentSettings()).put(\"this.is.unknown\", true).build()).build();\n+        restartNodesOnBrokenClusterState(ClusterState.builder(state).metadata(brokenMeta));\n+        ensureGreen(); // wait for state recovery\n+        state = client().admin().cluster().prepareState().get().getState();\n+        assertTrue(state.getMetadata().persistentSettings().getAsBoolean(\"archived.this.is.unknown\", false));\n+\n+        // cannot remove read only block due to archived settings\n+        final IllegalArgumentException e1 =\n+            expectThrows(\n+                IllegalArgumentException.class,\n+                () -> {\n+                    Settings.Builder builder = Settings.builder();\n+                    if (readOnly) {\n+                        builder.put(Metadata.SETTING_READ_ONLY_SETTING.getKey(), \"false\");\n+                    }\n+                    if (readOnlyAllowDelete) {\n+                        builder.put(Metadata.SETTING_READ_ONLY_ALLOW_DELETE_SETTING.getKey(), \"false\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "431a6e589ca3ec29c0dd26d2b06824d142eab591"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU1NjQzNzc2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/settings/TransportClusterUpdateSettingsAction.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNlQxNjoxOTowOFrOIafE8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNlQxNjoxOTowOFrOIafE8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDY0MzA1OA==", "bodyText": "This could just be a Set<String>, we don't care about the values.", "url": "https://github.com/elastic/elasticsearch/pull/64113#discussion_r564643058", "createdAt": "2021-01-26T16:19:08Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/settings/TransportClusterUpdateSettingsAction.java", "diffHunk": "@@ -62,22 +68,59 @@ public TransportClusterUpdateSettingsAction(TransportService transportService, C\n         this.clusterSettings = clusterSettings;\n     }\n \n+    /**\n+     skip check block if:\n+     * Only at least one of cluster.blocks.read_only or cluster.blocks.read_only_allow_delete is being cleared (set to null or false).\n+     * Or all of the following are true:\n+     * 1. At least one of cluster.blocks.read_only or cluster.blocks.read_only_allow_delete is being cleared (set to null or false).\n+     * 2. Neither cluster.blocks.read_only nor cluster.blocks.read_only_allow_delete is being set to true.\n+     * 3. The only other settings in this update are archived ones being set to null.\n+     */\n     @Override\n     protected ClusterBlockException checkBlock(ClusterUpdateSettingsRequest request, ClusterState state) {\n-        // allow for dedicated changes to the metadata blocks, so we don't block those to allow to \"re-enable\" it\n-        if (request.transientSettings().size() + request.persistentSettings().size() == 1) {\n-            // only one setting\n-            if (Metadata.SETTING_READ_ONLY_SETTING.exists(request.persistentSettings())\n-                || Metadata.SETTING_READ_ONLY_SETTING.exists(request.transientSettings())\n-                || Metadata.SETTING_READ_ONLY_ALLOW_DELETE_SETTING.exists(request.transientSettings())\n-                || Metadata.SETTING_READ_ONLY_ALLOW_DELETE_SETTING.exists(request.persistentSettings())) {\n-                // one of the settings above as the only setting in the request means - resetting the block!\n+        Map<String, String> clearedBlockAndArchivedSettings = new HashMap<>();\n+        if (checkClearedBlockAndArchivedSettings(request.transientSettings(), clearedBlockAndArchivedSettings)\n+            && checkClearedBlockAndArchivedSettings(request.persistentSettings(), clearedBlockAndArchivedSettings)) {\n+            if (clearedBlockAndArchivedSettings.containsKey(Metadata.SETTING_READ_ONLY_SETTING.getKey())\n+                || clearedBlockAndArchivedSettings.containsKey(Metadata.SETTING_READ_ONLY_ALLOW_DELETE_SETTING.getKey())) {\n                 return null;\n             }\n         }\n+\n         return state.blocks().globalBlockedException(ClusterBlockLevel.METADATA_WRITE);\n     }\n \n+    /**\n+     * Check settings that only contains block and archived settings.\n+     * @param settings target settings to be checked.\n+     * @param clearedBlockAndArchivedSettings block settings that have been set to null or false,\n+     *                                        archived settings that have been set to null.\n+     * @return true if all settings are clear blocks or archived settings.\n+     */\n+    private boolean checkClearedBlockAndArchivedSettings(final Settings settings,\n+                                                         final Map<String, String> clearedBlockAndArchivedSettings) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "431a6e589ca3ec29c0dd26d2b06824d142eab591"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU1NjQ0MzMzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/settings/TransportClusterUpdateSettingsAction.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNlQxNjoyMDoxN1rOIafIbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNlQxNjoyMDoxN1rOIafIbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDY0Mzk1MQ==", "bodyText": "I don't think we should duplicate the parsing of boolean settings here. Suggest using Metadata.SETTING_READ_ONLY_ALLOW_DELETE_SETTING.get(settings) etc.", "url": "https://github.com/elastic/elasticsearch/pull/64113#discussion_r564643951", "createdAt": "2021-01-26T16:20:17Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/settings/TransportClusterUpdateSettingsAction.java", "diffHunk": "@@ -62,22 +68,59 @@ public TransportClusterUpdateSettingsAction(TransportService transportService, C\n         this.clusterSettings = clusterSettings;\n     }\n \n+    /**\n+     skip check block if:\n+     * Only at least one of cluster.blocks.read_only or cluster.blocks.read_only_allow_delete is being cleared (set to null or false).\n+     * Or all of the following are true:\n+     * 1. At least one of cluster.blocks.read_only or cluster.blocks.read_only_allow_delete is being cleared (set to null or false).\n+     * 2. Neither cluster.blocks.read_only nor cluster.blocks.read_only_allow_delete is being set to true.\n+     * 3. The only other settings in this update are archived ones being set to null.\n+     */\n     @Override\n     protected ClusterBlockException checkBlock(ClusterUpdateSettingsRequest request, ClusterState state) {\n-        // allow for dedicated changes to the metadata blocks, so we don't block those to allow to \"re-enable\" it\n-        if (request.transientSettings().size() + request.persistentSettings().size() == 1) {\n-            // only one setting\n-            if (Metadata.SETTING_READ_ONLY_SETTING.exists(request.persistentSettings())\n-                || Metadata.SETTING_READ_ONLY_SETTING.exists(request.transientSettings())\n-                || Metadata.SETTING_READ_ONLY_ALLOW_DELETE_SETTING.exists(request.transientSettings())\n-                || Metadata.SETTING_READ_ONLY_ALLOW_DELETE_SETTING.exists(request.persistentSettings())) {\n-                // one of the settings above as the only setting in the request means - resetting the block!\n+        Map<String, String> clearedBlockAndArchivedSettings = new HashMap<>();\n+        if (checkClearedBlockAndArchivedSettings(request.transientSettings(), clearedBlockAndArchivedSettings)\n+            && checkClearedBlockAndArchivedSettings(request.persistentSettings(), clearedBlockAndArchivedSettings)) {\n+            if (clearedBlockAndArchivedSettings.containsKey(Metadata.SETTING_READ_ONLY_SETTING.getKey())\n+                || clearedBlockAndArchivedSettings.containsKey(Metadata.SETTING_READ_ONLY_ALLOW_DELETE_SETTING.getKey())) {\n                 return null;\n             }\n         }\n+\n         return state.blocks().globalBlockedException(ClusterBlockLevel.METADATA_WRITE);\n     }\n \n+    /**\n+     * Check settings that only contains block and archived settings.\n+     * @param settings target settings to be checked.\n+     * @param clearedBlockAndArchivedSettings block settings that have been set to null or false,\n+     *                                        archived settings that have been set to null.\n+     * @return true if all settings are clear blocks or archived settings.\n+     */\n+    private boolean checkClearedBlockAndArchivedSettings(final Settings settings,\n+                                                         final Map<String, String> clearedBlockAndArchivedSettings) {\n+        for (String key : settings.keySet()) {\n+            String value = settings.get(key);\n+            if (Metadata.SETTING_READ_ONLY_SETTING.getKey().equals(key)\n+                || Metadata.SETTING_READ_ONLY_ALLOW_DELETE_SETTING.getKey().equals(key)) {\n+                if (\"true\".equals(value)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "431a6e589ca3ec29c0dd26d2b06824d142eab591"}, "originalPosition": 64}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4306, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}