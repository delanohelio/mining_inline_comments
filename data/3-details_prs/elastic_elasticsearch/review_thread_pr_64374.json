{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEyNDcwOTc1", "number": 64374, "reviewThreads": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwOTo1MjoxOFrOEzuFtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNzowMzowNVrOE23Ovg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNjY3OTU2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/query/QueryShardContext.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwOTo1MjoxOFrOHrH-uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwOTo1MjoxOFrOHrH-uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDk4MTU2Mw==", "bodyText": "nice tricks! ;)", "url": "https://github.com/elastic/elasticsearch/pull/64374#discussion_r514981563", "createdAt": "2020-10-30T09:52:18Z", "author": {"login": "javanna"}, "path": "server/src/main/java/org/elasticsearch/index/query/QueryShardContext.java", "diffHunk": "@@ -522,4 +592,28 @@ public SimilarityService getSimilarityService() {\n     public BitsetFilterCache getBitsetFilterCache() {\n         return bitsetFilterCache;\n     }\n+\n+    private static Map<String, MappedFieldType> parseRuntimeMappings(\n+        Map<String, Object> mappings,\n+        Supplier<Mapper.TypeParser.ParserContext> parserContextSupplier,\n+        IndexSettings indexSettings\n+    ) {\n+        Map<String, MappedFieldType> runtimeMappings = new HashMap<>();\n+        for (Map.Entry<String, Object> entry : mappings.entrySet()) {\n+            String field = entry.getKey();\n+            if (entry.getValue() instanceof Map == false) {\n+                throw new ElasticsearchParseException(\"runtime mappings must be a map type\");\n+            }\n+            @SuppressWarnings(\"unchecked\")\n+            Map<String, Object> node = (Map<String, Object>) entry.getValue();\n+            // Replace the type until we have native support for the runtime section \n+            Object oldRuntimeType = node.put(\"runtime_type\", node.remove(\"type\"));\n+            if (oldRuntimeType != null) {\n+                throw new ElasticsearchParseException(\"use [type] in [runtime_mappings] instead of [runtime_type]\");\n+            }\n+            runtimeMappings.put(field, buildFieldType(\"runtime\", field, node, parserContextSupplier.get(), indexSettings));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "706da74631d905f928fa92d4a633356307f49871"}, "originalPosition": 188}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNjY4Mjc4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/enrich/src/main/java/org/elasticsearch/xpack/enrich/action/EnrichShardMultiSearchAction.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwOTo1MzoxOFrOHrIAwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwOTo1MzoxOFrOHrIAwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDk4MjA4MQ==", "bodyText": "When I looked I think that this one gets a search source builder, so it seemed that runtime mappings can be specified, hence we should use them?", "url": "https://github.com/elastic/elasticsearch/pull/64374#discussion_r514982081", "createdAt": "2020-10-30T09:53:18Z", "author": {"login": "javanna"}, "path": "x-pack/plugin/enrich/src/main/java/org/elasticsearch/xpack/enrich/action/EnrichShardMultiSearchAction.java", "diffHunk": "@@ -233,7 +235,8 @@ protected MultiSearchResponse shardOperation(Request request, ShardId shardId) t\n                     shardId.id(),\n                     searcher,\n                     () -> { throw new UnsupportedOperationException(); },\n-                    null\n+                    null,\n+                    emptyMap()  // NOCOMMIT is it right not to use the runtime mappings?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "706da74631d905f928fa92d4a633356307f49871"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0NzM4MDI2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/query/QueryShardContext.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNDo1NTo1NlrOHuHIfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxOTo0ODoxMFrOHuT7Tg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODExMzQwNg==", "bodyText": "how are you planning to address this? Should the method in MapperService take the runtime mappings as argument or is that too intrusive of a change?", "url": "https://github.com/elastic/elasticsearch/pull/64374#discussion_r518113406", "createdAt": "2020-11-05T14:55:56Z", "author": {"login": "javanna"}, "path": "server/src/main/java/org/elasticsearch/index/query/QueryShardContext.java", "diffHunk": "@@ -243,7 +301,21 @@ public boolean hasMappings() {\n      * type then the fields will be returned with a type prefix.\n      */\n     public Set<String> simpleMatchToIndexNames(String pattern) {\n-        return mapperService.simpleMatchToFullName(pattern);\n+        // TODO remove the duplication with MapperService and FieldTypeLookup", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05d0c9c26a1e56134a29c3084109084290c4075f"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE1NTIwOA==", "bodyText": "I was hoping to not think about it today. Pushing the runtime mappings over might do. I'll have a look once I get all the tests happy.", "url": "https://github.com/elastic/elasticsearch/pull/64374#discussion_r518155208", "createdAt": "2020-11-05T15:48:08Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/index/query/QueryShardContext.java", "diffHunk": "@@ -243,7 +301,21 @@ public boolean hasMappings() {\n      * type then the fields will be returned with a type prefix.\n      */\n     public Set<String> simpleMatchToIndexNames(String pattern) {\n-        return mapperService.simpleMatchToFullName(pattern);\n+        // TODO remove the duplication with MapperService and FieldTypeLookup", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODExMzQwNg=="}, "originalCommit": {"oid": "05d0c9c26a1e56134a29c3084109084290c4075f"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODMyMzAyMg==", "bodyText": "After looking a little more I wonder if the duplication is that bad - its another check of isSimpleMatchPattern when there are runtime fields. Compared to iterating a HashMap it seems ok.", "url": "https://github.com/elastic/elasticsearch/pull/64374#discussion_r518323022", "createdAt": "2020-11-05T19:48:10Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/index/query/QueryShardContext.java", "diffHunk": "@@ -243,7 +301,21 @@ public boolean hasMappings() {\n      * type then the fields will be returned with a type prefix.\n      */\n     public Set<String> simpleMatchToIndexNames(String pattern) {\n-        return mapperService.simpleMatchToFullName(pattern);\n+        // TODO remove the duplication with MapperService and FieldTypeLookup", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODExMzQwNg=="}, "originalCommit": {"oid": "05d0c9c26a1e56134a29c3084109084290c4075f"}, "originalPosition": 136}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MDcwODIxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/runtime-fields/qa/core-with-search/build.gradle", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwOTozNDozMFrOHumnqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxMzoxNTozNVrOHutlqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODYyOTI5MQ==", "bodyText": "We may find that #63572 helps here", "url": "https://github.com/elastic/elasticsearch/pull/64374#discussion_r518629291", "createdAt": "2020-11-06T09:34:30Z", "author": {"login": "romseygeek"}, "path": "x-pack/plugin/runtime-fields/qa/core-with-search/build.gradle", "diffHunk": "@@ -0,0 +1,55 @@\n+apply plugin: 'elasticsearch.yaml-rest-test'\n+\n+dependencies {\n+  yamlRestTestImplementation xpackProject(\"plugin:runtime-fields:qa\")\n+}\n+\n+restResources {\n+  restApi {\n+    includeXpack 'async_search', 'graph', '*_point_in_time'\n+  }\n+  restTests {\n+    includeCore '*'\n+    includeXpack 'async_search', 'graph'\n+  }\n+}\n+\n+testClusters.yamlRestTest {\n+  testDistribution = 'DEFAULT'\n+  setting 'xpack.license.self_generated.type', 'trial'\n+}\n+\n+yamlRestTest {\n+  systemProperty 'tests.rest.suite',\n+    [\n+      'async_search',\n+//      'field_caps',    These two don't support runtime fields on the request. Should they?\n+//      'graph',\n+//      'msearch',       This one just doesn't have infrastructure to hack the runtime fields into place\n+      'search',\n+      'search.aggregation',\n+      'search.highlight',\n+      'search.inner_hits',\n+      'search_shards',\n+      'suggest',\n+    ].join(',')\n+  systemProperty 'tests.rest.blacklist',\n+    [\n+      /////// TO FIX ///////\n+      'search.highlight/40_keyword_ignore/Plain Highligher should skip highlighting ignored keyword values', // The plain highlighter is incompatible with runtime fields. Worth fixing?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf63463666ce7d1bf412991f833c3e0c3218f9b6"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODc0MzQ2Ng==", "bodyText": "Yeah. I've not been pushing on these particularly hard. I probably should be.", "url": "https://github.com/elastic/elasticsearch/pull/64374#discussion_r518743466", "createdAt": "2020-11-06T13:15:35Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/runtime-fields/qa/core-with-search/build.gradle", "diffHunk": "@@ -0,0 +1,55 @@\n+apply plugin: 'elasticsearch.yaml-rest-test'\n+\n+dependencies {\n+  yamlRestTestImplementation xpackProject(\"plugin:runtime-fields:qa\")\n+}\n+\n+restResources {\n+  restApi {\n+    includeXpack 'async_search', 'graph', '*_point_in_time'\n+  }\n+  restTests {\n+    includeCore '*'\n+    includeXpack 'async_search', 'graph'\n+  }\n+}\n+\n+testClusters.yamlRestTest {\n+  testDistribution = 'DEFAULT'\n+  setting 'xpack.license.self_generated.type', 'trial'\n+}\n+\n+yamlRestTest {\n+  systemProperty 'tests.rest.suite',\n+    [\n+      'async_search',\n+//      'field_caps',    These two don't support runtime fields on the request. Should they?\n+//      'graph',\n+//      'msearch',       This one just doesn't have infrastructure to hack the runtime fields into place\n+      'search',\n+      'search.aggregation',\n+      'search.highlight',\n+      'search.inner_hits',\n+      'search_shards',\n+      'suggest',\n+    ].join(',')\n+  systemProperty 'tests.rest.blacklist',\n+    [\n+      /////// TO FIX ///////\n+      'search.highlight/40_keyword_ignore/Plain Highligher should skip highlighting ignored keyword values', // The plain highlighter is incompatible with runtime fields. Worth fixing?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODYyOTI5MQ=="}, "originalCommit": {"oid": "cf63463666ce7d1bf412991f833c3e0c3218f9b6"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MDcxMjg4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/runtime-fields/qa/core-with-search/src/yamlRestTest/java/org/elasticsearch/xpack/runtimefields/test/search/CoreTestsWithSearchRuntimeFieldsIT.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwOTozNTo0OVrOHumqpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNDoxMjozN1rOHuvlwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODYzMDA1Mg==", "bodyText": "I guess at some point we're going to need to integrate runtime fields into dynamic mappings in core code?", "url": "https://github.com/elastic/elasticsearch/pull/64374#discussion_r518630052", "createdAt": "2020-11-06T09:35:49Z", "author": {"login": "romseygeek"}, "path": "x-pack/plugin/runtime-fields/qa/core-with-search/src/yamlRestTest/java/org/elasticsearch/xpack/runtimefields/test/search/CoreTestsWithSearchRuntimeFieldsIT.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.runtimefields.test.search;\n+\n+import com.carrotsearch.randomizedtesting.annotations.Name;\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+\n+import org.elasticsearch.action.index.IndexRequest;\n+import org.elasticsearch.common.regex.Regex;\n+import org.elasticsearch.common.xcontent.XContentHelper;\n+import org.elasticsearch.index.mapper.DateFieldMapper;\n+import org.elasticsearch.test.rest.yaml.ClientYamlTestCandidate;\n+import org.elasticsearch.test.rest.yaml.ESClientYamlSuiteTestCase;\n+import org.elasticsearch.test.rest.yaml.section.ApiCallSection;\n+import org.elasticsearch.test.rest.yaml.section.ExecutableSection;\n+import org.elasticsearch.xpack.runtimefields.test.CoreTestTranslater;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static java.util.Collections.unmodifiableMap;\n+\n+/**\n+ * Runs elasticsearch's core rest tests disabling all mappings and replacing them\n+ * with runtime fields defined on the search request that load from {@code _source}. Tests\n+ * that configure the field in a way that are not supported by runtime fields are skipped.\n+ */\n+public class CoreTestsWithSearchRuntimeFieldsIT extends ESClientYamlSuiteTestCase {\n+    public CoreTestsWithSearchRuntimeFieldsIT(@Name(\"yaml\") ClientYamlTestCandidate testCandidate) {\n+        super(testCandidate);\n+    }\n+\n+    @Override\n+    protected boolean randomizeContentType() { // NOCOMMIT remove me\n+        return false;\n+    }\n+\n+    @ParametersFactory\n+    public static Iterable<Object[]> parameters() throws Exception {\n+        return new SearchRequestRuntimeFieldTranslater().parameters();\n+    }\n+\n+    /**\n+     * Translating the tests is fairly difficult here because instead of ES\n+     * tracking the mappings we have to track them. We don't have to do it as\n+     * well as ES, just well enough that we can decorate the search requests\n+     * with types that make most tests \"just work\".\n+     */\n+    private static class SearchRequestRuntimeFieldTranslater extends CoreTestTranslater {\n+        @Override\n+        protected Map<String, Object> dynamicTemplateFor(String type) {\n+            return dynamicTemplateToDisableRuntimeCompatibleFields(type);\n+        }\n+\n+        @Override\n+        protected Suite suite(ClientYamlTestCandidate candidate) {\n+            return new Suite(candidate) {\n+                private Map<String, Map<String, Map<String, Object>>> runtimeMappingsAfterSetup;\n+                private Map<String, Set<String>> mappedFieldsAfterSetup;\n+                private Map<String, Map<String, Map<String, Object>>> runtimeMappings;\n+                private Map<String, Set<String>> mappedFields;\n+\n+                @Override\n+                public boolean modifySections(List<ExecutableSection> executables) {\n+                    if (runtimeMappingsAfterSetup == null) {\n+                        // We're modifying the setup section\n+                        runtimeMappings = new HashMap<>();\n+                        mappedFields = new HashMap<>();\n+                        if (false == super.modifySections(executables)) {\n+                            return false;\n+                        }\n+                        runtimeMappingsAfterSetup = unmodifiableMap(runtimeMappings);\n+                        runtimeMappings = null;\n+                        mappedFieldsAfterSetup = unmodifiableMap(mappedFields);\n+                        mappedFields = null;\n+                        return true;\n+                    }\n+                    runtimeMappings = new HashMap<>(runtimeMappingsAfterSetup);\n+                    mappedFields = new HashMap<>(mappedFieldsAfterSetup);\n+                    return super.modifySections(executables);\n+                }\n+\n+                @Override\n+                protected boolean modifyMappingProperties(String index, Map<String, Object> properties) {\n+                    Map<String, Object> untouchedMapping = new HashMap<>();\n+                    Map<String, Map<String, Object>> runtimeMapping = new HashMap<>();\n+                    if (false == runtimeifyMappingProperties(properties, untouchedMapping, runtimeMapping)) {\n+                        return false;\n+                    }\n+                    properties.clear();\n+                    properties.putAll(untouchedMapping);\n+                    mappedFields.put(index, untouchedMapping.keySet());\n+                    runtimeMappings.put(index, runtimeMapping);\n+                    return true;\n+                }\n+\n+                @Override\n+                protected boolean modifySearch(ApiCallSection search) {\n+                    if (search.getBodies().isEmpty()) {\n+                        search.addBody(new HashMap<>());\n+                    }\n+                    for (Map<String, Object> body : search.getBodies()) {\n+                        Map<?, ?> runtimeMapping = runtimeMappings(search.getParams().get(\"index\"));\n+                        if (runtimeMapping == null) {\n+                            return false;\n+                        }\n+                        body.put(\"runtime_mappings\", runtimeMapping);\n+                    }\n+                    return true;\n+                }\n+\n+                private Map<?, ?> runtimeMappings(String index) {\n+                    if (index == null) {\n+                        return mergeMappings(new String[] { \"*\" });\n+                    }\n+                    String[] patterns = Arrays.stream(index.split(\",\")).map(m -> m.equals(\"_all\") ? \"*\" : m).toArray(String[]::new);\n+                    if (patterns.length == 0 && Regex.isSimpleMatchPattern(patterns[0])) {\n+                        return runtimeMappings.get(patterns[0]);\n+                    }\n+                    return mergeMappings(patterns);\n+                }\n+\n+                private Map<?, ?> mergeMappings(String[] patterns) {\n+                    Map<String, Map<String, Object>> merged = new HashMap<>();\n+                    for (Map.Entry<String, Map<String, Map<String, Object>>> indexEntry : runtimeMappings.entrySet()) {\n+                        if (false == Regex.simpleMatch(patterns, indexEntry.getKey())) {\n+                            continue;\n+                        }\n+                        for (Map.Entry<String, Map<String, Object>> field : indexEntry.getValue().entrySet()) {\n+                            Map<String, Object> mergedConfig = merged.get(field.getKey());\n+                            if (mergedConfig == null) {\n+                                merged.put(field.getKey(), field.getValue());\n+                            } else if (false == mergedConfig.equals(field.getValue())) {\n+                                // The two indices have different runtime mappings for a field so we have to give up on running the test.\n+                                return null;\n+                            }\n+                        }\n+                    }\n+                    for (Map.Entry<String, Set<String>> indexEntry : mappedFields.entrySet()) {\n+                        if (false == Regex.simpleMatch(patterns, indexEntry.getKey())) {\n+                            continue;\n+                        }\n+                        for (String mappedField : indexEntry.getValue()) {\n+                            if (merged.containsKey(mappedField)) {\n+                                // We have a runtime mappings for a field *and* regular mapping. We can't make this test work so skip it.\n+                                return null;\n+                            }\n+                        }\n+                    }\n+                    return merged;\n+                }\n+\n+                @Override\n+                protected boolean handleIndex(IndexRequest index) {\n+                    /*\n+                     * Ok! Let's reverse engineer dynamic mapping. Sort of. We're\n+                     * really just looking to figure out which of the runtime fields\n+                     * is \"close enough\" to what dynamic mapping would do.\n+                     */\n+                    if (index.getPipeline() != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf63463666ce7d1bf412991f833c3e0c3218f9b6"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODc0NDk3OA==", "bodyText": "The \"mapped\" version of these tests gets to use dynamic mappings. The \"search request\" version has to use dynamic mappings to disable the fields so that we can \"prove\" that we're replacing them with search requests.\nI guess another option is for me to hack the search requests and issue a get mapping or field caps request before hand to try to construct the search request based on the disabled mappings that I made. I didn't have that option when I first wrote the code so I did the dynamic mapping stuff. Its kind of nasty so maybe I should replace it with that...... I'd be ok doing it now if you feel strongly about it but I'd also be ok leaving this for a while.", "url": "https://github.com/elastic/elasticsearch/pull/64374#discussion_r518744978", "createdAt": "2020-11-06T13:18:32Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/runtime-fields/qa/core-with-search/src/yamlRestTest/java/org/elasticsearch/xpack/runtimefields/test/search/CoreTestsWithSearchRuntimeFieldsIT.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.runtimefields.test.search;\n+\n+import com.carrotsearch.randomizedtesting.annotations.Name;\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+\n+import org.elasticsearch.action.index.IndexRequest;\n+import org.elasticsearch.common.regex.Regex;\n+import org.elasticsearch.common.xcontent.XContentHelper;\n+import org.elasticsearch.index.mapper.DateFieldMapper;\n+import org.elasticsearch.test.rest.yaml.ClientYamlTestCandidate;\n+import org.elasticsearch.test.rest.yaml.ESClientYamlSuiteTestCase;\n+import org.elasticsearch.test.rest.yaml.section.ApiCallSection;\n+import org.elasticsearch.test.rest.yaml.section.ExecutableSection;\n+import org.elasticsearch.xpack.runtimefields.test.CoreTestTranslater;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static java.util.Collections.unmodifiableMap;\n+\n+/**\n+ * Runs elasticsearch's core rest tests disabling all mappings and replacing them\n+ * with runtime fields defined on the search request that load from {@code _source}. Tests\n+ * that configure the field in a way that are not supported by runtime fields are skipped.\n+ */\n+public class CoreTestsWithSearchRuntimeFieldsIT extends ESClientYamlSuiteTestCase {\n+    public CoreTestsWithSearchRuntimeFieldsIT(@Name(\"yaml\") ClientYamlTestCandidate testCandidate) {\n+        super(testCandidate);\n+    }\n+\n+    @Override\n+    protected boolean randomizeContentType() { // NOCOMMIT remove me\n+        return false;\n+    }\n+\n+    @ParametersFactory\n+    public static Iterable<Object[]> parameters() throws Exception {\n+        return new SearchRequestRuntimeFieldTranslater().parameters();\n+    }\n+\n+    /**\n+     * Translating the tests is fairly difficult here because instead of ES\n+     * tracking the mappings we have to track them. We don't have to do it as\n+     * well as ES, just well enough that we can decorate the search requests\n+     * with types that make most tests \"just work\".\n+     */\n+    private static class SearchRequestRuntimeFieldTranslater extends CoreTestTranslater {\n+        @Override\n+        protected Map<String, Object> dynamicTemplateFor(String type) {\n+            return dynamicTemplateToDisableRuntimeCompatibleFields(type);\n+        }\n+\n+        @Override\n+        protected Suite suite(ClientYamlTestCandidate candidate) {\n+            return new Suite(candidate) {\n+                private Map<String, Map<String, Map<String, Object>>> runtimeMappingsAfterSetup;\n+                private Map<String, Set<String>> mappedFieldsAfterSetup;\n+                private Map<String, Map<String, Map<String, Object>>> runtimeMappings;\n+                private Map<String, Set<String>> mappedFields;\n+\n+                @Override\n+                public boolean modifySections(List<ExecutableSection> executables) {\n+                    if (runtimeMappingsAfterSetup == null) {\n+                        // We're modifying the setup section\n+                        runtimeMappings = new HashMap<>();\n+                        mappedFields = new HashMap<>();\n+                        if (false == super.modifySections(executables)) {\n+                            return false;\n+                        }\n+                        runtimeMappingsAfterSetup = unmodifiableMap(runtimeMappings);\n+                        runtimeMappings = null;\n+                        mappedFieldsAfterSetup = unmodifiableMap(mappedFields);\n+                        mappedFields = null;\n+                        return true;\n+                    }\n+                    runtimeMappings = new HashMap<>(runtimeMappingsAfterSetup);\n+                    mappedFields = new HashMap<>(mappedFieldsAfterSetup);\n+                    return super.modifySections(executables);\n+                }\n+\n+                @Override\n+                protected boolean modifyMappingProperties(String index, Map<String, Object> properties) {\n+                    Map<String, Object> untouchedMapping = new HashMap<>();\n+                    Map<String, Map<String, Object>> runtimeMapping = new HashMap<>();\n+                    if (false == runtimeifyMappingProperties(properties, untouchedMapping, runtimeMapping)) {\n+                        return false;\n+                    }\n+                    properties.clear();\n+                    properties.putAll(untouchedMapping);\n+                    mappedFields.put(index, untouchedMapping.keySet());\n+                    runtimeMappings.put(index, runtimeMapping);\n+                    return true;\n+                }\n+\n+                @Override\n+                protected boolean modifySearch(ApiCallSection search) {\n+                    if (search.getBodies().isEmpty()) {\n+                        search.addBody(new HashMap<>());\n+                    }\n+                    for (Map<String, Object> body : search.getBodies()) {\n+                        Map<?, ?> runtimeMapping = runtimeMappings(search.getParams().get(\"index\"));\n+                        if (runtimeMapping == null) {\n+                            return false;\n+                        }\n+                        body.put(\"runtime_mappings\", runtimeMapping);\n+                    }\n+                    return true;\n+                }\n+\n+                private Map<?, ?> runtimeMappings(String index) {\n+                    if (index == null) {\n+                        return mergeMappings(new String[] { \"*\" });\n+                    }\n+                    String[] patterns = Arrays.stream(index.split(\",\")).map(m -> m.equals(\"_all\") ? \"*\" : m).toArray(String[]::new);\n+                    if (patterns.length == 0 && Regex.isSimpleMatchPattern(patterns[0])) {\n+                        return runtimeMappings.get(patterns[0]);\n+                    }\n+                    return mergeMappings(patterns);\n+                }\n+\n+                private Map<?, ?> mergeMappings(String[] patterns) {\n+                    Map<String, Map<String, Object>> merged = new HashMap<>();\n+                    for (Map.Entry<String, Map<String, Map<String, Object>>> indexEntry : runtimeMappings.entrySet()) {\n+                        if (false == Regex.simpleMatch(patterns, indexEntry.getKey())) {\n+                            continue;\n+                        }\n+                        for (Map.Entry<String, Map<String, Object>> field : indexEntry.getValue().entrySet()) {\n+                            Map<String, Object> mergedConfig = merged.get(field.getKey());\n+                            if (mergedConfig == null) {\n+                                merged.put(field.getKey(), field.getValue());\n+                            } else if (false == mergedConfig.equals(field.getValue())) {\n+                                // The two indices have different runtime mappings for a field so we have to give up on running the test.\n+                                return null;\n+                            }\n+                        }\n+                    }\n+                    for (Map.Entry<String, Set<String>> indexEntry : mappedFields.entrySet()) {\n+                        if (false == Regex.simpleMatch(patterns, indexEntry.getKey())) {\n+                            continue;\n+                        }\n+                        for (String mappedField : indexEntry.getValue()) {\n+                            if (merged.containsKey(mappedField)) {\n+                                // We have a runtime mappings for a field *and* regular mapping. We can't make this test work so skip it.\n+                                return null;\n+                            }\n+                        }\n+                    }\n+                    return merged;\n+                }\n+\n+                @Override\n+                protected boolean handleIndex(IndexRequest index) {\n+                    /*\n+                     * Ok! Let's reverse engineer dynamic mapping. Sort of. We're\n+                     * really just looking to figure out which of the runtime fields\n+                     * is \"close enough\" to what dynamic mapping would do.\n+                     */\n+                    if (index.getPipeline() != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODYzMDA1Mg=="}, "originalCommit": {"oid": "cf63463666ce7d1bf412991f833c3e0c3218f9b6"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODc3MDkyMQ==", "bodyText": "I think I'm getting confused between dynamic mappings and dynamic templates anyway.  Let's leave it as it is, but maybe open a separate issue to consider reworking it so it doesn't get lost?", "url": "https://github.com/elastic/elasticsearch/pull/64374#discussion_r518770921", "createdAt": "2020-11-06T14:03:58Z", "author": {"login": "romseygeek"}, "path": "x-pack/plugin/runtime-fields/qa/core-with-search/src/yamlRestTest/java/org/elasticsearch/xpack/runtimefields/test/search/CoreTestsWithSearchRuntimeFieldsIT.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.runtimefields.test.search;\n+\n+import com.carrotsearch.randomizedtesting.annotations.Name;\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+\n+import org.elasticsearch.action.index.IndexRequest;\n+import org.elasticsearch.common.regex.Regex;\n+import org.elasticsearch.common.xcontent.XContentHelper;\n+import org.elasticsearch.index.mapper.DateFieldMapper;\n+import org.elasticsearch.test.rest.yaml.ClientYamlTestCandidate;\n+import org.elasticsearch.test.rest.yaml.ESClientYamlSuiteTestCase;\n+import org.elasticsearch.test.rest.yaml.section.ApiCallSection;\n+import org.elasticsearch.test.rest.yaml.section.ExecutableSection;\n+import org.elasticsearch.xpack.runtimefields.test.CoreTestTranslater;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static java.util.Collections.unmodifiableMap;\n+\n+/**\n+ * Runs elasticsearch's core rest tests disabling all mappings and replacing them\n+ * with runtime fields defined on the search request that load from {@code _source}. Tests\n+ * that configure the field in a way that are not supported by runtime fields are skipped.\n+ */\n+public class CoreTestsWithSearchRuntimeFieldsIT extends ESClientYamlSuiteTestCase {\n+    public CoreTestsWithSearchRuntimeFieldsIT(@Name(\"yaml\") ClientYamlTestCandidate testCandidate) {\n+        super(testCandidate);\n+    }\n+\n+    @Override\n+    protected boolean randomizeContentType() { // NOCOMMIT remove me\n+        return false;\n+    }\n+\n+    @ParametersFactory\n+    public static Iterable<Object[]> parameters() throws Exception {\n+        return new SearchRequestRuntimeFieldTranslater().parameters();\n+    }\n+\n+    /**\n+     * Translating the tests is fairly difficult here because instead of ES\n+     * tracking the mappings we have to track them. We don't have to do it as\n+     * well as ES, just well enough that we can decorate the search requests\n+     * with types that make most tests \"just work\".\n+     */\n+    private static class SearchRequestRuntimeFieldTranslater extends CoreTestTranslater {\n+        @Override\n+        protected Map<String, Object> dynamicTemplateFor(String type) {\n+            return dynamicTemplateToDisableRuntimeCompatibleFields(type);\n+        }\n+\n+        @Override\n+        protected Suite suite(ClientYamlTestCandidate candidate) {\n+            return new Suite(candidate) {\n+                private Map<String, Map<String, Map<String, Object>>> runtimeMappingsAfterSetup;\n+                private Map<String, Set<String>> mappedFieldsAfterSetup;\n+                private Map<String, Map<String, Map<String, Object>>> runtimeMappings;\n+                private Map<String, Set<String>> mappedFields;\n+\n+                @Override\n+                public boolean modifySections(List<ExecutableSection> executables) {\n+                    if (runtimeMappingsAfterSetup == null) {\n+                        // We're modifying the setup section\n+                        runtimeMappings = new HashMap<>();\n+                        mappedFields = new HashMap<>();\n+                        if (false == super.modifySections(executables)) {\n+                            return false;\n+                        }\n+                        runtimeMappingsAfterSetup = unmodifiableMap(runtimeMappings);\n+                        runtimeMappings = null;\n+                        mappedFieldsAfterSetup = unmodifiableMap(mappedFields);\n+                        mappedFields = null;\n+                        return true;\n+                    }\n+                    runtimeMappings = new HashMap<>(runtimeMappingsAfterSetup);\n+                    mappedFields = new HashMap<>(mappedFieldsAfterSetup);\n+                    return super.modifySections(executables);\n+                }\n+\n+                @Override\n+                protected boolean modifyMappingProperties(String index, Map<String, Object> properties) {\n+                    Map<String, Object> untouchedMapping = new HashMap<>();\n+                    Map<String, Map<String, Object>> runtimeMapping = new HashMap<>();\n+                    if (false == runtimeifyMappingProperties(properties, untouchedMapping, runtimeMapping)) {\n+                        return false;\n+                    }\n+                    properties.clear();\n+                    properties.putAll(untouchedMapping);\n+                    mappedFields.put(index, untouchedMapping.keySet());\n+                    runtimeMappings.put(index, runtimeMapping);\n+                    return true;\n+                }\n+\n+                @Override\n+                protected boolean modifySearch(ApiCallSection search) {\n+                    if (search.getBodies().isEmpty()) {\n+                        search.addBody(new HashMap<>());\n+                    }\n+                    for (Map<String, Object> body : search.getBodies()) {\n+                        Map<?, ?> runtimeMapping = runtimeMappings(search.getParams().get(\"index\"));\n+                        if (runtimeMapping == null) {\n+                            return false;\n+                        }\n+                        body.put(\"runtime_mappings\", runtimeMapping);\n+                    }\n+                    return true;\n+                }\n+\n+                private Map<?, ?> runtimeMappings(String index) {\n+                    if (index == null) {\n+                        return mergeMappings(new String[] { \"*\" });\n+                    }\n+                    String[] patterns = Arrays.stream(index.split(\",\")).map(m -> m.equals(\"_all\") ? \"*\" : m).toArray(String[]::new);\n+                    if (patterns.length == 0 && Regex.isSimpleMatchPattern(patterns[0])) {\n+                        return runtimeMappings.get(patterns[0]);\n+                    }\n+                    return mergeMappings(patterns);\n+                }\n+\n+                private Map<?, ?> mergeMappings(String[] patterns) {\n+                    Map<String, Map<String, Object>> merged = new HashMap<>();\n+                    for (Map.Entry<String, Map<String, Map<String, Object>>> indexEntry : runtimeMappings.entrySet()) {\n+                        if (false == Regex.simpleMatch(patterns, indexEntry.getKey())) {\n+                            continue;\n+                        }\n+                        for (Map.Entry<String, Map<String, Object>> field : indexEntry.getValue().entrySet()) {\n+                            Map<String, Object> mergedConfig = merged.get(field.getKey());\n+                            if (mergedConfig == null) {\n+                                merged.put(field.getKey(), field.getValue());\n+                            } else if (false == mergedConfig.equals(field.getValue())) {\n+                                // The two indices have different runtime mappings for a field so we have to give up on running the test.\n+                                return null;\n+                            }\n+                        }\n+                    }\n+                    for (Map.Entry<String, Set<String>> indexEntry : mappedFields.entrySet()) {\n+                        if (false == Regex.simpleMatch(patterns, indexEntry.getKey())) {\n+                            continue;\n+                        }\n+                        for (String mappedField : indexEntry.getValue()) {\n+                            if (merged.containsKey(mappedField)) {\n+                                // We have a runtime mappings for a field *and* regular mapping. We can't make this test work so skip it.\n+                                return null;\n+                            }\n+                        }\n+                    }\n+                    return merged;\n+                }\n+\n+                @Override\n+                protected boolean handleIndex(IndexRequest index) {\n+                    /*\n+                     * Ok! Let's reverse engineer dynamic mapping. Sort of. We're\n+                     * really just looking to figure out which of the runtime fields\n+                     * is \"close enough\" to what dynamic mapping would do.\n+                     */\n+                    if (index.getPipeline() != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODYzMDA1Mg=="}, "originalCommit": {"oid": "cf63463666ce7d1bf412991f833c3e0c3218f9b6"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODc3NjI1OA==", "bodyText": "#64716", "url": "https://github.com/elastic/elasticsearch/pull/64374#discussion_r518776258", "createdAt": "2020-11-06T14:12:37Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/runtime-fields/qa/core-with-search/src/yamlRestTest/java/org/elasticsearch/xpack/runtimefields/test/search/CoreTestsWithSearchRuntimeFieldsIT.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.runtimefields.test.search;\n+\n+import com.carrotsearch.randomizedtesting.annotations.Name;\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+\n+import org.elasticsearch.action.index.IndexRequest;\n+import org.elasticsearch.common.regex.Regex;\n+import org.elasticsearch.common.xcontent.XContentHelper;\n+import org.elasticsearch.index.mapper.DateFieldMapper;\n+import org.elasticsearch.test.rest.yaml.ClientYamlTestCandidate;\n+import org.elasticsearch.test.rest.yaml.ESClientYamlSuiteTestCase;\n+import org.elasticsearch.test.rest.yaml.section.ApiCallSection;\n+import org.elasticsearch.test.rest.yaml.section.ExecutableSection;\n+import org.elasticsearch.xpack.runtimefields.test.CoreTestTranslater;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static java.util.Collections.unmodifiableMap;\n+\n+/**\n+ * Runs elasticsearch's core rest tests disabling all mappings and replacing them\n+ * with runtime fields defined on the search request that load from {@code _source}. Tests\n+ * that configure the field in a way that are not supported by runtime fields are skipped.\n+ */\n+public class CoreTestsWithSearchRuntimeFieldsIT extends ESClientYamlSuiteTestCase {\n+    public CoreTestsWithSearchRuntimeFieldsIT(@Name(\"yaml\") ClientYamlTestCandidate testCandidate) {\n+        super(testCandidate);\n+    }\n+\n+    @Override\n+    protected boolean randomizeContentType() { // NOCOMMIT remove me\n+        return false;\n+    }\n+\n+    @ParametersFactory\n+    public static Iterable<Object[]> parameters() throws Exception {\n+        return new SearchRequestRuntimeFieldTranslater().parameters();\n+    }\n+\n+    /**\n+     * Translating the tests is fairly difficult here because instead of ES\n+     * tracking the mappings we have to track them. We don't have to do it as\n+     * well as ES, just well enough that we can decorate the search requests\n+     * with types that make most tests \"just work\".\n+     */\n+    private static class SearchRequestRuntimeFieldTranslater extends CoreTestTranslater {\n+        @Override\n+        protected Map<String, Object> dynamicTemplateFor(String type) {\n+            return dynamicTemplateToDisableRuntimeCompatibleFields(type);\n+        }\n+\n+        @Override\n+        protected Suite suite(ClientYamlTestCandidate candidate) {\n+            return new Suite(candidate) {\n+                private Map<String, Map<String, Map<String, Object>>> runtimeMappingsAfterSetup;\n+                private Map<String, Set<String>> mappedFieldsAfterSetup;\n+                private Map<String, Map<String, Map<String, Object>>> runtimeMappings;\n+                private Map<String, Set<String>> mappedFields;\n+\n+                @Override\n+                public boolean modifySections(List<ExecutableSection> executables) {\n+                    if (runtimeMappingsAfterSetup == null) {\n+                        // We're modifying the setup section\n+                        runtimeMappings = new HashMap<>();\n+                        mappedFields = new HashMap<>();\n+                        if (false == super.modifySections(executables)) {\n+                            return false;\n+                        }\n+                        runtimeMappingsAfterSetup = unmodifiableMap(runtimeMappings);\n+                        runtimeMappings = null;\n+                        mappedFieldsAfterSetup = unmodifiableMap(mappedFields);\n+                        mappedFields = null;\n+                        return true;\n+                    }\n+                    runtimeMappings = new HashMap<>(runtimeMappingsAfterSetup);\n+                    mappedFields = new HashMap<>(mappedFieldsAfterSetup);\n+                    return super.modifySections(executables);\n+                }\n+\n+                @Override\n+                protected boolean modifyMappingProperties(String index, Map<String, Object> properties) {\n+                    Map<String, Object> untouchedMapping = new HashMap<>();\n+                    Map<String, Map<String, Object>> runtimeMapping = new HashMap<>();\n+                    if (false == runtimeifyMappingProperties(properties, untouchedMapping, runtimeMapping)) {\n+                        return false;\n+                    }\n+                    properties.clear();\n+                    properties.putAll(untouchedMapping);\n+                    mappedFields.put(index, untouchedMapping.keySet());\n+                    runtimeMappings.put(index, runtimeMapping);\n+                    return true;\n+                }\n+\n+                @Override\n+                protected boolean modifySearch(ApiCallSection search) {\n+                    if (search.getBodies().isEmpty()) {\n+                        search.addBody(new HashMap<>());\n+                    }\n+                    for (Map<String, Object> body : search.getBodies()) {\n+                        Map<?, ?> runtimeMapping = runtimeMappings(search.getParams().get(\"index\"));\n+                        if (runtimeMapping == null) {\n+                            return false;\n+                        }\n+                        body.put(\"runtime_mappings\", runtimeMapping);\n+                    }\n+                    return true;\n+                }\n+\n+                private Map<?, ?> runtimeMappings(String index) {\n+                    if (index == null) {\n+                        return mergeMappings(new String[] { \"*\" });\n+                    }\n+                    String[] patterns = Arrays.stream(index.split(\",\")).map(m -> m.equals(\"_all\") ? \"*\" : m).toArray(String[]::new);\n+                    if (patterns.length == 0 && Regex.isSimpleMatchPattern(patterns[0])) {\n+                        return runtimeMappings.get(patterns[0]);\n+                    }\n+                    return mergeMappings(patterns);\n+                }\n+\n+                private Map<?, ?> mergeMappings(String[] patterns) {\n+                    Map<String, Map<String, Object>> merged = new HashMap<>();\n+                    for (Map.Entry<String, Map<String, Map<String, Object>>> indexEntry : runtimeMappings.entrySet()) {\n+                        if (false == Regex.simpleMatch(patterns, indexEntry.getKey())) {\n+                            continue;\n+                        }\n+                        for (Map.Entry<String, Map<String, Object>> field : indexEntry.getValue().entrySet()) {\n+                            Map<String, Object> mergedConfig = merged.get(field.getKey());\n+                            if (mergedConfig == null) {\n+                                merged.put(field.getKey(), field.getValue());\n+                            } else if (false == mergedConfig.equals(field.getValue())) {\n+                                // The two indices have different runtime mappings for a field so we have to give up on running the test.\n+                                return null;\n+                            }\n+                        }\n+                    }\n+                    for (Map.Entry<String, Set<String>> indexEntry : mappedFields.entrySet()) {\n+                        if (false == Regex.simpleMatch(patterns, indexEntry.getKey())) {\n+                            continue;\n+                        }\n+                        for (String mappedField : indexEntry.getValue()) {\n+                            if (merged.containsKey(mappedField)) {\n+                                // We have a runtime mappings for a field *and* regular mapping. We can't make this test work so skip it.\n+                                return null;\n+                            }\n+                        }\n+                    }\n+                    return merged;\n+                }\n+\n+                @Override\n+                protected boolean handleIndex(IndexRequest index) {\n+                    /*\n+                     * Ok! Let's reverse engineer dynamic mapping. Sort of. We're\n+                     * really just looking to figure out which of the runtime fields\n+                     * is \"close enough\" to what dynamic mapping would do.\n+                     */\n+                    if (index.getPipeline() != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODYzMDA1Mg=="}, "originalCommit": {"oid": "cf63463666ce7d1bf412991f833c3e0c3218f9b6"}, "originalPosition": 167}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MDcxNzcxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/src/test/resources/rest-api-spec/test/runtime_fields/10_keyword.yml", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwOTozNzowNlrOHumtgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwOTozNzowNlrOHumtgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODYzMDc4NQ==", "bodyText": "This is just awesome.  So well done.", "url": "https://github.com/elastic/elasticsearch/pull/64374#discussion_r518630785", "createdAt": "2020-11-06T09:37:06Z", "author": {"login": "romseygeek"}, "path": "x-pack/plugin/src/test/resources/rest-api-spec/test/runtime_fields/10_keyword.yml", "diffHunk": "@@ -360,3 +360,79 @@ setup:\n   - match: { aggregations.to-users.users.hits.hits.2._index: test }\n   - match: { aggregations.to-users.users.hits.hits.2._nested.field: users }\n   - match: { aggregations.to-users.users.hits.hits.2._nested.offset: 1 }\n+\n+---\n+\"fetch defined on search request\":\n+  - do:\n+      search:\n+        index: sensor\n+        body:\n+          runtime_mappings:\n+            voltage_rating:\n+              type: keyword\n+              script: |\n+                double v = doc['voltage'].value;\n+                if (v < 4.8) {\n+                  emit('low');\n+                } else if (v > 5.2) {\n+                  emit('high');\n+                } else {\n+                  emit('ok');\n+                }\n+          fields: [voltage_rating]\n+          sort: timestamp\n+  - match: {hits.total.value: 6}\n+  - match: {hits.hits.0._source.voltage: 4.0}\n+  - match: {hits.hits.0.fields.voltage_rating: [low]}\n+\n+\n+---\n+\"match defined on search request\":\n+  - do:\n+      search:\n+        index: sensor\n+        body:\n+          runtime_mappings:\n+            voltage.rating:\n+              type: keyword\n+              script: |\n+                double v = doc['voltage'].value;\n+                if (v < 4.8) {\n+                  emit('low');\n+                } else if (v > 5.2) {\n+                  emit('high');\n+                } else {\n+                  emit('ok');\n+                }\n+          query:\n+            match:\n+              voltage.rating: ok\n+          sort: timestamp\n+  - match: {hits.total.value: 2}\n+  - match: {hits.hits.0._source.voltage: 5.1}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf63463666ce7d1bf412991f833c3e0c3218f9b6"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1ODA3Mzg3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/query/QueryShardContext.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxMTowOTowOVrOHvpp1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNjo0NDoyMVrOHv3ksA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTcyNzU3NA==", "bodyText": "Not extremely sure, but is it worth removing this constructor?", "url": "https://github.com/elastic/elasticsearch/pull/64374#discussion_r519727574", "createdAt": "2020-11-09T11:09:09Z", "author": {"login": "javanna"}, "path": "server/src/main/java/org/elasticsearch/index/query/QueryShardContext.java", "diffHunk": "@@ -122,16 +131,63 @@ public QueryShardContext(int shardId,\n                              BooleanSupplier allowExpensiveQueries,\n                              ValuesSourceRegistry valuesSourceRegistry) {\n         this(shardId, indexSettings, bigArrays, bitsetFilterCache, indexFieldDataLookup, mapperService, similarityService,\n-                scriptService, xContentRegistry, namedWriteableRegistry, client, searcher, nowInMillis, indexNameMatcher,\n-                new Index(RemoteClusterAware.buildRemoteIndexName(clusterAlias, indexSettings.getIndex().getName()),\n-                        indexSettings.getIndex().getUUID()), allowExpensiveQueries, valuesSourceRegistry);\n+                scriptService, xContentRegistry, namedWriteableRegistry, client, searcher, nowInMillis, clusterAlias,\n+                indexNameMatcher, allowExpensiveQueries, valuesSourceRegistry, emptyMap());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "139ef5f0542361ff15af2dfd20d11a53c6c23c67"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTg2MTY0Mg==", "bodyText": "It looks like I'd have to touch 15 files or something to do it. Would you be ok if I did it in a follow up change to keep this one ever so slightly smaller?", "url": "https://github.com/elastic/elasticsearch/pull/64374#discussion_r519861642", "createdAt": "2020-11-09T14:39:06Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/index/query/QueryShardContext.java", "diffHunk": "@@ -122,16 +131,63 @@ public QueryShardContext(int shardId,\n                              BooleanSupplier allowExpensiveQueries,\n                              ValuesSourceRegistry valuesSourceRegistry) {\n         this(shardId, indexSettings, bigArrays, bitsetFilterCache, indexFieldDataLookup, mapperService, similarityService,\n-                scriptService, xContentRegistry, namedWriteableRegistry, client, searcher, nowInMillis, indexNameMatcher,\n-                new Index(RemoteClusterAware.buildRemoteIndexName(clusterAlias, indexSettings.getIndex().getName()),\n-                        indexSettings.getIndex().getUUID()), allowExpensiveQueries, valuesSourceRegistry);\n+                scriptService, xContentRegistry, namedWriteableRegistry, client, searcher, nowInMillis, clusterAlias,\n+                indexNameMatcher, allowExpensiveQueries, valuesSourceRegistry, emptyMap());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTcyNzU3NA=="}, "originalCommit": {"oid": "139ef5f0542361ff15af2dfd20d11a53c6c23c67"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk1NTYzMg==", "bodyText": "fine", "url": "https://github.com/elastic/elasticsearch/pull/64374#discussion_r519955632", "createdAt": "2020-11-09T16:44:21Z", "author": {"login": "javanna"}, "path": "server/src/main/java/org/elasticsearch/index/query/QueryShardContext.java", "diffHunk": "@@ -122,16 +131,63 @@ public QueryShardContext(int shardId,\n                              BooleanSupplier allowExpensiveQueries,\n                              ValuesSourceRegistry valuesSourceRegistry) {\n         this(shardId, indexSettings, bigArrays, bitsetFilterCache, indexFieldDataLookup, mapperService, similarityService,\n-                scriptService, xContentRegistry, namedWriteableRegistry, client, searcher, nowInMillis, indexNameMatcher,\n-                new Index(RemoteClusterAware.buildRemoteIndexName(clusterAlias, indexSettings.getIndex().getName()),\n-                        indexSettings.getIndex().getUUID()), allowExpensiveQueries, valuesSourceRegistry);\n+                scriptService, xContentRegistry, namedWriteableRegistry, client, searcher, nowInMillis, clusterAlias,\n+                indexNameMatcher, allowExpensiveQueries, valuesSourceRegistry, emptyMap());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTcyNzU3NA=="}, "originalCommit": {"oid": "139ef5f0542361ff15af2dfd20d11a53c6c23c67"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1ODEyOTM1OnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/elasticsearch/index/mapper/DateFieldTypeTests.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxMToyNDowNVrOHvqK8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNDo0MToyMVrOHvx8Cw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTczNjA1MA==", "bodyText": "why do we need to mock mapper service now in some tests compared to before?", "url": "https://github.com/elastic/elasticsearch/pull/64374#discussion_r519736050", "createdAt": "2020-11-09T11:24:05Z", "author": {"login": "javanna"}, "path": "server/src/test/java/org/elasticsearch/index/mapper/DateFieldTypeTests.java", "diffHunk": "@@ -231,7 +233,7 @@ public void testRangeQueryWithIndexSort() {\n         IndexSettings indexSettings = new IndexSettings(indexMetadata, settings);\n \n         QueryShardContext context = new QueryShardContext(0, indexSettings,\n-            BigArrays.NON_RECYCLING_INSTANCE, null, null, null, null, null, xContentRegistry(), writableRegistry(),\n+            BigArrays.NON_RECYCLING_INSTANCE, null, null, mock(MapperService.class), null, null, xContentRegistry(), writableRegistry(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "139ef5f0542361ff15af2dfd20d11a53c6c23c67"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTg2MzMwNw==", "bodyText": "Because we're doing a method reference to it. Let me check if I can stomp that.", "url": "https://github.com/elastic/elasticsearch/pull/64374#discussion_r519863307", "createdAt": "2020-11-09T14:41:21Z", "author": {"login": "nik9000"}, "path": "server/src/test/java/org/elasticsearch/index/mapper/DateFieldTypeTests.java", "diffHunk": "@@ -231,7 +233,7 @@ public void testRangeQueryWithIndexSort() {\n         IndexSettings indexSettings = new IndexSettings(indexMetadata, settings);\n \n         QueryShardContext context = new QueryShardContext(0, indexSettings,\n-            BigArrays.NON_RECYCLING_INSTANCE, null, null, null, null, null, xContentRegistry(), writableRegistry(),\n+            BigArrays.NON_RECYCLING_INSTANCE, null, null, mock(MapperService.class), null, null, xContentRegistry(), writableRegistry(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTczNjA1MA=="}, "originalCommit": {"oid": "139ef5f0542361ff15af2dfd20d11a53c6c23c67"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1ODE1MjUzOnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/elasticsearch/search/AbstractSearchTestCase.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxMTozMDoyN1rOHvqY5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNToyNjowOFrOHv0Aqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTczOTYyMQ==", "bodyText": "you meant randomRuntimeMappings ?", "url": "https://github.com/elastic/elasticsearch/pull/64374#discussion_r519739621", "createdAt": "2020-11-09T11:30:27Z", "author": {"login": "javanna"}, "path": "server/src/test/java/org/elasticsearch/search/AbstractSearchTestCase.java", "diffHunk": "@@ -91,7 +91,22 @@ protected SearchSourceBuilder createSearchSourceBuilder() {\n                 SuggestBuilderTests::randomSuggestBuilder,\n                 QueryRescorerBuilderTests::randomRescoreBuilder,\n                 randomExtBuilders,\n-                CollapseBuilderTests::randomCollapseBuilder);\n+                CollapseBuilderTests::randomCollapseBuilder,\n+                AbstractSearchTestCase::randomRandomMappings);\n+    }\n+\n+    public static Map<String, Object> randomRandomMappings() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "139ef5f0542361ff15af2dfd20d11a53c6c23c67"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTg5NzI1OQ==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/elastic/elasticsearch/pull/64374#discussion_r519897259", "createdAt": "2020-11-09T15:26:08Z", "author": {"login": "nik9000"}, "path": "server/src/test/java/org/elasticsearch/search/AbstractSearchTestCase.java", "diffHunk": "@@ -91,7 +91,22 @@ protected SearchSourceBuilder createSearchSourceBuilder() {\n                 SuggestBuilderTests::randomSuggestBuilder,\n                 QueryRescorerBuilderTests::randomRescoreBuilder,\n                 randomExtBuilders,\n-                CollapseBuilderTests::randomCollapseBuilder);\n+                CollapseBuilderTests::randomCollapseBuilder,\n+                AbstractSearchTestCase::randomRandomMappings);\n+    }\n+\n+    public static Map<String, Object> randomRandomMappings() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTczOTYyMQ=="}, "originalCommit": {"oid": "139ef5f0542361ff15af2dfd20d11a53c6c23c67"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1ODE2MTM3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/enrich/src/main/java/org/elasticsearch/xpack/enrich/action/EnrichShardMultiSearchAction.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxMTozMjo1NVrOHvqeGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxMTozMjo1NVrOHvqeGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTc0MDk1NA==", "bodyText": "can you expand on why?", "url": "https://github.com/elastic/elasticsearch/pull/64374#discussion_r519740954", "createdAt": "2020-11-09T11:32:55Z", "author": {"login": "javanna"}, "path": "x-pack/plugin/enrich/src/main/java/org/elasticsearch/xpack/enrich/action/EnrichShardMultiSearchAction.java", "diffHunk": "@@ -233,7 +235,8 @@ protected MultiSearchResponse shardOperation(Request request, ShardId shardId) t\n                     shardId.id(),\n                     searcher,\n                     () -> { throw new UnsupportedOperationException(); },\n-                    null\n+                    null,\n+                    emptyMap()  // Enrich doesn't support defining runtime fields", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "139ef5f0542361ff15af2dfd20d11a53c6c23c67"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1ODE3NzQwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/runtime-fields/qa/core-with-search/build.gradle", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxMTozNzoyN1rOHvqnrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNDo1MToyMVrOHvyZ0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTc0MzQwNQ==", "bodyText": "arent we excluding field_caps above already?", "url": "https://github.com/elastic/elasticsearch/pull/64374#discussion_r519743405", "createdAt": "2020-11-09T11:37:27Z", "author": {"login": "javanna"}, "path": "x-pack/plugin/runtime-fields/qa/core-with-search/build.gradle", "diffHunk": "@@ -0,0 +1,55 @@\n+apply plugin: 'elasticsearch.yaml-rest-test'\n+\n+dependencies {\n+  yamlRestTestImplementation xpackProject(\"plugin:runtime-fields:qa\")\n+}\n+\n+restResources {\n+  restApi {\n+    includeXpack 'async_search', 'graph', '*_point_in_time'\n+  }\n+  restTests {\n+    includeCore '*'\n+    includeXpack 'async_search', 'graph'\n+  }\n+}\n+\n+testClusters.yamlRestTest {\n+  testDistribution = 'DEFAULT'\n+  setting 'xpack.license.self_generated.type', 'trial'\n+}\n+\n+yamlRestTest {\n+  systemProperty 'tests.rest.suite',\n+    [\n+      'async_search',\n+//      'field_caps',    These two don't support runtime fields on the request. Should they?\n+//      'graph',\n+//      'msearch',       This one just doesn't have infrastructure to hack the runtime fields into place\n+      'search',\n+      'search.aggregation',\n+      'search.highlight',\n+      'search.inner_hits',\n+      'search_shards',\n+      'suggest',\n+    ].join(',')\n+  systemProperty 'tests.rest.blacklist',\n+    [\n+      /////// TO FIX ///////\n+      'search.highlight/40_keyword_ignore/Plain Highligher should skip highlighting ignored keyword values', // The plain highlighter is incompatible with runtime fields. Worth fixing?\n+      'search/115_multiple_field_collapsing/two levels fields collapsing', // Broken. Gotta fix.\n+      'field_caps/30_filter/Field caps with index filter', // We don't support filtering field caps on runtime fields. What should we do?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "139ef5f0542361ff15af2dfd20d11a53c6c23c67"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTg3MDkyOQ==", "bodyText": "This list came from list in the other sub project. I think I should move the list to a common spot so I don't repeat it.", "url": "https://github.com/elastic/elasticsearch/pull/64374#discussion_r519870929", "createdAt": "2020-11-09T14:51:21Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/runtime-fields/qa/core-with-search/build.gradle", "diffHunk": "@@ -0,0 +1,55 @@\n+apply plugin: 'elasticsearch.yaml-rest-test'\n+\n+dependencies {\n+  yamlRestTestImplementation xpackProject(\"plugin:runtime-fields:qa\")\n+}\n+\n+restResources {\n+  restApi {\n+    includeXpack 'async_search', 'graph', '*_point_in_time'\n+  }\n+  restTests {\n+    includeCore '*'\n+    includeXpack 'async_search', 'graph'\n+  }\n+}\n+\n+testClusters.yamlRestTest {\n+  testDistribution = 'DEFAULT'\n+  setting 'xpack.license.self_generated.type', 'trial'\n+}\n+\n+yamlRestTest {\n+  systemProperty 'tests.rest.suite',\n+    [\n+      'async_search',\n+//      'field_caps',    These two don't support runtime fields on the request. Should they?\n+//      'graph',\n+//      'msearch',       This one just doesn't have infrastructure to hack the runtime fields into place\n+      'search',\n+      'search.aggregation',\n+      'search.highlight',\n+      'search.inner_hits',\n+      'search_shards',\n+      'suggest',\n+    ].join(',')\n+  systemProperty 'tests.rest.blacklist',\n+    [\n+      /////// TO FIX ///////\n+      'search.highlight/40_keyword_ignore/Plain Highligher should skip highlighting ignored keyword values', // The plain highlighter is incompatible with runtime fields. Worth fixing?\n+      'search/115_multiple_field_collapsing/two levels fields collapsing', // Broken. Gotta fix.\n+      'field_caps/30_filter/Field caps with index filter', // We don't support filtering field caps on runtime fields. What should we do?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTc0MzQwNQ=="}, "originalCommit": {"oid": "139ef5f0542361ff15af2dfd20d11a53c6c23c67"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1ODE4MTc2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/runtime-fields/qa/core-with-search/src/yamlRestTest/java/org/elasticsearch/xpack/runtimefields/test/search/CoreTestsWithSearchRuntimeFieldsIT.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxMTozODo0OVrOHvqqcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNDo1MTozNFrOHvyadQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTc0NDExNQ==", "bodyText": "can this be removed now?", "url": "https://github.com/elastic/elasticsearch/pull/64374#discussion_r519744115", "createdAt": "2020-11-09T11:38:49Z", "author": {"login": "javanna"}, "path": "x-pack/plugin/runtime-fields/qa/core-with-search/src/yamlRestTest/java/org/elasticsearch/xpack/runtimefields/test/search/CoreTestsWithSearchRuntimeFieldsIT.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.runtimefields.test.search;\n+\n+import com.carrotsearch.randomizedtesting.annotations.Name;\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+\n+import org.elasticsearch.action.index.IndexRequest;\n+import org.elasticsearch.common.regex.Regex;\n+import org.elasticsearch.common.xcontent.XContentHelper;\n+import org.elasticsearch.index.mapper.DateFieldMapper;\n+import org.elasticsearch.test.rest.yaml.ClientYamlTestCandidate;\n+import org.elasticsearch.test.rest.yaml.ESClientYamlSuiteTestCase;\n+import org.elasticsearch.test.rest.yaml.section.ApiCallSection;\n+import org.elasticsearch.test.rest.yaml.section.ExecutableSection;\n+import org.elasticsearch.xpack.runtimefields.test.CoreTestTranslater;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static java.util.Collections.unmodifiableMap;\n+\n+/**\n+ * Runs elasticsearch's core rest tests disabling all mappings and replacing them\n+ * with runtime fields defined on the search request that load from {@code _source}. Tests\n+ * that configure the field in a way that are not supported by runtime fields are skipped.\n+ */\n+public class CoreTestsWithSearchRuntimeFieldsIT extends ESClientYamlSuiteTestCase {\n+    public CoreTestsWithSearchRuntimeFieldsIT(@Name(\"yaml\") ClientYamlTestCandidate testCandidate) {\n+        super(testCandidate);\n+    }\n+\n+    @Override\n+    protected boolean randomizeContentType() { // NOCOMMIT remove me", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "139ef5f0542361ff15af2dfd20d11a53c6c23c67"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTg3MTA5Mw==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/elastic/elasticsearch/pull/64374#discussion_r519871093", "createdAt": "2020-11-09T14:51:34Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/runtime-fields/qa/core-with-search/src/yamlRestTest/java/org/elasticsearch/xpack/runtimefields/test/search/CoreTestsWithSearchRuntimeFieldsIT.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.runtimefields.test.search;\n+\n+import com.carrotsearch.randomizedtesting.annotations.Name;\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+\n+import org.elasticsearch.action.index.IndexRequest;\n+import org.elasticsearch.common.regex.Regex;\n+import org.elasticsearch.common.xcontent.XContentHelper;\n+import org.elasticsearch.index.mapper.DateFieldMapper;\n+import org.elasticsearch.test.rest.yaml.ClientYamlTestCandidate;\n+import org.elasticsearch.test.rest.yaml.ESClientYamlSuiteTestCase;\n+import org.elasticsearch.test.rest.yaml.section.ApiCallSection;\n+import org.elasticsearch.test.rest.yaml.section.ExecutableSection;\n+import org.elasticsearch.xpack.runtimefields.test.CoreTestTranslater;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static java.util.Collections.unmodifiableMap;\n+\n+/**\n+ * Runs elasticsearch's core rest tests disabling all mappings and replacing them\n+ * with runtime fields defined on the search request that load from {@code _source}. Tests\n+ * that configure the field in a way that are not supported by runtime fields are skipped.\n+ */\n+public class CoreTestsWithSearchRuntimeFieldsIT extends ESClientYamlSuiteTestCase {\n+    public CoreTestsWithSearchRuntimeFieldsIT(@Name(\"yaml\") ClientYamlTestCandidate testCandidate) {\n+        super(testCandidate);\n+    }\n+\n+    @Override\n+    protected boolean randomizeContentType() { // NOCOMMIT remove me", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTc0NDExNQ=="}, "originalCommit": {"oid": "139ef5f0542361ff15af2dfd20d11a53c6c23c67"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1ODIwNjk3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/src/test/resources/rest-api-spec/test/runtime_fields/10_keyword.yml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxMTo0NTo1MlrOHvq5sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNDo1NTowMlrOHvyldA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTc0ODAxOA==", "bodyText": "do we also want to test replacing a field within an existing object?", "url": "https://github.com/elastic/elasticsearch/pull/64374#discussion_r519748018", "createdAt": "2020-11-09T11:45:52Z", "author": {"login": "javanna"}, "path": "x-pack/plugin/src/test/resources/rest-api-spec/test/runtime_fields/10_keyword.yml", "diffHunk": "@@ -360,3 +360,79 @@ setup:\n   - match: { aggregations.to-users.users.hits.hits.2._index: test }\n   - match: { aggregations.to-users.users.hits.hits.2._nested.field: users }\n   - match: { aggregations.to-users.users.hits.hits.2._nested.offset: 1 }\n+\n+---\n+\"fetch defined on search request\":\n+  - do:\n+      search:\n+        index: sensor\n+        body:\n+          runtime_mappings:\n+            voltage_rating:\n+              type: keyword\n+              script: |\n+                double v = doc['voltage'].value;\n+                if (v < 4.8) {\n+                  emit('low');\n+                } else if (v > 5.2) {\n+                  emit('high');\n+                } else {\n+                  emit('ok');\n+                }\n+          fields: [voltage_rating]\n+          sort: timestamp\n+  - match: {hits.total.value: 6}\n+  - match: {hits.hits.0._source.voltage: 4.0}\n+  - match: {hits.hits.0.fields.voltage_rating: [low]}\n+\n+\n+---\n+\"match defined on search request\":\n+  - do:\n+      search:\n+        index: sensor\n+        body:\n+          runtime_mappings:\n+            voltage.rating:\n+              type: keyword\n+              script: |\n+                double v = doc['voltage'].value;\n+                if (v < 4.8) {\n+                  emit('low');\n+                } else if (v > 5.2) {\n+                  emit('high');\n+                } else {\n+                  emit('ok');\n+                }\n+          query:\n+            match:\n+              voltage.rating: ok\n+          sort: timestamp\n+  - match: {hits.total.value: 2}\n+  - match: {hits.hits.0._source.voltage: 5.1}\n+\n+---\n+\"search glob defined on search request\":\n+  - do:\n+      search:\n+        index: sensor\n+        body:\n+          runtime_mappings:\n+            voltage.rating:\n+              type: keyword\n+              script: |\n+                double v = doc['voltage'].value;\n+                if (v < 4.8) {\n+                  emit('low');\n+                } else if (v > 5.2) {\n+                  emit('high');\n+                } else {\n+                  emit('ok');\n+                }\n+          query:\n+            simple_query_string:\n+              fields: [voltage.*]\n+              query: ok\n+          sort: timestamp\n+  - match: {hits.total.value: 2}\n+  - match: {hits.hits.0._source.voltage: 5.1}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "139ef5f0542361ff15af2dfd20d11a53c6c23c67"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTg3MzkwOA==", "bodyText": "Good call!", "url": "https://github.com/elastic/elasticsearch/pull/64374#discussion_r519873908", "createdAt": "2020-11-09T14:55:02Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/src/test/resources/rest-api-spec/test/runtime_fields/10_keyword.yml", "diffHunk": "@@ -360,3 +360,79 @@ setup:\n   - match: { aggregations.to-users.users.hits.hits.2._index: test }\n   - match: { aggregations.to-users.users.hits.hits.2._nested.field: users }\n   - match: { aggregations.to-users.users.hits.hits.2._nested.offset: 1 }\n+\n+---\n+\"fetch defined on search request\":\n+  - do:\n+      search:\n+        index: sensor\n+        body:\n+          runtime_mappings:\n+            voltage_rating:\n+              type: keyword\n+              script: |\n+                double v = doc['voltage'].value;\n+                if (v < 4.8) {\n+                  emit('low');\n+                } else if (v > 5.2) {\n+                  emit('high');\n+                } else {\n+                  emit('ok');\n+                }\n+          fields: [voltage_rating]\n+          sort: timestamp\n+  - match: {hits.total.value: 6}\n+  - match: {hits.hits.0._source.voltage: 4.0}\n+  - match: {hits.hits.0.fields.voltage_rating: [low]}\n+\n+\n+---\n+\"match defined on search request\":\n+  - do:\n+      search:\n+        index: sensor\n+        body:\n+          runtime_mappings:\n+            voltage.rating:\n+              type: keyword\n+              script: |\n+                double v = doc['voltage'].value;\n+                if (v < 4.8) {\n+                  emit('low');\n+                } else if (v > 5.2) {\n+                  emit('high');\n+                } else {\n+                  emit('ok');\n+                }\n+          query:\n+            match:\n+              voltage.rating: ok\n+          sort: timestamp\n+  - match: {hits.total.value: 2}\n+  - match: {hits.hits.0._source.voltage: 5.1}\n+\n+---\n+\"search glob defined on search request\":\n+  - do:\n+      search:\n+        index: sensor\n+        body:\n+          runtime_mappings:\n+            voltage.rating:\n+              type: keyword\n+              script: |\n+                double v = doc['voltage'].value;\n+                if (v < 4.8) {\n+                  emit('low');\n+                } else if (v > 5.2) {\n+                  emit('high');\n+                } else {\n+                  emit('ok');\n+                }\n+          query:\n+            simple_query_string:\n+              fields: [voltage.*]\n+              query: ok\n+          sort: timestamp\n+  - match: {hits.total.value: 2}\n+  - match: {hits.hits.0._source.voltage: 5.1}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTc0ODAxOA=="}, "originalCommit": {"oid": "139ef5f0542361ff15af2dfd20d11a53c6c23c67"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1OTEzNzU3OnYy", "diffSide": "RIGHT", "path": "rest-api-spec/src/main/resources/rest-api-spec/test/search.aggregation/340_geo_distance.yml", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNToyMjowN1rOHvz0Lw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNToyMjowN1rOHvz0Lw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTg5NDA2Mw==", "bodyText": "I'll revert this one!", "url": "https://github.com/elastic/elasticsearch/pull/64374#discussion_r519894063", "createdAt": "2020-11-09T15:22:07Z", "author": {"login": "nik9000"}, "path": "rest-api-spec/src/main/resources/rest-api-spec/test/search.aggregation/340_geo_distance.yml", "diffHunk": "@@ -1,15 +1,15 @@\n setup:\n   - do:\n       indices.create:\n-        index: test\n+        index: test_geoadsf", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b336ff3f87026cb3d9481f74b16ba9841bdab266"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1OTQ5MTEzOnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/elasticsearch/search/builder/SearchSourceBuilderTests.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNjozNTo1N1rOHv3M9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNjo0Mjo0NFrOHv3foQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk0OTU1OQ==", "bodyText": "Maybe call this out as Version.V_8_0_0 explicitly so it doesn't start failing once master is on v9?", "url": "https://github.com/elastic/elasticsearch/pull/64374#discussion_r519949559", "createdAt": "2020-11-09T16:35:57Z", "author": {"login": "romseygeek"}, "path": "server/src/test/java/org/elasticsearch/search/builder/SearchSourceBuilderTests.java", "diffHunk": "@@ -93,16 +92,18 @@ private static void assertParseSearchSource(SearchSourceBuilder testBuilder, XCo\n     }\n \n     public void testSerialization() throws IOException {\n-        SearchSourceBuilder testBuilder = createSearchSourceBuilder();\n-        try (BytesStreamOutput output = new BytesStreamOutput()) {\n-            testBuilder.writeTo(output);\n-            try (StreamInput in = new NamedWriteableAwareStreamInput(output.bytes().streamInput(), namedWriteableRegistry)) {\n-                SearchSourceBuilder deserializedBuilder = new SearchSourceBuilder(in);\n-                assertEquals(deserializedBuilder, testBuilder);\n-                assertEquals(deserializedBuilder.hashCode(), testBuilder.hashCode());\n-                assertNotSame(deserializedBuilder, testBuilder);\n-            }\n-        }\n+        SearchSourceBuilder original = createSearchSourceBuilder();\n+        SearchSourceBuilder copy = copyBuilder(original);\n+        assertEquals(copy, original);\n+        assertEquals(copy.hashCode(), original.hashCode());\n+        assertNotSame(copy, original);\n+    }\n+\n+    public void testSerializingWithRuntimeFieldsBeforeSupportedThrows() {\n+        SearchSourceBuilder original = new SearchSourceBuilder().runtimeMappings(randomRuntimeMappings());\n+        Version v = Version.CURRENT.minimumCompatibilityVersion();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34abd68240e9111965339454ee5361fff682cac6"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk1NDMzNw==", "bodyText": "When we go to v9.0.0 we'll want to remove the test anyway. Frankly, I think we'll blast the test as soon as I'm done backporting because we'll be able to send to 7.11.0. This v will be a bit more complex in the backport.", "url": "https://github.com/elastic/elasticsearch/pull/64374#discussion_r519954337", "createdAt": "2020-11-09T16:42:44Z", "author": {"login": "nik9000"}, "path": "server/src/test/java/org/elasticsearch/search/builder/SearchSourceBuilderTests.java", "diffHunk": "@@ -93,16 +92,18 @@ private static void assertParseSearchSource(SearchSourceBuilder testBuilder, XCo\n     }\n \n     public void testSerialization() throws IOException {\n-        SearchSourceBuilder testBuilder = createSearchSourceBuilder();\n-        try (BytesStreamOutput output = new BytesStreamOutput()) {\n-            testBuilder.writeTo(output);\n-            try (StreamInput in = new NamedWriteableAwareStreamInput(output.bytes().streamInput(), namedWriteableRegistry)) {\n-                SearchSourceBuilder deserializedBuilder = new SearchSourceBuilder(in);\n-                assertEquals(deserializedBuilder, testBuilder);\n-                assertEquals(deserializedBuilder.hashCode(), testBuilder.hashCode());\n-                assertNotSame(deserializedBuilder, testBuilder);\n-            }\n-        }\n+        SearchSourceBuilder original = createSearchSourceBuilder();\n+        SearchSourceBuilder copy = copyBuilder(original);\n+        assertEquals(copy, original);\n+        assertEquals(copy.hashCode(), original.hashCode());\n+        assertNotSame(copy, original);\n+    }\n+\n+    public void testSerializingWithRuntimeFieldsBeforeSupportedThrows() {\n+        SearchSourceBuilder original = new SearchSourceBuilder().runtimeMappings(randomRuntimeMappings());\n+        Version v = Version.CURRENT.minimumCompatibilityVersion();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk0OTU1OQ=="}, "originalCommit": {"oid": "34abd68240e9111965339454ee5361fff682cac6"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1OTUzODIwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/query/QueryShardContext.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNjo0NTozNFrOHv3qOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNzozMjozMFrOHv51Yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk1NzA1MQ==", "bodyText": "I was wondering about this line: is it good also for runtime fields?", "url": "https://github.com/elastic/elasticsearch/pull/64374#discussion_r519957051", "createdAt": "2020-11-09T16:45:34Z", "author": {"login": "javanna"}, "path": "server/src/main/java/org/elasticsearch/index/query/QueryShardContext.java", "diffHunk": "@@ -287,12 +363,21 @@ public boolean isSourceEnabled() {\n      * Generally used to handle unmapped fields in the context of sorting.\n      */\n     public MappedFieldType buildAnonymousFieldType(String type) {\n-        final Mapper.TypeParser.ParserContext parserContext = mapperService.parserContext();\n+        return buildFieldType(type, \"__anonymous_\" + type, Collections.emptyMap(), mapperService.parserContext(), indexSettings);\n+    }\n+\n+    private static MappedFieldType buildFieldType(\n+        String type,\n+        String field,\n+        Map<String, Object> node,\n+        Mapper.TypeParser.ParserContext parserContext,\n+        IndexSettings indexSettings\n+    ) {\n         Mapper.TypeParser typeParser = parserContext.typeParser(type);\n         if (typeParser == null) {\n             throw new IllegalArgumentException(\"No mapper found for type [\" + type + \"]\");\n         }\n-        final Mapper.Builder builder = typeParser.parse(\"__anonymous_\" + type, Collections.emptyMap(), parserContext);\n+        Mapper.Builder builder = typeParser.parse(field, node, parserContext);\n         Mapper mapper = builder.build(new ContentPath(1));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34abd68240e9111965339454ee5361fff682cac6"}, "originalPosition": 196}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk2NDA0Mw==", "bodyText": "The new ContentPath(1) bit?", "url": "https://github.com/elastic/elasticsearch/pull/64374#discussion_r519964043", "createdAt": "2020-11-09T16:52:10Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/index/query/QueryShardContext.java", "diffHunk": "@@ -287,12 +363,21 @@ public boolean isSourceEnabled() {\n      * Generally used to handle unmapped fields in the context of sorting.\n      */\n     public MappedFieldType buildAnonymousFieldType(String type) {\n-        final Mapper.TypeParser.ParserContext parserContext = mapperService.parserContext();\n+        return buildFieldType(type, \"__anonymous_\" + type, Collections.emptyMap(), mapperService.parserContext(), indexSettings);\n+    }\n+\n+    private static MappedFieldType buildFieldType(\n+        String type,\n+        String field,\n+        Map<String, Object> node,\n+        Mapper.TypeParser.ParserContext parserContext,\n+        IndexSettings indexSettings\n+    ) {\n         Mapper.TypeParser typeParser = parserContext.typeParser(type);\n         if (typeParser == null) {\n             throw new IllegalArgumentException(\"No mapper found for type [\" + type + \"]\");\n         }\n-        final Mapper.Builder builder = typeParser.parse(\"__anonymous_\" + type, Collections.emptyMap(), parserContext);\n+        Mapper.Builder builder = typeParser.parse(field, node, parserContext);\n         Mapper mapper = builder.build(new ContentPath(1));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk1NzA1MQ=="}, "originalCommit": {"oid": "34abd68240e9111965339454ee5361fff682cac6"}, "originalPosition": 196}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk2NjM4MQ==", "bodyText": "yes", "url": "https://github.com/elastic/elasticsearch/pull/64374#discussion_r519966381", "createdAt": "2020-11-09T16:54:25Z", "author": {"login": "javanna"}, "path": "server/src/main/java/org/elasticsearch/index/query/QueryShardContext.java", "diffHunk": "@@ -287,12 +363,21 @@ public boolean isSourceEnabled() {\n      * Generally used to handle unmapped fields in the context of sorting.\n      */\n     public MappedFieldType buildAnonymousFieldType(String type) {\n-        final Mapper.TypeParser.ParserContext parserContext = mapperService.parserContext();\n+        return buildFieldType(type, \"__anonymous_\" + type, Collections.emptyMap(), mapperService.parserContext(), indexSettings);\n+    }\n+\n+    private static MappedFieldType buildFieldType(\n+        String type,\n+        String field,\n+        Map<String, Object> node,\n+        Mapper.TypeParser.ParserContext parserContext,\n+        IndexSettings indexSettings\n+    ) {\n         Mapper.TypeParser typeParser = parserContext.typeParser(type);\n         if (typeParser == null) {\n             throw new IllegalArgumentException(\"No mapper found for type [\" + type + \"]\");\n         }\n-        final Mapper.Builder builder = typeParser.parse(\"__anonymous_\" + type, Collections.emptyMap(), parserContext);\n+        Mapper.Builder builder = typeParser.parse(field, node, parserContext);\n         Mapper mapper = builder.build(new ContentPath(1));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk1NzA1MQ=="}, "originalCommit": {"oid": "34abd68240e9111965339454ee5361fff682cac6"}, "originalPosition": 196}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk5MjY3NQ==", "bodyText": "I looked around a bit and I'm not sure why anonymous fields use 1 here instead of 0 or 123 or any other number. I think we don't end up in the positions of building a path to add anyway. I'll do some more experimenting to see if I can make something \"funny\" if this is set to 0.", "url": "https://github.com/elastic/elasticsearch/pull/64374#discussion_r519992675", "createdAt": "2020-11-09T17:32:30Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/index/query/QueryShardContext.java", "diffHunk": "@@ -287,12 +363,21 @@ public boolean isSourceEnabled() {\n      * Generally used to handle unmapped fields in the context of sorting.\n      */\n     public MappedFieldType buildAnonymousFieldType(String type) {\n-        final Mapper.TypeParser.ParserContext parserContext = mapperService.parserContext();\n+        return buildFieldType(type, \"__anonymous_\" + type, Collections.emptyMap(), mapperService.parserContext(), indexSettings);\n+    }\n+\n+    private static MappedFieldType buildFieldType(\n+        String type,\n+        String field,\n+        Map<String, Object> node,\n+        Mapper.TypeParser.ParserContext parserContext,\n+        IndexSettings indexSettings\n+    ) {\n         Mapper.TypeParser typeParser = parserContext.typeParser(type);\n         if (typeParser == null) {\n             throw new IllegalArgumentException(\"No mapper found for type [\" + type + \"]\");\n         }\n-        final Mapper.Builder builder = typeParser.parse(\"__anonymous_\" + type, Collections.emptyMap(), parserContext);\n+        Mapper.Builder builder = typeParser.parse(field, node, parserContext);\n         Mapper mapper = builder.build(new ContentPath(1));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk1NzA1MQ=="}, "originalCommit": {"oid": "34abd68240e9111965339454ee5361fff682cac6"}, "originalPosition": 196}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1OTYwNjI2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNjo1Njo1NVrOHv4Vrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNzoxMzoyMlrOHv5DFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk2ODE3NA==", "bodyText": "shall we initialize it with empty list and make sure that it can never be null, then we can remove the boolean flag in the serialization methods?", "url": "https://github.com/elastic/elasticsearch/pull/64374#discussion_r519968174", "createdAt": "2020-11-09T16:56:55Z", "author": {"login": "javanna"}, "path": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java", "diffHunk": "@@ -191,6 +193,8 @@ public static HighlightBuilder highlight() {\n \n     private PointInTimeBuilder pointInTimeBuilder = null;\n \n+    private Map<String, Object> runtimeMappings = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f91f5670c613baec68bbfb906e001f19e4bee97d"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk3OTc5Nw==", "bodyText": "I was using the pattern from stuff like sort, but I see that lots of stuff uses the emptyMap style. I'll swap.", "url": "https://github.com/elastic/elasticsearch/pull/64374#discussion_r519979797", "createdAt": "2020-11-09T17:13:22Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java", "diffHunk": "@@ -191,6 +193,8 @@ public static HighlightBuilder highlight() {\n \n     private PointInTimeBuilder pointInTimeBuilder = null;\n \n+    private Map<String, Object> runtimeMappings = null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk2ODE3NA=="}, "originalCommit": {"oid": "f91f5670c613baec68bbfb906e001f19e4bee97d"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1OTYzMDUxOnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/elasticsearch/search/builder/SearchSourceBuilderTests.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNzowMjoxNFrOHv4kmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNzoxMTozNFrOHv4-Tw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk3MTk5Mw==", "bodyText": "can you extract this behaviour to the description of the PR so it is highlighted? I think it makes sense but it differs from how we've done these things in the past.", "url": "https://github.com/elastic/elasticsearch/pull/64374#discussion_r519971993", "createdAt": "2020-11-09T17:02:14Z", "author": {"login": "javanna"}, "path": "server/src/test/java/org/elasticsearch/search/builder/SearchSourceBuilderTests.java", "diffHunk": "@@ -93,16 +92,18 @@ private static void assertParseSearchSource(SearchSourceBuilder testBuilder, XCo\n     }\n \n     public void testSerialization() throws IOException {\n-        SearchSourceBuilder testBuilder = createSearchSourceBuilder();\n-        try (BytesStreamOutput output = new BytesStreamOutput()) {\n-            testBuilder.writeTo(output);\n-            try (StreamInput in = new NamedWriteableAwareStreamInput(output.bytes().streamInput(), namedWriteableRegistry)) {\n-                SearchSourceBuilder deserializedBuilder = new SearchSourceBuilder(in);\n-                assertEquals(deserializedBuilder, testBuilder);\n-                assertEquals(deserializedBuilder.hashCode(), testBuilder.hashCode());\n-                assertNotSame(deserializedBuilder, testBuilder);\n-            }\n-        }\n+        SearchSourceBuilder original = createSearchSourceBuilder();\n+        SearchSourceBuilder copy = copyBuilder(original);\n+        assertEquals(copy, original);\n+        assertEquals(copy.hashCode(), original.hashCode());\n+        assertNotSame(copy, original);\n+    }\n+\n+    public void testSerializingWithRuntimeFieldsBeforeSupportedThrows() {\n+        SearchSourceBuilder original = new SearchSourceBuilder().runtimeMappings(randomRuntimeMappings());\n+        Version v = Version.V_8_0_0.minimumCompatibilityVersion();\n+        Exception e = expectThrows(IllegalArgumentException.class, () -> copyBuilder(original, v));\n+        assertThat(e.getMessage(), equalTo(\"Versions before 8.0.0 don't support [runtime_mappings] and search was sent to [\" + v + \"]\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f91f5670c613baec68bbfb906e001f19e4bee97d"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk3ODU3NQ==", "bodyText": "I do this most of the time I implement something. But, sure!", "url": "https://github.com/elastic/elasticsearch/pull/64374#discussion_r519978575", "createdAt": "2020-11-09T17:11:34Z", "author": {"login": "nik9000"}, "path": "server/src/test/java/org/elasticsearch/search/builder/SearchSourceBuilderTests.java", "diffHunk": "@@ -93,16 +92,18 @@ private static void assertParseSearchSource(SearchSourceBuilder testBuilder, XCo\n     }\n \n     public void testSerialization() throws IOException {\n-        SearchSourceBuilder testBuilder = createSearchSourceBuilder();\n-        try (BytesStreamOutput output = new BytesStreamOutput()) {\n-            testBuilder.writeTo(output);\n-            try (StreamInput in = new NamedWriteableAwareStreamInput(output.bytes().streamInput(), namedWriteableRegistry)) {\n-                SearchSourceBuilder deserializedBuilder = new SearchSourceBuilder(in);\n-                assertEquals(deserializedBuilder, testBuilder);\n-                assertEquals(deserializedBuilder.hashCode(), testBuilder.hashCode());\n-                assertNotSame(deserializedBuilder, testBuilder);\n-            }\n-        }\n+        SearchSourceBuilder original = createSearchSourceBuilder();\n+        SearchSourceBuilder copy = copyBuilder(original);\n+        assertEquals(copy, original);\n+        assertEquals(copy.hashCode(), original.hashCode());\n+        assertNotSame(copy, original);\n+    }\n+\n+    public void testSerializingWithRuntimeFieldsBeforeSupportedThrows() {\n+        SearchSourceBuilder original = new SearchSourceBuilder().runtimeMappings(randomRuntimeMappings());\n+        Version v = Version.V_8_0_0.minimumCompatibilityVersion();\n+        Exception e = expectThrows(IllegalArgumentException.class, () -> copyBuilder(original, v));\n+        assertThat(e.getMessage(), equalTo(\"Versions before 8.0.0 don't support [runtime_mappings] and search was sent to [\" + v + \"]\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk3MTk5Mw=="}, "originalCommit": {"oid": "f91f5670c613baec68bbfb906e001f19e4bee97d"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1OTYzNDU0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/enrich/src/main/java/org/elasticsearch/xpack/enrich/action/EnrichShardMultiSearchAction.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNzowMzowNVrOHv4m8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNzoxMToxMlrOHv49TQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk3MjU5NQ==", "bodyText": "you have expanded the comment but not the why :) What made you decide that enrich does not support runtime fields defined in the search request?", "url": "https://github.com/elastic/elasticsearch/pull/64374#discussion_r519972595", "createdAt": "2020-11-09T17:03:05Z", "author": {"login": "javanna"}, "path": "x-pack/plugin/enrich/src/main/java/org/elasticsearch/xpack/enrich/action/EnrichShardMultiSearchAction.java", "diffHunk": "@@ -229,11 +231,18 @@ protected MultiSearchResponse shardOperation(Request request, ShardId shardId) t\n             final IndexShard indexShard = indicesService.getShardOrNull(shardId);\n             try (Engine.Searcher searcher = indexShard.acquireSearcher(\"enrich_msearch\")) {\n                 final FieldsVisitor visitor = new FieldsVisitor(true);\n+                /*\n+                 * Enrich doesn't support defining runtime fields in the search", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f91f5670c613baec68bbfb906e001f19e4bee97d"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk3ODMxNw==", "bodyText": "I didn't so much make the choice as not add it as a new feature. I'll send a new comment.", "url": "https://github.com/elastic/elasticsearch/pull/64374#discussion_r519978317", "createdAt": "2020-11-09T17:11:12Z", "author": {"login": "nik9000"}, "path": "x-pack/plugin/enrich/src/main/java/org/elasticsearch/xpack/enrich/action/EnrichShardMultiSearchAction.java", "diffHunk": "@@ -229,11 +231,18 @@ protected MultiSearchResponse shardOperation(Request request, ShardId shardId) t\n             final IndexShard indexShard = indicesService.getShardOrNull(shardId);\n             try (Engine.Searcher searcher = indexShard.acquireSearcher(\"enrich_msearch\")) {\n                 final FieldsVisitor visitor = new FieldsVisitor(true);\n+                /*\n+                 * Enrich doesn't support defining runtime fields in the search", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk3MjU5NQ=="}, "originalCommit": {"oid": "f91f5670c613baec68bbfb906e001f19e4bee97d"}, "originalPosition": 14}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4085, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}