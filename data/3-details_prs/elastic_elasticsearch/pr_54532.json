{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk2NTcxMjQx", "number": 54532, "title": "Fix responses for the token APIs", "bodyText": "This commit fixes our behavior for the use of token related APIs.\nMore concretely:\n\n\nIn the Get Token API with the refresh grant, when an invalid\n(already deleted, malformed, unknown) refresh token is used in the\nbody of the request, we respond with 400 HTTP status code\nand an error_description header with the message \"could not\nrefresh the requested token\".\nPreviously we would return erroneously return a  401 with \"token\nmalformed\" message.\n\n\nIn the Invalidate Token API, when using an invalid (already\ndeleted, malformed, unknown) access or refresh token, we respond\nwith 404 and a body that shows that no tokens were invalidated:\n{\n  \"invalidated_tokens\":0,\n  \"previously_invalidated_tokens\":0,\n   \"error_count\":0\n}\n\nThe previous behavior would be to erroneously return\na 400 or 401 ( depending on the case ).\n\n\nIn the Invalidate Token API, when the tokens index doesn't\nexist or is closed, we return 400 because we assume this is\na user issue either because they tried to invalidate a token\nwhen there is no tokens index yet ( i.e. no tokens have\nbeen created yet or the tokens index has been deleted ) or the\nindex is closed.\n\n\nIn the Invalidate Token API, when the tokens index is\nunavailable, we return a 503 status code because\nwe want to signal to the caller of the API that the token they\ntried to invalidate was not invalidated and we can't be sure\nif it is still valid or not, and that they should try the request\nagain.\n\n\nResolves: #53323", "createdAt": "2020-03-31T20:08:38Z", "url": "https://github.com/elastic/elasticsearch/pull/54532", "merged": true, "mergeCommit": {"oid": "de30a0e18e6ca14110f2b3adcccb204496753c47"}, "closed": true, "closedAt": "2020-04-16T06:35:45Z", "author": {"login": "jkakavas"}, "timelineItems": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcTIl_ngH2gAyMzk2NTcxMjQxOmE1ODg2NzkwOGE3ZmNhNmYyZWE0ZDQzMGY0MzIwODlkNGEwM2U1ZDk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcX4BUiAFqTM5Mzc2NzAzNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "a58867908a7fca6f2ea4d430f432089d4a03e5d9", "author": {"user": {"login": "jkakavas", "name": "Ioannis Kakavas"}}, "url": "https://github.com/elastic/elasticsearch/commit/a58867908a7fca6f2ea4d430f432089d4a03e5d9", "committedDate": "2020-03-31T19:51:23Z", "message": "Fix responses for the token APIs\n\nThis commit fixes our behavior for the use of token related APIs.\nMore concretely:\n\n- In the Get Token API with the `refresh` grant, when an invalid\n(already deleted, malformed, unknown) refresh token is used in the\nbody of the request, we respond with 400 and an error_description\nheader with the message \"could not refresh the requested token\" as\nopposed to sometimes doing that and sometimes returning `401` and\na message \"token malformed\"\n\n- In the Invalidate Token API, when using an invalid (already\ndeleted, malformed, unknown) access or refresh token, we respond\nwith 200 and a body that shows that no tokens were invalidated:\n```\n{\n  \"invalidated_tokens\":0,\n  \"previously_invalidated_tokens\":0,\n  \"error_count\":0\n}\n```\nas opposed to the current behavior which was to throw an error\nwith 400 or 401 ( depending on the case )"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "262cffa6ac1ba618a009581e947a279c16dcaf05", "author": {"user": {"login": "jkakavas", "name": "Ioannis Kakavas"}}, "url": "https://github.com/elastic/elasticsearch/commit/262cffa6ac1ba618a009581e947a279c16dcaf05", "committedDate": "2020-03-31T21:00:52Z", "message": "fix expected error"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg1MTAzNDU1", "url": "https://github.com/elastic/elasticsearch/pull/54532#pullrequestreview-385103455", "createdAt": "2020-03-31T21:04:10Z", "commit": {"oid": "262cffa6ac1ba618a009581e947a279c16dcaf05"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMTowNDoxMFrOF-oLWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMTowNDoxMFrOF-oLWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIxNDI5OA==", "bodyText": "The (expected for this test) 500 was masked by the 401 that was thrown in \n  \n    \n      elasticsearch/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/action/oidc/TransportOpenIdConnectLogoutAction.java\n    \n    \n         Line 55\n      in\n      d029a13\n    \n    \n    \n    \n\n        \n          \n           invalidateRefreshToken(request.getRefreshToken(), ActionListener.wrap(ignore -> {", "url": "https://github.com/elastic/elasticsearch/pull/54532#discussion_r401214298", "createdAt": "2020-03-31T21:04:10Z", "author": {"login": "jkakavas"}, "path": "x-pack/docs/en/rest-api/security/oidc-logout-api.asciidoc", "diffHunk": "@@ -48,7 +48,7 @@ POST /_security/oidc/logout\n   \"refresh_token\": \"vLBPvmAB6KvwvJZr27cS\"\n }\n --------------------------------------------------\n-// TEST[catch:unauthorized]\n+// TEST[catch:request]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "262cffa6ac1ba618a009581e947a279c16dcaf05"}, "originalPosition": 14}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a12ba64e52b849720fe702a5c6c56a4f9ca46cae", "author": {"user": {"login": "jkakavas", "name": "Ioannis Kakavas"}}, "url": "https://github.com/elastic/elasticsearch/commit/a12ba64e52b849720fe702a5c6c56a4f9ca46cae", "committedDate": "2020-04-01T09:50:09Z", "message": "fix doc test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "24eb4b788ca73e5bcdf326651cc8d9b02bc7e489", "author": {"user": {"login": "jkakavas", "name": "Ioannis Kakavas"}}, "url": "https://github.com/elastic/elasticsearch/commit/24eb4b788ca73e5bcdf326651cc8d9b02bc7e489", "committedDate": "2020-04-01T10:09:16Z", "message": "Merge remote-tracking branch 'origin/master' into fix-token-invalidation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2MTExMjMy", "url": "https://github.com/elastic/elasticsearch/pull/54532#pullrequestreview-386111232", "createdAt": "2020-04-02T05:12:19Z", "commit": {"oid": "24eb4b788ca73e5bcdf326651cc8d9b02bc7e489"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwNToxMjoxOVrOF_bf6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwNTozNDo1NVrOF_b3_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjA1NTE0NQ==", "bodyText": "With this change, a 200 response will be returned if the token index does not exist. This behaviour is different from the refresh token invalidation, which returns 400 invalidGrant when the index does not exist.", "url": "https://github.com/elastic/elasticsearch/pull/54532#discussion_r402055145", "createdAt": "2020-04-02T05:12:19Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/TokenService.java", "diffHunk": "@@ -584,7 +585,8 @@ public void invalidateAccessToken(String accessToken, ActionListener<TokensInval\n             final Iterator<TimeValue> backoff = DEFAULT_BACKOFF.iterator();\n             decodeToken(accessToken, ActionListener.wrap(userToken -> {\n                 if (userToken == null) {\n-                    listener.onFailure(traceLog(\"invalidate token\", accessToken, malformedTokenException()));\n+                    logger.trace(\"The access token [{}] is expired and already deleted\", accessToken);\n+                    listener.onResponse(TokensInvalidationResult.emptyResult());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24eb4b788ca73e5bcdf326651cc8d9b02bc7e489"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjA1Njc5Nw==", "bodyText": "This is necessary because the response changes to 200 and error now happens in the OIDC part as 500?", "url": "https://github.com/elastic/elasticsearch/pull/54532#discussion_r402056797", "createdAt": "2020-04-02T05:18:12Z", "author": {"login": "ywangd"}, "path": "x-pack/docs/en/rest-api/security/oidc-logout-api.asciidoc", "diffHunk": "@@ -48,7 +48,7 @@ POST /_security/oidc/logout\n   \"refresh_token\": \"vLBPvmAB6KvwvJZr27cS\"\n }\n --------------------------------------------------\n-// TEST[catch:unauthorized]\n+// TEST[catch:request]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIxNDI5OA=="}, "originalCommit": {"oid": "262cffa6ac1ba618a009581e947a279c16dcaf05"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjA2MTMwOQ==", "bodyText": "All usage of malformedTokenException seems to be deleted so itself can be removed as well.", "url": "https://github.com/elastic/elasticsearch/pull/54532#discussion_r402061309", "createdAt": "2020-04-02T05:34:55Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/TokenService.java", "diffHunk": "@@ -872,7 +891,7 @@ private void findTokenFromRefreshToken(String refreshToken, Iterator<TimeValue>\n                     }\n                 } catch (IOException e) {\n                     logger.debug(() -> new ParameterizedMessage(\"Could not decode refresh token [{}].\", refreshToken), e);\n-                    listener.onFailure(malformedTokenException());\n+                    listener.onResponse(SearchHits.empty());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24eb4b788ca73e5bcdf326651cc8d9b02bc7e489"}, "originalPosition": 90}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "00efc5421aaeb21809b0478432929739a994637c", "author": {"user": {"login": "jkakavas", "name": "Ioannis Kakavas"}}, "url": "https://github.com/elastic/elasticsearch/commit/00efc5421aaeb21809b0478432929739a994637c", "committedDate": "2020-04-08T13:20:48Z", "message": "Merge remote-tracking branch 'origin/master' into fix-token-invalidation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "406e4ebdfb40544874b226ec8367f7b45795b074", "author": {"user": {"login": "jkakavas", "name": "Ioannis Kakavas"}}, "url": "https://github.com/elastic/elasticsearch/commit/406e4ebdfb40544874b226ec8367f7b45795b074", "committedDate": "2020-04-09T13:48:01Z", "message": "Set status codes correctly. Allow callers of  to handle the exceptions thrown"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6344a1253085b5054c5db4e0360d1f1c188b652a", "author": {"user": {"login": "jkakavas", "name": "Ioannis Kakavas"}}, "url": "https://github.com/elastic/elasticsearch/commit/6344a1253085b5054c5db4e0360d1f1c188b652a", "committedDate": "2020-04-09T14:39:40Z", "message": "Merge branch 'master' of github.com:elastic/elasticsearch into fix-token-invalidation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9e0831f7cdca8c1cfa412bc4f7cde1ed281b21e5", "author": {"user": {"login": "jkakavas", "name": "Ioannis Kakavas"}}, "url": "https://github.com/elastic/elasticsearch/commit/9e0831f7cdca8c1cfa412bc4f7cde1ed281b21e5", "committedDate": "2020-04-09T16:56:35Z", "message": "remove unnecessary field from response, add yaml test to test response codes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwOTc0OTI3", "url": "https://github.com/elastic/elasticsearch/pull/54532#pullrequestreview-390974927", "createdAt": "2020-04-09T17:05:05Z", "commit": {"oid": "9e0831f7cdca8c1cfa412bc4f7cde1ed281b21e5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxNzowNTowNVrOGDhjkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxNzowNTowNVrOGDhjkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM0ODY4OA==", "bodyText": "This was added because we couldn't trigger the index to be unavailable ( but rather only not existent ) in TokenAuthIntegTests", "url": "https://github.com/elastic/elasticsearch/pull/54532#discussion_r406348688", "createdAt": "2020-04-09T17:05:05Z", "author": {"login": "jkakavas"}, "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/action/token/TransportInvalidateTokenActionTests.java", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.action.token;\n+\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.UUIDs;\n+import org.elasticsearch.common.io.stream.OutputStreamStreamOutput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.license.XPackLicenseState;\n+import org.elasticsearch.node.Node;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.test.ClusterServiceUtils;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.threadpool.TestThreadPool;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.core.XPackSettings;\n+import org.elasticsearch.xpack.core.security.SecurityContext;\n+import org.elasticsearch.xpack.core.security.action.token.InvalidateTokenRequest;\n+import org.elasticsearch.xpack.core.security.action.token.InvalidateTokenResponse;\n+import org.elasticsearch.xpack.security.authc.AuthenticationService;\n+import org.elasticsearch.xpack.security.authc.TokenService;\n+import org.elasticsearch.xpack.security.support.SecurityIndexManager;\n+import org.junit.After;\n+import org.junit.Before;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.time.Clock;\n+import java.util.Base64;\n+import java.util.Collections;\n+\n+import static org.elasticsearch.xpack.core.security.action.token.InvalidateTokenRequest.Type.ACCESS_TOKEN;\n+import static org.elasticsearch.xpack.core.security.action.token.InvalidateTokenRequest.Type.REFRESH_TOKEN;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+public class TransportInvalidateTokenActionTests extends ESTestCase {\n+\n+    private static final Settings SETTINGS = Settings.builder().put(Node.NODE_NAME_SETTING.getKey(), \"TokenServiceTests\")\n+        .put(XPackSettings.TOKEN_SERVICE_ENABLED_SETTING.getKey(), true).build();\n+\n+    private ThreadPool threadPool;\n+    private Client client;\n+    private SecurityIndexManager securityIndex;\n+    private ClusterService clusterService;\n+    private AuthenticationService authenticationService;\n+    private XPackLicenseState license;\n+    private SecurityContext securityContext;\n+\n+    @Before\n+    public void setup() {\n+        threadPool = new TestThreadPool(getTestName());\n+        securityContext = new SecurityContext(Settings.EMPTY, threadPool.getThreadContext());\n+        client = mock(Client.class);\n+        when(client.threadPool()).thenReturn(threadPool);\n+        when(client.settings()).thenReturn(SETTINGS);\n+        securityIndex = mock(SecurityIndexManager.class);\n+        this.clusterService = ClusterServiceUtils.createClusterService(threadPool);\n+        this.license = mock(XPackLicenseState.class);\n+        when(license.isTokenServiceAllowed()).thenReturn(true);\n+    }\n+\n+    public void testInvalidateTokensWhenIndexUnavailable() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e0831f7cdca8c1cfa412bc4f7cde1ed281b21e5"}, "originalPosition": 77}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "05816fe36e538b0b2eb271103d4792a9e777ab33", "author": {"user": {"login": "jkakavas", "name": "Ioannis Kakavas"}}, "url": "https://github.com/elastic/elasticsearch/commit/05816fe36e538b0b2eb271103d4792a9e777ab33", "committedDate": "2020-04-10T10:24:54Z", "message": "complete the cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a240c8d96ef148c555d171b3f2c93ea8bbd8d5f1", "author": {"user": {"login": "jkakavas", "name": "Ioannis Kakavas"}}, "url": "https://github.com/elastic/elasticsearch/commit/a240c8d96ef148c555d171b3f2c93ea8bbd8d5f1", "committedDate": "2020-04-10T13:14:24Z", "message": "Fix test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyMTAzMjg3", "url": "https://github.com/elastic/elasticsearch/pull/54532#pullrequestreview-392103287", "createdAt": "2020-04-13T11:57:46Z", "commit": {"oid": "9e0831f7cdca8c1cfa412bc4f7cde1ed281b21e5"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxMTo1Nzo0N1rOGEkeKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNToxMzozNFrOGEpr6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzQ0NTAzMg==", "bodyText": "This is a good catch.", "url": "https://github.com/elastic/elasticsearch/pull/54532#discussion_r407445032", "createdAt": "2020-04-13T11:57:47Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/ExpiredTokenRemover.java", "diffHunk": "@@ -70,6 +70,7 @@ public void doRun() {\n             indicesWithTokens.add(securityMainIndex.aliasName());\n         }\n         if (indicesWithTokens.isEmpty()) {\n+            markComplete();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e0831f7cdca8c1cfa412bc4f7cde1ed281b21e5"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzQ2MjMxNA==", "bodyText": "This method does not seem to be used anywhere?", "url": "https://github.com/elastic/elasticsearch/pull/54532#discussion_r407462314", "createdAt": "2020-04-13T12:49:50Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/TokenService.java", "diffHunk": "@@ -1749,15 +1784,10 @@ private static ElasticsearchSecurityException expiredTokenException() {\n     }\n \n     /**\n-     * Creates an {@link ElasticsearchSecurityException} that indicates the token was malformed. It\n-     * is up to the client to re-authenticate and obtain a new token. The format for this response\n-     * is defined in <a href=\"https://tools.ietf.org/html/rfc6750#section-3.1\"></a>\n+     * Creates an {@link ElasticsearchSecurityException} that indicates that we couldn't find the token document in our tokens index\n      */\n-    private static ElasticsearchSecurityException malformedTokenException() {\n-        ElasticsearchSecurityException e =\n-                new ElasticsearchSecurityException(\"token malformed\", RestStatus.UNAUTHORIZED);\n-        e.addHeader(\"WWW-Authenticate\", MALFORMED_TOKEN_WWW_AUTH_VALUE);\n-        return e;\n+    private static ElasticsearchException tokenNotFoundException() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a240c8d96ef148c555d171b3f2c93ea8bbd8d5f1"}, "originalPosition": 315}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzQ3NzU1MA==", "bodyText": "By read the code, it seems that a closed index counts as \"unavailable\"?", "url": "https://github.com/elastic/elasticsearch/pull/54532#discussion_r407477550", "createdAt": "2020-04-13T13:27:47Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/action/token/TransportInvalidateTokenActionTests.java", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.action.token;\n+\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.UUIDs;\n+import org.elasticsearch.common.io.stream.OutputStreamStreamOutput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.license.XPackLicenseState;\n+import org.elasticsearch.node.Node;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.test.ClusterServiceUtils;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.threadpool.TestThreadPool;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.core.XPackSettings;\n+import org.elasticsearch.xpack.core.security.SecurityContext;\n+import org.elasticsearch.xpack.core.security.action.token.InvalidateTokenRequest;\n+import org.elasticsearch.xpack.core.security.action.token.InvalidateTokenResponse;\n+import org.elasticsearch.xpack.security.authc.AuthenticationService;\n+import org.elasticsearch.xpack.security.authc.TokenService;\n+import org.elasticsearch.xpack.security.support.SecurityIndexManager;\n+import org.junit.After;\n+import org.junit.Before;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.time.Clock;\n+import java.util.Base64;\n+import java.util.Collections;\n+\n+import static org.elasticsearch.xpack.core.security.action.token.InvalidateTokenRequest.Type.ACCESS_TOKEN;\n+import static org.elasticsearch.xpack.core.security.action.token.InvalidateTokenRequest.Type.REFRESH_TOKEN;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+public class TransportInvalidateTokenActionTests extends ESTestCase {\n+\n+    private static final Settings SETTINGS = Settings.builder().put(Node.NODE_NAME_SETTING.getKey(), \"TokenServiceTests\")\n+        .put(XPackSettings.TOKEN_SERVICE_ENABLED_SETTING.getKey(), true).build();\n+\n+    private ThreadPool threadPool;\n+    private Client client;\n+    private SecurityIndexManager securityIndex;\n+    private ClusterService clusterService;\n+    private AuthenticationService authenticationService;\n+    private XPackLicenseState license;\n+    private SecurityContext securityContext;\n+\n+    @Before\n+    public void setup() {\n+        threadPool = new TestThreadPool(getTestName());\n+        securityContext = new SecurityContext(Settings.EMPTY, threadPool.getThreadContext());\n+        client = mock(Client.class);\n+        when(client.threadPool()).thenReturn(threadPool);\n+        when(client.settings()).thenReturn(SETTINGS);\n+        securityIndex = mock(SecurityIndexManager.class);\n+        this.clusterService = ClusterServiceUtils.createClusterService(threadPool);\n+        this.license = mock(XPackLicenseState.class);\n+        when(license.isTokenServiceAllowed()).thenReturn(true);\n+    }\n+\n+    public void testInvalidateTokensWhenIndexUnavailable() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM0ODY4OA=="}, "originalCommit": {"oid": "9e0831f7cdca8c1cfa412bc4f7cde1ed281b21e5"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzQ4MzM1NA==", "bodyText": "\ud83d\udc4dI think it is worth to make the behaviour of deleteXxx and invalidateXxx more consistent. It seems most of them are ignoring 404, e.g. deleteUser. Not suggesting it for this PR, but we could potentially push for more consistency in future work. Currently deleteRoleMapping and invalidateApiKey are not yet with this pattern.", "url": "https://github.com/elastic/elasticsearch/pull/54532#discussion_r407483354", "createdAt": "2020-04-13T13:41:18Z", "author": {"login": "ywangd"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/SecurityClient.java", "diffHunk": "@@ -765,7 +765,7 @@ public Cancellable createTokenAsync(CreateTokenRequest request, RequestOptions o\n      */\n     public InvalidateTokenResponse invalidateToken(InvalidateTokenRequest request, RequestOptions options) throws IOException {\n         return restHighLevelClient.performRequestAndParseEntity(request, SecurityRequestConverters::invalidateToken, options,\n-            InvalidateTokenResponse::fromXContent, emptySet());\n+            InvalidateTokenResponse::fromXContent, singleton(404));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a240c8d96ef148c555d171b3f2c93ea8bbd8d5f1"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUwNTU0OQ==", "bodyText": "I am not sure what this suppose to test? It's valid base64 and we expect it to fail due to which failure?", "url": "https://github.com/elastic/elasticsearch/pull/54532#discussion_r407505549", "createdAt": "2020-04-13T14:26:08Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/src/test/resources/rest-api-spec/test/token/11_invalidation.yml", "diffHunk": "@@ -0,0 +1,143 @@\n+---\n+setup:\n+  - skip:\n+      features: headers\n+\n+  - do:\n+      cluster.health:\n+        wait_for_status: yellow\n+\n+  - do:\n+      security.put_role:\n+        name: \"admin_role\"\n+        body:  >\n+          {\n+            \"cluster\": [\"manage_security\"]\n+          }\n+\n+  - do:\n+      security.put_user:\n+        username: \"token_user\"\n+        body:  >\n+          {\n+            \"password\" : \"x-pack-test-password\",\n+            \"roles\" : [ \"admin_role\" ],\n+            \"full_name\" : \"Token User\"\n+          }\n+\n+---\n+teardown:\n+\n+  - do:\n+      security.delete_role:\n+        name: \"admin_role\"\n+        ignore: 404\n+\n+  - do:\n+      security.delete_user:\n+        username: \"token_user\"\n+        ignore: 404\n+\n+---\n+\"Test invalidate access token return statuses\":\n+\n+  - do:\n+      catch: unavailable\n+      security.invalidate_token:\n+        body:\n+          token: 46ToAxYzNUdPZWdYOFRQcWhjeHR3NWpvTmVB\n+\n+  - do:\n+      security.get_token:\n+        body:\n+          grant_type: \"password\"\n+          username: \"token_user\"\n+          password: \"x-pack-test-password\"\n+\n+  - match: { type: \"Bearer\" }\n+  - is_true: access_token\n+  - set: { access_token: token }\n+  - match: { expires_in: 1200 }\n+  - is_false: scope\n+\n+  - do:\n+      catch: missing\n+      security.invalidate_token:\n+        body:\n+          token: \"!this_is_not_a_base64_string_and_we_should_fail_decoding_it\"\n+\n+  - match: { invalidated_tokens: 0 }\n+  - match: { previously_invalidated_tokens: 0 }\n+  - match: { error_count: 0 }\n+\n+  - do:\n+      catch: missing\n+      security.invalidate_token:\n+        body:\n+          token: \"10we+might+assume+this+is+valid+old+token\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a240c8d96ef148c555d171b3f2c93ea8bbd8d5f1"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUxMjA0MA==", "bodyText": "This kinda reasonates on what we have discussed the other day around how many statements should be surrounded by a try-catch block. The IOException is only thrown by unpackVersionAndPayload() which is the first statement in this try-catch block. The intention for returning 404 when unpacking fails would be much easier to understand if unpackVersionAndPayload is the only statement surrounded by this try-catch block.", "url": "https://github.com/elastic/elasticsearch/pull/54532#discussion_r407512040", "createdAt": "2020-04-13T14:38:48Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/TokenService.java", "diffHunk": "@@ -872,7 +912,7 @@ private void findTokenFromRefreshToken(String refreshToken, Iterator<TimeValue>\n                     }\n                 } catch (IOException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a240c8d96ef148c555d171b3f2c93ea8bbd8d5f1"}, "originalPosition": 241}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUyODg2Nw==", "bodyText": "Will this change an index related error (unavailable or not exists) to an security exception (401)? Do we need a isShardNotAvailableException here?", "url": "https://github.com/elastic/elasticsearch/pull/54532#discussion_r407528867", "createdAt": "2020-04-13T15:10:31Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/TokenService.java", "diffHunk": "@@ -578,17 +597,21 @@ void decodeToken(String token, ActionListener<UserToken> listener) {\n     public void invalidateAccessToken(String accessToken, ActionListener<TokensInvalidationResult> listener) {\n         ensureEnabled();\n         if (Strings.isNullOrEmpty(accessToken)) {\n-            listener.onFailure(traceLog(\"no access token provided\", new IllegalArgumentException(\"access token must be provided\")));\n+            listener.onFailure(traceLog(\"invalidate access token\", new IllegalArgumentException(\"access token must be provided\")));\n         } else {\n+            logger.debug(\"INVALIDATE ACCESS TOKEN\");\n             maybeStartTokenRemover();\n             final Iterator<TimeValue> backoff = DEFAULT_BACKOFF.iterator();\n             decodeToken(accessToken, ActionListener.wrap(userToken -> {\n                 if (userToken == null) {\n-                    listener.onFailure(traceLog(\"invalidate token\", accessToken, malformedTokenException()));\n+                    // The chances of a random token string decoding to something that we can read is minimal, so\n+                    // we assume that this was a token we have created but is now expired/revoked and deleted\n+                    logger.trace(\"The access token [{}] is expired and already deleted\", accessToken);\n+                    listener.onResponse(TokensInvalidationResult.emptyResult(RestStatus.NOT_FOUND));\n                 } else {\n                     indexInvalidation(Collections.singleton(userToken), backoff, \"access_token\", null, listener);\n                 }\n-            }, listener::onFailure));\n+            }, e -> listener.onFailure(unableToPerformAction(e))));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a240c8d96ef148c555d171b3f2c93ea8bbd8d5f1"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUzMDQ3NQ==", "bodyText": "Is this going to cause a NPE down the line, e.g. https://github.com/elastic/elasticsearch/blob/7.6/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/action/saml/TransportSamlLogoutAction.java#L57", "url": "https://github.com/elastic/elasticsearch/pull/54532#discussion_r407530475", "createdAt": "2020-04-13T15:13:34Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/TokenService.java", "diffHunk": "@@ -431,14 +444,20 @@ public void authenticateToken(SecureString tokenString, ActionListener<Authentic\n      */\n     public void getAuthenticationAndMetadata(String token, ActionListener<Tuple<Authentication, Map<String, Object>>> listener) {\n         decodeToken(token, ActionListener.wrap(\n-                userToken -> {\n-                    if (userToken == null) {\n-                        listener.onFailure(new ElasticsearchSecurityException(\"supplied token is not valid\"));\n-                    } else {\n-                        listener.onResponse(new Tuple<>(userToken.getAuthentication(), userToken.getMetadata()));\n-                    }\n-                },\n-                listener::onFailure\n+            userToken -> {\n+                if (userToken == null) {\n+                    listener.onFailure(new ElasticsearchSecurityException(\"supplied token is not valid\"));\n+                } else {\n+                    listener.onResponse(new Tuple<>(userToken.getAuthentication(), userToken.getMetadata()));\n+                }\n+            },\n+            e -> {\n+                if (isShardNotAvailableException(e)) {\n+                    listener.onResponse(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a240c8d96ef148c555d171b3f2c93ea8bbd8d5f1"}, "originalPosition": 68}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa3075adfb0a89464feb408249abde34be5c2fe8", "author": {"user": {"login": "jkakavas", "name": "Ioannis Kakavas"}}, "url": "https://github.com/elastic/elasticsearch/commit/fa3075adfb0a89464feb408249abde34be5c2fe8", "committedDate": "2020-04-14T09:05:42Z", "message": "address feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "33778d6b751326433b5c61e7edb54e100ca946bf", "author": {"user": {"login": "elasticmachine", "name": "Elastic Machine"}}, "url": "https://github.com/elastic/elasticsearch/commit/33778d6b751326433b5c61e7edb54e100ca946bf", "committedDate": "2020-04-14T09:45:23Z", "message": "Merge branch 'master' into fix-token-invalidation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzNjEwMzY1", "url": "https://github.com/elastic/elasticsearch/pull/54532#pullrequestreview-393610365", "createdAt": "2020-04-15T09:33:52Z", "commit": {"oid": "33778d6b751326433b5c61e7edb54e100ca946bf"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwOTozMzo1MlrOGFxm3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwOTozMzo1MlrOGFxm3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcwODgzMA==", "bodyText": "I think you should you the securityIndexManager.freeze() pattern here.", "url": "https://github.com/elastic/elasticsearch/pull/54532#discussion_r408708830", "createdAt": "2020-04-15T09:33:52Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/TokenService.java", "diffHunk": "@@ -450,7 +463,7 @@ private void getUserTokenFromId(String userTokenId, Version tokenVersion, Action\n         final SecurityIndexManager tokensIndex = getTokensIndexForVersion(tokenVersion);\n         if (tokensIndex.isAvailable() == false) {\n             logger.warn(\"failed to get access token [{}] because index [{}] is not available\", userTokenId, tokensIndex.aliasName());\n-            listener.onResponse(null);\n+            listener.onFailure(tokensIndex.getUnavailableReason());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33778d6b751326433b5c61e7edb54e100ca946bf"}, "originalPosition": 75}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2ba228bc8e54f149becbcad518e2fef1c392b2df", "author": {"user": {"login": "jkakavas", "name": "Ioannis Kakavas"}}, "url": "https://github.com/elastic/elasticsearch/commit/2ba228bc8e54f149becbcad518e2fef1c392b2df", "committedDate": "2020-04-15T10:07:04Z", "message": "address feedback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzNjc4NzM4", "url": "https://github.com/elastic/elasticsearch/pull/54532#pullrequestreview-393678738", "createdAt": "2020-04-15T11:16:19Z", "commit": {"oid": "2ba228bc8e54f149becbcad518e2fef1c392b2df"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxMToxNjoyMFrOGF1CvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxMToxNjoyMFrOGF1CvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc2NTExNw==", "bodyText": "Is it worthwhile to test \"unavailable\" index in TokenAuthIntegTests by closing the token index before invalidation?", "url": "https://github.com/elastic/elasticsearch/pull/54532#discussion_r408765117", "createdAt": "2020-04-15T11:16:20Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/action/token/TransportInvalidateTokenActionTests.java", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.action.token;\n+\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.UUIDs;\n+import org.elasticsearch.common.io.stream.OutputStreamStreamOutput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.license.XPackLicenseState;\n+import org.elasticsearch.node.Node;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.test.ClusterServiceUtils;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.threadpool.TestThreadPool;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.core.XPackSettings;\n+import org.elasticsearch.xpack.core.security.SecurityContext;\n+import org.elasticsearch.xpack.core.security.action.token.InvalidateTokenRequest;\n+import org.elasticsearch.xpack.core.security.action.token.InvalidateTokenResponse;\n+import org.elasticsearch.xpack.security.authc.AuthenticationService;\n+import org.elasticsearch.xpack.security.authc.TokenService;\n+import org.elasticsearch.xpack.security.support.SecurityIndexManager;\n+import org.junit.After;\n+import org.junit.Before;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.time.Clock;\n+import java.util.Base64;\n+import java.util.Collections;\n+\n+import static org.elasticsearch.xpack.core.security.action.token.InvalidateTokenRequest.Type.ACCESS_TOKEN;\n+import static org.elasticsearch.xpack.core.security.action.token.InvalidateTokenRequest.Type.REFRESH_TOKEN;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+public class TransportInvalidateTokenActionTests extends ESTestCase {\n+\n+    private static final Settings SETTINGS = Settings.builder().put(Node.NODE_NAME_SETTING.getKey(), \"TokenServiceTests\")\n+        .put(XPackSettings.TOKEN_SERVICE_ENABLED_SETTING.getKey(), true).build();\n+\n+    private ThreadPool threadPool;\n+    private Client client;\n+    private SecurityIndexManager securityIndex;\n+    private ClusterService clusterService;\n+    private AuthenticationService authenticationService;\n+    private XPackLicenseState license;\n+    private SecurityContext securityContext;\n+\n+    @Before\n+    public void setup() {\n+        threadPool = new TestThreadPool(getTestName());\n+        securityContext = new SecurityContext(Settings.EMPTY, threadPool.getThreadContext());\n+        client = mock(Client.class);\n+        when(client.threadPool()).thenReturn(threadPool);\n+        when(client.settings()).thenReturn(SETTINGS);\n+        securityIndex = mock(SecurityIndexManager.class);\n+        this.clusterService = ClusterServiceUtils.createClusterService(threadPool);\n+        this.license = mock(XPackLicenseState.class);\n+        when(license.isTokenServiceAllowed()).thenReturn(true);\n+    }\n+\n+    public void testInvalidateTokensWhenIndexUnavailable() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM0ODY4OA=="}, "originalCommit": {"oid": "9e0831f7cdca8c1cfa412bc4f7cde1ed281b21e5"}, "originalPosition": 77}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "84b6296d473b3ca44738d2d740a892a3b124a2e0", "author": {"user": {"login": "jkakavas", "name": "Ioannis Kakavas"}}, "url": "https://github.com/elastic/elasticsearch/commit/84b6296d473b3ca44738d2d740a892a3b124a2e0", "committedDate": "2020-04-15T12:04:08Z", "message": "Fix mocks to support SecurityIndexManager#freeze"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c78cb21fb1873a4d7da5b156cab7e8e046038257", "author": {"user": {"login": "jkakavas", "name": "Ioannis Kakavas"}}, "url": "https://github.com/elastic/elasticsearch/commit/c78cb21fb1873a4d7da5b156cab7e8e046038257", "committedDate": "2020-04-15T13:10:04Z", "message": "Differentiate between index closed/not-existent and unavailable"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzNzY3MDM3", "url": "https://github.com/elastic/elasticsearch/pull/54532#pullrequestreview-393767037", "createdAt": "2020-04-15T13:22:27Z", "commit": {"oid": "c78cb21fb1873a4d7da5b156cab7e8e046038257"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxMzoyMjoyN1rOGF5Zmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxMzoyMjoyN1rOGF5Zmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODgzNjUwNg==", "bodyText": "I'd prefer to have the new logic encapsulated inside unableToPerformAction(e). Otherwise it looks good.", "url": "https://github.com/elastic/elasticsearch/pull/54532#discussion_r408836506", "createdAt": "2020-04-15T13:22:27Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/TokenService.java", "diffHunk": "@@ -578,17 +594,26 @@ void decodeToken(String token, ActionListener<UserToken> listener) {\n     public void invalidateAccessToken(String accessToken, ActionListener<TokensInvalidationResult> listener) {\n         ensureEnabled();\n         if (Strings.isNullOrEmpty(accessToken)) {\n-            listener.onFailure(traceLog(\"no access token provided\", new IllegalArgumentException(\"access token must be provided\")));\n+            listener.onFailure(traceLog(\"invalidate access token\", new IllegalArgumentException(\"access token must be provided\")));\n         } else {\n             maybeStartTokenRemover();\n             final Iterator<TimeValue> backoff = DEFAULT_BACKOFF.iterator();\n             decodeToken(accessToken, ActionListener.wrap(userToken -> {\n                 if (userToken == null) {\n-                    listener.onFailure(traceLog(\"invalidate token\", accessToken, malformedTokenException()));\n+                    // The chances of a random token string decoding to something that we can read is minimal, so\n+                    // we assume that this was a token we have created but is now expired/revoked and deleted\n+                    logger.trace(\"The access token [{}] is expired and already deleted\", accessToken);\n+                    listener.onResponse(TokensInvalidationResult.emptyResult(RestStatus.NOT_FOUND));\n                 } else {\n                     indexInvalidation(Collections.singleton(userToken), backoff, \"access_token\", null, listener);\n                 }\n-            }, listener::onFailure));\n+            }, e -> {\n+                if (e instanceof IndexNotFoundException || e instanceof IndexClosedException) {\n+                    listener.onFailure(new ElasticsearchSecurityException(\"failed to invalidate token\", RestStatus.BAD_REQUEST));\n+                } else {\n+                    listener.onFailure(unableToPerformAction(e));\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c78cb21fb1873a4d7da5b156cab7e8e046038257"}, "originalPosition": 152}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1421, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}