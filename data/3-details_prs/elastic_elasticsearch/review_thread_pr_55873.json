{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEwMjI5MDg5", "number": 55873, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNjozMToxNVrOD3R9Rw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMDowMjozNVrOD5jvPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5MjkyNDg3OnYy", "diffSide": "RIGHT", "path": "docs/reference/search/profile.asciidoc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNjozMToxNVrOGNcwrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNTo1MzowMVrOGOFjlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc1NTg4Ng==", "bodyText": "I had to add these lines so I took the opportunity to update the values above with results from my test.", "url": "https://github.com/elastic/elasticsearch/pull/55873#discussion_r416755886", "createdAt": "2020-04-28T16:31:15Z", "author": {"login": "nik9000"}, "path": "docs/reference/search/profile.asciidoc", "diffHunk": "@@ -784,46 +784,52 @@ This yields the following aggregation profile output:\n           {\n             \"type\" : \"LongTermsAggregator\",\n             \"description\" : \"my_scoped_agg\",\n-            \"time_in_nanos\" : 195386,\n+            \"time_in_nanos\" : 195421,\n             \"breakdown\" : {\n               \"reduce\" : 0,\n-              \"build_aggregation\" : 81171,\n+              \"build_aggregation\" : 80927,\n               \"build_aggregation_count\" : 1,\n-              \"initialize\" : 22753,\n+              \"initialize\" : 3619,\n               \"initialize_count\" : 1,\n               \"reduce_count\" : 0,\n-              \"collect\" : 91456,\n-              \"collect_count\" : 4\n+              \"collect\" : 109778,\n+              \"collect_count\" : 4,\n+              \"run_deferred_collections\" : 1090,\n+              \"run_deferred_collections_count\" : 1", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45d04b2cd00c5798a24162ef4913d9dccb6ebe8c"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQyNDI3Ng==", "bodyText": "That looks like a useful addition, thanks!", "url": "https://github.com/elastic/elasticsearch/pull/55873#discussion_r417424276", "createdAt": "2020-04-29T15:53:01Z", "author": {"login": "jimczi"}, "path": "docs/reference/search/profile.asciidoc", "diffHunk": "@@ -784,46 +784,52 @@ This yields the following aggregation profile output:\n           {\n             \"type\" : \"LongTermsAggregator\",\n             \"description\" : \"my_scoped_agg\",\n-            \"time_in_nanos\" : 195386,\n+            \"time_in_nanos\" : 195421,\n             \"breakdown\" : {\n               \"reduce\" : 0,\n-              \"build_aggregation\" : 81171,\n+              \"build_aggregation\" : 80927,\n               \"build_aggregation_count\" : 1,\n-              \"initialize\" : 22753,\n+              \"initialize\" : 3619,\n               \"initialize_count\" : 1,\n               \"reduce_count\" : 0,\n-              \"collect\" : 91456,\n-              \"collect_count\" : 4\n+              \"collect\" : 109778,\n+              \"collect_count\" : 4,\n+              \"run_deferred_collections\" : 1090,\n+              \"run_deferred_collections_count\" : 1", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc1NTg4Ng=="}, "originalCommit": {"oid": "45d04b2cd00c5798a24162ef4913d9dccb6ebe8c"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NzIzNjUyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/aggregations/Aggregator.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNTo1Mzo0M1rOGOFlaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxMjozNzoxNFrOGRQ6Rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQyNDc0Nw==", "bodyText": "Can you add a comment regarding what the returned boolean means ?", "url": "https://github.com/elastic/elasticsearch/pull/55873#discussion_r417424747", "createdAt": "2020-04-29T15:53:43Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/Aggregator.java", "diffHunk": "@@ -152,15 +152,53 @@ public BucketComparator bucketComparator(String key, SortOrder order) {\n     }\n \n     /**\n-     * Build an aggregation for data that has been collected into {@code bucket}.\n+     * Build an aggregation for data that has been collected into\n+     * {@code owningBucketOrd}.\n+     * <p>\n+     * Bucketing aggregations sometimes delay collecting their results if they\n+     * are selective (like {@code terms}) or if they aren't sure which buckets\n+     * their documents will ultimately fall into\n+     * (like {@code auto_date_histogram}). If they do so then anything they\n+     * return from this method can't be trusted. To turn them into \"real\"\n+     * results you have to make all of the calls to this method that you\n+     * will ever make, then call {@link #runDeferredCollections()}. If that\n+     * returns {@code true} then every aggregation will need to be rewritten\n+     * with {@code InternalAggregation#undefer()}. This entire dance is\n+     * generally accomplished by calling {@link #buildTopLevel()} on each top\n+     * level aggregator. \n      */\n-    public abstract InternalAggregation buildAggregation(long bucket) throws IOException;\n+    public abstract InternalAggregation buildAggregation(long owningBucketOrd) throws IOException;\n+\n+    /**\n+     * Build the result of this aggregation if it is on top level of the\n+     * aggregation tree, properly handling deferred collections. It is only\n+     * correct to call this on aggregations that <strong>are</strong> at the\n+     * top level of the aggregation tree. Calling it for other aggregations\n+     * will trip assertions or return the wrong result. Those aggregtions will\n+     * have {@link #buildAggregation(long)}, {@link #runDeferredCollections()}\n+     * and {@link InternalAggregation#undefer()} called by their parent\n+     * aggregations. \n+     */\n+    public final InternalAggregation buildTopLevel() throws IOException {\n+        assert parent() == null;\n+        InternalAggregation result = buildAggregation(0);\n+        if (runDeferredCollections()) {\n+            return result.undefer();\n+        }\n+        return result;\n+    }\n \n     /**\n      * Build an empty aggregation.\n      */\n     public abstract InternalAggregation buildEmptyAggregation();\n \n+    /**\n+     * Run any deferred collections that are required to\n+     * {@link InternalAggregation#undefer()} this aggregations's results.\n+     */\n+    public abstract boolean runDeferredCollections() throws IOException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9dbbfbf95cf342f565fabb3c78f6eae6b954dc7d"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQwODQ1Nw==", "bodyText": "++", "url": "https://github.com/elastic/elasticsearch/pull/55873#discussion_r420408457", "createdAt": "2020-05-05T21:10:28Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/Aggregator.java", "diffHunk": "@@ -152,15 +152,53 @@ public BucketComparator bucketComparator(String key, SortOrder order) {\n     }\n \n     /**\n-     * Build an aggregation for data that has been collected into {@code bucket}.\n+     * Build an aggregation for data that has been collected into\n+     * {@code owningBucketOrd}.\n+     * <p>\n+     * Bucketing aggregations sometimes delay collecting their results if they\n+     * are selective (like {@code terms}) or if they aren't sure which buckets\n+     * their documents will ultimately fall into\n+     * (like {@code auto_date_histogram}). If they do so then anything they\n+     * return from this method can't be trusted. To turn them into \"real\"\n+     * results you have to make all of the calls to this method that you\n+     * will ever make, then call {@link #runDeferredCollections()}. If that\n+     * returns {@code true} then every aggregation will need to be rewritten\n+     * with {@code InternalAggregation#undefer()}. This entire dance is\n+     * generally accomplished by calling {@link #buildTopLevel()} on each top\n+     * level aggregator. \n      */\n-    public abstract InternalAggregation buildAggregation(long bucket) throws IOException;\n+    public abstract InternalAggregation buildAggregation(long owningBucketOrd) throws IOException;\n+\n+    /**\n+     * Build the result of this aggregation if it is on top level of the\n+     * aggregation tree, properly handling deferred collections. It is only\n+     * correct to call this on aggregations that <strong>are</strong> at the\n+     * top level of the aggregation tree. Calling it for other aggregations\n+     * will trip assertions or return the wrong result. Those aggregtions will\n+     * have {@link #buildAggregation(long)}, {@link #runDeferredCollections()}\n+     * and {@link InternalAggregation#undefer()} called by their parent\n+     * aggregations. \n+     */\n+    public final InternalAggregation buildTopLevel() throws IOException {\n+        assert parent() == null;\n+        InternalAggregation result = buildAggregation(0);\n+        if (runDeferredCollections()) {\n+            return result.undefer();\n+        }\n+        return result;\n+    }\n \n     /**\n      * Build an empty aggregation.\n      */\n     public abstract InternalAggregation buildEmptyAggregation();\n \n+    /**\n+     * Run any deferred collections that are required to\n+     * {@link InternalAggregation#undefer()} this aggregations's results.\n+     */\n+    public abstract boolean runDeferredCollections() throws IOException;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQyNDc0Nw=="}, "originalCommit": {"oid": "9dbbfbf95cf342f565fabb3c78f6eae6b954dc7d"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDc1NjAzOA==", "bodyText": "It turns out that this isn't needed any more. I've blasted it.", "url": "https://github.com/elastic/elasticsearch/pull/55873#discussion_r420756038", "createdAt": "2020-05-06T12:37:14Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/Aggregator.java", "diffHunk": "@@ -152,15 +152,53 @@ public BucketComparator bucketComparator(String key, SortOrder order) {\n     }\n \n     /**\n-     * Build an aggregation for data that has been collected into {@code bucket}.\n+     * Build an aggregation for data that has been collected into\n+     * {@code owningBucketOrd}.\n+     * <p>\n+     * Bucketing aggregations sometimes delay collecting their results if they\n+     * are selective (like {@code terms}) or if they aren't sure which buckets\n+     * their documents will ultimately fall into\n+     * (like {@code auto_date_histogram}). If they do so then anything they\n+     * return from this method can't be trusted. To turn them into \"real\"\n+     * results you have to make all of the calls to this method that you\n+     * will ever make, then call {@link #runDeferredCollections()}. If that\n+     * returns {@code true} then every aggregation will need to be rewritten\n+     * with {@code InternalAggregation#undefer()}. This entire dance is\n+     * generally accomplished by calling {@link #buildTopLevel()} on each top\n+     * level aggregator. \n      */\n-    public abstract InternalAggregation buildAggregation(long bucket) throws IOException;\n+    public abstract InternalAggregation buildAggregation(long owningBucketOrd) throws IOException;\n+\n+    /**\n+     * Build the result of this aggregation if it is on top level of the\n+     * aggregation tree, properly handling deferred collections. It is only\n+     * correct to call this on aggregations that <strong>are</strong> at the\n+     * top level of the aggregation tree. Calling it for other aggregations\n+     * will trip assertions or return the wrong result. Those aggregtions will\n+     * have {@link #buildAggregation(long)}, {@link #runDeferredCollections()}\n+     * and {@link InternalAggregation#undefer()} called by their parent\n+     * aggregations. \n+     */\n+    public final InternalAggregation buildTopLevel() throws IOException {\n+        assert parent() == null;\n+        InternalAggregation result = buildAggregation(0);\n+        if (runDeferredCollections()) {\n+            return result.undefer();\n+        }\n+        return result;\n+    }\n \n     /**\n      * Build an empty aggregation.\n      */\n     public abstract InternalAggregation buildEmptyAggregation();\n \n+    /**\n+     * Run any deferred collections that are required to\n+     * {@link InternalAggregation#undefer()} this aggregations's results.\n+     */\n+    public abstract boolean runDeferredCollections() throws IOException;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQyNDc0Nw=="}, "originalCommit": {"oid": "9dbbfbf95cf342f565fabb3c78f6eae6b954dc7d"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMjQ3NTg5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/aggregations/InternalMultiBucketAggregation.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQyMDoxNjo1NFrOGO4yYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQyMDoxNjo1NFrOGO4yYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI2MzY0OQ==", "bodyText": "I can revert this.", "url": "https://github.com/elastic/elasticsearch/pull/55873#discussion_r418263649", "createdAt": "2020-04-30T20:16:54Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/InternalMultiBucketAggregation.java", "diffHunk": "@@ -158,19 +158,27 @@ public final InternalAggregation reducePipelines(\n \n     @Override\n     public InternalAggregation copyWithRewritenBuckets(Function<InternalAggregations, InternalAggregations> rewriter) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f5ed9d33fc64d647e42904b17984578f0449dfb"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwODc5Nzc4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/BucketsAggregator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wM1QxNzoyNDo1MFrOGPt47Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wM1QxNzoyNToxMFrOGPt5Ew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTEzMzY3Nw==", "bodyText": "This was missing from some work that I did previously and removing the wrapping of LongTermsAggregator revealed it.", "url": "https://github.com/elastic/elasticsearch/pull/55873#discussion_r419133677", "createdAt": "2020-05-03T17:24:50Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/BucketsAggregator.java", "diffHunk": "@@ -174,6 +373,9 @@ public Aggregator resolveSortPath(AggregationPath.PathElement next, Iterator<Agg\n \n     @Override\n     public BucketComparator bucketComparator(String key, SortOrder order) {\n+        if (false == this instanceof SingleBucketAggregator) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e064c4c16850ffcb2fd86d6ab493de2ace7e6bf6"}, "originalPosition": 244}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTEzMzcxNQ==", "bodyText": "Without this we get strange test failures around sorting.", "url": "https://github.com/elastic/elasticsearch/pull/55873#discussion_r419133715", "createdAt": "2020-05-03T17:25:10Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/BucketsAggregator.java", "diffHunk": "@@ -174,6 +373,9 @@ public Aggregator resolveSortPath(AggregationPath.PathElement next, Iterator<Agg\n \n     @Override\n     public BucketComparator bucketComparator(String key, SortOrder order) {\n+        if (false == this instanceof SingleBucketAggregator) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTEzMzY3Nw=="}, "originalCommit": {"oid": "e064c4c16850ffcb2fd86d6ab493de2ace7e6bf6"}, "originalPosition": 244}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNjgwMTcxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/aggregations/AggregationPhase.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMDowMDoxMlrOGQ5Zyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMToxMTozNFrOGQ7ujQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM3MDg5MA==", "bodyText": "Can we use aggregator.buildTopLevel() ?", "url": "https://github.com/elastic/elasticsearch/pull/55873#discussion_r420370890", "createdAt": "2020-05-05T20:00:12Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/AggregationPhase.java", "diffHunk": "@@ -125,7 +125,7 @@ public void execute(SearchContext context) {\n         for (Aggregator aggregator : context.aggregations().aggregators()) {\n             try {\n                 aggregator.postCollection();\n-                aggregations.add(aggregator.buildAggregation(0));\n+                aggregations.add(aggregator.buildAggregations(new long[] {0})[0]);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e872b238774841974ccacbc7002e77422b869a90"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQwODk3Mw==", "bodyText": "++", "url": "https://github.com/elastic/elasticsearch/pull/55873#discussion_r420408973", "createdAt": "2020-05-05T21:11:34Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/AggregationPhase.java", "diffHunk": "@@ -125,7 +125,7 @@ public void execute(SearchContext context) {\n         for (Aggregator aggregator : context.aggregations().aggregators()) {\n             try {\n                 aggregator.postCollection();\n-                aggregations.add(aggregator.buildAggregation(0));\n+                aggregations.add(aggregator.buildAggregations(new long[] {0})[0]);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM3MDg5MA=="}, "originalCommit": {"oid": "e872b238774841974ccacbc7002e77422b869a90"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNjgwOTU3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/aggregations/Aggregator.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMDowMjozNVrOGQ5evA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQyMTo0MToxNFrOGRmeYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM3MjE1Ng==", "bodyText": "I think we should do this on the same pr, otherwise we should add a no-release tag so that we don't forget to do it before a release.", "url": "https://github.com/elastic/elasticsearch/pull/55873#discussion_r420372156", "createdAt": "2020-05-05T20:02:35Z", "author": {"login": "jimczi"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/Aggregator.java", "diffHunk": "@@ -152,9 +152,43 @@ public BucketComparator bucketComparator(String key, SortOrder order) {\n     }\n \n     /**\n-     * Build an aggregation for data that has been collected into {@code bucket}.\n+     * Build an aggregation for data that has been collected into\n+     * {@code owningBucketOrd}.\n+     * @deprecated use {@link #buildAggregations(long[])} instead \n      */\n-    public abstract InternalAggregation buildAggregation(long bucket) throws IOException;\n+    @Deprecated\n+    public InternalAggregation buildAggregation(long owningBucketOrd) throws IOException {\n+        /*\n+         * Temporarily check if it looks like we're being called from a test\n+         * and try to answer with the top level agg. This just prevents us from\n+         * having to modify 1231234134124 tests in one PR.\n+         */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e872b238774841974ccacbc7002e77422b869a90"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ2OTIxNA==", "bodyText": "I agree here. I don't think the change to calling buildTopLevel() in all the tests will be too distracting", "url": "https://github.com/elastic/elasticsearch/pull/55873#discussion_r420469214", "createdAt": "2020-05-05T23:35:24Z", "author": {"login": "talevy"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/Aggregator.java", "diffHunk": "@@ -152,9 +152,43 @@ public BucketComparator bucketComparator(String key, SortOrder order) {\n     }\n \n     /**\n-     * Build an aggregation for data that has been collected into {@code bucket}.\n+     * Build an aggregation for data that has been collected into\n+     * {@code owningBucketOrd}.\n+     * @deprecated use {@link #buildAggregations(long[])} instead \n      */\n-    public abstract InternalAggregation buildAggregation(long bucket) throws IOException;\n+    @Deprecated\n+    public InternalAggregation buildAggregation(long owningBucketOrd) throws IOException {\n+        /*\n+         * Temporarily check if it looks like we're being called from a test\n+         * and try to answer with the top level agg. This just prevents us from\n+         * having to modify 1231234134124 tests in one PR.\n+         */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM3MjE1Ng=="}, "originalCommit": {"oid": "e872b238774841974ccacbc7002e77422b869a90"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ3OTQ3Nw==", "bodyText": "", "url": "https://github.com/elastic/elasticsearch/pull/55873#discussion_r420479477", "createdAt": "2020-05-06T00:09:16Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/Aggregator.java", "diffHunk": "@@ -152,9 +152,43 @@ public BucketComparator bucketComparator(String key, SortOrder order) {\n     }\n \n     /**\n-     * Build an aggregation for data that has been collected into {@code bucket}.\n+     * Build an aggregation for data that has been collected into\n+     * {@code owningBucketOrd}.\n+     * @deprecated use {@link #buildAggregations(long[])} instead \n      */\n-    public abstract InternalAggregation buildAggregation(long bucket) throws IOException;\n+    @Deprecated\n+    public InternalAggregation buildAggregation(long owningBucketOrd) throws IOException {\n+        /*\n+         * Temporarily check if it looks like we're being called from a test\n+         * and try to answer with the top level agg. This just prevents us from\n+         * having to modify 1231234134124 tests in one PR.\n+         */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM3MjE1Ng=="}, "originalCommit": {"oid": "e872b238774841974ccacbc7002e77422b869a90"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTEwOTM0NQ==", "bodyText": "It was only about 40 places! I thought there were a couple hundred. Easy!", "url": "https://github.com/elastic/elasticsearch/pull/55873#discussion_r421109345", "createdAt": "2020-05-06T21:41:14Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/Aggregator.java", "diffHunk": "@@ -152,9 +152,43 @@ public BucketComparator bucketComparator(String key, SortOrder order) {\n     }\n \n     /**\n-     * Build an aggregation for data that has been collected into {@code bucket}.\n+     * Build an aggregation for data that has been collected into\n+     * {@code owningBucketOrd}.\n+     * @deprecated use {@link #buildAggregations(long[])} instead \n      */\n-    public abstract InternalAggregation buildAggregation(long bucket) throws IOException;\n+    @Deprecated\n+    public InternalAggregation buildAggregation(long owningBucketOrd) throws IOException {\n+        /*\n+         * Temporarily check if it looks like we're being called from a test\n+         * and try to answer with the top level agg. This just prevents us from\n+         * having to modify 1231234134124 tests in one PR.\n+         */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM3MjE1Ng=="}, "originalCommit": {"oid": "e872b238774841974ccacbc7002e77422b869a90"}, "originalPosition": 16}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2655, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}