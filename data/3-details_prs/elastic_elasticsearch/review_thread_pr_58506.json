{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM5MzE5NjE1", "number": 58506, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNzowNTowMlrOEKMcFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNzoxNjoxMlrOEKMuVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MTI1MDEyOnYy", "diffSide": "RIGHT", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/AExpression.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNzowNTowMlrOGrGKHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNzo1NDo0NFrOGrIEwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg0Mjg0Nw==", "bodyText": "Why is this inappropriate?", "url": "https://github.com/elastic/elasticsearch/pull/58506#discussion_r447842847", "createdAt": "2020-06-30T17:05:02Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/AExpression.java", "diffHunk": "@@ -105,36 +49,51 @@\n     /**\n      * Standard constructor with location used for error tracking.\n      */\n-    AExpression(int indentifier, Location location) {\n-        super(indentifier, location);\n+    AExpression(int identifier, Location location) {\n+        super(identifier, location);\n     }\n \n     /**\n      * Checks for errors and collects data for the writing phase.\n      */\n-    Output analyze(ClassNode classNode, SemanticScope semanticScope, Input input) {\n+    Output analyze(ClassNode classNode, SemanticScope semanticScope) {\n         throw new UnsupportedOperationException();\n     }\n \n     /**\n      * Checks for errors and collects data for the writing phase. Adds additional, common\n      * error checking for conditions related to static types and partially constructed static types.\n      */\n-    static Output analyze(AExpression expression, ClassNode classNode, SemanticScope semanticScope, Input input) {\n-        Output output = expression.analyze(classNode, semanticScope, input);\n+    static Output analyze(AExpression expression, ClassNode classNode, SemanticScope semanticScope) {\n+        Output output = expression.analyze(classNode, semanticScope);\n+\n+        if (semanticScope.hasDecoration(expression, PartialCanonicalTypeName.class)) {\n+            throw expression.createError(new IllegalArgumentException(\"cannot resolve symbol \" +\n+                    \"[\" + semanticScope.getDecoration(expression, PartialCanonicalTypeName.class).getPartialCanonicalTypeName() + \"]\"));\n+        }\n \n-        if (output.partialCanonicalTypeName != null) {\n-            throw expression.createError(new IllegalArgumentException(\"cannot resolve symbol [\" + output.partialCanonicalTypeName + \"]\"));\n+        if (semanticScope.hasDecoration(expression, StaticType.class)) {\n+            throw expression.createError(new IllegalArgumentException(\"value required: instead found unexpected type \" +\n+                    \"[\" + semanticScope.getDecoration(expression, StaticType.class).getStaticCanonicalTypeName() + \"]\"));\n         }\n \n-        if (output.isStaticType) {\n-            throw expression.createError(new IllegalArgumentException(\"value required: \" +\n-                    \"instead found unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(output.actual) + \"]\"));\n+        if (semanticScope.hasDecoration(expression, ValueType.class) == false) {\n+            throw expression.createError(new IllegalStateException(\"value required: instead found no value\"));\n         }\n \n         return output;\n     }\n \n+    // TODO: move this somewhere more appropriate", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f8c2d58c882d0b8f9296fe60302dc41df25f4c4"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg3NDI0MQ==", "bodyText": "This will be moved in a future PR because the whole point of this is to decouple the decorations from anything in the user tree. This violates that principle for now.", "url": "https://github.com/elastic/elasticsearch/pull/58506#discussion_r447874241", "createdAt": "2020-06-30T17:54:44Z", "author": {"login": "jdconrad"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/AExpression.java", "diffHunk": "@@ -105,36 +49,51 @@\n     /**\n      * Standard constructor with location used for error tracking.\n      */\n-    AExpression(int indentifier, Location location) {\n-        super(indentifier, location);\n+    AExpression(int identifier, Location location) {\n+        super(identifier, location);\n     }\n \n     /**\n      * Checks for errors and collects data for the writing phase.\n      */\n-    Output analyze(ClassNode classNode, SemanticScope semanticScope, Input input) {\n+    Output analyze(ClassNode classNode, SemanticScope semanticScope) {\n         throw new UnsupportedOperationException();\n     }\n \n     /**\n      * Checks for errors and collects data for the writing phase. Adds additional, common\n      * error checking for conditions related to static types and partially constructed static types.\n      */\n-    static Output analyze(AExpression expression, ClassNode classNode, SemanticScope semanticScope, Input input) {\n-        Output output = expression.analyze(classNode, semanticScope, input);\n+    static Output analyze(AExpression expression, ClassNode classNode, SemanticScope semanticScope) {\n+        Output output = expression.analyze(classNode, semanticScope);\n+\n+        if (semanticScope.hasDecoration(expression, PartialCanonicalTypeName.class)) {\n+            throw expression.createError(new IllegalArgumentException(\"cannot resolve symbol \" +\n+                    \"[\" + semanticScope.getDecoration(expression, PartialCanonicalTypeName.class).getPartialCanonicalTypeName() + \"]\"));\n+        }\n \n-        if (output.partialCanonicalTypeName != null) {\n-            throw expression.createError(new IllegalArgumentException(\"cannot resolve symbol [\" + output.partialCanonicalTypeName + \"]\"));\n+        if (semanticScope.hasDecoration(expression, StaticType.class)) {\n+            throw expression.createError(new IllegalArgumentException(\"value required: instead found unexpected type \" +\n+                    \"[\" + semanticScope.getDecoration(expression, StaticType.class).getStaticCanonicalTypeName() + \"]\"));\n         }\n \n-        if (output.isStaticType) {\n-            throw expression.createError(new IllegalArgumentException(\"value required: \" +\n-                    \"instead found unexpected type [\" + PainlessLookupUtility.typeToCanonicalTypeName(output.actual) + \"]\"));\n+        if (semanticScope.hasDecoration(expression, ValueType.class) == false) {\n+            throw expression.createError(new IllegalStateException(\"value required: instead found no value\"));\n         }\n \n         return output;\n     }\n \n+    // TODO: move this somewhere more appropriate", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg0Mjg0Nw=="}, "originalCommit": {"oid": "6f8c2d58c882d0b8f9296fe60302dc41df25f4c4"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MTI5NTkyOnYy", "diffSide": "RIGHT", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EConditional.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNzoxNTo1NlrOGrGlvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxODowMzoyNVrOGrIZVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg0OTkxOA==", "bodyText": "Consider renaming this to \"true clause\" or something more evocative.", "url": "https://github.com/elastic/elasticsearch/pull/58506#discussion_r447849918", "createdAt": "2020-06-30T17:15:56Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EConditional.java", "diffHunk": "@@ -59,65 +65,67 @@ public AExpression getRightNode() {\n     }\n \n     @Override\n-    Output analyze(ClassNode classNode, SemanticScope semanticScope, Input input) {\n-        if (input.write) {\n+    Output analyze(ClassNode classNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(this, Write.class)) {\n             throw createError(new IllegalArgumentException(\"invalid assignment: cannot assign a value to conditional operation [?:]\"));\n         }\n \n-        if (input.read == false) {\n+        if (semanticScope.getCondition(this, Read.class) == false) {\n             throw createError(new IllegalArgumentException(\"not a statement: result not used from conditional operation [?:]\"));\n         }\n \n         Output output = new Output();\n \n-        Input conditionInput = new Input();\n-        conditionInput.expected = boolean.class;\n-        Output conditionOutput = analyze(conditionNode, classNode, semanticScope, conditionInput);\n-        PainlessCast conditionCast = AnalyzerCaster.getLegalCast(classNode.getLocation(),\n-                conditionOutput.actual, conditionInput.expected, conditionInput.explicit, conditionInput.internal);\n \n-        Input leftInput = new Input();\n-        leftInput.expected = input.expected;\n-        leftInput.explicit = input.explicit;\n-        leftInput.internal = input.internal;\n-        Output leftOutput = analyze(leftNode, classNode, semanticScope, leftInput);\n+        semanticScope.setCondition(conditionNode, Read.class);\n+        semanticScope.putDecoration(conditionNode, new TargetType(boolean.class));\n+        Output conditionOutput = analyze(conditionNode, classNode, semanticScope);\n+        PainlessCast conditionCast = conditionNode.cast(semanticScope);\n \n-        Input rightInput = new Input();\n-        rightInput.expected = input.expected;\n-        rightInput.explicit = input.explicit;\n-        rightInput.internal = input.internal;\n-        Output rightOutput = analyze(rightNode, classNode, semanticScope, rightInput);\n+        semanticScope.setCondition(leftNode, Read.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f8c2d58c882d0b8f9296fe60302dc41df25f4c4"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg3OTUwOA==", "bodyText": "Done.", "url": "https://github.com/elastic/elasticsearch/pull/58506#discussion_r447879508", "createdAt": "2020-06-30T18:03:25Z", "author": {"login": "jdconrad"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EConditional.java", "diffHunk": "@@ -59,65 +65,67 @@ public AExpression getRightNode() {\n     }\n \n     @Override\n-    Output analyze(ClassNode classNode, SemanticScope semanticScope, Input input) {\n-        if (input.write) {\n+    Output analyze(ClassNode classNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(this, Write.class)) {\n             throw createError(new IllegalArgumentException(\"invalid assignment: cannot assign a value to conditional operation [?:]\"));\n         }\n \n-        if (input.read == false) {\n+        if (semanticScope.getCondition(this, Read.class) == false) {\n             throw createError(new IllegalArgumentException(\"not a statement: result not used from conditional operation [?:]\"));\n         }\n \n         Output output = new Output();\n \n-        Input conditionInput = new Input();\n-        conditionInput.expected = boolean.class;\n-        Output conditionOutput = analyze(conditionNode, classNode, semanticScope, conditionInput);\n-        PainlessCast conditionCast = AnalyzerCaster.getLegalCast(classNode.getLocation(),\n-                conditionOutput.actual, conditionInput.expected, conditionInput.explicit, conditionInput.internal);\n \n-        Input leftInput = new Input();\n-        leftInput.expected = input.expected;\n-        leftInput.explicit = input.explicit;\n-        leftInput.internal = input.internal;\n-        Output leftOutput = analyze(leftNode, classNode, semanticScope, leftInput);\n+        semanticScope.setCondition(conditionNode, Read.class);\n+        semanticScope.putDecoration(conditionNode, new TargetType(boolean.class));\n+        Output conditionOutput = analyze(conditionNode, classNode, semanticScope);\n+        PainlessCast conditionCast = conditionNode.cast(semanticScope);\n \n-        Input rightInput = new Input();\n-        rightInput.expected = input.expected;\n-        rightInput.explicit = input.explicit;\n-        rightInput.internal = input.internal;\n-        Output rightOutput = analyze(rightNode, classNode, semanticScope, rightInput);\n+        semanticScope.setCondition(leftNode, Read.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg0OTkxOA=="}, "originalCommit": {"oid": "6f8c2d58c882d0b8f9296fe60302dc41df25f4c4"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MTI5Njg3OnYy", "diffSide": "RIGHT", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EConditional.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNzoxNjoxMlrOGrGmVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxODowMzoyOVrOGrIZcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg1MDA3MQ==", "bodyText": "likewise \"false clause\"", "url": "https://github.com/elastic/elasticsearch/pull/58506#discussion_r447850071", "createdAt": "2020-06-30T17:16:12Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EConditional.java", "diffHunk": "@@ -59,65 +65,67 @@ public AExpression getRightNode() {\n     }\n \n     @Override\n-    Output analyze(ClassNode classNode, SemanticScope semanticScope, Input input) {\n-        if (input.write) {\n+    Output analyze(ClassNode classNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(this, Write.class)) {\n             throw createError(new IllegalArgumentException(\"invalid assignment: cannot assign a value to conditional operation [?:]\"));\n         }\n \n-        if (input.read == false) {\n+        if (semanticScope.getCondition(this, Read.class) == false) {\n             throw createError(new IllegalArgumentException(\"not a statement: result not used from conditional operation [?:]\"));\n         }\n \n         Output output = new Output();\n \n-        Input conditionInput = new Input();\n-        conditionInput.expected = boolean.class;\n-        Output conditionOutput = analyze(conditionNode, classNode, semanticScope, conditionInput);\n-        PainlessCast conditionCast = AnalyzerCaster.getLegalCast(classNode.getLocation(),\n-                conditionOutput.actual, conditionInput.expected, conditionInput.explicit, conditionInput.internal);\n \n-        Input leftInput = new Input();\n-        leftInput.expected = input.expected;\n-        leftInput.explicit = input.explicit;\n-        leftInput.internal = input.internal;\n-        Output leftOutput = analyze(leftNode, classNode, semanticScope, leftInput);\n+        semanticScope.setCondition(conditionNode, Read.class);\n+        semanticScope.putDecoration(conditionNode, new TargetType(boolean.class));\n+        Output conditionOutput = analyze(conditionNode, classNode, semanticScope);\n+        PainlessCast conditionCast = conditionNode.cast(semanticScope);\n \n-        Input rightInput = new Input();\n-        rightInput.expected = input.expected;\n-        rightInput.explicit = input.explicit;\n-        rightInput.internal = input.internal;\n-        Output rightOutput = analyze(rightNode, classNode, semanticScope, rightInput);\n+        semanticScope.setCondition(leftNode, Read.class);\n+        semanticScope.copyDecoration(this, leftNode, TargetType.class);\n+        semanticScope.replicateCondition(this, leftNode, Explicit.class);\n+        semanticScope.replicateCondition(this, leftNode, Internal.class);\n+        Output leftOutput = analyze(leftNode, classNode, semanticScope);\n+        Class<?> leftValueType = semanticScope.getDecoration(leftNode, ValueType.class).getValueType();\n \n-        output.actual = input.expected;\n+        semanticScope.setCondition(rightNode, Read.class);\n+        semanticScope.copyDecoration(this, rightNode, TargetType.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f8c2d58c882d0b8f9296fe60302dc41df25f4c4"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg3OTUzOA==", "bodyText": "Done.", "url": "https://github.com/elastic/elasticsearch/pull/58506#discussion_r447879538", "createdAt": "2020-06-30T18:03:29Z", "author": {"login": "jdconrad"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EConditional.java", "diffHunk": "@@ -59,65 +65,67 @@ public AExpression getRightNode() {\n     }\n \n     @Override\n-    Output analyze(ClassNode classNode, SemanticScope semanticScope, Input input) {\n-        if (input.write) {\n+    Output analyze(ClassNode classNode, SemanticScope semanticScope) {\n+        if (semanticScope.getCondition(this, Write.class)) {\n             throw createError(new IllegalArgumentException(\"invalid assignment: cannot assign a value to conditional operation [?:]\"));\n         }\n \n-        if (input.read == false) {\n+        if (semanticScope.getCondition(this, Read.class) == false) {\n             throw createError(new IllegalArgumentException(\"not a statement: result not used from conditional operation [?:]\"));\n         }\n \n         Output output = new Output();\n \n-        Input conditionInput = new Input();\n-        conditionInput.expected = boolean.class;\n-        Output conditionOutput = analyze(conditionNode, classNode, semanticScope, conditionInput);\n-        PainlessCast conditionCast = AnalyzerCaster.getLegalCast(classNode.getLocation(),\n-                conditionOutput.actual, conditionInput.expected, conditionInput.explicit, conditionInput.internal);\n \n-        Input leftInput = new Input();\n-        leftInput.expected = input.expected;\n-        leftInput.explicit = input.explicit;\n-        leftInput.internal = input.internal;\n-        Output leftOutput = analyze(leftNode, classNode, semanticScope, leftInput);\n+        semanticScope.setCondition(conditionNode, Read.class);\n+        semanticScope.putDecoration(conditionNode, new TargetType(boolean.class));\n+        Output conditionOutput = analyze(conditionNode, classNode, semanticScope);\n+        PainlessCast conditionCast = conditionNode.cast(semanticScope);\n \n-        Input rightInput = new Input();\n-        rightInput.expected = input.expected;\n-        rightInput.explicit = input.explicit;\n-        rightInput.internal = input.internal;\n-        Output rightOutput = analyze(rightNode, classNode, semanticScope, rightInput);\n+        semanticScope.setCondition(leftNode, Read.class);\n+        semanticScope.copyDecoration(this, leftNode, TargetType.class);\n+        semanticScope.replicateCondition(this, leftNode, Explicit.class);\n+        semanticScope.replicateCondition(this, leftNode, Internal.class);\n+        Output leftOutput = analyze(leftNode, classNode, semanticScope);\n+        Class<?> leftValueType = semanticScope.getDecoration(leftNode, ValueType.class).getValueType();\n \n-        output.actual = input.expected;\n+        semanticScope.setCondition(rightNode, Read.class);\n+        semanticScope.copyDecoration(this, rightNode, TargetType.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg1MDA3MQ=="}, "originalCommit": {"oid": "6f8c2d58c882d0b8f9296fe60302dc41df25f4c4"}, "originalPosition": 67}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1409, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}