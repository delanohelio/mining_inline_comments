{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg4MDQ4ODUx", "number": 62469, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxNTowNjoxNlrOEkGZSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxNToxMToyNFrOEkGigw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2Mjg4OTY4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/execution/search/BasicQueryClient.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxNTowNjoxNlrOHS1a8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxNTo0MDozOFrOHS2_PA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTUxMTY2Ng==", "bodyText": "is the innerListSize updated correctly? From what I understand it's the last one from the for loop.", "url": "https://github.com/elastic/elasticsearch/pull/62469#discussion_r489511666", "createdAt": "2020-09-16T15:06:16Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/execution/search/BasicQueryClient.java", "diffHunk": "@@ -64,48 +68,52 @@ protected void search(SearchRequest search, ActionListener<SearchResponse> liste\n     }\n \n     @Override\n-    public void get(Iterable<List<HitReference>> refs, ActionListener<List<List<GetResponse>>> listener) {\n-        MultiGetRequestBuilder requestBuilder = client.prepareMultiGet();\n-        // no need for real-time\n-        requestBuilder.setRealtime(false)\n-                      .setRefresh(false);\n+    public void fetchHits(Iterable<List<HitReference>> refs, ActionListener<List<List<SearchHit>>> listener) {\n+        IdsQueryBuilder idsQuery = idsQuery();\n \n-        int sz = 0;\n+        int innerListSize = 0;\n+        Set<String> indices = new HashSet<>();\n+\n+        // associate each reference with its own\n+        final Map<HitReference, List<Integer>> referenceToPosition = new HashMap<>();\n+        int counter = 0;\n \n         for (List<HitReference> list : refs) {\n-            sz = list.size();\n+            innerListSize = list.size();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d3c2a70275872b1560fcfafe023c77bea15daae"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTUzNzM0MA==", "bodyText": "Correct because each sequence has the same number of entries. The initialization happens in the loop since refs is an iterator so it's not possible to just peek at one entry, the whole iterator has to be consumed hence why it's part of the loop.", "url": "https://github.com/elastic/elasticsearch/pull/62469#discussion_r489537340", "createdAt": "2020-09-16T15:40:38Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/execution/search/BasicQueryClient.java", "diffHunk": "@@ -64,48 +68,52 @@ protected void search(SearchRequest search, ActionListener<SearchResponse> liste\n     }\n \n     @Override\n-    public void get(Iterable<List<HitReference>> refs, ActionListener<List<List<GetResponse>>> listener) {\n-        MultiGetRequestBuilder requestBuilder = client.prepareMultiGet();\n-        // no need for real-time\n-        requestBuilder.setRealtime(false)\n-                      .setRefresh(false);\n+    public void fetchHits(Iterable<List<HitReference>> refs, ActionListener<List<List<SearchHit>>> listener) {\n+        IdsQueryBuilder idsQuery = idsQuery();\n \n-        int sz = 0;\n+        int innerListSize = 0;\n+        Set<String> indices = new HashSet<>();\n+\n+        // associate each reference with its own\n+        final Map<HitReference, List<Integer>> referenceToPosition = new HashMap<>();\n+        int counter = 0;\n \n         for (List<HitReference> list : refs) {\n-            sz = list.size();\n+            innerListSize = list.size();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTUxMTY2Ng=="}, "originalCommit": {"oid": "4d3c2a70275872b1560fcfafe023c77bea15daae"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MjkwNTE4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/execution/search/BasicQueryClient.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxNTowOTo0NFrOHS1k2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxNjowNjowNVrOHS4D1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTUxNDIwMw==", "bodyText": "Is the ref.id() unique across indices? Is there a possibility to fetch more than one document residing in different indices?", "url": "https://github.com/elastic/elasticsearch/pull/62469#discussion_r489514203", "createdAt": "2020-09-16T15:09:44Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/execution/search/BasicQueryClient.java", "diffHunk": "@@ -64,48 +68,52 @@ protected void search(SearchRequest search, ActionListener<SearchResponse> liste\n     }\n \n     @Override\n-    public void get(Iterable<List<HitReference>> refs, ActionListener<List<List<GetResponse>>> listener) {\n-        MultiGetRequestBuilder requestBuilder = client.prepareMultiGet();\n-        // no need for real-time\n-        requestBuilder.setRealtime(false)\n-                      .setRefresh(false);\n+    public void fetchHits(Iterable<List<HitReference>> refs, ActionListener<List<List<SearchHit>>> listener) {\n+        IdsQueryBuilder idsQuery = idsQuery();\n \n-        int sz = 0;\n+        int innerListSize = 0;\n+        Set<String> indices = new HashSet<>();\n+\n+        // associate each reference with its own\n+        final Map<HitReference, List<Integer>> referenceToPosition = new HashMap<>();\n+        int counter = 0;\n \n         for (List<HitReference> list : refs) {\n-            sz = list.size();\n+            innerListSize = list.size();\n             for (HitReference ref : list) {\n-                Item item = new Item(ref.index(), ref.id());\n-                // make sure to get the whole source\n-                item.fetchSourceContext(FetchSourceContext.FETCH_SOURCE);\n-                requestBuilder.add(item);\n+                idsQuery.addIds(ref.id());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d3c2a70275872b1560fcfafe023c77bea15daae"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTUzODEzMA==", "bodyText": "Of course not. You can have a document with id 1 - that's not unique across indices hence why the results are checked based on their id and index.", "url": "https://github.com/elastic/elasticsearch/pull/62469#discussion_r489538130", "createdAt": "2020-09-16T15:41:44Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/execution/search/BasicQueryClient.java", "diffHunk": "@@ -64,48 +68,52 @@ protected void search(SearchRequest search, ActionListener<SearchResponse> liste\n     }\n \n     @Override\n-    public void get(Iterable<List<HitReference>> refs, ActionListener<List<List<GetResponse>>> listener) {\n-        MultiGetRequestBuilder requestBuilder = client.prepareMultiGet();\n-        // no need for real-time\n-        requestBuilder.setRealtime(false)\n-                      .setRefresh(false);\n+    public void fetchHits(Iterable<List<HitReference>> refs, ActionListener<List<List<SearchHit>>> listener) {\n+        IdsQueryBuilder idsQuery = idsQuery();\n \n-        int sz = 0;\n+        int innerListSize = 0;\n+        Set<String> indices = new HashSet<>();\n+\n+        // associate each reference with its own\n+        final Map<HitReference, List<Integer>> referenceToPosition = new HashMap<>();\n+        int counter = 0;\n \n         for (List<HitReference> list : refs) {\n-            sz = list.size();\n+            innerListSize = list.size();\n             for (HitReference ref : list) {\n-                Item item = new Item(ref.index(), ref.id());\n-                // make sure to get the whole source\n-                item.fetchSourceContext(FetchSourceContext.FETCH_SOURCE);\n-                requestBuilder.add(item);\n+                idsQuery.addIds(ref.id());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTUxNDIwMw=="}, "originalCommit": {"oid": "4d3c2a70275872b1560fcfafe023c77bea15daae"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU1NDkwMg==", "bodyText": "As discussed, I'm worried about some edge case where we have multiple indices in the result docs and multiple id collisions which could lead to fetching many more docs than required, which will also increase the memory consumption. On the other hand, I don't know that the performance impact would be if we make multiple IdQuery requests, each for each index involved along with its corresponding doc ids.", "url": "https://github.com/elastic/elasticsearch/pull/62469#discussion_r489554902", "createdAt": "2020-09-16T16:06:05Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/execution/search/BasicQueryClient.java", "diffHunk": "@@ -64,48 +68,52 @@ protected void search(SearchRequest search, ActionListener<SearchResponse> liste\n     }\n \n     @Override\n-    public void get(Iterable<List<HitReference>> refs, ActionListener<List<List<GetResponse>>> listener) {\n-        MultiGetRequestBuilder requestBuilder = client.prepareMultiGet();\n-        // no need for real-time\n-        requestBuilder.setRealtime(false)\n-                      .setRefresh(false);\n+    public void fetchHits(Iterable<List<HitReference>> refs, ActionListener<List<List<SearchHit>>> listener) {\n+        IdsQueryBuilder idsQuery = idsQuery();\n \n-        int sz = 0;\n+        int innerListSize = 0;\n+        Set<String> indices = new HashSet<>();\n+\n+        // associate each reference with its own\n+        final Map<HitReference, List<Integer>> referenceToPosition = new HashMap<>();\n+        int counter = 0;\n \n         for (List<HitReference> list : refs) {\n-            sz = list.size();\n+            innerListSize = list.size();\n             for (HitReference ref : list) {\n-                Item item = new Item(ref.index(), ref.id());\n-                // make sure to get the whole source\n-                item.fetchSourceContext(FetchSourceContext.FETCH_SOURCE);\n-                requestBuilder.add(item);\n+                idsQuery.addIds(ref.id());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTUxNDIwMw=="}, "originalCommit": {"oid": "4d3c2a70275872b1560fcfafe023c77bea15daae"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MjkxMzMxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/execution/search/BasicQueryClient.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxNToxMToyNFrOHS1pzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxNTo0Mjo0NlrOHS3FNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTUxNTQ3MQ==", "bodyText": "Is it possible to use some other key for the HashMap to avoid the creation of HitReference objects?", "url": "https://github.com/elastic/elasticsearch/pull/62469#discussion_r489515471", "createdAt": "2020-09-16T15:11:24Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/execution/search/BasicQueryClient.java", "diffHunk": "@@ -64,48 +68,52 @@ protected void search(SearchRequest search, ActionListener<SearchResponse> liste\n     }\n \n     @Override\n-    public void get(Iterable<List<HitReference>> refs, ActionListener<List<List<GetResponse>>> listener) {\n-        MultiGetRequestBuilder requestBuilder = client.prepareMultiGet();\n-        // no need for real-time\n-        requestBuilder.setRealtime(false)\n-                      .setRefresh(false);\n+    public void fetchHits(Iterable<List<HitReference>> refs, ActionListener<List<List<SearchHit>>> listener) {\n+        IdsQueryBuilder idsQuery = idsQuery();\n \n-        int sz = 0;\n+        int innerListSize = 0;\n+        Set<String> indices = new HashSet<>();\n+\n+        // associate each reference with its own\n+        final Map<HitReference, List<Integer>> referenceToPosition = new HashMap<>();\n+        int counter = 0;\n \n         for (List<HitReference> list : refs) {\n-            sz = list.size();\n+            innerListSize = list.size();\n             for (HitReference ref : list) {\n-                Item item = new Item(ref.index(), ref.id());\n-                // make sure to get the whole source\n-                item.fetchSourceContext(FetchSourceContext.FETCH_SOURCE);\n-                requestBuilder.add(item);\n+                idsQuery.addIds(ref.id());\n+                indices.add(ref.index());\n+                // remember the reference position\n+                List<Integer> positions = referenceToPosition.computeIfAbsent(ref, v -> new ArrayList<>(1));\n+                positions.add(counter++);\n             }\n         }\n \n-        final int listSize = sz;\n-        client.multiGet(requestBuilder.request(), wrap(r -> {\n-            List<List<GetResponse>> hits = new ArrayList<>(r.getResponses().length / listSize);\n-\n-            List<GetResponse> sequence = new ArrayList<>(listSize);\n-\n-            int counter = 0;\n-            for (MultiGetItemResponse mgr : r.getResponses()) {\n-                if (mgr.isFailed()) {\n-                    listener.onFailure(mgr.getFailure().getFailure());\n-                    return;\n-                }\n+        SearchSourceBuilder builder = SearchSourceBuilder.searchSource()\n+            // make sure to fetch the whole source\n+            .fetchSource(FetchSourceContext.FETCH_SOURCE)\n+            .trackTotalHits(false)\n+            .trackScores(false)\n+            .query(idsQuery);\n+\n+        final int listSize = innerListSize;\n+        final int topListSize = counter / listSize;\n+        // pre-allocate the response matrix\n+        @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+        List<SearchHit>[] hits = new List[topListSize];\n+        for (int i = 0; i < hits.length; i++) {\n+            hits[i] = Arrays.asList(new SearchHit[listSize]);\n+        }\n+        final List<List<SearchHit>> seq = Arrays.asList(hits);\n \n-                sequence.add(mgr.getResponse());\n+        SearchRequest search = prepareRequest(client, builder, false, indices.toArray(new String[0]));\n \n-                if (++counter == listSize) {\n-                    counter = 0;\n-                    hits.add(sequence);\n-                    sequence = new ArrayList<>(listSize);\n-                }\n+        search(search, ActionListeners.map(listener, r -> {\n+            for (SearchHit hit : RuntimeUtils.searchHits(r)) {\n+                List<Integer> positions = referenceToPosition.get(new HitReference(hit));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d3c2a70275872b1560fcfafe023c77bea15daae"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTUzODg2OQ==", "bodyText": "HitReference is that key - it's lightweight as it holds just the document index and id plus equals/hashcode. If there wasn't HitReference, we'd have to create it.", "url": "https://github.com/elastic/elasticsearch/pull/62469#discussion_r489538869", "createdAt": "2020-09-16T15:42:46Z", "author": {"login": "costin"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/execution/search/BasicQueryClient.java", "diffHunk": "@@ -64,48 +68,52 @@ protected void search(SearchRequest search, ActionListener<SearchResponse> liste\n     }\n \n     @Override\n-    public void get(Iterable<List<HitReference>> refs, ActionListener<List<List<GetResponse>>> listener) {\n-        MultiGetRequestBuilder requestBuilder = client.prepareMultiGet();\n-        // no need for real-time\n-        requestBuilder.setRealtime(false)\n-                      .setRefresh(false);\n+    public void fetchHits(Iterable<List<HitReference>> refs, ActionListener<List<List<SearchHit>>> listener) {\n+        IdsQueryBuilder idsQuery = idsQuery();\n \n-        int sz = 0;\n+        int innerListSize = 0;\n+        Set<String> indices = new HashSet<>();\n+\n+        // associate each reference with its own\n+        final Map<HitReference, List<Integer>> referenceToPosition = new HashMap<>();\n+        int counter = 0;\n \n         for (List<HitReference> list : refs) {\n-            sz = list.size();\n+            innerListSize = list.size();\n             for (HitReference ref : list) {\n-                Item item = new Item(ref.index(), ref.id());\n-                // make sure to get the whole source\n-                item.fetchSourceContext(FetchSourceContext.FETCH_SOURCE);\n-                requestBuilder.add(item);\n+                idsQuery.addIds(ref.id());\n+                indices.add(ref.index());\n+                // remember the reference position\n+                List<Integer> positions = referenceToPosition.computeIfAbsent(ref, v -> new ArrayList<>(1));\n+                positions.add(counter++);\n             }\n         }\n \n-        final int listSize = sz;\n-        client.multiGet(requestBuilder.request(), wrap(r -> {\n-            List<List<GetResponse>> hits = new ArrayList<>(r.getResponses().length / listSize);\n-\n-            List<GetResponse> sequence = new ArrayList<>(listSize);\n-\n-            int counter = 0;\n-            for (MultiGetItemResponse mgr : r.getResponses()) {\n-                if (mgr.isFailed()) {\n-                    listener.onFailure(mgr.getFailure().getFailure());\n-                    return;\n-                }\n+        SearchSourceBuilder builder = SearchSourceBuilder.searchSource()\n+            // make sure to fetch the whole source\n+            .fetchSource(FetchSourceContext.FETCH_SOURCE)\n+            .trackTotalHits(false)\n+            .trackScores(false)\n+            .query(idsQuery);\n+\n+        final int listSize = innerListSize;\n+        final int topListSize = counter / listSize;\n+        // pre-allocate the response matrix\n+        @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+        List<SearchHit>[] hits = new List[topListSize];\n+        for (int i = 0; i < hits.length; i++) {\n+            hits[i] = Arrays.asList(new SearchHit[listSize]);\n+        }\n+        final List<List<SearchHit>> seq = Arrays.asList(hits);\n \n-                sequence.add(mgr.getResponse());\n+        SearchRequest search = prepareRequest(client, builder, false, indices.toArray(new String[0]));\n \n-                if (++counter == listSize) {\n-                    counter = 0;\n-                    hits.add(sequence);\n-                    sequence = new ArrayList<>(listSize);\n-                }\n+        search(search, ActionListeners.map(listener, r -> {\n+            for (SearchHit hit : RuntimeUtils.searchHits(r)) {\n+                List<Integer> positions = referenceToPosition.get(new HitReference(hit));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTUxNTQ3MQ=="}, "originalCommit": {"oid": "4d3c2a70275872b1560fcfafe023c77bea15daae"}, "originalPosition": 109}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1484, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}