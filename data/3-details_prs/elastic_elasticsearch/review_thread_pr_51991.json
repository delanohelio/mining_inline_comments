{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcxODI4ODYw", "number": 51991, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxMDo0NzozOVrODdo5TA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QwNzowMTozOFrODd7aVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyNDA1MzI0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxMDo0NzozOVrOFmWxxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxNzowNzoxOFrOFnuNbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc2MzM5OA==", "bodyText": "I don't like this. These stats live at the Engine level, but the reference managers live down here, and we need to register the cache as a refresh listener; if there were any other implementations of Engine then they would also need to do the same (except ReadOnlyEngines of course, they don't refresh so don't need to update these stats).\nWe can't do this in the Engine constructor since these reference managers haven't been created when that runs, but I can't see another obvious place in the Engine lifecycle to do this. Suggestions welcome.", "url": "https://github.com/elastic/elasticsearch/pull/51991#discussion_r375763398", "createdAt": "2020-02-06T10:47:39Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java", "diffHunk": "@@ -247,6 +247,7 @@ public InternalEngine(EngineConfig engineConfig) {\n             }\n             this.lastRefreshedCheckpointListener = new LastRefreshedCheckpointListener(localCheckpointTracker.getProcessedCheckpoint());\n             this.internalReaderManager.addListener(lastRefreshedCheckpointListener);\n+            this.externalReaderManager.addListener(completionStatsCache);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5be0d83709ec31e3f6d6438a84110b59ea7ea81b"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTg1NTA3OA==", "bodyText": "I think I would prefer to move the completionStatsCache field down to this level instead (and repeat it in ReadOnlyEngine for now). That would make the completionStats method abstract in Engine.\nI see no need to specialize the caching in ReadOnlyEngine, but in theory, we could pick a different strategy there...", "url": "https://github.com/elastic/elasticsearch/pull/51991#discussion_r375855078", "createdAt": "2020-02-06T14:12:03Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java", "diffHunk": "@@ -247,6 +247,7 @@ public InternalEngine(EngineConfig engineConfig) {\n             }\n             this.lastRefreshedCheckpointListener = new LastRefreshedCheckpointListener(localCheckpointTracker.getProcessedCheckpoint());\n             this.internalReaderManager.addListener(lastRefreshedCheckpointListener);\n+            this.externalReaderManager.addListener(completionStatsCache);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc2MzM5OA=="}, "originalCommit": {"oid": "5be0d83709ec31e3f6d6438a84110b59ea7ea81b"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzE5NTg4NQ==", "bodyText": "Sure, thanks for the suggestion. Done in c3ae272.", "url": "https://github.com/elastic/elasticsearch/pull/51991#discussion_r377195885", "createdAt": "2020-02-10T17:07:18Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java", "diffHunk": "@@ -247,6 +247,7 @@ public InternalEngine(EngineConfig engineConfig) {\n             }\n             this.lastRefreshedCheckpointListener = new LastRefreshedCheckpointListener(localCheckpointTracker.getProcessedCheckpoint());\n             this.internalReaderManager.addListener(lastRefreshedCheckpointListener);\n+            this.externalReaderManager.addListener(completionStatsCache);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc2MzM5OA=="}, "originalCommit": {"oid": "5be0d83709ec31e3f6d6438a84110b59ea7ea81b"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyNDA1NzcyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/engine/Engine.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxMDo0ODo1NVrOFmW0cQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNToyNjoxNFrOFuKcfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc2NDA4MQ==", "bodyText": "NB this moves the stats back to the EXTERNAL searcher scope. Prior to #33847 they used the EXTERNAL searcher as here but since then they have been using the INTERNAL one. I think EXTERNAL is more appropriate.", "url": "https://github.com/elastic/elasticsearch/pull/51991#discussion_r375764081", "createdAt": "2020-02-06T10:48:55Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/index/engine/Engine.java", "diffHunk": "@@ -177,32 +170,14 @@ public MergeStats getMergeStats() {\n     /** Returns how many bytes we are currently moving from heap to disk */\n     public abstract long getWritingBytes();\n \n+\n+    final CompletionStatsCache completionStatsCache = new CompletionStatsCache(() -> acquireSearcher(\"completion_stats\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5be0d83709ec31e3f6d6438a84110b59ea7ea81b"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTg0MDA5Nw==", "bodyText": "Thanks for highlighting this. My hunch is that internal is more appropriate due to refreshIfNeeded, which can in some cases refresh the internal scope. This is out of a preference for returning as recent stats information as we can. Can you elaborate on why you find EXTERNAL more appropriate?", "url": "https://github.com/elastic/elasticsearch/pull/51991#discussion_r375840097", "createdAt": "2020-02-06T13:43:53Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/index/engine/Engine.java", "diffHunk": "@@ -177,32 +170,14 @@ public MergeStats getMergeStats() {\n     /** Returns how many bytes we are currently moving from heap to disk */\n     public abstract long getWritingBytes();\n \n+\n+    final CompletionStatsCache completionStatsCache = new CompletionStatsCache(() -> acquireSearcher(\"completion_stats\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc2NDA4MQ=="}, "originalCommit": {"oid": "5be0d83709ec31e3f6d6438a84110b59ea7ea81b"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzE5ODM3MA==", "bodyText": "I don't think we ever use the segments that are only referenced by the INTERNAL searcher for completion suggestions, but AIUI the previous implementation would load up their suggesters anyway. By moving this back to EXTERNAL we avoid even loading these unnecessary suggesters until they're externally exposed, so there's no need to account for their memory usage.\nI've not confirmed 100% that we never use internal-only segments for completion suggestions, so maybe that assumption is flawed.", "url": "https://github.com/elastic/elasticsearch/pull/51991#discussion_r377198370", "createdAt": "2020-02-10T17:11:33Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/index/engine/Engine.java", "diffHunk": "@@ -177,32 +170,14 @@ public MergeStats getMergeStats() {\n     /** Returns how many bytes we are currently moving from heap to disk */\n     public abstract long getWritingBytes();\n \n+\n+    final CompletionStatsCache completionStatsCache = new CompletionStatsCache(() -> acquireSearcher(\"completion_stats\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc2NDA4MQ=="}, "originalCommit": {"oid": "5be0d83709ec31e3f6d6438a84110b59ea7ea81b"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzk0OTk1MQ==", "bodyText": "++, thanks for elaborating, this makes perfect sense.", "url": "https://github.com/elastic/elasticsearch/pull/51991#discussion_r383949951", "createdAt": "2020-02-25T15:26:14Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/index/engine/Engine.java", "diffHunk": "@@ -177,32 +170,14 @@ public MergeStats getMergeStats() {\n     /** Returns how many bytes we are currently moving from heap to disk */\n     public abstract long getWritingBytes();\n \n+\n+    final CompletionStatsCache completionStatsCache = new CompletionStatsCache(() -> acquireSearcher(\"completion_stats\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc2NDA4MQ=="}, "originalCommit": {"oid": "5be0d83709ec31e3f6d6438a84110b59ea7ea81b"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyNDUzNDE4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/engine/CompletionStatsCache.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxMzo0MDozNFrOFmbWOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxNzowNjoyNVrOFnuLfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTgzODI2NQ==", "bodyText": "I think I would prefer to not cache an exception result (or at least clear the ref further down if newFuture.actionGet() throws an exception) in order to not stick to a bad result forever.", "url": "https://github.com/elastic/elasticsearch/pull/51991#discussion_r375838265", "createdAt": "2020-02-06T13:40:34Z", "author": {"login": "henningandersen"}, "path": "server/src/main/java/org/elasticsearch/index/engine/CompletionStatsCache.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.index.engine;\n+\n+import com.carrotsearch.hppc.ObjectLongHashMap;\n+import com.carrotsearch.hppc.cursors.ObjectLongCursor;\n+import org.apache.lucene.index.FieldInfo;\n+import org.apache.lucene.index.LeafReader;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.Terms;\n+import org.apache.lucene.search.ReferenceManager;\n+import org.apache.lucene.search.suggest.document.CompletionTerms;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.common.FieldMemoryStats;\n+import org.elasticsearch.common.regex.Regex;\n+import org.elasticsearch.search.suggest.completion.CompletionStats;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+class CompletionStatsCache implements ReferenceManager.RefreshListener {\n+\n+    private final Supplier<Engine.Searcher> searcherSupplier;\n+\n+    /**\n+     * Contains a future (i.e. non-null) if another thread is already computing stats, in which case wait for this computation to\n+     * complete. Contains null otherwise, in which case compute the stats ourselves and save them here for other threads to use.\n+     * Futures are eventually completed with stats that include all fields, requiring further filtering (see\n+     * {@link CompletionStatsCache#filterCompletionStatsByFieldName}).\n+     */\n+    private final AtomicReference<PlainActionFuture<CompletionStats>> completionStatsFutureRef = new AtomicReference<>();\n+\n+    CompletionStatsCache(Supplier<Engine.Searcher> searcherSupplier) {\n+        this.searcherSupplier = searcherSupplier;\n+    }\n+\n+    CompletionStats get(String... fieldNamePatterns) {\n+        final PlainActionFuture<CompletionStats> newFuture = new PlainActionFuture<>();\n+        final PlainActionFuture<CompletionStats> oldFuture = completionStatsFutureRef.compareAndExchange(null, newFuture);\n+\n+        if (oldFuture != null) {\n+            // we lost the race, someone else is already computing stats, so we wait for that to finish\n+            return filterCompletionStatsByFieldName(fieldNamePatterns, oldFuture.actionGet());\n+        }\n+\n+        // we won the race, nobody else is already computing stats, so it's up to us\n+        ActionListener.completeWith(newFuture, () -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db5be3a794c5560a8fd534bfb7fc5fc28472aac9"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzE5NTM4OA==", "bodyText": "Sure, makes sense, I made it immediately invalidate the cache on an exception (the exception is still shared amongst concurrent callers) in 5e9a3ab.", "url": "https://github.com/elastic/elasticsearch/pull/51991#discussion_r377195388", "createdAt": "2020-02-10T17:06:25Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/index/engine/CompletionStatsCache.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.index.engine;\n+\n+import com.carrotsearch.hppc.ObjectLongHashMap;\n+import com.carrotsearch.hppc.cursors.ObjectLongCursor;\n+import org.apache.lucene.index.FieldInfo;\n+import org.apache.lucene.index.LeafReader;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.Terms;\n+import org.apache.lucene.search.ReferenceManager;\n+import org.apache.lucene.search.suggest.document.CompletionTerms;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.common.FieldMemoryStats;\n+import org.elasticsearch.common.regex.Regex;\n+import org.elasticsearch.search.suggest.completion.CompletionStats;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+class CompletionStatsCache implements ReferenceManager.RefreshListener {\n+\n+    private final Supplier<Engine.Searcher> searcherSupplier;\n+\n+    /**\n+     * Contains a future (i.e. non-null) if another thread is already computing stats, in which case wait for this computation to\n+     * complete. Contains null otherwise, in which case compute the stats ourselves and save them here for other threads to use.\n+     * Futures are eventually completed with stats that include all fields, requiring further filtering (see\n+     * {@link CompletionStatsCache#filterCompletionStatsByFieldName}).\n+     */\n+    private final AtomicReference<PlainActionFuture<CompletionStats>> completionStatsFutureRef = new AtomicReference<>();\n+\n+    CompletionStatsCache(Supplier<Engine.Searcher> searcherSupplier) {\n+        this.searcherSupplier = searcherSupplier;\n+    }\n+\n+    CompletionStats get(String... fieldNamePatterns) {\n+        final PlainActionFuture<CompletionStats> newFuture = new PlainActionFuture<>();\n+        final PlainActionFuture<CompletionStats> oldFuture = completionStatsFutureRef.compareAndExchange(null, newFuture);\n+\n+        if (oldFuture != null) {\n+            // we lost the race, someone else is already computing stats, so we wait for that to finish\n+            return filterCompletionStatsByFieldName(fieldNamePatterns, oldFuture.actionGet());\n+        }\n+\n+        // we won the race, nobody else is already computing stats, so it's up to us\n+        ActionListener.completeWith(newFuture, () -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTgzODI2NQ=="}, "originalCommit": {"oid": "db5be3a794c5560a8fd534bfb7fc5fc28472aac9"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyNDk2NTk2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/engine/CompletionStatsCache.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxNTozNDo1NlrOFmfgHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxNzoxNzo1NlrOFnukqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTkwNjMzNQ==", "bodyText": "Instead of invalidating the entire current cache, we can mark the current cache as outdated (i.e., need to refresh), then we can reuse the stats of some LeafReader that haven't changed between refreshes.", "url": "https://github.com/elastic/elasticsearch/pull/51991#discussion_r375906335", "createdAt": "2020-02-06T15:34:56Z", "author": {"login": "dnhatn"}, "path": "server/src/main/java/org/elasticsearch/index/engine/CompletionStatsCache.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.index.engine;\n+\n+import com.carrotsearch.hppc.ObjectLongHashMap;\n+import com.carrotsearch.hppc.cursors.ObjectLongCursor;\n+import org.apache.lucene.index.FieldInfo;\n+import org.apache.lucene.index.LeafReader;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.Terms;\n+import org.apache.lucene.search.ReferenceManager;\n+import org.apache.lucene.search.suggest.document.CompletionTerms;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.common.FieldMemoryStats;\n+import org.elasticsearch.common.regex.Regex;\n+import org.elasticsearch.search.suggest.completion.CompletionStats;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+class CompletionStatsCache implements ReferenceManager.RefreshListener {\n+\n+    private final Supplier<Engine.Searcher> searcherSupplier;\n+\n+    /**\n+     * Contains a future (i.e. non-null) if another thread is already computing stats, in which case wait for this computation to\n+     * complete. Contains null otherwise, in which case compute the stats ourselves and save them here for other threads to use.\n+     * Futures are eventually completed with stats that include all fields, requiring further filtering (see\n+     * {@link CompletionStatsCache#filterCompletionStatsByFieldName}).\n+     */\n+    private final AtomicReference<PlainActionFuture<CompletionStats>> completionStatsFutureRef = new AtomicReference<>();\n+\n+    CompletionStatsCache(Supplier<Engine.Searcher> searcherSupplier) {\n+        this.searcherSupplier = searcherSupplier;\n+    }\n+\n+    CompletionStats get(String... fieldNamePatterns) {\n+        final PlainActionFuture<CompletionStats> newFuture = new PlainActionFuture<>();\n+        final PlainActionFuture<CompletionStats> oldFuture = completionStatsFutureRef.compareAndExchange(null, newFuture);\n+\n+        if (oldFuture != null) {\n+            // we lost the race, someone else is already computing stats, so we wait for that to finish\n+            return filterCompletionStatsByFieldName(fieldNamePatterns, oldFuture.actionGet());\n+        }\n+\n+        // we won the race, nobody else is already computing stats, so it's up to us\n+        ActionListener.completeWith(newFuture, () -> {\n+            long sizeInBytes = 0;\n+            final ObjectLongHashMap<String> completionFields = new ObjectLongHashMap<>();\n+\n+            try (Engine.Searcher currentSearcher = searcherSupplier.get()) {\n+                for (LeafReaderContext atomicReaderContext : currentSearcher.getIndexReader().leaves()) {\n+                    LeafReader atomicReader = atomicReaderContext.reader();\n+                    for (FieldInfo info : atomicReader.getFieldInfos()) {\n+                        Terms terms = atomicReader.terms(info.name);\n+                        if (terms instanceof CompletionTerms) {\n+                            // TODO: currently we load up the suggester for reporting its size\n+                            final long fstSize = ((CompletionTerms) terms).suggester().ramBytesUsed();\n+                            completionFields.addTo(info.name, fstSize);\n+                            sizeInBytes += fstSize;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            return new CompletionStats(sizeInBytes, new FieldMemoryStats(completionFields));\n+        });\n+\n+        return filterCompletionStatsByFieldName(fieldNamePatterns, newFuture.actionGet());\n+    }\n+\n+    private static CompletionStats filterCompletionStatsByFieldName(String[] fieldNamePatterns, CompletionStats fullCompletionStats) {\n+        final FieldMemoryStats fieldMemoryStats;\n+        if (fieldNamePatterns != null && fieldNamePatterns.length > 0) {\n+            final ObjectLongHashMap<String> completionFields = new ObjectLongHashMap<>(fieldNamePatterns.length);\n+            for (ObjectLongCursor<String> fieldCursor : fullCompletionStats.getFields()) {\n+                if (Regex.simpleMatch(fieldNamePatterns, fieldCursor.key)) {\n+                    completionFields.addTo(fieldCursor.key, fieldCursor.value);\n+                }\n+            }\n+            fieldMemoryStats = new FieldMemoryStats(completionFields);\n+        } else {\n+            fieldMemoryStats = null;\n+        }\n+        return new CompletionStats(fullCompletionStats.getSizeInBytes(), fieldMemoryStats);\n+    }\n+\n+    @Override\n+    public void beforeRefresh() {\n+    }\n+\n+    @Override\n+    public void afterRefresh(boolean didRefresh) {\n+        if (didRefresh) {\n+            completionStatsFutureRef.set(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db5be3a794c5560a8fd534bfb7fc5fc28472aac9"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzIwMTgzNQ==", "bodyText": "If we re-use a LeafReader across a refresh, does it keep its suggester loaded? If so, do we not already avoid most of the work of recomputing stats?\nNote that we need to break the stats down by field, because the user can select the fields in the API. If I understand correctly I think re-using stats on a per-segment basis too would require tracking everything on a per-segment-per-field basis which seems unnecessary.", "url": "https://github.com/elastic/elasticsearch/pull/51991#discussion_r377201835", "createdAt": "2020-02-10T17:17:56Z", "author": {"login": "DaveCTurner"}, "path": "server/src/main/java/org/elasticsearch/index/engine/CompletionStatsCache.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.index.engine;\n+\n+import com.carrotsearch.hppc.ObjectLongHashMap;\n+import com.carrotsearch.hppc.cursors.ObjectLongCursor;\n+import org.apache.lucene.index.FieldInfo;\n+import org.apache.lucene.index.LeafReader;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.Terms;\n+import org.apache.lucene.search.ReferenceManager;\n+import org.apache.lucene.search.suggest.document.CompletionTerms;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.common.FieldMemoryStats;\n+import org.elasticsearch.common.regex.Regex;\n+import org.elasticsearch.search.suggest.completion.CompletionStats;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+class CompletionStatsCache implements ReferenceManager.RefreshListener {\n+\n+    private final Supplier<Engine.Searcher> searcherSupplier;\n+\n+    /**\n+     * Contains a future (i.e. non-null) if another thread is already computing stats, in which case wait for this computation to\n+     * complete. Contains null otherwise, in which case compute the stats ourselves and save them here for other threads to use.\n+     * Futures are eventually completed with stats that include all fields, requiring further filtering (see\n+     * {@link CompletionStatsCache#filterCompletionStatsByFieldName}).\n+     */\n+    private final AtomicReference<PlainActionFuture<CompletionStats>> completionStatsFutureRef = new AtomicReference<>();\n+\n+    CompletionStatsCache(Supplier<Engine.Searcher> searcherSupplier) {\n+        this.searcherSupplier = searcherSupplier;\n+    }\n+\n+    CompletionStats get(String... fieldNamePatterns) {\n+        final PlainActionFuture<CompletionStats> newFuture = new PlainActionFuture<>();\n+        final PlainActionFuture<CompletionStats> oldFuture = completionStatsFutureRef.compareAndExchange(null, newFuture);\n+\n+        if (oldFuture != null) {\n+            // we lost the race, someone else is already computing stats, so we wait for that to finish\n+            return filterCompletionStatsByFieldName(fieldNamePatterns, oldFuture.actionGet());\n+        }\n+\n+        // we won the race, nobody else is already computing stats, so it's up to us\n+        ActionListener.completeWith(newFuture, () -> {\n+            long sizeInBytes = 0;\n+            final ObjectLongHashMap<String> completionFields = new ObjectLongHashMap<>();\n+\n+            try (Engine.Searcher currentSearcher = searcherSupplier.get()) {\n+                for (LeafReaderContext atomicReaderContext : currentSearcher.getIndexReader().leaves()) {\n+                    LeafReader atomicReader = atomicReaderContext.reader();\n+                    for (FieldInfo info : atomicReader.getFieldInfos()) {\n+                        Terms terms = atomicReader.terms(info.name);\n+                        if (terms instanceof CompletionTerms) {\n+                            // TODO: currently we load up the suggester for reporting its size\n+                            final long fstSize = ((CompletionTerms) terms).suggester().ramBytesUsed();\n+                            completionFields.addTo(info.name, fstSize);\n+                            sizeInBytes += fstSize;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            return new CompletionStats(sizeInBytes, new FieldMemoryStats(completionFields));\n+        });\n+\n+        return filterCompletionStatsByFieldName(fieldNamePatterns, newFuture.actionGet());\n+    }\n+\n+    private static CompletionStats filterCompletionStatsByFieldName(String[] fieldNamePatterns, CompletionStats fullCompletionStats) {\n+        final FieldMemoryStats fieldMemoryStats;\n+        if (fieldNamePatterns != null && fieldNamePatterns.length > 0) {\n+            final ObjectLongHashMap<String> completionFields = new ObjectLongHashMap<>(fieldNamePatterns.length);\n+            for (ObjectLongCursor<String> fieldCursor : fullCompletionStats.getFields()) {\n+                if (Regex.simpleMatch(fieldNamePatterns, fieldCursor.key)) {\n+                    completionFields.addTo(fieldCursor.key, fieldCursor.value);\n+                }\n+            }\n+            fieldMemoryStats = new FieldMemoryStats(completionFields);\n+        } else {\n+            fieldMemoryStats = null;\n+        }\n+        return new CompletionStats(fullCompletionStats.getSizeInBytes(), fieldMemoryStats);\n+    }\n+\n+    @Override\n+    public void beforeRefresh() {\n+    }\n+\n+    @Override\n+    public void afterRefresh(boolean didRefresh) {\n+        if (didRefresh) {\n+            completionStatsFutureRef.set(null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTkwNjMzNQ=="}, "originalCommit": {"oid": "db5be3a794c5560a8fd534bfb7fc5fc28472aac9"}, "originalPosition": 112}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyNzA4Njk0OnYy", "diffSide": "RIGHT", "path": "rest-api-spec/src/main/resources/rest-api-spec/test/indices.stats/40_updates_on_refresh.yml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QwNzowMTozOFrOFmz2vQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxNzowNjo0NlrOFnuMQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjIzOTgwNQ==", "bodyText": "Do we need the wait_for_events: languid hack here to guard against a relocation completing but delayed reroute causing a short period before the next relocation happens (in case more relocations are necessary to balance cluster)?", "url": "https://github.com/elastic/elasticsearch/pull/51991#discussion_r376239805", "createdAt": "2020-02-07T07:01:38Z", "author": {"login": "henningandersen"}, "path": "rest-api-spec/src/main/resources/rest-api-spec/test/indices.stats/40_updates_on_refresh.yml", "diffHunk": "@@ -0,0 +1,66 @@\n+---\n+setup:\n+\n+  - do:\n+      indices.create:\n+          index:  test1\n+          wait_for_active_shards: all\n+          body:\n+              settings:\n+                # Limit the number of shards so that shards are unlikely\n+                # to be relocated or being initialized between the test\n+                # set up and the test execution\n+                index.number_of_shards: 3\n+                index.number_of_replicas: 0\n+              mappings:\n+                  properties:\n+                      bar:\n+                          type: text\n+                          fielddata: true\n+                          fields:\n+                              completion:\n+                                  type: completion\n+\n+  - do:\n+      cluster.health:\n+        wait_for_no_relocating_shards: true", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db5be3a794c5560a8fd534bfb7fc5fc28472aac9"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzE5NTU4Ng==", "bodyText": "... maybe ...\nbut it doesn't hurt - added in e3262eb.", "url": "https://github.com/elastic/elasticsearch/pull/51991#discussion_r377195586", "createdAt": "2020-02-10T17:06:46Z", "author": {"login": "DaveCTurner"}, "path": "rest-api-spec/src/main/resources/rest-api-spec/test/indices.stats/40_updates_on_refresh.yml", "diffHunk": "@@ -0,0 +1,66 @@\n+---\n+setup:\n+\n+  - do:\n+      indices.create:\n+          index:  test1\n+          wait_for_active_shards: all\n+          body:\n+              settings:\n+                # Limit the number of shards so that shards are unlikely\n+                # to be relocated or being initialized between the test\n+                # set up and the test execution\n+                index.number_of_shards: 3\n+                index.number_of_replicas: 0\n+              mappings:\n+                  properties:\n+                      bar:\n+                          type: text\n+                          fielddata: true\n+                          fields:\n+                              completion:\n+                                  type: completion\n+\n+  - do:\n+      cluster.health:\n+        wait_for_no_relocating_shards: true", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjIzOTgwNQ=="}, "originalCommit": {"oid": "db5be3a794c5560a8fd534bfb7fc5fc28472aac9"}, "originalPosition": 26}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4975, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}