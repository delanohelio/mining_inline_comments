{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI1OTY2MjQ1", "number": 65386, "title": " Support unmapped fields in search 'fields' option", "bodyText": "Currently, the 'fields' option only supports fetching mapped fields. Since\n'fields' is meant to be the central place to retrieve document content, it\nshould allow for loading unmapped values. This change adds implementation and\ntests for this feature.\nCloses #63690", "createdAt": "2020-11-23T20:08:39Z", "url": "https://github.com/elastic/elasticsearch/pull/65386", "merged": true, "mergeCommit": {"oid": "3c3a43249f993f9c602e0875d491e990c752efe5"}, "closed": true, "closedAt": "2020-12-01T20:40:28Z", "author": {"login": "cbuescher"}, "timelineItems": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdfXDgYAH2gAyNTI1OTY2MjQ1OjQ3NWRhNDhhMzVkMDgwYjY5MzdiZDE1NmE2YTc2OTcyODRhOWI1MTQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdh_jC3AH2gAyNTI1OTY2MjQ1OjQyZjNjMWMzNDRhNDQ0ZDAxY2EzNzg4ODNlZGY4ZTcyNjRiMTNkNGU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "475da48a35d080b6937bd156a6a7697284a9b514", "author": {"user": {"login": "cbuescher", "name": "Christoph B\u00fcscher"}}, "url": "https://github.com/elastic/elasticsearch/commit/475da48a35d080b6937bd156a6a7697284a9b514", "committedDate": "2020-11-23T15:40:32Z", "message": "Support unmapped fields in search 'fields' option\n\nCurrently, the 'fields' option only supports fetching mapped fields. Since\n'fields' is meant to be the central place to retrieve document content, it\nshould allow for loading unmapped values. This change adds implementation and\ntests for this feature.\n\nCloses #63690"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "80e1822dcd5c60bcc6f85278be0c2b9593c1b2dd", "author": {"user": {"login": "cbuescher", "name": "Christoph B\u00fcscher"}}, "url": "https://github.com/elastic/elasticsearch/commit/80e1822dcd5c60bcc6f85278be0c2b9593c1b2dd", "committedDate": "2020-11-23T19:55:42Z", "message": "add docs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "08f919fbcf4281021cb67c020adc1e6ffe2dd9e0", "author": {"user": {"login": "cbuescher", "name": "Christoph B\u00fcscher"}}, "url": "https://github.com/elastic/elasticsearch/commit/08f919fbcf4281021cb67c020adc1e6ffe2dd9e0", "committedDate": "2020-11-24T10:23:40Z", "message": "Merge branch 'master' into unmapped-fields-63690"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3193e0d5bb4a101721dfa4c008dff163baaac9e7", "author": {"user": {"login": "cbuescher", "name": "Christoph B\u00fcscher"}}, "url": "https://github.com/elastic/elasticsearch/commit/3193e0d5bb4a101721dfa4c008dff163baaac9e7", "committedDate": "2020-11-24T10:54:40Z", "message": "fix tests"}, "afterCommit": {"oid": "81b05d368c8edd2d9e0c2a4f484b35115468e32c", "author": {"user": {"login": "cbuescher", "name": "Christoph B\u00fcscher"}}, "url": "https://github.com/elastic/elasticsearch/commit/81b05d368c8edd2d9e0c2a4f484b35115468e32c", "committedDate": "2020-11-24T11:41:53Z", "message": "fix tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7bb350e6b1037b17a1ddad75feaffc1c84cb83da", "author": {"user": {"login": "cbuescher", "name": "Christoph B\u00fcscher"}}, "url": "https://github.com/elastic/elasticsearch/commit/7bb350e6b1037b17a1ddad75feaffc1c84cb83da", "committedDate": "2020-11-24T12:46:35Z", "message": "fix tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "81b05d368c8edd2d9e0c2a4f484b35115468e32c", "author": {"user": {"login": "cbuescher", "name": "Christoph B\u00fcscher"}}, "url": "https://github.com/elastic/elasticsearch/commit/81b05d368c8edd2d9e0c2a4f484b35115468e32c", "committedDate": "2020-11-24T11:41:53Z", "message": "fix tests"}, "afterCommit": {"oid": "7bb350e6b1037b17a1ddad75feaffc1c84cb83da", "author": {"user": {"login": "cbuescher", "name": "Christoph B\u00fcscher"}}, "url": "https://github.com/elastic/elasticsearch/commit/7bb350e6b1037b17a1ddad75feaffc1c84cb83da", "committedDate": "2020-11-24T12:46:35Z", "message": "fix tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM4OTQ2MDU5", "url": "https://github.com/elastic/elasticsearch/pull/65386#pullrequestreview-538946059", "createdAt": "2020-11-26T02:03:01Z", "commit": {"oid": "7bb350e6b1037b17a1ddad75feaffc1c84cb83da"}, "state": "COMMENTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQwMjowMzowMVrOH6JTKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQwNDowMjo0OVrOH6LFww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDczMTgxNg==", "bodyText": "Small typo, fieldS -> fields", "url": "https://github.com/elastic/elasticsearch/pull/65386#discussion_r530731816", "createdAt": "2020-11-26T02:03:01Z", "author": {"login": "jtibshirani"}, "path": "docs/reference/search/search-your-data/retrieve-selected-fields.asciidoc", "diffHunk": "@@ -167,7 +167,92 @@ no dedicated array type, and any field could contain multiple values. The\n a specific order. See the mapping documentation on <<array, arrays>> for more\n background.\n \n+[discrete]\n+[[retrieve-unmapped-fields]]\n+==== Retrieving unmapped fields\n+\n+By default, the `fields` parameter returns only values of mapped fields. However,\n+Elasticsearch allows storing fields in `_source` that are unmapped, for example by\n+setting <<dynamic-field-mapping,Dynamic field mapping>> to `false` or by using an\n+object field with `enabled: false`, thereby disabling parsing and indexing of its content.\n+\n+Fields in such an object can be retrieved from `_source` using the `include_unmapped` option\n+in the `fieldS` section:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bb350e6b1037b17a1ddad75feaffc1c84cb83da"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDczMjIyNg==", "bodyText": "'true' has a missing backtick", "url": "https://github.com/elastic/elasticsearch/pull/65386#discussion_r530732226", "createdAt": "2020-11-26T02:04:30Z", "author": {"login": "jtibshirani"}, "path": "docs/reference/search/search-your-data/retrieve-selected-fields.asciidoc", "diffHunk": "@@ -167,7 +167,92 @@ no dedicated array type, and any field could contain multiple values. The\n a specific order. See the mapping documentation on <<array, arrays>> for more\n background.\n \n+[discrete]\n+[[retrieve-unmapped-fields]]\n+==== Retrieving unmapped fields\n+\n+By default, the `fields` parameter returns only values of mapped fields. However,\n+Elasticsearch allows storing fields in `_source` that are unmapped, for example by\n+setting <<dynamic-field-mapping,Dynamic field mapping>> to `false` or by using an\n+object field with `enabled: false`, thereby disabling parsing and indexing of its content.\n+\n+Fields in such an object can be retrieved from `_source` using the `include_unmapped` option\n+in the `fieldS` section:\n+\n+[source,console]\n+----\n+PUT my-index-000001\n+{\n+  \"mappings\": {\n+    \"enabled\": false <1>\n+  }\n+}\n+\n+PUT my-index-000001/_doc/1?refresh=true\n+{\n+  \"user_id\": \"kimchy\",\n+  \"session_data\": {\n+     \"object\": {\n+       \"some_field\": \"some_value\"\n+     }\n+   }\n+}\n+\n+POST my-index-000001/_search\n+{\n+  \"fields\": [\n+    \"user_id\",\n+    {\n+      \"field\": \"session_data.object.*\",\n+      \"include_unmapped\" : true <2>\n+    }\n+  ],\n+  \"_source\": false\n+}\n+----\n+\n+<1> Disable all mappings.\n+<2> Include unmapped fields matching this field pattern.\n \n+The response will contain fields results under the  `session_data.object.*` path even if the\n+fields are unmapped, but will not contain `user_id` since it is unmapped but the `include_unmapped`\n+flag hasn't been set to `true for that field pattern.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bb350e6b1037b17a1ddad75feaffc1c84cb83da"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDczNTkxOQ==", "bodyText": "Maybe we could stick to a nullable Boolean, for consistency with the format parameter and what we do elsewhere in the search builder code?\nIn mapping code I've also seen us use the Explicit class for this purpose (distinguishing between a value that was set explicitly vs. default).", "url": "https://github.com/elastic/elasticsearch/pull/65386#discussion_r530735919", "createdAt": "2020-11-26T02:18:33Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/search/fetch/subphase/FieldAndFormat.java", "diffHunk": "@@ -79,28 +86,44 @@ public XContentBuilder toXContent(XContentBuilder builder, Params params) throws\n     /** The format of the field, or {@code null} if defaults should be used. */\n     public final String format;\n \n-    /** Sole constructor. */\n+    /** Whether to include unmapped fields or not. */\n+    public final Optional<Boolean> includeUnmapped;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bb350e6b1037b17a1ddad75feaffc1c84cb83da"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDczNzE3OQ==", "bodyText": "Looks like includeUnmapped is unused here. Also, the number of addFetchField methods is adding up, some builders like TopHitsAggregationBuilder have three. Maybe we should switch to passing FieldAndFormat directly as an argument? We could still retain a single convenience method like addFetchField(String name).", "url": "https://github.com/elastic/elasticsearch/pull/65386#discussion_r530737179", "createdAt": "2020-11-26T02:23:33Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/action/search/SearchRequestBuilder.java", "diffHunk": "@@ -319,9 +319,10 @@ public SearchRequestBuilder addFetchField(String name) {\n      *\n      * @param name The field to load\n      * @param format an optional format string used when formatting values, for example a date format.\n+     * @param includeUnmapped whether this field pattern should also include unmapped fields\n      */\n-    public SearchRequestBuilder addFetchField(String name, String format) {\n-        sourceBuilder().fetchField(name, format);\n+    public SearchRequestBuilder addFetchField(String name, String format, boolean includeUnmapped) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bb350e6b1037b17a1ddad75feaffc1c84cb83da"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDc0MjI5OA==", "bodyText": "Could we make this a separate check, to keep the original too? Flattened field behavior is tricky and more test coverage is helpful!", "url": "https://github.com/elastic/elasticsearch/pull/65386#discussion_r530742298", "createdAt": "2020-11-26T02:43:17Z", "author": {"login": "jtibshirani"}, "path": "x-pack/plugin/src/test/resources/rest-api-spec/test/flattened/10_basic.yml", "diffHunk": "@@ -150,9 +150,10 @@\n       search:\n         index: test\n         body:\n-          fields: [\"flat*\"]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bb350e6b1037b17a1ddad75feaffc1c84cb83da"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDc0NjYwMw==", "bodyText": "Happy to discuss, my current thinking is that we should omit null values to be consistent with the case where include_unmapped: false.", "url": "https://github.com/elastic/elasticsearch/pull/65386#discussion_r530746603", "createdAt": "2020-11-26T03:00:23Z", "author": {"login": "jtibshirani"}, "path": "server/src/test/java/org/elasticsearch/search/fetch/subphase/FieldFetcherTests.java", "diffHunk": "@@ -394,21 +397,288 @@ public void testTextSubFields() throws IOException {\n         }\n     }\n \n-    private static Map<String, DocumentField> fetchFields(MapperService mapperService, XContentBuilder source, String fieldPattern)\n-        throws IOException {\n+    public void testSimpleUnmappedFields() throws IOException {\n+        MapperService mapperService = createMapperService();\n+\n+        XContentBuilder source = XContentFactory.jsonBuilder().startObject()\n+            .field(\"unmapped_f1\", \"some text\")\n+            .field(\"unmapped_f2\", \"some text\")\n+            .field(\"unmapped_f3\", \"some text\")\n+            .field(\"something_else\", \"some text\")\n+            .nullField(\"null_value\")\n+            .endObject();\n+\n+        Map<String, DocumentField> fields = fetchFields(mapperService, source, \"unmapped_f*\", true);\n+        assertThat(fields.size(), equalTo(3));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"unmapped_f1\", \"unmapped_f2\", \"unmapped_f3\"));\n+\n+        fields = fetchFields(mapperService, source, \"un*1\", true);\n+        assertThat(fields.size(), equalTo(1));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"unmapped_f1\"));\n+\n+        fields = fetchFields(mapperService, source, \"*thing*\", true);\n+        assertThat(fields.size(), equalTo(1));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"something_else\"));\n+\n+        fields = fetchFields(mapperService, source, \"*thing*\", true);\n+        assertThat(fields.size(), equalTo(1));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"something_else\"));\n+\n+        // TODO discuss wether we want to return something here", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bb350e6b1037b17a1ddad75feaffc1c84cb83da"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDc0ODA2MQ==", "bodyText": "Small comment, could this be combined with one of the previous test cases? I'm not sure it tests a new situation.", "url": "https://github.com/elastic/elasticsearch/pull/65386#discussion_r530748061", "createdAt": "2020-11-26T03:06:22Z", "author": {"login": "jtibshirani"}, "path": "server/src/test/java/org/elasticsearch/search/fetch/subphase/FieldFetcherTests.java", "diffHunk": "@@ -394,21 +397,288 @@ public void testTextSubFields() throws IOException {\n         }\n     }\n \n-    private static Map<String, DocumentField> fetchFields(MapperService mapperService, XContentBuilder source, String fieldPattern)\n-        throws IOException {\n+    public void testSimpleUnmappedFields() throws IOException {\n+        MapperService mapperService = createMapperService();\n+\n+        XContentBuilder source = XContentFactory.jsonBuilder().startObject()\n+            .field(\"unmapped_f1\", \"some text\")\n+            .field(\"unmapped_f2\", \"some text\")\n+            .field(\"unmapped_f3\", \"some text\")\n+            .field(\"something_else\", \"some text\")\n+            .nullField(\"null_value\")\n+            .endObject();\n+\n+        Map<String, DocumentField> fields = fetchFields(mapperService, source, \"unmapped_f*\", true);\n+        assertThat(fields.size(), equalTo(3));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"unmapped_f1\", \"unmapped_f2\", \"unmapped_f3\"));\n+\n+        fields = fetchFields(mapperService, source, \"un*1\", true);\n+        assertThat(fields.size(), equalTo(1));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"unmapped_f1\"));\n+\n+        fields = fetchFields(mapperService, source, \"*thing*\", true);\n+        assertThat(fields.size(), equalTo(1));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"something_else\"));\n+\n+        fields = fetchFields(mapperService, source, \"*thing*\", true);\n+        assertThat(fields.size(), equalTo(1));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"something_else\"));\n+\n+        // TODO discuss wether we want to return something here\n+        fields = fetchFields(mapperService, source, \"null*\", true);\n+        assertThat(fields.size(), equalTo(0));\n+        // assertThat(fields.get(\"null_value\").getValue(), equalTo(null));\n+    }\n+\n+    public void testSimpleUnmappedArray() throws IOException {\n+        MapperService mapperService = createMapperService();\n+\n+        XContentBuilder source = XContentFactory.jsonBuilder().startObject()\n+            .array(\"unmapped_field\", \"foo\", \"bar\")\n+            .endObject();\n+\n+        Map<String, DocumentField> fields = fetchFields(mapperService, source, \"unmapped_field\", true);\n+        assertThat(fields.size(), equalTo(1));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"unmapped_field\"));\n+\n+        for (DocumentField field : fields.values()) {\n+            assertThat(field.getValues().size(), equalTo(2));\n+            assertThat(field.getValues().get(0), equalTo(\"foo\"));\n+            assertThat(field.getValues().get(1), equalTo(\"bar\"));\n+        }\n+    }\n+\n+    public void testSimpleUnmappedArrayWithObjects() throws IOException {\n+        MapperService mapperService = createMapperService();\n+\n+        XContentBuilder source = XContentFactory.jsonBuilder().startObject()\n+            .startArray(\"unmapped_field\")\n+                .startObject()\n+                    .field(\"f1\", \"a\")\n+                .endObject()\n+                .startObject()\n+                    .field(\"f2\", \"b\")\n+                .endObject()\n+            .endArray()\n+            .endObject();\n+\n+        Map<String, DocumentField> fields = fetchFields(mapperService, source, \"unmapped_field\", true);\n+        assertThat(fields.size(), equalTo(0));\n+\n+        fields = fetchFields(mapperService, source, \"unmapped_field.f*\", true);\n+        assertThat(fields.size(), equalTo(2));\n+        assertThat(fields.get(\"unmapped_field.f1\").getValue(), equalTo(\"a\"));\n+        assertThat(fields.get(\"unmapped_field.f2\").getValue(), equalTo(\"b\"));\n+\n+        source = XContentFactory.jsonBuilder().startObject()\n+            .startArray(\"unmapped_field\")\n+                .startObject()\n+                    .field(\"f1\", \"a\")\n+                .endObject()\n+                .startObject()\n+                    .field(\"f1\", \"b\") // same field name, this should result in a list returned\n+                .endObject()\n+            .endArray()\n+            .endObject();\n+\n+        fields = fetchFields(mapperService, source, \"unmapped_field.f1\", true);\n+        assertThat(fields.size(), equalTo(1));\n+        DocumentField field = fields.get(\"unmapped_field.f1\");\n+        assertThat(field.getValues().size(), equalTo(2));\n+        assertThat(field.getValues().get(0), equalTo(\"a\"));\n+        assertThat(field.getValues().get(1), equalTo(\"b\"));\n+\n+    }\n+\n+    public void testUnmappedFieldsInsideObject() throws IOException {\n+        XContentBuilder mapping = XContentFactory.jsonBuilder().startObject()\n+            .startObject(\"properties\")\n+                .startObject(\"obj\")\n+                    .field(\"type\", \"object\")\n+                    .field(\"dynamic\", \"false\")\n+                    .startObject(\"properties\")\n+                        .startObject(\"f1\").field(\"type\", \"keyword\").endObject()\n+                    .endObject()\n+                .endObject()\n+            .endObject()\n+        .endObject();\n+\n+        IndexService indexService = createIndex(\"index\", Settings.EMPTY, mapping);\n+        MapperService mapperService = indexService.mapperService();\n+\n+        XContentBuilder source = XContentFactory.jsonBuilder().startObject()\n+            .field(\"obj.f1\", \"value1\")\n+            .field(\"obj.f2\", \"unmapped_value_f2\")\n+            .field(\"obj.innerObj.f3\", \"unmapped_value_f3\")\n+            .field(\"obj.innerObj.f4\", \"unmapped_value_f4\")\n+            .endObject();\n+\n+        Map<String, DocumentField> fields = fetchFields(mapperService, source, \"*\", false);\n+\n+        // without unmapped fields this should only return \"obj.f1\"\n+        assertThat(fields.size(), equalTo(1));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"obj.f1\"));\n+\n+        fields = fetchFields(mapperService, source, \"*\", true);\n+        assertThat(fields.size(), equalTo(4));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"obj.f1\", \"obj.f2\", \"obj.innerObj.f3\", \"obj.innerObj.f4\"));\n+    }\n+\n+    public void testUnmappedFieldsInsideDisabledObject() throws IOException {\n+        XContentBuilder mapping = XContentFactory.jsonBuilder().startObject()\n+            .startObject(\"properties\")\n+                .startObject(\"obj\")\n+                    .field(\"type\", \"object\")\n+                    .field(\"enabled\", \"false\")\n+                .endObject()\n+            .endObject()\n+        .endObject();\n+\n+        IndexService indexService = createIndex(\"index\", Settings.EMPTY, mapping);\n+        MapperService mapperService = indexService.mapperService();\n+\n+        XContentBuilder source = XContentFactory.jsonBuilder().startObject()\n+            .startArray(\"obj\")\n+            .value(\"string_value\")\n+            .startObject()\n+                .field(\"a\", \"b\")\n+            .endObject()\n+            .startArray()\n+                .value(1).value(2).value(3)\n+            .endArray()\n+            .endArray()\n+        .endObject();\n+\n+        Map<String, DocumentField> fields = fetchFields(mapperService, source, \"*\", false);\n+        // without unmapped fields this should return nothing\n+        assertThat(fields.size(), equalTo(0));\n+\n+        fields = fetchFields(mapperService, source, \"*\", true);\n+        assertThat(fields.size(), equalTo(2));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"obj\", \"obj.a\"));\n+\n+        List<Object> obj = fields.get(\"obj\").getValues();\n+        assertEquals(2, obj.size());\n+        assertThat(obj.get(0), instanceOf(String.class));\n+        assertEquals(\"string_value\", obj.get(0).toString());\n+        assertThat(obj.get(1), instanceOf(List.class));\n+        assertEquals(3, ((List<?>) obj.get(1)).size());\n+        assertEquals(\"[1, 2, 3]\", obj.get(1).toString());\n+\n+        List<Object> innerObj = fields.get(\"obj.a\").getValues();\n+        assertEquals(1, innerObj.size());\n+        assertEquals(\"b\", fields.get(\"obj.a\").getValue());\n+    }\n+\n+    /**\n+     * If a mapped field for some reason contains a \"_source\" value that is not returned by the\n+     * mapped retrieval mechanism (e.g. because its malformed), we don't want to fetch it from _source.\n+     */\n+    public void testMappedFieldNotOverwritten() throws IOException {\n+        XContentBuilder mapping = XContentFactory.jsonBuilder().startObject()\n+            .startObject(\"properties\")\n+                .startObject(\"f1\")\n+                    .field(\"type\", \"integer\")\n+                    .field(\"ignore_malformed\", \"true\")\n+                .endObject()\n+            .endObject()\n+        .endObject();\n+\n+        IndexService indexService = createIndex(\"index\", Settings.EMPTY, mapping);\n+        MapperService mapperService = indexService.mapperService();\n \n+        XContentBuilder source = XContentFactory.jsonBuilder().startObject()\n+            .field(\"f1\", \"malformed\")\n+            .endObject();\n+\n+        // this should not return a field bc. f1 is in the ignored fields\n+        Map<String, DocumentField> fields = fetchFields(\n+            mapperService,\n+            source,\n+            List.of(new FieldAndFormat(\"*\", null, Optional.of(true))),\n+            Set.of(\"f1\")\n+        );\n+        assertThat(fields.size(), equalTo(0));\n+\n+        // and this should neither\n+        fields = fetchFields(mapperService, source, List.of(new FieldAndFormat(\"*\", null, Optional.of(true))), Set.of(\"f1\"));\n+        assertThat(fields.size(), equalTo(0));\n+\n+        fields = fetchFields(mapperService, source, List.of(new FieldAndFormat(\"f1\", null, Optional.of(true))), Set.of(\"f1\"));\n+        assertThat(fields.size(), equalTo(0));\n+    }\n+\n+    public void testUnmappedFieldsWildcard() throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bb350e6b1037b17a1ddad75feaffc1c84cb83da"}, "originalPosition": 235}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDc1MjU5Mg==", "bodyText": "Maybe we should define the default of 'false' in a constant to make it easier to find?", "url": "https://github.com/elastic/elasticsearch/pull/65386#discussion_r530752592", "createdAt": "2020-11-26T03:25:13Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/search/fetch/subphase/FieldFetcher.java", "diffHunk": "@@ -45,9 +49,16 @@ public static FieldFetcher create(QueryShardContext context,\n                                       Collection<FieldAndFormat> fieldAndFormats) {\n \n         List<FieldContext> fieldContexts = new ArrayList<>();\n+        List<String> unmappedFetchPattern = new ArrayList<>();\n+        Set<String> mappedToExclude = new HashSet<>();\n+        int i = 0;\n \n         for (FieldAndFormat fieldAndFormat : fieldAndFormats) {\n             String fieldPattern = fieldAndFormat.field;\n+            if (fieldAndFormat.includeUnmapped.orElse(false)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bb350e6b1037b17a1ddad75feaffc1c84cb83da"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDc1Mjc2Mw==", "bodyText": "I think i is unused.", "url": "https://github.com/elastic/elasticsearch/pull/65386#discussion_r530752763", "createdAt": "2020-11-26T03:25:49Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/search/fetch/subphase/FieldFetcher.java", "diffHunk": "@@ -45,9 +49,16 @@ public static FieldFetcher create(QueryShardContext context,\n                                       Collection<FieldAndFormat> fieldAndFormats) {\n \n         List<FieldContext> fieldContexts = new ArrayList<>();\n+        List<String> unmappedFetchPattern = new ArrayList<>();\n+        Set<String> mappedToExclude = new HashSet<>();\n+        int i = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bb350e6b1037b17a1ddad75feaffc1c84cb83da"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDc1MzgxNg==", "bodyText": "To me it'd be clearer to completely skip collectUnmapped if we don't need to handle unmapped fields. We expect this to be the common case, and it would make it clear we won't do extra work.", "url": "https://github.com/elastic/elasticsearch/pull/65386#discussion_r530753816", "createdAt": "2020-11-26T03:30:30Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/search/fetch/subphase/FieldFetcher.java", "diffHunk": "@@ -85,9 +110,83 @@ private FieldFetcher(List<FieldContext> fieldContexts) {\n                 documentFields.put(field, new DocumentField(field, parsedValues));\n             }\n         }\n+        collectUnmapped(documentFields, sourceLookup.loadSourceIfNeeded(), \"\", 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bb350e6b1037b17a1ddad75feaffc1c84cb83da"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDc1NDI2MA==", "bodyText": "For consistency with the other cases, should this add to documentFields instead of returning a new list?", "url": "https://github.com/elastic/elasticsearch/pull/65386#discussion_r530754260", "createdAt": "2020-11-26T03:32:22Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/search/fetch/subphase/FieldFetcher.java", "diffHunk": "@@ -85,9 +110,83 @@ private FieldFetcher(List<FieldContext> fieldContexts) {\n                 documentFields.put(field, new DocumentField(field, parsedValues));\n             }\n         }\n+        collectUnmapped(documentFields, sourceLookup.loadSourceIfNeeded(), \"\", 0);\n         return documentFields;\n     }\n \n+    private void collectUnmapped(Map<String, DocumentField> documentFields, Map<String, Object> source, String parentPath, int lastState) {\n+        for (String key : source.keySet()) {\n+            Object value = source.get(key);\n+            String currentPath = parentPath + key;\n+            int currentState = step(this.unmappedFetchAutomaton, key, lastState);\n+            if (currentState == -1) {\n+                // current path doesn't match any fields pattern\n+                continue;\n+            }\n+            if (value instanceof Map) {\n+                // one step deeper into source tree\n+                collectUnmapped(\n+                    documentFields,\n+                    (Map<String, Object>) value,\n+                    currentPath + \".\",\n+                    step(this.unmappedFetchAutomaton, \".\", currentState)\n+                );\n+            } else if (value instanceof List) {\n+                // iterate through list values\n+                List<Object> list = collectUnmappedList(documentFields, (List<?>) value, currentPath, currentState);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bb350e6b1037b17a1ddad75feaffc1c84cb83da"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDc1NjUzOQ==", "bodyText": "I think we also need to check that the current path isn't part of mappedToExclude, otherwise we could overwrite mapped fields with these values.", "url": "https://github.com/elastic/elasticsearch/pull/65386#discussion_r530756539", "createdAt": "2020-11-26T03:42:18Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/search/fetch/subphase/FieldFetcher.java", "diffHunk": "@@ -85,9 +110,83 @@ private FieldFetcher(List<FieldContext> fieldContexts) {\n                 documentFields.put(field, new DocumentField(field, parsedValues));\n             }\n         }\n+        collectUnmapped(documentFields, sourceLookup.loadSourceIfNeeded(), \"\", 0);\n         return documentFields;\n     }\n \n+    private void collectUnmapped(Map<String, DocumentField> documentFields, Map<String, Object> source, String parentPath, int lastState) {\n+        for (String key : source.keySet()) {\n+            Object value = source.get(key);\n+            String currentPath = parentPath + key;\n+            int currentState = step(this.unmappedFetchAutomaton, key, lastState);\n+            if (currentState == -1) {\n+                // current path doesn't match any fields pattern\n+                continue;\n+            }\n+            if (value instanceof Map) {\n+                // one step deeper into source tree\n+                collectUnmapped(\n+                    documentFields,\n+                    (Map<String, Object>) value,\n+                    currentPath + \".\",\n+                    step(this.unmappedFetchAutomaton, \".\", currentState)\n+                );\n+            } else if (value instanceof List) {\n+                // iterate through list values\n+                List<Object> list = collectUnmappedList(documentFields, (List<?>) value, currentPath, currentState);\n+                if (list.isEmpty() == false) {\n+                    documentFields.put(currentPath, new DocumentField(currentPath, list));\n+                }\n+            } else {\n+                // we have a leaf value\n+                if (this.unmappedFetchAutomaton.isAccept(currentState) && this.mappedToExclude.contains(currentPath) == false) {\n+                    if (value != null) {\n+                        DocumentField currentEntry = documentFields.get(currentPath);\n+                        if (currentEntry == null) {\n+                            List<Object> list = new ArrayList<>();\n+                            list.add(value);\n+                            documentFields.put(currentPath, new DocumentField(currentPath, list));\n+                        } else {\n+                            currentEntry.getValues().add(value);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private List<Object> collectUnmappedList(\n+        Map<String, DocumentField> documentFields,\n+        Iterable<?> iterable,\n+        String parentPath,\n+        int lastState\n+    ) {\n+        List<Object> list = new ArrayList<>();\n+        for (Object value : iterable) {\n+            if (value instanceof Map) {\n+                collectUnmapped(\n+                    documentFields,\n+                    (Map<String, Object>) value,\n+                    parentPath + \".\",\n+                    step(this.unmappedFetchAutomaton, \".\", lastState)\n+                );\n+            } else if (value instanceof List) {\n+                // weird case, but can happen for objects with \"enabled\" : \"false\"\n+                list.add(collectUnmappedList(documentFields, (List<?>) value, parentPath, lastState));\n+            } else if (this.unmappedFetchAutomaton.isAccept(lastState)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bb350e6b1037b17a1ddad75feaffc1c84cb83da"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDc2MTEzNQ==", "bodyText": "Small comment: there's getting to be a lot of convenience methods, maybe we could prefer just constructing and passing in FieldAndFormat?", "url": "https://github.com/elastic/elasticsearch/pull/65386#discussion_r530761135", "createdAt": "2020-11-26T04:02:42Z", "author": {"login": "jtibshirani"}, "path": "server/src/test/java/org/elasticsearch/search/fetch/subphase/FieldFetcherTests.java", "diffHunk": "@@ -394,21 +397,288 @@ public void testTextSubFields() throws IOException {\n         }\n     }\n \n-    private static Map<String, DocumentField> fetchFields(MapperService mapperService, XContentBuilder source, String fieldPattern)\n-        throws IOException {\n+    public void testSimpleUnmappedFields() throws IOException {\n+        MapperService mapperService = createMapperService();\n+\n+        XContentBuilder source = XContentFactory.jsonBuilder().startObject()\n+            .field(\"unmapped_f1\", \"some text\")\n+            .field(\"unmapped_f2\", \"some text\")\n+            .field(\"unmapped_f3\", \"some text\")\n+            .field(\"something_else\", \"some text\")\n+            .nullField(\"null_value\")\n+            .endObject();\n+\n+        Map<String, DocumentField> fields = fetchFields(mapperService, source, \"unmapped_f*\", true);\n+        assertThat(fields.size(), equalTo(3));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"unmapped_f1\", \"unmapped_f2\", \"unmapped_f3\"));\n+\n+        fields = fetchFields(mapperService, source, \"un*1\", true);\n+        assertThat(fields.size(), equalTo(1));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"unmapped_f1\"));\n+\n+        fields = fetchFields(mapperService, source, \"*thing*\", true);\n+        assertThat(fields.size(), equalTo(1));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"something_else\"));\n+\n+        fields = fetchFields(mapperService, source, \"*thing*\", true);\n+        assertThat(fields.size(), equalTo(1));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"something_else\"));\n+\n+        // TODO discuss wether we want to return something here\n+        fields = fetchFields(mapperService, source, \"null*\", true);\n+        assertThat(fields.size(), equalTo(0));\n+        // assertThat(fields.get(\"null_value\").getValue(), equalTo(null));\n+    }\n+\n+    public void testSimpleUnmappedArray() throws IOException {\n+        MapperService mapperService = createMapperService();\n+\n+        XContentBuilder source = XContentFactory.jsonBuilder().startObject()\n+            .array(\"unmapped_field\", \"foo\", \"bar\")\n+            .endObject();\n+\n+        Map<String, DocumentField> fields = fetchFields(mapperService, source, \"unmapped_field\", true);\n+        assertThat(fields.size(), equalTo(1));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"unmapped_field\"));\n+\n+        for (DocumentField field : fields.values()) {\n+            assertThat(field.getValues().size(), equalTo(2));\n+            assertThat(field.getValues().get(0), equalTo(\"foo\"));\n+            assertThat(field.getValues().get(1), equalTo(\"bar\"));\n+        }\n+    }\n+\n+    public void testSimpleUnmappedArrayWithObjects() throws IOException {\n+        MapperService mapperService = createMapperService();\n+\n+        XContentBuilder source = XContentFactory.jsonBuilder().startObject()\n+            .startArray(\"unmapped_field\")\n+                .startObject()\n+                    .field(\"f1\", \"a\")\n+                .endObject()\n+                .startObject()\n+                    .field(\"f2\", \"b\")\n+                .endObject()\n+            .endArray()\n+            .endObject();\n+\n+        Map<String, DocumentField> fields = fetchFields(mapperService, source, \"unmapped_field\", true);\n+        assertThat(fields.size(), equalTo(0));\n+\n+        fields = fetchFields(mapperService, source, \"unmapped_field.f*\", true);\n+        assertThat(fields.size(), equalTo(2));\n+        assertThat(fields.get(\"unmapped_field.f1\").getValue(), equalTo(\"a\"));\n+        assertThat(fields.get(\"unmapped_field.f2\").getValue(), equalTo(\"b\"));\n+\n+        source = XContentFactory.jsonBuilder().startObject()\n+            .startArray(\"unmapped_field\")\n+                .startObject()\n+                    .field(\"f1\", \"a\")\n+                .endObject()\n+                .startObject()\n+                    .field(\"f1\", \"b\") // same field name, this should result in a list returned\n+                .endObject()\n+            .endArray()\n+            .endObject();\n+\n+        fields = fetchFields(mapperService, source, \"unmapped_field.f1\", true);\n+        assertThat(fields.size(), equalTo(1));\n+        DocumentField field = fields.get(\"unmapped_field.f1\");\n+        assertThat(field.getValues().size(), equalTo(2));\n+        assertThat(field.getValues().get(0), equalTo(\"a\"));\n+        assertThat(field.getValues().get(1), equalTo(\"b\"));\n+\n+    }\n+\n+    public void testUnmappedFieldsInsideObject() throws IOException {\n+        XContentBuilder mapping = XContentFactory.jsonBuilder().startObject()\n+            .startObject(\"properties\")\n+                .startObject(\"obj\")\n+                    .field(\"type\", \"object\")\n+                    .field(\"dynamic\", \"false\")\n+                    .startObject(\"properties\")\n+                        .startObject(\"f1\").field(\"type\", \"keyword\").endObject()\n+                    .endObject()\n+                .endObject()\n+            .endObject()\n+        .endObject();\n+\n+        IndexService indexService = createIndex(\"index\", Settings.EMPTY, mapping);\n+        MapperService mapperService = indexService.mapperService();\n+\n+        XContentBuilder source = XContentFactory.jsonBuilder().startObject()\n+            .field(\"obj.f1\", \"value1\")\n+            .field(\"obj.f2\", \"unmapped_value_f2\")\n+            .field(\"obj.innerObj.f3\", \"unmapped_value_f3\")\n+            .field(\"obj.innerObj.f4\", \"unmapped_value_f4\")\n+            .endObject();\n+\n+        Map<String, DocumentField> fields = fetchFields(mapperService, source, \"*\", false);\n+\n+        // without unmapped fields this should only return \"obj.f1\"\n+        assertThat(fields.size(), equalTo(1));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"obj.f1\"));\n+\n+        fields = fetchFields(mapperService, source, \"*\", true);\n+        assertThat(fields.size(), equalTo(4));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"obj.f1\", \"obj.f2\", \"obj.innerObj.f3\", \"obj.innerObj.f4\"));\n+    }\n+\n+    public void testUnmappedFieldsInsideDisabledObject() throws IOException {\n+        XContentBuilder mapping = XContentFactory.jsonBuilder().startObject()\n+            .startObject(\"properties\")\n+                .startObject(\"obj\")\n+                    .field(\"type\", \"object\")\n+                    .field(\"enabled\", \"false\")\n+                .endObject()\n+            .endObject()\n+        .endObject();\n+\n+        IndexService indexService = createIndex(\"index\", Settings.EMPTY, mapping);\n+        MapperService mapperService = indexService.mapperService();\n+\n+        XContentBuilder source = XContentFactory.jsonBuilder().startObject()\n+            .startArray(\"obj\")\n+            .value(\"string_value\")\n+            .startObject()\n+                .field(\"a\", \"b\")\n+            .endObject()\n+            .startArray()\n+                .value(1).value(2).value(3)\n+            .endArray()\n+            .endArray()\n+        .endObject();\n+\n+        Map<String, DocumentField> fields = fetchFields(mapperService, source, \"*\", false);\n+        // without unmapped fields this should return nothing\n+        assertThat(fields.size(), equalTo(0));\n+\n+        fields = fetchFields(mapperService, source, \"*\", true);\n+        assertThat(fields.size(), equalTo(2));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"obj\", \"obj.a\"));\n+\n+        List<Object> obj = fields.get(\"obj\").getValues();\n+        assertEquals(2, obj.size());\n+        assertThat(obj.get(0), instanceOf(String.class));\n+        assertEquals(\"string_value\", obj.get(0).toString());\n+        assertThat(obj.get(1), instanceOf(List.class));\n+        assertEquals(3, ((List<?>) obj.get(1)).size());\n+        assertEquals(\"[1, 2, 3]\", obj.get(1).toString());\n+\n+        List<Object> innerObj = fields.get(\"obj.a\").getValues();\n+        assertEquals(1, innerObj.size());\n+        assertEquals(\"b\", fields.get(\"obj.a\").getValue());\n+    }\n+\n+    /**\n+     * If a mapped field for some reason contains a \"_source\" value that is not returned by the\n+     * mapped retrieval mechanism (e.g. because its malformed), we don't want to fetch it from _source.\n+     */\n+    public void testMappedFieldNotOverwritten() throws IOException {\n+        XContentBuilder mapping = XContentFactory.jsonBuilder().startObject()\n+            .startObject(\"properties\")\n+                .startObject(\"f1\")\n+                    .field(\"type\", \"integer\")\n+                    .field(\"ignore_malformed\", \"true\")\n+                .endObject()\n+            .endObject()\n+        .endObject();\n+\n+        IndexService indexService = createIndex(\"index\", Settings.EMPTY, mapping);\n+        MapperService mapperService = indexService.mapperService();\n \n+        XContentBuilder source = XContentFactory.jsonBuilder().startObject()\n+            .field(\"f1\", \"malformed\")\n+            .endObject();\n+\n+        // this should not return a field bc. f1 is in the ignored fields\n+        Map<String, DocumentField> fields = fetchFields(\n+            mapperService,\n+            source,\n+            List.of(new FieldAndFormat(\"*\", null, Optional.of(true))),\n+            Set.of(\"f1\")\n+        );\n+        assertThat(fields.size(), equalTo(0));\n+\n+        // and this should neither\n+        fields = fetchFields(mapperService, source, List.of(new FieldAndFormat(\"*\", null, Optional.of(true))), Set.of(\"f1\"));\n+        assertThat(fields.size(), equalTo(0));\n+\n+        fields = fetchFields(mapperService, source, List.of(new FieldAndFormat(\"f1\", null, Optional.of(true))), Set.of(\"f1\"));\n+        assertThat(fields.size(), equalTo(0));\n+    }\n+\n+    public void testUnmappedFieldsWildcard() throws IOException {\n+        MapperService mapperService = createMapperService();\n+\n+        XContentBuilder source = XContentFactory.jsonBuilder().startObject()\n+            .startObject(\"unmapped_object\")\n+                .field(\"a\", \"foo\")\n+                .field(\"b\", \"bar\")\n+            .endObject()\n+            .endObject();\n+\n+        Map<String, DocumentField> fields = fetchFields(mapperService, source, \"unmapped_object\", true);\n+        assertThat(fields.size(), equalTo(0));\n+\n+        fields = fetchFields(mapperService, source, \"unmap*object\", true);\n+        assertThat(fields.size(), equalTo(0));\n+\n+        fields = fetchFields(mapperService, source, \"unmapped_object.*\", true);\n+        assertThat(fields.size(), equalTo(2));\n+        assertThat(fields.keySet(), containsInAnyOrder(\"unmapped_object.a\", \"unmapped_object.b\"));\n+\n+        assertThat(fields.get(\"unmapped_object.a\").getValue(), equalTo(\"foo\"));\n+        assertThat(fields.get(\"unmapped_object.b\").getValue(), equalTo(\"bar\"));\n+\n+        fields = fetchFields(mapperService, source, \"unmapped_object.a\", true);\n+        assertThat(fields.size(), equalTo(1));\n+        assertThat(fields.get(\"unmapped_object.a\").getValue(), equalTo(\"foo\"));\n+\n+        fields = fetchFields(mapperService, source, \"unmapped_object.b\", true);\n+        assertThat(fields.size(), equalTo(1));\n+        assertThat(fields.get(\"unmapped_object.b\").getValue(), equalTo(\"bar\"));\n+    }\n+\n+    private Map<String, DocumentField> fetchFields(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bb350e6b1037b17a1ddad75feaffc1c84cb83da"}, "originalPosition": 267}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDc2MTE1NQ==", "bodyText": "Nice test coverage! Some other cases that'd be good to check:\n\nSource documents that have dots in field names (like unmapped_field.a: value).\nMixed dot and object notation. We recently found a bug in the 'fields' option related to this: #65499.", "url": "https://github.com/elastic/elasticsearch/pull/65386#discussion_r530761155", "createdAt": "2020-11-26T04:02:49Z", "author": {"login": "jtibshirani"}, "path": "server/src/test/java/org/elasticsearch/search/fetch/subphase/FieldFetcherTests.java", "diffHunk": "@@ -394,21 +397,288 @@ public void testTextSubFields() throws IOException {\n         }\n     }\n \n-    private static Map<String, DocumentField> fetchFields(MapperService mapperService, XContentBuilder source, String fieldPattern)\n-        throws IOException {\n+    public void testSimpleUnmappedFields() throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bb350e6b1037b17a1ddad75feaffc1c84cb83da"}, "originalPosition": 24}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "102cde17e00938af7e90d70c5b2a6d4c3d3c5718", "author": {"user": {"login": "cbuescher", "name": "Christoph B\u00fcscher"}}, "url": "https://github.com/elastic/elasticsearch/commit/102cde17e00938af7e90d70c5b2a6d4c3d3c5718", "committedDate": "2020-11-26T18:52:13Z", "message": "Iter"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxNDI2ODAw", "url": "https://github.com/elastic/elasticsearch/pull/65386#pullrequestreview-541426800", "createdAt": "2020-12-01T01:40:28Z", "commit": {"oid": "102cde17e00938af7e90d70c5b2a6d4c3d3c5718"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwMTo0MDoyOVrOH8Uw_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwMTo0MzoxNVrOH8U0Lg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAxNjgzMA==", "bodyText": "I just noticed -- maybe we could switch fieldContexts to a LinkedHashMap? Then we could consult its key set and avoid creating this new set mappedToExclude. I could tackle this in a follow-up though, to keep this PR small.", "url": "https://github.com/elastic/elasticsearch/pull/65386#discussion_r533016830", "createdAt": "2020-12-01T01:40:29Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/search/fetch/subphase/FieldFetcher.java", "diffHunk": "@@ -78,21 +78,24 @@ public static FieldFetcher create(QueryShardContext context,\n                 Regex.simpleMatchToAutomaton(unmappedFetchPattern.toArray(new String[unmappedFetchPattern.size()]))\n             );\n         }\n-        return new FieldFetcher(fieldContexts, unmappedFetchAutomaton, mappedToExclude);\n+        return new FieldFetcher(fieldContexts, unmappedFetchAutomaton, mappedToExclude, includeUnmapped);\n     }\n \n     private final List<FieldContext> fieldContexts;\n     private final CharacterRunAutomaton unmappedFetchAutomaton;\n     private final Set<String> mappedToExclude;\n+    private final boolean includeUnmapped;\n \n     private FieldFetcher(\n         List<FieldContext> fieldContexts,\n         CharacterRunAutomaton unmappedFetchAutomaton,\n-        Set<String> mappedToExclude\n+        Set<String> mappedToExclude,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "102cde17e00938af7e90d70c5b2a6d4c3d3c5718"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAxNzY0Ng==", "bodyText": "Sorry for the confusion -- I didn't spot a behavioral bug, I just found the API choice surprising. The collectUnmappedList method returns a list, but collectUnmapped adds directly to the document fields map. I was wondering if there needs to be a difference?\nAnd your understanding looks right, thanks for adding more tests to confirm those cases.", "url": "https://github.com/elastic/elasticsearch/pull/65386#discussion_r533017646", "createdAt": "2020-12-01T01:43:15Z", "author": {"login": "jtibshirani"}, "path": "server/src/main/java/org/elasticsearch/search/fetch/subphase/FieldFetcher.java", "diffHunk": "@@ -85,9 +110,83 @@ private FieldFetcher(List<FieldContext> fieldContexts) {\n                 documentFields.put(field, new DocumentField(field, parsedValues));\n             }\n         }\n+        collectUnmapped(documentFields, sourceLookup.loadSourceIfNeeded(), \"\", 0);\n         return documentFields;\n     }\n \n+    private void collectUnmapped(Map<String, DocumentField> documentFields, Map<String, Object> source, String parentPath, int lastState) {\n+        for (String key : source.keySet()) {\n+            Object value = source.get(key);\n+            String currentPath = parentPath + key;\n+            int currentState = step(this.unmappedFetchAutomaton, key, lastState);\n+            if (currentState == -1) {\n+                // current path doesn't match any fields pattern\n+                continue;\n+            }\n+            if (value instanceof Map) {\n+                // one step deeper into source tree\n+                collectUnmapped(\n+                    documentFields,\n+                    (Map<String, Object>) value,\n+                    currentPath + \".\",\n+                    step(this.unmappedFetchAutomaton, \".\", currentState)\n+                );\n+            } else if (value instanceof List) {\n+                // iterate through list values\n+                List<Object> list = collectUnmappedList(documentFields, (List<?>) value, currentPath, currentState);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDc1NDI2MA=="}, "originalCommit": {"oid": "7bb350e6b1037b17a1ddad75feaffc1c84cb83da"}, "originalPosition": 99}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxNDMxMTI4", "url": "https://github.com/elastic/elasticsearch/pull/65386#pullrequestreview-541431128", "createdAt": "2020-12-01T01:53:05Z", "commit": {"oid": "102cde17e00938af7e90d70c5b2a6d4c3d3c5718"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwMTo1MzowNVrOH8VAwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwMTo1MzowNVrOH8VAwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAyMDg2NA==", "bodyText": "Small comment, we don't actually guarantee the values come back in the original order. So maybe we should check through something like assertThat(field.getValues(), hasItems(...)).", "url": "https://github.com/elastic/elasticsearch/pull/65386#discussion_r533020864", "createdAt": "2020-12-01T01:53:05Z", "author": {"login": "jtibshirani"}, "path": "server/src/test/java/org/elasticsearch/search/fetch/subphase/FieldFetcherTests.java", "diffHunk": "@@ -474,20 +482,40 @@ public void testSimpleUnmappedArrayWithObjects() throws IOException {\n             .startArray(\"unmapped_field\")\n                 .startObject()\n                     .field(\"f1\", \"a\")\n+                    .array(\"f2\", 1, 2)\n+                    .array(\"f3\", 1, 2)\n                 .endObject()\n                 .startObject()\n                     .field(\"f1\", \"b\") // same field name, this should result in a list returned\n+                    .array(\"f2\", 3, 4)\n+                    .array(\"f3\", \"foo\")\n                 .endObject()\n             .endArray()\n             .endObject();\n \n-        fields = fetchFields(mapperService, source, \"unmapped_field.f1\", true);\n+        fields = fetchFields(mapperService, source, fieldAndFormatList(\"unmapped_field.f1\", null, true), null);\n         assertThat(fields.size(), equalTo(1));\n         DocumentField field = fields.get(\"unmapped_field.f1\");\n         assertThat(field.getValues().size(), equalTo(2));\n         assertThat(field.getValues().get(0), equalTo(\"a\"));\n         assertThat(field.getValues().get(1), equalTo(\"b\"));\n \n+        fields = fetchFields(mapperService, source, fieldAndFormatList(\"unmapped_field.f2\", null, true), null);\n+        assertThat(fields.size(), equalTo(1));\n+        field = fields.get(\"unmapped_field.f2\");\n+        assertThat(field.getValues().size(), equalTo(4));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "102cde17e00938af7e90d70c5b2a6d4c3d3c5718"}, "originalPosition": 140}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5078d3411fcf6edb2fd4540aa7fb3832e7649ad6", "author": {"user": {"login": "cbuescher", "name": "Christoph B\u00fcscher"}}, "url": "https://github.com/elastic/elasticsearch/commit/5078d3411fcf6edb2fd4540aa7fb3832e7649ad6", "committedDate": "2020-12-01T10:41:16Z", "message": "change test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "81db762f58f793fffa0a003fdf5eca917a43e973", "author": {"user": {"login": "cbuescher", "name": "Christoph B\u00fcscher"}}, "url": "https://github.com/elastic/elasticsearch/commit/81db762f58f793fffa0a003fdf5eca917a43e973", "committedDate": "2020-12-01T10:53:58Z", "message": "Merge branch 'master' into unmapped-fields-63690"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2271fdd5ac16e78d86d59eaa246d7b09cddf2cad", "author": {"user": {"login": "cbuescher", "name": "Christoph B\u00fcscher"}}, "url": "https://github.com/elastic/elasticsearch/commit/2271fdd5ac16e78d86d59eaa246d7b09cddf2cad", "committedDate": "2020-12-01T12:17:02Z", "message": "Add skip to yaml test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQyMTMyNDIz", "url": "https://github.com/elastic/elasticsearch/pull/65386#pullrequestreview-542132423", "createdAt": "2020-12-01T17:26:49Z", "commit": {"oid": "2271fdd5ac16e78d86d59eaa246d7b09cddf2cad"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5206e7fcc9c054f18ef5196de828f14569358bca", "author": {"user": {"login": "cbuescher", "name": "Christoph B\u00fcscher"}}, "url": "https://github.com/elastic/elasticsearch/commit/5206e7fcc9c054f18ef5196de828f14569358bca", "committedDate": "2020-12-01T19:22:05Z", "message": "Change collectUnmappedList return type"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQyMjI1MzQ0", "url": "https://github.com/elastic/elasticsearch/pull/65386#pullrequestreview-542225344", "createdAt": "2020-12-01T19:27:02Z", "commit": {"oid": "5206e7fcc9c054f18ef5196de828f14569358bca"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "42f3c1c344a444d01ca378883edf8e7264b13d4e", "author": {"user": {"login": "cbuescher", "name": "Christoph B\u00fcscher"}}, "url": "https://github.com/elastic/elasticsearch/commit/42f3c1c344a444d01ca378883edf8e7264b13d4e", "committedDate": "2020-12-01T19:59:02Z", "message": "Correct yaml test"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4402, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}