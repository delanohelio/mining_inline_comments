{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIzOTAxNTAx", "number": 65256, "title": "Phase 1 support for operator privileges", "bodyText": "In some Elastic Stack environments, there is a distinction between the operator of the cluster infrastructure and the administrator of the cluster. This distinction cannot be supported currently because the \"administrator\" often has the superuser role which grants each and every privilege of the cluster.\nThis PR adds a new feature to protect a fixed set of APIs from the \"administrator\" even when it is a highly privileged user such as superuser. It enhances the Elasticsearch security model to have an additional layer of restriction in addition to the RBAC.", "createdAt": "2020-11-19T12:06:20Z", "url": "https://github.com/elastic/elasticsearch/pull/65256", "merged": true, "mergeCommit": {"oid": "def2f2777bf5c1c357d1aa34dc7ff93000580383"}, "closed": true, "closedAt": "2020-12-03T05:49:34Z", "author": {"login": "ywangd"}, "timelineItems": {"totalCount": 34, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdfS4_vAH2gAyNTIzOTAxNTAxOjQ5NjYzNjVhZGJlNjhlZmRkZTg0MDg4YmIxYWZlMGNhMjUzZmNmYjg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdibfEdAH2gAyNTIzOTAxNTAxOjU4MDdiMzMwY2IzMTA4NTg3ODBjYTgwOGU2ZmU1MWE1NWE0NzRlZTg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "4966365adbe68efdde84088bb1afe0ca253fcfb8", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/4966365adbe68efdde84088bb1afe0ca253fcfb8", "committedDate": "2020-11-23T10:49:26Z", "message": "WIP: operator privileges initial working code with smoke tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b1bd83c888581993697e807c11bc6ec4ea4fab28", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/b1bd83c888581993697e807c11bc6ec4ea4fab28", "committedDate": "2020-11-19T11:58:55Z", "message": "WIP: operator privileges initial working code with smoke tests"}, "afterCommit": {"oid": "96ccc048e65339698920f94c1f56323212320bc2", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/96ccc048e65339698920f94c1f56323212320bc2", "committedDate": "2020-11-23T13:00:13Z", "message": "WIP: working on tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "96ccc048e65339698920f94c1f56323212320bc2", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/96ccc048e65339698920f94c1f56323212320bc2", "committedDate": "2020-11-23T13:00:13Z", "message": "WIP: working on tests"}, "afterCommit": {"oid": "ceef13c8444ffc4cabf31e8450004048abec7b0a", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/ceef13c8444ffc4cabf31e8450004048abec7b0a", "committedDate": "2020-11-23T23:54:59Z", "message": "WIP: working on tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3d5f3b0417388819e4bc8bef73cc76321b16e046", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/3d5f3b0417388819e4bc8bef73cc76321b16e046", "committedDate": "2020-11-24T01:18:23Z", "message": "WIP: working on tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ceef13c8444ffc4cabf31e8450004048abec7b0a", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/ceef13c8444ffc4cabf31e8450004048abec7b0a", "committedDate": "2020-11-23T23:54:59Z", "message": "WIP: working on tests"}, "afterCommit": {"oid": "3d5f3b0417388819e4bc8bef73cc76321b16e046", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/3d5f3b0417388819e4bc8bef73cc76321b16e046", "committedDate": "2020-11-24T01:18:23Z", "message": "WIP: working on tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM3MDcwMjYw", "url": "https://github.com/elastic/elasticsearch/pull/65256#pullrequestreview-537070260", "createdAt": "2020-11-24T04:32:04Z", "commit": {"oid": "3d5f3b0417388819e4bc8bef73cc76321b16e046"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwNDozMjowNFrOH4ri0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwNDozMjowNFrOH4ri0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE5NTcyOQ==", "bodyText": "Other than adding the new enum here, what else is needed for telemetry? The XPackUsageFeatureAction is for feature usage which means billing and is not telemetry?", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r529195729", "createdAt": "2020-11-24T04:32:04Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/license/XPackLicenseState.java", "diffHunk": "@@ -98,7 +98,9 @@\n \n         ANALYTICS(OperationMode.MISSING, true),\n \n-        SEARCHABLE_SNAPSHOTS(OperationMode.ENTERPRISE, true);\n+        SEARCHABLE_SNAPSHOTS(OperationMode.ENTERPRISE, true),\n+\n+        OPERATOR_PRIVILEGES(OperationMode.ENTERPRISE, true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d5f3b0417388819e4bc8bef73cc76321b16e046"}, "originalPosition": 7}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cd5f33999d1edbb12a58c9bdfda5e97b7cf9379c", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/cd5f33999d1edbb12a58c9bdfda5e97b7cf9379c", "committedDate": "2020-11-24T05:07:47Z", "message": "Remove unnecessary file"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9834e47680d6aeec804f98807566a2727a543e04", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/9834e47680d6aeec804f98807566a2727a543e04", "committedDate": "2020-11-24T05:22:19Z", "message": "Use javaRestTest instead of test to align with recent changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9b63010318840d5ccd19ca3b4242b25c4d39942c", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/9b63010318840d5ccd19ca3b4242b25c4d39942c", "committedDate": "2020-11-24T08:14:18Z", "message": "Add a test plugin to ensure every action is declared either operator-only or not"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "be893ec7f85f2080676bedd20b3b97cfbbd8fb26", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/be893ec7f85f2080676bedd20b3b97cfbbd8fb26", "committedDate": "2020-11-24T09:01:44Z", "message": "spotless"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2d66a057b26a5eb605e0d0fb7eaa4e04fbcb2016", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/2d66a057b26a5eb605e0d0fb7eaa4e04fbcb2016", "committedDate": "2020-11-24T09:37:15Z", "message": "testingConventions test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM3MDcxMjEy", "url": "https://github.com/elastic/elasticsearch/pull/65256#pullrequestreview-537071212", "createdAt": "2020-11-24T04:34:56Z", "commit": {"oid": "3d5f3b0417388819e4bc8bef73cc76321b16e046"}, "state": "COMMENTED", "comments": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwNDozNDo1NlrOH4rmIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwNToxNDozM1rOH5jhCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE5NjU3OQ==", "bodyText": "XPackUsageFeatureAction is telemetry, not billing.\nBilling is GetFeatureUsageResponse.FeatureUsageInfo", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r529196579", "createdAt": "2020-11-24T04:34:56Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/license/XPackLicenseState.java", "diffHunk": "@@ -98,7 +98,9 @@\n \n         ANALYTICS(OperationMode.MISSING, true),\n \n-        SEARCHABLE_SNAPSHOTS(OperationMode.ENTERPRISE, true);\n+        SEARCHABLE_SNAPSHOTS(OperationMode.ENTERPRISE, true),\n+\n+        OPERATOR_PRIVILEGES(OperationMode.ENTERPRISE, true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE5NTcyOQ=="}, "originalCommit": {"oid": "3d5f3b0417388819e4bc8bef73cc76321b16e046"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE5Njg0MA==", "bodyText": "Can you explain?", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r529196840", "createdAt": "2020-11-24T04:35:49Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/internalClusterTest/java/org/elasticsearch/xpack/security/operator/NonOperatorOnlyActions.java", "diffHunk": "@@ -0,0 +1,13 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.operator;\n+\n+class NonOperatorOnlyActions {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d5f3b0417388819e4bc8bef73cc76321b16e046"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTIwMzQ1OQ==", "bodyText": "It's minor, but I find that to be a weird way to express containsNone (or not containsAny).\nAlso, it's going to be hard to debug if it fails.\nIf it were me, I'd implement a custom hasAny() matcher, and wrap it in a not", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r529203459", "createdAt": "2020-11-24T04:58:55Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/internalClusterTest/java/org/elasticsearch/xpack/security/operator/OperatorPrivilegesSingleNodeTests.java", "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.operator;\n+\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.action.admin.cluster.configuration.ClearVotingConfigExclusionsAction;\n+import org.elasticsearch.action.admin.cluster.configuration.ClearVotingConfigExclusionsRequest;\n+import org.elasticsearch.action.support.TransportAction;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.common.inject.Binding;\n+import org.elasticsearch.common.inject.Injector;\n+import org.elasticsearch.common.inject.TypeLiteral;\n+import org.elasticsearch.common.settings.SecureString;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.set.Sets;\n+import org.elasticsearch.test.SecuritySingleNodeTestCase;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.elasticsearch.test.SecuritySettingsSource.TEST_PASSWORD_HASHED;\n+import static org.elasticsearch.test.SecuritySettingsSourceField.TEST_PASSWORD;\n+import static org.elasticsearch.xpack.core.security.authc.support.UsernamePasswordToken.basicAuthHeaderValue;\n+import static org.hamcrest.Matchers.containsString;\n+\n+public class OperatorPrivilegesSingleNodeTests extends SecuritySingleNodeTestCase {\n+\n+    private static final String OPERATOR_USER_NAME = \"test_operator\";\n+\n+    @Override\n+    protected String configUsers() {\n+        return super.configUsers()\n+            + OPERATOR_USER_NAME + \":\" + TEST_PASSWORD_HASHED + \"\\n\";\n+    }\n+\n+    @Override\n+    protected String configRoles() {\n+        return super.configRoles()\n+            + \"limited_operator:\\n\"\n+            + \"  cluster:\\n\"\n+            + \"    - 'cluster:admin/voting_config/clear_exclusions'\\n\"\n+            + \"    - 'monitor'\\n\";\n+    }\n+\n+    @Override\n+    protected String configUsersRoles() {\n+        return super.configUsersRoles()\n+            + \"limited_operator:\" + OPERATOR_USER_NAME + \"\\n\";\n+    }\n+\n+    @Override\n+    protected String configOperatorUsers() {\n+        return super.configOperatorUsers()\n+            + \"operator:\\n\"\n+            + \"  - usernames: ['\" + OPERATOR_USER_NAME + \"']\\n\";\n+    }\n+\n+    @Override\n+    protected Settings nodeSettings() {\n+        Settings.Builder builder = Settings.builder().put(super.nodeSettings());\n+        // Ensure the new settings can be configured\n+        builder.put(\"xpack.security.operator_privileges.enabled\", \"true\");\n+        return builder.build();\n+    }\n+\n+    // TODO: Not all plugins are available in internal cluster tests. Hence not all action names can be checked.\n+    public void testActionsAreEitherOperatorOnlyOrNot() {\n+        final Injector injector = node().injector();\n+        final List<Binding<TransportAction>> bindings = injector.findBindingsByType(TypeLiteral.get(TransportAction.class));\n+\n+        final List<String> allActionNames = new ArrayList<>(bindings.size());\n+        for (final Binding<TransportAction> binding : bindings) {\n+            allActionNames.add(binding.getProvider().get().actionName);\n+        }\n+\n+        final Set<String> nonOperatorActions = Set.of(NON_OPERATOR_ACTIONS);\n+        final Set<String> expectedOperatorOnlyActions = Sets.difference(Set.copyOf(allActionNames), nonOperatorActions);\n+        final Set<String> actualOperatorOnlyActions = new HashSet<>(CompositeOperatorOnly.ActionOperatorOnly.SIMPLE_ACTIONS);\n+        assertTrue(actualOperatorOnlyActions.containsAll(expectedOperatorOnlyActions));\n+        assertFalse(actualOperatorOnlyActions.removeAll(nonOperatorActions));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d5f3b0417388819e4bc8bef73cc76321b16e046"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTIwNDEzNg==", "bodyText": "Should we have this method too?\npublic void testOperatorUserIsStillSubjectToRoleLimits()", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r529204136", "createdAt": "2020-11-24T05:01:12Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/internalClusterTest/java/org/elasticsearch/xpack/security/operator/OperatorPrivilegesSingleNodeTests.java", "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.operator;\n+\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.action.admin.cluster.configuration.ClearVotingConfigExclusionsAction;\n+import org.elasticsearch.action.admin.cluster.configuration.ClearVotingConfigExclusionsRequest;\n+import org.elasticsearch.action.support.TransportAction;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.common.inject.Binding;\n+import org.elasticsearch.common.inject.Injector;\n+import org.elasticsearch.common.inject.TypeLiteral;\n+import org.elasticsearch.common.settings.SecureString;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.set.Sets;\n+import org.elasticsearch.test.SecuritySingleNodeTestCase;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.elasticsearch.test.SecuritySettingsSource.TEST_PASSWORD_HASHED;\n+import static org.elasticsearch.test.SecuritySettingsSourceField.TEST_PASSWORD;\n+import static org.elasticsearch.xpack.core.security.authc.support.UsernamePasswordToken.basicAuthHeaderValue;\n+import static org.hamcrest.Matchers.containsString;\n+\n+public class OperatorPrivilegesSingleNodeTests extends SecuritySingleNodeTestCase {\n+\n+    private static final String OPERATOR_USER_NAME = \"test_operator\";\n+\n+    @Override\n+    protected String configUsers() {\n+        return super.configUsers()\n+            + OPERATOR_USER_NAME + \":\" + TEST_PASSWORD_HASHED + \"\\n\";\n+    }\n+\n+    @Override\n+    protected String configRoles() {\n+        return super.configRoles()\n+            + \"limited_operator:\\n\"\n+            + \"  cluster:\\n\"\n+            + \"    - 'cluster:admin/voting_config/clear_exclusions'\\n\"\n+            + \"    - 'monitor'\\n\";\n+    }\n+\n+    @Override\n+    protected String configUsersRoles() {\n+        return super.configUsersRoles()\n+            + \"limited_operator:\" + OPERATOR_USER_NAME + \"\\n\";\n+    }\n+\n+    @Override\n+    protected String configOperatorUsers() {\n+        return super.configOperatorUsers()\n+            + \"operator:\\n\"\n+            + \"  - usernames: ['\" + OPERATOR_USER_NAME + \"']\\n\";\n+    }\n+\n+    @Override\n+    protected Settings nodeSettings() {\n+        Settings.Builder builder = Settings.builder().put(super.nodeSettings());\n+        // Ensure the new settings can be configured\n+        builder.put(\"xpack.security.operator_privileges.enabled\", \"true\");\n+        return builder.build();\n+    }\n+\n+    // TODO: Not all plugins are available in internal cluster tests. Hence not all action names can be checked.\n+    public void testActionsAreEitherOperatorOnlyOrNot() {\n+        final Injector injector = node().injector();\n+        final List<Binding<TransportAction>> bindings = injector.findBindingsByType(TypeLiteral.get(TransportAction.class));\n+\n+        final List<String> allActionNames = new ArrayList<>(bindings.size());\n+        for (final Binding<TransportAction> binding : bindings) {\n+            allActionNames.add(binding.getProvider().get().actionName);\n+        }\n+\n+        final Set<String> nonOperatorActions = Set.of(NON_OPERATOR_ACTIONS);\n+        final Set<String> expectedOperatorOnlyActions = Sets.difference(Set.copyOf(allActionNames), nonOperatorActions);\n+        final Set<String> actualOperatorOnlyActions = new HashSet<>(CompositeOperatorOnly.ActionOperatorOnly.SIMPLE_ACTIONS);\n+        assertTrue(actualOperatorOnlyActions.containsAll(expectedOperatorOnlyActions));\n+        assertFalse(actualOperatorOnlyActions.removeAll(nonOperatorActions));\n+    }\n+\n+    public void testSuperuserWillFailToCallOperatorOnlyAction() {\n+        final ClearVotingConfigExclusionsRequest clearVotingConfigExclusionsRequest = new ClearVotingConfigExclusionsRequest();\n+        final ElasticsearchSecurityException e = expectThrows(ElasticsearchSecurityException.class,\n+            () -> client().execute(ClearVotingConfigExclusionsAction.INSTANCE, clearVotingConfigExclusionsRequest).actionGet());\n+        assertThat(e.getCause().getMessage(), containsString(\"Operator privileges are required for action\"));\n+    }\n+\n+    public void testOperatorUserWillSucceedToCallOperatorOnlyAction() {\n+        final Client client = client().filterWithHeader(Map.of(\n+            \"Authorization\",\n+            basicAuthHeaderValue(OPERATOR_USER_NAME, new SecureString(TEST_PASSWORD.toCharArray()))));\n+        final ClearVotingConfigExclusionsRequest clearVotingConfigExclusionsRequest = new ClearVotingConfigExclusionsRequest();\n+        client.execute(ClearVotingConfigExclusionsAction.INSTANCE, clearVotingConfigExclusionsRequest).actionGet();\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d5f3b0417388819e4bc8bef73cc76321b16e046"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTIwNDI5Ng==", "bodyText": "Its a subjective view, but I'd probably put this in a separate class just for neatness.", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r529204296", "createdAt": "2020-11-24T05:01:53Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/internalClusterTest/java/org/elasticsearch/xpack/security/operator/OperatorPrivilegesSingleNodeTests.java", "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.operator;\n+\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.action.admin.cluster.configuration.ClearVotingConfigExclusionsAction;\n+import org.elasticsearch.action.admin.cluster.configuration.ClearVotingConfigExclusionsRequest;\n+import org.elasticsearch.action.support.TransportAction;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.common.inject.Binding;\n+import org.elasticsearch.common.inject.Injector;\n+import org.elasticsearch.common.inject.TypeLiteral;\n+import org.elasticsearch.common.settings.SecureString;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.set.Sets;\n+import org.elasticsearch.test.SecuritySingleNodeTestCase;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.elasticsearch.test.SecuritySettingsSource.TEST_PASSWORD_HASHED;\n+import static org.elasticsearch.test.SecuritySettingsSourceField.TEST_PASSWORD;\n+import static org.elasticsearch.xpack.core.security.authc.support.UsernamePasswordToken.basicAuthHeaderValue;\n+import static org.hamcrest.Matchers.containsString;\n+\n+public class OperatorPrivilegesSingleNodeTests extends SecuritySingleNodeTestCase {\n+\n+    private static final String OPERATOR_USER_NAME = \"test_operator\";\n+\n+    @Override\n+    protected String configUsers() {\n+        return super.configUsers()\n+            + OPERATOR_USER_NAME + \":\" + TEST_PASSWORD_HASHED + \"\\n\";\n+    }\n+\n+    @Override\n+    protected String configRoles() {\n+        return super.configRoles()\n+            + \"limited_operator:\\n\"\n+            + \"  cluster:\\n\"\n+            + \"    - 'cluster:admin/voting_config/clear_exclusions'\\n\"\n+            + \"    - 'monitor'\\n\";\n+    }\n+\n+    @Override\n+    protected String configUsersRoles() {\n+        return super.configUsersRoles()\n+            + \"limited_operator:\" + OPERATOR_USER_NAME + \"\\n\";\n+    }\n+\n+    @Override\n+    protected String configOperatorUsers() {\n+        return super.configOperatorUsers()\n+            + \"operator:\\n\"\n+            + \"  - usernames: ['\" + OPERATOR_USER_NAME + \"']\\n\";\n+    }\n+\n+    @Override\n+    protected Settings nodeSettings() {\n+        Settings.Builder builder = Settings.builder().put(super.nodeSettings());\n+        // Ensure the new settings can be configured\n+        builder.put(\"xpack.security.operator_privileges.enabled\", \"true\");\n+        return builder.build();\n+    }\n+\n+    // TODO: Not all plugins are available in internal cluster tests. Hence not all action names can be checked.\n+    public void testActionsAreEitherOperatorOnlyOrNot() {\n+        final Injector injector = node().injector();\n+        final List<Binding<TransportAction>> bindings = injector.findBindingsByType(TypeLiteral.get(TransportAction.class));\n+\n+        final List<String> allActionNames = new ArrayList<>(bindings.size());\n+        for (final Binding<TransportAction> binding : bindings) {\n+            allActionNames.add(binding.getProvider().get().actionName);\n+        }\n+\n+        final Set<String> nonOperatorActions = Set.of(NON_OPERATOR_ACTIONS);\n+        final Set<String> expectedOperatorOnlyActions = Sets.difference(Set.copyOf(allActionNames), nonOperatorActions);\n+        final Set<String> actualOperatorOnlyActions = new HashSet<>(CompositeOperatorOnly.ActionOperatorOnly.SIMPLE_ACTIONS);\n+        assertTrue(actualOperatorOnlyActions.containsAll(expectedOperatorOnlyActions));\n+        assertFalse(actualOperatorOnlyActions.removeAll(nonOperatorActions));\n+    }\n+\n+    public void testSuperuserWillFailToCallOperatorOnlyAction() {\n+        final ClearVotingConfigExclusionsRequest clearVotingConfigExclusionsRequest = new ClearVotingConfigExclusionsRequest();\n+        final ElasticsearchSecurityException e = expectThrows(ElasticsearchSecurityException.class,\n+            () -> client().execute(ClearVotingConfigExclusionsAction.INSTANCE, clearVotingConfigExclusionsRequest).actionGet());\n+        assertThat(e.getCause().getMessage(), containsString(\"Operator privileges are required for action\"));\n+    }\n+\n+    public void testOperatorUserWillSucceedToCallOperatorOnlyAction() {\n+        final Client client = client().filterWithHeader(Map.of(\n+            \"Authorization\",\n+            basicAuthHeaderValue(OPERATOR_USER_NAME, new SecureString(TEST_PASSWORD.toCharArray()))));\n+        final ClearVotingConfigExclusionsRequest clearVotingConfigExclusionsRequest = new ClearVotingConfigExclusionsRequest();\n+        client.execute(ClearVotingConfigExclusionsAction.INSTANCE, clearVotingConfigExclusionsRequest).actionGet();\n+    }\n+\n+    public static final String[] NON_OPERATOR_ACTIONS = new String[] {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d5f3b0417388819e4bc8bef73cc76321b16e046"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDEwNDg3Nw==", "bodyText": "This seems more complex than we need. Don't we just need\nboolean isOperatorRequest(String action, TransportRequest request);", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r530104877", "createdAt": "2020-11-25T04:44:09Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/operator/OperatorOnly.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.operator;\n+\n+import org.elasticsearch.transport.TransportRequest;\n+\n+import java.util.function.Supplier;\n+\n+public interface OperatorOnly {\n+\n+    Result check(String action, TransportRequest request);\n+\n+    enum Status {\n+        YES, NO, CONTINUE;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d66a057b26a5eb605e0d0fb7eaa4e04fbcb2016"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDEwNTg5Ng==", "bodyText": "I think we should reverse the order of these if statements.\nIt will often be more efficient to check for whether the thread context is an operator, so I think we should just let operator users go through without checking the request/action.", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r530105896", "createdAt": "2020-11-25T04:48:10Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/operator/OperatorPrivileges.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.operator;\n+\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.license.XPackLicenseState;\n+import org.elasticsearch.transport.TransportRequest;\n+import org.elasticsearch.xpack.core.security.authc.Authentication;\n+import org.elasticsearch.xpack.core.security.authc.AuthenticationField;\n+\n+public class OperatorPrivileges {\n+\n+    public static final Setting<Boolean> OPERATOR_PRIVILEGES_ENABLED =\n+        Setting.boolSetting(\"xpack.security.operator_privileges.enabled\", false, Setting.Property.NodeScope);\n+\n+    private final OperatorUserDescriptor operatorUserDescriptor;\n+    private final CompositeOperatorOnly compositeOperatorOnly;\n+    private final XPackLicenseState licenseState;\n+    private final boolean enabled;\n+\n+    public OperatorPrivileges(Settings settings, XPackLicenseState licenseState,\n+                              OperatorUserDescriptor operatorUserDescriptor, CompositeOperatorOnly compositeOperatorOnly) {\n+        this.operatorUserDescriptor = operatorUserDescriptor;\n+        this.compositeOperatorOnly = compositeOperatorOnly;\n+        this.licenseState = licenseState;\n+        this.enabled = OPERATOR_PRIVILEGES_ENABLED.get(settings);\n+    }\n+\n+    public void maybeMarkOperatorUser(Authentication authentication, ThreadContext threadContext) {\n+        if (shouldProcess() && operatorUserDescriptor.isOperatorUser(authentication)) {\n+            threadContext.putHeader(\n+                AuthenticationField.PRIVILEGE_CATEGORY_KEY,\n+                AuthenticationField.PRIVILEGE_CATEGORY_VALUE_OPERATOR);\n+        }\n+    }\n+\n+    public ElasticsearchSecurityException check(String action, TransportRequest request, ThreadContext threadContext) {\n+        if (false == shouldProcess()) {\n+            return null;\n+        }\n+        final OperatorOnly.Result operatorOnlyCheckResult = compositeOperatorOnly.check(action, request);\n+        if (operatorOnlyCheckResult.getStatus() == OperatorOnly.Status.YES) {\n+            if (false == AuthenticationField.PRIVILEGE_CATEGORY_VALUE_OPERATOR.equals(\n+                threadContext.getHeader(AuthenticationField.PRIVILEGE_CATEGORY_KEY))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d66a057b26a5eb605e0d0fb7eaa4e04fbcb2016"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDEwNjQxNw==", "bodyText": "This shouldn't be lenient. If the file is missing or incorrect then it should fail the node on startup.", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r530106417", "createdAt": "2020-11-25T04:50:23Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/operator/OperatorUserDescriptor.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.operator;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.ElasticsearchParseException;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.xcontent.DeprecationHandler;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentParserUtils;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.env.Environment;\n+import org.elasticsearch.watcher.FileChangesListener;\n+import org.elasticsearch.watcher.FileWatcher;\n+import org.elasticsearch.watcher.ResourceWatcherService;\n+import org.elasticsearch.xpack.core.XPackPlugin;\n+import org.elasticsearch.xpack.core.security.authc.Authentication;\n+import org.elasticsearch.xpack.core.security.authc.AuthenticationField;\n+import org.elasticsearch.xpack.core.security.authc.file.FileRealmSettings;\n+import org.elasticsearch.xpack.core.security.user.User;\n+import org.elasticsearch.xpack.core.security.xcontent.XContentUtils;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+public class OperatorUserDescriptor {\n+    private static final Logger logger = LogManager.getLogger(OperatorUserDescriptor.class);\n+\n+    private final Path file;\n+    private volatile List<Group> groups;\n+\n+    public OperatorUserDescriptor(Environment env, ResourceWatcherService watcherService) {\n+        this.file =  XPackPlugin.resolveConfigFile(env, \"operator_users.yml\");\n+        this.groups = parseFileLenient(file, logger);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d66a057b26a5eb605e0d0fb7eaa4e04fbcb2016"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDEwNzE0Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return usernames.equals(group.usernames) && Objects.equals(realmName,\n          \n          \n            \n                            group.realmName) && realmType.equals(group.realmType) && authenticationType == group.authenticationType;\n          \n          \n            \n                        return usernames.equals(group.usernames) \n          \n          \n            \n                          && Objects.equals(realmName, group.realmName) \n          \n          \n            \n                          && realmType.equals(group.realmType) \n          \n          \n            \n                          && authenticationType == group.authenticationType;", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r530107147", "createdAt": "2020-11-25T04:53:02Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/operator/OperatorUserDescriptor.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.operator;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.ElasticsearchParseException;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.xcontent.DeprecationHandler;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentParserUtils;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.env.Environment;\n+import org.elasticsearch.watcher.FileChangesListener;\n+import org.elasticsearch.watcher.FileWatcher;\n+import org.elasticsearch.watcher.ResourceWatcherService;\n+import org.elasticsearch.xpack.core.XPackPlugin;\n+import org.elasticsearch.xpack.core.security.authc.Authentication;\n+import org.elasticsearch.xpack.core.security.authc.AuthenticationField;\n+import org.elasticsearch.xpack.core.security.authc.file.FileRealmSettings;\n+import org.elasticsearch.xpack.core.security.user.User;\n+import org.elasticsearch.xpack.core.security.xcontent.XContentUtils;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+public class OperatorUserDescriptor {\n+    private static final Logger logger = LogManager.getLogger(OperatorUserDescriptor.class);\n+\n+    private final Path file;\n+    private volatile List<Group> groups;\n+\n+    public OperatorUserDescriptor(Environment env, ResourceWatcherService watcherService) {\n+        this.file =  XPackPlugin.resolveConfigFile(env, \"operator_users.yml\");\n+        this.groups = parseFileLenient(file, logger);\n+        FileWatcher watcher = new FileWatcher(file.getParent());\n+        watcher.addListener(new OperatorUserDescriptor.FileListener());\n+        try {\n+            watcherService.add(watcher, ResourceWatcherService.Frequency.HIGH);\n+        } catch (IOException e) {\n+            throw new ElasticsearchException(\"failed to start watching the operator users file [\" + file.toAbsolutePath() + \"]\", e);\n+        }\n+    }\n+\n+    public boolean isOperatorUser(Authentication authentication) {\n+        if (authentication.getUser().isRunAs()) {\n+            return false;\n+        } else if (User.isInternal(authentication.getUser())) {\n+            // Internal user are considered operator users\n+            return true;\n+        }\n+\n+        return groups.stream().anyMatch(group -> {\n+            final Authentication.RealmRef realm = authentication.getSourceRealm();\n+            return group.usernames.contains(authentication.getUser().principal())\n+                && group.authenticationType == authentication.getAuthenticationType()\n+                && realm.getType().equals(group.realmType)\n+                && (realm.getType().equals(FileRealmSettings.TYPE) || realm.getName().equals(group.realmName));\n+        });\n+    }\n+\n+    // Package private for tests\n+    List<Group> getGroups() {\n+        return groups;\n+    }\n+\n+    public static final class Group {\n+        private final Set<String> usernames;\n+        private final String realmName;\n+        private final String realmType;\n+        private final Authentication.AuthenticationType authenticationType;\n+\n+        public Group(Set<String> usernames) {\n+            this(usernames, null, FileRealmSettings.TYPE, Authentication.AuthenticationType.REALM);\n+        }\n+\n+        public Group(Set<String> usernames, String realmName) {\n+            this(usernames, realmName, FileRealmSettings.TYPE, Authentication.AuthenticationType.REALM);\n+        }\n+\n+        public Group(\n+            Set<String> usernames, String realmName, String realmType, Authentication.AuthenticationType authenticationType) {\n+            this.usernames = usernames;\n+            this.realmName = realmName;\n+            this.realmType = realmType;\n+            this.authenticationType = authenticationType;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            final StringBuilder sb = new StringBuilder(\"Group[\");\n+            sb.append(\"usernames=\").append(usernames);\n+            if (realmName != null) {\n+                sb.append(\", realm_name=\").append(realmName);\n+            }\n+            if (realmType != null) {\n+                sb.append(\", realm_type=\").append(realmType);\n+            }\n+            if (authenticationType != null) {\n+                sb.append(\", auth_type=\").append(authenticationType.name().toLowerCase(Locale.ROOT));\n+            }\n+            sb.append(\"]\");\n+            return sb.toString();\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o)\n+                return true;\n+            if (o == null || getClass() != o.getClass())\n+                return false;\n+            Group group = (Group) o;\n+            return usernames.equals(group.usernames) && Objects.equals(realmName,\n+                group.realmName) && realmType.equals(group.realmType) && authenticationType == group.authenticationType;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d66a057b26a5eb605e0d0fb7eaa4e04fbcb2016"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDEwNzg4NQ==", "bodyText": "I think we need to wrap all this in an if-operator-privileges-configured, and then have a NoOperatorPrivileges impl.\nThen we can be strict in the parsing of operator privilege files, and warn loudly if they get deleted.", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r530107885", "createdAt": "2020-11-25T04:56:00Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/Security.java", "diffHunk": "@@ -473,8 +476,10 @@ protected Clock getClock() {\n         getLicenseState().addListener(new SecurityStatusChangeListener(getLicenseState()));\n \n         final AuthenticationFailureHandler failureHandler = createAuthenticationFailureHandler(realms, extensionComponents);\n+        final OperatorPrivileges operatorPrivileges = new OperatorPrivileges(settings, getLicenseState(),\n+            new OperatorUserDescriptor(environment, resourceWatcherService), new CompositeOperatorOnly());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d66a057b26a5eb605e0d0fb7eaa4e04fbcb2016"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDEwNzk4Mg==", "bodyText": "I think this should be an error (assuming we only load this class if oper-privs are enabled).", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r530107982", "createdAt": "2020-11-25T04:56:27Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/operator/OperatorUserDescriptor.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.operator;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.ElasticsearchParseException;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.xcontent.DeprecationHandler;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentParserUtils;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.env.Environment;\n+import org.elasticsearch.watcher.FileChangesListener;\n+import org.elasticsearch.watcher.FileWatcher;\n+import org.elasticsearch.watcher.ResourceWatcherService;\n+import org.elasticsearch.xpack.core.XPackPlugin;\n+import org.elasticsearch.xpack.core.security.authc.Authentication;\n+import org.elasticsearch.xpack.core.security.authc.AuthenticationField;\n+import org.elasticsearch.xpack.core.security.authc.file.FileRealmSettings;\n+import org.elasticsearch.xpack.core.security.user.User;\n+import org.elasticsearch.xpack.core.security.xcontent.XContentUtils;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+public class OperatorUserDescriptor {\n+    private static final Logger logger = LogManager.getLogger(OperatorUserDescriptor.class);\n+\n+    private final Path file;\n+    private volatile List<Group> groups;\n+\n+    public OperatorUserDescriptor(Environment env, ResourceWatcherService watcherService) {\n+        this.file =  XPackPlugin.resolveConfigFile(env, \"operator_users.yml\");\n+        this.groups = parseFileLenient(file, logger);\n+        FileWatcher watcher = new FileWatcher(file.getParent());\n+        watcher.addListener(new OperatorUserDescriptor.FileListener());\n+        try {\n+            watcherService.add(watcher, ResourceWatcherService.Frequency.HIGH);\n+        } catch (IOException e) {\n+            throw new ElasticsearchException(\"failed to start watching the operator users file [\" + file.toAbsolutePath() + \"]\", e);\n+        }\n+    }\n+\n+    public boolean isOperatorUser(Authentication authentication) {\n+        if (authentication.getUser().isRunAs()) {\n+            return false;\n+        } else if (User.isInternal(authentication.getUser())) {\n+            // Internal user are considered operator users\n+            return true;\n+        }\n+\n+        return groups.stream().anyMatch(group -> {\n+            final Authentication.RealmRef realm = authentication.getSourceRealm();\n+            return group.usernames.contains(authentication.getUser().principal())\n+                && group.authenticationType == authentication.getAuthenticationType()\n+                && realm.getType().equals(group.realmType)\n+                && (realm.getType().equals(FileRealmSettings.TYPE) || realm.getName().equals(group.realmName));\n+        });\n+    }\n+\n+    // Package private for tests\n+    List<Group> getGroups() {\n+        return groups;\n+    }\n+\n+    public static final class Group {\n+        private final Set<String> usernames;\n+        private final String realmName;\n+        private final String realmType;\n+        private final Authentication.AuthenticationType authenticationType;\n+\n+        public Group(Set<String> usernames) {\n+            this(usernames, null, FileRealmSettings.TYPE, Authentication.AuthenticationType.REALM);\n+        }\n+\n+        public Group(Set<String> usernames, String realmName) {\n+            this(usernames, realmName, FileRealmSettings.TYPE, Authentication.AuthenticationType.REALM);\n+        }\n+\n+        public Group(\n+            Set<String> usernames, String realmName, String realmType, Authentication.AuthenticationType authenticationType) {\n+            this.usernames = usernames;\n+            this.realmName = realmName;\n+            this.realmType = realmType;\n+            this.authenticationType = authenticationType;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            final StringBuilder sb = new StringBuilder(\"Group[\");\n+            sb.append(\"usernames=\").append(usernames);\n+            if (realmName != null) {\n+                sb.append(\", realm_name=\").append(realmName);\n+            }\n+            if (realmType != null) {\n+                sb.append(\", realm_type=\").append(realmType);\n+            }\n+            if (authenticationType != null) {\n+                sb.append(\", auth_type=\").append(authenticationType.name().toLowerCase(Locale.ROOT));\n+            }\n+            sb.append(\"]\");\n+            return sb.toString();\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o)\n+                return true;\n+            if (o == null || getClass() != o.getClass())\n+                return false;\n+            Group group = (Group) o;\n+            return usernames.equals(group.usernames) && Objects.equals(realmName,\n+                group.realmName) && realmType.equals(group.realmType) && authenticationType == group.authenticationType;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(usernames, realmName, realmType, authenticationType);\n+        }\n+    }\n+\n+    public static List<Group> parseFileLenient(Path path, Logger logger) {\n+        if (false == Files.exists(path)) {\n+            logger.debug(\"Skip reading operator user file since it does not exist\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d66a057b26a5eb605e0d0fb7eaa4e04fbcb2016"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDExMTEyOA==", "bodyText": "You could use XContentParserUtils.ensureFieldName for this, couldn't you?", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r530111128", "createdAt": "2020-11-25T05:08:21Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/operator/OperatorUserDescriptor.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.operator;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.ElasticsearchParseException;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.xcontent.DeprecationHandler;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentParserUtils;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.env.Environment;\n+import org.elasticsearch.watcher.FileChangesListener;\n+import org.elasticsearch.watcher.FileWatcher;\n+import org.elasticsearch.watcher.ResourceWatcherService;\n+import org.elasticsearch.xpack.core.XPackPlugin;\n+import org.elasticsearch.xpack.core.security.authc.Authentication;\n+import org.elasticsearch.xpack.core.security.authc.AuthenticationField;\n+import org.elasticsearch.xpack.core.security.authc.file.FileRealmSettings;\n+import org.elasticsearch.xpack.core.security.user.User;\n+import org.elasticsearch.xpack.core.security.xcontent.XContentUtils;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+public class OperatorUserDescriptor {\n+    private static final Logger logger = LogManager.getLogger(OperatorUserDescriptor.class);\n+\n+    private final Path file;\n+    private volatile List<Group> groups;\n+\n+    public OperatorUserDescriptor(Environment env, ResourceWatcherService watcherService) {\n+        this.file =  XPackPlugin.resolveConfigFile(env, \"operator_users.yml\");\n+        this.groups = parseFileLenient(file, logger);\n+        FileWatcher watcher = new FileWatcher(file.getParent());\n+        watcher.addListener(new OperatorUserDescriptor.FileListener());\n+        try {\n+            watcherService.add(watcher, ResourceWatcherService.Frequency.HIGH);\n+        } catch (IOException e) {\n+            throw new ElasticsearchException(\"failed to start watching the operator users file [\" + file.toAbsolutePath() + \"]\", e);\n+        }\n+    }\n+\n+    public boolean isOperatorUser(Authentication authentication) {\n+        if (authentication.getUser().isRunAs()) {\n+            return false;\n+        } else if (User.isInternal(authentication.getUser())) {\n+            // Internal user are considered operator users\n+            return true;\n+        }\n+\n+        return groups.stream().anyMatch(group -> {\n+            final Authentication.RealmRef realm = authentication.getSourceRealm();\n+            return group.usernames.contains(authentication.getUser().principal())\n+                && group.authenticationType == authentication.getAuthenticationType()\n+                && realm.getType().equals(group.realmType)\n+                && (realm.getType().equals(FileRealmSettings.TYPE) || realm.getName().equals(group.realmName));\n+        });\n+    }\n+\n+    // Package private for tests\n+    List<Group> getGroups() {\n+        return groups;\n+    }\n+\n+    public static final class Group {\n+        private final Set<String> usernames;\n+        private final String realmName;\n+        private final String realmType;\n+        private final Authentication.AuthenticationType authenticationType;\n+\n+        public Group(Set<String> usernames) {\n+            this(usernames, null, FileRealmSettings.TYPE, Authentication.AuthenticationType.REALM);\n+        }\n+\n+        public Group(Set<String> usernames, String realmName) {\n+            this(usernames, realmName, FileRealmSettings.TYPE, Authentication.AuthenticationType.REALM);\n+        }\n+\n+        public Group(\n+            Set<String> usernames, String realmName, String realmType, Authentication.AuthenticationType authenticationType) {\n+            this.usernames = usernames;\n+            this.realmName = realmName;\n+            this.realmType = realmType;\n+            this.authenticationType = authenticationType;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            final StringBuilder sb = new StringBuilder(\"Group[\");\n+            sb.append(\"usernames=\").append(usernames);\n+            if (realmName != null) {\n+                sb.append(\", realm_name=\").append(realmName);\n+            }\n+            if (realmType != null) {\n+                sb.append(\", realm_type=\").append(realmType);\n+            }\n+            if (authenticationType != null) {\n+                sb.append(\", auth_type=\").append(authenticationType.name().toLowerCase(Locale.ROOT));\n+            }\n+            sb.append(\"]\");\n+            return sb.toString();\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o)\n+                return true;\n+            if (o == null || getClass() != o.getClass())\n+                return false;\n+            Group group = (Group) o;\n+            return usernames.equals(group.usernames) && Objects.equals(realmName,\n+                group.realmName) && realmType.equals(group.realmType) && authenticationType == group.authenticationType;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(usernames, realmName, realmType, authenticationType);\n+        }\n+    }\n+\n+    public static List<Group> parseFileLenient(Path path, Logger logger) {\n+        if (false == Files.exists(path)) {\n+            logger.debug(\"Skip reading operator user file since it does not exist\");\n+            return List.of();\n+        }\n+        logger.debug(\"Reading operator users file [{}]\", path.toAbsolutePath());\n+        try {\n+            return parseFile(path);\n+        } catch (IOException | RuntimeException e) {\n+            logger.error(\"Failed to parse operator_users file [\" + path + \"].\", e);\n+            return List.of();\n+        }\n+    }\n+\n+    public static List<Group> parseFile(Path path) throws IOException {\n+        try (InputStream in = Files.newInputStream(path, StandardOpenOption.READ)) {\n+            return parseConfig(in);\n+        }\n+    }\n+\n+    public static List<Group> parseConfig(InputStream in) throws IOException {\n+        final List<Group> groups = new ArrayList<>();\n+        try (XContentParser parser = yamlParser(in)) {\n+            XContentParserUtils.ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser);\n+            while (parser.nextToken() != XContentParser.Token.END_OBJECT) {\n+                XContentParserUtils.ensureExpectedToken(XContentParser.Token.FIELD_NAME, parser.currentToken(), parser);\n+                final String categoryName = parser.currentName();\n+                if (false == AuthenticationField.PRIVILEGE_CATEGORY_VALUE_OPERATOR.equals(categoryName)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d66a057b26a5eb605e0d0fb7eaa4e04fbcb2016"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDExMTUzMA==", "bodyText": "Is it not possible to do this with ObjectParser?", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r530111530", "createdAt": "2020-11-25T05:09:40Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/operator/OperatorUserDescriptor.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.operator;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.ElasticsearchParseException;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.xcontent.DeprecationHandler;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentParserUtils;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.env.Environment;\n+import org.elasticsearch.watcher.FileChangesListener;\n+import org.elasticsearch.watcher.FileWatcher;\n+import org.elasticsearch.watcher.ResourceWatcherService;\n+import org.elasticsearch.xpack.core.XPackPlugin;\n+import org.elasticsearch.xpack.core.security.authc.Authentication;\n+import org.elasticsearch.xpack.core.security.authc.AuthenticationField;\n+import org.elasticsearch.xpack.core.security.authc.file.FileRealmSettings;\n+import org.elasticsearch.xpack.core.security.user.User;\n+import org.elasticsearch.xpack.core.security.xcontent.XContentUtils;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+public class OperatorUserDescriptor {\n+    private static final Logger logger = LogManager.getLogger(OperatorUserDescriptor.class);\n+\n+    private final Path file;\n+    private volatile List<Group> groups;\n+\n+    public OperatorUserDescriptor(Environment env, ResourceWatcherService watcherService) {\n+        this.file =  XPackPlugin.resolveConfigFile(env, \"operator_users.yml\");\n+        this.groups = parseFileLenient(file, logger);\n+        FileWatcher watcher = new FileWatcher(file.getParent());\n+        watcher.addListener(new OperatorUserDescriptor.FileListener());\n+        try {\n+            watcherService.add(watcher, ResourceWatcherService.Frequency.HIGH);\n+        } catch (IOException e) {\n+            throw new ElasticsearchException(\"failed to start watching the operator users file [\" + file.toAbsolutePath() + \"]\", e);\n+        }\n+    }\n+\n+    public boolean isOperatorUser(Authentication authentication) {\n+        if (authentication.getUser().isRunAs()) {\n+            return false;\n+        } else if (User.isInternal(authentication.getUser())) {\n+            // Internal user are considered operator users\n+            return true;\n+        }\n+\n+        return groups.stream().anyMatch(group -> {\n+            final Authentication.RealmRef realm = authentication.getSourceRealm();\n+            return group.usernames.contains(authentication.getUser().principal())\n+                && group.authenticationType == authentication.getAuthenticationType()\n+                && realm.getType().equals(group.realmType)\n+                && (realm.getType().equals(FileRealmSettings.TYPE) || realm.getName().equals(group.realmName));\n+        });\n+    }\n+\n+    // Package private for tests\n+    List<Group> getGroups() {\n+        return groups;\n+    }\n+\n+    public static final class Group {\n+        private final Set<String> usernames;\n+        private final String realmName;\n+        private final String realmType;\n+        private final Authentication.AuthenticationType authenticationType;\n+\n+        public Group(Set<String> usernames) {\n+            this(usernames, null, FileRealmSettings.TYPE, Authentication.AuthenticationType.REALM);\n+        }\n+\n+        public Group(Set<String> usernames, String realmName) {\n+            this(usernames, realmName, FileRealmSettings.TYPE, Authentication.AuthenticationType.REALM);\n+        }\n+\n+        public Group(\n+            Set<String> usernames, String realmName, String realmType, Authentication.AuthenticationType authenticationType) {\n+            this.usernames = usernames;\n+            this.realmName = realmName;\n+            this.realmType = realmType;\n+            this.authenticationType = authenticationType;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            final StringBuilder sb = new StringBuilder(\"Group[\");\n+            sb.append(\"usernames=\").append(usernames);\n+            if (realmName != null) {\n+                sb.append(\", realm_name=\").append(realmName);\n+            }\n+            if (realmType != null) {\n+                sb.append(\", realm_type=\").append(realmType);\n+            }\n+            if (authenticationType != null) {\n+                sb.append(\", auth_type=\").append(authenticationType.name().toLowerCase(Locale.ROOT));\n+            }\n+            sb.append(\"]\");\n+            return sb.toString();\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o)\n+                return true;\n+            if (o == null || getClass() != o.getClass())\n+                return false;\n+            Group group = (Group) o;\n+            return usernames.equals(group.usernames) && Objects.equals(realmName,\n+                group.realmName) && realmType.equals(group.realmType) && authenticationType == group.authenticationType;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(usernames, realmName, realmType, authenticationType);\n+        }\n+    }\n+\n+    public static List<Group> parseFileLenient(Path path, Logger logger) {\n+        if (false == Files.exists(path)) {\n+            logger.debug(\"Skip reading operator user file since it does not exist\");\n+            return List.of();\n+        }\n+        logger.debug(\"Reading operator users file [{}]\", path.toAbsolutePath());\n+        try {\n+            return parseFile(path);\n+        } catch (IOException | RuntimeException e) {\n+            logger.error(\"Failed to parse operator_users file [\" + path + \"].\", e);\n+            return List.of();\n+        }\n+    }\n+\n+    public static List<Group> parseFile(Path path) throws IOException {\n+        try (InputStream in = Files.newInputStream(path, StandardOpenOption.READ)) {\n+            return parseConfig(in);\n+        }\n+    }\n+\n+    public static List<Group> parseConfig(InputStream in) throws IOException {\n+        final List<Group> groups = new ArrayList<>();\n+        try (XContentParser parser = yamlParser(in)) {\n+            XContentParserUtils.ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser);\n+            while (parser.nextToken() != XContentParser.Token.END_OBJECT) {\n+                XContentParserUtils.ensureExpectedToken(XContentParser.Token.FIELD_NAME, parser.currentToken(), parser);\n+                final String categoryName = parser.currentName();\n+                if (false == AuthenticationField.PRIVILEGE_CATEGORY_VALUE_OPERATOR.equals(categoryName)) {\n+                    throw new IllegalArgumentException(\"Operator user config file must begin with operator, got [\" + categoryName + \"]\");\n+                }\n+                XContentParserUtils.ensureExpectedToken(XContentParser.Token.START_ARRAY, parser.nextToken(), parser);\n+                while (parser.nextToken() != XContentParser.Token.END_ARRAY) {\n+                    groups.add(parseOneGroup(parser));\n+                }\n+            }\n+        }\n+        return List.copyOf(groups);\n+    }\n+\n+    private static Group parseOneGroup(XContentParser parser) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d66a057b26a5eb605e0d0fb7eaa4e04fbcb2016"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDExMTk3MQ==", "bodyText": "This should be in x-pack/plugin/security/qa", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r530111971", "createdAt": "2020-11-25T05:11:22Z", "author": {"login": "tvernum"}, "path": "x-pack/qa/operator-privileges-tests/build.gradle", "diffHunk": "@@ -0,0 +1,38 @@\n+import org.elasticsearch.gradle.info.BuildParams", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d66a057b26a5eb605e0d0fb7eaa4e04fbcb2016"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDExMjA5Nw==", "bodyText": "example ?", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r530112097", "createdAt": "2020-11-25T05:11:46Z", "author": {"login": "tvernum"}, "path": "x-pack/qa/operator-privileges-tests/build.gradle", "diffHunk": "@@ -0,0 +1,38 @@\n+import org.elasticsearch.gradle.info.BuildParams\n+\n+apply plugin: 'elasticsearch.esplugin'\n+apply plugin: 'elasticsearch.java-rest-test'\n+\n+esplugin {\n+  name 'op-test'\n+  description 'An test plugin for testing hard to get internals'\n+  classname 'org.elasticsearch.example.OpTestPlugin'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d66a057b26a5eb605e0d0fb7eaa4e04fbcb2016"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDExMjEyNA==", "bodyText": "?", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r530112124", "createdAt": "2020-11-25T05:11:55Z", "author": {"login": "tvernum"}, "path": "x-pack/qa/operator-privileges-tests/build.gradle", "diffHunk": "@@ -0,0 +1,38 @@\n+import org.elasticsearch.gradle.info.BuildParams\n+\n+apply plugin: 'elasticsearch.esplugin'\n+apply plugin: 'elasticsearch.java-rest-test'\n+\n+esplugin {\n+  name 'op-test'\n+  description 'An test plugin for testing hard to get internals'\n+  classname 'org.elasticsearch.example.OpTestPlugin'\n+  licenseFile rootProject.file('licenses/APACHE-LICENSE-2.0.txt')", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d66a057b26a5eb605e0d0fb7eaa4e04fbcb2016"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDExMjU5OQ==", "bodyText": "You can move this as an inner class of GetActionsAction (like autoscaling does) if you want.", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r530112599", "createdAt": "2020-11-25T05:14:02Z", "author": {"login": "tvernum"}, "path": "x-pack/qa/operator-privileges-tests/src/main/java/org/elasticsearch/example/actions/GetActionsRequest.java", "diffHunk": "@@ -0,0 +1,27 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.example.actions;\n+\n+import org.elasticsearch.action.ActionRequest;\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+\n+import java.io.IOException;\n+\n+public class GetActionsRequest extends ActionRequest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d66a057b26a5eb605e0d0fb7eaa4e04fbcb2016"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDExMjc3Nw==", "bodyText": "I would be fine with that.", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r530112777", "createdAt": "2020-11-25T05:14:33Z", "author": {"login": "tvernum"}, "path": "x-pack/qa/operator-privileges-tests/src/main/java/org/elasticsearch/example/actions/RestGetActionsAction.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.example.actions;\n+\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.rest.BaseRestHandler;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.action.RestToXContentListener;\n+\n+import java.io.IOException;\n+import java.util.List;\n+\n+import static org.elasticsearch.rest.RestRequest.Method.GET;\n+\n+public class RestGetActionsAction extends BaseRestHandler {\n+    @Override\n+    public List<Route> routes() {\n+        return List.of(new Route(GET, \"/_test/get_actions\"));\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"test_get_actions\";\n+    }\n+\n+    @Override\n+    protected RestChannelConsumer prepareRequest(RestRequest request, NodeClient client) throws IOException {\n+        // It is also possible to use reflection to get NodeClient#actions and save all the transport related classes", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d66a057b26a5eb605e0d0fb7eaa4e04fbcb2016"}, "originalPosition": 32}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1b284760b6abbc4996208c644ae731b1e1b5dd8e", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/1b284760b6abbc4996208c644ae731b1e1b5dd8e", "committedDate": "2020-11-25T13:25:33Z", "message": "Update x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/operator/OperatorUserDescriptor.java\n\nCo-authored-by: Tim Vernum <tim@adjective.org>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "892840f780d89465a78a55ca4343e7aaee2a1b38", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/892840f780d89465a78a55ca4343e7aaee2a1b38", "committedDate": "2020-11-25T20:58:52Z", "message": "address feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9314789eac46196c338749976e6db3a7f745dd2d", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/9314789eac46196c338749976e6db3a7f745dd2d", "committedDate": "2020-11-25T20:58:52Z", "message": "Simplify the plugin IT test with reflection"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5dedd54c3ae9e696ef2d12af95afdb1267792536", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/5dedd54c3ae9e696ef2d12af95afdb1267792536", "committedDate": "2020-11-25T21:41:44Z", "message": "spotless"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "901ecd2d907653c956bf0718719908b579dd1602", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/901ecd2d907653c956bf0718719908b579dd1602", "committedDate": "2020-11-26T07:40:56Z", "message": "Refactor as suggested"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b52c8147e66d4236f6b12c1f001b0592c5a30302", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/b52c8147e66d4236f6b12c1f001b0592c5a30302", "committedDate": "2020-11-26T08:02:57Z", "message": "Move plugin test package"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5883923520fb9418330ef726d3a8fb460fbca498", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/5883923520fb9418330ef726d3a8fb460fbca498", "committedDate": "2020-11-26T08:58:50Z", "message": "Fix authenticationService tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1b3344f199b70b3db51de6c49d5efe4b289791f1", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/1b3344f199b70b3db51de6c49d5efe4b289791f1", "committedDate": "2020-11-26T12:48:21Z", "message": "Fix tests and telemetry"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0e170d913fd8517850477397d709dbd1911841d5", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/0e170d913fd8517850477397d709dbd1911841d5", "committedDate": "2020-11-26T12:58:29Z", "message": "Merge remote-tracking branch 'origin/master' into meta-101-operator-privileges-phase-one"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM5Mjk0Nzk4", "url": "https://github.com/elastic/elasticsearch/pull/65256#pullrequestreview-539294798", "createdAt": "2020-11-26T13:01:24Z", "commit": {"oid": "0e170d913fd8517850477397d709dbd1911841d5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxMzowMToyNFrOH6agUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxMzowMToyNFrOH6agUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTAxMzcxNQ==", "bodyText": "This test was skipped for a long time because of the naming convention mismatch. I fixed it but it's not 100% the same as it was because things evolved.", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r531013715", "createdAt": "2020-11-26T13:01:24Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/AuthenticationServiceTests.java", "diffHunk": "@@ -567,24 +582,23 @@ public void testTokenRestMissing() throws Exception {\n         });\n     }\n \n-    public void authenticationInContextAndHeader() throws Exception {\n+    public void testAuthenticationInContextAndHeader() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e170d913fd8517850477397d709dbd1911841d5"}, "originalPosition": 130}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM5Mjk2NzA1", "url": "https://github.com/elastic/elasticsearch/pull/65256#pullrequestreview-539296705", "createdAt": "2020-11-26T13:04:07Z", "commit": {"oid": "0e170d913fd8517850477397d709dbd1911841d5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxMzowNDowN1rOH6altg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxMzowNDowN1rOH6altg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTAxNTA5NA==", "bodyText": "I think auditing can be a follow up PR.", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r531015094", "createdAt": "2020-11-26T13:04:07Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/AuthorizationService.java", "diffHunk": "@@ -202,6 +205,16 @@ public void authorize(final Authentication authentication, final String action,\n             // sometimes a request might be wrapped within another, which is the case for proxied\n             // requests and concrete shard requests\n             final TransportRequest unwrappedRequest = maybeUnwrapRequest(authentication, originalRequest, action, auditId);\n+\n+            // Check operator privileges\n+            // TODO: audit?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e170d913fd8517850477397d709dbd1911841d5"}, "originalPosition": 39}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1082b139f548520b4b790fbca6dace8c26410093", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/1082b139f548520b4b790fbca6dace8c26410093", "committedDate": "2020-11-26T22:09:56Z", "message": "fix test failures"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQwNjI5NzQ0", "url": "https://github.com/elastic/elasticsearch/pull/65256#pullrequestreview-540629744", "createdAt": "2020-11-30T06:38:38Z", "commit": {"oid": "1082b139f548520b4b790fbca6dace8c26410093"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQwNjozODozOVrOH7tkVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQwNzozMjowMFrOH7upzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM3NDYxNQ==", "bodyText": "Is the abbreviation helping here? Would operator-priv-test be better?", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r532374615", "createdAt": "2020-11-30T06:38:39Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/qa/operator-privileges-tests/build.gradle", "diffHunk": "@@ -0,0 +1,37 @@\n+import org.elasticsearch.gradle.info.BuildParams\n+\n+apply plugin: 'elasticsearch.esplugin'\n+apply plugin: 'elasticsearch.java-rest-test'\n+\n+esplugin {\n+  name 'op-test'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1082b139f548520b4b790fbca6dace8c26410093"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM3NTIyOA==", "bodyText": "This seems like a weird thing to randomise. Given the purpose of this plugin is to test operator privileges, I would have expected it to be always true.\nWe have other QA tests where it is false...", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r532375228", "createdAt": "2020-11-30T06:40:27Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/qa/operator-privileges-tests/build.gradle", "diffHunk": "@@ -0,0 +1,37 @@\n+import org.elasticsearch.gradle.info.BuildParams\n+\n+apply plugin: 'elasticsearch.esplugin'\n+apply plugin: 'elasticsearch.java-rest-test'\n+\n+esplugin {\n+  name 'op-test'\n+  description 'An test plugin for testing hard to get internals'\n+  classname 'org.elasticsearch.xpack.security.operator.OpTestPlugin'\n+}\n+\n+dependencies {\n+  compileOnly project(':x-pack:plugin:core')\n+  javaRestTestImplementation project(':x-pack:plugin:core')\n+  javaRestTestImplementation project(':client:rest-high-level')\n+  javaRestTestImplementation project(':x-pack:plugin:security')\n+  // let the javaRestTest see the classpath of main\n+  javaRestTestImplementation project.sourceSets.main.runtimeClasspath\n+}\n+\n+boolean enableOperatorPrivileges = (new Random(Long.parseUnsignedLong(BuildParams.testSeed.tokenize(':').get(0), 16))).nextBoolean()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1082b139f548520b4b790fbca6dace8c26410093"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM3NTg1Mg==", "bodyText": "Oh, I didn't realise this would need reflection - that's pretty ugly. Are you sure this is the best option?", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r532375852", "createdAt": "2020-11-30T06:42:19Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/qa/operator-privileges-tests/src/main/java/org/elasticsearch/xpack/security/operator/actions/RestGetActionsAction.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.operator.actions;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.ActionType;\n+import org.elasticsearch.action.support.TransportAction;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.rest.BaseRestHandler;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.action.RestToXContentListener;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Field;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.rest.RestRequest.Method.GET;\n+\n+public class RestGetActionsAction extends BaseRestHandler {\n+    @Override\n+    public List<Route> routes() {\n+        return List.of(new Route(GET, \"/_test/get_actions\"));\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"test_get_actions\";\n+    }\n+\n+    @SuppressForbidden(reason = \"Use reflection for testing only\")\n+    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n+    @Override\n+    protected RestChannelConsumer prepareRequest(RestRequest request, NodeClient client) throws IOException {\n+        final Map<ActionType, TransportAction> actions = AccessController.doPrivileged(\n+            (PrivilegedAction<Map<ActionType, TransportAction>>) () -> {\n+                try {\n+                    final Field actionsField = client.getClass().getDeclaredField(\"actions\");\n+                    actionsField.setAccessible(true);\n+                    return (Map<ActionType, TransportAction>) actionsField.get(client);\n+                } catch (NoSuchFieldException | IllegalAccessException e) {\n+                    throw new ElasticsearchException(e);\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1082b139f548520b4b790fbca6dace8c26410093"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM3ODMzMw==", "bodyText": "Per my earlier comment I don't think we should be randomising this. The OperatorPrivilegesSingleNodeTests should run with operator privileges turned on.\nIf we need another set of tests without operator privileges, then let's add them, but randomisation is intended to deal with things that aren't supposed to affect the core of the test, rather than be a way to merge 2 test cases into 1 (but only run them half the time).", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r532378333", "createdAt": "2020-11-30T06:50:12Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/internalClusterTest/java/org/elasticsearch/xpack/security/operator/OperatorPrivilegesSingleNodeTests.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.operator;\n+\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.action.admin.cluster.configuration.ClearVotingConfigExclusionsAction;\n+import org.elasticsearch.action.admin.cluster.configuration.ClearVotingConfigExclusionsRequest;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.common.settings.SecureString;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.test.SecuritySingleNodeTestCase;\n+import org.elasticsearch.xpack.core.security.action.user.GetUsersAction;\n+import org.elasticsearch.xpack.core.security.action.user.GetUsersRequest;\n+import org.junit.BeforeClass;\n+\n+import java.util.Map;\n+\n+import static org.elasticsearch.test.SecuritySettingsSource.TEST_PASSWORD_HASHED;\n+import static org.elasticsearch.test.SecuritySettingsSourceField.TEST_PASSWORD;\n+import static org.elasticsearch.xpack.core.security.authc.support.UsernamePasswordToken.basicAuthHeaderValue;\n+import static org.hamcrest.Matchers.containsString;\n+\n+public class OperatorPrivilegesSingleNodeTests extends SecuritySingleNodeTestCase {\n+\n+    private static final String OPERATOR_USER_NAME = \"test_operator\";\n+\n+    private static boolean OPERATOR_PRIVILEGES_ENABLED;\n+\n+    @BeforeClass\n+    public static void randomOperatorPrivilegesEnabled() {\n+        OPERATOR_PRIVILEGES_ENABLED = randomBoolean();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1082b139f548520b4b790fbca6dace8c26410093"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM5MDAwMg==", "bodyText": "This message should use SINGLETON_REALM_TYPES", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r532390002", "createdAt": "2020-11-30T07:25:23Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/operator/FileOperatorUsersStore.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.operator;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.ElasticsearchParseException;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.ValidationException;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.DeprecationHandler;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.env.Environment;\n+import org.elasticsearch.watcher.FileChangesListener;\n+import org.elasticsearch.watcher.FileWatcher;\n+import org.elasticsearch.watcher.ResourceWatcherService;\n+import org.elasticsearch.xpack.core.XPackPlugin;\n+import org.elasticsearch.xpack.core.security.authc.Authentication;\n+import org.elasticsearch.xpack.core.security.authc.esnative.NativeRealmSettings;\n+import org.elasticsearch.xpack.core.security.authc.file.FileRealmSettings;\n+import org.elasticsearch.xpack.core.security.user.User;\n+import org.elasticsearch.xpack.security.authc.esnative.ReservedRealm;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.constructorArg;\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.optionalConstructorArg;\n+import static org.elasticsearch.xpack.security.operator.OperatorPrivileges.OPERATOR_PRIVILEGES_ENABLED;\n+\n+public class FileOperatorUsersStore {\n+    private static final Logger logger = LogManager.getLogger(FileOperatorUsersStore.class);\n+\n+    private final Path file;\n+    private volatile OperatorUsersDescriptor operatorUsersDescriptor;\n+\n+    public FileOperatorUsersStore(Environment env, ResourceWatcherService watcherService) {\n+        this.file =  XPackPlugin.resolveConfigFile(env, \"operator_users.yml\");\n+        this.operatorUsersDescriptor = parseFile(this.file, logger);\n+        FileWatcher watcher = new FileWatcher(file.getParent());\n+        watcher.addListener(new FileOperatorUsersStore.FileListener());\n+        try {\n+            watcherService.add(watcher, ResourceWatcherService.Frequency.HIGH);\n+        } catch (IOException e) {\n+            throw new ElasticsearchException(\"Failed to start watching the operator users file [\" + file.toAbsolutePath() + \"]\", e);\n+        }\n+    }\n+\n+    public boolean isOperatorUser(Authentication authentication) {\n+        if (authentication.getUser().isRunAs()) {\n+            return false;\n+        } else if (User.isInternal(authentication.getUser())) {\n+            // Internal user are considered operator users\n+            return true;\n+        }\n+\n+        // Other than realm name, other criteria must always be an exact match for the user to be an operator.\n+        // Realm name of a descriptor can be null. When it is null, it is ignored for comparison.\n+        // If not null, it will be compared exactly as well.\n+        // The special handling for realm name is because there can only be one file or native realm and it does\n+        // not matter what the name is.\n+        return operatorUsersDescriptor.groups.stream().anyMatch(group -> {\n+            final Authentication.RealmRef realm = authentication.getSourceRealm();\n+            return group.usernames.contains(authentication.getUser().principal())\n+                && group.authenticationType == authentication.getAuthenticationType()\n+                && realm.getType().equals(group.realmType)\n+                && (group.realmName == null || group.realmName.equals(realm.getName()));\n+        });\n+    }\n+\n+    // Package private for tests\n+    public OperatorUsersDescriptor getOperatorUsersDescriptor() {\n+        return operatorUsersDescriptor;\n+    }\n+\n+    static final class OperatorUsersDescriptor {\n+        private final List<Group> groups;\n+\n+        private OperatorUsersDescriptor(List<Group> groups) {\n+            this.groups = groups;\n+        }\n+\n+        // Package private for tests\n+        List<Group> getGroups() {\n+            return groups;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o)\n+                return true;\n+            if (o == null || getClass() != o.getClass())\n+                return false;\n+            OperatorUsersDescriptor that = (OperatorUsersDescriptor) o;\n+            return groups.equals(that.groups);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(groups);\n+        }\n+    }\n+\n+    private static final OperatorUsersDescriptor EMPTY_OPERATOR_USERS_DESCRIPTOR = new OperatorUsersDescriptor(List.of());\n+\n+    static final class Group {\n+        private static final Set<String> SINGLETON_REALM_TYPES = Set.of(\n+            FileRealmSettings.TYPE, NativeRealmSettings.TYPE, ReservedRealm.TYPE);\n+\n+        private final Set<String> usernames;\n+        private final String realmName;\n+        private final String realmType;\n+        private final Authentication.AuthenticationType authenticationType;\n+\n+        Group(Set<String> usernames) {\n+            this(usernames, null);\n+        }\n+\n+        Group(Set<String> usernames, @Nullable String realmName) {\n+            this(usernames, realmName, null, null);\n+        }\n+\n+        Group(Set<String> usernames, @Nullable String realmName, @Nullable String realmType,\n+                     @Nullable String authenticationType) {\n+            this.usernames = usernames;\n+            this.realmName = realmName;\n+            this.realmType = realmType == null ? FileRealmSettings.TYPE : realmType;\n+            this.authenticationType = authenticationType == null ? Authentication.AuthenticationType.REALM :\n+                Authentication.AuthenticationType.valueOf(authenticationType.toUpperCase(Locale.ROOT));\n+            validate();\n+        }\n+\n+        private void validate() {\n+            final ValidationException validationException = new ValidationException();\n+            if (false == FileRealmSettings.TYPE.equals(realmType)) {\n+                validationException.addValidationError(\"[realm_type] only supports [file]\");\n+            }\n+            if (Authentication.AuthenticationType.REALM != authenticationType) {\n+                validationException.addValidationError(\"[auth_type] only supports [realm]\");\n+            }\n+            if (realmName == null) {\n+                if (false == SINGLETON_REALM_TYPES.contains(realmType)) {\n+                    validationException.addValidationError(\n+                        \"[realm_name] must be specified for realm types other than [reserved], [file] and [native]\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1082b139f548520b4b790fbca6dace8c26410093"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM5MDY3Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.error(\"Failed to parse operator users file [\" + file + \"].\", e);\n          \n          \n            \n                            logger.error(new ParameterizedMessage(\"Failed to parse operator users file [{}].\", file), e);", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r532390677", "createdAt": "2020-11-30T07:27:12Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/operator/FileOperatorUsersStore.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.operator;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.ElasticsearchParseException;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.ValidationException;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.DeprecationHandler;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.env.Environment;\n+import org.elasticsearch.watcher.FileChangesListener;\n+import org.elasticsearch.watcher.FileWatcher;\n+import org.elasticsearch.watcher.ResourceWatcherService;\n+import org.elasticsearch.xpack.core.XPackPlugin;\n+import org.elasticsearch.xpack.core.security.authc.Authentication;\n+import org.elasticsearch.xpack.core.security.authc.esnative.NativeRealmSettings;\n+import org.elasticsearch.xpack.core.security.authc.file.FileRealmSettings;\n+import org.elasticsearch.xpack.core.security.user.User;\n+import org.elasticsearch.xpack.security.authc.esnative.ReservedRealm;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.constructorArg;\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.optionalConstructorArg;\n+import static org.elasticsearch.xpack.security.operator.OperatorPrivileges.OPERATOR_PRIVILEGES_ENABLED;\n+\n+public class FileOperatorUsersStore {\n+    private static final Logger logger = LogManager.getLogger(FileOperatorUsersStore.class);\n+\n+    private final Path file;\n+    private volatile OperatorUsersDescriptor operatorUsersDescriptor;\n+\n+    public FileOperatorUsersStore(Environment env, ResourceWatcherService watcherService) {\n+        this.file =  XPackPlugin.resolveConfigFile(env, \"operator_users.yml\");\n+        this.operatorUsersDescriptor = parseFile(this.file, logger);\n+        FileWatcher watcher = new FileWatcher(file.getParent());\n+        watcher.addListener(new FileOperatorUsersStore.FileListener());\n+        try {\n+            watcherService.add(watcher, ResourceWatcherService.Frequency.HIGH);\n+        } catch (IOException e) {\n+            throw new ElasticsearchException(\"Failed to start watching the operator users file [\" + file.toAbsolutePath() + \"]\", e);\n+        }\n+    }\n+\n+    public boolean isOperatorUser(Authentication authentication) {\n+        if (authentication.getUser().isRunAs()) {\n+            return false;\n+        } else if (User.isInternal(authentication.getUser())) {\n+            // Internal user are considered operator users\n+            return true;\n+        }\n+\n+        // Other than realm name, other criteria must always be an exact match for the user to be an operator.\n+        // Realm name of a descriptor can be null. When it is null, it is ignored for comparison.\n+        // If not null, it will be compared exactly as well.\n+        // The special handling for realm name is because there can only be one file or native realm and it does\n+        // not matter what the name is.\n+        return operatorUsersDescriptor.groups.stream().anyMatch(group -> {\n+            final Authentication.RealmRef realm = authentication.getSourceRealm();\n+            return group.usernames.contains(authentication.getUser().principal())\n+                && group.authenticationType == authentication.getAuthenticationType()\n+                && realm.getType().equals(group.realmType)\n+                && (group.realmName == null || group.realmName.equals(realm.getName()));\n+        });\n+    }\n+\n+    // Package private for tests\n+    public OperatorUsersDescriptor getOperatorUsersDescriptor() {\n+        return operatorUsersDescriptor;\n+    }\n+\n+    static final class OperatorUsersDescriptor {\n+        private final List<Group> groups;\n+\n+        private OperatorUsersDescriptor(List<Group> groups) {\n+            this.groups = groups;\n+        }\n+\n+        // Package private for tests\n+        List<Group> getGroups() {\n+            return groups;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o)\n+                return true;\n+            if (o == null || getClass() != o.getClass())\n+                return false;\n+            OperatorUsersDescriptor that = (OperatorUsersDescriptor) o;\n+            return groups.equals(that.groups);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(groups);\n+        }\n+    }\n+\n+    private static final OperatorUsersDescriptor EMPTY_OPERATOR_USERS_DESCRIPTOR = new OperatorUsersDescriptor(List.of());\n+\n+    static final class Group {\n+        private static final Set<String> SINGLETON_REALM_TYPES = Set.of(\n+            FileRealmSettings.TYPE, NativeRealmSettings.TYPE, ReservedRealm.TYPE);\n+\n+        private final Set<String> usernames;\n+        private final String realmName;\n+        private final String realmType;\n+        private final Authentication.AuthenticationType authenticationType;\n+\n+        Group(Set<String> usernames) {\n+            this(usernames, null);\n+        }\n+\n+        Group(Set<String> usernames, @Nullable String realmName) {\n+            this(usernames, realmName, null, null);\n+        }\n+\n+        Group(Set<String> usernames, @Nullable String realmName, @Nullable String realmType,\n+                     @Nullable String authenticationType) {\n+            this.usernames = usernames;\n+            this.realmName = realmName;\n+            this.realmType = realmType == null ? FileRealmSettings.TYPE : realmType;\n+            this.authenticationType = authenticationType == null ? Authentication.AuthenticationType.REALM :\n+                Authentication.AuthenticationType.valueOf(authenticationType.toUpperCase(Locale.ROOT));\n+            validate();\n+        }\n+\n+        private void validate() {\n+            final ValidationException validationException = new ValidationException();\n+            if (false == FileRealmSettings.TYPE.equals(realmType)) {\n+                validationException.addValidationError(\"[realm_type] only supports [file]\");\n+            }\n+            if (Authentication.AuthenticationType.REALM != authenticationType) {\n+                validationException.addValidationError(\"[auth_type] only supports [realm]\");\n+            }\n+            if (realmName == null) {\n+                if (false == SINGLETON_REALM_TYPES.contains(realmType)) {\n+                    validationException.addValidationError(\n+                        \"[realm_name] must be specified for realm types other than [reserved], [file] and [native]\");\n+                }\n+            }\n+            if (false == validationException.validationErrors().isEmpty()) {\n+                throw validationException;\n+            }\n+        }\n+\n+        @Override\n+        public String toString() {\n+            final StringBuilder sb = new StringBuilder(\"Group[\");\n+            sb.append(\"usernames=\").append(usernames);\n+            if (realmName != null) {\n+                sb.append(\", realm_name=\").append(realmName);\n+            }\n+            if (realmType != null) {\n+                sb.append(\", realm_type=\").append(realmType);\n+            }\n+            if (authenticationType != null) {\n+                sb.append(\", auth_type=\").append(authenticationType.name().toLowerCase(Locale.ROOT));\n+            }\n+            sb.append(\"]\");\n+            return sb.toString();\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o)\n+                return true;\n+            if (o == null || getClass() != o.getClass())\n+                return false;\n+            Group group = (Group) o;\n+            return usernames.equals(group.usernames)\n+              && Objects.equals(realmName, group.realmName)\n+              && realmType.equals(group.realmType)\n+              && authenticationType == group.authenticationType;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(usernames, realmName, realmType, authenticationType);\n+        }\n+    }\n+\n+    public static OperatorUsersDescriptor parseFile(Path file, Logger logger) {\n+        if (false == Files.exists(file)) {\n+            logger.warn(\"Operator privileges [{}] is enabled, but operator user file does not exist. \" +\n+                    \"No user will be able to perform operator-only actions.\", OPERATOR_PRIVILEGES_ENABLED.getKey());\n+            return EMPTY_OPERATOR_USERS_DESCRIPTOR;\n+        } else {\n+            logger.debug(\"Reading operator users file [{}]\", file.toAbsolutePath());\n+            try (InputStream in = Files.newInputStream(file, StandardOpenOption.READ)) {\n+                return parseConfig(in);\n+            } catch (IOException | RuntimeException e) {\n+                logger.error(\"Failed to parse operator users file [\" + file + \"].\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1082b139f548520b4b790fbca6dace8c26410093"}, "originalPosition": 213}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM5MTAwOA==", "bodyText": "Should we remove these now?", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r532391008", "createdAt": "2020-11-30T07:28:12Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/operator/OperatorOnlyRegistry.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.operator;\n+\n+import org.elasticsearch.action.admin.cluster.configuration.AddVotingConfigExclusionsAction;\n+import org.elasticsearch.action.admin.cluster.configuration.ClearVotingConfigExclusionsAction;\n+import org.elasticsearch.action.admin.cluster.repositories.delete.DeleteRepositoryAction;\n+import org.elasticsearch.action.admin.cluster.repositories.delete.DeleteRepositoryRequest;\n+import org.elasticsearch.action.admin.cluster.settings.ClusterUpdateSettingsAction;\n+import org.elasticsearch.action.admin.cluster.settings.ClusterUpdateSettingsRequest;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.util.set.Sets;\n+import org.elasticsearch.license.DeleteLicenseAction;\n+import org.elasticsearch.license.PutLicenseAction;\n+import org.elasticsearch.transport.TransportRequest;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import static org.elasticsearch.xpack.security.transport.filter.IPFilter.IP_FILTER_ENABLED_HTTP_SETTING;\n+import static org.elasticsearch.xpack.security.transport.filter.IPFilter.IP_FILTER_ENABLED_SETTING;\n+\n+public class OperatorOnlyRegistry {\n+\n+    public static final Set<String> SIMPLE_ACTIONS = Set.of(AddVotingConfigExclusionsAction.NAME,\n+        ClearVotingConfigExclusionsAction.NAME,\n+        PutLicenseAction.NAME,\n+        DeleteLicenseAction.NAME,\n+        // Autoscaling does not publish its actions to core, literal strings are needed.\n+        \"cluster:admin/autoscaling/put_autoscaling_policy\",\n+        \"cluster:admin/autoscaling/delete_autoscaling_policy\",\n+        \"cluster:admin/autoscaling/get_autoscaling_policy\",\n+        \"cluster:admin/autoscaling/get_autoscaling_capacity\");\n+\n+    // This class is a prototype to showcase what it would look like for operator only settings\n+    // It may NOT be included in phase 1 delivery. Also this may end up using Enum Property to\n+    // mark operator only settings instead of using the list here.\n+    public static final Set<String> SIMPLE_SETTINGS = Set.of(IP_FILTER_ENABLED_HTTP_SETTING.getKey(), IP_FILTER_ENABLED_SETTING.getKey(),\n+        // TODO: Use literal strings due to dependency. Alternatively we can let each plugin publish names of operator settings\n+        \"xpack.ml.max_machine_memory_percent\", \"xpack.ml.max_model_memory_limit\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1082b139f548520b4b790fbca6dace8c26410093"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM5MjM5Ng==", "bodyText": "This might feel less weird if we had a custom interface instead.\npublic interface OperatorPrivilegeViolation {\n   public String message();\n}\n\nThen it feel more natural to return null if there's no violation.", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r532392396", "createdAt": "2020-11-30T07:32:00Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/operator/OperatorOnlyRegistry.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.operator;\n+\n+import org.elasticsearch.action.admin.cluster.configuration.AddVotingConfigExclusionsAction;\n+import org.elasticsearch.action.admin.cluster.configuration.ClearVotingConfigExclusionsAction;\n+import org.elasticsearch.action.admin.cluster.repositories.delete.DeleteRepositoryAction;\n+import org.elasticsearch.action.admin.cluster.repositories.delete.DeleteRepositoryRequest;\n+import org.elasticsearch.action.admin.cluster.settings.ClusterUpdateSettingsAction;\n+import org.elasticsearch.action.admin.cluster.settings.ClusterUpdateSettingsRequest;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.util.set.Sets;\n+import org.elasticsearch.license.DeleteLicenseAction;\n+import org.elasticsearch.license.PutLicenseAction;\n+import org.elasticsearch.transport.TransportRequest;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import static org.elasticsearch.xpack.security.transport.filter.IPFilter.IP_FILTER_ENABLED_HTTP_SETTING;\n+import static org.elasticsearch.xpack.security.transport.filter.IPFilter.IP_FILTER_ENABLED_SETTING;\n+\n+public class OperatorOnlyRegistry {\n+\n+    public static final Set<String> SIMPLE_ACTIONS = Set.of(AddVotingConfigExclusionsAction.NAME,\n+        ClearVotingConfigExclusionsAction.NAME,\n+        PutLicenseAction.NAME,\n+        DeleteLicenseAction.NAME,\n+        // Autoscaling does not publish its actions to core, literal strings are needed.\n+        \"cluster:admin/autoscaling/put_autoscaling_policy\",\n+        \"cluster:admin/autoscaling/delete_autoscaling_policy\",\n+        \"cluster:admin/autoscaling/get_autoscaling_policy\",\n+        \"cluster:admin/autoscaling/get_autoscaling_capacity\");\n+\n+    // This class is a prototype to showcase what it would look like for operator only settings\n+    // It may NOT be included in phase 1 delivery. Also this may end up using Enum Property to\n+    // mark operator only settings instead of using the list here.\n+    public static final Set<String> SIMPLE_SETTINGS = Set.of(IP_FILTER_ENABLED_HTTP_SETTING.getKey(), IP_FILTER_ENABLED_SETTING.getKey(),\n+        // TODO: Use literal strings due to dependency. Alternatively we can let each plugin publish names of operator settings\n+        \"xpack.ml.max_machine_memory_percent\", \"xpack.ml.max_model_memory_limit\");\n+\n+    // This map is just to showcase how \"partial\" operator-only API would work.\n+    // It will be REMOVED before phase 1 delivery.\n+    public static final Map<String, Function<TransportRequest, Supplier<String>>> PARAMETER_SENSITIVE_ACTIONS =\n+        Map.of(DeleteRepositoryAction.NAME, (request) -> {\n+            assert request instanceof DeleteRepositoryRequest;\n+            final DeleteRepositoryRequest deleteRepositoryRequest = (DeleteRepositoryRequest) request;\n+            if (\"found-snapshots\".equals(deleteRepositoryRequest.name())) {\n+                return () -> \"action [\" + DeleteRepositoryAction.NAME + \"] with repository [\" + deleteRepositoryRequest.name();\n+            } else {\n+                return null;\n+            }\n+        });\n+\n+    // The return type is a bit weird, but it is a shortcut to avoid having to use either\n+    // a Tuple or a new class to hold true/false and a message/null.\n+    // Since the combination is either true+message or false+null, it is possible to just\n+    // use the existence of the message to also indicate whether the result is true or false.\n+    public Supplier<String> check(String action, TransportRequest request) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1082b139f548520b4b790fbca6dace8c26410093"}, "originalPosition": 66}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c3fa2bae4dd76fc02dbbd19564d5d10e27c76190", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/c3fa2bae4dd76fc02dbbd19564d5d10e27c76190", "committedDate": "2020-11-30T11:54:42Z", "message": "Update x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/operator/FileOperatorUsersStore.java\n\nCo-authored-by: Tim Vernum <tim@adjective.org>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4cf5b0873ebe60edc70d6c263774bcf0ad78e73a", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/4cf5b0873ebe60edc70d6c263774bcf0ad78e73a", "committedDate": "2020-11-30T11:55:18Z", "message": "wip"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "973e7a5da693e247dbc61ba6b7c67daf91d0203a", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/973e7a5da693e247dbc61ba6b7c67daf91d0203a", "committedDate": "2020-11-30T11:55:18Z", "message": "Address feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2ae1bef7a0e39fe51d2d9c5e0cc150f4acb00a1d", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/2ae1bef7a0e39fe51d2d9c5e0cc150f4acb00a1d", "committedDate": "2020-11-30T11:59:32Z", "message": "Fix import"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "91d2ef0b150150e69cc4b8b7a9c3c352e3663fa6", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/91d2ef0b150150e69cc4b8b7a9c3c352e3663fa6", "committedDate": "2020-11-30T22:10:39Z", "message": "Tweak"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6bddcff16232142d958ca17ac50644f21fdccdf1", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/6bddcff16232142d958ca17ac50644f21fdccdf1", "committedDate": "2020-11-30T23:24:37Z", "message": "fix test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQyNTQzMDE2", "url": "https://github.com/elastic/elasticsearch/pull/65256#pullrequestreview-542543016", "createdAt": "2020-12-02T06:56:56Z", "commit": {"oid": "6bddcff16232142d958ca17ac50644f21fdccdf1"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQwNjo1Njo1NlrOH9M1KQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQwNjo1Njo1NlrOH9M1KQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzkzNTQwMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public interface OperatorPrivilegesViolation {\n          \n          \n            \n                @FunctionalInterface\n          \n          \n            \n                public interface OperatorPrivilegesViolation {", "url": "https://github.com/elastic/elasticsearch/pull/65256#discussion_r533935401", "createdAt": "2020-12-02T06:56:56Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/operator/OperatorOnlyRegistry.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.operator;\n+\n+import org.elasticsearch.action.admin.cluster.configuration.AddVotingConfigExclusionsAction;\n+import org.elasticsearch.action.admin.cluster.configuration.ClearVotingConfigExclusionsAction;\n+import org.elasticsearch.license.DeleteLicenseAction;\n+import org.elasticsearch.license.PutLicenseAction;\n+import org.elasticsearch.transport.TransportRequest;\n+\n+import java.util.Set;\n+\n+public class OperatorOnlyRegistry {\n+\n+    public static final Set<String> SIMPLE_ACTIONS = Set.of(AddVotingConfigExclusionsAction.NAME,\n+        ClearVotingConfigExclusionsAction.NAME,\n+        PutLicenseAction.NAME,\n+        DeleteLicenseAction.NAME,\n+        // Autoscaling does not publish its actions to core, literal strings are needed.\n+        \"cluster:admin/autoscaling/put_autoscaling_policy\",\n+        \"cluster:admin/autoscaling/delete_autoscaling_policy\",\n+        \"cluster:admin/autoscaling/get_autoscaling_policy\",\n+        \"cluster:admin/autoscaling/get_autoscaling_capacity\");\n+\n+    /**\n+     * Check whether the given action and request qualify as operator-only. The method returns\n+     * null if the action+request is NOT operator-only. Other it returns a violation object\n+     * that contains the message for details.\n+     */\n+    public OperatorPrivilegesViolation check(String action, TransportRequest request) {\n+        if (SIMPLE_ACTIONS.contains(action)) {\n+            return () -> \"action [\" + action + \"]\";\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    public interface OperatorPrivilegesViolation {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bddcff16232142d958ca17ac50644f21fdccdf1"}, "originalPosition": 42}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e7042f90b146b48791cd07fc3f2711f918ad7197", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/e7042f90b146b48791cd07fc3f2711f918ad7197", "committedDate": "2020-12-03T04:31:08Z", "message": "Update x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/operator/OperatorOnlyRegistry.java\n\nCo-authored-by: Tim Vernum <tim@adjective.org>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5807b330cb310858780ca808e6fe51a55a474ee8", "author": {"user": {"login": "ywangd", "name": "Yang Wang"}}, "url": "https://github.com/elastic/elasticsearch/commit/5807b330cb310858780ca808e6fe51a55a474ee8", "committedDate": "2020-12-03T04:32:02Z", "message": "Merge remote-tracking branch 'origin/master' into meta-101-operator-privileges-phase-one"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 881, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}