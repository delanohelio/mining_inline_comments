{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgwODM1MjE4", "number": 52886, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNDoxMzoxNlrODj04gQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMTozMjo0OFrODlY3Vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4ODkzMTg1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/action/GrantApiKeyRequest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNDoxMzoxN1rOFv2Q3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwNTo1OToyM1rOFw5OMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTcxNjQ0Ng==", "bodyText": "use a local var for the type since we use it multiple times below", "url": "https://github.com/elastic/elasticsearch/pull/52886#discussion_r385716446", "createdAt": "2020-02-28T14:13:17Z", "author": {"login": "jkakavas"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/action/GrantApiKeyRequest.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.action;\n+\n+import org.elasticsearch.action.ActionRequest;\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.support.WriteRequest;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.settings.SecureString;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.action.ValidateActions.addValidationError;\n+\n+/**\n+ * Request class used for the creation of an API key on behalf of another user.\n+ * Logically this is similar to {@link CreateApiKeyRequest}, but is for cases when the user that has permission to call this action\n+ * is different to the user for whom the API key should be created\n+ */\n+public final class GrantApiKeyRequest extends ActionRequest {\n+\n+    public static final WriteRequest.RefreshPolicy DEFAULT_REFRESH_POLICY = WriteRequest.RefreshPolicy.WAIT_UNTIL;\n+    public static final String PASSWORD_GRANT_TYPE = \"password\";\n+    public static final String ACCESS_TOKEN_GRANT_TYPE = \"access_token\";\n+\n+    /**\n+     * Fields related to the end user authentication\n+     */\n+    public static class Grant implements Writeable {\n+        private String type;\n+        private String username;\n+        private SecureString password;\n+        private SecureString accessToken;\n+\n+        public Grant() {\n+        }\n+\n+        public Grant(StreamInput in) throws IOException {\n+            this.type = in.readString();\n+            this.username = in.readOptionalString();\n+            this.password = in.readOptionalSecureString();\n+            this.accessToken = in.readOptionalSecureString();\n+        }\n+\n+        public void writeTo(StreamOutput out) throws IOException {\n+            out.writeString(type);\n+            out.writeOptionalString(username);\n+            out.writeOptionalSecureString(password);\n+            out.writeOptionalSecureString(accessToken);\n+        }\n+\n+        public String getType() {\n+            return type;\n+        }\n+\n+        public String getUsername() {\n+            return username;\n+        }\n+\n+        public SecureString getPassword() {\n+            return password;\n+        }\n+\n+        public SecureString getAccessToken() {\n+            return accessToken;\n+        }\n+\n+        public void setType(String type) {\n+            this.type = type;\n+        }\n+\n+        public void setUsername(String username) {\n+            this.username = username;\n+        }\n+\n+        public void setPassword(SecureString password) {\n+            this.password = password;\n+        }\n+\n+        public void setAccessToken(SecureString accessToken) {\n+            this.accessToken = accessToken;\n+        }\n+    }\n+\n+    private final Grant grant;\n+    private CreateApiKeyRequest apiKey;\n+    private WriteRequest.RefreshPolicy refreshPolicy;\n+\n+    public GrantApiKeyRequest() {\n+        this.grant = new Grant();\n+        this.apiKey = new CreateApiKeyRequest();\n+        this.refreshPolicy = DEFAULT_REFRESH_POLICY;\n+    }\n+\n+    public GrantApiKeyRequest(StreamInput in) throws IOException {\n+        super(in);\n+        this.grant = new Grant(in);\n+        this.apiKey = new CreateApiKeyRequest(in);\n+        this.refreshPolicy = WriteRequest.RefreshPolicy.readFrom(in);\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        super.writeTo(out);\n+        grant.writeTo(out);\n+        apiKey.writeTo(out);\n+        refreshPolicy.writeTo(out);\n+    }\n+\n+    public WriteRequest.RefreshPolicy getRefreshPolicy() {\n+        return refreshPolicy;\n+    }\n+\n+    public void setRefreshPolicy(WriteRequest.RefreshPolicy refreshPolicy) {\n+        this.refreshPolicy = Objects.requireNonNull(refreshPolicy, \"refresh policy may not be null\");\n+    }\n+\n+    public Grant getGrant() {\n+        return grant;\n+    }\n+\n+    public CreateApiKeyRequest getApiKeyRequest() {\n+        return apiKey;\n+    }\n+\n+    public void setApiKeyRequest(CreateApiKeyRequest apiKeyRequest) {\n+        this.apiKey = Objects.requireNonNull(apiKeyRequest, \"Cannot set a null api_key\");\n+    }\n+\n+    @Override\n+    public ActionRequestValidationException validate() {\n+        ActionRequestValidationException validationException = apiKey.validate();\n+        if (grant.type == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17d292f52d9fd1d9ff51a1944cf230d2df28c955"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM0NzYxMw==", "bodyText": "Can do, but is there a reason why you'd like that?", "url": "https://github.com/elastic/elasticsearch/pull/52886#discussion_r386347613", "createdAt": "2020-03-02T11:49:00Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/action/GrantApiKeyRequest.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.action;\n+\n+import org.elasticsearch.action.ActionRequest;\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.support.WriteRequest;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.settings.SecureString;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.action.ValidateActions.addValidationError;\n+\n+/**\n+ * Request class used for the creation of an API key on behalf of another user.\n+ * Logically this is similar to {@link CreateApiKeyRequest}, but is for cases when the user that has permission to call this action\n+ * is different to the user for whom the API key should be created\n+ */\n+public final class GrantApiKeyRequest extends ActionRequest {\n+\n+    public static final WriteRequest.RefreshPolicy DEFAULT_REFRESH_POLICY = WriteRequest.RefreshPolicy.WAIT_UNTIL;\n+    public static final String PASSWORD_GRANT_TYPE = \"password\";\n+    public static final String ACCESS_TOKEN_GRANT_TYPE = \"access_token\";\n+\n+    /**\n+     * Fields related to the end user authentication\n+     */\n+    public static class Grant implements Writeable {\n+        private String type;\n+        private String username;\n+        private SecureString password;\n+        private SecureString accessToken;\n+\n+        public Grant() {\n+        }\n+\n+        public Grant(StreamInput in) throws IOException {\n+            this.type = in.readString();\n+            this.username = in.readOptionalString();\n+            this.password = in.readOptionalSecureString();\n+            this.accessToken = in.readOptionalSecureString();\n+        }\n+\n+        public void writeTo(StreamOutput out) throws IOException {\n+            out.writeString(type);\n+            out.writeOptionalString(username);\n+            out.writeOptionalSecureString(password);\n+            out.writeOptionalSecureString(accessToken);\n+        }\n+\n+        public String getType() {\n+            return type;\n+        }\n+\n+        public String getUsername() {\n+            return username;\n+        }\n+\n+        public SecureString getPassword() {\n+            return password;\n+        }\n+\n+        public SecureString getAccessToken() {\n+            return accessToken;\n+        }\n+\n+        public void setType(String type) {\n+            this.type = type;\n+        }\n+\n+        public void setUsername(String username) {\n+            this.username = username;\n+        }\n+\n+        public void setPassword(SecureString password) {\n+            this.password = password;\n+        }\n+\n+        public void setAccessToken(SecureString accessToken) {\n+            this.accessToken = accessToken;\n+        }\n+    }\n+\n+    private final Grant grant;\n+    private CreateApiKeyRequest apiKey;\n+    private WriteRequest.RefreshPolicy refreshPolicy;\n+\n+    public GrantApiKeyRequest() {\n+        this.grant = new Grant();\n+        this.apiKey = new CreateApiKeyRequest();\n+        this.refreshPolicy = DEFAULT_REFRESH_POLICY;\n+    }\n+\n+    public GrantApiKeyRequest(StreamInput in) throws IOException {\n+        super(in);\n+        this.grant = new Grant(in);\n+        this.apiKey = new CreateApiKeyRequest(in);\n+        this.refreshPolicy = WriteRequest.RefreshPolicy.readFrom(in);\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        super.writeTo(out);\n+        grant.writeTo(out);\n+        apiKey.writeTo(out);\n+        refreshPolicy.writeTo(out);\n+    }\n+\n+    public WriteRequest.RefreshPolicy getRefreshPolicy() {\n+        return refreshPolicy;\n+    }\n+\n+    public void setRefreshPolicy(WriteRequest.RefreshPolicy refreshPolicy) {\n+        this.refreshPolicy = Objects.requireNonNull(refreshPolicy, \"refresh policy may not be null\");\n+    }\n+\n+    public Grant getGrant() {\n+        return grant;\n+    }\n+\n+    public CreateApiKeyRequest getApiKeyRequest() {\n+        return apiKey;\n+    }\n+\n+    public void setApiKeyRequest(CreateApiKeyRequest apiKeyRequest) {\n+        this.apiKey = Objects.requireNonNull(apiKeyRequest, \"Cannot set a null api_key\");\n+    }\n+\n+    @Override\n+    public ActionRequestValidationException validate() {\n+        ActionRequestValidationException validationException = apiKey.validate();\n+        if (grant.type == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTcxNjQ0Ng=="}, "originalCommit": {"oid": "17d292f52d9fd1d9ff51a1944cf230d2df28c955"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjgxMzQ4OA==", "bodyText": "Not the end of the world as we know it, I think it reads better, feel free to decide.", "url": "https://github.com/elastic/elasticsearch/pull/52886#discussion_r386813488", "createdAt": "2020-03-03T05:59:23Z", "author": {"login": "jkakavas"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/action/GrantApiKeyRequest.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.action;\n+\n+import org.elasticsearch.action.ActionRequest;\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.support.WriteRequest;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.settings.SecureString;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.action.ValidateActions.addValidationError;\n+\n+/**\n+ * Request class used for the creation of an API key on behalf of another user.\n+ * Logically this is similar to {@link CreateApiKeyRequest}, but is for cases when the user that has permission to call this action\n+ * is different to the user for whom the API key should be created\n+ */\n+public final class GrantApiKeyRequest extends ActionRequest {\n+\n+    public static final WriteRequest.RefreshPolicy DEFAULT_REFRESH_POLICY = WriteRequest.RefreshPolicy.WAIT_UNTIL;\n+    public static final String PASSWORD_GRANT_TYPE = \"password\";\n+    public static final String ACCESS_TOKEN_GRANT_TYPE = \"access_token\";\n+\n+    /**\n+     * Fields related to the end user authentication\n+     */\n+    public static class Grant implements Writeable {\n+        private String type;\n+        private String username;\n+        private SecureString password;\n+        private SecureString accessToken;\n+\n+        public Grant() {\n+        }\n+\n+        public Grant(StreamInput in) throws IOException {\n+            this.type = in.readString();\n+            this.username = in.readOptionalString();\n+            this.password = in.readOptionalSecureString();\n+            this.accessToken = in.readOptionalSecureString();\n+        }\n+\n+        public void writeTo(StreamOutput out) throws IOException {\n+            out.writeString(type);\n+            out.writeOptionalString(username);\n+            out.writeOptionalSecureString(password);\n+            out.writeOptionalSecureString(accessToken);\n+        }\n+\n+        public String getType() {\n+            return type;\n+        }\n+\n+        public String getUsername() {\n+            return username;\n+        }\n+\n+        public SecureString getPassword() {\n+            return password;\n+        }\n+\n+        public SecureString getAccessToken() {\n+            return accessToken;\n+        }\n+\n+        public void setType(String type) {\n+            this.type = type;\n+        }\n+\n+        public void setUsername(String username) {\n+            this.username = username;\n+        }\n+\n+        public void setPassword(SecureString password) {\n+            this.password = password;\n+        }\n+\n+        public void setAccessToken(SecureString accessToken) {\n+            this.accessToken = accessToken;\n+        }\n+    }\n+\n+    private final Grant grant;\n+    private CreateApiKeyRequest apiKey;\n+    private WriteRequest.RefreshPolicy refreshPolicy;\n+\n+    public GrantApiKeyRequest() {\n+        this.grant = new Grant();\n+        this.apiKey = new CreateApiKeyRequest();\n+        this.refreshPolicy = DEFAULT_REFRESH_POLICY;\n+    }\n+\n+    public GrantApiKeyRequest(StreamInput in) throws IOException {\n+        super(in);\n+        this.grant = new Grant(in);\n+        this.apiKey = new CreateApiKeyRequest(in);\n+        this.refreshPolicy = WriteRequest.RefreshPolicy.readFrom(in);\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        super.writeTo(out);\n+        grant.writeTo(out);\n+        apiKey.writeTo(out);\n+        refreshPolicy.writeTo(out);\n+    }\n+\n+    public WriteRequest.RefreshPolicy getRefreshPolicy() {\n+        return refreshPolicy;\n+    }\n+\n+    public void setRefreshPolicy(WriteRequest.RefreshPolicy refreshPolicy) {\n+        this.refreshPolicy = Objects.requireNonNull(refreshPolicy, \"refresh policy may not be null\");\n+    }\n+\n+    public Grant getGrant() {\n+        return grant;\n+    }\n+\n+    public CreateApiKeyRequest getApiKeyRequest() {\n+        return apiKey;\n+    }\n+\n+    public void setApiKeyRequest(CreateApiKeyRequest apiKeyRequest) {\n+        this.apiKey = Objects.requireNonNull(apiKeyRequest, \"Cannot set a null api_key\");\n+    }\n+\n+    @Override\n+    public ActionRequestValidationException validate() {\n+        ActionRequestValidationException validationException = apiKey.validate();\n+        if (grant.type == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTcxNjQ0Ng=="}, "originalCommit": {"oid": "17d292f52d9fd1d9ff51a1944cf230d2df28c955"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4OTAxMjkzOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/qa/security-basic/src/test/java/org/elasticsearch/xpack/security/apikey/ApiKeyRestIT.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNDozNzoyMFrOFv3DLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQwMzo0NzoxOFrOFyFmEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTcyOTMyNw==", "bodyText": "should we add one with access_token grant since we're at it?", "url": "https://github.com/elastic/elasticsearch/pull/52886#discussion_r385729327", "createdAt": "2020-02-28T14:37:20Z", "author": {"login": "jkakavas"}, "path": "x-pack/plugin/security/qa/security-basic/src/test/java/org/elasticsearch/xpack/security/apikey/ApiKeyRestIT.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.apikey;\n+\n+import org.elasticsearch.client.Request;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.client.Response;\n+import org.elasticsearch.client.security.support.ApiKey;\n+import org.elasticsearch.common.settings.SecureString;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.test.XContentTestUtils;\n+import org.elasticsearch.xpack.core.security.authc.support.UsernamePasswordToken;\n+import org.elasticsearch.xpack.security.SecurityInBasicRestTestCase;\n+import org.junit.After;\n+import org.junit.Before;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.notNullValue;\n+\n+/**\n+ * This IT runs in the \"security-basic\" QA test because it has a working cluster with\n+ * API keys enabled, and there's no reason to have a dedicated QA project for API keys.\n+ */\n+public class ApiKeyRestIT extends SecurityInBasicRestTestCase {\n+\n+    private static final String SYSTEM_USER = \"system_user\";\n+    private static final SecureString SYSTEM_USER_PASSWORD = new SecureString(\"sys-pass\".toCharArray());\n+    private static final String END_USER = \"end_user\";\n+    private static final SecureString END_USER_PASSWORD = new SecureString(\"user-pass\".toCharArray());\n+\n+    @Before\n+    public void createUsers() throws IOException {\n+        createUser(SYSTEM_USER, SYSTEM_USER_PASSWORD, List.of(\"system_role\"));\n+        createRole(\"system_role\", Set.of(\"manage_api_key\"));\n+        createUser(END_USER, END_USER_PASSWORD, List.of(\"user_role\"));\n+        createRole(\"user_role\", Set.of(\"monitor\"));\n+    }\n+\n+    @After\n+    public void cleanUp() throws IOException {\n+        deleteUser(\"system_user\");\n+        deleteUser(\"end_user\");\n+        deleteRole(\"system_role\");\n+        deleteRole(\"user_role\");\n+        invalidateApiKeysForUser(END_USER);\n+    }\n+\n+    public void testGrantApiKeyForOtherUser() throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17d292f52d9fd1d9ff51a1944cf230d2df28c955"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM0OTY5NA==", "bodyText": "I can't in this test, because basic license doesn't suppor tokens, but I can move the test elsewhere and do that if you'd like it.\nSince the transport action test already covers Username+Password and AccessToken (both valid and invalid), I didn't think it was necessary to cover it again in the IT. I just wanted something integrated to test it top-to-bottom.\nTesting's a tricky balance, so if it's something you think we need, I'm happy to make it happen (but it will probably means a whole new QA project for rest tests using  security on trial licenses).", "url": "https://github.com/elastic/elasticsearch/pull/52886#discussion_r386349694", "createdAt": "2020-03-02T11:53:57Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/qa/security-basic/src/test/java/org/elasticsearch/xpack/security/apikey/ApiKeyRestIT.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.apikey;\n+\n+import org.elasticsearch.client.Request;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.client.Response;\n+import org.elasticsearch.client.security.support.ApiKey;\n+import org.elasticsearch.common.settings.SecureString;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.test.XContentTestUtils;\n+import org.elasticsearch.xpack.core.security.authc.support.UsernamePasswordToken;\n+import org.elasticsearch.xpack.security.SecurityInBasicRestTestCase;\n+import org.junit.After;\n+import org.junit.Before;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.notNullValue;\n+\n+/**\n+ * This IT runs in the \"security-basic\" QA test because it has a working cluster with\n+ * API keys enabled, and there's no reason to have a dedicated QA project for API keys.\n+ */\n+public class ApiKeyRestIT extends SecurityInBasicRestTestCase {\n+\n+    private static final String SYSTEM_USER = \"system_user\";\n+    private static final SecureString SYSTEM_USER_PASSWORD = new SecureString(\"sys-pass\".toCharArray());\n+    private static final String END_USER = \"end_user\";\n+    private static final SecureString END_USER_PASSWORD = new SecureString(\"user-pass\".toCharArray());\n+\n+    @Before\n+    public void createUsers() throws IOException {\n+        createUser(SYSTEM_USER, SYSTEM_USER_PASSWORD, List.of(\"system_role\"));\n+        createRole(\"system_role\", Set.of(\"manage_api_key\"));\n+        createUser(END_USER, END_USER_PASSWORD, List.of(\"user_role\"));\n+        createRole(\"user_role\", Set.of(\"monitor\"));\n+    }\n+\n+    @After\n+    public void cleanUp() throws IOException {\n+        deleteUser(\"system_user\");\n+        deleteUser(\"end_user\");\n+        deleteRole(\"system_role\");\n+        deleteRole(\"user_role\");\n+        invalidateApiKeysForUser(END_USER);\n+    }\n+\n+    public void testGrantApiKeyForOtherUser() throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTcyOTMyNw=="}, "originalCommit": {"oid": "17d292f52d9fd1d9ff51a1944cf230d2df28c955"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjgxMzYwOA==", "bodyText": "SGTM to leave it as is", "url": "https://github.com/elastic/elasticsearch/pull/52886#discussion_r386813608", "createdAt": "2020-03-03T05:59:52Z", "author": {"login": "jkakavas"}, "path": "x-pack/plugin/security/qa/security-basic/src/test/java/org/elasticsearch/xpack/security/apikey/ApiKeyRestIT.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.apikey;\n+\n+import org.elasticsearch.client.Request;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.client.Response;\n+import org.elasticsearch.client.security.support.ApiKey;\n+import org.elasticsearch.common.settings.SecureString;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.test.XContentTestUtils;\n+import org.elasticsearch.xpack.core.security.authc.support.UsernamePasswordToken;\n+import org.elasticsearch.xpack.security.SecurityInBasicRestTestCase;\n+import org.junit.After;\n+import org.junit.Before;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.notNullValue;\n+\n+/**\n+ * This IT runs in the \"security-basic\" QA test because it has a working cluster with\n+ * API keys enabled, and there's no reason to have a dedicated QA project for API keys.\n+ */\n+public class ApiKeyRestIT extends SecurityInBasicRestTestCase {\n+\n+    private static final String SYSTEM_USER = \"system_user\";\n+    private static final SecureString SYSTEM_USER_PASSWORD = new SecureString(\"sys-pass\".toCharArray());\n+    private static final String END_USER = \"end_user\";\n+    private static final SecureString END_USER_PASSWORD = new SecureString(\"user-pass\".toCharArray());\n+\n+    @Before\n+    public void createUsers() throws IOException {\n+        createUser(SYSTEM_USER, SYSTEM_USER_PASSWORD, List.of(\"system_role\"));\n+        createRole(\"system_role\", Set.of(\"manage_api_key\"));\n+        createUser(END_USER, END_USER_PASSWORD, List.of(\"user_role\"));\n+        createRole(\"user_role\", Set.of(\"monitor\"));\n+    }\n+\n+    @After\n+    public void cleanUp() throws IOException {\n+        deleteUser(\"system_user\");\n+        deleteUser(\"end_user\");\n+        deleteRole(\"system_role\");\n+        deleteRole(\"user_role\");\n+        invalidateApiKeysForUser(END_USER);\n+    }\n+\n+    public void testGrantApiKeyForOtherUser() throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTcyOTMyNw=="}, "originalCommit": {"oid": "17d292f52d9fd1d9ff51a1944cf230d2df28c955"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk3Mzc1Mw==", "bodyText": "I can't in this test, because basic license doesn't support tokens\n\nBut you can start a trial, as it's done in SecurityWithBasicLicenseIT#testWithTrialLicense , right ? If this is possible, I would also just slightly prefer a test case using tokens.", "url": "https://github.com/elastic/elasticsearch/pull/52886#discussion_r387973753", "createdAt": "2020-03-04T22:30:13Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/qa/security-basic/src/test/java/org/elasticsearch/xpack/security/apikey/ApiKeyRestIT.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.apikey;\n+\n+import org.elasticsearch.client.Request;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.client.Response;\n+import org.elasticsearch.client.security.support.ApiKey;\n+import org.elasticsearch.common.settings.SecureString;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.test.XContentTestUtils;\n+import org.elasticsearch.xpack.core.security.authc.support.UsernamePasswordToken;\n+import org.elasticsearch.xpack.security.SecurityInBasicRestTestCase;\n+import org.junit.After;\n+import org.junit.Before;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.notNullValue;\n+\n+/**\n+ * This IT runs in the \"security-basic\" QA test because it has a working cluster with\n+ * API keys enabled, and there's no reason to have a dedicated QA project for API keys.\n+ */\n+public class ApiKeyRestIT extends SecurityInBasicRestTestCase {\n+\n+    private static final String SYSTEM_USER = \"system_user\";\n+    private static final SecureString SYSTEM_USER_PASSWORD = new SecureString(\"sys-pass\".toCharArray());\n+    private static final String END_USER = \"end_user\";\n+    private static final SecureString END_USER_PASSWORD = new SecureString(\"user-pass\".toCharArray());\n+\n+    @Before\n+    public void createUsers() throws IOException {\n+        createUser(SYSTEM_USER, SYSTEM_USER_PASSWORD, List.of(\"system_role\"));\n+        createRole(\"system_role\", Set.of(\"manage_api_key\"));\n+        createUser(END_USER, END_USER_PASSWORD, List.of(\"user_role\"));\n+        createRole(\"user_role\", Set.of(\"monitor\"));\n+    }\n+\n+    @After\n+    public void cleanUp() throws IOException {\n+        deleteUser(\"system_user\");\n+        deleteUser(\"end_user\");\n+        deleteRole(\"system_role\");\n+        deleteRole(\"user_role\");\n+        invalidateApiKeysForUser(END_USER);\n+    }\n+\n+    public void testGrantApiKeyForOtherUser() throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTcyOTMyNw=="}, "originalCommit": {"oid": "17d292f52d9fd1d9ff51a1944cf230d2df28c955"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk3ODQyMQ==", "bodyText": "No, because a cluster can only start a trial once, and the other test does that.\nIf we want to test this with a non-basic license then we'll need a new QA project.", "url": "https://github.com/elastic/elasticsearch/pull/52886#discussion_r387978421", "createdAt": "2020-03-04T22:41:39Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/qa/security-basic/src/test/java/org/elasticsearch/xpack/security/apikey/ApiKeyRestIT.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.apikey;\n+\n+import org.elasticsearch.client.Request;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.client.Response;\n+import org.elasticsearch.client.security.support.ApiKey;\n+import org.elasticsearch.common.settings.SecureString;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.test.XContentTestUtils;\n+import org.elasticsearch.xpack.core.security.authc.support.UsernamePasswordToken;\n+import org.elasticsearch.xpack.security.SecurityInBasicRestTestCase;\n+import org.junit.After;\n+import org.junit.Before;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.notNullValue;\n+\n+/**\n+ * This IT runs in the \"security-basic\" QA test because it has a working cluster with\n+ * API keys enabled, and there's no reason to have a dedicated QA project for API keys.\n+ */\n+public class ApiKeyRestIT extends SecurityInBasicRestTestCase {\n+\n+    private static final String SYSTEM_USER = \"system_user\";\n+    private static final SecureString SYSTEM_USER_PASSWORD = new SecureString(\"sys-pass\".toCharArray());\n+    private static final String END_USER = \"end_user\";\n+    private static final SecureString END_USER_PASSWORD = new SecureString(\"user-pass\".toCharArray());\n+\n+    @Before\n+    public void createUsers() throws IOException {\n+        createUser(SYSTEM_USER, SYSTEM_USER_PASSWORD, List.of(\"system_role\"));\n+        createRole(\"system_role\", Set.of(\"manage_api_key\"));\n+        createUser(END_USER, END_USER_PASSWORD, List.of(\"user_role\"));\n+        createRole(\"user_role\", Set.of(\"monitor\"));\n+    }\n+\n+    @After\n+    public void cleanUp() throws IOException {\n+        deleteUser(\"system_user\");\n+        deleteUser(\"end_user\");\n+        deleteRole(\"system_role\");\n+        deleteRole(\"user_role\");\n+        invalidateApiKeysForUser(END_USER);\n+    }\n+\n+    public void testGrantApiKeyForOtherUser() throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTcyOTMyNw=="}, "originalCommit": {"oid": "17d292f52d9fd1d9ff51a1944cf230d2df28c955"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA2NDc4Ng==", "bodyText": "You convinced me that I was just being lazy, so I've added a new QA project, and a new test for authenticating with a token + API key expiration.", "url": "https://github.com/elastic/elasticsearch/pull/52886#discussion_r388064786", "createdAt": "2020-03-05T03:47:18Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/qa/security-basic/src/test/java/org/elasticsearch/xpack/security/apikey/ApiKeyRestIT.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.apikey;\n+\n+import org.elasticsearch.client.Request;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.client.Response;\n+import org.elasticsearch.client.security.support.ApiKey;\n+import org.elasticsearch.common.settings.SecureString;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.test.XContentTestUtils;\n+import org.elasticsearch.xpack.core.security.authc.support.UsernamePasswordToken;\n+import org.elasticsearch.xpack.security.SecurityInBasicRestTestCase;\n+import org.junit.After;\n+import org.junit.Before;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.notNullValue;\n+\n+/**\n+ * This IT runs in the \"security-basic\" QA test because it has a working cluster with\n+ * API keys enabled, and there's no reason to have a dedicated QA project for API keys.\n+ */\n+public class ApiKeyRestIT extends SecurityInBasicRestTestCase {\n+\n+    private static final String SYSTEM_USER = \"system_user\";\n+    private static final SecureString SYSTEM_USER_PASSWORD = new SecureString(\"sys-pass\".toCharArray());\n+    private static final String END_USER = \"end_user\";\n+    private static final SecureString END_USER_PASSWORD = new SecureString(\"user-pass\".toCharArray());\n+\n+    @Before\n+    public void createUsers() throws IOException {\n+        createUser(SYSTEM_USER, SYSTEM_USER_PASSWORD, List.of(\"system_role\"));\n+        createRole(\"system_role\", Set.of(\"manage_api_key\"));\n+        createUser(END_USER, END_USER_PASSWORD, List.of(\"user_role\"));\n+        createRole(\"user_role\", Set.of(\"monitor\"));\n+    }\n+\n+    @After\n+    public void cleanUp() throws IOException {\n+        deleteUser(\"system_user\");\n+        deleteUser(\"end_user\");\n+        deleteRole(\"system_role\");\n+        deleteRole(\"user_role\");\n+        invalidateApiKeysForUser(END_USER);\n+    }\n+\n+    public void testGrantApiKeyForOtherUser() throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTcyOTMyNw=="}, "originalCommit": {"oid": "17d292f52d9fd1d9ff51a1944cf230d2df28c955"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4OTA4NjA4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/action/TransportGrantApiKeyAction.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNDo1Nzo1OFrOFv3v2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwNjowNTowOFrOFw5UGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc0MDc2MA==", "bodyText": "is this needed ?", "url": "https://github.com/elastic/elasticsearch/pull/52886#discussion_r385740760", "createdAt": "2020-02-28T14:57:58Z", "author": {"login": "jkakavas"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/action/TransportGrantApiKeyAction.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.action;\n+\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.HandledTransportAction;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportMessage;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.core.security.action.CreateApiKeyResponse;\n+import org.elasticsearch.xpack.core.security.action.GrantApiKeyAction;\n+import org.elasticsearch.xpack.core.security.action.GrantApiKeyRequest;\n+import org.elasticsearch.xpack.core.security.authc.Authentication;\n+import org.elasticsearch.xpack.core.security.authc.support.UsernamePasswordToken;\n+import org.elasticsearch.xpack.security.authc.ApiKeyService;\n+import org.elasticsearch.xpack.security.authc.AuthenticationService;\n+import org.elasticsearch.xpack.security.authc.TokenService;\n+import org.elasticsearch.xpack.security.authc.support.ApiKeyGenerator;\n+import org.elasticsearch.xpack.security.authz.store.CompositeRolesStore;\n+\n+/**\n+ * Implementation of the action needed to create an API key on behalf of another user (using an OAuth style \"grant\")\n+ */\n+public final class TransportGrantApiKeyAction extends HandledTransportAction<GrantApiKeyRequest, CreateApiKeyResponse> {\n+\n+    private final ThreadContext threadContext;\n+    private final ApiKeyGenerator generator;\n+    private final AuthenticationService authenticationService;\n+    private final TokenService tokenService;\n+\n+    @Inject\n+    public TransportGrantApiKeyAction(TransportService transportService, ActionFilters actionFilters, ThreadPool threadPool,\n+                                      ApiKeyService apiKeyService, AuthenticationService authenticationService, TokenService tokenService,\n+                                      CompositeRolesStore rolesStore, NamedXContentRegistry xContentRegistry) {\n+        this(transportService, actionFilters, threadPool.getThreadContext(),\n+            new ApiKeyGenerator(apiKeyService, rolesStore, xContentRegistry), authenticationService, tokenService\n+        );\n+    }\n+\n+    // Constructor for testing\n+    TransportGrantApiKeyAction(TransportService transportService, ActionFilters actionFilters, ThreadContext threadContext,\n+                                      ApiKeyGenerator generator, AuthenticationService authenticationService, TokenService tokenService) {\n+        super(GrantApiKeyAction.NAME, transportService, actionFilters, GrantApiKeyRequest::new);\n+        this.threadContext = threadContext;\n+        this.generator = generator;\n+        this.authenticationService = authenticationService;\n+        this.tokenService = tokenService;\n+    }\n+\n+    @Override\n+    protected void doExecute(Task task, GrantApiKeyRequest request, ActionListener<CreateApiKeyResponse> listener) {\n+        try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {\n+            resolveAuthentication(request.getGrant(), request, ActionListener.wrap(\n+                authentication -> generator.generateApiKey(authentication, request.getApiKeyRequest(), listener),\n+                listener::onFailure\n+            ));\n+        }\n+    }\n+\n+    private void resolveAuthentication(GrantApiKeyRequest.Grant grant, TransportMessage message, ActionListener<Authentication> listener) {\n+        switch (grant.getType()) {\n+            case GrantApiKeyRequest.PASSWORD_GRANT_TYPE:\n+                final UsernamePasswordToken token = new UsernamePasswordToken(grant.getUsername(), grant.getPassword());\n+                authenticationService.authenticate(super.actionName, message, token, listener);\n+                return;\n+            case GrantApiKeyRequest.ACCESS_TOKEN_GRANT_TYPE:\n+                tokenService.authenticateToken(grant.getAccessToken(), listener);\n+                return;\n+            default:\n+                listener.onFailure(new ElasticsearchSecurityException(\"the grant type [{}] is not supported\", grant.getType()));\n+                return;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17d292f52d9fd1d9ff51a1944cf230d2df28c955"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxNjgyOQ==", "bodyText": "The return ? Not strictly, but I did it for symmetry with the other switch cases.\nDoes it bother you? I'm happy to change it, and I'm personally not consistent in my balance between \"symmetry\" and \"necessity\"", "url": "https://github.com/elastic/elasticsearch/pull/52886#discussion_r386716829", "createdAt": "2020-03-02T23:38:12Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/action/TransportGrantApiKeyAction.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.action;\n+\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.HandledTransportAction;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportMessage;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.core.security.action.CreateApiKeyResponse;\n+import org.elasticsearch.xpack.core.security.action.GrantApiKeyAction;\n+import org.elasticsearch.xpack.core.security.action.GrantApiKeyRequest;\n+import org.elasticsearch.xpack.core.security.authc.Authentication;\n+import org.elasticsearch.xpack.core.security.authc.support.UsernamePasswordToken;\n+import org.elasticsearch.xpack.security.authc.ApiKeyService;\n+import org.elasticsearch.xpack.security.authc.AuthenticationService;\n+import org.elasticsearch.xpack.security.authc.TokenService;\n+import org.elasticsearch.xpack.security.authc.support.ApiKeyGenerator;\n+import org.elasticsearch.xpack.security.authz.store.CompositeRolesStore;\n+\n+/**\n+ * Implementation of the action needed to create an API key on behalf of another user (using an OAuth style \"grant\")\n+ */\n+public final class TransportGrantApiKeyAction extends HandledTransportAction<GrantApiKeyRequest, CreateApiKeyResponse> {\n+\n+    private final ThreadContext threadContext;\n+    private final ApiKeyGenerator generator;\n+    private final AuthenticationService authenticationService;\n+    private final TokenService tokenService;\n+\n+    @Inject\n+    public TransportGrantApiKeyAction(TransportService transportService, ActionFilters actionFilters, ThreadPool threadPool,\n+                                      ApiKeyService apiKeyService, AuthenticationService authenticationService, TokenService tokenService,\n+                                      CompositeRolesStore rolesStore, NamedXContentRegistry xContentRegistry) {\n+        this(transportService, actionFilters, threadPool.getThreadContext(),\n+            new ApiKeyGenerator(apiKeyService, rolesStore, xContentRegistry), authenticationService, tokenService\n+        );\n+    }\n+\n+    // Constructor for testing\n+    TransportGrantApiKeyAction(TransportService transportService, ActionFilters actionFilters, ThreadContext threadContext,\n+                                      ApiKeyGenerator generator, AuthenticationService authenticationService, TokenService tokenService) {\n+        super(GrantApiKeyAction.NAME, transportService, actionFilters, GrantApiKeyRequest::new);\n+        this.threadContext = threadContext;\n+        this.generator = generator;\n+        this.authenticationService = authenticationService;\n+        this.tokenService = tokenService;\n+    }\n+\n+    @Override\n+    protected void doExecute(Task task, GrantApiKeyRequest request, ActionListener<CreateApiKeyResponse> listener) {\n+        try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {\n+            resolveAuthentication(request.getGrant(), request, ActionListener.wrap(\n+                authentication -> generator.generateApiKey(authentication, request.getApiKeyRequest(), listener),\n+                listener::onFailure\n+            ));\n+        }\n+    }\n+\n+    private void resolveAuthentication(GrantApiKeyRequest.Grant grant, TransportMessage message, ActionListener<Authentication> listener) {\n+        switch (grant.getType()) {\n+            case GrantApiKeyRequest.PASSWORD_GRANT_TYPE:\n+                final UsernamePasswordToken token = new UsernamePasswordToken(grant.getUsername(), grant.getPassword());\n+                authenticationService.authenticate(super.actionName, message, token, listener);\n+                return;\n+            case GrantApiKeyRequest.ACCESS_TOKEN_GRANT_TYPE:\n+                tokenService.authenticateToken(grant.getAccessToken(), listener);\n+                return;\n+            default:\n+                listener.onFailure(new ElasticsearchSecurityException(\"the grant type [{}] is not supported\", grant.getType()));\n+                return;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc0MDc2MA=="}, "originalCommit": {"oid": "17d292f52d9fd1d9ff51a1944cf230d2df28c955"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjgxNTAwMA==", "bodyText": "again, this was a nit, feel free to address or not. I tend to review ( also not very consistently I'd admit ) taking personal preference into consideration and I usually don't hold strong opinions on such things.", "url": "https://github.com/elastic/elasticsearch/pull/52886#discussion_r386815000", "createdAt": "2020-03-03T06:05:08Z", "author": {"login": "jkakavas"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/action/TransportGrantApiKeyAction.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.action;\n+\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.HandledTransportAction;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportMessage;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.core.security.action.CreateApiKeyResponse;\n+import org.elasticsearch.xpack.core.security.action.GrantApiKeyAction;\n+import org.elasticsearch.xpack.core.security.action.GrantApiKeyRequest;\n+import org.elasticsearch.xpack.core.security.authc.Authentication;\n+import org.elasticsearch.xpack.core.security.authc.support.UsernamePasswordToken;\n+import org.elasticsearch.xpack.security.authc.ApiKeyService;\n+import org.elasticsearch.xpack.security.authc.AuthenticationService;\n+import org.elasticsearch.xpack.security.authc.TokenService;\n+import org.elasticsearch.xpack.security.authc.support.ApiKeyGenerator;\n+import org.elasticsearch.xpack.security.authz.store.CompositeRolesStore;\n+\n+/**\n+ * Implementation of the action needed to create an API key on behalf of another user (using an OAuth style \"grant\")\n+ */\n+public final class TransportGrantApiKeyAction extends HandledTransportAction<GrantApiKeyRequest, CreateApiKeyResponse> {\n+\n+    private final ThreadContext threadContext;\n+    private final ApiKeyGenerator generator;\n+    private final AuthenticationService authenticationService;\n+    private final TokenService tokenService;\n+\n+    @Inject\n+    public TransportGrantApiKeyAction(TransportService transportService, ActionFilters actionFilters, ThreadPool threadPool,\n+                                      ApiKeyService apiKeyService, AuthenticationService authenticationService, TokenService tokenService,\n+                                      CompositeRolesStore rolesStore, NamedXContentRegistry xContentRegistry) {\n+        this(transportService, actionFilters, threadPool.getThreadContext(),\n+            new ApiKeyGenerator(apiKeyService, rolesStore, xContentRegistry), authenticationService, tokenService\n+        );\n+    }\n+\n+    // Constructor for testing\n+    TransportGrantApiKeyAction(TransportService transportService, ActionFilters actionFilters, ThreadContext threadContext,\n+                                      ApiKeyGenerator generator, AuthenticationService authenticationService, TokenService tokenService) {\n+        super(GrantApiKeyAction.NAME, transportService, actionFilters, GrantApiKeyRequest::new);\n+        this.threadContext = threadContext;\n+        this.generator = generator;\n+        this.authenticationService = authenticationService;\n+        this.tokenService = tokenService;\n+    }\n+\n+    @Override\n+    protected void doExecute(Task task, GrantApiKeyRequest request, ActionListener<CreateApiKeyResponse> listener) {\n+        try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {\n+            resolveAuthentication(request.getGrant(), request, ActionListener.wrap(\n+                authentication -> generator.generateApiKey(authentication, request.getApiKeyRequest(), listener),\n+                listener::onFailure\n+            ));\n+        }\n+    }\n+\n+    private void resolveAuthentication(GrantApiKeyRequest.Grant grant, TransportMessage message, ActionListener<Authentication> listener) {\n+        switch (grant.getType()) {\n+            case GrantApiKeyRequest.PASSWORD_GRANT_TYPE:\n+                final UsernamePasswordToken token = new UsernamePasswordToken(grant.getUsername(), grant.getPassword());\n+                authenticationService.authenticate(super.actionName, message, token, listener);\n+                return;\n+            case GrantApiKeyRequest.ACCESS_TOKEN_GRANT_TYPE:\n+                tokenService.authenticateToken(grant.getAccessToken(), listener);\n+                return;\n+            default:\n+                listener.onFailure(new ElasticsearchSecurityException(\"the grant type [{}] is not supported\", grant.getType()));\n+                return;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc0MDc2MA=="}, "originalCommit": {"oid": "17d292f52d9fd1d9ff51a1944cf230d2df28c955"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4OTE3MzA5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/support/ApiKeyGenerator.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNToyMToxNVrOFv4k8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwNjoxMDoxN1rOFw5YiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1NDM1NA==", "bodyText": "This is called in ApiKeyService#createApiKey(). Is it intentional that we do it here too becayse getRoleDescriptors can be expensive ? If so can we also /instead inject the ApiKeyService in the Transport service and short circuit there ?", "url": "https://github.com/elastic/elasticsearch/pull/52886#discussion_r385754354", "createdAt": "2020-02-28T15:21:15Z", "author": {"login": "jkakavas"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/support/ApiKeyGenerator.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.authc.support;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.xpack.core.security.action.CreateApiKeyRequest;\n+import org.elasticsearch.xpack.core.security.action.CreateApiKeyResponse;\n+import org.elasticsearch.xpack.core.security.authc.Authentication;\n+import org.elasticsearch.xpack.core.security.authz.RoleDescriptor;\n+import org.elasticsearch.xpack.core.security.authz.support.DLSRoleQueryValidator;\n+import org.elasticsearch.xpack.security.authc.ApiKeyService;\n+import org.elasticsearch.xpack.security.authz.store.CompositeRolesStore;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+\n+public class ApiKeyGenerator {\n+\n+    private final ApiKeyService apiKeyService;\n+    private final CompositeRolesStore rolesStore;\n+    private final NamedXContentRegistry xContentRegistry;\n+\n+    public ApiKeyGenerator(ApiKeyService apiKeyService, CompositeRolesStore rolesStore, NamedXContentRegistry xContentRegistry) {\n+        this.apiKeyService = apiKeyService;\n+        this.rolesStore = rolesStore;\n+        this.xContentRegistry = xContentRegistry;\n+    }\n+\n+    public void generateApiKey(Authentication authentication, CreateApiKeyRequest request, ActionListener<CreateApiKeyResponse> listener) {\n+        if (authentication == null) {\n+            listener.onFailure(new ElasticsearchSecurityException(\"no authentication available to generate API key\"));\n+            return;\n+        }\n+        apiKeyService.ensureEnabled();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17d292f52d9fd1d9ff51a1944cf230d2df28c955"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxNzc3NA==", "bodyText": "Partly the relative expense, but partly the \"right\" error message. If the API key service is disabled you want to prioritise that error message ahead of any role format issues.\n(That's specifically what triggered me to write it, I ran into something along those lines while testing)", "url": "https://github.com/elastic/elasticsearch/pull/52886#discussion_r386717774", "createdAt": "2020-03-02T23:41:00Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/support/ApiKeyGenerator.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.authc.support;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.xpack.core.security.action.CreateApiKeyRequest;\n+import org.elasticsearch.xpack.core.security.action.CreateApiKeyResponse;\n+import org.elasticsearch.xpack.core.security.authc.Authentication;\n+import org.elasticsearch.xpack.core.security.authz.RoleDescriptor;\n+import org.elasticsearch.xpack.core.security.authz.support.DLSRoleQueryValidator;\n+import org.elasticsearch.xpack.security.authc.ApiKeyService;\n+import org.elasticsearch.xpack.security.authz.store.CompositeRolesStore;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+\n+public class ApiKeyGenerator {\n+\n+    private final ApiKeyService apiKeyService;\n+    private final CompositeRolesStore rolesStore;\n+    private final NamedXContentRegistry xContentRegistry;\n+\n+    public ApiKeyGenerator(ApiKeyService apiKeyService, CompositeRolesStore rolesStore, NamedXContentRegistry xContentRegistry) {\n+        this.apiKeyService = apiKeyService;\n+        this.rolesStore = rolesStore;\n+        this.xContentRegistry = xContentRegistry;\n+    }\n+\n+    public void generateApiKey(Authentication authentication, CreateApiKeyRequest request, ActionListener<CreateApiKeyResponse> listener) {\n+        if (authentication == null) {\n+            listener.onFailure(new ElasticsearchSecurityException(\"no authentication available to generate API key\"));\n+            return;\n+        }\n+        apiKeyService.ensureEnabled();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1NDM1NA=="}, "originalCommit": {"oid": "17d292f52d9fd1d9ff51a1944cf230d2df28c955"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxODI5NQ==", "bodyText": "If so can we also /instead inject the ApiKeyService in the Transport service and short circuit there\n\nI don't know if we want to. I think we should prioritise authentication problems (even secondary auth problems) over the service being disabled. Happy to discuss if you feel otherwise.", "url": "https://github.com/elastic/elasticsearch/pull/52886#discussion_r386718295", "createdAt": "2020-03-02T23:42:28Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/support/ApiKeyGenerator.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.authc.support;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.xpack.core.security.action.CreateApiKeyRequest;\n+import org.elasticsearch.xpack.core.security.action.CreateApiKeyResponse;\n+import org.elasticsearch.xpack.core.security.authc.Authentication;\n+import org.elasticsearch.xpack.core.security.authz.RoleDescriptor;\n+import org.elasticsearch.xpack.core.security.authz.support.DLSRoleQueryValidator;\n+import org.elasticsearch.xpack.security.authc.ApiKeyService;\n+import org.elasticsearch.xpack.security.authz.store.CompositeRolesStore;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+\n+public class ApiKeyGenerator {\n+\n+    private final ApiKeyService apiKeyService;\n+    private final CompositeRolesStore rolesStore;\n+    private final NamedXContentRegistry xContentRegistry;\n+\n+    public ApiKeyGenerator(ApiKeyService apiKeyService, CompositeRolesStore rolesStore, NamedXContentRegistry xContentRegistry) {\n+        this.apiKeyService = apiKeyService;\n+        this.rolesStore = rolesStore;\n+        this.xContentRegistry = xContentRegistry;\n+    }\n+\n+    public void generateApiKey(Authentication authentication, CreateApiKeyRequest request, ActionListener<CreateApiKeyResponse> listener) {\n+        if (authentication == null) {\n+            listener.onFailure(new ElasticsearchSecurityException(\"no authentication available to generate API key\"));\n+            return;\n+        }\n+        apiKeyService.ensureEnabled();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1NDM1NA=="}, "originalCommit": {"oid": "17d292f52d9fd1d9ff51a1944cf230d2df28c955"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjgxNjEzNw==", "bodyText": ", but partly the \"right\" error message.\n\nMakes sense.\n\nI think we should prioritise authentication problems\n\nAgreed, I didn't think this through", "url": "https://github.com/elastic/elasticsearch/pull/52886#discussion_r386816137", "createdAt": "2020-03-03T06:10:17Z", "author": {"login": "jkakavas"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/support/ApiKeyGenerator.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.authc.support;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.xpack.core.security.action.CreateApiKeyRequest;\n+import org.elasticsearch.xpack.core.security.action.CreateApiKeyResponse;\n+import org.elasticsearch.xpack.core.security.authc.Authentication;\n+import org.elasticsearch.xpack.core.security.authz.RoleDescriptor;\n+import org.elasticsearch.xpack.core.security.authz.support.DLSRoleQueryValidator;\n+import org.elasticsearch.xpack.security.authc.ApiKeyService;\n+import org.elasticsearch.xpack.security.authz.store.CompositeRolesStore;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+\n+public class ApiKeyGenerator {\n+\n+    private final ApiKeyService apiKeyService;\n+    private final CompositeRolesStore rolesStore;\n+    private final NamedXContentRegistry xContentRegistry;\n+\n+    public ApiKeyGenerator(ApiKeyService apiKeyService, CompositeRolesStore rolesStore, NamedXContentRegistry xContentRegistry) {\n+        this.apiKeyService = apiKeyService;\n+        this.rolesStore = rolesStore;\n+        this.xContentRegistry = xContentRegistry;\n+    }\n+\n+    public void generateApiKey(Authentication authentication, CreateApiKeyRequest request, ActionListener<CreateApiKeyResponse> listener) {\n+        if (authentication == null) {\n+            listener.onFailure(new ElasticsearchSecurityException(\"no authentication available to generate API key\"));\n+            return;\n+        }\n+        apiKeyService.ensureEnabled();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1NDM1NA=="}, "originalCommit": {"oid": "17d292f52d9fd1d9ff51a1944cf230d2df28c955"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNTExNzg5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/TokenService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMDozMzoyMVrOFyOR7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMDozMzoyMVrOFyOR7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIwNzA4NQ==", "bodyText": "I believe this new method should return the new fancy 400 exceptions when the token service is not enabled (since it's not used in the authentication chain).", "url": "https://github.com/elastic/elasticsearch/pull/52886#discussion_r388207085", "createdAt": "2020-03-05T10:33:21Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/TokenService.java", "diffHunk": "@@ -394,6 +394,32 @@ void getAndValidateToken(ThreadContext ctx, ActionListener<UserToken> listener)\n         }\n     }\n \n+    /**\n+     * Decodes the provided token, and validates it (for format, expiry and invalidation).\n+     * If valid, the token's {@link Authentication} (see {@link UserToken#getAuthentication()} is provided to the listener.\n+     * If the token is invalid (expired etc), then {@link ActionListener#onFailure(Exception)} will be called.\n+     * If tokens are not enabled, or the token does not exist, {@link ActionListener#onResponse} will be called with a\n+     * {@code null} authentication object.\n+     */\n+    public void authenticateToken(SecureString tokenString, ActionListener<Authentication> listener) {\n+        if (isEnabled()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5808256c01fc4c0ce767b8ebc414be74162e584"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNTEzNDcyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/TokenService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMDozNzo0M1rOFyObnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMToyMTowM1rOFyPyaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIwOTU2NA==", "bodyText": "Also because this new method is not used in the authn chain, when a token fails decoding it's a client error.\nI believe:\nlistener.onFailure(new IllegalArgumentException());\n\nwould do, it would return 400 (currently this falls back to 500 in ApiKeyGenerator#generateApiKey).", "url": "https://github.com/elastic/elasticsearch/pull/52886#discussion_r388209564", "createdAt": "2020-03-05T10:37:43Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/TokenService.java", "diffHunk": "@@ -394,6 +394,32 @@ void getAndValidateToken(ThreadContext ctx, ActionListener<UserToken> listener)\n         }\n     }\n \n+    /**\n+     * Decodes the provided token, and validates it (for format, expiry and invalidation).\n+     * If valid, the token's {@link Authentication} (see {@link UserToken#getAuthentication()} is provided to the listener.\n+     * If the token is invalid (expired etc), then {@link ActionListener#onFailure(Exception)} will be called.\n+     * If tokens are not enabled, or the token does not exist, {@link ActionListener#onResponse} will be called with a\n+     * {@code null} authentication object.\n+     */\n+    public void authenticateToken(SecureString tokenString, ActionListener<Authentication> listener) {\n+        if (isEnabled()) {\n+            decodeToken(tokenString.toString(), ActionListener.wrap(userToken -> {\n+                if (userToken != null) {\n+                    checkIfTokenIsValid(userToken, ActionListener.wrap(\n+                        token -> {\n+                            listener.onResponse(token == null ? null : token.getAuthentication());\n+                        },\n+                        listener::onFailure\n+                    ));\n+                } else {\n+                    listener.onResponse(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5808256c01fc4c0ce767b8ebc414be74162e584"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIzMTc4NQ==", "bodyText": "Good point @albertzaharovits", "url": "https://github.com/elastic/elasticsearch/pull/52886#discussion_r388231785", "createdAt": "2020-03-05T11:21:03Z", "author": {"login": "jkakavas"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/TokenService.java", "diffHunk": "@@ -394,6 +394,32 @@ void getAndValidateToken(ThreadContext ctx, ActionListener<UserToken> listener)\n         }\n     }\n \n+    /**\n+     * Decodes the provided token, and validates it (for format, expiry and invalidation).\n+     * If valid, the token's {@link Authentication} (see {@link UserToken#getAuthentication()} is provided to the listener.\n+     * If the token is invalid (expired etc), then {@link ActionListener#onFailure(Exception)} will be called.\n+     * If tokens are not enabled, or the token does not exist, {@link ActionListener#onResponse} will be called with a\n+     * {@code null} authentication object.\n+     */\n+    public void authenticateToken(SecureString tokenString, ActionListener<Authentication> listener) {\n+        if (isEnabled()) {\n+            decodeToken(tokenString.toString(), ActionListener.wrap(userToken -> {\n+                if (userToken != null) {\n+                    checkIfTokenIsValid(userToken, ActionListener.wrap(\n+                        token -> {\n+                            listener.onResponse(token == null ? null : token.getAuthentication());\n+                        },\n+                        listener::onFailure\n+                    ));\n+                } else {\n+                    listener.onResponse(null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIwOTU2NA=="}, "originalCommit": {"oid": "f5808256c01fc4c0ce767b8ebc414be74162e584"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNTI1OTI1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/rest/action/apikey/RestGrantApiKeyAction.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMToxNToyMFrOFyPn9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMToxNToyMFrOFyPn9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIyOTExMA==", "bodyText": "The refresh_policy should be forwarded to the inner CreateApiKeyRequest to take effect.", "url": "https://github.com/elastic/elasticsearch/pull/52886#discussion_r388229110", "createdAt": "2020-03-05T11:15:20Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/rest/action/apikey/RestGrantApiKeyAction.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.rest.action.apikey;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.WriteRequest;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.settings.SecureString;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.license.XPackLicenseState;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.xpack.core.security.action.CreateApiKeyRequestBuilder;\n+import org.elasticsearch.xpack.core.security.action.CreateApiKeyResponse;\n+import org.elasticsearch.xpack.core.security.action.GrantApiKeyAction;\n+import org.elasticsearch.xpack.core.security.action.GrantApiKeyRequest;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static org.elasticsearch.rest.RestRequest.Method.POST;\n+import static org.elasticsearch.rest.RestRequest.Method.PUT;\n+\n+/**\n+ * Rest action to create an API key on behalf of another user. Loosely mimics the API of\n+ * {@link org.elasticsearch.xpack.security.rest.action.oauth2.RestGetTokenAction} combined with {@link RestCreateApiKeyAction}\n+ */\n+public final class RestGrantApiKeyAction extends ApiKeyBaseRestHandler {\n+\n+    final Logger logger = LogManager.getLogger();\n+\n+    static final ObjectParser<GrantApiKeyRequest, Void> PARSER = new ObjectParser<>(\"grant_api_key_request\", GrantApiKeyRequest::new);\n+    static {\n+        PARSER.declareString((req, str) -> req.getGrant().setType(str), new ParseField(\"grant_type\"));\n+        PARSER.declareString((req, str) -> req.getGrant().setUsername(str), new ParseField(\"username\"));\n+        PARSER.declareField((req, secStr) -> req.getGrant().setPassword(secStr), RestGrantApiKeyAction::getSecureString,\n+            new ParseField(\"password\"), ObjectParser.ValueType.STRING);\n+        PARSER.declareField((req, secStr) -> req.getGrant().setAccessToken(secStr), RestGrantApiKeyAction::getSecureString,\n+            new ParseField(\"access_token\"), ObjectParser.ValueType.STRING);\n+        PARSER.declareObject((req, api) -> req.setApiKeyRequest(api), (parser, ignore) -> CreateApiKeyRequestBuilder.parse(parser),\n+            new ParseField(\"api_key\"));\n+    }\n+\n+    private static SecureString getSecureString(XContentParser parser) throws IOException {\n+        return new SecureString(\n+            Arrays.copyOfRange(parser.textCharacters(), parser.textOffset(), parser.textOffset() + parser.textLength()));\n+    }\n+\n+    public RestGrantApiKeyAction(Settings settings, XPackLicenseState licenseState) {\n+        super(settings, licenseState);\n+    }\n+\n+    @Override\n+    public List<Route> routes() {\n+        return List.of(\n+            new Route(POST, \"/_security/api_key/grant\"),\n+            new Route(PUT, \"/_security/api_key/grant\"));\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"xpack_security_grant_api_key\";\n+    }\n+\n+    @Override\n+    protected RestChannelConsumer innerPrepareRequest(final RestRequest request, final NodeClient client) throws IOException {\n+        String refresh = request.param(\"refresh\");\n+        try (XContentParser parser = request.contentParser()) {\n+            final GrantApiKeyRequest grantRequest = PARSER.parse(parser, null);\n+            if (refresh != null) {\n+                grantRequest.setRefreshPolicy(WriteRequest.RefreshPolicy.parse(refresh));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5808256c01fc4c0ce767b8ebc414be74162e584"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNTMxMjg2OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/rest/action/apikey/RestGrantApiKeyAction.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMTozMjo0OFrOFyQIFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQwNTo1NzowMlrOF1SEMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIzNzMzMw==", "bodyText": "I like this wrapping to translate 401 to 403!\nAssuming this is the sole reason of existence for the inner class, in order to make it easier to read, I would make it more concise:\n            return channel -> client.execute(GrantApiKeyAction.INSTANCE, grantRequest,\n                    ActionListener.delegateResponse(new RestToXContentListener<>(channel),\n                            (l, e) -> {\n                                RestStatus status = ExceptionsHelper.status(e);\n                                if (status == RestStatus.UNAUTHORIZED) {\n                                    l.onFailure(new ElasticsearchSecurityException(\"Failed to authenticate api key grant\",\n                                            RestStatus.FORBIDDEN, e));\n                                } else {\n                                    l.onFailure(e);\n                                }\n                            }));", "url": "https://github.com/elastic/elasticsearch/pull/52886#discussion_r388237333", "createdAt": "2020-03-05T11:32:48Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/rest/action/apikey/RestGrantApiKeyAction.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.rest.action.apikey;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.WriteRequest;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.settings.SecureString;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.license.XPackLicenseState;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.xpack.core.security.action.CreateApiKeyRequestBuilder;\n+import org.elasticsearch.xpack.core.security.action.CreateApiKeyResponse;\n+import org.elasticsearch.xpack.core.security.action.GrantApiKeyAction;\n+import org.elasticsearch.xpack.core.security.action.GrantApiKeyRequest;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static org.elasticsearch.rest.RestRequest.Method.POST;\n+import static org.elasticsearch.rest.RestRequest.Method.PUT;\n+\n+/**\n+ * Rest action to create an API key on behalf of another user. Loosely mimics the API of\n+ * {@link org.elasticsearch.xpack.security.rest.action.oauth2.RestGetTokenAction} combined with {@link RestCreateApiKeyAction}\n+ */\n+public final class RestGrantApiKeyAction extends ApiKeyBaseRestHandler {\n+\n+    final Logger logger = LogManager.getLogger();\n+\n+    static final ObjectParser<GrantApiKeyRequest, Void> PARSER = new ObjectParser<>(\"grant_api_key_request\", GrantApiKeyRequest::new);\n+    static {\n+        PARSER.declareString((req, str) -> req.getGrant().setType(str), new ParseField(\"grant_type\"));\n+        PARSER.declareString((req, str) -> req.getGrant().setUsername(str), new ParseField(\"username\"));\n+        PARSER.declareField((req, secStr) -> req.getGrant().setPassword(secStr), RestGrantApiKeyAction::getSecureString,\n+            new ParseField(\"password\"), ObjectParser.ValueType.STRING);\n+        PARSER.declareField((req, secStr) -> req.getGrant().setAccessToken(secStr), RestGrantApiKeyAction::getSecureString,\n+            new ParseField(\"access_token\"), ObjectParser.ValueType.STRING);\n+        PARSER.declareObject((req, api) -> req.setApiKeyRequest(api), (parser, ignore) -> CreateApiKeyRequestBuilder.parse(parser),\n+            new ParseField(\"api_key\"));\n+    }\n+\n+    private static SecureString getSecureString(XContentParser parser) throws IOException {\n+        return new SecureString(\n+            Arrays.copyOfRange(parser.textCharacters(), parser.textOffset(), parser.textOffset() + parser.textLength()));\n+    }\n+\n+    public RestGrantApiKeyAction(Settings settings, XPackLicenseState licenseState) {\n+        super(settings, licenseState);\n+    }\n+\n+    @Override\n+    public List<Route> routes() {\n+        return List.of(\n+            new Route(POST, \"/_security/api_key/grant\"),\n+            new Route(PUT, \"/_security/api_key/grant\"));\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"xpack_security_grant_api_key\";\n+    }\n+\n+    @Override\n+    protected RestChannelConsumer innerPrepareRequest(final RestRequest request, final NodeClient client) throws IOException {\n+        String refresh = request.param(\"refresh\");\n+        try (XContentParser parser = request.contentParser()) {\n+            final GrantApiKeyRequest grantRequest = PARSER.parse(parser, null);\n+            if (refresh != null) {\n+                grantRequest.setRefreshPolicy(WriteRequest.RefreshPolicy.parse(refresh));\n+            }\n+            return channel -> client.execute(GrantApiKeyAction.INSTANCE, grantRequest, new ResponseListener(channel));\n+        }\n+    }\n+\n+    private class ResponseListener implements ActionListener<CreateApiKeyResponse> {\n+        private final RestChannel channel;\n+\n+        ResponseListener(RestChannel channel) {\n+            this.channel = channel;\n+        }\n+\n+        @Override\n+        public void onResponse(CreateApiKeyResponse response) {\n+            try (XContentBuilder builder = channel.newBuilder()) {\n+                channel.sendResponse(new BytesRestResponse(RestStatus.OK, response.toXContent(builder, channel.request())));\n+            } catch (IOException e) {\n+                sendFailure(e);\n+            }\n+        }\n+\n+        @Override\n+        public void onFailure(Exception e) {\n+            RestStatus status = ExceptionsHelper.status(e);\n+            if (status == RestStatus.UNAUTHORIZED) {\n+                sendFailure(new ElasticsearchSecurityException(\"Failed to authenticate api key grant\", RestStatus.FORBIDDEN, e));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5808256c01fc4c0ce767b8ebc414be74162e584"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQxNDgzMg==", "bodyText": "Thanks @albertzaharovits that was a huge improvement.", "url": "https://github.com/elastic/elasticsearch/pull/52886#discussion_r391414832", "createdAt": "2020-03-12T05:57:02Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/rest/action/apikey/RestGrantApiKeyAction.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.rest.action.apikey;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.WriteRequest;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.settings.SecureString;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.license.XPackLicenseState;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.xpack.core.security.action.CreateApiKeyRequestBuilder;\n+import org.elasticsearch.xpack.core.security.action.CreateApiKeyResponse;\n+import org.elasticsearch.xpack.core.security.action.GrantApiKeyAction;\n+import org.elasticsearch.xpack.core.security.action.GrantApiKeyRequest;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static org.elasticsearch.rest.RestRequest.Method.POST;\n+import static org.elasticsearch.rest.RestRequest.Method.PUT;\n+\n+/**\n+ * Rest action to create an API key on behalf of another user. Loosely mimics the API of\n+ * {@link org.elasticsearch.xpack.security.rest.action.oauth2.RestGetTokenAction} combined with {@link RestCreateApiKeyAction}\n+ */\n+public final class RestGrantApiKeyAction extends ApiKeyBaseRestHandler {\n+\n+    final Logger logger = LogManager.getLogger();\n+\n+    static final ObjectParser<GrantApiKeyRequest, Void> PARSER = new ObjectParser<>(\"grant_api_key_request\", GrantApiKeyRequest::new);\n+    static {\n+        PARSER.declareString((req, str) -> req.getGrant().setType(str), new ParseField(\"grant_type\"));\n+        PARSER.declareString((req, str) -> req.getGrant().setUsername(str), new ParseField(\"username\"));\n+        PARSER.declareField((req, secStr) -> req.getGrant().setPassword(secStr), RestGrantApiKeyAction::getSecureString,\n+            new ParseField(\"password\"), ObjectParser.ValueType.STRING);\n+        PARSER.declareField((req, secStr) -> req.getGrant().setAccessToken(secStr), RestGrantApiKeyAction::getSecureString,\n+            new ParseField(\"access_token\"), ObjectParser.ValueType.STRING);\n+        PARSER.declareObject((req, api) -> req.setApiKeyRequest(api), (parser, ignore) -> CreateApiKeyRequestBuilder.parse(parser),\n+            new ParseField(\"api_key\"));\n+    }\n+\n+    private static SecureString getSecureString(XContentParser parser) throws IOException {\n+        return new SecureString(\n+            Arrays.copyOfRange(parser.textCharacters(), parser.textOffset(), parser.textOffset() + parser.textLength()));\n+    }\n+\n+    public RestGrantApiKeyAction(Settings settings, XPackLicenseState licenseState) {\n+        super(settings, licenseState);\n+    }\n+\n+    @Override\n+    public List<Route> routes() {\n+        return List.of(\n+            new Route(POST, \"/_security/api_key/grant\"),\n+            new Route(PUT, \"/_security/api_key/grant\"));\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"xpack_security_grant_api_key\";\n+    }\n+\n+    @Override\n+    protected RestChannelConsumer innerPrepareRequest(final RestRequest request, final NodeClient client) throws IOException {\n+        String refresh = request.param(\"refresh\");\n+        try (XContentParser parser = request.contentParser()) {\n+            final GrantApiKeyRequest grantRequest = PARSER.parse(parser, null);\n+            if (refresh != null) {\n+                grantRequest.setRefreshPolicy(WriteRequest.RefreshPolicy.parse(refresh));\n+            }\n+            return channel -> client.execute(GrantApiKeyAction.INSTANCE, grantRequest, new ResponseListener(channel));\n+        }\n+    }\n+\n+    private class ResponseListener implements ActionListener<CreateApiKeyResponse> {\n+        private final RestChannel channel;\n+\n+        ResponseListener(RestChannel channel) {\n+            this.channel = channel;\n+        }\n+\n+        @Override\n+        public void onResponse(CreateApiKeyResponse response) {\n+            try (XContentBuilder builder = channel.newBuilder()) {\n+                channel.sendResponse(new BytesRestResponse(RestStatus.OK, response.toXContent(builder, channel.request())));\n+            } catch (IOException e) {\n+                sendFailure(e);\n+            }\n+        }\n+\n+        @Override\n+        public void onFailure(Exception e) {\n+            RestStatus status = ExceptionsHelper.status(e);\n+            if (status == RestStatus.UNAUTHORIZED) {\n+                sendFailure(new ElasticsearchSecurityException(\"Failed to authenticate api key grant\", RestStatus.FORBIDDEN, e));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIzNzMzMw=="}, "originalCommit": {"oid": "f5808256c01fc4c0ce767b8ebc414be74162e584"}, "originalPosition": 112}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3694, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}