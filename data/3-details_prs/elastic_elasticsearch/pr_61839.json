{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc3NzIxMDQ3", "number": 61839, "title": "Clone Snapshot API", "bodyText": "Snapshot clone API. Complete except for some TODOs around documentation (and adding HLRC support).", "createdAt": "2020-09-02T10:22:38Z", "url": "https://github.com/elastic/elasticsearch/pull/61839", "merged": true, "mergeCommit": {"oid": "f7f239d39aa29ebdbaa05552f42a280ece8c826e"}, "closed": true, "closedAt": "2020-10-02T19:28:45Z", "author": {"login": "original-brownbear"}, "timelineItems": {"totalCount": 160, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdJ0sgnAH2gAyNDc3NzIxMDQ3OmFlM2YxMDg4MzdjOTE2YTRmMTBkMzJjYzI3OTc1NjQ1NDgzODdlNzc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdOmyEDgH2gAyNDc3NzIxMDQ3OjZhZDM1NTIyZmM5Yzc1Y2Y1NjFiZTUzMGQ0YWNlOGY4YWUwZWZlMGU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "ae3f108837c916a4f10d32cc2797564548387e77", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/ae3f108837c916a4f10d32cc2797564548387e77", "committedDate": "2020-09-17T17:46:14Z", "message": "Merge remote-tracking branch 'elastic/master' into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1f9d70161266199de7bee3b61f51f9845d2e58be", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/1f9d70161266199de7bee3b61f51f9845d2e58be", "committedDate": "2020-09-20T11:00:47Z", "message": "Merge remote-tracking branch 'elastic/master' into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f1bf399ce49e1ea9c013c59aa4f8dd27fe8f9d21", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/f1bf399ce49e1ea9c013c59aa4f8dd27fe8f9d21", "committedDate": "2020-09-20T11:39:16Z", "message": "fix docs?"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eed621424feb884d663b2e4dbf4dfac6c30b7e21", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/eed621424feb884d663b2e4dbf4dfac6c30b7e21", "committedDate": "2020-09-20T17:04:19Z", "message": "remove settings for now"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "06ce72dd4dd4d35dfae12a2b5c149b999ed5f480", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/06ce72dd4dd4d35dfae12a2b5c149b999ed5f480", "committedDate": "2020-09-21T15:39:58Z", "message": "Merge remote-tracking branch 'elastic/master' into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "55b2d8490c2a8afb3ccc7eabd50589c19e3e6af2", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/55b2d8490c2a8afb3ccc7eabd50589c19e3e6af2", "committedDate": "2020-09-21T21:19:00Z", "message": "Merge remote-tracking branch 'elastic/master' into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "95ffa6fd57459ee4b3ae518b0724036cd46b65a0", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/95ffa6fd57459ee4b3ae518b0724036cd46b65a0", "committedDate": "2020-09-22T10:35:27Z", "message": "Merge remote-tracking branch 'elastic/master' into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "30e623b0534b074fac7b4b209fc90b50c8908f5f", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/30e623b0534b074fac7b4b209fc90b50c8908f5f", "committedDate": "2020-09-28T12:40:02Z", "message": "Merge remote-tracking branch 'elastic/master' into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "72a7f4bf04d545d079eea1da5a09285006149596", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/72a7f4bf04d545d079eea1da5a09285006149596", "committedDate": "2020-09-28T12:42:03Z", "message": "less noise"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9141f37e824e96bfee0d847dbfb0e2f3522692f5", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/9141f37e824e96bfee0d847dbfb0e2f3522692f5", "committedDate": "2020-09-29T09:54:29Z", "message": "Merge remote-tracking branch 'elastic/master' into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c0504fb662be0971345e4807630b74e130aeff23", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/c0504fb662be0971345e4807630b74e130aeff23", "committedDate": "2020-09-29T10:58:11Z", "message": "remove noisy changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "157ec270824769a4b3c3898e8e0f3d54eba1b678", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/157ec270824769a4b3c3898e8e0f3d54eba1b678", "committedDate": "2020-09-29T11:05:07Z", "message": "reduce noise"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "56779b4a7172f186cb82db535e77bc1f5e7bbed8", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/56779b4a7172f186cb82db535e77bc1f5e7bbed8", "committedDate": "2020-09-29T11:58:09Z", "message": "align style"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d504a4e50cf9824c231f9e13893bc49e5c1b884c", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/d504a4e50cf9824c231f9e13893bc49e5c1b884c", "committedDate": "2020-09-29T12:00:41Z", "message": "align style"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ad43cea9bca2af3dc7e6d8caff81683872ca5499", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/ad43cea9bca2af3dc7e6d8caff81683872ca5499", "committedDate": "2020-09-29T12:14:29Z", "message": "making things look nicer"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1a4f1f9814ea083ee66de9d505563f9356f1ea5d", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/1a4f1f9814ea083ee66de9d505563f9356f1ea5d", "committedDate": "2020-09-29T13:03:40Z", "message": "drier"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "911457a9967b167ce5f998e630965dea85ab83f8", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/911457a9967b167ce5f998e630965dea85ab83f8", "committedDate": "2020-09-29T13:03:53Z", "message": "Merge remote-tracking branch 'elastic/master' into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0a15e5db9e01e5498e9f601071de1b362efddd26", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/0a15e5db9e01e5498e9f601071de1b362efddd26", "committedDate": "2020-09-29T13:42:54Z", "message": "drier"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c3ae02d65cf1d3cb811fb5590f469d7383571c28", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/c3ae02d65cf1d3cb811fb5590f469d7383571c28", "committedDate": "2020-09-29T18:45:04Z", "message": "nicer"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "80facac2808da35aaab5ecf61736cbbcdfee9c65", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/80facac2808da35aaab5ecf61736cbbcdfee9c65", "committedDate": "2020-09-29T19:02:00Z", "message": "make some things nicer"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "75821afbc5540dd304e559f69ffe9be24031719b", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/75821afbc5540dd304e559f69ffe9be24031719b", "committedDate": "2020-09-29T19:18:04Z", "message": "add validation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9d4c34830668f3669f8adad57188e8016167a7cd", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/9d4c34830668f3669f8adad57188e8016167a7cd", "committedDate": "2020-09-30T07:44:16Z", "message": "Merge remote-tracking branch 'elastic/master' into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3b5b057064bea068645ee71a627b1862b59f0c96", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/3b5b057064bea068645ee71a627b1862b59f0c96", "committedDate": "2020-09-30T08:01:16Z", "message": "less noisy"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9c73e11f96e3d2fefbbc5057ceb9bd5ae86a7acd", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/9c73e11f96e3d2fefbbc5057ceb9bd5ae86a7acd", "committedDate": "2020-09-30T08:34:33Z", "message": "less noise"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0cccd4efd8d066e480aa391dfadb000755dbc1d0", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/0cccd4efd8d066e480aa391dfadb000755dbc1d0", "committedDate": "2020-09-30T12:03:33Z", "message": "Merge remote-tracking branch 'elastic/master' into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6942a0fd1dcf66ddfba3a56432ed525305344169", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/6942a0fd1dcf66ddfba3a56432ed525305344169", "committedDate": "2020-09-30T12:06:20Z", "message": "cleaner"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c9410421776d878ce461360641286af798a6db24", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/c9410421776d878ce461360641286af798a6db24", "committedDate": "2020-09-30T12:29:20Z", "message": "safer"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "855a1cb2a0b60380f6e9f65a681cf745d6f0714f", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/855a1cb2a0b60380f6e9f65a681cf745d6f0714f", "committedDate": "2020-09-30T12:37:48Z", "message": "better docs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "de8ca3705948f85523830381aa7113f28855cd87", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/de8ca3705948f85523830381aa7113f28855cd87", "committedDate": "2020-09-30T12:54:54Z", "message": "Merge remote-tracking branch 'elastic/master' into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "78e3110d704d383228ed7b8056a3fe6ebe0d2819", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/78e3110d704d383228ed7b8056a3fe6ebe0d2819", "committedDate": "2020-09-30T15:19:15Z", "message": "better"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "38d56ea5c72800aed34ba99bfac3c68fbae73fa4", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/38d56ea5c72800aed34ba99bfac3c68fbae73fa4", "committedDate": "2020-09-30T15:23:05Z", "message": "better"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f0c7df1f1c74b285305a6fd53f2c443d7733aacb", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/f0c7df1f1c74b285305a6fd53f2c443d7733aacb", "committedDate": "2020-09-30T17:22:56Z", "message": "Merge remote-tracking branch 'elastic/master' into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "db3e957842816e34ed314000b827b2c1033fa40b", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/db3e957842816e34ed314000b827b2c1033fa40b", "committedDate": "2020-09-30T19:13:36Z", "message": "Merge remote-tracking branch 'elastic/master' into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e0d38156fdc123655328ad13689ac657b81b336d", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/e0d38156fdc123655328ad13689ac657b81b336d", "committedDate": "2020-10-01T06:24:09Z", "message": "Merge remote-tracking branch 'elastic/master' into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7266d3ea0bd971f1ffcbeb08107b4b722dbc382d", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/7266d3ea0bd971f1ffcbeb08107b4b722dbc382d", "committedDate": "2020-10-01T07:16:34Z", "message": "nicer"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ec76593610a160d27bc009290ecf6009b34f7260", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/ec76593610a160d27bc009290ecf6009b34f7260", "committedDate": "2020-10-01T07:19:11Z", "message": "simpler diff"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "631df59d78f46887910178f07aab08e92c9855e9", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/631df59d78f46887910178f07aab08e92c9855e9", "committedDate": "2020-10-01T07:21:34Z", "message": "fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e7bd833383b145ba2a07b036f5dba84d741fa290", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/e7bd833383b145ba2a07b036f5dba84d741fa290", "committedDate": "2020-10-01T07:45:32Z", "message": "TODO"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3c5f8cdf4b87ce4211ae8a3cfd6caa7aadae4dec", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/3c5f8cdf4b87ce4211ae8a3cfd6caa7aadae4dec", "committedDate": "2020-10-01T08:10:37Z", "message": "tests are hard"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwMTcwMDk3", "url": "https://github.com/elastic/elasticsearch/pull/61839#pullrequestreview-500170097", "createdAt": "2020-10-01T09:32:53Z", "commit": {"oid": "3c5f8cdf4b87ce4211ae8a3cfd6caa7aadae4dec"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxMDowNToxOVrOHbDaYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxMjo0Mjo0NlrOHbIiww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODEyOTUwNw==", "bodyText": "I'm not sure split strings are also trimmed so it's better to not add a white space after the comma\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              \"indices\": \"index_a, index_b\"\n          \n          \n            \n              \"indices\": \"index_a,index_b\"", "url": "https://github.com/elastic/elasticsearch/pull/61839#discussion_r498129507", "createdAt": "2020-10-01T10:05:19Z", "author": {"login": "tlrx"}, "path": "docs/reference/snapshot-restore/apis/clone-snapshot-api.asciidoc", "diffHunk": "@@ -0,0 +1,52 @@\n+[[clone-snapshot-api]]\n+=== Clone snapshot API\n+++++\n+<titleabbrev>Clone snapshot</titleabbrev>\n+++++\n+\n+Clones part or all of a snapshot into a new snapshot.\n+\n+[source,console]\n+----\n+PUT /_snapshot/my_repository/source_snapshot/_clone/target_snapshot\n+{\n+  \"indices\": \"index_a, index_b\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c5f8cdf4b87ce4211ae8a3cfd6caa7aadae4dec"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODEyOTk0Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Name of the snapshot repository that both source- and target snapshot belong to.\n          \n          \n            \n            Name of the snapshot repository that both source and target snapshot belong to.", "url": "https://github.com/elastic/elasticsearch/pull/61839#discussion_r498129947", "createdAt": "2020-10-01T10:06:03Z", "author": {"login": "tlrx"}, "path": "docs/reference/snapshot-restore/apis/clone-snapshot-api.asciidoc", "diffHunk": "@@ -0,0 +1,52 @@\n+[[clone-snapshot-api]]\n+=== Clone snapshot API\n+++++\n+<titleabbrev>Clone snapshot</titleabbrev>\n+++++\n+\n+Clones part or all of a snapshot into a new snapshot.\n+\n+[source,console]\n+----\n+PUT /_snapshot/my_repository/source_snapshot/_clone/target_snapshot\n+{\n+  \"indices\": \"index_a, index_b\"\n+}\n+----\n+// TEST[skip:TODO]\n+\n+[[clone-snapshot-api-request]]\n+==== {api-request-title}\n+\n+`PUT /_snapshot/<repository>/<source_snapshot>/_clone/<target_snapshot>`\n+\n+[[clone-snapshot-api-desc]]\n+==== {api-description-title}\n+\n+The clone snapshot API allows creating a copy of all or part of an existing snapshot\n+within the same repository.\n+\n+[[clone-snapshot-api-params]]\n+==== {api-path-parms-title}\n+\n+`<repository>`::\n+(Required, string)\n+Name of the snapshot repository that both source- and target snapshot belong to.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c5f8cdf4b87ce4211ae8a3cfd6caa7aadae4dec"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODEzMDM5NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            NOTE: You can also create snapshots that are copies of part of an existing snapshot using the <<clone-snapshot-api,clone snapshot API>>.\n          \n          \n            \n            NOTE: You can also create snapshots that are copies or part of an existing snapshot using the <<clone-snapshot-api,clone snapshot API>>.", "url": "https://github.com/elastic/elasticsearch/pull/61839#discussion_r498130394", "createdAt": "2020-10-01T10:06:51Z", "author": {"login": "tlrx"}, "path": "docs/reference/snapshot-restore/take-snapshot.asciidoc", "diffHunk": "@@ -124,3 +124,5 @@ PUT /_snapshot/my_backup/<snapshot-{now/d}>\n PUT /_snapshot/my_backup/%3Csnapshot-%7Bnow%2Fd%7D%3E\n -----------------------------------\n // TEST[continued]\n+\n+NOTE: You can also create snapshots that are copies of part of an existing snapshot using the <<clone-snapshot-api,clone snapshot API>>.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c5f8cdf4b87ce4211ae8a3cfd6caa7aadae4dec"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODE2OTY3Ng==", "bodyText": "I think we are silently losing global metadata and data streams information, are we ok with that?", "url": "https://github.com/elastic/elasticsearch/pull/61839#discussion_r498169676", "createdAt": "2020-10-01T11:22:14Z", "author": {"login": "tlrx"}, "path": "server/src/main/java/org/elasticsearch/cluster/SnapshotsInProgress.java", "diffHunk": "@@ -96,18 +99,52 @@ public static Entry startedEntry(Snapshot snapshot, boolean includeGlobalState,\n                 indices, dataStreams, startTime, repositoryStateId, shards, null, userMetadata, version);\n     }\n \n+    /**\n+     * Creates the initial snapshot clone entry\n+     *\n+     * @param snapshot snapshot to clone into\n+     * @param source   snapshot to clone from\n+     * @param indices  indices to clone\n+     * @param startTime start time\n+     * @param repositoryStateId repository state id that this clone is based on\n+     * @param version repository metadata version to write\n+     * @return snapshot clone entry\n+     */\n+    public static Entry startClone(Snapshot snapshot, SnapshotId source, List<IndexId> indices, long startTime,\n+                                   long repositoryStateId, Version version) {\n+        return new SnapshotsInProgress.Entry(snapshot, false, false, State.STARTED, indices, Collections.emptyList(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c5f8cdf4b87ce4211ae8a3cfd6caa7aadae4dec"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODE3NDM4MQ==", "bodyText": "Do you think we could have a test that fails to clone a snapshot with failed indices?", "url": "https://github.com/elastic/elasticsearch/pull/61839#discussion_r498174381", "createdAt": "2020-10-01T11:31:51Z", "author": {"login": "tlrx"}, "path": "server/src/internalClusterTest/java/org/elasticsearch/snapshots/CloneSnapshotIT.java", "diffHunk": "@@ -107,6 +122,365 @@ public void testShardClone() throws Exception {\n         assertEquals(newShardGeneration, newShardGeneration2);\n     }\n \n+    public void testCloneSnapshotIndex() throws Exception {\n+        internalCluster().startMasterOnlyNode();\n+        internalCluster().startDataOnlyNode();\n+        final String repoName = \"repo-name\";\n+        createRepository(repoName, \"fs\");\n+\n+        final String indexName = \"index-1\";\n+        createIndexWithRandomDocs(indexName, randomIntBetween(5, 10));\n+        final String sourceSnapshot = \"source-snapshot\";\n+        createFullSnapshot(repoName, sourceSnapshot);\n+\n+        indexRandomDocs(indexName, randomIntBetween(20, 100));\n+        if (randomBoolean()) {\n+            assertAcked(admin().indices().prepareDelete(indexName));\n+        }\n+        final String targetSnapshot = \"target-snapshot\";\n+        assertAcked(startClone(repoName, sourceSnapshot, targetSnapshot, indexName).get());\n+\n+        final List<SnapshotStatus> status = clusterAdmin().prepareSnapshotStatus(repoName)\n+                .setSnapshots(sourceSnapshot, targetSnapshot).get().getSnapshots();\n+        assertThat(status, hasSize(2));\n+        final SnapshotIndexStatus status1 = status.get(0).getIndices().get(indexName);\n+        final SnapshotIndexStatus status2 = status.get(1).getIndices().get(indexName);\n+        assertEquals(status1.getStats().getTotalFileCount(), status2.getStats().getTotalFileCount());\n+        assertEquals(status1.getStats().getTotalSize(), status2.getStats().getTotalSize());\n+    }\n+\n+    public void testClonePreventsSnapshotDelete() throws Exception {\n+        final String masterName = internalCluster().startMasterOnlyNode();\n+        internalCluster().startDataOnlyNode();\n+        final String repoName = \"repo-name\";\n+        createRepository(repoName, \"mock\");\n+\n+        final String indexName = \"index-1\";\n+        createIndexWithRandomDocs(indexName, randomIntBetween(5, 10));\n+        final String sourceSnapshot = \"source-snapshot\";\n+        createFullSnapshot(repoName, sourceSnapshot);\n+\n+        indexRandomDocs(indexName, randomIntBetween(20, 100));\n+\n+        final String targetSnapshot = \"target-snapshot\";\n+        blockNodeOnAnyFiles(repoName, masterName);\n+        final ActionFuture<AcknowledgedResponse> cloneFuture = startClone(repoName, sourceSnapshot, targetSnapshot, indexName);\n+        waitForBlock(masterName, repoName, TimeValue.timeValueSeconds(30L));\n+        assertFalse(cloneFuture.isDone());\n+\n+        ConcurrentSnapshotExecutionException ex = expectThrows(ConcurrentSnapshotExecutionException.class,\n+                () -> startDeleteSnapshot(repoName, sourceSnapshot).actionGet());\n+        assertThat(ex.getMessage(), containsString(\"cannot delete snapshot while it is being cloned\"));\n+\n+        unblockNode(repoName, masterName);\n+        assertAcked(cloneFuture.get());\n+        final List<SnapshotStatus> status = clusterAdmin().prepareSnapshotStatus(repoName)\n+                .setSnapshots(sourceSnapshot, targetSnapshot).get().getSnapshots();\n+        assertThat(status, hasSize(2));\n+        final SnapshotIndexStatus status1 = status.get(0).getIndices().get(indexName);\n+        final SnapshotIndexStatus status2 = status.get(1).getIndices().get(indexName);\n+        assertEquals(status1.getStats().getTotalFileCount(), status2.getStats().getTotalFileCount());\n+        assertEquals(status1.getStats().getTotalSize(), status2.getStats().getTotalSize());\n+    }\n+\n+    public void testConcurrentCloneAndSnapshot() throws Exception {\n+        internalCluster().startMasterOnlyNode();\n+        final String dataNode = internalCluster().startDataOnlyNode();\n+        final String repoName = \"repo-name\";\n+        createRepository(repoName, \"mock\");\n+\n+        final String indexName = \"index-1\";\n+        createIndexWithRandomDocs(indexName, randomIntBetween(5, 10));\n+        final String sourceSnapshot = \"source-snapshot\";\n+        createFullSnapshot(repoName, sourceSnapshot);\n+\n+        indexRandomDocs(indexName, randomIntBetween(20, 100));\n+\n+        final String targetSnapshot = \"target-snapshot\";\n+        final ActionFuture<CreateSnapshotResponse> snapshot2Future =\n+                startFullSnapshotBlockedOnDataNode(\"snapshot-2\", repoName, dataNode);\n+        waitForBlock(dataNode, repoName, TimeValue.timeValueSeconds(30L));\n+        final ActionFuture<AcknowledgedResponse> cloneFuture = startClone(repoName, sourceSnapshot, targetSnapshot, indexName);\n+        awaitNumberOfSnapshotsInProgress(2);\n+        unblockNode(repoName, dataNode);\n+        assertAcked(cloneFuture.get());\n+        assertSuccessful(snapshot2Future);\n+    }\n+\n+    public void testLongRunningCloneAllowsConcurrentSnapshot() throws Exception {\n+        // large snapshot pool so blocked snapshot threads from cloning don't prevent concurrent snapshot finalizations\n+        final String masterNode = internalCluster().startMasterOnlyNode(LARGE_SNAPSHOT_POOL_SETTINGS);\n+        internalCluster().startDataOnlyNode();\n+        final String repoName = \"test-repo\";\n+        createRepository(repoName, \"mock\");\n+        final String indexSlow = \"index-slow\";\n+        createIndexWithContent(indexSlow);\n+\n+        final String sourceSnapshot = \"source-snapshot\";\n+        createFullSnapshot(repoName, sourceSnapshot);\n+\n+        final String targetSnapshot = \"target-snapshot\";\n+        blockMasterOnShardClone(repoName);\n+        final ActionFuture<AcknowledgedResponse> cloneFuture = startClone(repoName, sourceSnapshot, targetSnapshot, indexSlow);\n+        waitForBlock(masterNode, repoName, TimeValue.timeValueSeconds(30L));\n+\n+        final String indexFast = \"index-fast\";\n+        createIndexWithRandomDocs(indexFast, randomIntBetween(20, 100));\n+\n+        assertSuccessful(clusterAdmin().prepareCreateSnapshot(repoName, \"fast-snapshot\")\n+                .setIndices(indexFast).setWaitForCompletion(true).execute());\n+\n+        assertThat(cloneFuture.isDone(), is(false));\n+        unblockNode(repoName, masterNode);\n+\n+        assertAcked(cloneFuture.get());\n+    }\n+\n+    public void testLongRunningSnapshotAllowsConcurrentClone() throws Exception {\n+        internalCluster().startMasterOnlyNode();\n+        final String dataNode = internalCluster().startDataOnlyNode();\n+        final String repoName = \"test-repo\";\n+        createRepository(repoName, \"mock\");\n+        final String indexSlow = \"index-slow\";\n+        createIndexWithContent(indexSlow);\n+\n+        final String sourceSnapshot = \"source-snapshot\";\n+        createFullSnapshot(repoName, sourceSnapshot);\n+\n+        final String indexFast = \"index-fast\";\n+        createIndexWithRandomDocs(indexFast, randomIntBetween(20, 100));\n+\n+        blockDataNode(repoName, dataNode);\n+        final ActionFuture<CreateSnapshotResponse> snapshotFuture = clusterAdmin()\n+                .prepareCreateSnapshot(repoName, \"fast-snapshot\").setIndices(indexFast).setWaitForCompletion(true).execute();\n+        waitForBlock(dataNode, repoName, TimeValue.timeValueSeconds(30L));\n+\n+        final String targetSnapshot = \"target-snapshot\";\n+        assertAcked(startClone(repoName, sourceSnapshot, targetSnapshot, indexSlow).get());\n+\n+        assertThat(snapshotFuture.isDone(), is(false));\n+        unblockNode(repoName, dataNode);\n+\n+        assertSuccessful(snapshotFuture);\n+    }\n+\n+    public void testDeletePreventsClone() throws Exception {\n+        final String masterName = internalCluster().startMasterOnlyNode();\n+        internalCluster().startDataOnlyNode();\n+        final String repoName = \"repo-name\";\n+        createRepository(repoName, \"mock\");\n+\n+        final String indexName = \"index-1\";\n+        createIndexWithRandomDocs(indexName, randomIntBetween(5, 10));\n+        final String sourceSnapshot = \"source-snapshot\";\n+        createFullSnapshot(repoName, sourceSnapshot);\n+\n+        indexRandomDocs(indexName, randomIntBetween(20, 100));\n+\n+        final String targetSnapshot = \"target-snapshot\";\n+        blockNodeOnAnyFiles(repoName, masterName);\n+        final ActionFuture<AcknowledgedResponse> deleteFuture = startDeleteSnapshot(repoName, sourceSnapshot);\n+        waitForBlock(masterName, repoName, TimeValue.timeValueSeconds(30L));\n+        assertFalse(deleteFuture.isDone());\n+\n+        ConcurrentSnapshotExecutionException ex = expectThrows(ConcurrentSnapshotExecutionException.class, () ->\n+                startClone(repoName, sourceSnapshot, targetSnapshot, indexName).actionGet());\n+        assertThat(ex.getMessage(), containsString(\"cannot clone from snapshot that is being deleted\"));\n+\n+        unblockNode(repoName, masterName);\n+        assertAcked(deleteFuture.get());\n+    }\n+\n+    public void testBackToBackClonesForIndexNotInCluster() throws Exception {\n+        // large snapshot pool so blocked snapshot threads from cloning don't prevent concurrent snapshot finalizations\n+        final String masterNode = internalCluster().startMasterOnlyNode(LARGE_SNAPSHOT_POOL_SETTINGS);\n+        internalCluster().startDataOnlyNode();\n+        final String repoName = \"test-repo\";\n+        createRepository(repoName, \"mock\");\n+        final String indexBlocked = \"index-blocked\";\n+        createIndexWithContent(indexBlocked);\n+\n+        final String sourceSnapshot = \"source-snapshot\";\n+        createFullSnapshot(repoName, sourceSnapshot);\n+\n+        assertAcked(admin().indices().prepareDelete(indexBlocked).get());\n+\n+        final String targetSnapshot1 = \"target-snapshot\";\n+        blockMasterOnShardClone(repoName);\n+        final ActionFuture<AcknowledgedResponse> cloneFuture1 = startClone(repoName, sourceSnapshot, targetSnapshot1, indexBlocked);\n+        waitForBlock(masterNode, repoName, TimeValue.timeValueSeconds(30L));\n+        assertThat(cloneFuture1.isDone(), is(false));\n+\n+        final int extraClones = randomIntBetween(1, 5);\n+        final List<ActionFuture<AcknowledgedResponse>> extraCloneFutures = new ArrayList<>(extraClones);\n+        for (int i = 0; i < extraClones; i++) {\n+            extraCloneFutures.add(startClone(repoName, sourceSnapshot, \"target-snapshot-\" + i, indexBlocked));\n+        }\n+        awaitNumberOfSnapshotsInProgress(1 + extraClones);\n+        for (ActionFuture<AcknowledgedResponse> extraCloneFuture : extraCloneFutures) {\n+            assertFalse(extraCloneFuture.isDone());\n+        }\n+\n+        final int extraSnapshots = randomIntBetween(0, 5);\n+        if (extraSnapshots > 0) {\n+            createIndexWithContent(indexBlocked);\n+        }\n+\n+        final List<ActionFuture<CreateSnapshotResponse>> extraSnapshotFutures = new ArrayList<>(extraSnapshots);\n+        for (int i = 0; i < extraSnapshots; i++) {\n+            extraSnapshotFutures.add(startFullSnapshot(repoName, \"extra-snap-\" + i));\n+        }\n+\n+        awaitNumberOfSnapshotsInProgress(1 + extraClones + extraSnapshots);\n+        for (ActionFuture<CreateSnapshotResponse> extraSnapshotFuture : extraSnapshotFutures) {\n+            assertFalse(extraSnapshotFuture.isDone());\n+        }\n+\n+        unblockNode(repoName, masterNode);\n+        assertAcked(cloneFuture1.get());\n+\n+        for (ActionFuture<AcknowledgedResponse> extraCloneFuture : extraCloneFutures) {\n+            assertAcked(extraCloneFuture.get());\n+        }\n+        for (ActionFuture<CreateSnapshotResponse> extraSnapshotFuture : extraSnapshotFutures) {\n+            assertSuccessful(extraSnapshotFuture);\n+        }\n+    }\n+\n+    public void testMasterFailoverDuringCloneStep1() throws Exception {\n+        internalCluster().startMasterOnlyNodes(3);\n+        internalCluster().startDataOnlyNode();\n+        final String repoName = \"test-repo\";\n+        createRepository(repoName, \"mock\");\n+        final String testIndex = \"index-test\";\n+        createIndexWithContent(testIndex);\n+\n+        final String sourceSnapshot = \"source-snapshot\";\n+        createFullSnapshot(repoName, sourceSnapshot);\n+\n+        blockMasterOnReadIndexMeta(repoName);\n+        final ActionFuture<AcknowledgedResponse> cloneFuture =\n+                startCloneFromDataNode(repoName, sourceSnapshot, \"target-snapshot\", testIndex);\n+        awaitNumberOfSnapshotsInProgress(1);\n+        final String masterNode = internalCluster().getMasterName();\n+        waitForBlock(masterNode, repoName, TimeValue.timeValueSeconds(30L));\n+        internalCluster().restartNode(masterNode);\n+        boolean cloneSucceeded = false;\n+        try {\n+            cloneFuture.actionGet(TimeValue.timeValueSeconds(30L));\n+            cloneSucceeded = true;\n+        } catch (SnapshotException sne) {\n+            // ignored, most of the time we will throw here but we could randomly run into a situation where the data node retries the\n+            // snapshot on disconnect slowly enough for it to work out\n+        }\n+\n+        awaitNoMoreRunningOperations(internalCluster().getMasterName());\n+\n+        assertAllSnapshotsSuccessful(getRepositoryData(repoName), cloneSucceeded ? 2 : 1);\n+    }\n+\n+    public void testFailsOnCloneMissingIndices() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c5f8cdf4b87ce4211ae8a3cfd6caa7aadae4dec"}, "originalPosition": 314}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODE4MjA2OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        assert assertShardsConsistent(source, state, indices, shards, this.clones);\n          \n          \n            \n                        assert assertShardsConsistent(this.source, this.state, this.indices, this.shards, this.clones);", "url": "https://github.com/elastic/elasticsearch/pull/61839#discussion_r498182069", "createdAt": "2020-10-01T11:47:27Z", "author": {"login": "tlrx"}, "path": "server/src/main/java/org/elasticsearch/cluster/SnapshotsInProgress.java", "diffHunk": "@@ -124,11 +170,18 @@ public Entry(Snapshot snapshot, boolean includeGlobalState, boolean partial, Sta\n             this.dataStreams = dataStreams;\n             this.startTime = startTime;\n             this.shards = shards;\n-            assert assertShardsConsistent(state, indices, shards);\n             this.repositoryStateId = repositoryStateId;\n             this.failure = failure;\n             this.userMetadata = userMetadata;\n             this.version = version;\n+            this.source = source;\n+            if (source == null) {\n+                assert clones == null || clones.isEmpty() : \"Provided [\" + clones + \"] but no source\";\n+                this.clones = ImmutableOpenMap.of();\n+            } else {\n+                this.clones = clones;\n+            }\n+            assert assertShardsConsistent(source, state, indices, shards, this.clones);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c5f8cdf4b87ce4211ae8a3cfd6caa7aadae4dec"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODE4OTM2NA==", "bodyText": "Maybe move this few steps up, after final String repositoryName = request.repository();", "url": "https://github.com/elastic/elasticsearch/pull/61839#discussion_r498189364", "createdAt": "2020-10-01T12:01:10Z", "author": {"login": "tlrx"}, "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -313,6 +308,275 @@ public TimeValue timeout() {\n         }, \"create_snapshot [\" + snapshotName + ']', listener::onFailure);\n     }\n \n+    private static void ensureSnapshotNameNotRunning(List<SnapshotsInProgress.Entry> runningSnapshots, String repositoryName,\n+                                                     String snapshotName) {\n+        if (runningSnapshots.stream().anyMatch(s -> {\n+            final Snapshot running = s.snapshot();\n+            return running.getRepository().equals(repositoryName) && running.getSnapshotId().getName().equals(snapshotName);\n+        })) {\n+            throw new InvalidSnapshotNameException(repositoryName, snapshotName, \"snapshot with the same name is already in-progress\");\n+        }\n+    }\n+\n+    private static Map<String, IndexId> getInFlightIndexIds(List<SnapshotsInProgress.Entry> runningSnapshots, String repositoryName) {\n+        return runningSnapshots.stream().filter(entry -> entry.repository().equals(repositoryName))\n+                .flatMap(entry -> entry.indices().stream()).distinct()\n+                .collect(Collectors.toMap(IndexId::getName, Function.identity()));\n+    }\n+\n+    public void cloneSnapshot(CloneSnapshotRequest request, ActionListener<Void> listener) {\n+        final String repositoryName = request.repository();\n+        final String snapshotName = indexNameExpressionResolver.resolveDateMathExpression(request.target());\n+        validate(repositoryName, snapshotName);\n+        Repository repository = repositoriesService.repository(repositoryName);\n+        if (repository.isReadOnly()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c5f8cdf4b87ce4211ae8a3cfd6caa7aadae4dec"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODE5Njk3NA==", "bodyText": "nit: indentation messed up here, making the code difficult to read", "url": "https://github.com/elastic/elasticsearch/pull/61839#discussion_r498196974", "createdAt": "2020-10-01T12:15:08Z", "author": {"login": "tlrx"}, "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -313,6 +308,275 @@ public TimeValue timeout() {\n         }, \"create_snapshot [\" + snapshotName + ']', listener::onFailure);\n     }\n \n+    private static void ensureSnapshotNameNotRunning(List<SnapshotsInProgress.Entry> runningSnapshots, String repositoryName,\n+                                                     String snapshotName) {\n+        if (runningSnapshots.stream().anyMatch(s -> {\n+            final Snapshot running = s.snapshot();\n+            return running.getRepository().equals(repositoryName) && running.getSnapshotId().getName().equals(snapshotName);\n+        })) {\n+            throw new InvalidSnapshotNameException(repositoryName, snapshotName, \"snapshot with the same name is already in-progress\");\n+        }\n+    }\n+\n+    private static Map<String, IndexId> getInFlightIndexIds(List<SnapshotsInProgress.Entry> runningSnapshots, String repositoryName) {\n+        return runningSnapshots.stream().filter(entry -> entry.repository().equals(repositoryName))\n+                .flatMap(entry -> entry.indices().stream()).distinct()\n+                .collect(Collectors.toMap(IndexId::getName, Function.identity()));\n+    }\n+\n+    public void cloneSnapshot(CloneSnapshotRequest request, ActionListener<Void> listener) {\n+        final String repositoryName = request.repository();\n+        final String snapshotName = indexNameExpressionResolver.resolveDateMathExpression(request.target());\n+        validate(repositoryName, snapshotName);\n+        Repository repository = repositoriesService.repository(repositoryName);\n+        if (repository.isReadOnly()) {\n+            listener.onFailure(new RepositoryException(repositoryName, \"cannot create snapshot in a readonly repository\"));\n+            return;\n+        }\n+        final SnapshotId snapshotId = new SnapshotId(snapshotName, UUIDs.randomBase64UUID());\n+        final Snapshot snapshot = new Snapshot(repositoryName, snapshotId);\n+        initializingClones.add(snapshot);\n+        repository.executeConsistentStateUpdate(repositoryData -> new ClusterStateUpdateTask() {\n+\n+            private SnapshotsInProgress.Entry newEntry;\n+\n+            @Override\n+            public ClusterState execute(ClusterState currentState) {\n+                ensureSnapshotNameAvailableInRepo(repositoryData, snapshotName, repository);\n+                ensureNoCleanupInProgress(currentState, repositoryName, snapshotName);\n+                final SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE, SnapshotsInProgress.EMPTY);\n+                final List<SnapshotsInProgress.Entry> runningSnapshots = snapshots.entries();\n+                ensureSnapshotNameNotRunning(runningSnapshots, repositoryName, snapshotName);\n+                validate(repositoryName, snapshotName, currentState);\n+\n+                final SnapshotId sourceSnapshotId = repositoryData.getSnapshotIds()\n+                        .stream()\n+                        .filter(src -> src.getName().equals(request.source()))\n+                        .findAny()\n+                        .orElseThrow(() -> new SnapshotMissingException(repositoryName, request.source()));\n+                final SnapshotDeletionsInProgress deletionsInProgress =\n+                        currentState.custom(SnapshotDeletionsInProgress.TYPE, SnapshotDeletionsInProgress.EMPTY);\n+                if (deletionsInProgress.getEntries().stream().anyMatch(entry -> entry.getSnapshots().contains(sourceSnapshotId))) {\n+                    throw new ConcurrentSnapshotExecutionException(repositoryName, sourceSnapshotId.getName(),\n+                            \"cannot clone from snapshot that is being deleted\");\n+                }\n+                ensureBelowConcurrencyLimit(repositoryName, snapshotName, snapshots, deletionsInProgress);\n+                final List<String> indicesForSnapshot = new ArrayList<>();\n+                for (IndexId indexId : repositoryData.getIndices().values()) {\n+                    if (repositoryData.getSnapshots(indexId).contains(sourceSnapshotId)) {\n+                        indicesForSnapshot.add(indexId.getName());\n+                    }\n+                }\n+                final List<String> matchingIndices =\n+                        SnapshotUtils.filterIndices(indicesForSnapshot, request.indices(), request.indicesOptions());\n+                if (matchingIndices.isEmpty()) {\n+                    throw new SnapshotException(new Snapshot(repositoryName, sourceSnapshotId),\n+                            \"No indices in the source snapshot [\" + sourceSnapshotId + \"] matched requested pattern [\"\n+                                    + Strings.arrayToCommaDelimitedString(request.indices()) + \"]\");\n+                }\n+                newEntry = SnapshotsInProgress.startClone(\n+                        snapshot, sourceSnapshotId,\n+                        repositoryData.resolveIndices(matchingIndices),\n+                        threadPool.absoluteTimeInMillis(), repositoryData.getGenId(),\n+                        minCompatibleVersion(currentState.nodes().getMinNodeVersion(), repositoryData, null));\n+                final List<SnapshotsInProgress.Entry> newEntries = new ArrayList<>(runningSnapshots);\n+                newEntries.add(newEntry);\n+                return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE,\n+                        SnapshotsInProgress.of(List.copyOf(newEntries))).build();\n+            }\n+\n+            @Override\n+            public void onFailure(String source, Exception e) {\n+                initializingClones.remove(snapshot);\n+                logger.warn(() -> new ParameterizedMessage(\"[{}][{}] failed to clone snapshot\", repositoryName, snapshotName), e);\n+                listener.onFailure(e);\n+            }\n+\n+            @Override\n+            public void clusterStateProcessed(String source, ClusterState oldState, final ClusterState newState) {\n+                logger.info(\"snapshot clone [{}] started\", snapshot);\n+                addListener(snapshot, ActionListener.wrap(r -> listener.onResponse(null), listener::onFailure));\n+                startCloning(repository, newEntry);\n+            }\n+\n+            @Override\n+            public TimeValue timeout() {\n+                initializingClones.remove(snapshot);\n+                return request.masterNodeTimeout();\n+            }\n+        }, \"clone_snapshot [\" + request.source() + \"][\" + snapshotName + ']', listener::onFailure);\n+    }\n+\n+    private static void ensureNoCleanupInProgress(ClusterState currentState, String repositoryName, String snapshotName) {\n+        final RepositoryCleanupInProgress repositoryCleanupInProgress =\n+                currentState.custom(RepositoryCleanupInProgress.TYPE, RepositoryCleanupInProgress.EMPTY);\n+        if (repositoryCleanupInProgress.hasCleanupInProgress()) {\n+            throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName,\n+                    \"cannot snapshot while a repository cleanup is in-progress in [\" + repositoryCleanupInProgress + \"]\");\n+        }\n+    }\n+\n+    private static void ensureSnapshotNameAvailableInRepo(RepositoryData repositoryData, String snapshotName, Repository repository) {\n+        // check if the snapshot name already exists in the repository\n+        if (repositoryData.getSnapshotIds().stream().anyMatch(s -> s.getName().equals(snapshotName))) {\n+            throw new InvalidSnapshotNameException(\n+                    repository.getMetadata().name(), snapshotName, \"snapshot with the same name already exists\");\n+        }\n+    }\n+\n+    /**\n+     * Determine the number of shards in each index of a clone operation and update the cluster state accordingly.\n+     *\n+     * @param repository     repository to run operation on\n+     * @param cloneEntry     clone operation in the cluster state\n+     */\n+    private void startCloning(Repository repository, SnapshotsInProgress.Entry cloneEntry) {\n+        final List<IndexId> indices = cloneEntry.indices();\n+        final SnapshotId sourceSnapshot = cloneEntry.source();\n+        final Snapshot targetSnapshot = cloneEntry.snapshot();\n+\n+        final Executor executor = threadPool.executor(ThreadPool.Names.SNAPSHOT);\n+        // Exception handler for IO exceptions with loading index and repo metadata\n+        final Consumer<Exception> onFailure = e -> {\n+            initializingClones.remove(targetSnapshot);\n+            logger.info(() -> new ParameterizedMessage(\"Failed to start snapshot clone [{}]\", cloneEntry), e);\n+            removeFailedSnapshotFromClusterState(targetSnapshot, e, null);\n+        };\n+\n+        // 1. step, load SnapshotInfo to make sure that source snapshot was successful for the indices we want to clone\n+        // TODO: we could skip this step for snapshots with state SUCCESS\n+        final StepListener<SnapshotInfo> snapshotInfoListener = new StepListener<>();\n+        executor.execute(ActionRunnable.supply(snapshotInfoListener, () -> repository.getSnapshotInfo(sourceSnapshot)));\n+\n+        final StepListener<Collection<Tuple<IndexId, Integer>>> allShardCountsListener = new StepListener<>();\n+        final GroupedActionListener<Tuple<IndexId, Integer>> shardCountListener =\n+                new GroupedActionListener<>(allShardCountsListener, indices.size());\n+        snapshotInfoListener.whenComplete(snapshotInfo -> {\n+            for (IndexId indexId : indices) {\n+                if (RestoreService.failed(snapshotInfo, indexId.getName())) {\n+                    throw new SnapshotException(targetSnapshot, \"Can't clone index [\" + indexId +\n+                            \"] because its snapshot is was not successful.\");\n+                }\n+            }\n+            // 2. step, load the number of shards we have in each index to be cloned from the index metadata.\n+            repository.getRepositoryData(ActionListener.wrap(repositoryData -> {\n+                for (IndexId index : indices) {\n+                    executor.execute(ActionRunnable.supply(shardCountListener, () -> {\n+                        final IndexMetadata metadata = repository.getSnapshotIndexMetaData(repositoryData, sourceSnapshot, index);\n+                        return Tuple.tuple(index, metadata.getNumberOfShards());\n+                    }));\n+                }\n+            }, onFailure));\n+        }, onFailure);\n+\n+        // 3. step, we have all the shard counts, now update the cluster state to have clone jobs in the snap entry\n+        allShardCountsListener.whenComplete(counts -> repository.executeConsistentStateUpdate(repoData -> new ClusterStateUpdateTask() {\n+\n+            private SnapshotsInProgress.Entry updatedEntry;\n+\n+            @Override\n+            public ClusterState execute(ClusterState currentState) {\n+                final SnapshotsInProgress snapshotsInProgress =\n+                        currentState.custom(SnapshotsInProgress.TYPE, SnapshotsInProgress.EMPTY);\n+                final List<SnapshotsInProgress.Entry> updatedEntries = new ArrayList<>(snapshotsInProgress.entries());\n+                boolean changed = false;\n+                final String localNodeId = currentState.nodes().getLocalNodeId();\n+                final String repoName = cloneEntry.repository();\n+                final Map<String, IndexId> indexIds = getInFlightIndexIds(updatedEntries, repoName);\n+                final ShardGenerations shardGenerations = repoData.shardGenerations();\n+                for (int i = 0; i < updatedEntries.size(); i++) {\n+                    if (cloneEntry.equals(updatedEntries.get(i))) {\n+                        final ImmutableOpenMap.Builder<RepositoryShardId, ShardSnapshotStatus> clonesBuilder =\n+                                ImmutableOpenMap.builder();\n+                        // TODO: could be optimized by just dealing with repo shard id directly\n+                        final Set<RepositoryShardId> busyShardsInRepo =\n+                                busyShardsForRepo(repoName, snapshotsInProgress, currentState.metadata())\n+                                        .stream()\n+                                        .map(shardId -> new RepositoryShardId(indexIds.get(shardId.getIndexName()), shardId.getId()))\n+                                        .collect(Collectors.toSet());\n+                        for (Tuple<IndexId, Integer> count : counts) {\n+                            for (int shardId = 0; shardId < count.v2(); shardId++) {\n+                                final RepositoryShardId repoShardId = new RepositoryShardId(count.v1(), shardId);\n+                                if (busyShardsInRepo.contains(repoShardId)) {\n+                                    clonesBuilder.put(repoShardId, ShardSnapshotStatus.UNASSIGNED_QUEUED);\n+                                } else {\n+                                    clonesBuilder.put(repoShardId,\n+                                            new ShardSnapshotStatus(localNodeId, shardGenerations.getShardGen(count.v1(), shardId)));\n+                                }\n+                            }\n+                        }\n+                        updatedEntry = cloneEntry.withClones(clonesBuilder.build());\n+                        updatedEntries.set(i, updatedEntry);\n+                        changed = true;\n+                        break;\n+                    }\n+                }\n+                return updateWithSnapshots(currentState, changed ? SnapshotsInProgress.of(updatedEntries) : null, null);\n+            }\n+\n+            @Override\n+            public void onFailure(String source, Exception e) {\n+                initializingClones.remove(targetSnapshot);\n+                logger.info(() -> new ParameterizedMessage(\"Failed to start snapshot clone [{}]\", cloneEntry), e);\n+                failAllListenersOnMasterFailOver(e);\n+            }\n+\n+            @Override\n+            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n+                initializingClones.remove(targetSnapshot);\n+                if (updatedEntry != null) {\n+                    final Snapshot target = updatedEntry.snapshot();\n+                    final SnapshotId sourceSnapshot = updatedEntry.source();\n+                    for (ObjectObjectCursor<RepositoryShardId, ShardSnapshotStatus> indexClone : updatedEntry.clones()) {\n+                        final ShardSnapshotStatus shardStatusBefore = indexClone.value;\n+                        if (shardStatusBefore.state() != ShardState.INIT) {\n+                            continue;\n+                        }\n+                        final RepositoryShardId repoShardId = indexClone.key;\n+                        runReadyClone(target, sourceSnapshot, shardStatusBefore, repoShardId, repository);\n+                    }\n+                } else {\n+                    // Extremely unlikely corner case of master failing over between between starting the clone and\n+                    // starting shard clones.\n+                    logger.warn(\"Did not find expected entry [{}] in the cluster state\", cloneEntry);\n+                }\n+            }\n+        }, \"start snapshot clone\", onFailure), onFailure);\n+    }\n+\n+    private final Set<RepositoryShardId> currentlyCloning = Collections.synchronizedSet(new HashSet<>());\n+\n+    private void runReadyClone(Snapshot target, SnapshotId sourceSnapshot, ShardSnapshotStatus shardStatusBefore,\n+                               RepositoryShardId repoShardId, Repository repository) {\n+        final SnapshotId targetSnapshot = target.getSnapshotId();\n+        final String localNodeId = clusterService.localNode().getId();\n+        if (currentlyCloning.add(repoShardId)) {\n+            repository.cloneShardSnapshot(sourceSnapshot, targetSnapshot, repoShardId,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c5f8cdf4b87ce4211ae8a3cfd6caa7aadae4dec"}, "originalPosition": 341}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODIxMjQzNg==", "bodyText": "nit: ident", "url": "https://github.com/elastic/elasticsearch/pull/61839#discussion_r498212436", "createdAt": "2020-10-01T12:40:58Z", "author": {"login": "tlrx"}, "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -1159,6 +1465,17 @@ public ClusterState execute(ClusterState currentState) {\n                 if (snapshotIds.isEmpty()) {\n                     return currentState;\n                 }\n+                final Set<SnapshotId> activeCloneSources = snapshots.entries()\n+                        .stream()\n+                        .filter(entry -> entry.source() != null)\n+                        .map(SnapshotsInProgress.Entry::source\n+                        ).collect(Collectors.toSet());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c5f8cdf4b87ce4211ae8a3cfd6caa7aadae4dec"}, "originalPosition": 536}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODIxMzExMg==", "bodyText": "It's use everywhere, maybe adding a method isClone() returning source != null would be more explicit?", "url": "https://github.com/elastic/elasticsearch/pull/61839#discussion_r498213112", "createdAt": "2020-10-01T12:42:01Z", "author": {"login": "tlrx"}, "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -1809,16 +2126,32 @@ public static ClusterState updateWithSnapshots(ClusterState state,\n      * @param snapshots    snapshots in progress\n      * @return shard ids that currently have an actively executing shard snapshot on a data node\n      */\n-    private static Set<ShardId> busyShardsForRepo(String repoName, @Nullable SnapshotsInProgress snapshots) {\n+    private static Set<ShardId> busyShardsForRepo(String repoName, @Nullable SnapshotsInProgress snapshots, Metadata metadata) {\n         final List<SnapshotsInProgress.Entry> runningSnapshots = snapshots == null ? List.of() : snapshots.entries();\n         final Set<ShardId> inProgressShards = new HashSet<>();\n         for (SnapshotsInProgress.Entry runningSnapshot : runningSnapshots) {\n             if (runningSnapshot.repository().equals(repoName) == false) {\n                 continue;\n             }\n-            for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shard : runningSnapshot.shards()) {\n-                if (shard.value.isActive()) {\n-                    inProgressShards.add(shard.key);\n+            if (runningSnapshot.source() == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c5f8cdf4b87ce4211ae8a3cfd6caa7aadae4dec"}, "originalPosition": 570}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODIxMzU3MQ==", "bodyText": "Maybe activeShardsForRepo would be more appropriate?", "url": "https://github.com/elastic/elasticsearch/pull/61839#discussion_r498213571", "createdAt": "2020-10-01T12:42:46Z", "author": {"login": "tlrx"}, "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -1809,16 +2126,32 @@ public static ClusterState updateWithSnapshots(ClusterState state,\n      * @param snapshots    snapshots in progress\n      * @return shard ids that currently have an actively executing shard snapshot on a data node\n      */\n-    private static Set<ShardId> busyShardsForRepo(String repoName, @Nullable SnapshotsInProgress snapshots) {\n+    private static Set<ShardId> busyShardsForRepo(String repoName, @Nullable SnapshotsInProgress snapshots, Metadata metadata) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c5f8cdf4b87ce4211ae8a3cfd6caa7aadae4dec"}, "originalPosition": 560}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6ba89cb1bb5e33ee92c15f62789a1ad03b51a7b9", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/6ba89cb1bb5e33ee92c15f62789a1ad03b51a7b9", "committedDate": "2020-10-01T14:00:02Z", "message": "fix doc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2432ab2c62b3770ab27fd60aa946f6a7a62ee34f", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/2432ab2c62b3770ab27fd60aa946f6a7a62ee34f", "committedDate": "2020-10-01T14:00:32Z", "message": "fix doc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bdd6943f91386b376807b7efd9a3daa247926bea", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/bdd6943f91386b376807b7efd9a3daa247926bea", "committedDate": "2020-10-01T14:07:54Z", "message": "include global metadata"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6d6c592745d04a073672d3d4eefdfddbdaa3017f", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/6d6c592745d04a073672d3d4eefdfddbdaa3017f", "committedDate": "2020-10-01T14:22:53Z", "message": "fix indent"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "900eabaa2f4f6a783bfec3fce9d16ddffa0e3c55", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/900eabaa2f4f6a783bfec3fce9d16ddffa0e3c55", "committedDate": "2020-10-01T14:23:29Z", "message": "fix indent"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwMzY0NDYw", "url": "https://github.com/elastic/elasticsearch/pull/61839#pullrequestreview-500364460", "createdAt": "2020-10-01T13:47:14Z", "commit": {"oid": "3c5f8cdf4b87ce4211ae8a3cfd6caa7aadae4dec"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxMzo0NzoxNFrOHbLNLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNDozMDoyMVrOHbNNHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI1NzE5Ng==", "bodyText": "Given the complexity of this method, I think it deserves its own unit tests.", "url": "https://github.com/elastic/elasticsearch/pull/61839#discussion_r498257196", "createdAt": "2020-10-01T13:47:14Z", "author": {"login": "tlrx"}, "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -1911,82 +2244,246 @@ public boolean assertAllListenersResolved() {\n         return true;\n     }\n \n+    /**\n+     * Executor that applies {@link ShardSnapshotUpdate}s to the current cluster state. The algorithm implemented below works as described\n+     * below:\n+     * Every shard snapshot or clone state update can result in multiple snapshots being updated. In order to determine whether or not a\n+     * shard update has an effect we use an outer loop over all current executing snapshot operations that iterates over them in the order\n+     * they were started in and an inner loop over the list of shard update tasks.\n+     *\n+     * If the inner loop finds that a shard update task applies to a given snapshot and either a shard-snapshot or shard-clone operation in\n+     * it then it will update the state of the snapshot entry accordingly. If that update was a noop, then the task is removed from the\n+     * iteration as it was already applied before and likely just arrived on the master node again due to retries upstream.\n+     * If the update was not a noop, then it means that the shard it applied to is now available for another snapshot or clone operation\n+     * to be re-assigned if there is another snapshot operation that is waiting for the shard to become available. We therefore record the\n+     * fact that a task was executed by adding it to a collection of executed tasks. If a subsequent execution of the outer loop finds that\n+     * a task in the executed tasks collection applied to a shard it was waiting for to become available, then the shard snapshot operation\n+     * will be started for that snapshot entry and the task removed from the collection of tasks that need to be applied to snapshot\n+     * entries since it can not have any further effects.\n+     */\n     private static final ClusterStateTaskExecutor<ShardSnapshotUpdate> SHARD_STATE_EXECUTOR = (currentState, tasks) -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c5f8cdf4b87ce4211ae8a3cfd6caa7aadae4dec"}, "originalPosition": 613}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI2MTg5NA==", "bodyText": "Can we assert entry.source() != null ?", "url": "https://github.com/elastic/elasticsearch/pull/61839#discussion_r498261894", "createdAt": "2020-10-01T13:53:36Z", "author": {"login": "tlrx"}, "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -1911,82 +2244,246 @@ public boolean assertAllListenersResolved() {\n         return true;\n     }\n \n+    /**\n+     * Executor that applies {@link ShardSnapshotUpdate}s to the current cluster state. The algorithm implemented below works as described\n+     * below:\n+     * Every shard snapshot or clone state update can result in multiple snapshots being updated. In order to determine whether or not a\n+     * shard update has an effect we use an outer loop over all current executing snapshot operations that iterates over them in the order\n+     * they were started in and an inner loop over the list of shard update tasks.\n+     *\n+     * If the inner loop finds that a shard update task applies to a given snapshot and either a shard-snapshot or shard-clone operation in\n+     * it then it will update the state of the snapshot entry accordingly. If that update was a noop, then the task is removed from the\n+     * iteration as it was already applied before and likely just arrived on the master node again due to retries upstream.\n+     * If the update was not a noop, then it means that the shard it applied to is now available for another snapshot or clone operation\n+     * to be re-assigned if there is another snapshot operation that is waiting for the shard to become available. We therefore record the\n+     * fact that a task was executed by adding it to a collection of executed tasks. If a subsequent execution of the outer loop finds that\n+     * a task in the executed tasks collection applied to a shard it was waiting for to become available, then the shard snapshot operation\n+     * will be started for that snapshot entry and the task removed from the collection of tasks that need to be applied to snapshot\n+     * entries since it can not have any further effects.\n+     */\n     private static final ClusterStateTaskExecutor<ShardSnapshotUpdate> SHARD_STATE_EXECUTOR = (currentState, tasks) -> {\n         int changedCount = 0;\n         int startedCount = 0;\n         final List<SnapshotsInProgress.Entry> entries = new ArrayList<>();\n+        final String localNodeId = currentState.nodes().getLocalNodeId();\n         // Tasks to check for updates for running snapshots.\n         final List<ShardSnapshotUpdate> unconsumedTasks = new ArrayList<>(tasks);\n         // Tasks that were used to complete an existing in-progress shard snapshot\n         final Set<ShardSnapshotUpdate> executedTasks = new HashSet<>();\n+        // Outer loop over all snapshot entries in the order they were created in\n         for (SnapshotsInProgress.Entry entry : currentState.custom(SnapshotsInProgress.TYPE, SnapshotsInProgress.EMPTY).entries()) {\n             if (entry.state().completed()) {\n+                // completed snapshots do not require any updates so we just add them to the new list and keep going\n                 entries.add(entry);\n                 continue;\n             }\n             ImmutableOpenMap.Builder<ShardId, ShardSnapshotStatus> shards = null;\n+            ImmutableOpenMap.Builder<RepositoryShardId, ShardSnapshotStatus> clones = null;\n+            Map<String, IndexId> indicesLookup = null;\n+            // inner loop over all the shard updates that are potentially applicable to the current snapshot entry\n             for (Iterator<ShardSnapshotUpdate> iterator = unconsumedTasks.iterator(); iterator.hasNext(); ) {\n                 final ShardSnapshotUpdate updateSnapshotState = iterator.next();\n                 final Snapshot updatedSnapshot = updateSnapshotState.snapshot;\n                 final String updatedRepository = updatedSnapshot.getRepository();\n                 if (entry.repository().equals(updatedRepository) == false) {\n+                    // the update applies to a different repository so it is irrelevant here\n                     continue;\n                 }\n-                final ShardId finishedShardId = updateSnapshotState.shardId;\n-                if (entry.snapshot().getSnapshotId().equals(updatedSnapshot.getSnapshotId())) {\n-                    final ShardSnapshotStatus existing = entry.shards().get(finishedShardId);\n-                    if (existing == null) {\n-                        logger.warn(\"Received shard snapshot status update [{}] but this shard is not tracked in [{}]\",\n-                                updateSnapshotState, entry);\n-                        assert false : \"This should never happen, data nodes should only send updates for expected shards\";\n-                        continue;\n-                    }\n-                    if (existing.state().completed()) {\n-                        // No point in doing noop updates that might happen if data nodes resends shard status after a disconnect.\n-                        iterator.remove();\n-                        continue;\n-                    }\n-                    logger.trace(\"[{}] Updating shard [{}] with status [{}]\", updatedSnapshot,\n-                            finishedShardId, updateSnapshotState.updatedState.state());\n-                    if (shards == null) {\n-                        shards = ImmutableOpenMap.builder(entry.shards());\n-                    }\n-                    shards.put(finishedShardId, updateSnapshotState.updatedState);\n-                    executedTasks.add(updateSnapshotState);\n-                    changedCount++;\n-                } else if (executedTasks.contains(updateSnapshotState)) {\n-                    // tasks that completed a shard might allow starting a new shard snapshot for the current snapshot\n-                    final ShardSnapshotStatus existingStatus = entry.shards().get(finishedShardId);\n-                    if (existingStatus == null || existingStatus.state() != ShardState.QUEUED) {\n-                        continue;\n+                if (updateSnapshotState.isClone()) {\n+                    // The update applied to a shard clone operation\n+                    final RepositoryShardId finishedShardId = updateSnapshotState.repoShardId;\n+                    if (entry.snapshot().getSnapshotId().equals(updatedSnapshot.getSnapshotId())) {\n+                        final ShardSnapshotStatus existing = entry.clones().get(finishedShardId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c5f8cdf4b87ce4211ae8a3cfd6caa7aadae4dec"}, "originalPosition": 672}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI4OTk1MA==", "bodyText": "I've been a bit worried about re-resolving indices here as the cloned shard could reference an index from the snapshot that do not exist anymore, or could have been recreated with a different sharding, but after writing some tests I think it's OK as existingStatus == null later will prevent any difference in the number of shards.", "url": "https://github.com/elastic/elasticsearch/pull/61839#discussion_r498289950", "createdAt": "2020-10-01T14:30:21Z", "author": {"login": "tlrx"}, "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -1911,82 +2244,246 @@ public boolean assertAllListenersResolved() {\n         return true;\n     }\n \n+    /**\n+     * Executor that applies {@link ShardSnapshotUpdate}s to the current cluster state. The algorithm implemented below works as described\n+     * below:\n+     * Every shard snapshot or clone state update can result in multiple snapshots being updated. In order to determine whether or not a\n+     * shard update has an effect we use an outer loop over all current executing snapshot operations that iterates over them in the order\n+     * they were started in and an inner loop over the list of shard update tasks.\n+     *\n+     * If the inner loop finds that a shard update task applies to a given snapshot and either a shard-snapshot or shard-clone operation in\n+     * it then it will update the state of the snapshot entry accordingly. If that update was a noop, then the task is removed from the\n+     * iteration as it was already applied before and likely just arrived on the master node again due to retries upstream.\n+     * If the update was not a noop, then it means that the shard it applied to is now available for another snapshot or clone operation\n+     * to be re-assigned if there is another snapshot operation that is waiting for the shard to become available. We therefore record the\n+     * fact that a task was executed by adding it to a collection of executed tasks. If a subsequent execution of the outer loop finds that\n+     * a task in the executed tasks collection applied to a shard it was waiting for to become available, then the shard snapshot operation\n+     * will be started for that snapshot entry and the task removed from the collection of tasks that need to be applied to snapshot\n+     * entries since it can not have any further effects.\n+     */\n     private static final ClusterStateTaskExecutor<ShardSnapshotUpdate> SHARD_STATE_EXECUTOR = (currentState, tasks) -> {\n         int changedCount = 0;\n         int startedCount = 0;\n         final List<SnapshotsInProgress.Entry> entries = new ArrayList<>();\n+        final String localNodeId = currentState.nodes().getLocalNodeId();\n         // Tasks to check for updates for running snapshots.\n         final List<ShardSnapshotUpdate> unconsumedTasks = new ArrayList<>(tasks);\n         // Tasks that were used to complete an existing in-progress shard snapshot\n         final Set<ShardSnapshotUpdate> executedTasks = new HashSet<>();\n+        // Outer loop over all snapshot entries in the order they were created in\n         for (SnapshotsInProgress.Entry entry : currentState.custom(SnapshotsInProgress.TYPE, SnapshotsInProgress.EMPTY).entries()) {\n             if (entry.state().completed()) {\n+                // completed snapshots do not require any updates so we just add them to the new list and keep going\n                 entries.add(entry);\n                 continue;\n             }\n             ImmutableOpenMap.Builder<ShardId, ShardSnapshotStatus> shards = null;\n+            ImmutableOpenMap.Builder<RepositoryShardId, ShardSnapshotStatus> clones = null;\n+            Map<String, IndexId> indicesLookup = null;\n+            // inner loop over all the shard updates that are potentially applicable to the current snapshot entry\n             for (Iterator<ShardSnapshotUpdate> iterator = unconsumedTasks.iterator(); iterator.hasNext(); ) {\n                 final ShardSnapshotUpdate updateSnapshotState = iterator.next();\n                 final Snapshot updatedSnapshot = updateSnapshotState.snapshot;\n                 final String updatedRepository = updatedSnapshot.getRepository();\n                 if (entry.repository().equals(updatedRepository) == false) {\n+                    // the update applies to a different repository so it is irrelevant here\n                     continue;\n                 }\n-                final ShardId finishedShardId = updateSnapshotState.shardId;\n-                if (entry.snapshot().getSnapshotId().equals(updatedSnapshot.getSnapshotId())) {\n-                    final ShardSnapshotStatus existing = entry.shards().get(finishedShardId);\n-                    if (existing == null) {\n-                        logger.warn(\"Received shard snapshot status update [{}] but this shard is not tracked in [{}]\",\n-                                updateSnapshotState, entry);\n-                        assert false : \"This should never happen, data nodes should only send updates for expected shards\";\n-                        continue;\n-                    }\n-                    if (existing.state().completed()) {\n-                        // No point in doing noop updates that might happen if data nodes resends shard status after a disconnect.\n-                        iterator.remove();\n-                        continue;\n-                    }\n-                    logger.trace(\"[{}] Updating shard [{}] with status [{}]\", updatedSnapshot,\n-                            finishedShardId, updateSnapshotState.updatedState.state());\n-                    if (shards == null) {\n-                        shards = ImmutableOpenMap.builder(entry.shards());\n-                    }\n-                    shards.put(finishedShardId, updateSnapshotState.updatedState);\n-                    executedTasks.add(updateSnapshotState);\n-                    changedCount++;\n-                } else if (executedTasks.contains(updateSnapshotState)) {\n-                    // tasks that completed a shard might allow starting a new shard snapshot for the current snapshot\n-                    final ShardSnapshotStatus existingStatus = entry.shards().get(finishedShardId);\n-                    if (existingStatus == null || existingStatus.state() != ShardState.QUEUED) {\n-                        continue;\n+                if (updateSnapshotState.isClone()) {\n+                    // The update applied to a shard clone operation\n+                    final RepositoryShardId finishedShardId = updateSnapshotState.repoShardId;\n+                    if (entry.snapshot().getSnapshotId().equals(updatedSnapshot.getSnapshotId())) {\n+                        final ShardSnapshotStatus existing = entry.clones().get(finishedShardId);\n+                        if (existing == null) {\n+                            logger.warn(\"Received clone shard snapshot status update [{}] but this shard is not tracked in [{}]\",\n+                                    updateSnapshotState, entry);\n+                            assert false : \"This should never happen, master will not submit a state update for a non-existing clone\";\n+                            continue;\n+                        }\n+                        if (existing.state().completed()) {\n+                            // No point in doing noop updates that might happen if data nodes resends shard status after a disconnect.\n+                            iterator.remove();\n+                            continue;\n+                        }\n+                        logger.trace(\"[{}] Updating shard clone [{}] with status [{}]\", updatedSnapshot,\n+                                finishedShardId, updateSnapshotState.updatedState.state());\n+                        if (clones == null) {\n+                            clones = ImmutableOpenMap.builder(entry.clones());\n+                        }\n+                        changedCount++;\n+                        clones.put(finishedShardId, updateSnapshotState.updatedState);\n+                        executedTasks.add(updateSnapshotState);\n+                    } else if (executedTasks.contains(updateSnapshotState)) {\n+                        // the update was already executed on the clone operation it applied to, now we check if it may be possible to\n+                        // start a shard snapshot or clone operation on the current entry\n+                        if (entry.source() == null) {\n+                            // current entry is a snapshot operation so we must translate the repository shard id to a routing shard id\n+                            final IndexMetadata indexMeta = currentState.metadata().index(finishedShardId.indexName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c5f8cdf4b87ce4211ae8a3cfd6caa7aadae4dec"}, "originalPosition": 697}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "468359d148c268695a3ffa196ac825b5149b276a", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/468359d148c268695a3ffa196ac825b5149b276a", "committedDate": "2020-10-01T14:51:07Z", "message": "add assertion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "60df5f9ab7ab5c20ac51a3d331fdb54a742754b3", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/60df5f9ab7ab5c20ac51a3d331fdb54a742754b3", "committedDate": "2020-10-01T15:01:53Z", "message": "isCLone"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ad9fe18a90f1dc94d0b53ae6f5e3bf4077d388ff", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/ad9fe18a90f1dc94d0b53ae6f5e3bf4077d388ff", "committedDate": "2020-10-01T15:08:24Z", "message": "Merge remote-tracking branch 'elastic/master' into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "df09e3ec4959ba81ea7672aa1e14ccad796c44d9", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/df09e3ec4959ba81ea7672aa1e14ccad796c44d9", "committedDate": "2020-10-01T21:31:42Z", "message": "some UTs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c8d5961a8b59cb336b4c3b2b43904455a499eb88", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/c8d5961a8b59cb336b4c3b2b43904455a499eb88", "committedDate": "2020-10-02T06:56:33Z", "message": "moar UTs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4c2a2128e0af590457d7a19cd2f734f1077f0fdd", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/4c2a2128e0af590457d7a19cd2f734f1077f0fdd", "committedDate": "2020-10-02T07:23:17Z", "message": "even moar tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3b1085f41c0b26c2bd50bb8c6d7e657ceac3b92f", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/3b1085f41c0b26c2bd50bb8c6d7e657ceac3b92f", "committedDate": "2020-10-02T07:44:31Z", "message": "even moar tests (80% cov)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "208985efcddcefd504fc9f5da3d5241e760174af", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/208985efcddcefd504fc9f5da3d5241e760174af", "committedDate": "2020-10-02T08:11:46Z", "message": "full coverage"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5316fc3b3ffd03b5ab4f5a3723eaf1997cb12aa0", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/5316fc3b3ffd03b5ab4f5a3723eaf1997cb12aa0", "committedDate": "2020-10-02T08:17:22Z", "message": "shorter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6e5b74bfcd431b1192f4aface3739f2026da8268", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/6e5b74bfcd431b1192f4aface3739f2026da8268", "committedDate": "2020-10-02T08:30:27Z", "message": "IT"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxMTM5Mzc0", "url": "https://github.com/elastic/elasticsearch/pull/61839#pullrequestreview-501139374", "createdAt": "2020-10-02T13:34:33Z", "commit": {"oid": "6e5b74bfcd431b1192f4aface3739f2026da8268"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxMzozNDozM1rOHbt1vA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxMzozNDozM1rOHbt1vA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODgyNDYzNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        \"] because its snapshot is was not successful.\");\n          \n          \n            \n                                        \"] because its snapshot was not successful.\");", "url": "https://github.com/elastic/elasticsearch/pull/61839#discussion_r498824636", "createdAt": "2020-10-02T13:34:33Z", "author": {"login": "tlrx"}, "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -313,6 +308,276 @@ public TimeValue timeout() {\n         }, \"create_snapshot [\" + snapshotName + ']', listener::onFailure);\n     }\n \n+    private static void ensureSnapshotNameNotRunning(List<SnapshotsInProgress.Entry> runningSnapshots, String repositoryName,\n+                                                     String snapshotName) {\n+        if (runningSnapshots.stream().anyMatch(s -> {\n+            final Snapshot running = s.snapshot();\n+            return running.getRepository().equals(repositoryName) && running.getSnapshotId().getName().equals(snapshotName);\n+        })) {\n+            throw new InvalidSnapshotNameException(repositoryName, snapshotName, \"snapshot with the same name is already in-progress\");\n+        }\n+    }\n+\n+    private static Map<String, IndexId> getInFlightIndexIds(List<SnapshotsInProgress.Entry> runningSnapshots, String repositoryName) {\n+        return runningSnapshots.stream().filter(entry -> entry.repository().equals(repositoryName))\n+                .flatMap(entry -> entry.indices().stream()).distinct()\n+                .collect(Collectors.toMap(IndexId::getName, Function.identity()));\n+    }\n+\n+    public void cloneSnapshot(CloneSnapshotRequest request, ActionListener<Void> listener) {\n+        final String repositoryName = request.repository();\n+        Repository repository = repositoriesService.repository(repositoryName);\n+        if (repository.isReadOnly()) {\n+            listener.onFailure(new RepositoryException(repositoryName, \"cannot create snapshot in a readonly repository\"));\n+            return;\n+        }\n+        final String snapshotName = indexNameExpressionResolver.resolveDateMathExpression(request.target());\n+        validate(repositoryName, snapshotName);\n+        final SnapshotId snapshotId = new SnapshotId(snapshotName, UUIDs.randomBase64UUID());\n+        final Snapshot snapshot = new Snapshot(repositoryName, snapshotId);\n+        initializingClones.add(snapshot);\n+        repository.executeConsistentStateUpdate(repositoryData -> new ClusterStateUpdateTask() {\n+\n+            private SnapshotsInProgress.Entry newEntry;\n+\n+            @Override\n+            public ClusterState execute(ClusterState currentState) {\n+                ensureSnapshotNameAvailableInRepo(repositoryData, snapshotName, repository);\n+                ensureNoCleanupInProgress(currentState, repositoryName, snapshotName);\n+                final SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE, SnapshotsInProgress.EMPTY);\n+                final List<SnapshotsInProgress.Entry> runningSnapshots = snapshots.entries();\n+                ensureSnapshotNameNotRunning(runningSnapshots, repositoryName, snapshotName);\n+                validate(repositoryName, snapshotName, currentState);\n+\n+                final SnapshotId sourceSnapshotId = repositoryData.getSnapshotIds()\n+                        .stream()\n+                        .filter(src -> src.getName().equals(request.source()))\n+                        .findAny()\n+                        .orElseThrow(() -> new SnapshotMissingException(repositoryName, request.source()));\n+                final SnapshotDeletionsInProgress deletionsInProgress =\n+                        currentState.custom(SnapshotDeletionsInProgress.TYPE, SnapshotDeletionsInProgress.EMPTY);\n+                if (deletionsInProgress.getEntries().stream().anyMatch(entry -> entry.getSnapshots().contains(sourceSnapshotId))) {\n+                    throw new ConcurrentSnapshotExecutionException(repositoryName, sourceSnapshotId.getName(),\n+                            \"cannot clone from snapshot that is being deleted\");\n+                }\n+                ensureBelowConcurrencyLimit(repositoryName, snapshotName, snapshots, deletionsInProgress);\n+                final List<String> indicesForSnapshot = new ArrayList<>();\n+                for (IndexId indexId : repositoryData.getIndices().values()) {\n+                    if (repositoryData.getSnapshots(indexId).contains(sourceSnapshotId)) {\n+                        indicesForSnapshot.add(indexId.getName());\n+                    }\n+                }\n+                final List<String> matchingIndices =\n+                        SnapshotUtils.filterIndices(indicesForSnapshot, request.indices(), request.indicesOptions());\n+                if (matchingIndices.isEmpty()) {\n+                    throw new SnapshotException(new Snapshot(repositoryName, sourceSnapshotId),\n+                            \"No indices in the source snapshot [\" + sourceSnapshotId + \"] matched requested pattern [\"\n+                                    + Strings.arrayToCommaDelimitedString(request.indices()) + \"]\");\n+                }\n+                newEntry = SnapshotsInProgress.startClone(\n+                        snapshot, sourceSnapshotId,\n+                        repositoryData.resolveIndices(matchingIndices),\n+                        threadPool.absoluteTimeInMillis(), repositoryData.getGenId(),\n+                        minCompatibleVersion(currentState.nodes().getMinNodeVersion(), repositoryData, null));\n+                final List<SnapshotsInProgress.Entry> newEntries = new ArrayList<>(runningSnapshots);\n+                newEntries.add(newEntry);\n+                return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE,\n+                        SnapshotsInProgress.of(List.copyOf(newEntries))).build();\n+            }\n+\n+            @Override\n+            public void onFailure(String source, Exception e) {\n+                initializingClones.remove(snapshot);\n+                logger.warn(() -> new ParameterizedMessage(\"[{}][{}] failed to clone snapshot\", repositoryName, snapshotName), e);\n+                listener.onFailure(e);\n+            }\n+\n+            @Override\n+            public void clusterStateProcessed(String source, ClusterState oldState, final ClusterState newState) {\n+                logger.info(\"snapshot clone [{}] started\", snapshot);\n+                addListener(snapshot, ActionListener.wrap(r -> listener.onResponse(null), listener::onFailure));\n+                startCloning(repository, newEntry);\n+            }\n+\n+            @Override\n+            public TimeValue timeout() {\n+                initializingClones.remove(snapshot);\n+                return request.masterNodeTimeout();\n+            }\n+        }, \"clone_snapshot [\" + request.source() + \"][\" + snapshotName + ']', listener::onFailure);\n+    }\n+\n+    private static void ensureNoCleanupInProgress(ClusterState currentState, String repositoryName, String snapshotName) {\n+        final RepositoryCleanupInProgress repositoryCleanupInProgress =\n+                currentState.custom(RepositoryCleanupInProgress.TYPE, RepositoryCleanupInProgress.EMPTY);\n+        if (repositoryCleanupInProgress.hasCleanupInProgress()) {\n+            throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName,\n+                    \"cannot snapshot while a repository cleanup is in-progress in [\" + repositoryCleanupInProgress + \"]\");\n+        }\n+    }\n+\n+    private static void ensureSnapshotNameAvailableInRepo(RepositoryData repositoryData, String snapshotName, Repository repository) {\n+        // check if the snapshot name already exists in the repository\n+        if (repositoryData.getSnapshotIds().stream().anyMatch(s -> s.getName().equals(snapshotName))) {\n+            throw new InvalidSnapshotNameException(\n+                    repository.getMetadata().name(), snapshotName, \"snapshot with the same name already exists\");\n+        }\n+    }\n+\n+    /**\n+     * Determine the number of shards in each index of a clone operation and update the cluster state accordingly.\n+     *\n+     * @param repository     repository to run operation on\n+     * @param cloneEntry     clone operation in the cluster state\n+     */\n+    private void startCloning(Repository repository, SnapshotsInProgress.Entry cloneEntry) {\n+        final List<IndexId> indices = cloneEntry.indices();\n+        final SnapshotId sourceSnapshot = cloneEntry.source();\n+        final Snapshot targetSnapshot = cloneEntry.snapshot();\n+\n+        final Executor executor = threadPool.executor(ThreadPool.Names.SNAPSHOT);\n+        // Exception handler for IO exceptions with loading index and repo metadata\n+        final Consumer<Exception> onFailure = e -> {\n+            initializingClones.remove(targetSnapshot);\n+            logger.info(() -> new ParameterizedMessage(\"Failed to start snapshot clone [{}]\", cloneEntry), e);\n+            removeFailedSnapshotFromClusterState(targetSnapshot, e, null);\n+        };\n+\n+        // 1. step, load SnapshotInfo to make sure that source snapshot was successful for the indices we want to clone\n+        // TODO: we could skip this step for snapshots with state SUCCESS\n+        final StepListener<SnapshotInfo> snapshotInfoListener = new StepListener<>();\n+        executor.execute(ActionRunnable.supply(snapshotInfoListener, () -> repository.getSnapshotInfo(sourceSnapshot)));\n+\n+        final StepListener<Collection<Tuple<IndexId, Integer>>> allShardCountsListener = new StepListener<>();\n+        final GroupedActionListener<Tuple<IndexId, Integer>> shardCountListener =\n+                new GroupedActionListener<>(allShardCountsListener, indices.size());\n+        snapshotInfoListener.whenComplete(snapshotInfo -> {\n+            for (IndexId indexId : indices) {\n+                if (RestoreService.failed(snapshotInfo, indexId.getName())) {\n+                    throw new SnapshotException(targetSnapshot, \"Can't clone index [\" + indexId +\n+                            \"] because its snapshot is was not successful.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e5b74bfcd431b1192f4aface3739f2026da8268"}, "originalPosition": 245}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c5f3bd5a452f2067aa8157914d50f01d61511fb7", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/c5f3bd5a452f2067aa8157914d50f01d61511fb7", "committedDate": "2020-10-02T13:43:47Z", "message": "Update server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java\n\nCo-authored-by: Tanguy Leroux <tlrx.dev@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2a5a226b0ecda994359a92c5ba0fe46b53c5900e", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/2a5a226b0ecda994359a92c5ba0fe46b53c5900e", "committedDate": "2020-10-02T14:21:58Z", "message": "Merge remote-tracking branch 'elastic/master' into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6ad35522fc9c75cf561be530d4ace8f8ae0efe0e", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/6ad35522fc9c75cf561be530d4ace8f8ae0efe0e", "committedDate": "2020-10-02T14:23:15Z", "message": "gotta fix message in tests as well"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "87d721e1a963912d17af7189c9728c190407617d", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/87d721e1a963912d17af7189c9728c190407617d", "committedDate": "2020-08-03T10:09:20Z", "message": "bck"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4ae31193d4db14540279cc76420a621eeb96134d", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/4ae31193d4db14540279cc76420a621eeb96134d", "committedDate": "2020-08-03T10:09:29Z", "message": "Merge remote-tracking branch 'elastic/master' into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d84264d479a95a53abf89e5601aa3d5fb3599975", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/d84264d479a95a53abf89e5601aa3d5fb3599975", "committedDate": "2020-08-03T16:41:12Z", "message": "Clone snapshot API start"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f6d287eb4fafdaf60818124589bdd9999ae46d07", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/f6d287eb4fafdaf60818124589bdd9999ae46d07", "committedDate": "2020-08-03T16:45:50Z", "message": "Merge remote-tracking branch 'elastic/master' into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "38da49aee9b2aa375f87766791eb86e45e9fee97", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/38da49aee9b2aa375f87766791eb86e45e9fee97", "committedDate": "2020-08-03T18:10:03Z", "message": "works"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "988490b657e1432e255ed224fdf75eb9293180ab", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/988490b657e1432e255ed224fdf75eb9293180ab", "committedDate": "2020-08-03T18:23:38Z", "message": "Merge remote-tracking branch 'elastic/master' into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b4be1f6f0dec850b4a28533a10492561568dc026", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/b4be1f6f0dec850b4a28533a10492561568dc026", "committedDate": "2020-08-03T18:33:22Z", "message": "r/w"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2e3fbccea3b3da0270077c2d4668766e9bf3234a", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/2e3fbccea3b3da0270077c2d4668766e9bf3234a", "committedDate": "2020-08-03T19:30:30Z", "message": "bck"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "28d6e9746e308bbc90d7e7cfa8cdb6647b36883d", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/28d6e9746e308bbc90d7e7cfa8cdb6647b36883d", "committedDate": "2020-08-04T10:25:19Z", "message": "Merge remote-tracking branch 'elastic/master' into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eb7b620304453a07ccfc64c3e68e64fecfe01fb6", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/eb7b620304453a07ccfc64c3e68e64fecfe01fb6", "committedDate": "2020-08-05T08:09:20Z", "message": "Merge remote-tracking branch 'elastic/master' into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cf5d19915c2d4e349f78d118edfabb5507fe67e4", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/cf5d19915c2d4e349f78d118edfabb5507fe67e4", "committedDate": "2020-08-05T08:37:06Z", "message": "fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bf0671f3637cdd52b9ce4a468f1b8a194e349a50", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/bf0671f3637cdd52b9ce4a468f1b8a194e349a50", "committedDate": "2020-08-05T12:07:08Z", "message": "Merge remote-tracking branch 'elastic/master' into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6a06ae8d08375d9ef79a51ca027e4229fa9eb25e", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/6a06ae8d08375d9ef79a51ca027e4229fa9eb25e", "committedDate": "2020-08-05T12:31:36Z", "message": "progress"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "789a07df787cc3da80c418e3359bdcadbb640114", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/789a07df787cc3da80c418e3359bdcadbb640114", "committedDate": "2020-08-05T16:46:09Z", "message": "bck"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9218b62f1754eefc693bb8690624614658dc03b6", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/9218b62f1754eefc693bb8690624614658dc03b6", "committedDate": "2020-08-06T12:15:28Z", "message": "Merge remote-tracking branch 'elastic/master' into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9647e44e5c73b7b427ff2cc8df66775e540d46ad", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/9647e44e5c73b7b427ff2cc8df66775e540d46ad", "committedDate": "2020-08-06T12:19:05Z", "message": "fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "41463b661bb4e8d185eb53144379c0492c3c2b10", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/41463b661bb4e8d185eb53144379c0492c3c2b10", "committedDate": "2020-08-10T11:23:26Z", "message": "Merge remote-tracking branch 'elastic/master' into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e140322007abf62cf6d37b63562323cd064e246b", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/e140322007abf62cf6d37b63562323cd064e246b", "committedDate": "2020-08-10T11:36:58Z", "message": "Merge remote-tracking branch 'elastic/master' into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ddbcb23283edfd5f5c2863dbb68fd57decda31db", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/ddbcb23283edfd5f5c2863dbb68fd57decda31db", "committedDate": "2020-08-11T09:50:02Z", "message": "Merge remote-tracking branch 'elastic/master' into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f662c4739647b353f34c7f7708cd965c0eab92b9", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/f662c4739647b353f34c7f7708cd965c0eab92b9", "committedDate": "2020-08-11T12:16:12Z", "message": "Merge remote-tracking branch 'elastic/master' into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e95a9e2a2df34231c56495b1ac7fbdf9115bf0f1", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/e95a9e2a2df34231c56495b1ac7fbdf9115bf0f1", "committedDate": "2020-08-11T13:27:11Z", "message": "bck"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bf6ec9625defb20facd82d82998f061fc594d28e", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/bf6ec9625defb20facd82d82998f061fc594d28e", "committedDate": "2020-08-11T13:35:26Z", "message": "Merge remote-tracking branch 'elastic/master' into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1c135969ee83f223cf1b8018ecd88a870e36713e", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/1c135969ee83f223cf1b8018ecd88a870e36713e", "committedDate": "2020-08-11T19:23:45Z", "message": "bck"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4d816e34834e5eac394170f018291cda294c4c7c", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/4d816e34834e5eac394170f018291cda294c4c7c", "committedDate": "2020-08-12T10:58:55Z", "message": "Merge remote-tracking branch 'elastic/master' into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e01a58e3af38ac579885aca3487f8324350010b7", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/e01a58e3af38ac579885aca3487f8324350010b7", "committedDate": "2020-08-12T14:20:57Z", "message": "bck"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c319448cc77efce4a9766e0585ae8de878b0bd04", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/c319448cc77efce4a9766e0585ae8de878b0bd04", "committedDate": "2020-08-30T16:20:41Z", "message": "bck"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4c754d127fe0330669ba30c13093f6258ce31107", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/4c754d127fe0330669ba30c13093f6258ce31107", "committedDate": "2020-08-30T16:59:59Z", "message": "bck"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fc3fd52e7ebfe1108a080b9eb74cdef0dee3c351", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/fc3fd52e7ebfe1108a080b9eb74cdef0dee3c351", "committedDate": "2020-08-30T19:56:49Z", "message": "Merge remote-tracking branch 'elastic/master' into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6d18df3116ba7feff71262e5613e56b02eb85965", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/6d18df3116ba7feff71262e5613e56b02eb85965", "committedDate": "2020-08-31T08:37:40Z", "message": "Merge remote-tracking branch 'elastic/master' into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "617ee9bbbbb48fcb6f3ccc92284e45c421b28cfd", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/617ee9bbbbb48fcb6f3ccc92284e45c421b28cfd", "committedDate": "2020-08-31T12:55:25Z", "message": "bck"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c1d9e9350ac8fd5d125832948ab7cc2bc0343dd6", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/c1d9e9350ac8fd5d125832948ab7cc2bc0343dd6", "committedDate": "2020-08-31T13:54:44Z", "message": "bck"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5a9ce25a6ffa0f9aa535ef1ed8c33e10424260c6", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/5a9ce25a6ffa0f9aa535ef1ed8c33e10424260c6", "committedDate": "2020-08-31T13:54:54Z", "message": "Merge remote-tracking branch 'elastic/master' into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7b527223acdaf3f1d48efb0e08ed5284020a68b3", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/7b527223acdaf3f1d48efb0e08ed5284020a68b3", "committedDate": "2020-08-31T14:09:09Z", "message": "bck"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "214901f666a38c7f79015f894064d9b82ab087d9", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/214901f666a38c7f79015f894064d9b82ab087d9", "committedDate": "2020-08-31T15:16:54Z", "message": "worksish"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5b14bd42c4ebd2b63bd0bc20af8d7541407d0f94", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/5b14bd42c4ebd2b63bd0bc20af8d7541407d0f94", "committedDate": "2020-08-31T16:04:24Z", "message": "bck"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c1253489501d60f2bac68c90d3c9ee716eb0fb1e", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/c1253489501d60f2bac68c90d3c9ee716eb0fb1e", "committedDate": "2020-08-31T16:12:01Z", "message": "bck"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a56e8262c63c70d864f4e76ace893c7ba7044def", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/a56e8262c63c70d864f4e76ace893c7ba7044def", "committedDate": "2020-08-31T16:13:43Z", "message": "bck"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bdac60a9797c393092ef7ddf2b86e2b183ebf9e5", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/bdac60a9797c393092ef7ddf2b86e2b183ebf9e5", "committedDate": "2020-08-31T17:09:33Z", "message": "bck"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "82808e560f1e0a84ebeaaca654027eae7a2608de", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/82808e560f1e0a84ebeaaca654027eae7a2608de", "committedDate": "2020-08-31T18:15:37Z", "message": "better"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "95638b21548a038ef7206d58e81d483500956047", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/95638b21548a038ef7206d58e81d483500956047", "committedDate": "2020-08-31T18:58:45Z", "message": "bck"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "862e8ca5bab7eaec7aec64fbd1f6fd7ff76dc34f", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/862e8ca5bab7eaec7aec64fbd1f6fd7ff76dc34f", "committedDate": "2020-08-31T21:17:59Z", "message": "green"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c882c9f9ac56020cccadb9c622a30751a723b6af", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/c882c9f9ac56020cccadb9c622a30751a723b6af", "committedDate": "2020-09-01T08:42:06Z", "message": "Merge remote-tracking branch 'elastic/master' into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8494701bf0ec0ed062be997f4dae38702b5ff09c", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/8494701bf0ec0ed062be997f4dae38702b5ff09c", "committedDate": "2020-09-01T09:22:23Z", "message": "Merge remote-tracking branch 'elastic/master' into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "19e6e7b293434885a23e2956d64c9cd5f0af6c95", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/19e6e7b293434885a23e2956d64c9cd5f0af6c95", "committedDate": "2020-09-01T10:25:14Z", "message": "Merge remote-tracking branch 'elastic/master' into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ecd821d438cca3b36bdc407a4abff2f45813d81c", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/ecd821d438cca3b36bdc407a4abff2f45813d81c", "committedDate": "2020-09-01T11:03:04Z", "message": "bck"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0eb072db5de4b57c0a4d52419962b44a4beaf09c", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/0eb072db5de4b57c0a4d52419962b44a4beaf09c", "committedDate": "2020-09-01T11:45:51Z", "message": "Merge remote-tracking branch 'elastic/master' into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8a74150b34159c59da76c16ec347a9250fb392ed", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/8a74150b34159c59da76c16ec347a9250fb392ed", "committedDate": "2020-09-01T12:56:35Z", "message": "bck"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ec4b1672f05e9cd8f2b93b6d4dbf6fbcef6a95e1", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/ec4b1672f05e9cd8f2b93b6d4dbf6fbcef6a95e1", "committedDate": "2020-09-01T12:56:43Z", "message": "Merge remote-tracking branch 'elastic/master' into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b1b950ef04f91febc50990fb0f409fc3fa6e7b11", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/b1b950ef04f91febc50990fb0f409fc3fa6e7b11", "committedDate": "2020-09-01T13:20:33Z", "message": "clone prevents delete"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2090a547a3e5bfa9c20db4e8f325d91045b4c9e0", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/2090a547a3e5bfa9c20db4e8f325d91045b4c9e0", "committedDate": "2020-09-01T13:49:25Z", "message": "delete prevents clone"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "24dfb6c6ddb15b9bb529d9cc15bfac0a89a04bc4", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/24dfb6c6ddb15b9bb529d9cc15bfac0a89a04bc4", "committedDate": "2020-09-01T15:22:54Z", "message": "bck"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "087f52288b42f5eafb2332892416f2c211000186", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/087f52288b42f5eafb2332892416f2c211000186", "committedDate": "2020-09-02T09:01:15Z", "message": "Merge remote-tracking branch 'elastic/master' into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e363042965810cfc1582cf1281c3085afe6468b8", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/e363042965810cfc1582cf1281c3085afe6468b8", "committedDate": "2020-09-02T10:11:57Z", "message": "bck"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4c6b0d5fb3335aead8472b2bb4652e8892f07379", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/4c6b0d5fb3335aead8472b2bb4652e8892f07379", "committedDate": "2020-09-02T10:14:26Z", "message": "cleanup rest action"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "daeb2fadd9aaf30b2fa83f3ce1d117700fd5c20c", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/daeb2fadd9aaf30b2fa83f3ce1d117700fd5c20c", "committedDate": "2020-09-02T10:33:03Z", "message": "shorter diff"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6999ea22e4a33e3e47374c02ec4948056a9be343", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/6999ea22e4a33e3e47374c02ec4948056a9be343", "committedDate": "2020-09-02T11:17:24Z", "message": "bck"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4658086fad03b4186d7595177a019681257be3ee", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/4658086fad03b4186d7595177a019681257be3ee", "committedDate": "2020-09-02T11:19:10Z", "message": "Merge remote-tracking branch 'elastic/master' into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "94ba717f068aedfdc3793cb713a2f0bde086e7cf", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/94ba717f068aedfdc3793cb713a2f0bde086e7cf", "committedDate": "2020-09-02T11:53:52Z", "message": "docs test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "96f2617292d9dca33630d28a879bb5fe5dae9bae", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/96f2617292d9dca33630d28a879bb5fe5dae9bae", "committedDate": "2020-09-02T12:21:42Z", "message": "one more case handled"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "09de3d62cfa96e1ff29504d765b1b99c2d71621a", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/09de3d62cfa96e1ff29504d765b1b99c2d71621a", "committedDate": "2020-09-02T13:04:36Z", "message": "error handling"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "33012dcdb51d4da857efc050e77d75a714151673", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/33012dcdb51d4da857efc050e77d75a714151673", "committedDate": "2020-09-02T14:54:16Z", "message": "Merge remote-tracking branch 'elastic/master' into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a50e50607986bcd3c1c0f3eca1564bc9135c5713", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/a50e50607986bcd3c1c0f3eca1564bc9135c5713", "committedDate": "2020-09-02T16:43:37Z", "message": "Merge remote-tracking branch 'elastic/master' into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d2c47f837f3c4a342b79790ce3ea901c9c4a571a", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/d2c47f837f3c4a342b79790ce3ea901c9c4a571a", "committedDate": "2020-09-02T19:50:03Z", "message": "Merge remote-tracking branch 'elastic/master' into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0f61e835bbdf9a531ddb20a9bf0cac97a6a18376", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/0f61e835bbdf9a531ddb20a9bf0cac97a6a18376", "committedDate": "2020-09-03T08:44:40Z", "message": "Merge remote-tracking branch 'elastic/master' into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9db152ff741cbcdbe6c8847be6b06a9e9b47c4e6", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/9db152ff741cbcdbe6c8847be6b06a9e9b47c4e6", "committedDate": "2020-09-03T11:51:15Z", "message": "more fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "10b3516a44be2b580b6f914db197b86b2352e2d3", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/10b3516a44be2b580b6f914db197b86b2352e2d3", "committedDate": "2020-09-03T14:01:30Z", "message": "last one?"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1cf9a6736759f977f315ad3d587d0fe66cc13329", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/1cf9a6736759f977f315ad3d587d0fe66cc13329", "committedDate": "2020-09-03T22:10:03Z", "message": "bck"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d9622265acd1a6be3e647eba9e90b5dc869d1f22", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/d9622265acd1a6be3e647eba9e90b5dc869d1f22", "committedDate": "2020-09-05T15:13:58Z", "message": "Merge remote-tracking branch 'elastic/master' into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e3dfef36055701697d2b0ccc811c93bad4377139", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/e3dfef36055701697d2b0ccc811c93bad4377139", "committedDate": "2020-09-07T13:23:43Z", "message": "Merge remote-tracking branch 'elastic/master' into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a06ee9d8bc18b8ede6e0a0668e95ba4d577ed4bc", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/a06ee9d8bc18b8ede6e0a0668e95ba4d577ed4bc", "committedDate": "2020-09-07T14:10:23Z", "message": "Merge remote-tracking branch 'elastic/master' into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a51f0a31d0f97570ed5aedddb16b5d3e554b58de", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/a51f0a31d0f97570ed5aedddb16b5d3e554b58de", "committedDate": "2020-09-07T15:00:18Z", "message": "fix state machine"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6f149f75a56942f2fffde94802721159a5e58d02", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/6f149f75a56942f2fffde94802721159a5e58d02", "committedDate": "2020-09-07T15:10:16Z", "message": "optimize"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "52020af79b65fb0589b103f3414ca7ca7e310cf7", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/52020af79b65fb0589b103f3414ca7ca7e310cf7", "committedDate": "2020-09-07T16:30:14Z", "message": "better not great"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8a8f98546a64ed428d002bffe8c01a3618f964ac", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/8a8f98546a64ed428d002bffe8c01a3618f964ac", "committedDate": "2020-09-10T14:30:16Z", "message": "Merge remote-tracking branch 'elastic/master' into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aab90773d4f5829aec0025a5a201d528248f4f94", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/aab90773d4f5829aec0025a5a201d528248f4f94", "committedDate": "2020-09-12T13:32:00Z", "message": "Merge remote-tracking branch 'elastic/master' into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "176fb7d89fa36bec990b73d515225948658a511c", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/176fb7d89fa36bec990b73d515225948658a511c", "committedDate": "2020-09-13T20:45:17Z", "message": "Merge remote-tracking branch 'elastic/master' into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5b7b795af272431e1eed23757c4e0ba99893c5f8", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/5b7b795af272431e1eed23757c4e0ba99893c5f8", "committedDate": "2020-09-14T05:24:31Z", "message": "mroe efficient"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b756cc256bf956a2ec77c16c42812dd4b1e6e0b8", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/b756cc256bf956a2ec77c16c42812dd4b1e6e0b8", "committedDate": "2020-09-14T05:42:57Z", "message": "fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0f71f8b83df7cf52f6730c23b7b7359b591f0865", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/0f71f8b83df7cf52f6730c23b7b7359b591f0865", "committedDate": "2020-09-14T08:25:09Z", "message": "Merge remote-tracking branch 'elastic/master' into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1059222c164d40b19b8012965274ee7a86a83984", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/1059222c164d40b19b8012965274ee7a86a83984", "committedDate": "2020-09-15T07:28:36Z", "message": "Merge remote-tracking branch 'elastic/master' into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b26c47c7ce344c66c79a28ddd5e82f01c8b2b112", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/b26c47c7ce344c66c79a28ddd5e82f01c8b2b112", "committedDate": "2020-09-15T09:08:11Z", "message": "fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "13d4b9850a57835de052f92c55944d4081887c40", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/13d4b9850a57835de052f92c55944d4081887c40", "committedDate": "2020-09-15T09:08:23Z", "message": "Merge remote-tracking branch 'elastic/master' into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ab787bd5fce822c221e788f6836b3788f739b476", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/ab787bd5fce822c221e788f6836b3788f739b476", "committedDate": "2020-09-15T10:46:14Z", "message": "Merge remote-tracking branch 'elastic/master' into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6bf7bc0cfe605f3d6a48dbc8181933ff9a43d863", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/6bf7bc0cfe605f3d6a48dbc8181933ff9a43d863", "committedDate": "2020-09-15T12:18:36Z", "message": "Merge remote-tracking branch 'elastic/master' into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1defbd5a6c29d927541ef61b5a69801f026a193d", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/1defbd5a6c29d927541ef61b5a69801f026a193d", "committedDate": "2020-09-15T12:39:29Z", "message": "Merge remote-tracking branch 'elastic/master' into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f7d2588e29f55b5246aee22b312a44e5b6240ae7", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/f7d2588e29f55b5246aee22b312a44e5b6240ae7", "committedDate": "2020-09-15T13:10:11Z", "message": "Merge remote-tracking branch 'elastic/master' into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "87e1c3da2c7316049f667ebc9c0cc632e56d7627", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/87e1c3da2c7316049f667ebc9c0cc632e56d7627", "committedDate": "2020-09-15T13:45:08Z", "message": "Merge branch 'master' of github.com:elastic/elasticsearch into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ad4d438af4eb2be491d2bdc95f40ffd8ffa2d0a8", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/ad4d438af4eb2be491d2bdc95f40ffd8ffa2d0a8", "committedDate": "2020-09-15T15:35:38Z", "message": "Merge remote-tracking branch 'elastic/master' into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f04e0d1ae04b971017bba1d09c0cc3a0875fb6f5", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/f04e0d1ae04b971017bba1d09c0cc3a0875fb6f5", "committedDate": "2020-09-16T11:57:49Z", "message": "Merge remote-tracking branch 'elastic/master' into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c0027c2418e04282c249ee9c4ff0e429b8b2e5bd", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/c0027c2418e04282c249ee9c4ff0e429b8b2e5bd", "committedDate": "2020-09-17T07:05:02Z", "message": "Merge remote-tracking branch 'elastic/master' into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d2dc4f8f1752a9559f68a88859d272580ab167d1", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/d2dc4f8f1752a9559f68a88859d272580ab167d1", "committedDate": "2020-09-17T09:33:26Z", "message": "reproducer"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "225cac01d30a69808fb9b1e79ff671cb00047901", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/225cac01d30a69808fb9b1e79ff671cb00047901", "committedDate": "2020-09-17T09:37:38Z", "message": "Merge remote-tracking branch 'elastic/master' into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "43242d8be70a96ec15a724e33f440ffa8c74bd39", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/43242d8be70a96ec15a724e33f440ffa8c74bd39", "committedDate": "2020-09-17T10:41:31Z", "message": "fix master failover part 1"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4f6eec8bf8b4cb6da1d36f6c40605ef03b1fdb0f", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/4f6eec8bf8b4cb6da1d36f6c40605ef03b1fdb0f", "committedDate": "2020-09-17T10:54:40Z", "message": "fix master failover part 2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c01ebbcf2d2871d87c406435555024061bb64df3", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/c01ebbcf2d2871d87c406435555024061bb64df3", "committedDate": "2020-09-17T11:27:38Z", "message": "nicer"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9c1d38ca2eb5c2643b964241a032001d9c722d09", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/9c1d38ca2eb5c2643b964241a032001d9c722d09", "committedDate": "2020-09-17T11:46:27Z", "message": "nicer"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c011f13d6448d092c132b34efdc1ceaf2dcd052b", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/c011f13d6448d092c132b34efdc1ceaf2dcd052b", "committedDate": "2020-09-17T11:47:59Z", "message": "cleaner"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "51bfc4a9cda6edc836955ee675d0469b5698dd8e", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/51bfc4a9cda6edc836955ee675d0469b5698dd8e", "committedDate": "2020-09-17T13:33:33Z", "message": "fix more edge cases"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cf5dc894348466815eb63682def637388c8e0c06", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/cf5dc894348466815eb63682def637388c8e0c06", "committedDate": "2020-09-17T14:12:29Z", "message": "Merge remote-tracking branch 'elastic/master' into clone-snapshot-on-repo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7eb9762190330f5043dc9bbcc230b3076bc7afc1", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/7eb9762190330f5043dc9bbcc230b3076bc7afc1", "committedDate": "2020-09-17T14:43:34Z", "message": "shorter"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4990, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}