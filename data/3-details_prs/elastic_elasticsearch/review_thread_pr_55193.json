{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAzNDkwMjQy", "number": 55193, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxMTowODozM1rODyBfkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxNjo1NDozOFrOD03IuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzc5ODU4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Concat.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxMTowODozM1rOGF0zaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNzoyODo1MlrOGGEIyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc2MTE5Mg==", "bodyText": "Why only isExact? Shouldn't this be a string only type of value?", "url": "https://github.com/elastic/elasticsearch/pull/55193#discussion_r408761192", "createdAt": "2020-04-15T11:08:33Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Concat.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ParamsBuilder;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.StringJoiner;\n+\n+import static org.elasticsearch.xpack.eql.expression.function.scalar.string.ConcatFunctionProcessor.doProcess;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isExact;\n+import static org.elasticsearch.xpack.ql.expression.gen.script.ParamsBuilder.paramsBuilder;\n+\n+/**\n+ * EQL specific concat function to build a string of all input arguments concatenated.\n+ */\n+public class Concat extends ScalarFunction {\n+\n+    private final List<Expression> values;\n+\n+    public Concat(Source source, List<Expression> values) {\n+        super(source, values);\n+        this.values = values;\n+    }\n+\n+    @Override\n+    protected TypeResolution resolveType() {\n+        if (!childrenResolved()) {\n+            return new TypeResolution(\"Unresolved children\");\n+        }\n+\n+        TypeResolution resolution = TypeResolution.TYPE_RESOLVED;\n+        int index = 0;\n+        for (Expression value : values) {\n+            resolution = isExact(value, sourceText(), ParamOrdinal.fromIndex(index));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bcc4033416bcb7954e024d5b12109ebd04a994e8"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc2MzI3NA==", "bodyText": "Also, this loop goes through all of concat's values and returns the resolution of the last element in list. Shouldn't, maybe, stop at the first resolution that is .unresolved() and return that?", "url": "https://github.com/elastic/elasticsearch/pull/55193#discussion_r408763274", "createdAt": "2020-04-15T11:12:47Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Concat.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ParamsBuilder;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.StringJoiner;\n+\n+import static org.elasticsearch.xpack.eql.expression.function.scalar.string.ConcatFunctionProcessor.doProcess;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isExact;\n+import static org.elasticsearch.xpack.ql.expression.gen.script.ParamsBuilder.paramsBuilder;\n+\n+/**\n+ * EQL specific concat function to build a string of all input arguments concatenated.\n+ */\n+public class Concat extends ScalarFunction {\n+\n+    private final List<Expression> values;\n+\n+    public Concat(Source source, List<Expression> values) {\n+        super(source, values);\n+        this.values = values;\n+    }\n+\n+    @Override\n+    protected TypeResolution resolveType() {\n+        if (!childrenResolved()) {\n+            return new TypeResolution(\"Unresolved children\");\n+        }\n+\n+        TypeResolution resolution = TypeResolution.TYPE_RESOLVED;\n+        int index = 0;\n+        for (Expression value : values) {\n+            resolution = isExact(value, sourceText(), ParamOrdinal.fromIndex(index));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc2MTE5Mg=="}, "originalCommit": {"oid": "bcc4033416bcb7954e024d5b12109ebd04a994e8"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAxMTMwNA==", "bodyText": "fixed in 9295e79", "url": "https://github.com/elastic/elasticsearch/pull/55193#discussion_r409011304", "createdAt": "2020-04-15T17:27:05Z", "author": {"login": "rw-access"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Concat.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ParamsBuilder;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.StringJoiner;\n+\n+import static org.elasticsearch.xpack.eql.expression.function.scalar.string.ConcatFunctionProcessor.doProcess;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isExact;\n+import static org.elasticsearch.xpack.ql.expression.gen.script.ParamsBuilder.paramsBuilder;\n+\n+/**\n+ * EQL specific concat function to build a string of all input arguments concatenated.\n+ */\n+public class Concat extends ScalarFunction {\n+\n+    private final List<Expression> values;\n+\n+    public Concat(Source source, List<Expression> values) {\n+        super(source, values);\n+        this.values = values;\n+    }\n+\n+    @Override\n+    protected TypeResolution resolveType() {\n+        if (!childrenResolved()) {\n+            return new TypeResolution(\"Unresolved children\");\n+        }\n+\n+        TypeResolution resolution = TypeResolution.TYPE_RESOLVED;\n+        int index = 0;\n+        for (Expression value : values) {\n+            resolution = isExact(value, sourceText(), ParamOrdinal.fromIndex(index));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc2MTE5Mg=="}, "originalCommit": {"oid": "bcc4033416bcb7954e024d5b12109ebd04a994e8"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAxMjQyNQ==", "bodyText": "also, this accepts non string parameters as well, and calls .toString() on them\nthe example uses pid which is a long\nhttps://eql.readthedocs.io/en/latest/query-guide/functions.html#concat", "url": "https://github.com/elastic/elasticsearch/pull/55193#discussion_r409012425", "createdAt": "2020-04-15T17:28:52Z", "author": {"login": "rw-access"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Concat.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ParamsBuilder;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.StringJoiner;\n+\n+import static org.elasticsearch.xpack.eql.expression.function.scalar.string.ConcatFunctionProcessor.doProcess;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isExact;\n+import static org.elasticsearch.xpack.ql.expression.gen.script.ParamsBuilder.paramsBuilder;\n+\n+/**\n+ * EQL specific concat function to build a string of all input arguments concatenated.\n+ */\n+public class Concat extends ScalarFunction {\n+\n+    private final List<Expression> values;\n+\n+    public Concat(Source source, List<Expression> values) {\n+        super(source, values);\n+        this.values = values;\n+    }\n+\n+    @Override\n+    protected TypeResolution resolveType() {\n+        if (!childrenResolved()) {\n+            return new TypeResolution(\"Unresolved children\");\n+        }\n+\n+        TypeResolution resolution = TypeResolution.TYPE_RESOLVED;\n+        int index = 0;\n+        for (Expression value : values) {\n+            resolution = isExact(value, sourceText(), ParamOrdinal.fromIndex(index));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc2MTE5Mg=="}, "originalCommit": {"oid": "bcc4033416bcb7954e024d5b12109ebd04a994e8"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzgxODg1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/ConcatFunctionPipe.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxMToxNDo1NVrOGF1ACA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxMToxNDo1NVrOGF1ACA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc2NDQyNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for (Pipe v: values) {\n          \n          \n            \n                    for (Pipe v : values) {\n          \n      \n    \n    \n  \n\nAnd the same change throughout the rest of this function's classes. Thanks.", "url": "https://github.com/elastic/elasticsearch/pull/55193#discussion_r408764424", "createdAt": "2020-04-15T11:14:55Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/ConcatFunctionPipe.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.ql.execution.search.QlSourceBuilder;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class ConcatFunctionPipe extends Pipe {\n+\n+    private final List<Pipe> values;\n+\n+    public ConcatFunctionPipe(Source source, Expression expression, List<Pipe> values) {\n+        super(source, expression, values);\n+        this.values = values;\n+    }\n+\n+    @Override\n+    public final Pipe replaceChildren(List<Pipe> newChildren) {\n+        return new ConcatFunctionPipe(source(), expression(), newChildren);\n+    }\n+\n+    @Override\n+    public final Pipe resolveAttributes(AttributeResolver resolver) {\n+        List<Pipe> newValues = new ArrayList<>(values.size());\n+        for (Pipe v: values) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bcc4033416bcb7954e024d5b12109ebd04a994e8"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzgxOTQwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/ConcatFunctionPipe.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxMToxNTowOVrOGF1AeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxMToxNTowOVrOGF1AeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc2NDUzNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for (Pipe p: values) {\n          \n          \n            \n                    for (Pipe p : values) {", "url": "https://github.com/elastic/elasticsearch/pull/55193#discussion_r408764536", "createdAt": "2020-04-15T11:15:09Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/ConcatFunctionPipe.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.ql.execution.search.QlSourceBuilder;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class ConcatFunctionPipe extends Pipe {\n+\n+    private final List<Pipe> values;\n+\n+    public ConcatFunctionPipe(Source source, Expression expression, List<Pipe> values) {\n+        super(source, expression, values);\n+        this.values = values;\n+    }\n+\n+    @Override\n+    public final Pipe replaceChildren(List<Pipe> newChildren) {\n+        return new ConcatFunctionPipe(source(), expression(), newChildren);\n+    }\n+\n+    @Override\n+    public final Pipe resolveAttributes(AttributeResolver resolver) {\n+        List<Pipe> newValues = new ArrayList<>(values.size());\n+        for (Pipe v: values) {\n+            newValues.add(v.resolveAttributes(resolver));\n+        }\n+\n+        if (newValues == values) {\n+            return this;\n+        }\n+\n+        return replaceChildren(newValues);\n+    }\n+\n+    @Override\n+    public boolean supportedByAggsOnlyQuery() {\n+        for (Pipe p: values) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bcc4033416bcb7954e024d5b12109ebd04a994e8"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzgyMTYxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/qa/common/src/main/resources/test_queries_supported.toml", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxMToxNTo1NFrOGF1B2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxMTo1NjoyOVrOGGhweQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc2NDg4OQ==", "bodyText": "Please, add more integration tests here:\n\nwith one pattern only\nwith an empty string pattern among other patterns\nwith null patterns", "url": "https://github.com/elastic/elasticsearch/pull/55193#discussion_r408764889", "createdAt": "2020-04-15T11:15:54Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/eql/qa/common/src/main/resources/test_queries_supported.toml", "diffHunk": "@@ -14,6 +14,16 @@ query = '''\n file where between(file_path, \"dev\", \".json\", true) == \"\\\\TestLogs\\\\something\"\n '''\n \n+[[queries]]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bcc4033416bcb7954e024d5b12109ebd04a994e8"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ5NzcyMQ==", "bodyText": "With all nulls as well", "url": "https://github.com/elastic/elasticsearch/pull/55193#discussion_r409497721", "createdAt": "2020-04-16T11:56:29Z", "author": {"login": "matriv"}, "path": "x-pack/plugin/eql/qa/common/src/main/resources/test_queries_supported.toml", "diffHunk": "@@ -14,6 +14,16 @@ query = '''\n file where between(file_path, \"dev\", \".json\", true) == \"\\\\TestLogs\\\\something\"\n '''\n \n+[[queries]]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc2NDg4OQ=="}, "originalCommit": {"oid": "bcc4033416bcb7954e024d5b12109ebd04a994e8"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzgyMzkwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/ConcatFunctionPipe.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxMToxNjo0MFrOGF1DUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxMToxNjo0MFrOGF1DUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc2NTI2Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for (Pipe p: values) {\n          \n          \n            \n                    for (Pipe p : values) {", "url": "https://github.com/elastic/elasticsearch/pull/55193#discussion_r408765267", "createdAt": "2020-04-15T11:16:40Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/ConcatFunctionPipe.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.ql.execution.search.QlSourceBuilder;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class ConcatFunctionPipe extends Pipe {\n+\n+    private final List<Pipe> values;\n+\n+    public ConcatFunctionPipe(Source source, Expression expression, List<Pipe> values) {\n+        super(source, expression, values);\n+        this.values = values;\n+    }\n+\n+    @Override\n+    public final Pipe replaceChildren(List<Pipe> newChildren) {\n+        return new ConcatFunctionPipe(source(), expression(), newChildren);\n+    }\n+\n+    @Override\n+    public final Pipe resolveAttributes(AttributeResolver resolver) {\n+        List<Pipe> newValues = new ArrayList<>(values.size());\n+        for (Pipe v: values) {\n+            newValues.add(v.resolveAttributes(resolver));\n+        }\n+\n+        if (newValues == values) {\n+            return this;\n+        }\n+\n+        return replaceChildren(newValues);\n+    }\n+\n+    @Override\n+    public boolean supportedByAggsOnlyQuery() {\n+        for (Pipe p: values) {\n+            if (p.supportedByAggsOnlyQuery() == false) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean resolved() {\n+        for (Pipe p: values) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bcc4033416bcb7954e024d5b12109ebd04a994e8"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzgyNDcwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/ConcatFunctionPipe.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxMToxNjo1NlrOGF1D0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxMToxNjo1NlrOGF1D0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc2NTM5NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for (Pipe v: values) {\n          \n          \n            \n                    for (Pipe v : values) {", "url": "https://github.com/elastic/elasticsearch/pull/55193#discussion_r408765395", "createdAt": "2020-04-15T11:16:56Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/ConcatFunctionPipe.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.ql.execution.search.QlSourceBuilder;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class ConcatFunctionPipe extends Pipe {\n+\n+    private final List<Pipe> values;\n+\n+    public ConcatFunctionPipe(Source source, Expression expression, List<Pipe> values) {\n+        super(source, expression, values);\n+        this.values = values;\n+    }\n+\n+    @Override\n+    public final Pipe replaceChildren(List<Pipe> newChildren) {\n+        return new ConcatFunctionPipe(source(), expression(), newChildren);\n+    }\n+\n+    @Override\n+    public final Pipe resolveAttributes(AttributeResolver resolver) {\n+        List<Pipe> newValues = new ArrayList<>(values.size());\n+        for (Pipe v: values) {\n+            newValues.add(v.resolveAttributes(resolver));\n+        }\n+\n+        if (newValues == values) {\n+            return this;\n+        }\n+\n+        return replaceChildren(newValues);\n+    }\n+\n+    @Override\n+    public boolean supportedByAggsOnlyQuery() {\n+        for (Pipe p: values) {\n+            if (p.supportedByAggsOnlyQuery() == false) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean resolved() {\n+        for (Pipe p: values) {\n+            if (p.resolved() == false) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public final void collectFields(QlSourceBuilder sourceBuilder) {\n+        for (Pipe v: values) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bcc4033416bcb7954e024d5b12109ebd04a994e8"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NzU1ODk3OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/planner/QueryFolderFailTests.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxNjo1NDozOFrOGKAwhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxNjo1NDozOFrOGKAwhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE1MTM2Nw==", "bodyText": "Small improvement here: if it's possible for a one argument call to not use \"first\" in the error message, that would look more user friendly.\nAlso, I would like to see one or two tests where another argument different from the first doesn't fulfill the restriction.", "url": "https://github.com/elastic/elasticsearch/pull/55193#discussion_r413151367", "createdAt": "2020-04-22T16:54:38Z", "author": {"login": "astefan"}, "path": "x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/planner/QueryFolderFailTests.java", "diffHunk": "@@ -93,6 +93,14 @@ public void testCIDRMatchNonString() {\n                 \"line 1:15: argument of [cidrMatch(source_address, 12345)] must be [string], found value [12345] type [integer]\", msg);\n     }\n \n+    public void testConcatWithInexact() {\n+        VerificationException e = expectThrows(VerificationException.class,\n+            () -> plan(\"process where concat(plain_text)\"));\n+        String msg = e.getMessage();\n+        assertEquals(\"Found 1 problem\\nline 1:15: [concat(plain_text)] cannot operate on first argument field of data type \"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c28ee3496e907228c5835a08484c5bcfaa8e276"}, "originalPosition": 8}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1029, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}