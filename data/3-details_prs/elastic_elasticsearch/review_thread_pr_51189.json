{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY0NDYzOTQ3", "number": 51189, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQwNzo1MTowNlrODZHvZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQwNzo1NTozNVrODZHyzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NjY3ODE0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/index/shard/PrimaryReplicaSyncer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQwNzo1MTowNlrOFfVrNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQxNTo0NDozMFrOFfiYgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQwNTMwMw==", "bodyText": "readHistoryOperations used Math.max(0, startingSeqNo) as from. I wonder if we need to guard against SequenceNumbers.UNASSIGNED_SEQ_NO similarly here.", "url": "https://github.com/elastic/elasticsearch/pull/51189#discussion_r368405303", "createdAt": "2020-01-20T07:51:06Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/index/shard/PrimaryReplicaSyncer.java", "diffHunk": "@@ -91,9 +90,7 @@ public void resync(final IndexShard indexShard, final ActionListener<ResyncTask>\n             // Wrap translog snapshot to make it synchronized as it is accessed by different threads through SnapshotSender.\n             // Even though those calls are not concurrent, snapshot.next() uses non-synchronized state and is not multi-thread-compatible\n             // Also fail the resync early if the shard is shutting down\n-            snapshot = indexShard.getHistoryOperations(\"resync\",\n-                indexShard.indexSettings.isSoftDeleteEnabled() ? Engine.HistorySource.INDEX : Engine.HistorySource.TRANSLOG,\n-                startingSeqNo);\n+            snapshot = indexShard.newChangesSnapshot(\"resync\", startingSeqNo, Long.MAX_VALUE, false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "106b0d7789e150bda8077105e751033453c54b16"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODYxMzUwNg==", "bodyText": "I could not find the reason why we used Math.max(0, startingSeqNo). We should always have a valid global checkpoint here, then startingSeqNo should be non-negative. I added an assertion in ea8da99.", "url": "https://github.com/elastic/elasticsearch/pull/51189#discussion_r368613506", "createdAt": "2020-01-20T15:44:30Z", "author": {"login": "dnhatn"}, "path": "server/src/main/java/org/elasticsearch/index/shard/PrimaryReplicaSyncer.java", "diffHunk": "@@ -91,9 +90,7 @@ public void resync(final IndexShard indexShard, final ActionListener<ResyncTask>\n             // Wrap translog snapshot to make it synchronized as it is accessed by different threads through SnapshotSender.\n             // Even though those calls are not concurrent, snapshot.next() uses non-synchronized state and is not multi-thread-compatible\n             // Also fail the resync early if the shard is shutting down\n-            snapshot = indexShard.getHistoryOperations(\"resync\",\n-                indexShard.indexSettings.isSoftDeleteEnabled() ? Engine.HistorySource.INDEX : Engine.HistorySource.TRANSLOG,\n-                startingSeqNo);\n+            snapshot = indexShard.newChangesSnapshot(\"resync\", startingSeqNo, Long.MAX_VALUE, false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQwNTMwMw=="}, "originalCommit": {"oid": "106b0d7789e150bda8077105e751033453c54b16"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NjY4Njg3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/indices/recovery/RecoverySourceHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQwNzo1NTozNVrOFfVwbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQxNTo0NTozMlrOFfiaZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQwNjYzOQ==", "bodyText": "can startingSeqNo be `UNASSIGNED_SEQ_NO here?", "url": "https://github.com/elastic/elasticsearch/pull/51189#discussion_r368406639", "createdAt": "2020-01-20T07:55:35Z", "author": {"login": "ywelsch"}, "path": "server/src/main/java/org/elasticsearch/indices/recovery/RecoverySourceHandler.java", "diffHunk": "@@ -296,9 +286,8 @@ public void recoverToTarget(ActionListener<RecoveryResponse> listener) {\n                     shardId + \" initiating tracking of \" + request.targetAllocationId(), shard, cancellableThreads, logger);\n \n                 final long endingSeqNo = shard.seqNoStats().getMaxSeqNo();\n-                logger.trace(\"snapshot translog for recovery; current size is [{}]\",\n-                    shard.estimateNumberOfHistoryOperations(\"peer-recovery\", historySource, startingSeqNo));\n-                final Translog.Snapshot phase2Snapshot = shard.getHistoryOperations(\"peer-recovery\", historySource, startingSeqNo);\n+                logger.trace(\"snapshot for recovery; current size is [{}]\", estimateNumberOfHistoryOperations(startingSeqNo));\n+                final Translog.Snapshot phase2Snapshot = shard.newChangesSnapshot(\"peer-recovery\", startingSeqNo, Long.MAX_VALUE, false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "106b0d7789e150bda8077105e751033453c54b16"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODYxMzk4OQ==", "bodyText": "It should be non-negative. We assert it here: \n  \n    \n      elasticsearch/server/src/main/java/org/elasticsearch/indices/recovery/RecoverySourceHandler.java\n    \n    \n         Line 269\n      in\n      106b0d7\n    \n    \n    \n    \n\n        \n          \n           assert startingSeqNo >= 0 : \"startingSeqNo must be non negative. got: \" + startingSeqNo; \n        \n    \n  \n\n.", "url": "https://github.com/elastic/elasticsearch/pull/51189#discussion_r368613989", "createdAt": "2020-01-20T15:45:32Z", "author": {"login": "dnhatn"}, "path": "server/src/main/java/org/elasticsearch/indices/recovery/RecoverySourceHandler.java", "diffHunk": "@@ -296,9 +286,8 @@ public void recoverToTarget(ActionListener<RecoveryResponse> listener) {\n                     shardId + \" initiating tracking of \" + request.targetAllocationId(), shard, cancellableThreads, logger);\n \n                 final long endingSeqNo = shard.seqNoStats().getMaxSeqNo();\n-                logger.trace(\"snapshot translog for recovery; current size is [{}]\",\n-                    shard.estimateNumberOfHistoryOperations(\"peer-recovery\", historySource, startingSeqNo));\n-                final Translog.Snapshot phase2Snapshot = shard.getHistoryOperations(\"peer-recovery\", historySource, startingSeqNo);\n+                logger.trace(\"snapshot for recovery; current size is [{}]\", estimateNumberOfHistoryOperations(startingSeqNo));\n+                final Translog.Snapshot phase2Snapshot = shard.newChangesSnapshot(\"peer-recovery\", startingSeqNo, Long.MAX_VALUE, false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQwNjYzOQ=="}, "originalCommit": {"oid": "106b0d7789e150bda8077105e751033453c54b16"}, "originalPosition": 75}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4548, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}