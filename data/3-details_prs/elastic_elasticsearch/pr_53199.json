{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg0NTMyMDE1", "number": 53199, "title": "Simplify BucketedSort/Teach BitArray a useful trick", "bodyText": "Our lovely BitArray compactly stores \"flags\", lazilly growing its\nunderlying storage. It is super useful when you need to store one bit of\ndata for a zillion buckets or a documents or something. Usefully, it\ndefaults to false. But there is a wrinkle! If you ask it whether or\nnot a bit is set but it hasn't grown its underlying storage array\n\"around\" that index then it'll throw an ArrayIndexOutOfBoundsException.\nThe per-document use cases tend to show up in order and don't tend to\nmind this too much. But the use case in aggregations, the per-bucket use\ncase, does. Because buckets are collected out of order all the time.\nThis changes BitArray so it'll return false if the index is too big\nfor the underlying storage. After all, that index can't have been set\nor else we would have grown the underlying array. Logically, I believe\nthis makes sense. And it makes my life easy. At the cost of three lines.\nbut this adds an extra test to every call to get. I think this is\nlikely ok because it is \"very close\" to an array index lookup that\nalready runs the same test. So I think it'll end up merged with the\narray bounds check.", "createdAt": "2020-03-05T22:26:30Z", "url": "https://github.com/elastic/elasticsearch/pull/53199", "merged": true, "mergeCommit": {"oid": "d26faceae2d1e1c552d286f423b5a50085d95042"}, "closed": true, "closedAt": "2020-03-06T18:17:34Z", "author": {"login": "nik9000"}, "timelineItems": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcKyuHegH2gAyMzg0NTMyMDE1OjRmZmNjZTlhZGYwYTBiNmMwNWY4YjA2ZTgyZjg3ZGFjOTYyMTNhZTg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcK7JYLAFqTM3MDEyNjM4Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "4ffcce9adf0a0b6c05f8b06e82f87dac96213ae8", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/4ffcce9adf0a0b6c05f8b06e82f87dac96213ae8", "committedDate": "2020-03-05T21:50:57Z", "message": "Simplify BucketedSort\n\nOur lovely `BitArray` compactly stores \"flags\", lazilly growing its\nunderlying storage. It is super useful when you need to store one bit of\ndata for a zillion buckets or a documents or something. Usefully, it\ndefaults to `false`. But there is a wrinkle! If you ask it whether or\nnot a bit is set but it hasn't grown its underlying storage array\n\"around\" that index then it'll throw an `ArrayIndexOutOfBoundsException`.\nThe per-document use cases tend to show up in order and don't tend to\nmind this too much. But the use case in aggregations, the per-bucket use\ncase, does. Because buckets are collected out of order all the time.\n\nThis changes `BitArray` so it'll return `false` if the index is too big\nfor the underlying storage. After all, that index *can't* have been set\nor else we would have grown the underlying array. Logically, I believe\nthis makes sense. And it makes my life easy. At the cost of three lines.\n\n*but* this adds an extra test to every call to `get`. I think this is\nlikely ok because it is \"very close\" to an array index lookup that\nalready runs the same test. So I *think* it'll end up merged with the\narray bounds check."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwMTI2Mzg3", "url": "https://github.com/elastic/elasticsearch/pull/53199#pullrequestreview-370126387", "createdAt": "2020-03-06T07:31:09Z", "commit": {"oid": "4ffcce9adf0a0b6c05f8b06e82f87dac96213ae8"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwNzozMTowOVrOFyvXgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwNzozMzowMlrOFyvZ6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc0OTE4NA==", "bodyText": "That's a good catch. It feels more natural and robust to test BitArray size within the BitArray implementation than add it to the  calling methods (such as in BucketSort).\nWhen it comes to performance, we can't really say if this test affects some compiler optimization unless we test/benchmark it. Also, I wonder if this is faster or just catching the ArrayIndexOutOfBoundsException thrown by bits.get(wordNum) within the method and simply returning false. I know try/catch blocks can have performance impacts too.", "url": "https://github.com/elastic/elasticsearch/pull/53199#discussion_r388749184", "createdAt": "2020-03-06T07:31:09Z", "author": {"login": "csoulios"}, "path": "server/src/main/java/org/elasticsearch/common/util/BitArray.java", "diffHunk": "@@ -37,16 +37,32 @@ public BitArray(int initialSize, BigArrays bigArrays) {\n         this.bits = bigArrays.newLongArray(initialSize, true);\n     }\n \n+    /**\n+     * Set the {@code index}th bit.\n+     */\n     public void set(int index) {\n         fill(index, true);\n     }\n \n+    /**\n+     * Clear the {@code index}th bit.\n+     */\n     public void clear(int index) {\n         fill(index, false);\n     }\n \n+    /**\n+     * Is the {@code index}th bit set?\n+     */\n     public boolean get(int index) {\n         int wordNum = index >> 6;\n+        if (wordNum >= bits.size()) {\n+            /*\n+             * If the word is bigger than the array then it could *never* have\n+             * been set.\n+             */\n+            return false;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ffcce9adf0a0b6c05f8b06e82f87dac96213ae8"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc0OTgwMQ==", "bodyText": "I always appreciate it when I see some javadoc added \ud83d\udc4d", "url": "https://github.com/elastic/elasticsearch/pull/53199#discussion_r388749801", "createdAt": "2020-03-06T07:33:02Z", "author": {"login": "csoulios"}, "path": "server/src/main/java/org/elasticsearch/common/util/BitArray.java", "diffHunk": "@@ -37,16 +37,32 @@ public BitArray(int initialSize, BigArrays bigArrays) {\n         this.bits = bigArrays.newLongArray(initialSize, true);\n     }\n \n+    /**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ffcce9adf0a0b6c05f8b06e82f87dac96213ae8"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1823, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}