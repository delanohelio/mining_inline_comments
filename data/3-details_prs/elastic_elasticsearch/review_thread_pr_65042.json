{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIxMjQ0NjEw", "number": 65042, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxMToyMTozNFrOE5-Ipw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxNTozNzoxMlrOE6FGVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5MjIyMzExOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxMToyMTozNFrOH0wRdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxMzoyNjoyMVrOH00pgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA3ODkwMA==", "bodyText": "This is the only place where the clone is re-queued right? I was wondering if this could lead to starvation in some really bad scenarios, but I think that's not possible?", "url": "https://github.com/elastic/elasticsearch/pull/65042#discussion_r525078900", "createdAt": "2020-11-17T11:21:34Z", "author": {"login": "fcofdez"}, "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -476,25 +476,50 @@ public ClusterState execute(ClusterState currentState) {\n                 final String repoName = cloneEntry.repository();\n                 final ShardGenerations shardGenerations = repoData.shardGenerations();\n                 for (int i = 0; i < updatedEntries.size(); i++) {\n-                    if (cloneEntry.snapshot().equals(updatedEntries.get(i).snapshot())) {\n+                    final SnapshotsInProgress.Entry entry = updatedEntries.get(i);\n+                    if (cloneEntry.repository().equals(entry.repository()) == false) {\n+                        // different repo => just continue without modification\n+                        continue;\n+                    }\n+                    if (cloneEntry.snapshot().getSnapshotId().equals(entry.snapshot().getSnapshotId())) {\n                         final ImmutableOpenMap.Builder<RepositoryShardId, ShardSnapshotStatus> clonesBuilder =\n                                 ImmutableOpenMap.builder();\n-                        final InFlightShardSnapshotStates inFlightShardStates =\n-                            InFlightShardSnapshotStates.forRepo(repoName, snapshotsInProgress.entries());\n+                        final boolean readyToExecute = currentState.custom(\n+                                SnapshotDeletionsInProgress.TYPE, SnapshotDeletionsInProgress.EMPTY).getEntries().stream()\n+                                .noneMatch(e -> e.repository().equals(repoName) && e.state() == SnapshotDeletionsInProgress.State.STARTED);\n+                        final InFlightShardSnapshotStates inFlightShardStates;\n+                        if (readyToExecute) {\n+                            inFlightShardStates = InFlightShardSnapshotStates.forRepo(repoName, snapshotsInProgress.entries());\n+                        } else {\n+                            // no need to compute these, we'll mark all shards as queued anyway because we wait for the delete\n+                            inFlightShardStates = null;\n+                        }\n+                        boolean queuedShards = false;\n                         for (Tuple<IndexId, Integer> count : counts) {\n                             for (int shardId = 0; shardId < count.v2(); shardId++) {\n                                 final RepositoryShardId repoShardId = new RepositoryShardId(count.v1(), shardId);\n                                 final String indexName = repoShardId.indexName();\n-                                if (inFlightShardStates.isActive(indexName, shardId)) {\n+                                if (readyToExecute == false || inFlightShardStates.isActive(indexName, shardId)) {\n                                     clonesBuilder.put(repoShardId, ShardSnapshotStatus.UNASSIGNED_QUEUED);\n+                                    queuedShards = true;\n                                 } else {\n                                     clonesBuilder.put(repoShardId, new ShardSnapshotStatus(localNodeId,\n                                         inFlightShardStates.generationForShard(repoShardId.index(), shardId, shardGenerations)));\n                                 }\n                             }\n                         }\n                         updatedEntry = cloneEntry.withClones(clonesBuilder.build());\n-                        updatedEntries.set(i, updatedEntry);\n+                        if (queuedShards) {\n+                            // We queued up some shards based on the in-flight operations found in all snapshots for the current\n+                            // repository, so in order to make sure we don't set a shard to QUEUED before (as in before it in the\n+                            // `updatedEntries` list) one that is actively executing we just put it to the back of the list as if we had\n+                            // just created the entry\n+                            // TODO: If we could eventually drop the snapshot clone init phase we don't need this any longer\n+                            updatedEntries.remove(i);\n+                            updatedEntries.add(updatedEntry);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d57e5da3cf8466ff06584b89649cb19d88d16c9"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTE1MDU5NQ==", "bodyText": "This is the only place where the clone is re-queued right\n\nRight, we're only doing this here.\n\nI was wondering if this could lead to starvation in some really bad scenarios, but I think that's not possible?\n\nI think we're good here even in theory. We do all the shard count fetching on the SNAPSHOT pool and any operation that would keep adding more and more operations to the list so quickly that we never get our turn would have to do some work on the SNAPSHOT pool eventually so we're safe on that front :)", "url": "https://github.com/elastic/elasticsearch/pull/65042#discussion_r525150595", "createdAt": "2020-11-17T13:26:21Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -476,25 +476,50 @@ public ClusterState execute(ClusterState currentState) {\n                 final String repoName = cloneEntry.repository();\n                 final ShardGenerations shardGenerations = repoData.shardGenerations();\n                 for (int i = 0; i < updatedEntries.size(); i++) {\n-                    if (cloneEntry.snapshot().equals(updatedEntries.get(i).snapshot())) {\n+                    final SnapshotsInProgress.Entry entry = updatedEntries.get(i);\n+                    if (cloneEntry.repository().equals(entry.repository()) == false) {\n+                        // different repo => just continue without modification\n+                        continue;\n+                    }\n+                    if (cloneEntry.snapshot().getSnapshotId().equals(entry.snapshot().getSnapshotId())) {\n                         final ImmutableOpenMap.Builder<RepositoryShardId, ShardSnapshotStatus> clonesBuilder =\n                                 ImmutableOpenMap.builder();\n-                        final InFlightShardSnapshotStates inFlightShardStates =\n-                            InFlightShardSnapshotStates.forRepo(repoName, snapshotsInProgress.entries());\n+                        final boolean readyToExecute = currentState.custom(\n+                                SnapshotDeletionsInProgress.TYPE, SnapshotDeletionsInProgress.EMPTY).getEntries().stream()\n+                                .noneMatch(e -> e.repository().equals(repoName) && e.state() == SnapshotDeletionsInProgress.State.STARTED);\n+                        final InFlightShardSnapshotStates inFlightShardStates;\n+                        if (readyToExecute) {\n+                            inFlightShardStates = InFlightShardSnapshotStates.forRepo(repoName, snapshotsInProgress.entries());\n+                        } else {\n+                            // no need to compute these, we'll mark all shards as queued anyway because we wait for the delete\n+                            inFlightShardStates = null;\n+                        }\n+                        boolean queuedShards = false;\n                         for (Tuple<IndexId, Integer> count : counts) {\n                             for (int shardId = 0; shardId < count.v2(); shardId++) {\n                                 final RepositoryShardId repoShardId = new RepositoryShardId(count.v1(), shardId);\n                                 final String indexName = repoShardId.indexName();\n-                                if (inFlightShardStates.isActive(indexName, shardId)) {\n+                                if (readyToExecute == false || inFlightShardStates.isActive(indexName, shardId)) {\n                                     clonesBuilder.put(repoShardId, ShardSnapshotStatus.UNASSIGNED_QUEUED);\n+                                    queuedShards = true;\n                                 } else {\n                                     clonesBuilder.put(repoShardId, new ShardSnapshotStatus(localNodeId,\n                                         inFlightShardStates.generationForShard(repoShardId.index(), shardId, shardGenerations)));\n                                 }\n                             }\n                         }\n                         updatedEntry = cloneEntry.withClones(clonesBuilder.build());\n-                        updatedEntries.set(i, updatedEntry);\n+                        if (queuedShards) {\n+                            // We queued up some shards based on the in-flight operations found in all snapshots for the current\n+                            // repository, so in order to make sure we don't set a shard to QUEUED before (as in before it in the\n+                            // `updatedEntries` list) one that is actively executing we just put it to the back of the list as if we had\n+                            // just created the entry\n+                            // TODO: If we could eventually drop the snapshot clone init phase we don't need this any longer\n+                            updatedEntries.remove(i);\n+                            updatedEntries.add(updatedEntry);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA3ODkwMA=="}, "originalCommit": {"oid": "3d57e5da3cf8466ff06584b89649cb19d88d16c9"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5MjIyODY1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/cluster/SnapshotsInProgress.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxMToyMjo1NFrOH0wUtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxNToyMDoxNlrOH06BSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA3OTczNQ==", "bodyText": "Is this related to this pr?", "url": "https://github.com/elastic/elasticsearch/pull/65042#discussion_r525079735", "createdAt": "2020-11-17T11:22:54Z", "author": {"login": "fcofdez"}, "path": "server/src/main/java/org/elasticsearch/cluster/SnapshotsInProgress.java", "diffHunk": "@@ -471,6 +472,25 @@ public XContentBuilder toXContent(XContentBuilder builder, Params params) throws\n                 }\n             }\n             builder.endArray();\n+            if (isClone()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d57e5da3cf8466ff06584b89649cb19d88d16c9"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTE0OTMxMg==", "bodyText": "Sort of, it's of necessary to make assertion failure messages useful, that's where I noticed this was missing.", "url": "https://github.com/elastic/elasticsearch/pull/65042#discussion_r525149312", "createdAt": "2020-11-17T13:24:20Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/cluster/SnapshotsInProgress.java", "diffHunk": "@@ -471,6 +472,25 @@ public XContentBuilder toXContent(XContentBuilder builder, Params params) throws\n                 }\n             }\n             builder.endArray();\n+            if (isClone()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA3OTczNQ=="}, "originalCommit": {"oid": "3d57e5da3cf8466ff06584b89649cb19d88d16c9"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTIzODYwMg==", "bodyText": "That looks strange that Entry implements ToXContent just for rendering assertion error messages? I guess it's fine but I find it strange (and it should implement ToXContentObject)", "url": "https://github.com/elastic/elasticsearch/pull/65042#discussion_r525238602", "createdAt": "2020-11-17T15:20:16Z", "author": {"login": "tlrx"}, "path": "server/src/main/java/org/elasticsearch/cluster/SnapshotsInProgress.java", "diffHunk": "@@ -471,6 +472,25 @@ public XContentBuilder toXContent(XContentBuilder builder, Params params) throws\n                 }\n             }\n             builder.endArray();\n+            if (isClone()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA3OTczNQ=="}, "originalCommit": {"oid": "3d57e5da3cf8466ff06584b89649cb19d88d16c9"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5MjI0MTQxOnYy", "diffSide": "RIGHT", "path": "server/src/internalClusterTest/java/org/elasticsearch/snapshots/CloneSnapshotIT.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxMToyNjoyOFrOH0wchA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxMzoyMjo1MFrOH00g0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA4MTczMg==", "bodyText": "Maybe we could assert here that the shard snapshots are queued?", "url": "https://github.com/elastic/elasticsearch/pull/65042#discussion_r525081732", "createdAt": "2020-11-17T11:26:28Z", "author": {"login": "fcofdez"}, "path": "server/src/internalClusterTest/java/org/elasticsearch/snapshots/CloneSnapshotIT.java", "diffHunk": "@@ -571,6 +575,40 @@ public void testStartCloneWithSuccessfulShardSnapshotPendingFinalization() throw\n         assertEquals(getSnapshot(repoName, cloneName).state(), SnapshotState.SUCCESS);\n     }\n \n+    public void testStartCloneDuringRunningDelete() throws Exception {\n+        final String masterName = internalCluster().startMasterOnlyNode(LARGE_SNAPSHOT_POOL_SETTINGS);\n+        internalCluster().startDataOnlyNode();\n+        final String repoName = \"test-repo\";\n+        createRepository(repoName, \"mock\");\n+\n+        final String indexName = \"test-idx\";\n+        createIndexWithContent(indexName);\n+\n+        final String sourceSnapshot = \"source-snapshot\";\n+        createFullSnapshot(repoName, sourceSnapshot);\n+\n+        final List<String> snapshotNames = createNSnapshots(repoName, randomIntBetween(1, 5));\n+        blockMasterOnWriteIndexFile(repoName);\n+        final ActionFuture<AcknowledgedResponse> deleteFuture = startDeleteSnapshot(repoName, randomFrom(snapshotNames));\n+        waitForBlock(masterName, repoName);\n+        awaitNDeletionsInProgress(1);\n+\n+        final ActionFuture<AcknowledgedResponse> cloneFuture = startClone(repoName, sourceSnapshot, \"target-snapshot\", indexName);\n+        logger.info(\"--> waiting for snapshot clone to be fully initialized\");\n+        awaitClusterState(state -> {\n+            for (SnapshotsInProgress.Entry entry : state.custom(SnapshotsInProgress.TYPE, SnapshotsInProgress.EMPTY).entries()) {\n+                if (entry.clones().isEmpty() == false) {\n+                    assertEquals(sourceSnapshot, entry.source().getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d57e5da3cf8466ff06584b89649cb19d88d16c9"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTE0ODM2OQ==", "bodyText": "++ I added that now. Technically this is ensured by assertions we have on the cluster state in SnapshotsService but practically this makes the test a lot clearer in its intent :)", "url": "https://github.com/elastic/elasticsearch/pull/65042#discussion_r525148369", "createdAt": "2020-11-17T13:22:50Z", "author": {"login": "original-brownbear"}, "path": "server/src/internalClusterTest/java/org/elasticsearch/snapshots/CloneSnapshotIT.java", "diffHunk": "@@ -571,6 +575,40 @@ public void testStartCloneWithSuccessfulShardSnapshotPendingFinalization() throw\n         assertEquals(getSnapshot(repoName, cloneName).state(), SnapshotState.SUCCESS);\n     }\n \n+    public void testStartCloneDuringRunningDelete() throws Exception {\n+        final String masterName = internalCluster().startMasterOnlyNode(LARGE_SNAPSHOT_POOL_SETTINGS);\n+        internalCluster().startDataOnlyNode();\n+        final String repoName = \"test-repo\";\n+        createRepository(repoName, \"mock\");\n+\n+        final String indexName = \"test-idx\";\n+        createIndexWithContent(indexName);\n+\n+        final String sourceSnapshot = \"source-snapshot\";\n+        createFullSnapshot(repoName, sourceSnapshot);\n+\n+        final List<String> snapshotNames = createNSnapshots(repoName, randomIntBetween(1, 5));\n+        blockMasterOnWriteIndexFile(repoName);\n+        final ActionFuture<AcknowledgedResponse> deleteFuture = startDeleteSnapshot(repoName, randomFrom(snapshotNames));\n+        waitForBlock(masterName, repoName);\n+        awaitNDeletionsInProgress(1);\n+\n+        final ActionFuture<AcknowledgedResponse> cloneFuture = startClone(repoName, sourceSnapshot, \"target-snapshot\", indexName);\n+        logger.info(\"--> waiting for snapshot clone to be fully initialized\");\n+        awaitClusterState(state -> {\n+            for (SnapshotsInProgress.Entry entry : state.custom(SnapshotsInProgress.TYPE, SnapshotsInProgress.EMPTY).entries()) {\n+                if (entry.clones().isEmpty() == false) {\n+                    assertEquals(sourceSnapshot, entry.source().getName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA4MTczMg=="}, "originalCommit": {"oid": "3d57e5da3cf8466ff06584b89649cb19d88d16c9"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5MzI4MzA1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxNToyNjo0M1rOH06dcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxNTo1Nzo0N1rOH08T4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTI0NTgxMA==", "bodyText": "readyToExecute kind of lack of meaning, maybe startedSnapshotDeletion (+ anyMatch)?", "url": "https://github.com/elastic/elasticsearch/pull/65042#discussion_r525245810", "createdAt": "2020-11-17T15:26:43Z", "author": {"login": "tlrx"}, "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -476,25 +476,50 @@ public ClusterState execute(ClusterState currentState) {\n                 final String repoName = cloneEntry.repository();\n                 final ShardGenerations shardGenerations = repoData.shardGenerations();\n                 for (int i = 0; i < updatedEntries.size(); i++) {\n-                    if (cloneEntry.snapshot().equals(updatedEntries.get(i).snapshot())) {\n+                    final SnapshotsInProgress.Entry entry = updatedEntries.get(i);\n+                    if (cloneEntry.repository().equals(entry.repository()) == false) {\n+                        // different repo => just continue without modification\n+                        continue;\n+                    }\n+                    if (cloneEntry.snapshot().getSnapshotId().equals(entry.snapshot().getSnapshotId())) {\n                         final ImmutableOpenMap.Builder<RepositoryShardId, ShardSnapshotStatus> clonesBuilder =\n                                 ImmutableOpenMap.builder();\n-                        final InFlightShardSnapshotStates inFlightShardStates =\n-                            InFlightShardSnapshotStates.forRepo(repoName, snapshotsInProgress.entries());\n+                        final boolean readyToExecute = currentState.custom(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7b19344a1b1c239f6bbd5db749e43189e0efea8"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTI3NjEzMQ==", "bodyText": "++ this is 100% the better name, I'll leave it as is for a sec though so it's less confusing to review when drying things up (we use the same mechanics and var name in the normal snapshot shard assignments path ... and it's equally weird there in hindsight :))", "url": "https://github.com/elastic/elasticsearch/pull/65042#discussion_r525276131", "createdAt": "2020-11-17T15:57:47Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -476,25 +476,50 @@ public ClusterState execute(ClusterState currentState) {\n                 final String repoName = cloneEntry.repository();\n                 final ShardGenerations shardGenerations = repoData.shardGenerations();\n                 for (int i = 0; i < updatedEntries.size(); i++) {\n-                    if (cloneEntry.snapshot().equals(updatedEntries.get(i).snapshot())) {\n+                    final SnapshotsInProgress.Entry entry = updatedEntries.get(i);\n+                    if (cloneEntry.repository().equals(entry.repository()) == false) {\n+                        // different repo => just continue without modification\n+                        continue;\n+                    }\n+                    if (cloneEntry.snapshot().getSnapshotId().equals(entry.snapshot().getSnapshotId())) {\n                         final ImmutableOpenMap.Builder<RepositoryShardId, ShardSnapshotStatus> clonesBuilder =\n                                 ImmutableOpenMap.builder();\n-                        final InFlightShardSnapshotStates inFlightShardStates =\n-                            InFlightShardSnapshotStates.forRepo(repoName, snapshotsInProgress.entries());\n+                        final boolean readyToExecute = currentState.custom(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTI0NTgxMA=="}, "originalCommit": {"oid": "f7b19344a1b1c239f6bbd5db749e43189e0efea8"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5MzMwNTIzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxNToyOTowNVrOH06ryQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxNToyOTowNVrOH06ryQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTI0OTQ4MQ==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/elastic/elasticsearch/pull/65042#discussion_r525249481", "createdAt": "2020-11-17T15:29:05Z", "author": {"login": "tlrx"}, "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -797,11 +822,15 @@ private static boolean assertNoDanglingSnapshots(ClusterState state) {\n         final Set<String> reposSeen = new HashSet<>();\n         for (SnapshotsInProgress.Entry entry : snapshotsInProgress.entries()) {\n             if (reposSeen.add(entry.repository())) {\n-                for (ObjectCursor<ShardSnapshotStatus> value : entry.shards().values()) {\n+                for (ObjectCursor<ShardSnapshotStatus> value : (entry.isClone() ? entry.clones() : entry.shards()).values()) {\n                     if (value.value.equals(ShardSnapshotStatus.UNASSIGNED_QUEUED)) {\n                         assert reposWithRunningDelete.contains(entry.repository())\n                                 : \"Found shard snapshot waiting to be assigned in [\" + entry +\n                                 \"] but it is not blocked by any running delete\";\n+                    } else if (value.value.isActive()) {\n+                        assert reposWithRunningDelete.contains(entry.repository()) == false\n+                                : \"Found shard snapshot actively executing in [\" + entry +\n+                                \"] when it should be blocked by a running delete\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7b19344a1b1c239f6bbd5db749e43189e0efea8"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5MzM0MTkwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxNTozMzowN1rOH07DwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxNTozMzowN1rOH07DwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTI1NTYxNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        // Collect waiting shards that in entry that we can assign now that we are done with the deletion\n          \n          \n            \n                                        // Collect waiting shards from that entry that we can assign now that we are done with the deletion", "url": "https://github.com/elastic/elasticsearch/pull/65042#discussion_r525255617", "createdAt": "2020-11-17T15:33:07Z", "author": {"login": "tlrx"}, "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -1929,50 +1961,89 @@ private SnapshotsInProgress updatedSnapshotsInProgress(ClusterState currentState\n \n             // Keep track of shardIds that we started snapshots for as a result of removing this delete so we don't assign\n             // them to multiple snapshots by accident\n-            final Set<ShardId> reassignedShardIds = new HashSet<>();\n+            final Map<String, Set<Integer>> reassignedShardIds = new HashMap<>();\n \n             boolean changed = false;\n \n+            final String localNodeId = currentState.nodes().getLocalNodeId();\n             final String repoName = deleteEntry.repository();\n             // Computing the new assignments can be quite costly, only do it once below if actually needed\n             ImmutableOpenMap<ShardId, ShardSnapshotStatus> shardAssignments = null;\n+            InFlightShardSnapshotStates inFlightShardStates = null;\n             for (SnapshotsInProgress.Entry entry : snapshotsInProgress.entries()) {\n                 if (entry.repository().equals(repoName)) {\n                     if (entry.state().completed() == false) {\n-                        // Collect waiting shards that in entry that we can assign now that we are done with the deletion\n-                        final List<ShardId> canBeUpdated = new ArrayList<>();\n-                        for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> value : entry.shards()) {\n-                            if (value.value.equals(ShardSnapshotStatus.UNASSIGNED_QUEUED)\n-                                    && reassignedShardIds.contains(value.key) == false) {\n-                                canBeUpdated.add(value.key);\n+                        // TODO: dry up redundant computation and code between clone and non-clone case, in particular reuse\n+                        //  `inFlightShardStates` across both clone and standard snapshot code\n+                        if (entry.isClone()) {\n+                            // Collect waiting shards that in entry that we can assign now that we are done with the deletion", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7b19344a1b1c239f6bbd5db749e43189e0efea8"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5MzM1NjYxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxNTozNTo1MFrOH07NHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxNTo1NToyNFrOH08MZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTI1ODAxMw==", "bodyText": "Maybe evaluate canBeUpdated.isEmpty() first and then only compute readyToExecute if needed?", "url": "https://github.com/elastic/elasticsearch/pull/65042#discussion_r525258013", "createdAt": "2020-11-17T15:35:50Z", "author": {"login": "tlrx"}, "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -1929,50 +1961,89 @@ private SnapshotsInProgress updatedSnapshotsInProgress(ClusterState currentState\n \n             // Keep track of shardIds that we started snapshots for as a result of removing this delete so we don't assign\n             // them to multiple snapshots by accident\n-            final Set<ShardId> reassignedShardIds = new HashSet<>();\n+            final Map<String, Set<Integer>> reassignedShardIds = new HashMap<>();\n \n             boolean changed = false;\n \n+            final String localNodeId = currentState.nodes().getLocalNodeId();\n             final String repoName = deleteEntry.repository();\n             // Computing the new assignments can be quite costly, only do it once below if actually needed\n             ImmutableOpenMap<ShardId, ShardSnapshotStatus> shardAssignments = null;\n+            InFlightShardSnapshotStates inFlightShardStates = null;\n             for (SnapshotsInProgress.Entry entry : snapshotsInProgress.entries()) {\n                 if (entry.repository().equals(repoName)) {\n                     if (entry.state().completed() == false) {\n-                        // Collect waiting shards that in entry that we can assign now that we are done with the deletion\n-                        final List<ShardId> canBeUpdated = new ArrayList<>();\n-                        for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> value : entry.shards()) {\n-                            if (value.value.equals(ShardSnapshotStatus.UNASSIGNED_QUEUED)\n-                                    && reassignedShardIds.contains(value.key) == false) {\n-                                canBeUpdated.add(value.key);\n+                        // TODO: dry up redundant computation and code between clone and non-clone case, in particular reuse\n+                        //  `inFlightShardStates` across both clone and standard snapshot code\n+                        if (entry.isClone()) {\n+                            // Collect waiting shards that in entry that we can assign now that we are done with the deletion\n+                            final List<RepositoryShardId> canBeUpdated = new ArrayList<>();\n+                            for (ObjectObjectCursor<RepositoryShardId, ShardSnapshotStatus> value : entry.clones()) {\n+                                if (value.value.equals(ShardSnapshotStatus.UNASSIGNED_QUEUED)\n+                                        && alreadyReassigned(value.key.indexName(), value.key.shardId(), reassignedShardIds) == false) {\n+                                    canBeUpdated.add(value.key);\n+                                }\n+                            }\n+                            // TODO: the below logic is very similar to that in #startCloning and both could be dried up against each other\n+                            //       also the code for standard snapshots could make use of this breakout as well\n+                            final boolean readyToExecute = updatedDeletions.getEntries().stream().noneMatch(\n+                                    e -> e.repository().equals(repoName) && e.state() == SnapshotDeletionsInProgress.State.STARTED);\n+                            if (readyToExecute == false || canBeUpdated.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7b19344a1b1c239f6bbd5db749e43189e0efea8"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTI3NDIxNQ==", "bodyText": "++", "url": "https://github.com/elastic/elasticsearch/pull/65042#discussion_r525274215", "createdAt": "2020-11-17T15:55:24Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -1929,50 +1961,89 @@ private SnapshotsInProgress updatedSnapshotsInProgress(ClusterState currentState\n \n             // Keep track of shardIds that we started snapshots for as a result of removing this delete so we don't assign\n             // them to multiple snapshots by accident\n-            final Set<ShardId> reassignedShardIds = new HashSet<>();\n+            final Map<String, Set<Integer>> reassignedShardIds = new HashMap<>();\n \n             boolean changed = false;\n \n+            final String localNodeId = currentState.nodes().getLocalNodeId();\n             final String repoName = deleteEntry.repository();\n             // Computing the new assignments can be quite costly, only do it once below if actually needed\n             ImmutableOpenMap<ShardId, ShardSnapshotStatus> shardAssignments = null;\n+            InFlightShardSnapshotStates inFlightShardStates = null;\n             for (SnapshotsInProgress.Entry entry : snapshotsInProgress.entries()) {\n                 if (entry.repository().equals(repoName)) {\n                     if (entry.state().completed() == false) {\n-                        // Collect waiting shards that in entry that we can assign now that we are done with the deletion\n-                        final List<ShardId> canBeUpdated = new ArrayList<>();\n-                        for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> value : entry.shards()) {\n-                            if (value.value.equals(ShardSnapshotStatus.UNASSIGNED_QUEUED)\n-                                    && reassignedShardIds.contains(value.key) == false) {\n-                                canBeUpdated.add(value.key);\n+                        // TODO: dry up redundant computation and code between clone and non-clone case, in particular reuse\n+                        //  `inFlightShardStates` across both clone and standard snapshot code\n+                        if (entry.isClone()) {\n+                            // Collect waiting shards that in entry that we can assign now that we are done with the deletion\n+                            final List<RepositoryShardId> canBeUpdated = new ArrayList<>();\n+                            for (ObjectObjectCursor<RepositoryShardId, ShardSnapshotStatus> value : entry.clones()) {\n+                                if (value.value.equals(ShardSnapshotStatus.UNASSIGNED_QUEUED)\n+                                        && alreadyReassigned(value.key.indexName(), value.key.shardId(), reassignedShardIds) == false) {\n+                                    canBeUpdated.add(value.key);\n+                                }\n+                            }\n+                            // TODO: the below logic is very similar to that in #startCloning and both could be dried up against each other\n+                            //       also the code for standard snapshots could make use of this breakout as well\n+                            final boolean readyToExecute = updatedDeletions.getEntries().stream().noneMatch(\n+                                    e -> e.repository().equals(repoName) && e.state() == SnapshotDeletionsInProgress.State.STARTED);\n+                            if (readyToExecute == false || canBeUpdated.isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTI1ODAxMw=="}, "originalCommit": {"oid": "f7b19344a1b1c239f6bbd5db749e43189e0efea8"}, "originalPosition": 121}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5MzM2NDA3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxNTozNzoxMlrOH07RvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxNjowMTozM1rOH08gGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTI1OTE5Ng==", "bodyText": "Maybe add some message in case it occurs in tests?", "url": "https://github.com/elastic/elasticsearch/pull/65042#discussion_r525259196", "createdAt": "2020-11-17T15:37:12Z", "author": {"login": "tlrx"}, "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -1987,6 +2058,15 @@ private SnapshotsInProgress updatedSnapshotsInProgress(ClusterState currentState\n             }\n             return changed ? SnapshotsInProgress.of(snapshotEntries) : null;\n         }\n+\n+        private void markShardReassigned(String indexName, int shardId, Map<String, Set<Integer>> reassignments) {\n+            final boolean added = reassignments.computeIfAbsent(indexName, k -> new HashSet<>()).add(shardId);\n+            assert added;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7b19344a1b1c239f6bbd5db749e43189e0efea8"}, "originalPosition": 210}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTI3OTI1Nw==", "bodyText": "++", "url": "https://github.com/elastic/elasticsearch/pull/65042#discussion_r525279257", "createdAt": "2020-11-17T16:01:33Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -1987,6 +2058,15 @@ private SnapshotsInProgress updatedSnapshotsInProgress(ClusterState currentState\n             }\n             return changed ? SnapshotsInProgress.of(snapshotEntries) : null;\n         }\n+\n+        private void markShardReassigned(String indexName, int shardId, Map<String, Set<Integer>> reassignments) {\n+            final boolean added = reassignments.computeIfAbsent(indexName, k -> new HashSet<>()).add(shardId);\n+            assert added;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTI1OTE5Ng=="}, "originalCommit": {"oid": "f7b19344a1b1c239f6bbd5db749e43189e0efea8"}, "originalPosition": 210}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3016, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}