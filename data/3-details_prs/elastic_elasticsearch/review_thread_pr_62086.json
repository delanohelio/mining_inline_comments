{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDgxOTU3OTY3", "number": 62086, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMTozNTo0NlrOEjFU_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxMjoxNjoyNlrOEnA4Yg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MjIyOTA5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/transform/qa/multi-node-tests/src/javaRestTest/java/org/elasticsearch/xpack/transform/integration/TransformIntegTestCase.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMTozNTo0NlrOHRPpyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMTozNTo0NlrOHRPpyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg0NDI5OQ==", "bodyText": "for loop could be used here as well, making this snippet more concise:\nfor (int retries = 10; retries > 0; --retries) {\n}", "url": "https://github.com/elastic/elasticsearch/pull/62086#discussion_r487844299", "createdAt": "2020-09-14T11:35:46Z", "author": {"login": "przemekwitek"}, "path": "x-pack/plugin/transform/qa/multi-node-tests/src/javaRestTest/java/org/elasticsearch/xpack/transform/integration/TransformIntegTestCase.java", "diffHunk": "@@ -140,6 +142,26 @@ protected StartTransformResponse startTransform(String id, RequestOptions option\n         }\n     }\n \n+    // workaround for https://github.com/elastic/elasticsearch/issues/62204\n+    protected StartTransformResponse startTransformWithRetryOnConflict(String id, RequestOptions options) throws Exception {\n+        int retries = 10;\n+        ElasticsearchStatusException lastConflict = null;\n+        while (retries > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f77dacfa489eba7bb70d76eab916b02919244e9"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MjIzNDEyOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/transform/qa/multi-node-tests/src/javaRestTest/java/org/elasticsearch/xpack/transform/integration/TransformIntegTestCase.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMTozNzoyNVrOHRPs4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMTozNzoyNVrOHRPs4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg0NTA4OQ==", "bodyText": "[nit] It's rather style issue, not a real problem here, but I would write this line:\n                if (RestStatus.CONFLICT.equals(e.status()) == false) {\n\nso that NPE is impossible (even theoretically).", "url": "https://github.com/elastic/elasticsearch/pull/62086#discussion_r487845089", "createdAt": "2020-09-14T11:37:25Z", "author": {"login": "przemekwitek"}, "path": "x-pack/plugin/transform/qa/multi-node-tests/src/javaRestTest/java/org/elasticsearch/xpack/transform/integration/TransformIntegTestCase.java", "diffHunk": "@@ -140,6 +142,26 @@ protected StartTransformResponse startTransform(String id, RequestOptions option\n         }\n     }\n \n+    // workaround for https://github.com/elastic/elasticsearch/issues/62204\n+    protected StartTransformResponse startTransformWithRetryOnConflict(String id, RequestOptions options) throws Exception {\n+        int retries = 10;\n+        ElasticsearchStatusException lastConflict = null;\n+        while (retries > 0) {\n+            try (RestHighLevelClient restClient = new TestRestHighLevelClient()) {\n+                return restClient.transform().startTransform(new StartTransformRequest(id), options);\n+            } catch (ElasticsearchStatusException e) {\n+                if (e.status().equals(RestStatus.CONFLICT) == false) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f77dacfa489eba7bb70d76eab916b02919244e9"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MjI0MTg4OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMTozOTo1NVrOHRPxlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMTozOTo1NVrOHRPxlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg0NjI5Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * can overwrite this, to provide a better logic, when state should be saved.\n          \n          \n            \n                 * can override this, to provide a better logic, when state should be saved.", "url": "https://github.com/elastic/elasticsearch/pull/62086#discussion_r487846293", "createdAt": "2020-09-14T11:39:55Z", "author": {"login": "przemekwitek"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexer.java", "diffHunk": "@@ -244,6 +244,17 @@ public synchronized boolean maybeTriggerAsyncJob(long now) {\n         }\n     }\n \n+    /**\n+     * Checks if the state should be persisted, if true doSaveState is called before continuing. Inherited classes\n+     * can overwrite this, to provide a better logic, when state should be saved.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f77dacfa489eba7bb70d76eab916b02919244e9"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MjI0NTE5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMTo0MDo1N1rOHRPzng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMTo0MDo1N1rOHRPzng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg0NjgxNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                protected void runSearchImmediatly() {\n          \n          \n            \n                protected void runSearchImmediately() {", "url": "https://github.com/elastic/elasticsearch/pull/62086#discussion_r487846814", "createdAt": "2020-09-14T11:40:57Z", "author": {"login": "przemekwitek"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexer.java", "diffHunk": "@@ -254,7 +265,16 @@ protected void rethrottle() {\n             return;\n         }\n \n-        reQueueThrottledSearch();\n+        reQueueThrottledSearch(false);\n+    }\n+\n+    /**\n+     * Re-schedules the current search request to run immediately, iff one is scheduled.\n+     *\n+     * Call this if you need the indexer to fast forward a scheduled(throttled) search once in order to complete a full cycle.\n+     */\n+    protected void runSearchImmediatly() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f77dacfa489eba7bb70d76eab916b02919244e9"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MjI0NTczOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMTo0MTowOFrOHRPz7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMTo0MTowOFrOHRPz7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg0Njg5NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Call this if you need the indexer to fast forward a scheduled(throttled) search once in order to complete a full cycle.\n          \n          \n            \n                 * Call this if you need the indexer to fast forward a scheduled (throttled) search once in order to complete a full cycle.", "url": "https://github.com/elastic/elasticsearch/pull/62086#discussion_r487846895", "createdAt": "2020-09-14T11:41:08Z", "author": {"login": "przemekwitek"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexer.java", "diffHunk": "@@ -254,7 +265,16 @@ protected void rethrottle() {\n             return;\n         }\n \n-        reQueueThrottledSearch();\n+        reQueueThrottledSearch(false);\n+    }\n+\n+    /**\n+     * Re-schedules the current search request to run immediately, iff one is scheduled.\n+     *\n+     * Call this if you need the indexer to fast forward a scheduled(throttled) search once in order to complete a full cycle.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f77dacfa489eba7bb70d76eab916b02919244e9"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MjM4MjgwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/TransformTask.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjoyMTowN1rOHRRGLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxMjowODozNlrOHV23Ag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg2Nzk0OQ==", "bodyText": "Since this is no longer synchronized, it is possible for a stop call or a start call to be executing at any point.\nIs this acceptable?", "url": "https://github.com/elastic/elasticsearch/pull/62086#discussion_r487867949", "createdAt": "2020-09-14T12:21:07Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/TransformTask.java", "diffHunk": "@@ -299,7 +295,7 @@ void setShouldStopAtCheckpoint(boolean shouldStopAtCheckpoint) {\n      * @param shouldStopAtCheckpoint whether or not we should stop at the next checkpoint or not\n      * @param shouldStopAtCheckpointListener the listener to return to when we have persisted the updated value to the state index.\n      */\n-    public synchronized void setShouldStopAtCheckpoint(\n+    public void setShouldStopAtCheckpoint(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f77dacfa489eba7bb70d76eab916b02919244e9"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk5NTMzNQ==", "bodyText": "with the atomic ops in stopAtCheckpoint, I think we can get rid of synchronized. I can not think of any bad collision with stop and start.", "url": "https://github.com/elastic/elasticsearch/pull/62086#discussion_r487995335", "createdAt": "2020-09-14T14:53:15Z", "author": {"login": "hendrikmuhs"}, "path": "x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/TransformTask.java", "diffHunk": "@@ -299,7 +295,7 @@ void setShouldStopAtCheckpoint(boolean shouldStopAtCheckpoint) {\n      * @param shouldStopAtCheckpoint whether or not we should stop at the next checkpoint or not\n      * @param shouldStopAtCheckpointListener the listener to return to when we have persisted the updated value to the state index.\n      */\n-    public synchronized void setShouldStopAtCheckpoint(\n+    public void setShouldStopAtCheckpoint(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg2Nzk0OQ=="}, "originalCommit": {"oid": "6f77dacfa489eba7bb70d76eab916b02919244e9"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjY4MDk2Mg==", "bodyText": "FWIW: I added synchronized back, but 1 level down in the indexer, as I realized a corner case: >1 calls to at the same time or triggering while this is running.", "url": "https://github.com/elastic/elasticsearch/pull/62086#discussion_r492680962", "createdAt": "2020-09-22T12:08:36Z", "author": {"login": "hendrikmuhs"}, "path": "x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/TransformTask.java", "diffHunk": "@@ -299,7 +295,7 @@ void setShouldStopAtCheckpoint(boolean shouldStopAtCheckpoint) {\n      * @param shouldStopAtCheckpoint whether or not we should stop at the next checkpoint or not\n      * @param shouldStopAtCheckpointListener the listener to return to when we have persisted the updated value to the state index.\n      */\n-    public synchronized void setShouldStopAtCheckpoint(\n+    public void setShouldStopAtCheckpoint(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg2Nzk0OQ=="}, "originalCommit": {"oid": "6f77dacfa489eba7bb70d76eab916b02919244e9"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MjM4MzIxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/TransformIndexer.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMjoyMToxN1rOHRRGag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxNTowOToyOFrOHRZsQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg2ODAxMA==", "bodyText": "This always assumes that the saving state succeeds. If saving the state fails, the listeners are never called.", "url": "https://github.com/elastic/elasticsearch/pull/62086#discussion_r487868010", "createdAt": "2020-09-14T12:21:17Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/TransformIndexer.java", "diffHunk": "@@ -508,6 +518,43 @@ protected void onAbort() {\n         context.shutdown();\n     }\n \n+    protected void callAndResetSaveStateListeners() {\n+        Collection<ActionListener<Void>> listeners = saveStateListeners.getAndSet(null);\n+        if (listeners != null) {\n+            for (ActionListener<Void> l : listeners) {\n+                l.onResponse(null);\n+            }\n+        }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f77dacfa489eba7bb70d76eab916b02919244e9"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg3MTkwMQ==", "bodyText": "It also seems to me that a previous save state could be getting called (its listener executing), and these listeners get triggered. But, it is not their current state (e.g. the one with \"stop at checkpoint\") that was saved, but the previous one that was in the middle of saving.", "url": "https://github.com/elastic/elasticsearch/pull/62086#discussion_r487871901", "createdAt": "2020-09-14T12:27:42Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/TransformIndexer.java", "diffHunk": "@@ -508,6 +518,43 @@ protected void onAbort() {\n         context.shutdown();\n     }\n \n+    protected void callAndResetSaveStateListeners() {\n+        Collection<ActionListener<Void>> listeners = saveStateListeners.getAndSet(null);\n+        if (listeners != null) {\n+            for (ActionListener<Void> l : listeners) {\n+                l.onResponse(null);\n+            }\n+        }\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg2ODAxMA=="}, "originalCommit": {"oid": "6f77dacfa489eba7bb70d76eab916b02919244e9"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAwODc2OQ==", "bodyText": "good spot! I changed the implementation to get and reset the listener before calling save state. I think that covers it. Now its possible that \"stop at checkpoint\" is set after the listeners are taken, but this is benign, I added comments in code.", "url": "https://github.com/elastic/elasticsearch/pull/62086#discussion_r488008769", "createdAt": "2020-09-14T15:09:28Z", "author": {"login": "hendrikmuhs"}, "path": "x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/TransformIndexer.java", "diffHunk": "@@ -508,6 +518,43 @@ protected void onAbort() {\n         context.shutdown();\n     }\n \n+    protected void callAndResetSaveStateListeners() {\n+        Collection<ActionListener<Void>> listeners = saveStateListeners.getAndSet(null);\n+        if (listeners != null) {\n+            for (ActionListener<Void> l : listeners) {\n+                l.onResponse(null);\n+            }\n+        }\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg2ODAxMA=="}, "originalCommit": {"oid": "6f77dacfa489eba7bb70d76eab916b02919244e9"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1NjQyMzg0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/transform/qa/multi-node-tests/src/javaRestTest/java/org/elasticsearch/xpack/transform/integration/TransformIntegTestCase.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQwODozMzo0M1rOHR23QA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQwODozMzo0M1rOHR23QA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODQ4NjcyMA==", "bodyText": "This line is not needed anymore.", "url": "https://github.com/elastic/elasticsearch/pull/62086#discussion_r488486720", "createdAt": "2020-09-15T08:33:43Z", "author": {"login": "przemekwitek"}, "path": "x-pack/plugin/transform/qa/multi-node-tests/src/javaRestTest/java/org/elasticsearch/xpack/transform/integration/TransformIntegTestCase.java", "diffHunk": "@@ -140,6 +142,25 @@ protected StartTransformResponse startTransform(String id, RequestOptions option\n         }\n     }\n \n+    // workaround for https://github.com/elastic/elasticsearch/issues/62204\n+    protected StartTransformResponse startTransformWithRetryOnConflict(String id, RequestOptions options) throws Exception {\n+        ElasticsearchStatusException lastConflict = null;\n+        for (int retries = 10; retries > 0; --retries) {\n+            try (RestHighLevelClient restClient = new TestRestHighLevelClient()) {\n+                return restClient.transform().startTransform(new StartTransformRequest(id), options);\n+            } catch (ElasticsearchStatusException e) {\n+                if (RestStatus.CONFLICT.equals(e.status()) == false) {\n+                    throw e;\n+                }\n+\n+                lastConflict = e;\n+                --retries;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f30b704a51af627a432552e3b7353bfa7ae4d79e"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3OTE0ODA0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/TransformIndexer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxMzoxMDowMVrOHVPOFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxMzoxMDowMVrOHVPOFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjAzMTUwOQ==", "bodyText": "Could you adjust the comment indicating that this is because the method is synchronized? It took me a second to see that all the triggering methods, etc. were synchronized.\nAlso, it might be good to make this method final so it cannot be overridden and consequently cause MT issues in the future by accident.", "url": "https://github.com/elastic/elasticsearch/pull/62086#discussion_r492031509", "createdAt": "2020-09-21T13:10:01Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/TransformIndexer.java", "diffHunk": "@@ -508,6 +522,89 @@ protected void onAbort() {\n         context.shutdown();\n     }\n \n+    /**\n+     * Let the indexer stop at the next checkpoint and call the listener after the flag has been persisted in state.\n+     *\n+     * If the indexer isn't running, persist state if required and call the listener immediately.\n+     */\n+    synchronized void setStopAtCheckpoint(boolean shouldStopAtCheckpoint, ActionListener<Void> shouldStopAtCheckpointListener) {\n+        IndexerState state = getState();\n+\n+        // in case the indexer isn't running, respond immediately\n+        if (state == IndexerState.STARTED && context.shouldStopAtCheckpoint() != shouldStopAtCheckpoint) {\n+            context.setShouldStopAtCheckpoint(shouldStopAtCheckpoint);\n+\n+            // because save state is async we need to block the call until state is persisted, so that the job can not\n+            // be triggered\n+            CountDownLatch latch = new CountDownLatch(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f159e71a3f26ba7a297114655f8b0276cef6530"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3OTE2MTA5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/TransformIndexer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxMzoxMzowOVrOHVPWFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNDo1NTozNFrOHVUQXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjAzMzU1OA==", "bodyText": "I think this method call stack goes all the way back to the transport layer:\n\n  \n    \n      elasticsearch/x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/action/TransportStopTransformAction.java\n    \n    \n        Lines 219 to 228\n      in\n      95a7eed\n    \n    \n    \n    \n\n        \n          \n           protected void taskOperation(Request request, TransformTask transformTask, ActionListener<Response> listener) { \n        \n\n        \n          \n            \n        \n\n        \n          \n               Set<String> ids = request.getExpandedIds(); \n        \n\n        \n          \n               if (ids == null) { \n        \n\n        \n          \n                   listener.onFailure(new IllegalStateException(\"Request does not have expandedIds set\")); \n        \n\n        \n          \n                   return; \n        \n\n        \n          \n               } \n        \n\n        \n          \n            \n        \n\n        \n          \n               if (ids.contains(transformTask.getTransformId())) { \n        \n\n        \n          \n                   transformTask.setShouldStopAtCheckpoint(request.isWaitForCheckpoint(), ActionListener.wrap(r -> { \n        \n    \n  \n\n\nConsequently, do we know what threadpool we will be locking up for 5 seconds?", "url": "https://github.com/elastic/elasticsearch/pull/62086#discussion_r492033558", "createdAt": "2020-09-21T13:13:09Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/TransformIndexer.java", "diffHunk": "@@ -508,6 +522,89 @@ protected void onAbort() {\n         context.shutdown();\n     }\n \n+    /**\n+     * Let the indexer stop at the next checkpoint and call the listener after the flag has been persisted in state.\n+     *\n+     * If the indexer isn't running, persist state if required and call the listener immediately.\n+     */\n+    synchronized void setStopAtCheckpoint(boolean shouldStopAtCheckpoint, ActionListener<Void> shouldStopAtCheckpointListener) {\n+        IndexerState state = getState();\n+\n+        // in case the indexer isn't running, respond immediately\n+        if (state == IndexerState.STARTED && context.shouldStopAtCheckpoint() != shouldStopAtCheckpoint) {\n+            context.setShouldStopAtCheckpoint(shouldStopAtCheckpoint);\n+\n+            // because save state is async we need to block the call until state is persisted, so that the job can not\n+            // be triggered\n+            CountDownLatch latch = new CountDownLatch(1);\n+            try {\n+                doSaveState(IndexerState.STARTED, getPosition(), () -> {\n+                    latch.countDown();\n+                    shouldStopAtCheckpointListener.onResponse(null);\n+                });\n+\n+                latch.await(PERSIST_STOP_AT_CHECKPOINT_TIMEOUT_SEC, TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f159e71a3f26ba7a297114655f8b0276cef6530"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjExNDAxNA==", "bodyText": "good spot, I offloaded it now. This might explain the test failures.", "url": "https://github.com/elastic/elasticsearch/pull/62086#discussion_r492114014", "createdAt": "2020-09-21T14:55:34Z", "author": {"login": "hendrikmuhs"}, "path": "x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/TransformIndexer.java", "diffHunk": "@@ -508,6 +522,89 @@ protected void onAbort() {\n         context.shutdown();\n     }\n \n+    /**\n+     * Let the indexer stop at the next checkpoint and call the listener after the flag has been persisted in state.\n+     *\n+     * If the indexer isn't running, persist state if required and call the listener immediately.\n+     */\n+    synchronized void setStopAtCheckpoint(boolean shouldStopAtCheckpoint, ActionListener<Void> shouldStopAtCheckpointListener) {\n+        IndexerState state = getState();\n+\n+        // in case the indexer isn't running, respond immediately\n+        if (state == IndexerState.STARTED && context.shouldStopAtCheckpoint() != shouldStopAtCheckpoint) {\n+            context.setShouldStopAtCheckpoint(shouldStopAtCheckpoint);\n+\n+            // because save state is async we need to block the call until state is persisted, so that the job can not\n+            // be triggered\n+            CountDownLatch latch = new CountDownLatch(1);\n+            try {\n+                doSaveState(IndexerState.STARTED, getPosition(), () -> {\n+                    latch.countDown();\n+                    shouldStopAtCheckpointListener.onResponse(null);\n+                });\n+\n+                latch.await(PERSIST_STOP_AT_CHECKPOINT_TIMEOUT_SEC, TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjAzMzU1OA=="}, "originalCommit": {"oid": "9f159e71a3f26ba7a297114655f8b0276cef6530"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5MzQ0MzU0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/TransformIndexer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxMjoxNjoyNlrOHXXnmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxMjoxNjoyNlrOHXXnmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI2NjI2Ng==", "bodyText": "In testing (or where assertions are enabled), this would cause the caller to freeze and never return.\nI am not sure how to assert here AND fire an onFailure result. But, not doing so might cause some frustrating test investigations", "url": "https://github.com/elastic/elasticsearch/pull/62086#discussion_r494266266", "createdAt": "2020-09-24T12:16:26Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/TransformIndexer.java", "diffHunk": "@@ -508,6 +522,100 @@ protected void onAbort() {\n         context.shutdown();\n     }\n \n+    /**\n+     * Let the indexer stop at the next checkpoint and call the listener after the flag has been persisted in state.\n+     *\n+     * If the indexer isn't running, persist state if required and call the listener immediately.\n+     */\n+    final void setStopAtCheckpoint(boolean shouldStopAtCheckpoint, ActionListener<Void> shouldStopAtCheckpointListener) {\n+        // this should be called from the generic threadpool\n+        assert Thread.currentThread().getName().contains(ThreadPool.Names.GENERIC);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0efdfd87ca0c5f4e0aee98ccf06c3ea2e38d643"}, "originalPosition": 56}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1664, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}