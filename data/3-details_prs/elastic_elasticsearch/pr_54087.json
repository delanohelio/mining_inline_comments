{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkyOTk4MDY0", "number": 54087, "title": "[ML] Stratified cross validation split for classification", "bodyText": "As classification now works for multiple classes, randomly\npicking training/test data frame rows is not good enough.\nThis commit introduces a stratified cross validation splitter\nthat maintains the proportion of the each class in the dataset\nin the sample that is used for training the model.", "createdAt": "2020-03-24T13:41:42Z", "url": "https://github.com/elastic/elasticsearch/pull/54087", "merged": true, "mergeCommit": {"oid": "af7b95b2193ab105dfd05ddddbef01407f168161"}, "closed": true, "closedAt": "2020-03-24T15:43:25Z", "author": {"login": "dimitris-athanasiou"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcQzbBwgFqTM4MDMyNzUwMw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcQ0JqIgFqTM4MDM4NzIyMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwMzI3NTAz", "url": "https://github.com/elastic/elasticsearch/pull/54087#pullrequestreview-380327503", "createdAt": "2020-03-24T13:51:15Z", "commit": {"oid": "37fe98ac77e80b0e8ee2c867647f58701ab25dd7"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxMzo1MToxNVrOF6xKEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxMzo1NTo0M1rOF6xXbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzE2NzEyMA==", "bodyText": "Could you set allowPartialResults(false) or something to capture the missing shards issues?", "url": "https://github.com/elastic/elasticsearch/pull/54087#discussion_r397167120", "createdAt": "2020-03-24T13:51:15Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/dataframe/process/crossvalidation/CrossValidationSplitterFactory.java", "diffHunk": "@@ -5,32 +5,84 @@\n  */\n package org.elasticsearch.xpack.ml.dataframe.process.crossvalidation;\n \n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.search.SearchRequestBuilder;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.action.search.ShardSearchFailure;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.search.aggregations.AggregationBuilders;\n+import org.elasticsearch.search.aggregations.Aggregations;\n+import org.elasticsearch.search.aggregations.bucket.terms.Terms;\n+import org.elasticsearch.xpack.core.ClientHelper;\n+import org.elasticsearch.xpack.core.ml.dataframe.DataFrameAnalyticsConfig;\n import org.elasticsearch.xpack.core.ml.dataframe.analyses.Classification;\n-import org.elasticsearch.xpack.core.ml.dataframe.analyses.DataFrameAnalysis;\n import org.elasticsearch.xpack.core.ml.dataframe.analyses.Regression;\n+import org.elasticsearch.xpack.core.ml.utils.ExceptionsHelper;\n \n+import java.util.Arrays;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n import java.util.Objects;\n \n public class CrossValidationSplitterFactory {\n \n+    private static final Logger LOGGER = LogManager.getLogger(CrossValidationSplitterFactory.class);\n+\n+    private final Client client;\n+    private final DataFrameAnalyticsConfig config;\n     private final List<String> fieldNames;\n \n-    public CrossValidationSplitterFactory(List<String> fieldNames) {\n+    public CrossValidationSplitterFactory(Client client, DataFrameAnalyticsConfig config, List<String> fieldNames) {\n+        this.client = Objects.requireNonNull(client);\n+        this.config = Objects.requireNonNull(config);\n         this.fieldNames = Objects.requireNonNull(fieldNames);\n     }\n \n-    public CrossValidationSplitter create(DataFrameAnalysis analysis) {\n-        if (analysis instanceof Regression) {\n-            Regression regression = (Regression) analysis;\n+    public CrossValidationSplitter create() {\n+        if (config.getAnalysis() instanceof Regression) {\n+            Regression regression = (Regression) config.getAnalysis();\n             return new RandomCrossValidationSplitter(\n                 fieldNames, regression.getDependentVariable(), regression.getTrainingPercent(), regression.getRandomizeSeed());\n         }\n-        if (analysis instanceof Classification) {\n-            Classification classification = (Classification) analysis;\n-            return new RandomCrossValidationSplitter(\n-                fieldNames, classification.getDependentVariable(), classification.getTrainingPercent(), classification.getRandomizeSeed());\n+        if (config.getAnalysis() instanceof Classification) {\n+            return createStratifiedSplitter((Classification) config.getAnalysis());\n         }\n         return (row, incrementTrainingDocs, incrementTestDocs) -> incrementTrainingDocs.run();\n     }\n+\n+    private CrossValidationSplitter createStratifiedSplitter(Classification classification) {\n+        String aggName = \"dependent_variable_terms\";\n+        SearchRequestBuilder searchRequestBuilder = client.prepareSearch(config.getDest().getIndex())\n+            .setSize(0)\n+            .addAggregation(AggregationBuilders.terms(aggName)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37fe98ac77e80b0e8ee2c867647f58701ab25dd7"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzE3MDU0Mg==", "bodyText": "#nit\nThis will still hit the hashmap capacity since the default load factory is 0.75f.\nIf you are wanting to reserve the whole of the hashMap, I suggest increasing the size (taking the load factory into consideration) or supplying your own load factor 1.0f.", "url": "https://github.com/elastic/elasticsearch/pull/54087#discussion_r397170542", "createdAt": "2020-03-24T13:55:43Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/dataframe/process/crossvalidation/StratifiedCrossValidationSplitter.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ml.dataframe.process.crossvalidation;\n+\n+import org.elasticsearch.xpack.core.ml.utils.ExceptionsHelper;\n+import org.elasticsearch.xpack.ml.dataframe.extractor.DataFrameDataExtractor;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+\n+/**\n+ * Given a dependent variable, randomly splits the dataset trying\n+ * to preserve the proportion of each class in the training sample.\n+ */\n+public class StratifiedCrossValidationSplitter implements CrossValidationSplitter {\n+\n+    private final int dependentVariableIndex;\n+    private final double samplingRatio;\n+    private final Random random;\n+    private final Map<String, ClassSample> classSamples;\n+\n+    public StratifiedCrossValidationSplitter(List<String> fieldNames, String dependentVariable, Map<String, Long> classCardinalities,\n+                                             double trainingPercent, long randomizeSeed) {\n+        assert trainingPercent >= 1.0 && trainingPercent <= 100.0;\n+        this.dependentVariableIndex = findDependentVariableIndex(fieldNames, dependentVariable);\n+        this.samplingRatio = trainingPercent / 100.0;\n+        this.random = new Random(randomizeSeed);\n+        this.classSamples = new HashMap<>(classCardinalities.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37fe98ac77e80b0e8ee2c867647f58701ab25dd7"}, "originalPosition": 34}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwMzI3NDUx", "url": "https://github.com/elastic/elasticsearch/pull/54087#pullrequestreview-380327451", "createdAt": "2020-03-24T13:51:12Z", "commit": {"oid": "37fe98ac77e80b0e8ee2c867647f58701ab25dd7"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxMzo1MToxMlrOF6xJ5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxNDoyMDo0N1rOF6yfqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzE2NzA3Nw==", "bodyText": "nit: I would extract this into a separate method createRandomSplitter, just for consistency with createStratifiedSplitter.", "url": "https://github.com/elastic/elasticsearch/pull/54087#discussion_r397167077", "createdAt": "2020-03-24T13:51:12Z", "author": {"login": "przemekwitek"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/dataframe/process/crossvalidation/CrossValidationSplitterFactory.java", "diffHunk": "@@ -5,32 +5,84 @@\n  */\n package org.elasticsearch.xpack.ml.dataframe.process.crossvalidation;\n \n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.search.SearchRequestBuilder;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.action.search.ShardSearchFailure;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.search.aggregations.AggregationBuilders;\n+import org.elasticsearch.search.aggregations.Aggregations;\n+import org.elasticsearch.search.aggregations.bucket.terms.Terms;\n+import org.elasticsearch.xpack.core.ClientHelper;\n+import org.elasticsearch.xpack.core.ml.dataframe.DataFrameAnalyticsConfig;\n import org.elasticsearch.xpack.core.ml.dataframe.analyses.Classification;\n-import org.elasticsearch.xpack.core.ml.dataframe.analyses.DataFrameAnalysis;\n import org.elasticsearch.xpack.core.ml.dataframe.analyses.Regression;\n+import org.elasticsearch.xpack.core.ml.utils.ExceptionsHelper;\n \n+import java.util.Arrays;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n import java.util.Objects;\n \n public class CrossValidationSplitterFactory {\n \n+    private static final Logger LOGGER = LogManager.getLogger(CrossValidationSplitterFactory.class);\n+\n+    private final Client client;\n+    private final DataFrameAnalyticsConfig config;\n     private final List<String> fieldNames;\n \n-    public CrossValidationSplitterFactory(List<String> fieldNames) {\n+    public CrossValidationSplitterFactory(Client client, DataFrameAnalyticsConfig config, List<String> fieldNames) {\n+        this.client = Objects.requireNonNull(client);\n+        this.config = Objects.requireNonNull(config);\n         this.fieldNames = Objects.requireNonNull(fieldNames);\n     }\n \n-    public CrossValidationSplitter create(DataFrameAnalysis analysis) {\n-        if (analysis instanceof Regression) {\n-            Regression regression = (Regression) analysis;\n+    public CrossValidationSplitter create() {\n+        if (config.getAnalysis() instanceof Regression) {\n+            Regression regression = (Regression) config.getAnalysis();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37fe98ac77e80b0e8ee2c867647f58701ab25dd7"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzE2OTU3Ng==", "bodyText": "Just double-checking: are we sure at this point that there is no more than 30 buckets because we did a check in ExtractedFieldsDetector?", "url": "https://github.com/elastic/elasticsearch/pull/54087#discussion_r397169576", "createdAt": "2020-03-24T13:54:19Z", "author": {"login": "przemekwitek"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/dataframe/process/crossvalidation/CrossValidationSplitterFactory.java", "diffHunk": "@@ -5,32 +5,84 @@\n  */\n package org.elasticsearch.xpack.ml.dataframe.process.crossvalidation;\n \n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.search.SearchRequestBuilder;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.action.search.ShardSearchFailure;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.search.aggregations.AggregationBuilders;\n+import org.elasticsearch.search.aggregations.Aggregations;\n+import org.elasticsearch.search.aggregations.bucket.terms.Terms;\n+import org.elasticsearch.xpack.core.ClientHelper;\n+import org.elasticsearch.xpack.core.ml.dataframe.DataFrameAnalyticsConfig;\n import org.elasticsearch.xpack.core.ml.dataframe.analyses.Classification;\n-import org.elasticsearch.xpack.core.ml.dataframe.analyses.DataFrameAnalysis;\n import org.elasticsearch.xpack.core.ml.dataframe.analyses.Regression;\n+import org.elasticsearch.xpack.core.ml.utils.ExceptionsHelper;\n \n+import java.util.Arrays;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n import java.util.Objects;\n \n public class CrossValidationSplitterFactory {\n \n+    private static final Logger LOGGER = LogManager.getLogger(CrossValidationSplitterFactory.class);\n+\n+    private final Client client;\n+    private final DataFrameAnalyticsConfig config;\n     private final List<String> fieldNames;\n \n-    public CrossValidationSplitterFactory(List<String> fieldNames) {\n+    public CrossValidationSplitterFactory(Client client, DataFrameAnalyticsConfig config, List<String> fieldNames) {\n+        this.client = Objects.requireNonNull(client);\n+        this.config = Objects.requireNonNull(config);\n         this.fieldNames = Objects.requireNonNull(fieldNames);\n     }\n \n-    public CrossValidationSplitter create(DataFrameAnalysis analysis) {\n-        if (analysis instanceof Regression) {\n-            Regression regression = (Regression) analysis;\n+    public CrossValidationSplitter create() {\n+        if (config.getAnalysis() instanceof Regression) {\n+            Regression regression = (Regression) config.getAnalysis();\n             return new RandomCrossValidationSplitter(\n                 fieldNames, regression.getDependentVariable(), regression.getTrainingPercent(), regression.getRandomizeSeed());\n         }\n-        if (analysis instanceof Classification) {\n-            Classification classification = (Classification) analysis;\n-            return new RandomCrossValidationSplitter(\n-                fieldNames, classification.getDependentVariable(), classification.getTrainingPercent(), classification.getRandomizeSeed());\n+        if (config.getAnalysis() instanceof Classification) {\n+            return createStratifiedSplitter((Classification) config.getAnalysis());\n         }\n         return (row, incrementTrainingDocs, incrementTestDocs) -> incrementTrainingDocs.run();\n     }\n+\n+    private CrossValidationSplitter createStratifiedSplitter(Classification classification) {\n+        String aggName = \"dependent_variable_terms\";\n+        SearchRequestBuilder searchRequestBuilder = client.prepareSearch(config.getDest().getIndex())\n+            .setSize(0)\n+            .addAggregation(AggregationBuilders.terms(aggName)\n+                .field(classification.getDependentVariable())\n+                .size(Classification.MAX_DEPENDENT_VARIABLE_CARDINALITY));\n+        SearchResponse searchResponse = ClientHelper.executeWithHeaders(config.getHeaders(), ClientHelper.ML_ORIGIN, client,\n+            searchRequestBuilder::get);\n+\n+        ShardSearchFailure[] shardFailures = searchResponse.getShardFailures();\n+        if (shardFailures != null && shardFailures.length > 0) {\n+            LOGGER.error(\"[{}] Dependent variable terms search returned shard failures: {}\", config.getId(),\n+                Arrays.toString(shardFailures));\n+            throw new ElasticsearchException(ExceptionsHelper.shardFailuresToErrorMsg(config.getId(), shardFailures));\n+        }\n+        int unavailableShards = searchResponse.getTotalShards() - searchResponse.getSuccessfulShards();\n+        if (unavailableShards > 0) {\n+            throw new ElasticsearchException(\"[\" + config.getId() + \"] Dependent variable terms search encountered [\"\n+                + unavailableShards + \"] unavailable shards\");\n+        }\n+\n+        Aggregations aggs = searchResponse.getAggregations();\n+        Terms terms = aggs.get(aggName);\n+        Map<String, Long> classCardinalities = new HashMap<>();\n+        for (Terms.Bucket bucket : terms.getBuckets()) {\n+            classCardinalities.put(String.valueOf(bucket.getKey()), bucket.getDocCount());\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37fe98ac77e80b0e8ee2c867647f58701ab25dd7"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzE3MDg5Nw==", "bodyText": "Would it be possible to use List::indexOf here?", "url": "https://github.com/elastic/elasticsearch/pull/54087#discussion_r397170897", "createdAt": "2020-03-24T13:56:10Z", "author": {"login": "przemekwitek"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/dataframe/process/crossvalidation/StratifiedCrossValidationSplitter.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ml.dataframe.process.crossvalidation;\n+\n+import org.elasticsearch.xpack.core.ml.utils.ExceptionsHelper;\n+import org.elasticsearch.xpack.ml.dataframe.extractor.DataFrameDataExtractor;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+\n+/**\n+ * Given a dependent variable, randomly splits the dataset trying\n+ * to preserve the proportion of each class in the training sample.\n+ */\n+public class StratifiedCrossValidationSplitter implements CrossValidationSplitter {\n+\n+    private final int dependentVariableIndex;\n+    private final double samplingRatio;\n+    private final Random random;\n+    private final Map<String, ClassSample> classSamples;\n+\n+    public StratifiedCrossValidationSplitter(List<String> fieldNames, String dependentVariable, Map<String, Long> classCardinalities,\n+                                             double trainingPercent, long randomizeSeed) {\n+        assert trainingPercent >= 1.0 && trainingPercent <= 100.0;\n+        this.dependentVariableIndex = findDependentVariableIndex(fieldNames, dependentVariable);\n+        this.samplingRatio = trainingPercent / 100.0;\n+        this.random = new Random(randomizeSeed);\n+        this.classSamples = new HashMap<>(classCardinalities.size());\n+        classCardinalities.entrySet().forEach(entry -> classSamples.put(entry.getKey(), new ClassSample(entry.getValue())));\n+    }\n+\n+    private static int findDependentVariableIndex(List<String> fieldNames, String dependentVariable) {\n+        for (int i = 0; i < fieldNames.size(); i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37fe98ac77e80b0e8ee2c867647f58701ab25dd7"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzE3Mzk1Mw==", "bodyText": "s/DependendVariable/DependentVariable/", "url": "https://github.com/elastic/elasticsearch/pull/54087#discussion_r397173953", "createdAt": "2020-03-24T14:00:25Z", "author": {"login": "przemekwitek"}, "path": "x-pack/plugin/ml/src/test/java/org/elasticsearch/xpack/ml/dataframe/process/crossvalidation/StratifiedCrossValidationSplitterTests.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ml.dataframe.process.crossvalidation;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ml.dataframe.extractor.DataFrameDataExtractor;\n+import org.junit.Before;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.hamcrest.CoreMatchers.equalTo;\n+import static org.hamcrest.Matchers.closeTo;\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.lessThanOrEqualTo;\n+\n+public class StratifiedCrossValidationSplitterTests extends ESTestCase {\n+\n+    private static final int ROWS_COUNT = 500;\n+\n+    private List<String> fields;\n+    private int dependentVariableIndex;\n+    private String dependentVariable;\n+    private long randomizeSeed;\n+    private Map<String, Long> classCardinalities;\n+    private String[] classValuesPerRow;\n+    private long trainingDocsCount;\n+    private long testDocsCount;\n+\n+    @Before\n+    public void setUpTests() {\n+        int fieldCount = randomIntBetween(1, 5);\n+        fields = new ArrayList<>(fieldCount);\n+        for (int i = 0; i < fieldCount; i++) {\n+            fields.add(randomAlphaOfLength(10));\n+        }\n+        dependentVariableIndex = randomIntBetween(0, fieldCount - 1);\n+        dependentVariable = fields.get(dependentVariableIndex);\n+        randomizeSeed = randomLong();\n+\n+        long classA = 0;\n+        long classB = 0;\n+        long classC = 0;\n+\n+\n+        classValuesPerRow = new String[ROWS_COUNT];\n+        for (int i = 0; i < classValuesPerRow.length; i++) {\n+            double randomDouble = randomDoubleBetween(0.0, 1.0, true);\n+            if (randomDouble < 0.2) {\n+                classValuesPerRow[i] = \"a\";\n+                classA++;\n+            } else if (randomDouble < 0.5) {\n+                classValuesPerRow[i] = \"b\";\n+                classB++;\n+            } else {\n+                classValuesPerRow[i] = \"c\";\n+                classC++;\n+            }\n+        }\n+\n+        classCardinalities = new HashMap<>();\n+        classCardinalities.put(\"a\", classA);\n+        classCardinalities.put(\"b\", classB);\n+        classCardinalities.put(\"c\", classC);\n+    }\n+\n+    public void testConstructor_GivenMissingDependendVariable() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37fe98ac77e80b0e8ee2c867647f58701ab25dd7"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzE3NjQwNA==", "bodyText": "Is this comment relevant to this test case?", "url": "https://github.com/elastic/elasticsearch/pull/54087#discussion_r397176404", "createdAt": "2020-03-24T14:03:53Z", "author": {"login": "przemekwitek"}, "path": "x-pack/plugin/ml/src/test/java/org/elasticsearch/xpack/ml/dataframe/process/crossvalidation/StratifiedCrossValidationSplitterTests.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ml.dataframe.process.crossvalidation;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ml.dataframe.extractor.DataFrameDataExtractor;\n+import org.junit.Before;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.hamcrest.CoreMatchers.equalTo;\n+import static org.hamcrest.Matchers.closeTo;\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.lessThanOrEqualTo;\n+\n+public class StratifiedCrossValidationSplitterTests extends ESTestCase {\n+\n+    private static final int ROWS_COUNT = 500;\n+\n+    private List<String> fields;\n+    private int dependentVariableIndex;\n+    private String dependentVariable;\n+    private long randomizeSeed;\n+    private Map<String, Long> classCardinalities;\n+    private String[] classValuesPerRow;\n+    private long trainingDocsCount;\n+    private long testDocsCount;\n+\n+    @Before\n+    public void setUpTests() {\n+        int fieldCount = randomIntBetween(1, 5);\n+        fields = new ArrayList<>(fieldCount);\n+        for (int i = 0; i < fieldCount; i++) {\n+            fields.add(randomAlphaOfLength(10));\n+        }\n+        dependentVariableIndex = randomIntBetween(0, fieldCount - 1);\n+        dependentVariable = fields.get(dependentVariableIndex);\n+        randomizeSeed = randomLong();\n+\n+        long classA = 0;\n+        long classB = 0;\n+        long classC = 0;\n+\n+\n+        classValuesPerRow = new String[ROWS_COUNT];\n+        for (int i = 0; i < classValuesPerRow.length; i++) {\n+            double randomDouble = randomDoubleBetween(0.0, 1.0, true);\n+            if (randomDouble < 0.2) {\n+                classValuesPerRow[i] = \"a\";\n+                classA++;\n+            } else if (randomDouble < 0.5) {\n+                classValuesPerRow[i] = \"b\";\n+                classB++;\n+            } else {\n+                classValuesPerRow[i] = \"c\";\n+                classC++;\n+            }\n+        }\n+\n+        classCardinalities = new HashMap<>();\n+        classCardinalities.put(\"a\", classA);\n+        classCardinalities.put(\"b\", classB);\n+        classCardinalities.put(\"c\", classC);\n+    }\n+\n+    public void testConstructor_GivenMissingDependendVariable() {\n+        ElasticsearchException e = expectThrows(ElasticsearchException.class, () -> new StratifiedCrossValidationSplitter(\n+            Collections.emptyList(), \"foo\", Collections.emptyMap(), 100.0, 0));\n+        assertThat(e.getMessage(), equalTo(\"Could not find dependent variable [foo] in fields []\"));\n+    }\n+\n+    public void testProcess_GivenUnknownClass() {\n+        CrossValidationSplitter splitter = createSplitter(100.0);\n+        String[] row = new String[fields.size()];\n+        for (int fieldIndex = 0; fieldIndex < fields.size(); fieldIndex++) {\n+            row[fieldIndex] = randomAlphaOfLength(5);\n+        }\n+        row[dependentVariableIndex] = \"unknown_class\";\n+\n+        IllegalStateException e = expectThrows(IllegalStateException.class,\n+            () -> splitter.process(row, this::incrementTrainingDocsCount, this::incrementTestDocsCount));\n+\n+        assertThat(e.getMessage(), equalTo(\"Unknown class [unknown_class]; expected one of [a, b, c]\"));\n+    }\n+\n+    public void testProcess_GivenRowsWithoutDependentVariableValue() {\n+        CrossValidationSplitter splitter = createSplitter(50.0);\n+\n+        for (int i = 0; i < classValuesPerRow.length; i++) {\n+            String[] row = new String[fields.size()];\n+            for (int fieldIndex = 0; fieldIndex < fields.size(); fieldIndex++) {\n+                String value = fieldIndex == dependentVariableIndex ? DataFrameDataExtractor.NULL_VALUE : randomAlphaOfLength(10);\n+                row[fieldIndex] = value;\n+            }\n+\n+            String[] processedRow = Arrays.copyOf(row, row.length);\n+            splitter.process(processedRow, this::incrementTrainingDocsCount, this::incrementTestDocsCount);\n+\n+            // As all these rows have no dependent variable value, they're not for training and should be unaffected\n+            assertThat(Arrays.equals(processedRow, row), is(true));\n+        }\n+        assertThat(trainingDocsCount, equalTo(0L));\n+        assertThat(testDocsCount, equalTo(500L));\n+    }\n+\n+    public void testProcess_GivenRowsWithDependentVariableValue_AndTrainingPercentIsHundred() {\n+        CrossValidationSplitter splitter = createSplitter(100.0);\n+\n+        for (int i = 0; i < classValuesPerRow.length; i++) {\n+            String[] row = new String[fields.size()];\n+            for (int fieldIndex = 0; fieldIndex < fields.size(); fieldIndex++) {\n+                String value = fieldIndex == dependentVariableIndex ? classValuesPerRow[i] : randomAlphaOfLength(10);\n+                row[fieldIndex] = value;\n+            }\n+\n+            String[] processedRow = Arrays.copyOf(row, row.length);\n+            splitter.process(processedRow, this::incrementTrainingDocsCount, this::incrementTestDocsCount);\n+\n+            // As all these rows have no dependent variable value, they're not for training and should be unaffected", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37fe98ac77e80b0e8ee2c867647f58701ab25dd7"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzE4OTAzNA==", "bodyText": "But what if we are unlucky with random generator?", "url": "https://github.com/elastic/elasticsearch/pull/54087#discussion_r397189034", "createdAt": "2020-03-24T14:20:47Z", "author": {"login": "przemekwitek"}, "path": "x-pack/plugin/ml/src/test/java/org/elasticsearch/xpack/ml/dataframe/process/crossvalidation/StratifiedCrossValidationSplitterTests.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ml.dataframe.process.crossvalidation;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ml.dataframe.extractor.DataFrameDataExtractor;\n+import org.junit.Before;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.hamcrest.CoreMatchers.equalTo;\n+import static org.hamcrest.Matchers.closeTo;\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.lessThanOrEqualTo;\n+\n+public class StratifiedCrossValidationSplitterTests extends ESTestCase {\n+\n+    private static final int ROWS_COUNT = 500;\n+\n+    private List<String> fields;\n+    private int dependentVariableIndex;\n+    private String dependentVariable;\n+    private long randomizeSeed;\n+    private Map<String, Long> classCardinalities;\n+    private String[] classValuesPerRow;\n+    private long trainingDocsCount;\n+    private long testDocsCount;\n+\n+    @Before\n+    public void setUpTests() {\n+        int fieldCount = randomIntBetween(1, 5);\n+        fields = new ArrayList<>(fieldCount);\n+        for (int i = 0; i < fieldCount; i++) {\n+            fields.add(randomAlphaOfLength(10));\n+        }\n+        dependentVariableIndex = randomIntBetween(0, fieldCount - 1);\n+        dependentVariable = fields.get(dependentVariableIndex);\n+        randomizeSeed = randomLong();\n+\n+        long classA = 0;\n+        long classB = 0;\n+        long classC = 0;\n+\n+\n+        classValuesPerRow = new String[ROWS_COUNT];\n+        for (int i = 0; i < classValuesPerRow.length; i++) {\n+            double randomDouble = randomDoubleBetween(0.0, 1.0, true);\n+            if (randomDouble < 0.2) {\n+                classValuesPerRow[i] = \"a\";\n+                classA++;\n+            } else if (randomDouble < 0.5) {\n+                classValuesPerRow[i] = \"b\";\n+                classB++;\n+            } else {\n+                classValuesPerRow[i] = \"c\";\n+                classC++;\n+            }\n+        }\n+\n+        classCardinalities = new HashMap<>();\n+        classCardinalities.put(\"a\", classA);\n+        classCardinalities.put(\"b\", classB);\n+        classCardinalities.put(\"c\", classC);\n+    }\n+\n+    public void testConstructor_GivenMissingDependendVariable() {\n+        ElasticsearchException e = expectThrows(ElasticsearchException.class, () -> new StratifiedCrossValidationSplitter(\n+            Collections.emptyList(), \"foo\", Collections.emptyMap(), 100.0, 0));\n+        assertThat(e.getMessage(), equalTo(\"Could not find dependent variable [foo] in fields []\"));\n+    }\n+\n+    public void testProcess_GivenUnknownClass() {\n+        CrossValidationSplitter splitter = createSplitter(100.0);\n+        String[] row = new String[fields.size()];\n+        for (int fieldIndex = 0; fieldIndex < fields.size(); fieldIndex++) {\n+            row[fieldIndex] = randomAlphaOfLength(5);\n+        }\n+        row[dependentVariableIndex] = \"unknown_class\";\n+\n+        IllegalStateException e = expectThrows(IllegalStateException.class,\n+            () -> splitter.process(row, this::incrementTrainingDocsCount, this::incrementTestDocsCount));\n+\n+        assertThat(e.getMessage(), equalTo(\"Unknown class [unknown_class]; expected one of [a, b, c]\"));\n+    }\n+\n+    public void testProcess_GivenRowsWithoutDependentVariableValue() {\n+        CrossValidationSplitter splitter = createSplitter(50.0);\n+\n+        for (int i = 0; i < classValuesPerRow.length; i++) {\n+            String[] row = new String[fields.size()];\n+            for (int fieldIndex = 0; fieldIndex < fields.size(); fieldIndex++) {\n+                String value = fieldIndex == dependentVariableIndex ? DataFrameDataExtractor.NULL_VALUE : randomAlphaOfLength(10);\n+                row[fieldIndex] = value;\n+            }\n+\n+            String[] processedRow = Arrays.copyOf(row, row.length);\n+            splitter.process(processedRow, this::incrementTrainingDocsCount, this::incrementTestDocsCount);\n+\n+            // As all these rows have no dependent variable value, they're not for training and should be unaffected\n+            assertThat(Arrays.equals(processedRow, row), is(true));\n+        }\n+        assertThat(trainingDocsCount, equalTo(0L));\n+        assertThat(testDocsCount, equalTo(500L));\n+    }\n+\n+    public void testProcess_GivenRowsWithDependentVariableValue_AndTrainingPercentIsHundred() {\n+        CrossValidationSplitter splitter = createSplitter(100.0);\n+\n+        for (int i = 0; i < classValuesPerRow.length; i++) {\n+            String[] row = new String[fields.size()];\n+            for (int fieldIndex = 0; fieldIndex < fields.size(); fieldIndex++) {\n+                String value = fieldIndex == dependentVariableIndex ? classValuesPerRow[i] : randomAlphaOfLength(10);\n+                row[fieldIndex] = value;\n+            }\n+\n+            String[] processedRow = Arrays.copyOf(row, row.length);\n+            splitter.process(processedRow, this::incrementTrainingDocsCount, this::incrementTestDocsCount);\n+\n+            // As all these rows have no dependent variable value, they're not for training and should be unaffected\n+            assertThat(Arrays.equals(processedRow, row), is(true));\n+        }\n+        assertThat(trainingDocsCount, equalTo(500L));\n+        assertThat(testDocsCount, equalTo(0L));\n+    }\n+\n+    public void testProcess_GivenRowsWithDependentVariableValue_AndTrainingPercentIsRandom() {\n+        // We don't go too low here to avoid flakiness\n+        double trainingPercent = randomDoubleBetween(50.0, 100.0, true);\n+\n+        CrossValidationSplitter splitter = createSplitter(trainingPercent);\n+\n+        Map<String, Integer> totalRowsPerClass = new HashMap<>();\n+        Map<String, Integer> trainingRowsPerClass = new HashMap<>();\n+\n+        for (String classValue : classCardinalities.keySet()) {\n+            totalRowsPerClass.put(classValue, 0);\n+            trainingRowsPerClass.put(classValue, 0);\n+        }\n+\n+        for (int i = 0; i < classValuesPerRow.length; i++) {\n+            String[] row = new String[fields.size()];\n+            for (int fieldIndex = 0; fieldIndex < fields.size(); fieldIndex++) {\n+                String value = fieldIndex == dependentVariableIndex ? classValuesPerRow[i] : randomAlphaOfLength(10);\n+                row[fieldIndex] = value;\n+            }\n+\n+            String[] processedRow = Arrays.copyOf(row, row.length);\n+            splitter.process(processedRow, this::incrementTrainingDocsCount, this::incrementTestDocsCount);\n+\n+            for (int fieldIndex = 0; fieldIndex < fields.size(); fieldIndex++) {\n+                if (fieldIndex != dependentVariableIndex) {\n+                    assertThat(processedRow[fieldIndex], equalTo(row[fieldIndex]));\n+                }\n+            }\n+\n+            String classValue = row[dependentVariableIndex];\n+            totalRowsPerClass.compute(classValue, (k, v) -> v + 1);\n+\n+            if (DataFrameDataExtractor.NULL_VALUE.equals(processedRow[dependentVariableIndex]) == false) {\n+                assertThat(processedRow[dependentVariableIndex], equalTo(row[dependentVariableIndex]));\n+                trainingRowsPerClass.compute(classValue, (k, v) -> v + 1);\n+            }\n+        }\n+\n+        double trainingFraction = trainingPercent / 100;\n+\n+        // We can assert we're plus/minus 1 from rounding error\n+\n+        double expectedTotalTrainingCount = ROWS_COUNT * trainingFraction;\n+        assertThat(trainingDocsCount + testDocsCount, equalTo((long) ROWS_COUNT));\n+        assertThat(trainingDocsCount, greaterThanOrEqualTo((long) Math.floor(expectedTotalTrainingCount - 1)));\n+        assertThat(trainingDocsCount, lessThanOrEqualTo((long) Math.ceil(expectedTotalTrainingCount + 1)));\n+\n+        for (String classValue : classCardinalities.keySet()) {\n+            double expectedClassTrainingCount = totalRowsPerClass.get(classValue) * trainingFraction;\n+            int classTrainingCount = trainingRowsPerClass.get(classValue);\n+            assertThat((double) classTrainingCount, is(closeTo(expectedClassTrainingCount, 1.0)));\n+        }\n+    }\n+\n+    public void testProcess_SelectsTrainingRowsUniformly() {\n+        double trainingPercent = 50.0;\n+        int runCount = 500;\n+\n+        int[] trainingCountPerRow = new int[ROWS_COUNT];\n+\n+        for (int run = 0; run < runCount; run++) {\n+\n+            randomizeSeed = randomLong();\n+            CrossValidationSplitter crossValidationSplitter = createSplitter(trainingPercent);\n+\n+            for (int i = 0; i < classValuesPerRow.length; i++) {\n+                String[] row = new String[fields.size()];\n+                for (int fieldIndex = 0; fieldIndex < fields.size(); fieldIndex++) {\n+                    String value = fieldIndex == dependentVariableIndex ? classValuesPerRow[i] : randomAlphaOfLength(10);\n+                    row[fieldIndex] = value;\n+                }\n+\n+                String[] processedRow = Arrays.copyOf(row, row.length);\n+                crossValidationSplitter.process(processedRow, this::incrementTrainingDocsCount, this::incrementTestDocsCount);\n+\n+                if (processedRow[dependentVariableIndex] != DataFrameDataExtractor.NULL_VALUE) {\n+                    trainingCountPerRow[i]++;\n+                }\n+            }\n+        }\n+\n+        // We expect each data row to be selected uniformly.\n+        // Thus the fraction of the row count where it's selected for training against the number of runs\n+        // should be close to the training percent, which is set to 0.5", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37fe98ac77e80b0e8ee2c867647f58701ab25dd7"}, "originalPosition": 221}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3782ff99138839e8838c567cbde87cd8c6d0bbf4", "author": {"user": {"login": "dimitris-athanasiou", "name": "Dimitris Athanasiou"}}, "url": "https://github.com/elastic/elasticsearch/commit/3782ff99138839e8838c567cbde87cd8c6d0bbf4", "committedDate": "2020-03-24T14:25:40Z", "message": "[ML] Stratified cross validation split for classification\n\nAs classification now works for multiple classes, randomly\npicking training/test data frame rows is not good enough.\nThis commit introduces a stratified cross validation splitter\nthat maintains the proportion of the each class in the dataset\nin the sample that is used for training the model."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a65578aef1dfb099e98d9cbfeda29366f035b3ba", "author": {"user": {"login": "dimitris-athanasiou", "name": "Dimitris Athanasiou"}}, "url": "https://github.com/elastic/elasticsearch/commit/a65578aef1dfb099e98d9cbfeda29366f035b3ba", "committedDate": "2020-03-24T14:25:40Z", "message": "Set allowPartialResults false"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9afc2b6aad8b16b599cfbf48238f438e1b770683", "author": {"user": {"login": "dimitris-athanasiou", "name": "Dimitris Athanasiou"}}, "url": "https://github.com/elastic/elasticsearch/commit/9afc2b6aad8b16b599cfbf48238f438e1b770683", "committedDate": "2020-03-24T14:45:13Z", "message": "Address comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "37fe98ac77e80b0e8ee2c867647f58701ab25dd7", "author": {"user": {"login": "dimitris-athanasiou", "name": "Dimitris Athanasiou"}}, "url": "https://github.com/elastic/elasticsearch/commit/37fe98ac77e80b0e8ee2c867647f58701ab25dd7", "committedDate": "2020-03-24T13:40:15Z", "message": "[ML] Stratified cross validation split for classification\n\nAs classification now works for multiple classes, randomly\npicking training/test data frame rows is not good enough.\nThis commit introduces a stratified cross validation splitter\nthat maintains the proportion of the each class in the dataset\nin the sample that is used for training the model."}, "afterCommit": {"oid": "9afc2b6aad8b16b599cfbf48238f438e1b770683", "author": {"user": {"login": "dimitris-athanasiou", "name": "Dimitris Athanasiou"}}, "url": "https://github.com/elastic/elasticsearch/commit/9afc2b6aad8b16b599cfbf48238f438e1b770683", "committedDate": "2020-03-24T14:45:13Z", "message": "Address comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwMzgyNDA1", "url": "https://github.com/elastic/elasticsearch/pull/54087#pullrequestreview-380382405", "createdAt": "2020-03-24T14:46:46Z", "commit": {"oid": "9afc2b6aad8b16b599cfbf48238f438e1b770683"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxNDo0Njo0N1rOF6zwLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxNDo0Njo0N1rOF6zwLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzIwOTY0NA==", "bodyText": "@benwtrent I forgot to address your comment before so I squeezed this one here", "url": "https://github.com/elastic/elasticsearch/pull/54087#discussion_r397209644", "createdAt": "2020-03-24T14:46:47Z", "author": {"login": "dimitris-athanasiou"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/dataframe/process/AnalyticsProcessManager.java", "diffHunk": "@@ -324,7 +324,8 @@ private void refreshIndices(String jobId) {\n         );\n         refreshRequest.indicesOptions(IndicesOptions.lenientExpandOpen());\n \n-        LOGGER.debug(\"[{}] Refreshing indices {}\", jobId, Arrays.toString(refreshRequest.indices()));\n+        LOGGER.debug(() -> new ParameterizedMessage(\"[{}] Refreshing indices {}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9afc2b6aad8b16b599cfbf48238f438e1b770683"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwMzg3MjIw", "url": "https://github.com/elastic/elasticsearch/pull/54087#pullrequestreview-380387220", "createdAt": "2020-03-24T14:51:29Z", "commit": {"oid": "9afc2b6aad8b16b599cfbf48238f438e1b770683"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxNDo1MToyOVrOF6z_JQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxNDo1MToyOVrOF6z_JQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzIxMzQ3Nw==", "bodyText": "Ack", "url": "https://github.com/elastic/elasticsearch/pull/54087#discussion_r397213477", "createdAt": "2020-03-24T14:51:29Z", "author": {"login": "przemekwitek"}, "path": "x-pack/plugin/ml/src/test/java/org/elasticsearch/xpack/ml/dataframe/process/crossvalidation/StratifiedCrossValidationSplitterTests.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ml.dataframe.process.crossvalidation;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.ml.dataframe.extractor.DataFrameDataExtractor;\n+import org.junit.Before;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.hamcrest.CoreMatchers.equalTo;\n+import static org.hamcrest.Matchers.closeTo;\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.lessThanOrEqualTo;\n+\n+public class StratifiedCrossValidationSplitterTests extends ESTestCase {\n+\n+    private static final int ROWS_COUNT = 500;\n+\n+    private List<String> fields;\n+    private int dependentVariableIndex;\n+    private String dependentVariable;\n+    private long randomizeSeed;\n+    private Map<String, Long> classCardinalities;\n+    private String[] classValuesPerRow;\n+    private long trainingDocsCount;\n+    private long testDocsCount;\n+\n+    @Before\n+    public void setUpTests() {\n+        int fieldCount = randomIntBetween(1, 5);\n+        fields = new ArrayList<>(fieldCount);\n+        for (int i = 0; i < fieldCount; i++) {\n+            fields.add(randomAlphaOfLength(10));\n+        }\n+        dependentVariableIndex = randomIntBetween(0, fieldCount - 1);\n+        dependentVariable = fields.get(dependentVariableIndex);\n+        randomizeSeed = randomLong();\n+\n+        long classA = 0;\n+        long classB = 0;\n+        long classC = 0;\n+\n+\n+        classValuesPerRow = new String[ROWS_COUNT];\n+        for (int i = 0; i < classValuesPerRow.length; i++) {\n+            double randomDouble = randomDoubleBetween(0.0, 1.0, true);\n+            if (randomDouble < 0.2) {\n+                classValuesPerRow[i] = \"a\";\n+                classA++;\n+            } else if (randomDouble < 0.5) {\n+                classValuesPerRow[i] = \"b\";\n+                classB++;\n+            } else {\n+                classValuesPerRow[i] = \"c\";\n+                classC++;\n+            }\n+        }\n+\n+        classCardinalities = new HashMap<>();\n+        classCardinalities.put(\"a\", classA);\n+        classCardinalities.put(\"b\", classB);\n+        classCardinalities.put(\"c\", classC);\n+    }\n+\n+    public void testConstructor_GivenMissingDependendVariable() {\n+        ElasticsearchException e = expectThrows(ElasticsearchException.class, () -> new StratifiedCrossValidationSplitter(\n+            Collections.emptyList(), \"foo\", Collections.emptyMap(), 100.0, 0));\n+        assertThat(e.getMessage(), equalTo(\"Could not find dependent variable [foo] in fields []\"));\n+    }\n+\n+    public void testProcess_GivenUnknownClass() {\n+        CrossValidationSplitter splitter = createSplitter(100.0);\n+        String[] row = new String[fields.size()];\n+        for (int fieldIndex = 0; fieldIndex < fields.size(); fieldIndex++) {\n+            row[fieldIndex] = randomAlphaOfLength(5);\n+        }\n+        row[dependentVariableIndex] = \"unknown_class\";\n+\n+        IllegalStateException e = expectThrows(IllegalStateException.class,\n+            () -> splitter.process(row, this::incrementTrainingDocsCount, this::incrementTestDocsCount));\n+\n+        assertThat(e.getMessage(), equalTo(\"Unknown class [unknown_class]; expected one of [a, b, c]\"));\n+    }\n+\n+    public void testProcess_GivenRowsWithoutDependentVariableValue() {\n+        CrossValidationSplitter splitter = createSplitter(50.0);\n+\n+        for (int i = 0; i < classValuesPerRow.length; i++) {\n+            String[] row = new String[fields.size()];\n+            for (int fieldIndex = 0; fieldIndex < fields.size(); fieldIndex++) {\n+                String value = fieldIndex == dependentVariableIndex ? DataFrameDataExtractor.NULL_VALUE : randomAlphaOfLength(10);\n+                row[fieldIndex] = value;\n+            }\n+\n+            String[] processedRow = Arrays.copyOf(row, row.length);\n+            splitter.process(processedRow, this::incrementTrainingDocsCount, this::incrementTestDocsCount);\n+\n+            // As all these rows have no dependent variable value, they're not for training and should be unaffected\n+            assertThat(Arrays.equals(processedRow, row), is(true));\n+        }\n+        assertThat(trainingDocsCount, equalTo(0L));\n+        assertThat(testDocsCount, equalTo(500L));\n+    }\n+\n+    public void testProcess_GivenRowsWithDependentVariableValue_AndTrainingPercentIsHundred() {\n+        CrossValidationSplitter splitter = createSplitter(100.0);\n+\n+        for (int i = 0; i < classValuesPerRow.length; i++) {\n+            String[] row = new String[fields.size()];\n+            for (int fieldIndex = 0; fieldIndex < fields.size(); fieldIndex++) {\n+                String value = fieldIndex == dependentVariableIndex ? classValuesPerRow[i] : randomAlphaOfLength(10);\n+                row[fieldIndex] = value;\n+            }\n+\n+            String[] processedRow = Arrays.copyOf(row, row.length);\n+            splitter.process(processedRow, this::incrementTrainingDocsCount, this::incrementTestDocsCount);\n+\n+            // As all these rows have no dependent variable value, they're not for training and should be unaffected\n+            assertThat(Arrays.equals(processedRow, row), is(true));\n+        }\n+        assertThat(trainingDocsCount, equalTo(500L));\n+        assertThat(testDocsCount, equalTo(0L));\n+    }\n+\n+    public void testProcess_GivenRowsWithDependentVariableValue_AndTrainingPercentIsRandom() {\n+        // We don't go too low here to avoid flakiness\n+        double trainingPercent = randomDoubleBetween(50.0, 100.0, true);\n+\n+        CrossValidationSplitter splitter = createSplitter(trainingPercent);\n+\n+        Map<String, Integer> totalRowsPerClass = new HashMap<>();\n+        Map<String, Integer> trainingRowsPerClass = new HashMap<>();\n+\n+        for (String classValue : classCardinalities.keySet()) {\n+            totalRowsPerClass.put(classValue, 0);\n+            trainingRowsPerClass.put(classValue, 0);\n+        }\n+\n+        for (int i = 0; i < classValuesPerRow.length; i++) {\n+            String[] row = new String[fields.size()];\n+            for (int fieldIndex = 0; fieldIndex < fields.size(); fieldIndex++) {\n+                String value = fieldIndex == dependentVariableIndex ? classValuesPerRow[i] : randomAlphaOfLength(10);\n+                row[fieldIndex] = value;\n+            }\n+\n+            String[] processedRow = Arrays.copyOf(row, row.length);\n+            splitter.process(processedRow, this::incrementTrainingDocsCount, this::incrementTestDocsCount);\n+\n+            for (int fieldIndex = 0; fieldIndex < fields.size(); fieldIndex++) {\n+                if (fieldIndex != dependentVariableIndex) {\n+                    assertThat(processedRow[fieldIndex], equalTo(row[fieldIndex]));\n+                }\n+            }\n+\n+            String classValue = row[dependentVariableIndex];\n+            totalRowsPerClass.compute(classValue, (k, v) -> v + 1);\n+\n+            if (DataFrameDataExtractor.NULL_VALUE.equals(processedRow[dependentVariableIndex]) == false) {\n+                assertThat(processedRow[dependentVariableIndex], equalTo(row[dependentVariableIndex]));\n+                trainingRowsPerClass.compute(classValue, (k, v) -> v + 1);\n+            }\n+        }\n+\n+        double trainingFraction = trainingPercent / 100;\n+\n+        // We can assert we're plus/minus 1 from rounding error\n+\n+        double expectedTotalTrainingCount = ROWS_COUNT * trainingFraction;\n+        assertThat(trainingDocsCount + testDocsCount, equalTo((long) ROWS_COUNT));\n+        assertThat(trainingDocsCount, greaterThanOrEqualTo((long) Math.floor(expectedTotalTrainingCount - 1)));\n+        assertThat(trainingDocsCount, lessThanOrEqualTo((long) Math.ceil(expectedTotalTrainingCount + 1)));\n+\n+        for (String classValue : classCardinalities.keySet()) {\n+            double expectedClassTrainingCount = totalRowsPerClass.get(classValue) * trainingFraction;\n+            int classTrainingCount = trainingRowsPerClass.get(classValue);\n+            assertThat((double) classTrainingCount, is(closeTo(expectedClassTrainingCount, 1.0)));\n+        }\n+    }\n+\n+    public void testProcess_SelectsTrainingRowsUniformly() {\n+        double trainingPercent = 50.0;\n+        int runCount = 500;\n+\n+        int[] trainingCountPerRow = new int[ROWS_COUNT];\n+\n+        for (int run = 0; run < runCount; run++) {\n+\n+            randomizeSeed = randomLong();\n+            CrossValidationSplitter crossValidationSplitter = createSplitter(trainingPercent);\n+\n+            for (int i = 0; i < classValuesPerRow.length; i++) {\n+                String[] row = new String[fields.size()];\n+                for (int fieldIndex = 0; fieldIndex < fields.size(); fieldIndex++) {\n+                    String value = fieldIndex == dependentVariableIndex ? classValuesPerRow[i] : randomAlphaOfLength(10);\n+                    row[fieldIndex] = value;\n+                }\n+\n+                String[] processedRow = Arrays.copyOf(row, row.length);\n+                crossValidationSplitter.process(processedRow, this::incrementTrainingDocsCount, this::incrementTestDocsCount);\n+\n+                if (processedRow[dependentVariableIndex] != DataFrameDataExtractor.NULL_VALUE) {\n+                    trainingCountPerRow[i]++;\n+                }\n+            }\n+        }\n+\n+        // We expect each data row to be selected uniformly.\n+        // Thus the fraction of the row count where it's selected for training against the number of runs\n+        // should be close to the training percent, which is set to 0.5", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzE4OTAzNA=="}, "originalCommit": {"oid": "37fe98ac77e80b0e8ee2c867647f58701ab25dd7"}, "originalPosition": 221}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1697, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}