{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI3NDU4NTI0", "number": 57627, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMjoxNDowOVrOECwJxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMjoxNDoyNVrOECwKEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMzIxNTQzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/aggregations/metrics/ScriptedMetricAggregator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMjoxNDowOVrOGfZ0Gg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMjoxNDowOVrOGfZ0Gg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU4MTk3OA==", "bodyText": "haha", "url": "https://github.com/elastic/elasticsearch/pull/57627#discussion_r435581978", "createdAt": "2020-06-04T22:14:09Z", "author": {"login": "talevy"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/metrics/ScriptedMetricAggregator.java", "diffHunk": "@@ -23,38 +23,66 @@\n import org.apache.lucene.search.Scorable;\n import org.apache.lucene.search.ScoreMode;\n import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.lease.Releasables;\n import org.elasticsearch.common.util.CollectionUtils;\n+import org.elasticsearch.common.util.ObjectArray;\n import org.elasticsearch.script.Script;\n import org.elasticsearch.script.ScriptedMetricAggContexts;\n+import org.elasticsearch.script.ScriptedMetricAggContexts.MapScript;\n import org.elasticsearch.search.aggregations.Aggregator;\n import org.elasticsearch.search.aggregations.InternalAggregation;\n import org.elasticsearch.search.aggregations.LeafBucketCollector;\n import org.elasticsearch.search.aggregations.LeafBucketCollectorBase;\n import org.elasticsearch.search.internal.SearchContext;\n+import org.elasticsearch.search.lookup.SearchLookup;\n \n import java.io.IOException;\n+import java.util.HashMap;\n import java.util.Map;\n \n class ScriptedMetricAggregator extends MetricsAggregator {\n+    /**\n+     * Estimated cost to maintain a bucket. Since this aggregator uses\n+     * untracked java collections for its state it is going to both be\n+     * much \"heavier\" than a normal metric aggregator and not going to be\n+     * tracked by the circuit breakers properly. This is sad. So we pick a big\n+     * number and estimate that each bucket costs that. It could be wildly\n+     * inaccurate. We're sort of hoping that the real memory breaker saves\n+     * us here. Or that folks just don't use the aggregation.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22828cc7f0f3de81766bd749adda1cf236a6883d"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMzIxNjE2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/aggregations/metrics/ScriptedMetricAggregator.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMjoxNDoyNVrOGfZ0hQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNTo1Nzo0N1rOGf0O3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU4MjA4NQ==", "bodyText": "what made you choose this number beyond just \"make it large\"?", "url": "https://github.com/elastic/elasticsearch/pull/57627#discussion_r435582085", "createdAt": "2020-06-04T22:14:25Z", "author": {"login": "talevy"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/metrics/ScriptedMetricAggregator.java", "diffHunk": "@@ -23,38 +23,66 @@\n import org.apache.lucene.search.Scorable;\n import org.apache.lucene.search.ScoreMode;\n import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.lease.Releasables;\n import org.elasticsearch.common.util.CollectionUtils;\n+import org.elasticsearch.common.util.ObjectArray;\n import org.elasticsearch.script.Script;\n import org.elasticsearch.script.ScriptedMetricAggContexts;\n+import org.elasticsearch.script.ScriptedMetricAggContexts.MapScript;\n import org.elasticsearch.search.aggregations.Aggregator;\n import org.elasticsearch.search.aggregations.InternalAggregation;\n import org.elasticsearch.search.aggregations.LeafBucketCollector;\n import org.elasticsearch.search.aggregations.LeafBucketCollectorBase;\n import org.elasticsearch.search.internal.SearchContext;\n+import org.elasticsearch.search.lookup.SearchLookup;\n \n import java.io.IOException;\n+import java.util.HashMap;\n import java.util.Map;\n \n class ScriptedMetricAggregator extends MetricsAggregator {\n+    /**\n+     * Estimated cost to maintain a bucket. Since this aggregator uses\n+     * untracked java collections for its state it is going to both be\n+     * much \"heavier\" than a normal metric aggregator and not going to be\n+     * tracked by the circuit breakers properly. This is sad. So we pick a big\n+     * number and estimate that each bucket costs that. It could be wildly\n+     * inaccurate. We're sort of hoping that the real memory breaker saves\n+     * us here. Or that folks just don't use the aggregation.\n+     */\n+    private static final long BUCKET_COST_ESTIMATE = 1024 * 5;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22828cc7f0f3de81766bd749adda1cf236a6883d"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk2ODAwNg==", "bodyText": "Drive-by comment: I wonder if it would make sense to expose this as a configurable option for advanced users?  (perhaps in a followup PR)\nReasoning being that we can't figure it out easily, it's already an advanced agg, so a user might actually be able to give us a reasonable estimate.  And if they don't set it, we fall back to Big Number.\nDunno, might be a terrible idea :)", "url": "https://github.com/elastic/elasticsearch/pull/57627#discussion_r435968006", "createdAt": "2020-06-05T14:41:29Z", "author": {"login": "polyfractal"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/metrics/ScriptedMetricAggregator.java", "diffHunk": "@@ -23,38 +23,66 @@\n import org.apache.lucene.search.Scorable;\n import org.apache.lucene.search.ScoreMode;\n import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.lease.Releasables;\n import org.elasticsearch.common.util.CollectionUtils;\n+import org.elasticsearch.common.util.ObjectArray;\n import org.elasticsearch.script.Script;\n import org.elasticsearch.script.ScriptedMetricAggContexts;\n+import org.elasticsearch.script.ScriptedMetricAggContexts.MapScript;\n import org.elasticsearch.search.aggregations.Aggregator;\n import org.elasticsearch.search.aggregations.InternalAggregation;\n import org.elasticsearch.search.aggregations.LeafBucketCollector;\n import org.elasticsearch.search.aggregations.LeafBucketCollectorBase;\n import org.elasticsearch.search.internal.SearchContext;\n+import org.elasticsearch.search.lookup.SearchLookup;\n \n import java.io.IOException;\n+import java.util.HashMap;\n import java.util.Map;\n \n class ScriptedMetricAggregator extends MetricsAggregator {\n+    /**\n+     * Estimated cost to maintain a bucket. Since this aggregator uses\n+     * untracked java collections for its state it is going to both be\n+     * much \"heavier\" than a normal metric aggregator and not going to be\n+     * tracked by the circuit breakers properly. This is sad. So we pick a big\n+     * number and estimate that each bucket costs that. It could be wildly\n+     * inaccurate. We're sort of hoping that the real memory breaker saves\n+     * us here. Or that folks just don't use the aggregation.\n+     */\n+    private static final long BUCKET_COST_ESTIMATE = 1024 * 5;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU4MjA4NQ=="}, "originalCommit": {"oid": "22828cc7f0f3de81766bd749adda1cf236a6883d"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk5MDQ4Nw==", "bodyText": "The number is the original default \"weight\" of an aggregator. So it is basically what we used to have. I didn't want to just set it to the default weight because it doesn't really have anything to do with it. Other than it is what we were using.\nMaking it configurable is certainly interesting! I don't folks are going to have a good idea of what to set it to without having done some java hacking though. We try not to leak stuff like that to our users. OTOH scripted_metric is pretty bonkers so if we are going to leak that sort of thing anywhere, here is it.", "url": "https://github.com/elastic/elasticsearch/pull/57627#discussion_r435990487", "createdAt": "2020-06-05T15:17:42Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/metrics/ScriptedMetricAggregator.java", "diffHunk": "@@ -23,38 +23,66 @@\n import org.apache.lucene.search.Scorable;\n import org.apache.lucene.search.ScoreMode;\n import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.lease.Releasables;\n import org.elasticsearch.common.util.CollectionUtils;\n+import org.elasticsearch.common.util.ObjectArray;\n import org.elasticsearch.script.Script;\n import org.elasticsearch.script.ScriptedMetricAggContexts;\n+import org.elasticsearch.script.ScriptedMetricAggContexts.MapScript;\n import org.elasticsearch.search.aggregations.Aggregator;\n import org.elasticsearch.search.aggregations.InternalAggregation;\n import org.elasticsearch.search.aggregations.LeafBucketCollector;\n import org.elasticsearch.search.aggregations.LeafBucketCollectorBase;\n import org.elasticsearch.search.internal.SearchContext;\n+import org.elasticsearch.search.lookup.SearchLookup;\n \n import java.io.IOException;\n+import java.util.HashMap;\n import java.util.Map;\n \n class ScriptedMetricAggregator extends MetricsAggregator {\n+    /**\n+     * Estimated cost to maintain a bucket. Since this aggregator uses\n+     * untracked java collections for its state it is going to both be\n+     * much \"heavier\" than a normal metric aggregator and not going to be\n+     * tracked by the circuit breakers properly. This is sad. So we pick a big\n+     * number and estimate that each bucket costs that. It could be wildly\n+     * inaccurate. We're sort of hoping that the real memory breaker saves\n+     * us here. Or that folks just don't use the aggregation.\n+     */\n+    private static final long BUCKET_COST_ESTIMATE = 1024 * 5;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU4MjA4NQ=="}, "originalCommit": {"oid": "22828cc7f0f3de81766bd749adda1cf236a6883d"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAxNDgxMg==", "bodyText": "Yeah I don't feel super great about the idea either.  But then again, we're essentially allowing a user to write a custom map-reduce job that runs on ES, so exposing this kind of accounting isn't too crazy in that context.\nThere's probably a case for forcing the user to estimate it too, since I've definitely seen very bad scripts knock over clusters before (maps holding high cardinality IDs, etc).  I think that's probably a bridge too far, alas :)", "url": "https://github.com/elastic/elasticsearch/pull/57627#discussion_r436014812", "createdAt": "2020-06-05T15:57:47Z", "author": {"login": "polyfractal"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/metrics/ScriptedMetricAggregator.java", "diffHunk": "@@ -23,38 +23,66 @@\n import org.apache.lucene.search.Scorable;\n import org.apache.lucene.search.ScoreMode;\n import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.lease.Releasables;\n import org.elasticsearch.common.util.CollectionUtils;\n+import org.elasticsearch.common.util.ObjectArray;\n import org.elasticsearch.script.Script;\n import org.elasticsearch.script.ScriptedMetricAggContexts;\n+import org.elasticsearch.script.ScriptedMetricAggContexts.MapScript;\n import org.elasticsearch.search.aggregations.Aggregator;\n import org.elasticsearch.search.aggregations.InternalAggregation;\n import org.elasticsearch.search.aggregations.LeafBucketCollector;\n import org.elasticsearch.search.aggregations.LeafBucketCollectorBase;\n import org.elasticsearch.search.internal.SearchContext;\n+import org.elasticsearch.search.lookup.SearchLookup;\n \n import java.io.IOException;\n+import java.util.HashMap;\n import java.util.Map;\n \n class ScriptedMetricAggregator extends MetricsAggregator {\n+    /**\n+     * Estimated cost to maintain a bucket. Since this aggregator uses\n+     * untracked java collections for its state it is going to both be\n+     * much \"heavier\" than a normal metric aggregator and not going to be\n+     * tracked by the circuit breakers properly. This is sad. So we pick a big\n+     * number and estimate that each bucket costs that. It could be wildly\n+     * inaccurate. We're sort of hoping that the real memory breaker saves\n+     * us here. Or that folks just don't use the aggregation.\n+     */\n+    private static final long BUCKET_COST_ESTIMATE = 1024 * 5;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU4MjA4NQ=="}, "originalCommit": {"oid": "22828cc7f0f3de81766bd749adda1cf236a6883d"}, "originalPosition": 31}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3663, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}