{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY0MDAzNTM1", "number": 51135, "title": "Update quantiles document in the index the document belongs to", "bodyText": "Currently, the quantiles document is always indexed into the index pointed by an alias \".ml-state-write\".\nWe plan this alias->index mapping to change over time (as we introduce rollover).\nTherefore, we need to make sure we don't end up with two copies of the quantiles document.\nThis PR achieves that by:\n\nsearching for the doc\neither indexing it into the current write index or updating it in its current index\n\nRelates #29938", "createdAt": "2020-01-17T07:19:47Z", "url": "https://github.com/elastic/elasticsearch/pull/51135", "merged": true, "mergeCommit": {"oid": "7c31d39e84209c049332074111652fc4b8ac15eb"}, "closed": true, "closedAt": "2020-01-24T13:28:44Z", "author": {"login": "przemekwitek"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb7Ocy3gBqjI5NTgwNzg4ODA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb9ea4CgFqTM0NzkzMjYwOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "309f8a3349dbbbe4c68aaa983e3160a949f18de7", "author": {"user": {"login": "przemekwitek", "name": "Przemys\u0142aw Witek"}}, "url": "https://github.com/elastic/elasticsearch/commit/309f8a3349dbbbe4c68aaa983e3160a949f18de7", "committedDate": "2020-01-17T07:16:45Z", "message": "Update quantiles document in the index the document belongs to"}, "afterCommit": {"oid": "df60ecad398de88bd4e461fac1843d203fe0c6b2", "author": {"user": {"login": "przemekwitek", "name": "Przemys\u0142aw Witek"}}, "url": "https://github.com/elastic/elasticsearch/commit/df60ecad398de88bd4e461fac1843d203fe0c6b2", "committedDate": "2020-01-17T13:05:13Z", "message": "Use OriginSettingClient instead of Client"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "df60ecad398de88bd4e461fac1843d203fe0c6b2", "author": {"user": {"login": "przemekwitek", "name": "Przemys\u0142aw Witek"}}, "url": "https://github.com/elastic/elasticsearch/commit/df60ecad398de88bd4e461fac1843d203fe0c6b2", "committedDate": "2020-01-17T13:05:13Z", "message": "Use OriginSettingClient instead of Client"}, "afterCommit": {"oid": "86d284b16bf180d1d16711083489a9590bc33e58", "author": {"user": {"login": "przemekwitek", "name": "Przemys\u0142aw Witek"}}, "url": "https://github.com/elastic/elasticsearch/commit/86d284b16bf180d1d16711083489a9590bc33e58", "committedDate": "2020-01-21T11:09:49Z", "message": "Use OriginSettingClient instead of Client"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "86d284b16bf180d1d16711083489a9590bc33e58", "author": {"user": {"login": "przemekwitek", "name": "Przemys\u0142aw Witek"}}, "url": "https://github.com/elastic/elasticsearch/commit/86d284b16bf180d1d16711083489a9590bc33e58", "committedDate": "2020-01-21T11:09:49Z", "message": "Use OriginSettingClient instead of Client"}, "afterCommit": {"oid": "c2505cf660ca7b7f81ad8c36cbb1447d84b01fbd", "author": {"user": {"login": "przemekwitek", "name": "Przemys\u0142aw Witek"}}, "url": "https://github.com/elastic/elasticsearch/commit/c2505cf660ca7b7f81ad8c36cbb1447d84b01fbd", "committedDate": "2020-01-21T11:10:22Z", "message": "Use OriginSettingClient instead of Client"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2NTY1NzM1", "url": "https://github.com/elastic/elasticsearch/pull/51135#pullrequestreview-346565735", "createdAt": "2020-01-22T12:57:21Z", "commit": {"oid": "c2505cf660ca7b7f81ad8c36cbb1447d84b01fbd"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxMjo1NzoyMVrOFgbI-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxMzowMTowNlrOFgbPdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU0MzQxOA==", "bodyText": "Minor optimizations (not super necessary).\nI am not 100% if the IdsQueryBuilder automatically is wrapped in a filter or not.\nBut, we should do something so that the docs are not scored. Possibly wrap in a constant score query?\nAlso, trackTotalHits could be false", "url": "https://github.com/elastic/elasticsearch/pull/51135#discussion_r369543418", "createdAt": "2020-01-22T12:57:21Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/job/persistence/JobResultsPersister.java", "diffHunk": "@@ -255,17 +259,50 @@ public void persistCategoryDefinition(CategoryDefinition category, Supplier<Bool\n      * Persist the quantiles (blocking)\n      */\n     public void persistQuantiles(Quantiles quantiles, Supplier<Boolean> shouldRetry) {\n-        Persistable persistable = new Persistable(quantiles.getJobId(), quantiles, Quantiles.documentId(quantiles.getJobId()));\n-        persistable.persist(AnomalyDetectorsIndex.jobStateIndexWriteAlias(), shouldRetry);\n+        String quantilesDocId = Quantiles.documentId(quantiles.getJobId());\n+\n+        SearchRequest searchRequest =\n+            new SearchRequest(AnomalyDetectorsIndex.jobStateIndexPattern())\n+                .source(new SearchSourceBuilder().size(1).query(new IdsQueryBuilder().addIds(quantilesDocId)));\n+        SearchResponse searchResponse = client.search(searchRequest).actionGet();\n+        String indexOrAlias = AnomalyDetectorsIndex.jobStateIndexWriteAlias();\n+        if (searchResponse.getHits().getHits().length > 0) {\n+            indexOrAlias = searchResponse.getHits().getHits()[0].getIndex();\n+        }\n+\n+        Persistable persistable = new Persistable(indexOrAlias, quantiles.getJobId(), quantiles, quantilesDocId);\n+        persistable.persist(shouldRetry);\n     }\n \n     /**\n      * Persist the quantiles (async)\n      */\n     public void persistQuantiles(Quantiles quantiles, WriteRequest.RefreshPolicy refreshPolicy, ActionListener<IndexResponse> listener) {\n-        Persistable persistable = new Persistable(quantiles.getJobId(), quantiles, Quantiles.documentId(quantiles.getJobId()));\n-        persistable.setRefreshPolicy(refreshPolicy);\n-        persistable.persist(AnomalyDetectorsIndex.jobStateIndexWriteAlias(), listener);\n+        String quantilesDocId = Quantiles.documentId(quantiles.getJobId());\n+\n+        // Step 2: Create or update the quantiles document:\n+        //   - if the document did not exist, create the new one in the current write index\n+        //   - if the document did exist, update it in the index where it resides (not necessarily the current write index)\n+        ActionListener<SearchResponse> searchFormerQuantilesDocListener = ActionListener.wrap(\n+            searchResponse -> {\n+                String indexOrAlias = AnomalyDetectorsIndex.jobStateIndexWriteAlias();\n+                if (searchResponse.getHits().getHits().length > 0) {\n+                    indexOrAlias = searchResponse.getHits().getHits()[0].getIndex();\n+                }\n+\n+                Persistable persistable = new Persistable(indexOrAlias, quantiles.getJobId(), quantiles, quantilesDocId);\n+                persistable.setRefreshPolicy(refreshPolicy);\n+                persistable.persist(listener);\n+            },\n+            listener::onFailure\n+        );\n+\n+        // Step 1: Search for existing quantiles document in .ml-state*\n+        SearchRequest searchRequest =\n+            new SearchRequest(AnomalyDetectorsIndex.jobStateIndexPattern())\n+                .source(new SearchSourceBuilder().size(1).query(new IdsQueryBuilder().addIds(quantilesDocId)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c2505cf660ca7b7f81ad8c36cbb1447d84b01fbd"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU0NTA3Ng==", "bodyText": "I am not 100% sure about this.\nThis means that if we fail to search for the ID, the job will be flagged as failed immediately and stop running.\nI wonder if we should do retries on the synchronous search as we do for the persistence?", "url": "https://github.com/elastic/elasticsearch/pull/51135#discussion_r369545076", "createdAt": "2020-01-22T13:01:06Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/job/persistence/JobResultsPersister.java", "diffHunk": "@@ -255,17 +259,50 @@ public void persistCategoryDefinition(CategoryDefinition category, Supplier<Bool\n      * Persist the quantiles (blocking)\n      */\n     public void persistQuantiles(Quantiles quantiles, Supplier<Boolean> shouldRetry) {\n-        Persistable persistable = new Persistable(quantiles.getJobId(), quantiles, Quantiles.documentId(quantiles.getJobId()));\n-        persistable.persist(AnomalyDetectorsIndex.jobStateIndexWriteAlias(), shouldRetry);\n+        String quantilesDocId = Quantiles.documentId(quantiles.getJobId());\n+\n+        SearchRequest searchRequest =\n+            new SearchRequest(AnomalyDetectorsIndex.jobStateIndexPattern())\n+                .source(new SearchSourceBuilder().size(1).query(new IdsQueryBuilder().addIds(quantilesDocId)));\n+        SearchResponse searchResponse = client.search(searchRequest).actionGet();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c2505cf660ca7b7f81ad8c36cbb1447d84b01fbd"}, "originalPosition": 56}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7be3b332e3e15e5707a5f617d93d780ae11735bb", "author": {"user": {"login": "przemekwitek", "name": "Przemys\u0142aw Witek"}}, "url": "https://github.com/elastic/elasticsearch/commit/7be3b332e3e15e5707a5f617d93d780ae11735bb", "committedDate": "2020-01-23T08:25:13Z", "message": "Update quantiles document in the index the document belongs to"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5649ee9aa8c80b1e0d4efa64df8be8c8fb135fbb", "author": {"user": {"login": "przemekwitek", "name": "Przemys\u0142aw Witek"}}, "url": "https://github.com/elastic/elasticsearch/commit/5649ee9aa8c80b1e0d4efa64df8be8c8fb135fbb", "committedDate": "2020-01-23T08:25:13Z", "message": "Use OriginSettingClient instead of Client"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6f09cac6138531978b6ccd2a51a28cdaa80a3de1", "author": {"user": {"login": "przemekwitek", "name": "Przemys\u0142aw Witek"}}, "url": "https://github.com/elastic/elasticsearch/commit/6f09cac6138531978b6ccd2a51a28cdaa80a3de1", "committedDate": "2020-01-23T16:06:31Z", "message": "Apply review comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c2505cf660ca7b7f81ad8c36cbb1447d84b01fbd", "author": {"user": {"login": "przemekwitek", "name": "Przemys\u0142aw Witek"}}, "url": "https://github.com/elastic/elasticsearch/commit/c2505cf660ca7b7f81ad8c36cbb1447d84b01fbd", "committedDate": "2020-01-21T11:10:22Z", "message": "Use OriginSettingClient instead of Client"}, "afterCommit": {"oid": "6f09cac6138531978b6ccd2a51a28cdaa80a3de1", "author": {"user": {"login": "przemekwitek", "name": "Przemys\u0142aw Witek"}}, "url": "https://github.com/elastic/elasticsearch/commit/6f09cac6138531978b6ccd2a51a28cdaa80a3de1", "committedDate": "2020-01-23T16:06:31Z", "message": "Apply review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3NDkzMDc5", "url": "https://github.com/elastic/elasticsearch/pull/51135#pullrequestreview-347493079", "createdAt": "2020-01-23T17:53:44Z", "commit": {"oid": "6f09cac6138531978b6ccd2a51a28cdaa80a3de1"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxNzo1Mzo0NFrOFhHS_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxNzo1NzowMlrOFhHY2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI2Njg3Nw==", "bodyText": "I thought that client.search threw if the search request failed.", "url": "https://github.com/elastic/elasticsearch/pull/51135#discussion_r370266877", "createdAt": "2020-01-23T17:53:44Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/utils/persistence/ResultsPersisterService.java", "diffHunk": "@@ -85,29 +94,77 @@ public BulkResponse bulkIndexWithRetry(BulkRequest bulkRequest,\n                                            String jobId,\n                                            Supplier<Boolean> shouldRetry,\n                                            Consumer<String> msgHandler) {\n-        int currentMin = MIN_RETRY_SLEEP_MILLIS;\n-        int currentMax = MIN_RETRY_SLEEP_MILLIS;\n-        int currentAttempt = 0;\n-        BulkResponse bulkResponse = null;\n-        final Random random = Randomness.get();\n-        while(currentAttempt <= maxFailureRetries) {\n-            bulkResponse = bulkIndex(bulkRequest);\n+        RetryContext retryContext = new RetryContext(jobId, shouldRetry, msgHandler);\n+        while (true) {\n+            BulkResponse bulkResponse = client.bulk(bulkRequest).actionGet();\n             if (bulkResponse.hasFailures() == false) {\n                 return bulkResponse;\n             }\n+\n+            retryContext.nextIteration(\"index\", bulkResponse.buildFailureMessage());\n+\n+            // We should only retry the docs that failed.\n+            bulkRequest = buildNewRequestFromFailures(bulkRequest, bulkResponse);\n+        }\n+    }\n+\n+    public SearchResponse searchWithRetry(SearchRequest searchRequest,\n+                                          String jobId,\n+                                          Supplier<Boolean> shouldRetry,\n+                                          Consumer<String> msgHandler) {\n+        RetryContext retryContext = new RetryContext(jobId, shouldRetry, msgHandler);\n+        while (true) {\n+            SearchResponse searchResponse = client.search(searchRequest).actionGet();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f09cac6138531978b6ccd2a51a28cdaa80a3de1"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI2ODE5OA==", "bodyText": "given the message above, the log line is [job_id] [job_id] seems redundant.", "url": "https://github.com/elastic/elasticsearch/pull/51135#discussion_r370268198", "createdAt": "2020-01-23T17:56:40Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/utils/persistence/ResultsPersisterService.java", "diffHunk": "@@ -85,29 +94,77 @@ public BulkResponse bulkIndexWithRetry(BulkRequest bulkRequest,\n                                            String jobId,\n                                            Supplier<Boolean> shouldRetry,\n                                            Consumer<String> msgHandler) {\n-        int currentMin = MIN_RETRY_SLEEP_MILLIS;\n-        int currentMax = MIN_RETRY_SLEEP_MILLIS;\n-        int currentAttempt = 0;\n-        BulkResponse bulkResponse = null;\n-        final Random random = Randomness.get();\n-        while(currentAttempt <= maxFailureRetries) {\n-            bulkResponse = bulkIndex(bulkRequest);\n+        RetryContext retryContext = new RetryContext(jobId, shouldRetry, msgHandler);\n+        while (true) {\n+            BulkResponse bulkResponse = client.bulk(bulkRequest).actionGet();\n             if (bulkResponse.hasFailures() == false) {\n                 return bulkResponse;\n             }\n+\n+            retryContext.nextIteration(\"index\", bulkResponse.buildFailureMessage());\n+\n+            // We should only retry the docs that failed.\n+            bulkRequest = buildNewRequestFromFailures(bulkRequest, bulkResponse);\n+        }\n+    }\n+\n+    public SearchResponse searchWithRetry(SearchRequest searchRequest,\n+                                          String jobId,\n+                                          Supplier<Boolean> shouldRetry,\n+                                          Consumer<String> msgHandler) {\n+        RetryContext retryContext = new RetryContext(jobId, shouldRetry, msgHandler);\n+        while (true) {\n+            SearchResponse searchResponse = client.search(searchRequest).actionGet();\n+            if (searchResponse.status().getStatus() == 200) {\n+                return searchResponse;\n+            }\n+\n+            retryContext.nextIteration(\"search\", searchResponse.status().toString());\n+        }\n+    }\n+\n+    /**\n+     * {@link RetryContext} object handles logic that is executed between consecutive retries of an action.\n+     *\n+     * Note that it does not execute the action itself.\n+     */\n+    private class RetryContext {\n+\n+        final String jobId;\n+        final Supplier<Boolean> shouldRetry;\n+        final Consumer<String> msgHandler;\n+        final Random random = Randomness.get();\n+\n+        int currentAttempt = 0;\n+        int currentMin = MIN_RETRY_SLEEP_MILLIS;\n+        int currentMax = MIN_RETRY_SLEEP_MILLIS;\n+\n+        RetryContext(String jobId, Supplier<Boolean> shouldRetry, Consumer<String> msgHandler) {\n+            this.jobId = jobId;\n+            this.shouldRetry = shouldRetry;\n+            this.msgHandler = msgHandler;\n+        }\n+\n+        void nextIteration(String actionName, String failureMessage) {\n+            currentAttempt++;\n+\n+            // If the outside conditions have changed and retries are no longer needed, do not retry.\n             if (shouldRetry.get() == false) {\n-                throw new ElasticsearchException(\"[{}] failed to index all results. {}\", jobId, bulkResponse.buildFailureMessage());\n+                String msg = new ParameterizedMessage(\n+                    \"[{}] should not retry {} after [{}] attempts. {}\", jobId, actionName, currentAttempt, failureMessage)\n+                    .getFormattedMessage();\n+                LOGGER.info(() -> new ParameterizedMessage(\"[{}] {}\", jobId, msg));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f09cac6138531978b6ccd2a51a28cdaa80a3de1"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI2ODM3OQ==", "bodyText": "given the message above, the log line is [job_id] [job_id] seems redundant.", "url": "https://github.com/elastic/elasticsearch/pull/51135#discussion_r370268379", "createdAt": "2020-01-23T17:57:02Z", "author": {"login": "benwtrent"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/utils/persistence/ResultsPersisterService.java", "diffHunk": "@@ -85,29 +94,77 @@ public BulkResponse bulkIndexWithRetry(BulkRequest bulkRequest,\n                                            String jobId,\n                                            Supplier<Boolean> shouldRetry,\n                                            Consumer<String> msgHandler) {\n-        int currentMin = MIN_RETRY_SLEEP_MILLIS;\n-        int currentMax = MIN_RETRY_SLEEP_MILLIS;\n-        int currentAttempt = 0;\n-        BulkResponse bulkResponse = null;\n-        final Random random = Randomness.get();\n-        while(currentAttempt <= maxFailureRetries) {\n-            bulkResponse = bulkIndex(bulkRequest);\n+        RetryContext retryContext = new RetryContext(jobId, shouldRetry, msgHandler);\n+        while (true) {\n+            BulkResponse bulkResponse = client.bulk(bulkRequest).actionGet();\n             if (bulkResponse.hasFailures() == false) {\n                 return bulkResponse;\n             }\n+\n+            retryContext.nextIteration(\"index\", bulkResponse.buildFailureMessage());\n+\n+            // We should only retry the docs that failed.\n+            bulkRequest = buildNewRequestFromFailures(bulkRequest, bulkResponse);\n+        }\n+    }\n+\n+    public SearchResponse searchWithRetry(SearchRequest searchRequest,\n+                                          String jobId,\n+                                          Supplier<Boolean> shouldRetry,\n+                                          Consumer<String> msgHandler) {\n+        RetryContext retryContext = new RetryContext(jobId, shouldRetry, msgHandler);\n+        while (true) {\n+            SearchResponse searchResponse = client.search(searchRequest).actionGet();\n+            if (searchResponse.status().getStatus() == 200) {\n+                return searchResponse;\n+            }\n+\n+            retryContext.nextIteration(\"search\", searchResponse.status().toString());\n+        }\n+    }\n+\n+    /**\n+     * {@link RetryContext} object handles logic that is executed between consecutive retries of an action.\n+     *\n+     * Note that it does not execute the action itself.\n+     */\n+    private class RetryContext {\n+\n+        final String jobId;\n+        final Supplier<Boolean> shouldRetry;\n+        final Consumer<String> msgHandler;\n+        final Random random = Randomness.get();\n+\n+        int currentAttempt = 0;\n+        int currentMin = MIN_RETRY_SLEEP_MILLIS;\n+        int currentMax = MIN_RETRY_SLEEP_MILLIS;\n+\n+        RetryContext(String jobId, Supplier<Boolean> shouldRetry, Consumer<String> msgHandler) {\n+            this.jobId = jobId;\n+            this.shouldRetry = shouldRetry;\n+            this.msgHandler = msgHandler;\n+        }\n+\n+        void nextIteration(String actionName, String failureMessage) {\n+            currentAttempt++;\n+\n+            // If the outside conditions have changed and retries are no longer needed, do not retry.\n             if (shouldRetry.get() == false) {\n-                throw new ElasticsearchException(\"[{}] failed to index all results. {}\", jobId, bulkResponse.buildFailureMessage());\n+                String msg = new ParameterizedMessage(\n+                    \"[{}] should not retry {} after [{}] attempts. {}\", jobId, actionName, currentAttempt, failureMessage)\n+                    .getFormattedMessage();\n+                LOGGER.info(() -> new ParameterizedMessage(\"[{}] {}\", jobId, msg));\n+                throw new ElasticsearchException(msg);\n             }\n+\n+            // If the configured maximum number of retries has been reached, do not retry.\n             if (currentAttempt > maxFailureRetries) {\n-                LOGGER.warn(\"[{}] failed to index after [{}] attempts. Setting [xpack.ml.persist_results_max_retries] was reduced\",\n-                    jobId,\n-                    currentAttempt);\n-                throw new ElasticsearchException(\"[{}] failed to index all results after [{}] attempts. {}\",\n-                    jobId,\n-                    currentAttempt,\n-                    bulkResponse.buildFailureMessage());\n+                String msg = new ParameterizedMessage(\n+                    \"[{}] failed to {} after [{}] attempts. {}\", jobId, actionName, currentAttempt, failureMessage).getFormattedMessage();\n+                LOGGER.warn(() -> new ParameterizedMessage(\"[{}] {}\", jobId, msg));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f09cac6138531978b6ccd2a51a28cdaa80a3de1"}, "originalPosition": 138}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "af96027c0491067eaad182d1c2f57488cc7ed3fb", "author": {"user": {"login": "przemekwitek", "name": "Przemys\u0142aw Witek"}}, "url": "https://github.com/elastic/elasticsearch/commit/af96027c0491067eaad182d1c2f57488cc7ed3fb", "committedDate": "2020-01-24T09:00:53Z", "message": "Apply more review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3Nzc5ODU4", "url": "https://github.com/elastic/elasticsearch/pull/51135#pullrequestreview-347779858", "createdAt": "2020-01-24T07:14:45Z", "commit": {"oid": "6f09cac6138531978b6ccd2a51a28cdaa80a3de1"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwNzoxNDo0NlrOFhVa7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwOTowNjoyMFrOFhXZSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ5ODI4Ng==", "bodyText": "Done.", "url": "https://github.com/elastic/elasticsearch/pull/51135#discussion_r370498286", "createdAt": "2020-01-24T07:14:46Z", "author": {"login": "przemekwitek"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/utils/persistence/ResultsPersisterService.java", "diffHunk": "@@ -85,29 +94,77 @@ public BulkResponse bulkIndexWithRetry(BulkRequest bulkRequest,\n                                            String jobId,\n                                            Supplier<Boolean> shouldRetry,\n                                            Consumer<String> msgHandler) {\n-        int currentMin = MIN_RETRY_SLEEP_MILLIS;\n-        int currentMax = MIN_RETRY_SLEEP_MILLIS;\n-        int currentAttempt = 0;\n-        BulkResponse bulkResponse = null;\n-        final Random random = Randomness.get();\n-        while(currentAttempt <= maxFailureRetries) {\n-            bulkResponse = bulkIndex(bulkRequest);\n+        RetryContext retryContext = new RetryContext(jobId, shouldRetry, msgHandler);\n+        while (true) {\n+            BulkResponse bulkResponse = client.bulk(bulkRequest).actionGet();\n             if (bulkResponse.hasFailures() == false) {\n                 return bulkResponse;\n             }\n+\n+            retryContext.nextIteration(\"index\", bulkResponse.buildFailureMessage());\n+\n+            // We should only retry the docs that failed.\n+            bulkRequest = buildNewRequestFromFailures(bulkRequest, bulkResponse);\n+        }\n+    }\n+\n+    public SearchResponse searchWithRetry(SearchRequest searchRequest,\n+                                          String jobId,\n+                                          Supplier<Boolean> shouldRetry,\n+                                          Consumer<String> msgHandler) {\n+        RetryContext retryContext = new RetryContext(jobId, shouldRetry, msgHandler);\n+        while (true) {\n+            SearchResponse searchResponse = client.search(searchRequest).actionGet();\n+            if (searchResponse.status().getStatus() == 200) {\n+                return searchResponse;\n+            }\n+\n+            retryContext.nextIteration(\"search\", searchResponse.status().toString());\n+        }\n+    }\n+\n+    /**\n+     * {@link RetryContext} object handles logic that is executed between consecutive retries of an action.\n+     *\n+     * Note that it does not execute the action itself.\n+     */\n+    private class RetryContext {\n+\n+        final String jobId;\n+        final Supplier<Boolean> shouldRetry;\n+        final Consumer<String> msgHandler;\n+        final Random random = Randomness.get();\n+\n+        int currentAttempt = 0;\n+        int currentMin = MIN_RETRY_SLEEP_MILLIS;\n+        int currentMax = MIN_RETRY_SLEEP_MILLIS;\n+\n+        RetryContext(String jobId, Supplier<Boolean> shouldRetry, Consumer<String> msgHandler) {\n+            this.jobId = jobId;\n+            this.shouldRetry = shouldRetry;\n+            this.msgHandler = msgHandler;\n+        }\n+\n+        void nextIteration(String actionName, String failureMessage) {\n+            currentAttempt++;\n+\n+            // If the outside conditions have changed and retries are no longer needed, do not retry.\n             if (shouldRetry.get() == false) {\n-                throw new ElasticsearchException(\"[{}] failed to index all results. {}\", jobId, bulkResponse.buildFailureMessage());\n+                String msg = new ParameterizedMessage(\n+                    \"[{}] should not retry {} after [{}] attempts. {}\", jobId, actionName, currentAttempt, failureMessage)\n+                    .getFormattedMessage();\n+                LOGGER.info(() -> new ParameterizedMessage(\"[{}] {}\", jobId, msg));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI2ODE5OA=="}, "originalCommit": {"oid": "6f09cac6138531978b6ccd2a51a28cdaa80a3de1"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ5ODMwNA==", "bodyText": "Done.", "url": "https://github.com/elastic/elasticsearch/pull/51135#discussion_r370498304", "createdAt": "2020-01-24T07:14:51Z", "author": {"login": "przemekwitek"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/utils/persistence/ResultsPersisterService.java", "diffHunk": "@@ -85,29 +94,77 @@ public BulkResponse bulkIndexWithRetry(BulkRequest bulkRequest,\n                                            String jobId,\n                                            Supplier<Boolean> shouldRetry,\n                                            Consumer<String> msgHandler) {\n-        int currentMin = MIN_RETRY_SLEEP_MILLIS;\n-        int currentMax = MIN_RETRY_SLEEP_MILLIS;\n-        int currentAttempt = 0;\n-        BulkResponse bulkResponse = null;\n-        final Random random = Randomness.get();\n-        while(currentAttempt <= maxFailureRetries) {\n-            bulkResponse = bulkIndex(bulkRequest);\n+        RetryContext retryContext = new RetryContext(jobId, shouldRetry, msgHandler);\n+        while (true) {\n+            BulkResponse bulkResponse = client.bulk(bulkRequest).actionGet();\n             if (bulkResponse.hasFailures() == false) {\n                 return bulkResponse;\n             }\n+\n+            retryContext.nextIteration(\"index\", bulkResponse.buildFailureMessage());\n+\n+            // We should only retry the docs that failed.\n+            bulkRequest = buildNewRequestFromFailures(bulkRequest, bulkResponse);\n+        }\n+    }\n+\n+    public SearchResponse searchWithRetry(SearchRequest searchRequest,\n+                                          String jobId,\n+                                          Supplier<Boolean> shouldRetry,\n+                                          Consumer<String> msgHandler) {\n+        RetryContext retryContext = new RetryContext(jobId, shouldRetry, msgHandler);\n+        while (true) {\n+            SearchResponse searchResponse = client.search(searchRequest).actionGet();\n+            if (searchResponse.status().getStatus() == 200) {\n+                return searchResponse;\n+            }\n+\n+            retryContext.nextIteration(\"search\", searchResponse.status().toString());\n+        }\n+    }\n+\n+    /**\n+     * {@link RetryContext} object handles logic that is executed between consecutive retries of an action.\n+     *\n+     * Note that it does not execute the action itself.\n+     */\n+    private class RetryContext {\n+\n+        final String jobId;\n+        final Supplier<Boolean> shouldRetry;\n+        final Consumer<String> msgHandler;\n+        final Random random = Randomness.get();\n+\n+        int currentAttempt = 0;\n+        int currentMin = MIN_RETRY_SLEEP_MILLIS;\n+        int currentMax = MIN_RETRY_SLEEP_MILLIS;\n+\n+        RetryContext(String jobId, Supplier<Boolean> shouldRetry, Consumer<String> msgHandler) {\n+            this.jobId = jobId;\n+            this.shouldRetry = shouldRetry;\n+            this.msgHandler = msgHandler;\n+        }\n+\n+        void nextIteration(String actionName, String failureMessage) {\n+            currentAttempt++;\n+\n+            // If the outside conditions have changed and retries are no longer needed, do not retry.\n             if (shouldRetry.get() == false) {\n-                throw new ElasticsearchException(\"[{}] failed to index all results. {}\", jobId, bulkResponse.buildFailureMessage());\n+                String msg = new ParameterizedMessage(\n+                    \"[{}] should not retry {} after [{}] attempts. {}\", jobId, actionName, currentAttempt, failureMessage)\n+                    .getFormattedMessage();\n+                LOGGER.info(() -> new ParameterizedMessage(\"[{}] {}\", jobId, msg));\n+                throw new ElasticsearchException(msg);\n             }\n+\n+            // If the configured maximum number of retries has been reached, do not retry.\n             if (currentAttempt > maxFailureRetries) {\n-                LOGGER.warn(\"[{}] failed to index after [{}] attempts. Setting [xpack.ml.persist_results_max_retries] was reduced\",\n-                    jobId,\n-                    currentAttempt);\n-                throw new ElasticsearchException(\"[{}] failed to index all results after [{}] attempts. {}\",\n-                    jobId,\n-                    currentAttempt,\n-                    bulkResponse.buildFailureMessage());\n+                String msg = new ParameterizedMessage(\n+                    \"[{}] failed to {} after [{}] attempts. {}\", jobId, actionName, currentAttempt, failureMessage).getFormattedMessage();\n+                LOGGER.warn(() -> new ParameterizedMessage(\"[{}] {}\", jobId, msg));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI2ODM3OQ=="}, "originalCommit": {"oid": "6f09cac6138531978b6ccd2a51a28cdaa80a3de1"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDUzMDYzNQ==", "bodyText": "Done (catching ElasticsearchException).", "url": "https://github.com/elastic/elasticsearch/pull/51135#discussion_r370530635", "createdAt": "2020-01-24T09:06:20Z", "author": {"login": "przemekwitek"}, "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/utils/persistence/ResultsPersisterService.java", "diffHunk": "@@ -85,29 +94,77 @@ public BulkResponse bulkIndexWithRetry(BulkRequest bulkRequest,\n                                            String jobId,\n                                            Supplier<Boolean> shouldRetry,\n                                            Consumer<String> msgHandler) {\n-        int currentMin = MIN_RETRY_SLEEP_MILLIS;\n-        int currentMax = MIN_RETRY_SLEEP_MILLIS;\n-        int currentAttempt = 0;\n-        BulkResponse bulkResponse = null;\n-        final Random random = Randomness.get();\n-        while(currentAttempt <= maxFailureRetries) {\n-            bulkResponse = bulkIndex(bulkRequest);\n+        RetryContext retryContext = new RetryContext(jobId, shouldRetry, msgHandler);\n+        while (true) {\n+            BulkResponse bulkResponse = client.bulk(bulkRequest).actionGet();\n             if (bulkResponse.hasFailures() == false) {\n                 return bulkResponse;\n             }\n+\n+            retryContext.nextIteration(\"index\", bulkResponse.buildFailureMessage());\n+\n+            // We should only retry the docs that failed.\n+            bulkRequest = buildNewRequestFromFailures(bulkRequest, bulkResponse);\n+        }\n+    }\n+\n+    public SearchResponse searchWithRetry(SearchRequest searchRequest,\n+                                          String jobId,\n+                                          Supplier<Boolean> shouldRetry,\n+                                          Consumer<String> msgHandler) {\n+        RetryContext retryContext = new RetryContext(jobId, shouldRetry, msgHandler);\n+        while (true) {\n+            SearchResponse searchResponse = client.search(searchRequest).actionGet();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI2Njg3Nw=="}, "originalCommit": {"oid": "6f09cac6138531978b6ccd2a51a28cdaa80a3de1"}, "originalPosition": 83}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3OTMyNjA4", "url": "https://github.com/elastic/elasticsearch/pull/51135#pullrequestreview-347932608", "createdAt": "2020-01-24T12:50:49Z", "commit": {"oid": "af96027c0491067eaad182d1c2f57488cc7ed3fb"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2956, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}