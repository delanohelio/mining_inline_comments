{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY1MzcwNjA1", "number": 51256, "title": "Simplify Snapshot Initialization", "bodyText": "We were loading RepositoryData twice during snapshot initialization,\nredundantly checking if a snapshot existed already.\nThe first snapshot existence check is somewhat redundant because a snapshot could be\ncreated between loading RepositoryData and updating the cluster state with the INIT\nstate snapshot entry.\nAlso, it is much safer to do the subsequent checks for index existence in the repo and\nand the presence of old version snapshots once the INIT state entry prevents further\nsnapshots from being created concurrently.\nWhile the current state of things will never lead to corruption on a concurrent snapshot\ncreation, it could result in a situation (though unlikely) where all the snapshot's work\nis done on the data nodes, only to find out that the repository generation was off during\nsnapshot finalization, failing there and leaving a bunch of dead data in the repository\nthat won't be used in a subsequent snapshot (because the shard generation was never referenced\ndue to the failed snapshot finalization).\nBwC should not be a concern here since the init stage only has meaning for a single master node as any init stage snapshot is removed on master-failover so creating the placeholder entry with repo generation -2 makes no difference here..\nNote: This is a step on the way to parallel repository operations by making snapshot related CS\nand repo related CS more tightly correlated.", "createdAt": "2020-01-21T15:38:50Z", "url": "https://github.com/elastic/elasticsearch/pull/51256", "merged": true, "mergeCommit": {"oid": "6736cf51bd1e1cf96b6003078d7ca9740d2d176e"}, "closed": true, "closedAt": "2020-01-23T11:32:42Z", "author": {"login": "original-brownbear"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb8i6ftgH2gAyMzY1MzcwNjA1OjIzM2M3NDZhMGQ5ODE0YzA3NDg4MjBmZThiZGJlMzk5YmJkZjgwMjA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb84Z6FAH2gAyMzY1MzcwNjA1OjZkYTI1NjUxNzY2MmQyYzIzZGY2N2RmYWMyZDA0ZDE3YWMwYWY5YzI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "233c746a0d9814c0748820fe8bdbe399bbdf8020", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/233c746a0d9814c0748820fe8bdbe399bbdf8020", "committedDate": "2020-01-21T15:31:03Z", "message": "Simplify Snapshot Initialization\n\nWe were loading `RepositoryData` twice during snapshot initialization,\nredundantly checking if a snapshot existed already.\nThe first snapshot existence check is somewhat redundant because a snapshot could be\ncreated between loading `RepositoryData` and updating the cluster state with the `INIT`\nstate snapshot entry.\nAlso, it is much safer to do the subsequent checks for index existence in the repo and\nand the presence of old version snapshots once the `INIT` state entry prevents further\nsnapshots from being created concurrently.\nWhile the current state of things will never lead to corruption on a concurrent snapshot\ncreation, it could result in a situation (though unlikely) where all the snapshot's work\nis done on the data nodes, only to find out that the repository generation was off during\nsnapshot finalization, failing there and leaving a bunch of dead data in the repository\nthat won't be used in a subsequent snapshot (because the shard generation was never referenced\ndue to the failed snapshot finalization).\n\nNote: This is a step on the way to parallel repository operations by making snapshot related CS\nand repo related CS more tightly correlated."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1ffd8077f85855380d341659b2ff53a373d2def6", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/1ffd8077f85855380d341659b2ff53a373d2def6", "committedDate": "2020-01-21T15:40:40Z", "message": "cs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7ca5ef3d193a2bb5d45085ed085169d562b604d5", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/7ca5ef3d193a2bb5d45085ed085169d562b604d5", "committedDate": "2020-01-21T15:45:18Z", "message": "shorter"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2Njc4Nzkx", "url": "https://github.com/elastic/elasticsearch/pull/51256#pullrequestreview-346678791", "createdAt": "2020-01-22T15:31:12Z", "commit": {"oid": "7ca5ef3d193a2bb5d45085ed085169d562b604d5"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxNTozMToxM1rOFggbNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxNTozNTo1OVrOFggmnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYzMDAwNw==", "bodyText": "I find this a bit more readable:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (snapshots == null || snapshots.entries().isEmpty()) {\n          \n          \n            \n                            if (snapshots != null && snapshots.entries().isEmpty() == false) {\n          \n          \n            \n                                    throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName, \" a snapshot is already running\");\n          \n          \n            \n                            }\n          \n          \n            \n                            // Store newSnapshot here to be processed in clusterStateProcessed\n          \n          \n            \n                            ...", "url": "https://github.com/elastic/elasticsearch/pull/51256#discussion_r369630007", "createdAt": "2020-01-22T15:31:13Z", "author": {"login": "tlrx"}, "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -268,90 +268,86 @@ public void createSnapshot(final CreateSnapshotRequest request, final ActionList\n         final String snapshotName = indexNameExpressionResolver.resolveDateMathExpression(request.snapshot());\n         validate(repositoryName, snapshotName);\n         final SnapshotId snapshotId = new SnapshotId(snapshotName, UUIDs.randomBase64UUID()); // new UUID for the snapshot\n-        final StepListener<RepositoryData> repositoryDataListener = new StepListener<>();\n-        repositoriesService.repository(repositoryName).getRepositoryData(repositoryDataListener);\n-        repositoryDataListener.whenComplete(repositoryData -> {\n-            final boolean hasOldFormatSnapshots = hasOldVersionSnapshots(repositoryName, repositoryData, null);\n-            clusterService.submitStateUpdateTask(\"create_snapshot [\" + snapshotName + ']', new ClusterStateUpdateTask() {\n-\n-                private SnapshotsInProgress.Entry newSnapshot = null;\n-\n-                @Override\n-                public ClusterState execute(ClusterState currentState) {\n-                    validate(repositoryName, snapshotName, currentState);\n-                    SnapshotDeletionsInProgress deletionsInProgress = currentState.custom(SnapshotDeletionsInProgress.TYPE);\n-                    if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {\n-                        throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName,\n-                            \"cannot snapshot while a snapshot deletion is in-progress in [\" + deletionsInProgress + \"]\");\n-                    }\n-                    final RepositoryCleanupInProgress repositoryCleanupInProgress = currentState.custom(RepositoryCleanupInProgress.TYPE);\n-                    if (repositoryCleanupInProgress != null && repositoryCleanupInProgress.hasCleanupInProgress()) {\n-                        throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName,\n-                            \"cannot snapshot while a repository cleanup is in-progress in [\" + repositoryCleanupInProgress + \"]\");\n-                    }\n-                    SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE);\n-                    if (snapshots == null || snapshots.entries().isEmpty()) {\n-                        // Store newSnapshot here to be processed in clusterStateProcessed\n-                        List<String> indices = Arrays.asList(indexNameExpressionResolver.concreteIndexNames(currentState,\n-                            request.indicesOptions(), request.indices()));\n-                        logger.trace(\"[{}][{}] creating snapshot for indices [{}]\", repositoryName, snapshotName, indices);\n-                        List<IndexId> snapshotIndices = repositoryData.resolveNewIndices(indices);\n-                        newSnapshot = new SnapshotsInProgress.Entry(\n-                            new Snapshot(repositoryName, snapshotId),\n-                            request.includeGlobalState(), request.partial(),\n-                            State.INIT,\n-                            snapshotIndices,\n-                            threadPool.absoluteTimeInMillis(),\n-                            repositoryData.getGenId(),\n-                            null,\n-                            request.userMetadata(),\n-                            hasOldFormatSnapshots == false &&\n-                                clusterService.state().nodes().getMinNodeVersion().onOrAfter(SHARD_GEN_IN_REPO_DATA_VERSION));\n-                        initializingSnapshots.add(newSnapshot.snapshot());\n-                        snapshots = new SnapshotsInProgress(newSnapshot);\n-                    } else {\n-                        throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName, \" a snapshot is already running\");\n-                    }\n-                    return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE, snapshots).build();\n+        clusterService.submitStateUpdateTask(\"create_snapshot [\" + snapshotName + ']', new ClusterStateUpdateTask() {\n+\n+            private SnapshotsInProgress.Entry newSnapshot = null;\n+\n+            private List<String> indices;\n+\n+            @Override\n+            public ClusterState execute(ClusterState currentState) {\n+                validate(repositoryName, snapshotName, currentState);\n+                SnapshotDeletionsInProgress deletionsInProgress = currentState.custom(SnapshotDeletionsInProgress.TYPE);\n+                if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {\n+                    throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName,\n+                        \"cannot snapshot while a snapshot deletion is in-progress in [\" + deletionsInProgress + \"]\");\n                 }\n+                final RepositoryCleanupInProgress repositoryCleanupInProgress = currentState.custom(RepositoryCleanupInProgress.TYPE);\n+                if (repositoryCleanupInProgress != null && repositoryCleanupInProgress.hasCleanupInProgress()) {\n+                    throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName,\n+                        \"cannot snapshot while a repository cleanup is in-progress in [\" + repositoryCleanupInProgress + \"]\");\n+                }\n+                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE);\n+                if (snapshots == null || snapshots.entries().isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ca5ef3d193a2bb5d45085ed085169d562b604d5"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYzMjkyNQ==", "bodyText": "Maybe add a comment on why the list is empty here? Something like\n// list of snapshot indices will be resolved later", "url": "https://github.com/elastic/elasticsearch/pull/51256#discussion_r369632925", "createdAt": "2020-01-22T15:35:59Z", "author": {"login": "tlrx"}, "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -268,90 +268,86 @@ public void createSnapshot(final CreateSnapshotRequest request, final ActionList\n         final String snapshotName = indexNameExpressionResolver.resolveDateMathExpression(request.snapshot());\n         validate(repositoryName, snapshotName);\n         final SnapshotId snapshotId = new SnapshotId(snapshotName, UUIDs.randomBase64UUID()); // new UUID for the snapshot\n-        final StepListener<RepositoryData> repositoryDataListener = new StepListener<>();\n-        repositoriesService.repository(repositoryName).getRepositoryData(repositoryDataListener);\n-        repositoryDataListener.whenComplete(repositoryData -> {\n-            final boolean hasOldFormatSnapshots = hasOldVersionSnapshots(repositoryName, repositoryData, null);\n-            clusterService.submitStateUpdateTask(\"create_snapshot [\" + snapshotName + ']', new ClusterStateUpdateTask() {\n-\n-                private SnapshotsInProgress.Entry newSnapshot = null;\n-\n-                @Override\n-                public ClusterState execute(ClusterState currentState) {\n-                    validate(repositoryName, snapshotName, currentState);\n-                    SnapshotDeletionsInProgress deletionsInProgress = currentState.custom(SnapshotDeletionsInProgress.TYPE);\n-                    if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {\n-                        throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName,\n-                            \"cannot snapshot while a snapshot deletion is in-progress in [\" + deletionsInProgress + \"]\");\n-                    }\n-                    final RepositoryCleanupInProgress repositoryCleanupInProgress = currentState.custom(RepositoryCleanupInProgress.TYPE);\n-                    if (repositoryCleanupInProgress != null && repositoryCleanupInProgress.hasCleanupInProgress()) {\n-                        throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName,\n-                            \"cannot snapshot while a repository cleanup is in-progress in [\" + repositoryCleanupInProgress + \"]\");\n-                    }\n-                    SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE);\n-                    if (snapshots == null || snapshots.entries().isEmpty()) {\n-                        // Store newSnapshot here to be processed in clusterStateProcessed\n-                        List<String> indices = Arrays.asList(indexNameExpressionResolver.concreteIndexNames(currentState,\n-                            request.indicesOptions(), request.indices()));\n-                        logger.trace(\"[{}][{}] creating snapshot for indices [{}]\", repositoryName, snapshotName, indices);\n-                        List<IndexId> snapshotIndices = repositoryData.resolveNewIndices(indices);\n-                        newSnapshot = new SnapshotsInProgress.Entry(\n-                            new Snapshot(repositoryName, snapshotId),\n-                            request.includeGlobalState(), request.partial(),\n-                            State.INIT,\n-                            snapshotIndices,\n-                            threadPool.absoluteTimeInMillis(),\n-                            repositoryData.getGenId(),\n-                            null,\n-                            request.userMetadata(),\n-                            hasOldFormatSnapshots == false &&\n-                                clusterService.state().nodes().getMinNodeVersion().onOrAfter(SHARD_GEN_IN_REPO_DATA_VERSION));\n-                        initializingSnapshots.add(newSnapshot.snapshot());\n-                        snapshots = new SnapshotsInProgress(newSnapshot);\n-                    } else {\n-                        throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName, \" a snapshot is already running\");\n-                    }\n-                    return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE, snapshots).build();\n+        clusterService.submitStateUpdateTask(\"create_snapshot [\" + snapshotName + ']', new ClusterStateUpdateTask() {\n+\n+            private SnapshotsInProgress.Entry newSnapshot = null;\n+\n+            private List<String> indices;\n+\n+            @Override\n+            public ClusterState execute(ClusterState currentState) {\n+                validate(repositoryName, snapshotName, currentState);\n+                SnapshotDeletionsInProgress deletionsInProgress = currentState.custom(SnapshotDeletionsInProgress.TYPE);\n+                if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {\n+                    throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName,\n+                        \"cannot snapshot while a snapshot deletion is in-progress in [\" + deletionsInProgress + \"]\");\n                 }\n+                final RepositoryCleanupInProgress repositoryCleanupInProgress = currentState.custom(RepositoryCleanupInProgress.TYPE);\n+                if (repositoryCleanupInProgress != null && repositoryCleanupInProgress.hasCleanupInProgress()) {\n+                    throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName,\n+                        \"cannot snapshot while a repository cleanup is in-progress in [\" + repositoryCleanupInProgress + \"]\");\n+                }\n+                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE);\n+                if (snapshots == null || snapshots.entries().isEmpty()) {\n+                    // Store newSnapshot here to be processed in clusterStateProcessed\n+                    indices = Arrays.asList(indexNameExpressionResolver.concreteIndexNames(currentState,\n+                        request.indicesOptions(), request.indices()));\n+                    logger.trace(\"[{}][{}] creating snapshot for indices [{}]\", repositoryName, snapshotName, indices);\n+                    newSnapshot = new SnapshotsInProgress.Entry(\n+                        new Snapshot(repositoryName, snapshotId),\n+                        request.includeGlobalState(), request.partial(),\n+                        State.INIT,\n+                        Collections.emptyList(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ca5ef3d193a2bb5d45085ed085169d562b604d5"}, "originalPosition": 87}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ae7c2a68c910cf3f79c976229a9396e2068ae373", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/ae7c2a68c910cf3f79c976229a9396e2068ae373", "committedDate": "2020-01-22T16:29:09Z", "message": "Merge remote-tracking branch 'elastic/master' into make-snapshot-delete-order-deterministic"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6da256517662d2c23df67dfac2d04d17ac0af9c2", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/6da256517662d2c23df67dfac2d04d17ac0af9c2", "committedDate": "2020-01-22T16:33:22Z", "message": "CR comments"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2781, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}