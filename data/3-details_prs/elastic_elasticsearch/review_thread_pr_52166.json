{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzczMzY2Mjk4", "number": 52166, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMTo1MDoyMFrODe-W9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMjowMjoxN1rODe-kyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzODA1NTU3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/SearchModule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMTo1MDoyMFrOFoac-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMTo1MDoyMFrOFoac-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkyMDc2MQ==", "bodyText": "Nit - align indentation please.", "url": "https://github.com/elastic/elasticsearch/pull/52166#discussion_r377920761", "createdAt": "2020-02-11T21:50:20Z", "author": {"login": "not-napoleon"}, "path": "server/src/main/java/org/elasticsearch/search/SearchModule.java", "diffHunk": "@@ -395,7 +395,8 @@ private void registerAggregations(List<SearchPlugin> plugins) {\n                 RareTermsAggregationBuilder::parse)\n                     .addResultReader(StringRareTerms.NAME, StringRareTerms::new)\n                     .addResultReader(UnmappedRareTerms.NAME, UnmappedRareTerms::new)\n-                    .addResultReader(LongRareTerms.NAME, LongRareTerms::new));\n+                    .addResultReader(LongRareTerms.NAME, LongRareTerms::new)\n+            .setAggregatorRegistrar(RareTermsAggregationBuilder::registerAggregators));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3bc413f0faa17238f9843146ae24f738f545133"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzODA1OTMxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/RareTermsAggregatorFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMTo1MTozOFrOFoafWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxOToxMDozNVrOFo7FRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkyMTM3MQ==", "bodyText": "Nit - Do we need to keep copying this TODO around?  I'm not even sure it's really still valid, registration in the factory hasn't been as messy as I'd expected when I first wrote that down.", "url": "https://github.com/elastic/elasticsearch/pull/52166#discussion_r377921371", "createdAt": "2020-02-11T21:51:38Z", "author": {"login": "not-napoleon"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/RareTermsAggregatorFactory.java", "diffHunk": "@@ -44,6 +47,89 @@\n     private final int maxDocCount;\n     private final double precision;\n \n+    // TODO: Registration should happen on the actual aggregator classes", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3bc413f0faa17238f9843146ae24f738f545133"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ1NTM2NQ==", "bodyText": "Yeah good point, it hasn't bothered me in the factory either.  I'll remove.", "url": "https://github.com/elastic/elasticsearch/pull/52166#discussion_r378455365", "createdAt": "2020-02-12T19:10:35Z", "author": {"login": "polyfractal"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/RareTermsAggregatorFactory.java", "diffHunk": "@@ -44,6 +47,89 @@\n     private final int maxDocCount;\n     private final double precision;\n \n+    // TODO: Registration should happen on the actual aggregator classes", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkyMTM3MQ=="}, "originalCommit": {"oid": "d3bc413f0faa17238f9843146ae24f738f545133"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzODA4MDczOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/RareTermsAggregatorFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMTo1ODo0MlrOFoastw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxOToxMTo1M1rOFo7IJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkyNDc5MQ==", "bodyText": "This seems like it should be an IllegalArgumentException - Something didn't go wrong with the agg, the user sent us nonsense.", "url": "https://github.com/elastic/elasticsearch/pull/52166#discussion_r377924791", "createdAt": "2020-02-11T21:58:42Z", "author": {"login": "not-napoleon"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/RareTermsAggregatorFactory.java", "diffHunk": "@@ -44,6 +47,89 @@\n     private final int maxDocCount;\n     private final double precision;\n \n+    // TODO: Registration should happen on the actual aggregator classes\n+    static void registerAggregators(ValuesSourceRegistry valuesSourceRegistry) {\n+        valuesSourceRegistry.register(RareTermsAggregationBuilder.NAME,\n+            List.of(CoreValuesSourceType.BYTES, CoreValuesSourceType.IP),\n+            RareTermsAggregatorFactory.bytesSupplier());\n+\n+        valuesSourceRegistry.register(RareTermsAggregationBuilder.NAME,\n+            List.of(CoreValuesSourceType.DATE, CoreValuesSourceType.BOOLEAN, CoreValuesSourceType.NUMERIC),\n+            RareTermsAggregatorFactory.numericSupplier());\n+    }\n+\n+    /**\n+     * This supplier is used for all the field types that should be aggregated as bytes/strings,\n+     * including those that need global ordinals\n+     */\n+    private static RareTermsAggregatorSupplier bytesSupplier() {\n+        return new RareTermsAggregatorSupplier() {\n+            @Override\n+            public Aggregator build(String name,\n+                                    AggregatorFactories factories,\n+                                    ValuesSource valuesSource,\n+                                    DocValueFormat format,\n+                                    int maxDocCount,\n+                                    double precision,\n+                                    IncludeExclude includeExclude,\n+                                    SearchContext context,\n+                                    Aggregator parent,\n+                                    List<PipelineAggregator> pipelineAggregators,\n+                                    Map<String, Object> metaData) throws IOException {\n+\n+                ExecutionMode execution = ExecutionMode.MAP; //TODO global ords not implemented yet, only supports \"map\"\n+\n+                if ((includeExclude != null) && (includeExclude.isRegexBased()) && format != DocValueFormat.RAW) {\n+                    throw new AggregationExecutionException(\"Aggregation [\" + name + \"] cannot support \" +\n+                        \"regular expression style include/exclude settings as they can only be applied to string fields. \" +\n+                        \"Use an array of values for include/exclude clauses\");\n+                }\n+\n+                return execution.create(name, factories, valuesSource, format,\n+                    includeExclude, context, parent, pipelineAggregators, metaData, maxDocCount, precision);\n+\n+            }\n+        };\n+    }\n+\n+    /**\n+     * This supplier is used for all fields that expect to be aggregated as a numeric value.\n+     * This includes floating points, and formatted types that use numerics internally for storage (date, boolean, etc)\n+     */\n+    private static RareTermsAggregatorSupplier numericSupplier() {\n+        return new RareTermsAggregatorSupplier() {\n+            @Override\n+            public Aggregator build(String name,\n+                                    AggregatorFactories factories,\n+                                    ValuesSource valuesSource,\n+                                    DocValueFormat format,\n+                                    int maxDocCount,\n+                                    double precision,\n+                                    IncludeExclude includeExclude,\n+                                    SearchContext context,\n+                                    Aggregator parent,\n+                                    List<PipelineAggregator> pipelineAggregators,\n+                                    Map<String, Object> metaData) throws IOException {\n+\n+                if ((includeExclude != null) && (includeExclude.isRegexBased())) {\n+                    throw new AggregationExecutionException(\"Aggregation [\" + name + \"] cannot support regular expression \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3bc413f0faa17238f9843146ae24f738f545133"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ1NjEwMw==", "bodyText": "It is somewhat conditional, since the same include/exclude could work on a different field type (strings vs numerics).  But I generally agree, will switch it over.", "url": "https://github.com/elastic/elasticsearch/pull/52166#discussion_r378456103", "createdAt": "2020-02-12T19:11:53Z", "author": {"login": "polyfractal"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/RareTermsAggregatorFactory.java", "diffHunk": "@@ -44,6 +47,89 @@\n     private final int maxDocCount;\n     private final double precision;\n \n+    // TODO: Registration should happen on the actual aggregator classes\n+    static void registerAggregators(ValuesSourceRegistry valuesSourceRegistry) {\n+        valuesSourceRegistry.register(RareTermsAggregationBuilder.NAME,\n+            List.of(CoreValuesSourceType.BYTES, CoreValuesSourceType.IP),\n+            RareTermsAggregatorFactory.bytesSupplier());\n+\n+        valuesSourceRegistry.register(RareTermsAggregationBuilder.NAME,\n+            List.of(CoreValuesSourceType.DATE, CoreValuesSourceType.BOOLEAN, CoreValuesSourceType.NUMERIC),\n+            RareTermsAggregatorFactory.numericSupplier());\n+    }\n+\n+    /**\n+     * This supplier is used for all the field types that should be aggregated as bytes/strings,\n+     * including those that need global ordinals\n+     */\n+    private static RareTermsAggregatorSupplier bytesSupplier() {\n+        return new RareTermsAggregatorSupplier() {\n+            @Override\n+            public Aggregator build(String name,\n+                                    AggregatorFactories factories,\n+                                    ValuesSource valuesSource,\n+                                    DocValueFormat format,\n+                                    int maxDocCount,\n+                                    double precision,\n+                                    IncludeExclude includeExclude,\n+                                    SearchContext context,\n+                                    Aggregator parent,\n+                                    List<PipelineAggregator> pipelineAggregators,\n+                                    Map<String, Object> metaData) throws IOException {\n+\n+                ExecutionMode execution = ExecutionMode.MAP; //TODO global ords not implemented yet, only supports \"map\"\n+\n+                if ((includeExclude != null) && (includeExclude.isRegexBased()) && format != DocValueFormat.RAW) {\n+                    throw new AggregationExecutionException(\"Aggregation [\" + name + \"] cannot support \" +\n+                        \"regular expression style include/exclude settings as they can only be applied to string fields. \" +\n+                        \"Use an array of values for include/exclude clauses\");\n+                }\n+\n+                return execution.create(name, factories, valuesSource, format,\n+                    includeExclude, context, parent, pipelineAggregators, metaData, maxDocCount, precision);\n+\n+            }\n+        };\n+    }\n+\n+    /**\n+     * This supplier is used for all fields that expect to be aggregated as a numeric value.\n+     * This includes floating points, and formatted types that use numerics internally for storage (date, boolean, etc)\n+     */\n+    private static RareTermsAggregatorSupplier numericSupplier() {\n+        return new RareTermsAggregatorSupplier() {\n+            @Override\n+            public Aggregator build(String name,\n+                                    AggregatorFactories factories,\n+                                    ValuesSource valuesSource,\n+                                    DocValueFormat format,\n+                                    int maxDocCount,\n+                                    double precision,\n+                                    IncludeExclude includeExclude,\n+                                    SearchContext context,\n+                                    Aggregator parent,\n+                                    List<PipelineAggregator> pipelineAggregators,\n+                                    Map<String, Object> metaData) throws IOException {\n+\n+                if ((includeExclude != null) && (includeExclude.isRegexBased())) {\n+                    throw new AggregationExecutionException(\"Aggregation [\" + name + \"] cannot support regular expression \" +", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkyNDc5MQ=="}, "originalCommit": {"oid": "d3bc413f0faa17238f9843146ae24f738f545133"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzODA4NjU1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/RareTermsAggregatorFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMjowMDozN1rOFoawUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMjowMDozN1rOFoawUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkyNTcxNA==", "bodyText": "As above, this feels like an IllegalArgumentException.  If they gave us a Range field as input, we'd throw IllegalArgumentException, this feels like the same type of error.", "url": "https://github.com/elastic/elasticsearch/pull/52166#discussion_r377925714", "createdAt": "2020-02-11T22:00:37Z", "author": {"login": "not-napoleon"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/RareTermsAggregatorFactory.java", "diffHunk": "@@ -44,6 +47,89 @@\n     private final int maxDocCount;\n     private final double precision;\n \n+    // TODO: Registration should happen on the actual aggregator classes\n+    static void registerAggregators(ValuesSourceRegistry valuesSourceRegistry) {\n+        valuesSourceRegistry.register(RareTermsAggregationBuilder.NAME,\n+            List.of(CoreValuesSourceType.BYTES, CoreValuesSourceType.IP),\n+            RareTermsAggregatorFactory.bytesSupplier());\n+\n+        valuesSourceRegistry.register(RareTermsAggregationBuilder.NAME,\n+            List.of(CoreValuesSourceType.DATE, CoreValuesSourceType.BOOLEAN, CoreValuesSourceType.NUMERIC),\n+            RareTermsAggregatorFactory.numericSupplier());\n+    }\n+\n+    /**\n+     * This supplier is used for all the field types that should be aggregated as bytes/strings,\n+     * including those that need global ordinals\n+     */\n+    private static RareTermsAggregatorSupplier bytesSupplier() {\n+        return new RareTermsAggregatorSupplier() {\n+            @Override\n+            public Aggregator build(String name,\n+                                    AggregatorFactories factories,\n+                                    ValuesSource valuesSource,\n+                                    DocValueFormat format,\n+                                    int maxDocCount,\n+                                    double precision,\n+                                    IncludeExclude includeExclude,\n+                                    SearchContext context,\n+                                    Aggregator parent,\n+                                    List<PipelineAggregator> pipelineAggregators,\n+                                    Map<String, Object> metaData) throws IOException {\n+\n+                ExecutionMode execution = ExecutionMode.MAP; //TODO global ords not implemented yet, only supports \"map\"\n+\n+                if ((includeExclude != null) && (includeExclude.isRegexBased()) && format != DocValueFormat.RAW) {\n+                    throw new AggregationExecutionException(\"Aggregation [\" + name + \"] cannot support \" +\n+                        \"regular expression style include/exclude settings as they can only be applied to string fields. \" +\n+                        \"Use an array of values for include/exclude clauses\");\n+                }\n+\n+                return execution.create(name, factories, valuesSource, format,\n+                    includeExclude, context, parent, pipelineAggregators, metaData, maxDocCount, precision);\n+\n+            }\n+        };\n+    }\n+\n+    /**\n+     * This supplier is used for all fields that expect to be aggregated as a numeric value.\n+     * This includes floating points, and formatted types that use numerics internally for storage (date, boolean, etc)\n+     */\n+    private static RareTermsAggregatorSupplier numericSupplier() {\n+        return new RareTermsAggregatorSupplier() {\n+            @Override\n+            public Aggregator build(String name,\n+                                    AggregatorFactories factories,\n+                                    ValuesSource valuesSource,\n+                                    DocValueFormat format,\n+                                    int maxDocCount,\n+                                    double precision,\n+                                    IncludeExclude includeExclude,\n+                                    SearchContext context,\n+                                    Aggregator parent,\n+                                    List<PipelineAggregator> pipelineAggregators,\n+                                    Map<String, Object> metaData) throws IOException {\n+\n+                if ((includeExclude != null) && (includeExclude.isRegexBased())) {\n+                    throw new AggregationExecutionException(\"Aggregation [\" + name + \"] cannot support regular expression \" +\n+                        \"style include/exclude settings as they can only be applied to string fields. Use an array of numeric \" +\n+                        \"values for include/exclude clauses used to filter numeric fields\");\n+                }\n+\n+                IncludeExclude.LongFilter longFilter = null;\n+                if (((ValuesSource.Numeric) valuesSource).isFloatingPoint()) {\n+                    throw new AggregationExecutionException(\"RareTerms aggregation does not support floating point fields.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3bc413f0faa17238f9843146ae24f738f545133"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzODA5MDk4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/RareTermsAggregatorFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMjowMjoxN1rOFoazSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMjowMjoxN1rOFoazSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkyNjQ3Mw==", "bodyText": "Again, I think this should be IllegalArgumentException, see comment below.", "url": "https://github.com/elastic/elasticsearch/pull/52166#discussion_r377926473", "createdAt": "2020-02-11T22:02:17Z", "author": {"login": "not-napoleon"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/RareTermsAggregatorFactory.java", "diffHunk": "@@ -44,6 +47,89 @@\n     private final int maxDocCount;\n     private final double precision;\n \n+    // TODO: Registration should happen on the actual aggregator classes\n+    static void registerAggregators(ValuesSourceRegistry valuesSourceRegistry) {\n+        valuesSourceRegistry.register(RareTermsAggregationBuilder.NAME,\n+            List.of(CoreValuesSourceType.BYTES, CoreValuesSourceType.IP),\n+            RareTermsAggregatorFactory.bytesSupplier());\n+\n+        valuesSourceRegistry.register(RareTermsAggregationBuilder.NAME,\n+            List.of(CoreValuesSourceType.DATE, CoreValuesSourceType.BOOLEAN, CoreValuesSourceType.NUMERIC),\n+            RareTermsAggregatorFactory.numericSupplier());\n+    }\n+\n+    /**\n+     * This supplier is used for all the field types that should be aggregated as bytes/strings,\n+     * including those that need global ordinals\n+     */\n+    private static RareTermsAggregatorSupplier bytesSupplier() {\n+        return new RareTermsAggregatorSupplier() {\n+            @Override\n+            public Aggregator build(String name,\n+                                    AggregatorFactories factories,\n+                                    ValuesSource valuesSource,\n+                                    DocValueFormat format,\n+                                    int maxDocCount,\n+                                    double precision,\n+                                    IncludeExclude includeExclude,\n+                                    SearchContext context,\n+                                    Aggregator parent,\n+                                    List<PipelineAggregator> pipelineAggregators,\n+                                    Map<String, Object> metaData) throws IOException {\n+\n+                ExecutionMode execution = ExecutionMode.MAP; //TODO global ords not implemented yet, only supports \"map\"\n+\n+                if ((includeExclude != null) && (includeExclude.isRegexBased()) && format != DocValueFormat.RAW) {\n+                    throw new AggregationExecutionException(\"Aggregation [\" + name + \"] cannot support \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3bc413f0faa17238f9843146ae24f738f545133"}, "originalPosition": 50}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4711, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}