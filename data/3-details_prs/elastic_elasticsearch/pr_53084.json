{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgzMTgzMTQ4", "number": 53084, "title": "Add API to mount a snapshot as a searchable index", "bodyText": "This commit adds an API for mounting a snapshot as a searchable index.\nInternally, a request is made to the repository to fetch metadata information necessary from the\nsnapshot in question, which is then passed to the regular snapshot restore mechanism with some\nspecialized settings.\nAssume you have an existing snapshot repository and snapshot, the API looks like:\nPOST /my-new-index/_snapshot/mount?wait_for_completion=true\n{\n  \"repository\": \"my-s3-repo\",\n  \"snapshot\": \"production-2019-12-11-aoeufao\",\n  \"snapshot_index\": \"important-data\",\n  \"index_settings\": {\n    \"index.number_of_replicas\": 2\n  },\n  \"ignore_index_settings\": [\"index.refresh_interval\"]\n}\nWhile the request may appear similar to a snapshot restore request, it has slight differences. The\nrepository, snapshot, and snapshot_index fields are required (all other fields are optional).\nThe response is identical to the response when restoring a snapshot. In the above example the newly\nrestored/mounted index will be called my-new-index.\nRelates to #50999", "createdAt": "2020-03-03T21:16:54Z", "url": "https://github.com/elastic/elasticsearch/pull/53084", "merged": true, "mergeCommit": {"oid": "88b01a26ce9749ed224850613067aeec6cf5c0e5"}, "closed": true, "closedAt": "2020-03-10T10:04:02Z", "author": {"login": "dakrone"}, "timelineItems": {"totalCount": 31, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcKI6yxgH2gAyMzgzMTgzMTQ4OmM4NDdlMDM1YmFhMmUwYjM3MDgwOGFhN2E1MmE2ZDU5YzUyNTZhNDQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcL9oXggH2gAyMzgzMTgzMTQ4OmI0NGQyMjA1MmY5NDFiMGQ2ZmIzNzJjMTZhMzk5YTYwOGQyMDUyYmU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "c847e035baa2e0b370808aa7a52a6d59c5256a44", "author": {"user": {"login": "dakrone", "name": "Lee Hinman"}}, "url": "https://github.com/elastic/elasticsearch/commit/c847e035baa2e0b370808aa7a52a6d59c5256a44", "committedDate": "2020-03-03T21:08:47Z", "message": "Add API to mount a snapshot as a searchable index\n\nThis commit adds an API for mounting a snapshot as a searchable index.\n\nInternally, a request is made to the repository to fetch metadata information necessary from the\nsnapshot in question, which is then passed to the regular snapshot restore mechanism with some\nspecialized settings.\n\nAssume you have an existing snapshot repository and snapshot, the API looks like:\n\n```json\nPOST /my-new-index/_snapshot/mount?wait_for_completion=true\n{\n  \"repository\": \"my-s3-repo\",\n  \"snapshot\": \"production-2019-12-11-aoeufao\",\n  \"snapshot_index\": \"important-data\",\n  \"index_settings\": {\n    \"index.number_of_replicas\": 2\n  },\n  \"ignore_index_settings\": [\"index.refresh_interval\"]\n}\n```\n\nWhile the request may appear similar to a snapshot restore request, it has slight differences. The\n`repository`, `snapshot`, and `snapshot_index` fields are required (all other fields are optional).\n\nThe response is identical to the response when restoring a snapshot.\n\nRelates to #50999"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4NjE5Mjkx", "url": "https://github.com/elastic/elasticsearch/pull/53084#pullrequestreview-368619291", "createdAt": "2020-03-04T09:27:59Z", "commit": {"oid": "c847e035baa2e0b370808aa7a52a6d59c5256a44"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwOToyNzo1OVrOFxlsMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwOTo1NjoyOFrOFxmrfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU0MjA2NA==", "bodyText": "This is \"disrupting\" the usual lifecycle of Repository. On the other hand, SearchableSnapshotRepository was useful when the searchable repository was explicitly registered as a delegating repository. I don't think it's needed anymore: the  DirectoryFactory logic can be moved back to the plugin class, and instead of passing directly a BlobContainer instance to the SearchableSnapshotDirectory it could use the RepositoriesService to retrieve it on demande. This way we get rid of a class and we take care of reloading the BlobStoreRepository instance that could have changed. WDYT?", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r387542064", "createdAt": "2020-03-04T09:27:59Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/SearchableSnapshotRepository.java", "diffHunk": "@@ -160,16 +164,17 @@ public Repository create(RepositoryMetaData metaData, Function<String, Factory>\n         return (indexSettings, shardPath) -> {\n             final RepositoriesService repositories = repositoriesService.get();\n             assert repositories != null;\n-\n-            final Repository repository = repositories.repository(SNAPSHOT_REPOSITORY_SETTING.get(indexSettings.getSettings()));\n-            if (repository instanceof SearchableSnapshotRepository == false) {\n-                throw new IllegalArgumentException(\"Repository [\" + repository + \"] is not searchable\");\n-            }\n-\n             final CacheService cache = cacheService.get();\n             assert cache != null;\n \n-            return ((SearchableSnapshotRepository) repository).makeDirectory(indexSettings, shardPath, cache, currentTimeNanosSupplier);\n+            final Repository repository = repositories.repository(SNAPSHOT_REPOSITORY_SETTING.get(indexSettings.getSettings()));\n+            // TODO: is this okay?\n+//            if (repository instanceof SearchableSnapshotRepository == false) {\n+//                throw new IllegalArgumentException(\"Repository [\" + repository + \"] is not searchable\");\n+//            }\n+\n+            SearchableSnapshotRepository searchableRepo = new SearchableSnapshotRepository(repository);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c847e035baa2e0b370808aa7a52a6d59c5256a44"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU0NDk5Mg==", "bodyText": "Should we make this uniform with other searchable snapshots related actions?", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r387544992", "createdAt": "2020-03-04T09:33:07Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/action/MountSearchableSnapshotAction.java", "diffHunk": "@@ -0,0 +1,20 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.searchablesnapshots.action;\n+\n+import org.elasticsearch.action.ActionType;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotResponse;\n+\n+public class MountSearchableSnapshotAction extends ActionType<RestoreSnapshotResponse> {\n+\n+    public static final MountSearchableSnapshotAction INSTANCE = new MountSearchableSnapshotAction();\n+    public static final String NAME = \"cluster:admin/snapshot/mount\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c847e035baa2e0b370808aa7a52a6d59c5256a44"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU0NTQ5Nw==", "bodyText": "This doc needs to be updated", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r387545497", "createdAt": "2020-03-04T09:34:01Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/action/MountSearchableSnapshotRequest.java", "diffHunk": "@@ -0,0 +1,435 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.searchablesnapshots.action;\n+\n+import org.elasticsearch.ElasticsearchGenerationException;\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.action.support.master.MasterNodeRequest;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.common.xcontent.XContentType;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.action.ValidateActions.addValidationError;\n+import static org.elasticsearch.common.settings.Settings.Builder.EMPTY_SETTINGS;\n+import static org.elasticsearch.common.settings.Settings.readSettingsFromStream;\n+import static org.elasticsearch.common.settings.Settings.writeSettingsToStream;\n+\n+public class MountSearchableSnapshotRequest extends MasterNodeRequest<MountSearchableSnapshotRequest> implements ToXContentObject {\n+\n+    private final String mountedIndex;\n+    private String snapshot;\n+    private String repository;\n+    private String snapshotIndex;\n+    private Boolean waitForCompletion;\n+    private Settings settings = EMPTY_SETTINGS;\n+    private Settings indexSettings = EMPTY_SETTINGS;\n+    private String[] ignoreIndexSettings = Strings.EMPTY_ARRAY;\n+\n+    /**\n+     * Constructs a new put repository request with the provided repository and snapshot names.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c847e035baa2e0b370808aa7a52a6d59c5256a44"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU0ODI4Ng==", "bodyText": "Should we use indices or index?", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r387548286", "createdAt": "2020-03-04T09:39:01Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/action/MountSearchableSnapshotRequest.java", "diffHunk": "@@ -0,0 +1,435 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.searchablesnapshots.action;\n+\n+import org.elasticsearch.ElasticsearchGenerationException;\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.action.support.master.MasterNodeRequest;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.common.xcontent.XContentType;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.action.ValidateActions.addValidationError;\n+import static org.elasticsearch.common.settings.Settings.Builder.EMPTY_SETTINGS;\n+import static org.elasticsearch.common.settings.Settings.readSettingsFromStream;\n+import static org.elasticsearch.common.settings.Settings.writeSettingsToStream;\n+\n+public class MountSearchableSnapshotRequest extends MasterNodeRequest<MountSearchableSnapshotRequest> implements ToXContentObject {\n+\n+    private final String mountedIndex;\n+    private String snapshot;\n+    private String repository;\n+    private String snapshotIndex;\n+    private Boolean waitForCompletion;\n+    private Settings settings = EMPTY_SETTINGS;\n+    private Settings indexSettings = EMPTY_SETTINGS;\n+    private String[] ignoreIndexSettings = Strings.EMPTY_ARRAY;\n+\n+    /**\n+     * Constructs a new put repository request with the provided repository and snapshot names.\n+     */\n+    public MountSearchableSnapshotRequest(String mountedIndex) {\n+        this.mountedIndex = mountedIndex;\n+    }\n+\n+    public MountSearchableSnapshotRequest(StreamInput in) throws IOException {\n+        super(in);\n+        this.snapshot = in.readString();\n+        this.repository = in.readString();\n+        this.snapshotIndex = in.readString();\n+        this.mountedIndex = in.readString();\n+        this.waitForCompletion = in.readOptionalBoolean();\n+        this.settings = readSettingsFromStream(in);\n+        this.indexSettings = readSettingsFromStream(in);\n+        this.ignoreIndexSettings = in.readStringArray();\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        super.writeTo(out);\n+        out.writeString(snapshot);\n+        out.writeString(repository);\n+        out.writeString(snapshotIndex);\n+        out.writeString(mountedIndex);\n+        out.writeOptionalBoolean(waitForCompletion);\n+        writeSettingsToStream(settings, out);\n+        writeSettingsToStream(indexSettings, out);\n+        out.writeStringArray(ignoreIndexSettings);\n+    }\n+\n+    @Override\n+    public ActionRequestValidationException validate() {\n+        ActionRequestValidationException validationException = null;\n+        if (snapshot == null) {\n+            validationException = addValidationError(\"snapshot name is missing\", validationException);\n+        }\n+        if (repository == null) {\n+            validationException = addValidationError(\"repository is missing\", validationException);\n+        }\n+        if (snapshotIndex == null) {\n+            validationException = addValidationError(\"index name from snapshot is missing\", validationException);\n+        }\n+        if (mountedIndex == null) {\n+            validationException = addValidationError(\"index name to mount is missing\", validationException);\n+        }\n+        if (settings == null) {\n+            validationException = addValidationError(\"settings are missing\", validationException);\n+        }\n+        if (indexSettings == null) {\n+            validationException = addValidationError(\"indexSettings are missing\", validationException);\n+        }\n+        return validationException;\n+    }\n+\n+    /**\n+     * Sets the name of the snapshot.\n+     *\n+     * @param snapshot snapshot name\n+     * @return this request\n+     */\n+    public MountSearchableSnapshotRequest snapshot(String snapshot) {\n+        this.snapshot = snapshot;\n+        return this;\n+    }\n+\n+    /**\n+     * Returns the name of the snapshot.\n+     *\n+     * @return snapshot name\n+     */\n+    public String snapshot() {\n+        return this.snapshot;\n+    }\n+\n+    /**\n+     * Sets repository name\n+     *\n+     * @param repository repository name\n+     * @return this request\n+     */\n+    public MountSearchableSnapshotRequest repository(String repository) {\n+        this.repository = repository;\n+        return this;\n+    }\n+\n+    /**\n+     * Returns repository name\n+     *\n+     * @return repository name\n+     */\n+    public String repository() {\n+        return this.repository;\n+    }\n+\n+    /**\n+     * Sets the name of the index that should be restored from snapshot\n+     */\n+    public MountSearchableSnapshotRequest snapshotIndex(String indexName) {\n+        this.snapshotIndex = indexName;\n+        return this;\n+    }\n+\n+    /**\n+     * Returns index that should be restored from snapshot\n+     */\n+    public String snapshotIndex() {\n+        return snapshotIndex;\n+    }\n+\n+    /**\n+     * Returns new index name after the snapshot has been mounted\n+     */\n+    public String mountedIndex() {\n+        return mountedIndex;\n+    }\n+\n+    /**\n+     * If this parameter is set to true the operation will wait for completion of restore process before returning.\n+     *\n+     * @param waitForCompletion if true the operation will wait for completion\n+     * @return this request\n+     */\n+    public MountSearchableSnapshotRequest waitForCompletion(boolean waitForCompletion) {\n+        this.waitForCompletion = waitForCompletion;\n+        return this;\n+    }\n+\n+    /**\n+     * Returns wait for completion setting\n+     *\n+     * @return true if the operation will wait for completion\n+     */\n+    public boolean waitForCompletion() {\n+        return waitForCompletion;\n+    }\n+\n+    /**\n+     * Sets repository-specific restore settings.\n+     * <p>\n+     * See repository documentation for more information.\n+     *\n+     * @param settings repository-specific snapshot settings\n+     * @return this request\n+     */\n+    public MountSearchableSnapshotRequest settings(Settings settings) {\n+        this.settings = settings;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets repository-specific restore settings.\n+     * <p>\n+     * See repository documentation for more information.\n+     *\n+     * @param settings repository-specific snapshot settings\n+     * @return this request\n+     */\n+    public MountSearchableSnapshotRequest settings(Settings.Builder settings) {\n+        this.settings = settings.build();\n+        return this;\n+    }\n+\n+    /**\n+     * Sets repository-specific restore settings in JSON or YAML format\n+     * <p>\n+     * See repository documentation for more information.\n+     *\n+     * @param source repository-specific snapshot settings\n+     * @param xContentType the content type of the source\n+     * @return this request\n+     */\n+    public MountSearchableSnapshotRequest settings(String source, XContentType xContentType) {\n+        this.settings = Settings.builder().loadFromSource(source, xContentType).build();\n+        return this;\n+    }\n+\n+    /**\n+     * Sets repository-specific restore settings\n+     * <p>\n+     * See repository documentation for more information.\n+     *\n+     * @param source repository-specific snapshot settings\n+     * @return this request\n+     */\n+    public MountSearchableSnapshotRequest settings(Map<String, Object> source) {\n+        try {\n+            XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON);\n+            builder.map(source);\n+            settings(Strings.toString(builder), builder.contentType());\n+        } catch (IOException e) {\n+            throw new ElasticsearchGenerationException(\"Failed to generate [\" + source + \"]\", e);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Returns repository-specific restore settings\n+     *\n+     * @return restore settings\n+     */\n+    public Settings settings() {\n+        return this.settings;\n+    }\n+\n+    /**\n+     * Sets the list of index settings and index settings groups that shouldn't be restored from snapshot\n+     */\n+    public MountSearchableSnapshotRequest ignoreIndexSettings(String... ignoreIndexSettings) {\n+        this.ignoreIndexSettings = ignoreIndexSettings;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the list of index settings and index settings groups that shouldn't be restored from snapshot\n+     */\n+    public MountSearchableSnapshotRequest ignoreIndexSettings(List<String> ignoreIndexSettings) {\n+        this.ignoreIndexSettings = ignoreIndexSettings.toArray(new String[ignoreIndexSettings.size()]);\n+        return this;\n+    }\n+\n+    /**\n+     * Returns the list of index settings and index settings groups that shouldn't be restored from snapshot\n+     */\n+    public String[] ignoreIndexSettings() {\n+        return ignoreIndexSettings;\n+    }\n+\n+    /**\n+     * Sets settings that should be added/changed for restored index\n+     */\n+    public MountSearchableSnapshotRequest indexSettings(Settings settings) {\n+        this.indexSettings = settings;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets settings that should be added/changed for restored index\n+     */\n+    public MountSearchableSnapshotRequest indexSettings(Settings.Builder settings) {\n+        this.indexSettings = settings.build();\n+        return this;\n+    }\n+\n+    /**\n+     * Sets settings that should be added/changed for restored index\n+     */\n+    public MountSearchableSnapshotRequest indexSettings(String source, XContentType xContentType) {\n+        this.indexSettings = Settings.builder().loadFromSource(source, xContentType).build();\n+        return this;\n+    }\n+\n+    /**\n+     * Sets settings that should be added/changed for restored index\n+     */\n+    public MountSearchableSnapshotRequest indexSettings(Map<String, Object> source) {\n+        try {\n+            XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON);\n+            builder.map(source);\n+            indexSettings(Strings.toString(builder), builder.contentType());\n+        } catch (IOException e) {\n+            throw new ElasticsearchGenerationException(\"Failed to generate [\" + source + \"]\", e);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Returns settings that should be added/changed for restored index\n+     */\n+    public Settings indexSettings() {\n+        return this.indexSettings;\n+    }\n+\n+    /**\n+     * Parses mount definition\n+     *\n+     * @param source mount definition\n+     * @return this request\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public MountSearchableSnapshotRequest source(Map<String, Object> source) {\n+        // TODO: this could be rewritten with a Constructing Object Parser rather than manually\n+        //  parsing the XContent, this was copied/modified from RestoreSnapshotRequest\n+        for (Map.Entry<String, Object> entry : source.entrySet()) {\n+            String name = entry.getKey();\n+            if (name.equals(\"snapshot_index\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c847e035baa2e0b370808aa7a52a6d59c5256a44"}, "originalPosition": 330}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU0OTA1MQ==", "bodyText": "Nit: extra line", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r387549051", "createdAt": "2020-03-04T09:40:27Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/action/TransportMountSearchableSnapshotAction.java", "diffHunk": "@@ -0,0 +1,158 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.searchablesnapshots.action;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.StepListener;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotResponse;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.master.TransportMasterNodeAction;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.block.ClusterBlockLevel;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.repositories.RepositoryData;\n+import org.elasticsearch.snapshots.SnapshotId;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotRepository;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static org.elasticsearch.index.IndexModule.INDEX_STORE_TYPE_SETTING;\n+\n+public class TransportMountSearchableSnapshotAction\n+    extends TransportMasterNodeAction<MountSearchableSnapshotRequest, RestoreSnapshotResponse> {\n+\n+    private final Client client;\n+    private final RepositoriesService repositoriesService;\n+\n+    @Inject\n+    public TransportMountSearchableSnapshotAction(TransportService transportService, ClusterService clusterService, Client client,\n+                                                  ThreadPool threadPool, RepositoriesService repositoriesService,\n+                                                  ActionFilters actionFilters, IndexNameExpressionResolver indexNameExpressionResolver) {\n+        super(MountSearchableSnapshotAction.NAME, transportService, clusterService, threadPool, actionFilters,\n+            MountSearchableSnapshotRequest::new, indexNameExpressionResolver);\n+        this.client = client;\n+        this.repositoriesService = repositoriesService;\n+    }\n+\n+    @Override\n+    protected String executor() {\n+        // Using the generic instead of the snapshot threadpool here as the snapshot threadpool might be blocked on long running tasks\n+        // which would block the request from getting an error response because of the ongoing task\n+        return ThreadPool.Names.GENERIC;\n+    }\n+\n+    @Override\n+    protected RestoreSnapshotResponse read(StreamInput in) throws IOException {\n+        return new RestoreSnapshotResponse(in);\n+    }\n+\n+    @Override\n+    protected ClusterBlockException checkBlock(MountSearchableSnapshotRequest request, ClusterState state) {\n+        // Restoring a snapshot might change the global state and create/change an index,\n+        // so we need to check for METADATA_WRITE and WRITE blocks\n+        ClusterBlockException blockException = state.blocks().globalBlockedException(ClusterBlockLevel.METADATA_WRITE);\n+        if (blockException != null) {\n+            return blockException;\n+        }\n+        return state.blocks().globalBlockedException(ClusterBlockLevel.WRITE);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c847e035baa2e0b370808aa7a52a6d59c5256a44"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU1MDk2OQ==", "bodyText": "This throws a RepositoryMissingException which must be caught and passed to the listener.onFailure() method", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r387550969", "createdAt": "2020-03-04T09:43:47Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/action/TransportMountSearchableSnapshotAction.java", "diffHunk": "@@ -0,0 +1,158 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.searchablesnapshots.action;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.StepListener;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotResponse;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.master.TransportMasterNodeAction;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.block.ClusterBlockLevel;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.repositories.RepositoryData;\n+import org.elasticsearch.snapshots.SnapshotId;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotRepository;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static org.elasticsearch.index.IndexModule.INDEX_STORE_TYPE_SETTING;\n+\n+public class TransportMountSearchableSnapshotAction\n+    extends TransportMasterNodeAction<MountSearchableSnapshotRequest, RestoreSnapshotResponse> {\n+\n+    private final Client client;\n+    private final RepositoriesService repositoriesService;\n+\n+    @Inject\n+    public TransportMountSearchableSnapshotAction(TransportService transportService, ClusterService clusterService, Client client,\n+                                                  ThreadPool threadPool, RepositoriesService repositoriesService,\n+                                                  ActionFilters actionFilters, IndexNameExpressionResolver indexNameExpressionResolver) {\n+        super(MountSearchableSnapshotAction.NAME, transportService, clusterService, threadPool, actionFilters,\n+            MountSearchableSnapshotRequest::new, indexNameExpressionResolver);\n+        this.client = client;\n+        this.repositoriesService = repositoriesService;\n+    }\n+\n+    @Override\n+    protected String executor() {\n+        // Using the generic instead of the snapshot threadpool here as the snapshot threadpool might be blocked on long running tasks\n+        // which would block the request from getting an error response because of the ongoing task\n+        return ThreadPool.Names.GENERIC;\n+    }\n+\n+    @Override\n+    protected RestoreSnapshotResponse read(StreamInput in) throws IOException {\n+        return new RestoreSnapshotResponse(in);\n+    }\n+\n+    @Override\n+    protected ClusterBlockException checkBlock(MountSearchableSnapshotRequest request, ClusterState state) {\n+        // Restoring a snapshot might change the global state and create/change an index,\n+        // so we need to check for METADATA_WRITE and WRITE blocks\n+        ClusterBlockException blockException = state.blocks().globalBlockedException(ClusterBlockLevel.METADATA_WRITE);\n+        if (blockException != null) {\n+            return blockException;\n+        }\n+        return state.blocks().globalBlockedException(ClusterBlockLevel.WRITE);\n+\n+    }\n+\n+    /**\n+     * Return the index settings required to make a snapshot searchable\n+     */\n+    private static Settings getIndexSettings(String repoName, SnapshotId snapshotId, IndexId indexId) {\n+        return Settings.builder()\n+            .put(SearchableSnapshotRepository.SNAPSHOT_REPOSITORY_SETTING.getKey(), repoName)\n+            .put(SearchableSnapshotRepository.SNAPSHOT_SNAPSHOT_NAME_SETTING.getKey(), snapshotId.getName())\n+            .put(SearchableSnapshotRepository.SNAPSHOT_SNAPSHOT_ID_SETTING.getKey(), snapshotId.getUUID())\n+            .put(SearchableSnapshotRepository.SNAPSHOT_INDEX_ID_SETTING.getKey(), indexId.getId())\n+            .put(INDEX_STORE_TYPE_SETTING.getKey(), SearchableSnapshotRepository.SNAPSHOT_DIRECTORY_FACTORY_KEY)\n+            .put(IndexMetaData.SETTING_BLOCKS_WRITE, true)\n+            .build();\n+    }\n+\n+    @Override\n+    protected void masterOperation(Task task, final MountSearchableSnapshotRequest request, final ClusterState state,\n+                                   final ActionListener<RestoreSnapshotResponse> listener) {\n+        final String repoName = request.repository();\n+        final String snapName = request.snapshot();\n+        final String indexName = request.snapshotIndex();\n+\n+        // Retrieve IndexId and SnapshotId instances, which are then used to create a new restore\n+        // request, which is then sent on to the actual snapshot restore mechanism\n+        final Repository repository = repositoriesService.repository(repoName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c847e035baa2e0b370808aa7a52a6d59c5256a44"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU1MzkxNg==", "bodyText": "What are these exactly?", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r387553916", "createdAt": "2020-03-04T09:48:46Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/action/MountSearchableSnapshotRequest.java", "diffHunk": "@@ -0,0 +1,435 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.searchablesnapshots.action;\n+\n+import org.elasticsearch.ElasticsearchGenerationException;\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.action.support.master.MasterNodeRequest;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.common.xcontent.XContentType;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.action.ValidateActions.addValidationError;\n+import static org.elasticsearch.common.settings.Settings.Builder.EMPTY_SETTINGS;\n+import static org.elasticsearch.common.settings.Settings.readSettingsFromStream;\n+import static org.elasticsearch.common.settings.Settings.writeSettingsToStream;\n+\n+public class MountSearchableSnapshotRequest extends MasterNodeRequest<MountSearchableSnapshotRequest> implements ToXContentObject {\n+\n+    private final String mountedIndex;\n+    private String snapshot;\n+    private String repository;\n+    private String snapshotIndex;\n+    private Boolean waitForCompletion;\n+    private Settings settings = EMPTY_SETTINGS;\n+    private Settings indexSettings = EMPTY_SETTINGS;\n+    private String[] ignoreIndexSettings = Strings.EMPTY_ARRAY;\n+\n+    /**\n+     * Constructs a new put repository request with the provided repository and snapshot names.\n+     */\n+    public MountSearchableSnapshotRequest(String mountedIndex) {\n+        this.mountedIndex = mountedIndex;\n+    }\n+\n+    public MountSearchableSnapshotRequest(StreamInput in) throws IOException {\n+        super(in);\n+        this.snapshot = in.readString();\n+        this.repository = in.readString();\n+        this.snapshotIndex = in.readString();\n+        this.mountedIndex = in.readString();\n+        this.waitForCompletion = in.readOptionalBoolean();\n+        this.settings = readSettingsFromStream(in);\n+        this.indexSettings = readSettingsFromStream(in);\n+        this.ignoreIndexSettings = in.readStringArray();\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        super.writeTo(out);\n+        out.writeString(snapshot);\n+        out.writeString(repository);\n+        out.writeString(snapshotIndex);\n+        out.writeString(mountedIndex);\n+        out.writeOptionalBoolean(waitForCompletion);\n+        writeSettingsToStream(settings, out);\n+        writeSettingsToStream(indexSettings, out);\n+        out.writeStringArray(ignoreIndexSettings);\n+    }\n+\n+    @Override\n+    public ActionRequestValidationException validate() {\n+        ActionRequestValidationException validationException = null;\n+        if (snapshot == null) {\n+            validationException = addValidationError(\"snapshot name is missing\", validationException);\n+        }\n+        if (repository == null) {\n+            validationException = addValidationError(\"repository is missing\", validationException);\n+        }\n+        if (snapshotIndex == null) {\n+            validationException = addValidationError(\"index name from snapshot is missing\", validationException);\n+        }\n+        if (mountedIndex == null) {\n+            validationException = addValidationError(\"index name to mount is missing\", validationException);\n+        }\n+        if (settings == null) {\n+            validationException = addValidationError(\"settings are missing\", validationException);\n+        }\n+        if (indexSettings == null) {\n+            validationException = addValidationError(\"indexSettings are missing\", validationException);\n+        }\n+        return validationException;\n+    }\n+\n+    /**\n+     * Sets the name of the snapshot.\n+     *\n+     * @param snapshot snapshot name\n+     * @return this request\n+     */\n+    public MountSearchableSnapshotRequest snapshot(String snapshot) {\n+        this.snapshot = snapshot;\n+        return this;\n+    }\n+\n+    /**\n+     * Returns the name of the snapshot.\n+     *\n+     * @return snapshot name\n+     */\n+    public String snapshot() {\n+        return this.snapshot;\n+    }\n+\n+    /**\n+     * Sets repository name\n+     *\n+     * @param repository repository name\n+     * @return this request\n+     */\n+    public MountSearchableSnapshotRequest repository(String repository) {\n+        this.repository = repository;\n+        return this;\n+    }\n+\n+    /**\n+     * Returns repository name\n+     *\n+     * @return repository name\n+     */\n+    public String repository() {\n+        return this.repository;\n+    }\n+\n+    /**\n+     * Sets the name of the index that should be restored from snapshot\n+     */\n+    public MountSearchableSnapshotRequest snapshotIndex(String indexName) {\n+        this.snapshotIndex = indexName;\n+        return this;\n+    }\n+\n+    /**\n+     * Returns index that should be restored from snapshot\n+     */\n+    public String snapshotIndex() {\n+        return snapshotIndex;\n+    }\n+\n+    /**\n+     * Returns new index name after the snapshot has been mounted\n+     */\n+    public String mountedIndex() {\n+        return mountedIndex;\n+    }\n+\n+    /**\n+     * If this parameter is set to true the operation will wait for completion of restore process before returning.\n+     *\n+     * @param waitForCompletion if true the operation will wait for completion\n+     * @return this request\n+     */\n+    public MountSearchableSnapshotRequest waitForCompletion(boolean waitForCompletion) {\n+        this.waitForCompletion = waitForCompletion;\n+        return this;\n+    }\n+\n+    /**\n+     * Returns wait for completion setting\n+     *\n+     * @return true if the operation will wait for completion\n+     */\n+    public boolean waitForCompletion() {\n+        return waitForCompletion;\n+    }\n+\n+    /**\n+     * Sets repository-specific restore settings.\n+     * <p>\n+     * See repository documentation for more information.\n+     *\n+     * @param settings repository-specific snapshot settings\n+     * @return this request\n+     */\n+    public MountSearchableSnapshotRequest settings(Settings settings) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c847e035baa2e0b370808aa7a52a6d59c5256a44"}, "originalPosition": 190}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU1ODI3MA==", "bodyText": "I'm wondering if we need these verification - maybe we could just let the Restore action do it for us? (and configure appropriate indices options like ignore_unavailable: false)", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r387558270", "createdAt": "2020-03-04T09:56:28Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/action/TransportMountSearchableSnapshotAction.java", "diffHunk": "@@ -0,0 +1,158 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.searchablesnapshots.action;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.StepListener;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotResponse;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.master.TransportMasterNodeAction;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.block.ClusterBlockLevel;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.repositories.RepositoryData;\n+import org.elasticsearch.snapshots.SnapshotId;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotRepository;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static org.elasticsearch.index.IndexModule.INDEX_STORE_TYPE_SETTING;\n+\n+public class TransportMountSearchableSnapshotAction\n+    extends TransportMasterNodeAction<MountSearchableSnapshotRequest, RestoreSnapshotResponse> {\n+\n+    private final Client client;\n+    private final RepositoriesService repositoriesService;\n+\n+    @Inject\n+    public TransportMountSearchableSnapshotAction(TransportService transportService, ClusterService clusterService, Client client,\n+                                                  ThreadPool threadPool, RepositoriesService repositoriesService,\n+                                                  ActionFilters actionFilters, IndexNameExpressionResolver indexNameExpressionResolver) {\n+        super(MountSearchableSnapshotAction.NAME, transportService, clusterService, threadPool, actionFilters,\n+            MountSearchableSnapshotRequest::new, indexNameExpressionResolver);\n+        this.client = client;\n+        this.repositoriesService = repositoriesService;\n+    }\n+\n+    @Override\n+    protected String executor() {\n+        // Using the generic instead of the snapshot threadpool here as the snapshot threadpool might be blocked on long running tasks\n+        // which would block the request from getting an error response because of the ongoing task\n+        return ThreadPool.Names.GENERIC;\n+    }\n+\n+    @Override\n+    protected RestoreSnapshotResponse read(StreamInput in) throws IOException {\n+        return new RestoreSnapshotResponse(in);\n+    }\n+\n+    @Override\n+    protected ClusterBlockException checkBlock(MountSearchableSnapshotRequest request, ClusterState state) {\n+        // Restoring a snapshot might change the global state and create/change an index,\n+        // so we need to check for METADATA_WRITE and WRITE blocks\n+        ClusterBlockException blockException = state.blocks().globalBlockedException(ClusterBlockLevel.METADATA_WRITE);\n+        if (blockException != null) {\n+            return blockException;\n+        }\n+        return state.blocks().globalBlockedException(ClusterBlockLevel.WRITE);\n+\n+    }\n+\n+    /**\n+     * Return the index settings required to make a snapshot searchable\n+     */\n+    private static Settings getIndexSettings(String repoName, SnapshotId snapshotId, IndexId indexId) {\n+        return Settings.builder()\n+            .put(SearchableSnapshotRepository.SNAPSHOT_REPOSITORY_SETTING.getKey(), repoName)\n+            .put(SearchableSnapshotRepository.SNAPSHOT_SNAPSHOT_NAME_SETTING.getKey(), snapshotId.getName())\n+            .put(SearchableSnapshotRepository.SNAPSHOT_SNAPSHOT_ID_SETTING.getKey(), snapshotId.getUUID())\n+            .put(SearchableSnapshotRepository.SNAPSHOT_INDEX_ID_SETTING.getKey(), indexId.getId())\n+            .put(INDEX_STORE_TYPE_SETTING.getKey(), SearchableSnapshotRepository.SNAPSHOT_DIRECTORY_FACTORY_KEY)\n+            .put(IndexMetaData.SETTING_BLOCKS_WRITE, true)\n+            .build();\n+    }\n+\n+    @Override\n+    protected void masterOperation(Task task, final MountSearchableSnapshotRequest request, final ClusterState state,\n+                                   final ActionListener<RestoreSnapshotResponse> listener) {\n+        final String repoName = request.repository();\n+        final String snapName = request.snapshot();\n+        final String indexName = request.snapshotIndex();\n+\n+        // Retrieve IndexId and SnapshotId instances, which are then used to create a new restore\n+        // request, which is then sent on to the actual snapshot restore mechanism\n+        final Repository repository = repositoriesService.repository(repoName);\n+        final StepListener<RepositoryData> repositoryDataListener = new StepListener<>();\n+        repository.getRepositoryData(repositoryDataListener);\n+        repositoryDataListener.whenComplete(repoData -> {\n+            final Map<String, IndexId> indexIds = repoData.getIndices();\n+\n+            if (indexIds.containsKey(indexName) == false && indexIds.get(indexName) != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c847e035baa2e0b370808aa7a52a6d59c5256a44"}, "originalPosition": 111}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0cd28a37065b221b124d3e890f94cd6d0943023d", "author": {"user": {"login": "dakrone", "name": "Lee Hinman"}}, "url": "https://github.com/elastic/elasticsearch/commit/0cd28a37065b221b124d3e890f94cd6d0943023d", "committedDate": "2020-03-04T18:34:09Z", "message": "Update docstring for MountSearchableSnapshotRequest constructor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2bcab06cc58edf8981945f408dee83b40a8fecd0", "author": {"user": {"login": "dakrone", "name": "Lee Hinman"}}, "url": "https://github.com/elastic/elasticsearch/commit/2bcab06cc58edf8981945f408dee83b40a8fecd0", "committedDate": "2020-03-04T18:34:40Z", "message": "Remove extra line"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "000ee16dffa1b1b82fc4f7f6bc444677c932db53", "author": {"user": {"login": "dakrone", "name": "Lee Hinman"}}, "url": "https://github.com/elastic/elasticsearch/commit/000ee16dffa1b1b82fc4f7f6bc444677c932db53", "committedDate": "2020-03-04T18:36:35Z", "message": "Wrap repository fetching in try/catch"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5NDEzOTYx", "url": "https://github.com/elastic/elasticsearch/pull/53084#pullrequestreview-369413961", "createdAt": "2020-03-05T09:32:35Z", "commit": {"oid": "000ee16dffa1b1b82fc4f7f6bc444677c932db53"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQwOTozMjozNVrOFyMNNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQwOTo1MTozNVrOFyM3jA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODE3MzExMA==", "bodyText": "I'd prefer we did this TODO in this PR, since I think it would mean we could drop the need for validation and make all the required fields into constructor args (and final) instead.", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r388173110", "createdAt": "2020-03-05T09:32:35Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/action/MountSearchableSnapshotRequest.java", "diffHunk": "@@ -0,0 +1,435 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.searchablesnapshots.action;\n+\n+import org.elasticsearch.ElasticsearchGenerationException;\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.action.support.master.MasterNodeRequest;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.common.xcontent.XContentType;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.action.ValidateActions.addValidationError;\n+import static org.elasticsearch.common.settings.Settings.Builder.EMPTY_SETTINGS;\n+import static org.elasticsearch.common.settings.Settings.readSettingsFromStream;\n+import static org.elasticsearch.common.settings.Settings.writeSettingsToStream;\n+\n+public class MountSearchableSnapshotRequest extends MasterNodeRequest<MountSearchableSnapshotRequest> implements ToXContentObject {\n+\n+    private final String mountedIndex;\n+    private String snapshot;\n+    private String repository;\n+    private String snapshotIndex;\n+    private Boolean waitForCompletion;\n+    private Settings settings = EMPTY_SETTINGS;\n+    private Settings indexSettings = EMPTY_SETTINGS;\n+    private String[] ignoreIndexSettings = Strings.EMPTY_ARRAY;\n+\n+    /**\n+     * Constructs a new mount searchable snapshot request, restoring an index under the given mountedIndex name\n+     */\n+    public MountSearchableSnapshotRequest(String mountedIndex) {\n+        this.mountedIndex = mountedIndex;\n+    }\n+\n+    public MountSearchableSnapshotRequest(StreamInput in) throws IOException {\n+        super(in);\n+        this.snapshot = in.readString();\n+        this.repository = in.readString();\n+        this.snapshotIndex = in.readString();\n+        this.mountedIndex = in.readString();\n+        this.waitForCompletion = in.readOptionalBoolean();\n+        this.settings = readSettingsFromStream(in);\n+        this.indexSettings = readSettingsFromStream(in);\n+        this.ignoreIndexSettings = in.readStringArray();\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        super.writeTo(out);\n+        out.writeString(snapshot);\n+        out.writeString(repository);\n+        out.writeString(snapshotIndex);\n+        out.writeString(mountedIndex);\n+        out.writeOptionalBoolean(waitForCompletion);\n+        writeSettingsToStream(settings, out);\n+        writeSettingsToStream(indexSettings, out);\n+        out.writeStringArray(ignoreIndexSettings);\n+    }\n+\n+    @Override\n+    public ActionRequestValidationException validate() {\n+        ActionRequestValidationException validationException = null;\n+        if (snapshot == null) {\n+            validationException = addValidationError(\"snapshot name is missing\", validationException);\n+        }\n+        if (repository == null) {\n+            validationException = addValidationError(\"repository is missing\", validationException);\n+        }\n+        if (snapshotIndex == null) {\n+            validationException = addValidationError(\"index name from snapshot is missing\", validationException);\n+        }\n+        if (mountedIndex == null) {\n+            validationException = addValidationError(\"index name to mount is missing\", validationException);\n+        }\n+        if (settings == null) {\n+            validationException = addValidationError(\"settings are missing\", validationException);\n+        }\n+        if (indexSettings == null) {\n+            validationException = addValidationError(\"indexSettings are missing\", validationException);\n+        }\n+        return validationException;\n+    }\n+\n+    /**\n+     * Sets the name of the snapshot.\n+     *\n+     * @param snapshot snapshot name\n+     * @return this request\n+     */\n+    public MountSearchableSnapshotRequest snapshot(String snapshot) {\n+        this.snapshot = snapshot;\n+        return this;\n+    }\n+\n+    /**\n+     * Returns the name of the snapshot.\n+     *\n+     * @return snapshot name\n+     */\n+    public String snapshot() {\n+        return this.snapshot;\n+    }\n+\n+    /**\n+     * Sets repository name\n+     *\n+     * @param repository repository name\n+     * @return this request\n+     */\n+    public MountSearchableSnapshotRequest repository(String repository) {\n+        this.repository = repository;\n+        return this;\n+    }\n+\n+    /**\n+     * Returns repository name\n+     *\n+     * @return repository name\n+     */\n+    public String repository() {\n+        return this.repository;\n+    }\n+\n+    /**\n+     * Sets the name of the index that should be restored from snapshot\n+     */\n+    public MountSearchableSnapshotRequest snapshotIndex(String indexName) {\n+        this.snapshotIndex = indexName;\n+        return this;\n+    }\n+\n+    /**\n+     * Returns index that should be restored from snapshot\n+     */\n+    public String snapshotIndex() {\n+        return snapshotIndex;\n+    }\n+\n+    /**\n+     * Returns new index name after the snapshot has been mounted\n+     */\n+    public String mountedIndex() {\n+        return mountedIndex;\n+    }\n+\n+    /**\n+     * If this parameter is set to true the operation will wait for completion of restore process before returning.\n+     *\n+     * @param waitForCompletion if true the operation will wait for completion\n+     * @return this request\n+     */\n+    public MountSearchableSnapshotRequest waitForCompletion(boolean waitForCompletion) {\n+        this.waitForCompletion = waitForCompletion;\n+        return this;\n+    }\n+\n+    /**\n+     * Returns wait for completion setting\n+     *\n+     * @return true if the operation will wait for completion\n+     */\n+    public boolean waitForCompletion() {\n+        return waitForCompletion;\n+    }\n+\n+    /**\n+     * Sets repository-specific restore settings.\n+     * <p>\n+     * See repository documentation for more information.\n+     *\n+     * @param settings repository-specific snapshot settings\n+     * @return this request\n+     */\n+    public MountSearchableSnapshotRequest settings(Settings settings) {\n+        this.settings = settings;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets repository-specific restore settings.\n+     * <p>\n+     * See repository documentation for more information.\n+     *\n+     * @param settings repository-specific snapshot settings\n+     * @return this request\n+     */\n+    public MountSearchableSnapshotRequest settings(Settings.Builder settings) {\n+        this.settings = settings.build();\n+        return this;\n+    }\n+\n+    /**\n+     * Sets repository-specific restore settings in JSON or YAML format\n+     * <p>\n+     * See repository documentation for more information.\n+     *\n+     * @param source repository-specific snapshot settings\n+     * @param xContentType the content type of the source\n+     * @return this request\n+     */\n+    public MountSearchableSnapshotRequest settings(String source, XContentType xContentType) {\n+        this.settings = Settings.builder().loadFromSource(source, xContentType).build();\n+        return this;\n+    }\n+\n+    /**\n+     * Sets repository-specific restore settings\n+     * <p>\n+     * See repository documentation for more information.\n+     *\n+     * @param source repository-specific snapshot settings\n+     * @return this request\n+     */\n+    public MountSearchableSnapshotRequest settings(Map<String, Object> source) {\n+        try {\n+            XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON);\n+            builder.map(source);\n+            settings(Strings.toString(builder), builder.contentType());\n+        } catch (IOException e) {\n+            throw new ElasticsearchGenerationException(\"Failed to generate [\" + source + \"]\", e);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Returns repository-specific restore settings\n+     *\n+     * @return restore settings\n+     */\n+    public Settings settings() {\n+        return this.settings;\n+    }\n+\n+    /**\n+     * Sets the list of index settings and index settings groups that shouldn't be restored from snapshot\n+     */\n+    public MountSearchableSnapshotRequest ignoreIndexSettings(String... ignoreIndexSettings) {\n+        this.ignoreIndexSettings = ignoreIndexSettings;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the list of index settings and index settings groups that shouldn't be restored from snapshot\n+     */\n+    public MountSearchableSnapshotRequest ignoreIndexSettings(List<String> ignoreIndexSettings) {\n+        this.ignoreIndexSettings = ignoreIndexSettings.toArray(new String[ignoreIndexSettings.size()]);\n+        return this;\n+    }\n+\n+    /**\n+     * Returns the list of index settings and index settings groups that shouldn't be restored from snapshot\n+     */\n+    public String[] ignoreIndexSettings() {\n+        return ignoreIndexSettings;\n+    }\n+\n+    /**\n+     * Sets settings that should be added/changed for restored index\n+     */\n+    public MountSearchableSnapshotRequest indexSettings(Settings settings) {\n+        this.indexSettings = settings;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets settings that should be added/changed for restored index\n+     */\n+    public MountSearchableSnapshotRequest indexSettings(Settings.Builder settings) {\n+        this.indexSettings = settings.build();\n+        return this;\n+    }\n+\n+    /**\n+     * Sets settings that should be added/changed for restored index\n+     */\n+    public MountSearchableSnapshotRequest indexSettings(String source, XContentType xContentType) {\n+        this.indexSettings = Settings.builder().loadFromSource(source, xContentType).build();\n+        return this;\n+    }\n+\n+    /**\n+     * Sets settings that should be added/changed for restored index\n+     */\n+    public MountSearchableSnapshotRequest indexSettings(Map<String, Object> source) {\n+        try {\n+            XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON);\n+            builder.map(source);\n+            indexSettings(Strings.toString(builder), builder.contentType());\n+        } catch (IOException e) {\n+            throw new ElasticsearchGenerationException(\"Failed to generate [\" + source + \"]\", e);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Returns settings that should be added/changed for restored index\n+     */\n+    public Settings indexSettings() {\n+        return this.indexSettings;\n+    }\n+\n+    /**\n+     * Parses mount definition\n+     *\n+     * @param source mount definition\n+     * @return this request\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public MountSearchableSnapshotRequest source(Map<String, Object> source) {\n+        // TODO: this could be rewritten with a Constructing Object Parser rather than manually\n+        //  parsing the XContent, this was copied/modified from RestoreSnapshotRequest", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "000ee16dffa1b1b82fc4f7f6bc444677c932db53"}, "originalPosition": 327}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODE3NDg0OQ==", "bodyText": "I'm with Tanguy here, I think it would be good to remove SearchableSnapshotRepository in this PR.", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r388174849", "createdAt": "2020-03-05T09:35:39Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/SearchableSnapshotRepository.java", "diffHunk": "@@ -160,16 +164,17 @@ public Repository create(RepositoryMetaData metaData, Function<String, Factory>\n         return (indexSettings, shardPath) -> {\n             final RepositoriesService repositories = repositoriesService.get();\n             assert repositories != null;\n-\n-            final Repository repository = repositories.repository(SNAPSHOT_REPOSITORY_SETTING.get(indexSettings.getSettings()));\n-            if (repository instanceof SearchableSnapshotRepository == false) {\n-                throw new IllegalArgumentException(\"Repository [\" + repository + \"] is not searchable\");\n-            }\n-\n             final CacheService cache = cacheService.get();\n             assert cache != null;\n \n-            return ((SearchableSnapshotRepository) repository).makeDirectory(indexSettings, shardPath, cache, currentTimeNanosSupplier);\n+            final Repository repository = repositories.repository(SNAPSHOT_REPOSITORY_SETTING.get(indexSettings.getSettings()));\n+            // TODO: is this okay?\n+//            if (repository instanceof SearchableSnapshotRepository == false) {\n+//                throw new IllegalArgumentException(\"Repository [\" + repository + \"] is not searchable\");\n+//            }\n+\n+            SearchableSnapshotRepository searchableRepo = new SearchableSnapshotRepository(repository);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU0MjA2NA=="}, "originalCommit": {"oid": "c847e035baa2e0b370808aa7a52a6d59c5256a44"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODE4Mzk0OA==", "bodyText": "I think just POST is sufficient, in line with the restore API. We're not creating a resource at this URI as PUT  would imply.", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r388183948", "createdAt": "2020-03-05T09:51:35Z", "author": {"login": "DaveCTurner"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/rest/RestMountSearchableSnapshotAction.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.searchablesnapshots.rest;\n+\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.rest.BaseRestHandler;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.action.RestToXContentListener;\n+import org.elasticsearch.xpack.searchablesnapshots.action.MountSearchableSnapshotAction;\n+import org.elasticsearch.xpack.searchablesnapshots.action.MountSearchableSnapshotRequest;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static org.elasticsearch.rest.RestRequest.Method.POST;\n+import static org.elasticsearch.rest.RestRequest.Method.PUT;\n+\n+public class RestMountSearchableSnapshotAction extends BaseRestHandler {\n+    @Override\n+    public String getName() {\n+        return \"mount_snapshot_action\";\n+    }\n+\n+    @Override\n+    public List<Route> routes() {\n+        return Arrays.asList(new Route(POST, \"/{index}/_snapshot/mount\"),\n+            new Route(PUT, \"/{index}/_snapshot/mount\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "000ee16dffa1b1b82fc4f7f6bc444677c932db53"}, "originalPosition": 32}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "74212e11ba35bdda4f07e216d15bfc3631eb2ccf", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/74212e11ba35bdda4f07e216d15bfc3631eb2ccf", "committedDate": "2020-03-05T18:00:00Z", "message": "ConstructingObjectParser"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b4933e547ef34a23fbc522c70205567d36d5b5d9", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/b4933e547ef34a23fbc522c70205567d36d5b5d9", "committedDate": "2020-03-06T11:08:52Z", "message": "Tidy up transport action"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ff16586957b240aeba35d9a9a6b23f6f37006b5d", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/ff16586957b240aeba35d9a9a6b23f6f37006b5d", "committedDate": "2020-03-06T11:08:52Z", "message": "Revert"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "520673e5505ade3a6e17a73829ebd71f6822d0a8", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/520673e5505ade3a6e17a73829ebd71f6822d0a8", "committedDate": "2020-03-06T12:23:22Z", "message": "Fix up REST tests and a  bit of a refactor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4cbf27e33c1f4ff28475cf2705136fbe3d46711c", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/4cbf27e33c1f4ff28475cf2705136fbe3d46711c", "committedDate": "2020-03-06T12:37:34Z", "message": "Move more code  out  of SearchableSnapshotRepository"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4ad409b41801d78137832d0c8f3d099a4f968853", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/4ad409b41801d78137832d0c8f3d099a4f968853", "committedDate": "2020-03-06T12:47:15Z", "message": "Move factory around"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f44d68fcb7bcf84874398d366bd4555bc0151056", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/f44d68fcb7bcf84874398d366bd4555bc0151056", "committedDate": "2020-03-06T12:52:21Z", "message": "Move settings etc."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "595a74f2bee65cee0fd6066e0e5533bd3949af54", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/595a74f2bee65cee0fd6066e0e5533bd3949af54", "committedDate": "2020-03-06T13:04:07Z", "message": "Whitespace"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "924a74131ccae10ed0d9414f87552a02facce63e", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/924a74131ccae10ed0d9414f87552a02facce63e", "committedDate": "2020-03-06T13:15:49Z", "message": "Less nullability"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fd9d85803494939cc2facbb96e4c7b003080b62b", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/fd9d85803494939cc2facbb96e4c7b003080b62b", "committedDate": "2020-03-06T13:16:57Z", "message": "Final"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7297b3583383b899986e04f754851ef182a2a152", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/7297b3583383b899986e04f754851ef182a2a152", "committedDate": "2020-03-06T13:33:06Z", "message": "More tidy"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dae1d9328687eb96c0038c2d463c970e89dcb353", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/dae1d9328687eb96c0038c2d463c970e89dcb353", "committedDate": "2020-03-06T13:54:42Z", "message": "Rejig API shape"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "366f4561a03ff02e35a5005a4443f259e4bbdaf6", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/366f4561a03ff02e35a5005a4443f259e4bbdaf6", "committedDate": "2020-03-06T14:06:01Z", "message": "Merge branch 'feature/searchable-snapshots' into ss-add-dedicated-restore-api"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "96ab3241962d5a38d94f82185f9667f209dd4e4c", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/96ab3241962d5a38d94f82185f9667f209dd4e4c", "committedDate": "2020-03-06T16:20:14Z", "message": "Merge branch 'feature/searchable-snapshots' into ss-add-dedicated-restore-api"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwOTkzOTIw", "url": "https://github.com/elastic/elasticsearch/pull/53084#pullrequestreview-370993920", "createdAt": "2020-03-09T08:52:14Z", "commit": {"oid": "96ab3241962d5a38d94f82185f9667f209dd4e4c"}, "state": "COMMENTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQwODo1MjoxNFrOFzezgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQwOTo0MTozNFrOFzgRkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTUyNjQwMg==", "bodyText": "Thanks Lee, I do agree with your reasoning here.", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r389526402", "createdAt": "2020-03-09T08:52:14Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/action/MountSearchableSnapshotAction.java", "diffHunk": "@@ -0,0 +1,20 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.searchablesnapshots.action;\n+\n+import org.elasticsearch.action.ActionType;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotResponse;\n+\n+public class MountSearchableSnapshotAction extends ActionType<RestoreSnapshotResponse> {\n+\n+    public static final MountSearchableSnapshotAction INSTANCE = new MountSearchableSnapshotAction();\n+    public static final String NAME = \"cluster:admin/snapshot/mount\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU0NDk5Mg=="}, "originalCommit": {"oid": "c847e035baa2e0b370808aa7a52a6d59c5256a44"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTUyNzUxNQ==", "bodyText": "Should we validate that the request contains a repo/snapshot/index?", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r389527515", "createdAt": "2020-03-09T08:54:41Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/action/MountSearchableSnapshotRequest.java", "diffHunk": "@@ -0,0 +1,223 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.searchablesnapshots.action;\n+\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.support.master.MasterNodeRequest;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.common.settings.Settings.readSettingsFromStream;\n+import static org.elasticsearch.common.settings.Settings.writeSettingsToStream;\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.constructorArg;\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.optionalConstructorArg;\n+\n+public class MountSearchableSnapshotRequest extends MasterNodeRequest<MountSearchableSnapshotRequest> implements ToXContentObject {\n+\n+    public static final ConstructingObjectParser<MountSearchableSnapshotRequest, RequestParams> PARSER = new ConstructingObjectParser<>(\n+        \"mount_searchable_snapshot\", true,\n+        (a, p) -> new MountSearchableSnapshotRequest(\n+            Objects.requireNonNullElse((String)a[1], (String)a[0]),\n+            p.repositoryName,\n+            p.snapshotName,\n+            (String)a[0],\n+            Objects.requireNonNullElse((Settings)a[2], Settings.EMPTY),\n+            Objects.requireNonNullElse((String[])a[3], Strings.EMPTY_ARRAY),\n+            p.waitForCompletion));\n+\n+    private static final ParseField INDEX_FIELD = new ParseField(\"index\");\n+    private static final ParseField RENAMED_INDEX_FIELD = new ParseField(\"renamed_index\");\n+    private static final ParseField INDEX_SETTINGS_FIELD = new ParseField(\"index_settings\");\n+    private static final ParseField IGNORE_INDEX_SETTINGS_FIELD = new ParseField(\"ignore_index_settings\");\n+\n+    static {\n+        PARSER.declareField(constructorArg(), XContentParser::text, INDEX_FIELD, ObjectParser.ValueType.STRING);\n+        PARSER.declareField(optionalConstructorArg(), XContentParser::text, RENAMED_INDEX_FIELD, ObjectParser.ValueType.STRING);\n+        PARSER.declareField(optionalConstructorArg(), Settings::fromXContent, INDEX_SETTINGS_FIELD, ObjectParser.ValueType.OBJECT);\n+        PARSER.declareField(optionalConstructorArg(),\n+            p -> p.list().stream().map(s -> (String) s).collect(Collectors.toList()).toArray(Strings.EMPTY_ARRAY),\n+            IGNORE_INDEX_SETTINGS_FIELD, ObjectParser.ValueType.STRING_ARRAY);\n+    }\n+\n+    public static class RequestParams {\n+        private final String repositoryName;\n+        private final String snapshotName;\n+        final boolean waitForCompletion;\n+\n+        public RequestParams(String repositoryName, String snapshotName, boolean waitForCompletion) {\n+            this.repositoryName = repositoryName;\n+            this.snapshotName = snapshotName;\n+            this.waitForCompletion = waitForCompletion;\n+        }\n+    }\n+\n+    private final String mountedIndexName;\n+    private final String repositoryName;\n+    private final String snapshotName;\n+    private final String snapshotIndexName;\n+    private final Settings indexSettings;\n+    private final String[] ignoredIndexSettings;\n+    private final boolean waitForCompletion;\n+\n+    /**\n+     * Constructs a new mount searchable snapshot request, restoring an index with the settings needed to make it a searchable snapshot.\n+     */\n+    public MountSearchableSnapshotRequest(String mountedIndexName, String repositoryName, String snapshotName, String snapshotIndexName,\n+                                          Settings indexSettings, String[] ignoredIndexSettings, boolean waitForCompletion) {\n+        this.mountedIndexName = Objects.requireNonNull(mountedIndexName);\n+        this.repositoryName = Objects.requireNonNull(repositoryName);\n+        this.snapshotName = Objects.requireNonNull(snapshotName);\n+        this.snapshotIndexName = Objects.requireNonNull(snapshotIndexName);\n+        this.indexSettings = Objects.requireNonNull(indexSettings);\n+        this.ignoredIndexSettings = Objects.requireNonNull(ignoredIndexSettings);\n+        this.waitForCompletion = waitForCompletion;\n+    }\n+\n+    MountSearchableSnapshotRequest(StreamInput in) throws IOException {\n+        super(in);\n+        this.mountedIndexName = in.readString();\n+        this.repositoryName = in.readString();\n+        this.snapshotName = in.readString();\n+        this.snapshotIndexName = in.readOptionalString();\n+        this.indexSettings = readSettingsFromStream(in);\n+        this.ignoredIndexSettings = in.readStringArray();\n+        this.waitForCompletion = in.readBoolean();\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        super.writeTo(out);\n+        out.writeString(mountedIndexName);\n+        out.writeString(repositoryName);\n+        out.writeString(snapshotName);\n+        out.writeOptionalString(snapshotIndexName);\n+        writeSettingsToStream(indexSettings, out);\n+        out.writeStringArray(ignoredIndexSettings);\n+        out.writeBoolean(waitForCompletion);\n+    }\n+\n+    @Override\n+    public ActionRequestValidationException validate() {\n+       return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96ab3241962d5a38d94f82185f9667f209dd4e4c"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTUzMTE0Nw==", "bodyText": "Maybe pass the RestRequest directly to the ObjectParser's context when applying the parsing logic?", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r389531147", "createdAt": "2020-03-09T09:02:42Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/action/MountSearchableSnapshotRequest.java", "diffHunk": "@@ -0,0 +1,223 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.searchablesnapshots.action;\n+\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.support.master.MasterNodeRequest;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.common.settings.Settings.readSettingsFromStream;\n+import static org.elasticsearch.common.settings.Settings.writeSettingsToStream;\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.constructorArg;\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.optionalConstructorArg;\n+\n+public class MountSearchableSnapshotRequest extends MasterNodeRequest<MountSearchableSnapshotRequest> implements ToXContentObject {\n+\n+    public static final ConstructingObjectParser<MountSearchableSnapshotRequest, RequestParams> PARSER = new ConstructingObjectParser<>(\n+        \"mount_searchable_snapshot\", true,\n+        (a, p) -> new MountSearchableSnapshotRequest(\n+            Objects.requireNonNullElse((String)a[1], (String)a[0]),\n+            p.repositoryName,\n+            p.snapshotName,\n+            (String)a[0],\n+            Objects.requireNonNullElse((Settings)a[2], Settings.EMPTY),\n+            Objects.requireNonNullElse((String[])a[3], Strings.EMPTY_ARRAY),\n+            p.waitForCompletion));\n+\n+    private static final ParseField INDEX_FIELD = new ParseField(\"index\");\n+    private static final ParseField RENAMED_INDEX_FIELD = new ParseField(\"renamed_index\");\n+    private static final ParseField INDEX_SETTINGS_FIELD = new ParseField(\"index_settings\");\n+    private static final ParseField IGNORE_INDEX_SETTINGS_FIELD = new ParseField(\"ignore_index_settings\");\n+\n+    static {\n+        PARSER.declareField(constructorArg(), XContentParser::text, INDEX_FIELD, ObjectParser.ValueType.STRING);\n+        PARSER.declareField(optionalConstructorArg(), XContentParser::text, RENAMED_INDEX_FIELD, ObjectParser.ValueType.STRING);\n+        PARSER.declareField(optionalConstructorArg(), Settings::fromXContent, INDEX_SETTINGS_FIELD, ObjectParser.ValueType.OBJECT);\n+        PARSER.declareField(optionalConstructorArg(),\n+            p -> p.list().stream().map(s -> (String) s).collect(Collectors.toList()).toArray(Strings.EMPTY_ARRAY),\n+            IGNORE_INDEX_SETTINGS_FIELD, ObjectParser.ValueType.STRING_ARRAY);\n+    }\n+\n+    public static class RequestParams {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96ab3241962d5a38d94f82185f9667f209dd4e4c"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTUzMjMzMg==", "bodyText": "Generating a XContent from a request object is useful for the RestHighLevelClient only (we don't really need it for testing the server logic) so I think this code should be moved to the rest-high-level project in a different PR. We'll have to upgrade the RestHighLevelClient to support other searchable snapshot APIs anyway and we can do it later.", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r389532332", "createdAt": "2020-03-09T09:05:20Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/action/MountSearchableSnapshotRequest.java", "diffHunk": "@@ -0,0 +1,223 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.searchablesnapshots.action;\n+\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.support.master.MasterNodeRequest;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.common.settings.Settings.readSettingsFromStream;\n+import static org.elasticsearch.common.settings.Settings.writeSettingsToStream;\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.constructorArg;\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.optionalConstructorArg;\n+\n+public class MountSearchableSnapshotRequest extends MasterNodeRequest<MountSearchableSnapshotRequest> implements ToXContentObject {\n+\n+    public static final ConstructingObjectParser<MountSearchableSnapshotRequest, RequestParams> PARSER = new ConstructingObjectParser<>(\n+        \"mount_searchable_snapshot\", true,\n+        (a, p) -> new MountSearchableSnapshotRequest(\n+            Objects.requireNonNullElse((String)a[1], (String)a[0]),\n+            p.repositoryName,\n+            p.snapshotName,\n+            (String)a[0],\n+            Objects.requireNonNullElse((Settings)a[2], Settings.EMPTY),\n+            Objects.requireNonNullElse((String[])a[3], Strings.EMPTY_ARRAY),\n+            p.waitForCompletion));\n+\n+    private static final ParseField INDEX_FIELD = new ParseField(\"index\");\n+    private static final ParseField RENAMED_INDEX_FIELD = new ParseField(\"renamed_index\");\n+    private static final ParseField INDEX_SETTINGS_FIELD = new ParseField(\"index_settings\");\n+    private static final ParseField IGNORE_INDEX_SETTINGS_FIELD = new ParseField(\"ignore_index_settings\");\n+\n+    static {\n+        PARSER.declareField(constructorArg(), XContentParser::text, INDEX_FIELD, ObjectParser.ValueType.STRING);\n+        PARSER.declareField(optionalConstructorArg(), XContentParser::text, RENAMED_INDEX_FIELD, ObjectParser.ValueType.STRING);\n+        PARSER.declareField(optionalConstructorArg(), Settings::fromXContent, INDEX_SETTINGS_FIELD, ObjectParser.ValueType.OBJECT);\n+        PARSER.declareField(optionalConstructorArg(),\n+            p -> p.list().stream().map(s -> (String) s).collect(Collectors.toList()).toArray(Strings.EMPTY_ARRAY),\n+            IGNORE_INDEX_SETTINGS_FIELD, ObjectParser.ValueType.STRING_ARRAY);\n+    }\n+\n+    public static class RequestParams {\n+        private final String repositoryName;\n+        private final String snapshotName;\n+        final boolean waitForCompletion;\n+\n+        public RequestParams(String repositoryName, String snapshotName, boolean waitForCompletion) {\n+            this.repositoryName = repositoryName;\n+            this.snapshotName = snapshotName;\n+            this.waitForCompletion = waitForCompletion;\n+        }\n+    }\n+\n+    private final String mountedIndexName;\n+    private final String repositoryName;\n+    private final String snapshotName;\n+    private final String snapshotIndexName;\n+    private final Settings indexSettings;\n+    private final String[] ignoredIndexSettings;\n+    private final boolean waitForCompletion;\n+\n+    /**\n+     * Constructs a new mount searchable snapshot request, restoring an index with the settings needed to make it a searchable snapshot.\n+     */\n+    public MountSearchableSnapshotRequest(String mountedIndexName, String repositoryName, String snapshotName, String snapshotIndexName,\n+                                          Settings indexSettings, String[] ignoredIndexSettings, boolean waitForCompletion) {\n+        this.mountedIndexName = Objects.requireNonNull(mountedIndexName);\n+        this.repositoryName = Objects.requireNonNull(repositoryName);\n+        this.snapshotName = Objects.requireNonNull(snapshotName);\n+        this.snapshotIndexName = Objects.requireNonNull(snapshotIndexName);\n+        this.indexSettings = Objects.requireNonNull(indexSettings);\n+        this.ignoredIndexSettings = Objects.requireNonNull(ignoredIndexSettings);\n+        this.waitForCompletion = waitForCompletion;\n+    }\n+\n+    MountSearchableSnapshotRequest(StreamInput in) throws IOException {\n+        super(in);\n+        this.mountedIndexName = in.readString();\n+        this.repositoryName = in.readString();\n+        this.snapshotName = in.readString();\n+        this.snapshotIndexName = in.readOptionalString();\n+        this.indexSettings = readSettingsFromStream(in);\n+        this.ignoredIndexSettings = in.readStringArray();\n+        this.waitForCompletion = in.readBoolean();\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        super.writeTo(out);\n+        out.writeString(mountedIndexName);\n+        out.writeString(repositoryName);\n+        out.writeString(snapshotName);\n+        out.writeOptionalString(snapshotIndexName);\n+        writeSettingsToStream(indexSettings, out);\n+        out.writeStringArray(ignoredIndexSettings);\n+        out.writeBoolean(waitForCompletion);\n+    }\n+\n+    @Override\n+    public ActionRequestValidationException validate() {\n+       return null;\n+    }\n+\n+    /**\n+     * @return the name of the index that will be created\n+     */\n+    public String mountedIndexName() {\n+        return mountedIndexName;\n+    }\n+\n+    /**\n+     * @return the name of the repository\n+     */\n+    public String repositoryName() {\n+        return this.repositoryName;\n+    }\n+\n+    /**\n+     * @return the name of the snapshot.\n+     */\n+    public String snapshotName() {\n+        return this.snapshotName;\n+    }\n+\n+    /**\n+     * @return the name of the index contained in the snapshot\n+     */\n+    public String snapshotIndexName() {\n+        return snapshotIndexName;\n+    }\n+\n+    /**\n+     * @return true if the operation will wait for completion\n+     */\n+    public boolean waitForCompletion() {\n+        return waitForCompletion;\n+    }\n+\n+    /**\n+     * @return settings that should be added to the index when it is mounted\n+     */\n+    public Settings indexSettings() {\n+        return this.indexSettings;\n+    }\n+\n+    /**\n+     * @return the names of settings that should be removed from the index when it is mounted\n+     */\n+    public String[] ignoreIndexSettings() {\n+        return ignoredIndexSettings;\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96ab3241962d5a38d94f82185f9667f209dd4e4c"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTUzMjgyMA==", "bodyText": "Maybe:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return \"mount snapshot [\" + repositoryName + \":\" + snapshotName + \":\" + snapshotIndexName + \"->\" + mountedIndexName + \"]\";\n          \n          \n            \n                    return \"mount snapshot [\" + repositoryName + \":\" + snapshotName + \":\" + snapshotIndexName + \"] as index [\" + mountedIndexName + \"]\";", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r389532820", "createdAt": "2020-03-09T09:06:21Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/action/MountSearchableSnapshotRequest.java", "diffHunk": "@@ -0,0 +1,223 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.searchablesnapshots.action;\n+\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.support.master.MasterNodeRequest;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.common.settings.Settings.readSettingsFromStream;\n+import static org.elasticsearch.common.settings.Settings.writeSettingsToStream;\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.constructorArg;\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.optionalConstructorArg;\n+\n+public class MountSearchableSnapshotRequest extends MasterNodeRequest<MountSearchableSnapshotRequest> implements ToXContentObject {\n+\n+    public static final ConstructingObjectParser<MountSearchableSnapshotRequest, RequestParams> PARSER = new ConstructingObjectParser<>(\n+        \"mount_searchable_snapshot\", true,\n+        (a, p) -> new MountSearchableSnapshotRequest(\n+            Objects.requireNonNullElse((String)a[1], (String)a[0]),\n+            p.repositoryName,\n+            p.snapshotName,\n+            (String)a[0],\n+            Objects.requireNonNullElse((Settings)a[2], Settings.EMPTY),\n+            Objects.requireNonNullElse((String[])a[3], Strings.EMPTY_ARRAY),\n+            p.waitForCompletion));\n+\n+    private static final ParseField INDEX_FIELD = new ParseField(\"index\");\n+    private static final ParseField RENAMED_INDEX_FIELD = new ParseField(\"renamed_index\");\n+    private static final ParseField INDEX_SETTINGS_FIELD = new ParseField(\"index_settings\");\n+    private static final ParseField IGNORE_INDEX_SETTINGS_FIELD = new ParseField(\"ignore_index_settings\");\n+\n+    static {\n+        PARSER.declareField(constructorArg(), XContentParser::text, INDEX_FIELD, ObjectParser.ValueType.STRING);\n+        PARSER.declareField(optionalConstructorArg(), XContentParser::text, RENAMED_INDEX_FIELD, ObjectParser.ValueType.STRING);\n+        PARSER.declareField(optionalConstructorArg(), Settings::fromXContent, INDEX_SETTINGS_FIELD, ObjectParser.ValueType.OBJECT);\n+        PARSER.declareField(optionalConstructorArg(),\n+            p -> p.list().stream().map(s -> (String) s).collect(Collectors.toList()).toArray(Strings.EMPTY_ARRAY),\n+            IGNORE_INDEX_SETTINGS_FIELD, ObjectParser.ValueType.STRING_ARRAY);\n+    }\n+\n+    public static class RequestParams {\n+        private final String repositoryName;\n+        private final String snapshotName;\n+        final boolean waitForCompletion;\n+\n+        public RequestParams(String repositoryName, String snapshotName, boolean waitForCompletion) {\n+            this.repositoryName = repositoryName;\n+            this.snapshotName = snapshotName;\n+            this.waitForCompletion = waitForCompletion;\n+        }\n+    }\n+\n+    private final String mountedIndexName;\n+    private final String repositoryName;\n+    private final String snapshotName;\n+    private final String snapshotIndexName;\n+    private final Settings indexSettings;\n+    private final String[] ignoredIndexSettings;\n+    private final boolean waitForCompletion;\n+\n+    /**\n+     * Constructs a new mount searchable snapshot request, restoring an index with the settings needed to make it a searchable snapshot.\n+     */\n+    public MountSearchableSnapshotRequest(String mountedIndexName, String repositoryName, String snapshotName, String snapshotIndexName,\n+                                          Settings indexSettings, String[] ignoredIndexSettings, boolean waitForCompletion) {\n+        this.mountedIndexName = Objects.requireNonNull(mountedIndexName);\n+        this.repositoryName = Objects.requireNonNull(repositoryName);\n+        this.snapshotName = Objects.requireNonNull(snapshotName);\n+        this.snapshotIndexName = Objects.requireNonNull(snapshotIndexName);\n+        this.indexSettings = Objects.requireNonNull(indexSettings);\n+        this.ignoredIndexSettings = Objects.requireNonNull(ignoredIndexSettings);\n+        this.waitForCompletion = waitForCompletion;\n+    }\n+\n+    MountSearchableSnapshotRequest(StreamInput in) throws IOException {\n+        super(in);\n+        this.mountedIndexName = in.readString();\n+        this.repositoryName = in.readString();\n+        this.snapshotName = in.readString();\n+        this.snapshotIndexName = in.readOptionalString();\n+        this.indexSettings = readSettingsFromStream(in);\n+        this.ignoredIndexSettings = in.readStringArray();\n+        this.waitForCompletion = in.readBoolean();\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        super.writeTo(out);\n+        out.writeString(mountedIndexName);\n+        out.writeString(repositoryName);\n+        out.writeString(snapshotName);\n+        out.writeOptionalString(snapshotIndexName);\n+        writeSettingsToStream(indexSettings, out);\n+        out.writeStringArray(ignoredIndexSettings);\n+        out.writeBoolean(waitForCompletion);\n+    }\n+\n+    @Override\n+    public ActionRequestValidationException validate() {\n+       return null;\n+    }\n+\n+    /**\n+     * @return the name of the index that will be created\n+     */\n+    public String mountedIndexName() {\n+        return mountedIndexName;\n+    }\n+\n+    /**\n+     * @return the name of the repository\n+     */\n+    public String repositoryName() {\n+        return this.repositoryName;\n+    }\n+\n+    /**\n+     * @return the name of the snapshot.\n+     */\n+    public String snapshotName() {\n+        return this.snapshotName;\n+    }\n+\n+    /**\n+     * @return the name of the index contained in the snapshot\n+     */\n+    public String snapshotIndexName() {\n+        return snapshotIndexName;\n+    }\n+\n+    /**\n+     * @return true if the operation will wait for completion\n+     */\n+    public boolean waitForCompletion() {\n+        return waitForCompletion;\n+    }\n+\n+    /**\n+     * @return settings that should be added to the index when it is mounted\n+     */\n+    public Settings indexSettings() {\n+        return this.indexSettings;\n+    }\n+\n+    /**\n+     * @return the names of settings that should be removed from the index when it is mounted\n+     */\n+    public String[] ignoreIndexSettings() {\n+        return ignoredIndexSettings;\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject();\n+        builder.field(INDEX_FIELD.getPreferredName(), snapshotIndexName);\n+        builder.field(RENAMED_INDEX_FIELD.getPreferredName(), mountedIndexName);\n+        if (indexSettings.isEmpty() == false) {\n+            builder.startObject(INDEX_SETTINGS_FIELD.getPreferredName());\n+            indexSettings.toXContent(builder, params);\n+            builder.endObject();\n+        }\n+        if (ignoredIndexSettings.length > 0) {\n+            builder.startArray(IGNORE_INDEX_SETTINGS_FIELD.getPreferredName());\n+            for (String ignoreIndexSetting : ignoredIndexSettings) {\n+                builder.value(ignoreIndexSetting);\n+            }\n+            builder.endArray();\n+        }\n+        builder.endObject();\n+        return builder;\n+    }\n+\n+    @Override\n+    public String getDescription() {\n+        return \"mount snapshot [\" + repositoryName + \":\" + snapshotName + \":\" + snapshotIndexName + \"->\" + mountedIndexName + \"]\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96ab3241962d5a38d94f82185f9667f209dd4e4c"}, "originalPosition": 193}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTUzMzQzNg==", "bodyText": "Nit: I think this could be plain Javadoc at the class level (for better visibility)", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r389533436", "createdAt": "2020-03-09T09:07:45Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/action/TransportMountSearchableSnapshotAction.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.searchablesnapshots.action;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.StepListener;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotResponse;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.master.TransportMasterNodeAction;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.repositories.RepositoryData;\n+import org.elasticsearch.snapshots.SnapshotId;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshots;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static org.elasticsearch.index.IndexModule.INDEX_STORE_TYPE_SETTING;\n+\n+public class TransportMountSearchableSnapshotAction\n+    extends TransportMasterNodeAction<MountSearchableSnapshotRequest, RestoreSnapshotResponse> {\n+    // This action doesn't technically need to run on the master node, but it needs to get metadata from the repository and we only expect", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96ab3241962d5a38d94f82185f9667f209dd4e4c"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTUzMzY1MQ==", "bodyText": "I think this deserves a tests", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r389533651", "createdAt": "2020-03-09T09:08:16Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/action/TransportMountSearchableSnapshotAction.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.searchablesnapshots.action;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.StepListener;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotResponse;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.master.TransportMasterNodeAction;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.repositories.RepositoryData;\n+import org.elasticsearch.snapshots.SnapshotId;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshots;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static org.elasticsearch.index.IndexModule.INDEX_STORE_TYPE_SETTING;\n+\n+public class TransportMountSearchableSnapshotAction\n+    extends TransportMasterNodeAction<MountSearchableSnapshotRequest, RestoreSnapshotResponse> {\n+    // This action doesn't technically need to run on the master node, but it needs to get metadata from the repository and we only expect\n+    // the repository to be accessible from data and master-eligible nodes so we can't run it everywhere. Given that we already have a way\n+    // to run actions on the master and that we have to do the restore via the master, it's simplest to use TransportMasterNodeAction.\n+\n+    private final Client client;\n+    private final RepositoriesService repositoriesService;\n+\n+    @Inject\n+    public TransportMountSearchableSnapshotAction(TransportService transportService, ClusterService clusterService, Client client,\n+                                                  ThreadPool threadPool, RepositoriesService repositoriesService,\n+                                                  ActionFilters actionFilters, IndexNameExpressionResolver indexNameExpressionResolver) {\n+        super(MountSearchableSnapshotAction.NAME, transportService, clusterService, threadPool, actionFilters,\n+            MountSearchableSnapshotRequest::new, indexNameExpressionResolver);\n+        this.client = client;\n+        this.repositoriesService = repositoriesService;\n+    }\n+\n+    @Override\n+    protected String executor() {\n+        // Avoid SNAPSHOT since snapshot threads may all be busy with long-running tasks which would block this action from responding with\n+        // an error. Avoid SAME since getting the repository metadata may block on IO.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96ab3241962d5a38d94f82185f9667f209dd4e4c"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTUzNDQwNQ==", "bodyText": "Nit: maybe buildIndexSettings() ?", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r389534405", "createdAt": "2020-03-09T09:09:57Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/action/TransportMountSearchableSnapshotAction.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.searchablesnapshots.action;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.StepListener;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotResponse;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.master.TransportMasterNodeAction;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.repositories.RepositoryData;\n+import org.elasticsearch.snapshots.SnapshotId;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshots;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static org.elasticsearch.index.IndexModule.INDEX_STORE_TYPE_SETTING;\n+\n+public class TransportMountSearchableSnapshotAction\n+    extends TransportMasterNodeAction<MountSearchableSnapshotRequest, RestoreSnapshotResponse> {\n+    // This action doesn't technically need to run on the master node, but it needs to get metadata from the repository and we only expect\n+    // the repository to be accessible from data and master-eligible nodes so we can't run it everywhere. Given that we already have a way\n+    // to run actions on the master and that we have to do the restore via the master, it's simplest to use TransportMasterNodeAction.\n+\n+    private final Client client;\n+    private final RepositoriesService repositoriesService;\n+\n+    @Inject\n+    public TransportMountSearchableSnapshotAction(TransportService transportService, ClusterService clusterService, Client client,\n+                                                  ThreadPool threadPool, RepositoriesService repositoriesService,\n+                                                  ActionFilters actionFilters, IndexNameExpressionResolver indexNameExpressionResolver) {\n+        super(MountSearchableSnapshotAction.NAME, transportService, clusterService, threadPool, actionFilters,\n+            MountSearchableSnapshotRequest::new, indexNameExpressionResolver);\n+        this.client = client;\n+        this.repositoriesService = repositoriesService;\n+    }\n+\n+    @Override\n+    protected String executor() {\n+        // Avoid SNAPSHOT since snapshot threads may all be busy with long-running tasks which would block this action from responding with\n+        // an error. Avoid SAME since getting the repository metadata may block on IO.\n+        return ThreadPool.Names.GENERIC;\n+    }\n+\n+    @Override\n+    protected RestoreSnapshotResponse read(StreamInput in) throws IOException {\n+        return new RestoreSnapshotResponse(in);\n+    }\n+\n+    @Override\n+    protected ClusterBlockException checkBlock(MountSearchableSnapshotRequest request, ClusterState state) {\n+        // The restore action checks the cluster blocks.\n+        return null;\n+    }\n+\n+    /**\n+     * Return the index settings required to make a snapshot searchable\n+     */\n+    private static Settings getIndexSettings(String repoName, SnapshotId snapshotId, IndexId indexId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96ab3241962d5a38d94f82185f9667f209dd4e4c"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTUzNjAwMQ==", "bodyText": "Good point @DaveCTurner, but I still think that mixing listener and throwing exception is confusing", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r389536001", "createdAt": "2020-03-09T09:13:14Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/action/TransportMountSearchableSnapshotAction.java", "diffHunk": "@@ -0,0 +1,158 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.searchablesnapshots.action;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.StepListener;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotResponse;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.master.TransportMasterNodeAction;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.block.ClusterBlockLevel;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.repositories.RepositoryData;\n+import org.elasticsearch.snapshots.SnapshotId;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotRepository;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static org.elasticsearch.index.IndexModule.INDEX_STORE_TYPE_SETTING;\n+\n+public class TransportMountSearchableSnapshotAction\n+    extends TransportMasterNodeAction<MountSearchableSnapshotRequest, RestoreSnapshotResponse> {\n+\n+    private final Client client;\n+    private final RepositoriesService repositoriesService;\n+\n+    @Inject\n+    public TransportMountSearchableSnapshotAction(TransportService transportService, ClusterService clusterService, Client client,\n+                                                  ThreadPool threadPool, RepositoriesService repositoriesService,\n+                                                  ActionFilters actionFilters, IndexNameExpressionResolver indexNameExpressionResolver) {\n+        super(MountSearchableSnapshotAction.NAME, transportService, clusterService, threadPool, actionFilters,\n+            MountSearchableSnapshotRequest::new, indexNameExpressionResolver);\n+        this.client = client;\n+        this.repositoriesService = repositoriesService;\n+    }\n+\n+    @Override\n+    protected String executor() {\n+        // Using the generic instead of the snapshot threadpool here as the snapshot threadpool might be blocked on long running tasks\n+        // which would block the request from getting an error response because of the ongoing task\n+        return ThreadPool.Names.GENERIC;\n+    }\n+\n+    @Override\n+    protected RestoreSnapshotResponse read(StreamInput in) throws IOException {\n+        return new RestoreSnapshotResponse(in);\n+    }\n+\n+    @Override\n+    protected ClusterBlockException checkBlock(MountSearchableSnapshotRequest request, ClusterState state) {\n+        // Restoring a snapshot might change the global state and create/change an index,\n+        // so we need to check for METADATA_WRITE and WRITE blocks\n+        ClusterBlockException blockException = state.blocks().globalBlockedException(ClusterBlockLevel.METADATA_WRITE);\n+        if (blockException != null) {\n+            return blockException;\n+        }\n+        return state.blocks().globalBlockedException(ClusterBlockLevel.WRITE);\n+\n+    }\n+\n+    /**\n+     * Return the index settings required to make a snapshot searchable\n+     */\n+    private static Settings getIndexSettings(String repoName, SnapshotId snapshotId, IndexId indexId) {\n+        return Settings.builder()\n+            .put(SearchableSnapshotRepository.SNAPSHOT_REPOSITORY_SETTING.getKey(), repoName)\n+            .put(SearchableSnapshotRepository.SNAPSHOT_SNAPSHOT_NAME_SETTING.getKey(), snapshotId.getName())\n+            .put(SearchableSnapshotRepository.SNAPSHOT_SNAPSHOT_ID_SETTING.getKey(), snapshotId.getUUID())\n+            .put(SearchableSnapshotRepository.SNAPSHOT_INDEX_ID_SETTING.getKey(), indexId.getId())\n+            .put(INDEX_STORE_TYPE_SETTING.getKey(), SearchableSnapshotRepository.SNAPSHOT_DIRECTORY_FACTORY_KEY)\n+            .put(IndexMetaData.SETTING_BLOCKS_WRITE, true)\n+            .build();\n+    }\n+\n+    @Override\n+    protected void masterOperation(Task task, final MountSearchableSnapshotRequest request, final ClusterState state,\n+                                   final ActionListener<RestoreSnapshotResponse> listener) {\n+        final String repoName = request.repository();\n+        final String snapName = request.snapshot();\n+        final String indexName = request.snapshotIndex();\n+\n+        // Retrieve IndexId and SnapshotId instances, which are then used to create a new restore\n+        // request, which is then sent on to the actual snapshot restore mechanism\n+        final Repository repository = repositoriesService.repository(repoName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU1MDk2OQ=="}, "originalCommit": {"oid": "c847e035baa2e0b370808aa7a52a6d59c5256a44"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTUzNzE1NQ==", "bodyText": "Yes, sorry for the noise. I've been too quick at commenting here.", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r389537155", "createdAt": "2020-03-09T09:15:33Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/action/TransportMountSearchableSnapshotAction.java", "diffHunk": "@@ -0,0 +1,158 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.searchablesnapshots.action;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.StepListener;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotResponse;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.master.TransportMasterNodeAction;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.block.ClusterBlockLevel;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.repositories.RepositoryData;\n+import org.elasticsearch.snapshots.SnapshotId;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshotRepository;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static org.elasticsearch.index.IndexModule.INDEX_STORE_TYPE_SETTING;\n+\n+public class TransportMountSearchableSnapshotAction\n+    extends TransportMasterNodeAction<MountSearchableSnapshotRequest, RestoreSnapshotResponse> {\n+\n+    private final Client client;\n+    private final RepositoriesService repositoriesService;\n+\n+    @Inject\n+    public TransportMountSearchableSnapshotAction(TransportService transportService, ClusterService clusterService, Client client,\n+                                                  ThreadPool threadPool, RepositoriesService repositoriesService,\n+                                                  ActionFilters actionFilters, IndexNameExpressionResolver indexNameExpressionResolver) {\n+        super(MountSearchableSnapshotAction.NAME, transportService, clusterService, threadPool, actionFilters,\n+            MountSearchableSnapshotRequest::new, indexNameExpressionResolver);\n+        this.client = client;\n+        this.repositoriesService = repositoriesService;\n+    }\n+\n+    @Override\n+    protected String executor() {\n+        // Using the generic instead of the snapshot threadpool here as the snapshot threadpool might be blocked on long running tasks\n+        // which would block the request from getting an error response because of the ongoing task\n+        return ThreadPool.Names.GENERIC;\n+    }\n+\n+    @Override\n+    protected RestoreSnapshotResponse read(StreamInput in) throws IOException {\n+        return new RestoreSnapshotResponse(in);\n+    }\n+\n+    @Override\n+    protected ClusterBlockException checkBlock(MountSearchableSnapshotRequest request, ClusterState state) {\n+        // Restoring a snapshot might change the global state and create/change an index,\n+        // so we need to check for METADATA_WRITE and WRITE blocks\n+        ClusterBlockException blockException = state.blocks().globalBlockedException(ClusterBlockLevel.METADATA_WRITE);\n+        if (blockException != null) {\n+            return blockException;\n+        }\n+        return state.blocks().globalBlockedException(ClusterBlockLevel.WRITE);\n+\n+    }\n+\n+    /**\n+     * Return the index settings required to make a snapshot searchable\n+     */\n+    private static Settings getIndexSettings(String repoName, SnapshotId snapshotId, IndexId indexId) {\n+        return Settings.builder()\n+            .put(SearchableSnapshotRepository.SNAPSHOT_REPOSITORY_SETTING.getKey(), repoName)\n+            .put(SearchableSnapshotRepository.SNAPSHOT_SNAPSHOT_NAME_SETTING.getKey(), snapshotId.getName())\n+            .put(SearchableSnapshotRepository.SNAPSHOT_SNAPSHOT_ID_SETTING.getKey(), snapshotId.getUUID())\n+            .put(SearchableSnapshotRepository.SNAPSHOT_INDEX_ID_SETTING.getKey(), indexId.getId())\n+            .put(INDEX_STORE_TYPE_SETTING.getKey(), SearchableSnapshotRepository.SNAPSHOT_DIRECTORY_FACTORY_KEY)\n+            .put(IndexMetaData.SETTING_BLOCKS_WRITE, true)\n+            .build();\n+    }\n+\n+    @Override\n+    protected void masterOperation(Task task, final MountSearchableSnapshotRequest request, final ClusterState state,\n+                                   final ActionListener<RestoreSnapshotResponse> listener) {\n+        final String repoName = request.repository();\n+        final String snapName = request.snapshot();\n+        final String indexName = request.snapshotIndex();\n+\n+        // Retrieve IndexId and SnapshotId instances, which are then used to create a new restore\n+        // request, which is then sent on to the actual snapshot restore mechanism\n+        final Repository repository = repositoriesService.repository(repoName);\n+        final StepListener<RepositoryData> repositoryDataListener = new StepListener<>();\n+        repository.getRepositoryData(repositoryDataListener);\n+        repositoryDataListener.whenComplete(repoData -> {\n+            final Map<String, IndexId> indexIds = repoData.getIndices();\n+\n+            if (indexIds.containsKey(indexName) == false && indexIds.get(indexName) != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU1ODI3MA=="}, "originalCommit": {"oid": "c847e035baa2e0b370808aa7a52a6d59c5256a44"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTU0NTE4Mg==", "bodyText": "This is a good observation. I don't have a strong opinion about it as the Directory implementation ensures (from index settings) that we are restoring the snapshot id/index id discovered here; but I agree that a different snapshot and/or index could be resolved later by the transport restore action itself (and if that index has a different number of shards, boom). I see this as a low risk that could maybe be worked around by adding snapshot it and index id to the restore request and check them (if present) during restore?", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r389545182", "createdAt": "2020-03-09T09:31:11Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/action/TransportMountSearchableSnapshotAction.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.searchablesnapshots.action;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.StepListener;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotResponse;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.master.TransportMasterNodeAction;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.repositories.RepositoryData;\n+import org.elasticsearch.snapshots.SnapshotId;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.searchablesnapshots.SearchableSnapshots;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static org.elasticsearch.index.IndexModule.INDEX_STORE_TYPE_SETTING;\n+\n+public class TransportMountSearchableSnapshotAction\n+    extends TransportMasterNodeAction<MountSearchableSnapshotRequest, RestoreSnapshotResponse> {\n+    // This action doesn't technically need to run on the master node, but it needs to get metadata from the repository and we only expect\n+    // the repository to be accessible from data and master-eligible nodes so we can't run it everywhere. Given that we already have a way\n+    // to run actions on the master and that we have to do the restore via the master, it's simplest to use TransportMasterNodeAction.\n+\n+    private final Client client;\n+    private final RepositoriesService repositoriesService;\n+\n+    @Inject\n+    public TransportMountSearchableSnapshotAction(TransportService transportService, ClusterService clusterService, Client client,\n+                                                  ThreadPool threadPool, RepositoriesService repositoriesService,\n+                                                  ActionFilters actionFilters, IndexNameExpressionResolver indexNameExpressionResolver) {\n+        super(MountSearchableSnapshotAction.NAME, transportService, clusterService, threadPool, actionFilters,\n+            MountSearchableSnapshotRequest::new, indexNameExpressionResolver);\n+        this.client = client;\n+        this.repositoriesService = repositoriesService;\n+    }\n+\n+    @Override\n+    protected String executor() {\n+        // Avoid SNAPSHOT since snapshot threads may all be busy with long-running tasks which would block this action from responding with\n+        // an error. Avoid SAME since getting the repository metadata may block on IO.\n+        return ThreadPool.Names.GENERIC;\n+    }\n+\n+    @Override\n+    protected RestoreSnapshotResponse read(StreamInput in) throws IOException {\n+        return new RestoreSnapshotResponse(in);\n+    }\n+\n+    @Override\n+    protected ClusterBlockException checkBlock(MountSearchableSnapshotRequest request, ClusterState state) {\n+        // The restore action checks the cluster blocks.\n+        return null;\n+    }\n+\n+    /**\n+     * Return the index settings required to make a snapshot searchable\n+     */\n+    private static Settings getIndexSettings(String repoName, SnapshotId snapshotId, IndexId indexId) {\n+        return Settings.builder()\n+            .put(SearchableSnapshots.SNAPSHOT_REPOSITORY_SETTING.getKey(), repoName)\n+            .put(SearchableSnapshots.SNAPSHOT_SNAPSHOT_NAME_SETTING.getKey(), snapshotId.getName())\n+            .put(SearchableSnapshots.SNAPSHOT_SNAPSHOT_ID_SETTING.getKey(), snapshotId.getUUID())\n+            .put(SearchableSnapshots.SNAPSHOT_INDEX_ID_SETTING.getKey(), indexId.getId())\n+            .put(INDEX_STORE_TYPE_SETTING.getKey(), SearchableSnapshots.SNAPSHOT_DIRECTORY_FACTORY_KEY)\n+            .put(IndexMetaData.SETTING_BLOCKS_WRITE, true)\n+            .build();\n+    }\n+\n+    @Override\n+    protected void masterOperation(Task task, final MountSearchableSnapshotRequest request, final ClusterState state,\n+                                   final ActionListener<RestoreSnapshotResponse> listener) {\n+        final String repoName = request.repositoryName();\n+        final String snapName = request.snapshotName();\n+        final String indexName = request.snapshotIndexName();\n+\n+        // Retrieve IndexId and SnapshotId instances, which are then used to create a new restore\n+        // request, which is then sent on to the actual snapshot restore mechanism\n+        final Repository repository = repositoriesService.repository(repoName);\n+        final StepListener<RepositoryData> repositoryDataListener = new StepListener<>();\n+        repository.getRepositoryData(repositoryDataListener);\n+        repositoryDataListener.whenComplete(repoData -> {\n+            final Map<String, IndexId> indexIds = repoData.getIndices();\n+            if (indexIds.containsKey(indexName) == false && indexIds.get(indexName) != null) {\n+                throw new IndexNotFoundException(\"index [\" + indexName + \"] not found in repository [\" + repoName + \"]\");\n+            }\n+            final IndexId indexId = indexIds.get(indexName);\n+\n+            final Optional<SnapshotId> matchingSnapshotId = repoData.getSnapshotIds().stream()\n+                .filter(s -> snapName.equals(s.getName())).findFirst();\n+            if (matchingSnapshotId.isEmpty()) {\n+                throw new ElasticsearchException(\"snapshot [\" + snapName + \"] not found in repository [\" + repoName + \"]\");\n+            }\n+            final SnapshotId snapshotId = matchingSnapshotId.get();\n+\n+            // NORELEASE TODO should we ensure that the IDs we just obtained match the ones that we ultimately restore?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96ab3241962d5a38d94f82185f9667f209dd4e4c"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTU1MDQ4Mg==", "bodyText": "I don't think we should test the request parsing logic here (we have AbstractRequestTestCase for this in the client project)", "url": "https://github.com/elastic/elasticsearch/pull/53084#discussion_r389550482", "createdAt": "2020-03-09T09:41:34Z", "author": {"login": "tlrx"}, "path": "x-pack/plugin/searchable-snapshots/src/test/java/org/elasticsearch/xpack/searchablesnapshots/action/MountSearchableSnapshotRequestTests.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.searchablesnapshots.action;\n+\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.test.AbstractWireSerializingTestCase;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+\n+public class MountSearchableSnapshotRequestTests extends AbstractWireSerializingTestCase<MountSearchableSnapshotRequest> {\n+    public void testParse() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96ab3241962d5a38d94f82185f9667f209dd4e4c"}, "originalPosition": 26}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7b8e5608b2076061c805ab4c6aa8799aae350629", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/7b8e5608b2076061c805ab4c6aa8799aae350629", "committedDate": "2020-03-09T09:50:28Z", "message": "Not optional"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cca756ecba0db5cc514e13568c9413681264254e", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/cca756ecba0db5cc514e13568c9413681264254e", "committedDate": "2020-03-09T09:53:33Z", "message": "Better description"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4a7588f2959f7a43e98061d788e9ff8225441cfa", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/4a7588f2959f7a43e98061d788e9ff8225441cfa", "committedDate": "2020-03-09T11:06:08Z", "message": "Remove ToXContent, we will do this later in the client"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dbe178f8d913d3125b3601acf84a34c52ac952ed", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/dbe178f8d913d3125b3601acf84a34c52ac952ed", "committedDate": "2020-03-09T11:17:41Z", "message": "Pass request directly to parser"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6d2e48ceffa25c484fb917cccf1ea928655e8031", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/6d2e48ceffa25c484fb917cccf1ea928655e8031", "committedDate": "2020-03-09T11:21:03Z", "message": "Javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "85ba30188ae38d8dffd9ea2825e501ca12a733e4", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/85ba30188ae38d8dffd9ea2825e501ca12a733e4", "committedDate": "2020-03-09T11:22:58Z", "message": "Rename"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "414e830129249bff43ccec131543f939c3a1b8b7", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/414e830129249bff43ccec131543f939c3a1b8b7", "committedDate": "2020-03-09T11:40:15Z", "message": "Expand TODO comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e9945d50e1cdf8f7202025880db60368caa04ae2", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/e9945d50e1cdf8f7202025880db60368caa04ae2", "committedDate": "2020-03-09T12:14:07Z", "message": "Merge branch 'feature/searchable-snapshots' into ss-add-dedicated-restore-api"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxMTE2MzYz", "url": "https://github.com/elastic/elasticsearch/pull/53084#pullrequestreview-371116363", "createdAt": "2020-03-09T12:20:16Z", "commit": {"oid": "414e830129249bff43ccec131543f939c3a1b8b7"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b44d22052f941b0d6fb372c16a399a608d2052be", "author": {"user": {"login": "DaveCTurner", "name": "David Turner"}}, "url": "https://github.com/elastic/elasticsearch/commit/b44d22052f941b0d6fb372c16a399a608d2052be", "committedDate": "2020-03-09T13:07:33Z", "message": "Merge branch 'feature/searchable-snapshots' into ss-add-dedicated-restore-api"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1729, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}