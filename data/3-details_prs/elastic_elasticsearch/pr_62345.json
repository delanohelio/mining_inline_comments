{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg2OTEzMzc5", "number": 62345, "title": "Speed up writeVInt", "bodyText": "This speeds up StreamOutput#writeVInt quite a bit which is nice\nbecause it is very commonly called when serializing aggregations. Well,\nwhen serializing anything. All \"collections\" serialize their size as a\nvint. Anyway, I was examining the serialization speeds of StringTerms\nand this saves about 30% of the write time for that. I expect it'll be\nuseful other places.", "createdAt": "2020-09-14T21:57:57Z", "url": "https://github.com/elastic/elasticsearch/pull/62345", "merged": true, "mergeCommit": {"oid": "dfc45396e74e104f7725ae8094e126e98abcb033"}, "closed": true, "closedAt": "2020-09-15T18:20:53Z", "author": {"login": "nik9000"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdI6gZ1gH2gAyNDg2OTEzMzc5OjE1NDcxZTYwMjBmMTgwMzkzODUyMWZhMjBlYWJhY2RhNjRjNjg5MjI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdJK5XoAH2gAyNDg2OTEzMzc5OmJkOWNjNTc5M2I3MjNmOGI0NmM3NGJkMmI0YTlmMzkzMTExYzRlMzQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "15471e6020f1803938521fa20eabacda64c68922", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/15471e6020f1803938521fa20eabacda64c68922", "committedDate": "2020-09-14T21:58:31Z", "message": "Speed up writeVInt\n\nThis speeds up `StreamOutput#writeVInt` quite a bit which is nice\nbecause it is *very* commonly called when serializing aggregations. Well,\nwhen serializing anything. All \"collections\" serialize their size as a\nvint. Anyway, I was examining the serialization speeds of `StringTerms`\nand this saves about 30% of the write time for that. I expect it'll be\nuseful other places."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg4MTg0ODcz", "url": "https://github.com/elastic/elasticsearch/pull/62345#pullrequestreview-488184873", "createdAt": "2020-09-14T21:58:09Z", "commit": {"oid": "15471e6020f1803938521fa20eabacda64c68922"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQyMTo1ODowOVrOHRoD7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQyMTo1OToyNFrOHRoHyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI0NDIwNw==", "bodyText": "This was just wrong.", "url": "https://github.com/elastic/elasticsearch/pull/62345#discussion_r488244207", "createdAt": "2020-09-14T21:58:09Z", "author": {"login": "nik9000"}, "path": "benchmarks/README.md", "diffHunk": "@@ -78,7 +78,6 @@ cd fcml*\n make\n cd example/hsdis\n make\n-cp .libs/libhsdis.so.0.0.0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15471e6020f1803938521fa20eabacda64c68922"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI0NTE5Mg==", "bodyText": "I'm unsure if we actually want this benchmark, especially compared to the one that @jimczi showed me. But it is fairly targeted which can be useful.", "url": "https://github.com/elastic/elasticsearch/pull/62345#discussion_r488245192", "createdAt": "2020-09-14T21:59:24Z", "author": {"login": "nik9000"}, "path": "benchmarks/src/main/java/org/elasticsearch/benchmark/search/aggregations/bucket/terms/StringTermsSerializationBenchmark.java", "diffHunk": "@@ -0,0 +1,77 @@\n+package org.elasticsearch.benchmark.search.aggregations.bucket.terms;\n+\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.io.stream.BytesStreamOutput;\n+import org.elasticsearch.common.io.stream.DelayableWriteable;\n+import org.elasticsearch.common.io.stream.NamedWriteableRegistry;\n+import org.elasticsearch.search.DocValueFormat;\n+import org.elasticsearch.search.aggregations.BucketOrder;\n+import org.elasticsearch.search.aggregations.InternalAggregation;\n+import org.elasticsearch.search.aggregations.InternalAggregations;\n+import org.elasticsearch.search.aggregations.bucket.terms.StringTerms;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+@Fork(2)\n+@Warmup(iterations = 10)\n+@Measurement(iterations = 5)\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+public class StringTermsSerializationBenchmark {\n+    private static final NamedWriteableRegistry REGISTRY = new NamedWriteableRegistry(\n+        List.of(new NamedWriteableRegistry.Entry(InternalAggregation.class, StringTerms.NAME, StringTerms::new))\n+    );\n+    @Param(value = { \"1000\" })\n+    private int buckets;\n+\n+    private DelayableWriteable<InternalAggregations> results;\n+\n+    @Setup\n+    public void initResults() {\n+        results = DelayableWriteable.referencing(InternalAggregations.from(List.of(newTerms(true))));\n+    }\n+\n+    private StringTerms newTerms(boolean withNested) {\n+        List<StringTerms.Bucket> resultBuckets = new ArrayList<>(buckets);\n+        for (int i = 0; i < buckets; i++) {\n+            InternalAggregations inner = withNested ? InternalAggregations.from(List.of(newTerms(false))) : InternalAggregations.EMPTY;\n+            resultBuckets.add(new StringTerms.Bucket(new BytesRef(\"test\" + i), i, inner, false, 0, DocValueFormat.RAW));\n+        }\n+        return new StringTerms(\n+            \"test\",\n+            BucketOrder.key(true),\n+            BucketOrder.key(true),\n+            buckets,\n+            1,\n+            null,\n+            DocValueFormat.RAW,\n+            buckets,\n+            false,\n+            100000,\n+            resultBuckets,\n+            0\n+        );\n+    }\n+\n+    @Benchmark\n+    public DelayableWriteable<InternalAggregations> serialize() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15471e6020f1803938521fa20eabacda64c68922"}, "originalPosition": 74}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c65a0b150e7e90a40fe9f398b3f1b614c8c685d1", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/c65a0b150e7e90a40fe9f398b3f1b614c8c685d1", "committedDate": "2020-09-14T22:02:53Z", "message": "License headers"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5cd3531e65ce0f61a2fb3a41dcf3db7b8910bcd4", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/5cd3531e65ce0f61a2fb3a41dcf3db7b8910bcd4", "committedDate": "2020-09-15T00:28:44Z", "message": "Switch?!"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "929297f3a72d6d80e26b9a415e1204b413c52079", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/929297f3a72d6d80e26b9a415e1204b413c52079", "committedDate": "2020-09-15T00:34:05Z", "message": "drop"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg4MjQ2NTA2", "url": "https://github.com/elastic/elasticsearch/pull/62345#pullrequestreview-488246506", "createdAt": "2020-09-15T00:43:26Z", "commit": {"oid": "929297f3a72d6d80e26b9a415e1204b413c52079"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQwMDo0MzoyNlrOHRsYWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQwMDo0MzoyNlrOHRsYWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMxNDk3MA==", "bodyText": "This gets compiled to lzcnt and the JVM's tableswitch. At this point the overhead of the buffer and BigArrays dominates the method.", "url": "https://github.com/elastic/elasticsearch/pull/62345#discussion_r488314970", "createdAt": "2020-09-15T00:43:26Z", "author": {"login": "nik9000"}, "path": "server/src/main/java/org/elasticsearch/common/io/stream/StreamOutput.java", "diffHunk": "@@ -218,14 +218,85 @@ public void writeInt(int i) throws IOException {\n      * using {@link #writeInt}\n      */\n     public void writeVInt(int i) throws IOException {\n-        final byte[] buffer = scratch.get();\n-        int index = 0;\n-        while ((i & ~0x7F) != 0) {\n-            buffer[index++] = ((byte) ((i & 0x7f) | 0x80));\n-            i >>>= 7;\n+        /*\n+         * Pick the number of bytes that we need based on the value and then\n+         * encode the int, unrolling the loops by hand. This allows writing\n+         * small numbers to use `writeByte` which is simple and fast. The\n+         * unrolling saves a few comparisons and bitwise operations. All\n+         * together this saves quite a bit of time compared to a naive\n+         * implementation.\n+         */\n+        switch (Integer.numberOfLeadingZeros(i)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "929297f3a72d6d80e26b9a415e1204b413c52079"}, "originalPosition": 17}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ca6cd67ccd78ea75546606e160ca7ffc5deb86c7", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/ca6cd67ccd78ea75546606e160ca7ffc5deb86c7", "committedDate": "2020-09-15T00:45:16Z", "message": "Repeat is forbidden"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5beaac827ced891220a6e8427136cfe1d605dc57", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/5beaac827ced891220a6e8427136cfe1d605dc57", "committedDate": "2020-09-15T01:16:18Z", "message": "Revert \"drop\"\n\nThis reverts commit 929297f3a72d6d80e26b9a415e1204b413c52079."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg4MzUyMDcz", "url": "https://github.com/elastic/elasticsearch/pull/62345#pullrequestreview-488352073", "createdAt": "2020-09-15T06:10:36Z", "commit": {"oid": "ca6cd67ccd78ea75546606e160ca7ffc5deb86c7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQwNjoxMDozNlrOHRyJPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQwNjoxMDozNlrOHRyJPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODQwOTQwNA==", "bodyText": "I love this until here :) The fact that we can special case number of leading zeros > 24 is pretty significant and I can see the ~30% performance gain as well.\nHard coding all possible offsets below and doing all the buffer getting and writeBytes inline with those hard coded offsets I don't think is a good idea. This blows up the method size significantly for a tiny saving in CPU when it comes to evaluating the loop.\nI benchmarked both this version and:\n    public void writeVInt(int i) throws IOException {\n        if (Integer.numberOfLeadingZeros(i) > 24) {\n            writeByte((byte) i);\n        } else {\n            final byte[] buffer = scratch.get();\n            int index = 0;\n            do {\n                buffer[index++] = ((byte) ((i & 0x7f) | 0x80));\n                i >>>= 7;\n            } while ((i & ~0x7F) != 0);\n            buffer[index++] = ((byte) i);\n            writeBytes(buffer, 0, index);\n        }\n    }\nand I can't see statistically significant difference so that's not worth the complication IMO.\nI would in fact expect the above version with the loop to be faster than what is in this PR in the real world because the smaller method size has a better better chance of getting inlined in some places (73 vs 507 bytes on JDK14/Linux for me).\nI suppose you could work around the code bloat by doing this:\n        final int leadingZeros = Integer.numberOfLeadingZeros(i);\n        if (Integer.numberOfLeadingZeros(i) > 24) {\n            writeByte((byte) i);\n        } else {\n            final byte[] buffer = scratch.get();\n            final int length;\n            switch (leadingZeros) {\n                case 24:\n                case 23:\n                case 22:\n                case 21:\n                case 20:\n                case 19:\n                case 18:\n                    buffer[0] = (byte) (i & 0x7f | 0x80);\n                    buffer[1] = (byte) (i >>> 7);\n                    assert buffer[1] <= 0x7f;\n                    length = 2;\n                    break;\n                case 17:\n                case 16:\n                case 15:\n                case 14:\n                case 13:\n                case 12:\n                case 11:\n                    buffer[0] = (byte) (i & 0x7f | 0x80);\n                    buffer[1] = (byte) ((i >>> 7) & 0x7f | 0x80);\n                    buffer[2] = (byte) (i >>> 14);\n                    assert buffer[2] <= 0x7f;\n                    length = 3;\n                    break;\n                case 10:\n                case 9:\n                case 8:\n                case 7:\n                case 6:\n                case 5:\n                case 4:\n                    buffer[0] = (byte) (i & 0x7f | 0x80);\n                    buffer[1] = (byte) ((i >>> 7) & 0x7f | 0x80);\n                    buffer[2] = (byte) ((i >>> 14) & 0x7f | 0x80);\n                    buffer[3] = (byte) (i >>> 21);\n                    assert buffer[3] <= 0x7f;\n                    length = 4;\n                    break;\n                case 3:\n                case 2:\n                case 1:\n                case 0:\n                    buffer[0] = (byte) (i & 0x7f | 0x80);\n                    buffer[1] = (byte) ((i >>> 7) & 0x7f | 0x80);\n                    buffer[2] = (byte) ((i >>> 14) & 0x7f | 0x80);\n                    buffer[3] = (byte) ((i >>> 21) & 0x7f | 0x80);\n                    buffer[4] = (byte) (i >>> 28);\n                    assert buffer[4] <= 0x7f;\n                    length = 5;\n                    break;\n                default:\n                    throw new UnsupportedOperationException(\n                            \"Can't encode [\" + i + \"]. Missing case for [\" + Integer.numberOfLeadingZeros(i) + \"]?\"\n                    );\n            }\n            writeBytes(buffer, 0, length);\n        }\nbut I can't measure a performance difference to the loop at all so personally I'd go for the shorter loop just for simplicity's sake.", "url": "https://github.com/elastic/elasticsearch/pull/62345#discussion_r488409404", "createdAt": "2020-09-15T06:10:36Z", "author": {"login": "original-brownbear"}, "path": "server/src/main/java/org/elasticsearch/common/io/stream/StreamOutput.java", "diffHunk": "@@ -218,14 +218,85 @@ public void writeInt(int i) throws IOException {\n      * using {@link #writeInt}\n      */\n     public void writeVInt(int i) throws IOException {\n-        final byte[] buffer = scratch.get();\n-        int index = 0;\n-        while ((i & ~0x7F) != 0) {\n-            buffer[index++] = ((byte) ((i & 0x7f) | 0x80));\n-            i >>>= 7;\n+        /*\n+         * Pick the number of bytes that we need based on the value and then\n+         * encode the int, unrolling the loops by hand. This allows writing\n+         * small numbers to use `writeByte` which is simple and fast. The\n+         * unrolling saves a few comparisons and bitwise operations. All\n+         * together this saves quite a bit of time compared to a naive\n+         * implementation.\n+         */\n+        switch (Integer.numberOfLeadingZeros(i)) {\n+            case 32:\n+            case 31:\n+            case 30:\n+            case 29:\n+            case 28:\n+            case 27:\n+            case 26:\n+            case 25:\n+                writeByte((byte) i);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca6cd67ccd78ea75546606e160ca7ffc5deb86c7"}, "originalPosition": 26}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ec402169487cf53b8965c60b2aa4ef94da3a6db3", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/ec402169487cf53b8965c60b2aa4ef94da3a6db3", "committedDate": "2020-09-15T12:16:53Z", "message": "Simplify"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e35e1c5e94ce2aa8cd4c9a5b6f3017d9f0fe1fbd", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/e35e1c5e94ce2aa8cd4c9a5b6f3017d9f0fe1fbd", "committedDate": "2020-09-15T12:39:02Z", "message": "Explain differently"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg4NjQ0ODYy", "url": "https://github.com/elastic/elasticsearch/pull/62345#pullrequestreview-488644862", "createdAt": "2020-09-15T12:48:35Z", "commit": {"oid": "4f6d4d8bc489c83898516777ae54085ba49cd34e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxMjo0ODozNVrOHSAHTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxMjo0ODozNVrOHSAHTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODYzODI4Ng==", "bodyText": "I think we probably don't want to keep this benchmark but I pushed it so you could see what I was using for the numbers I shared.", "url": "https://github.com/elastic/elasticsearch/pull/62345#discussion_r488638286", "createdAt": "2020-09-15T12:48:35Z", "author": {"login": "nik9000"}, "path": "benchmarks/src/main/java/org/elasticsearch/benchmark/search/aggregations/bucket/terms/StringTermsSerializationBenchmark.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.benchmark.search.aggregations.bucket.terms;\n+\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.io.stream.BytesStreamOutput;\n+import org.elasticsearch.common.io.stream.DelayableWriteable;\n+import org.elasticsearch.common.io.stream.NamedWriteableRegistry;\n+import org.elasticsearch.search.DocValueFormat;\n+import org.elasticsearch.search.aggregations.BucketOrder;\n+import org.elasticsearch.search.aggregations.InternalAggregation;\n+import org.elasticsearch.search.aggregations.InternalAggregations;\n+import org.elasticsearch.search.aggregations.bucket.terms.StringTerms;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+@Fork(2)\n+@Warmup(iterations = 10)\n+@Measurement(iterations = 5)\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+public class StringTermsSerializationBenchmark {\n+    private static final NamedWriteableRegistry REGISTRY = new NamedWriteableRegistry(\n+        List.of(new NamedWriteableRegistry.Entry(InternalAggregation.class, StringTerms.NAME, StringTerms::new))\n+    );\n+    @Param(value = { \"1000\" })\n+    private int buckets;\n+\n+    private DelayableWriteable<InternalAggregations> results;\n+\n+    @Setup\n+    public void initResults() {\n+        results = DelayableWriteable.referencing(InternalAggregations.from(List.of(newTerms(true))));\n+    }\n+\n+    private StringTerms newTerms(boolean withNested) {\n+        List<StringTerms.Bucket> resultBuckets = new ArrayList<>(buckets);\n+        for (int i = 0; i < buckets; i++) {\n+            InternalAggregations inner = withNested ? InternalAggregations.from(List.of(newTerms(false))) : InternalAggregations.EMPTY;\n+            resultBuckets.add(new StringTerms.Bucket(new BytesRef(\"test\" + i), i, inner, false, 0, DocValueFormat.RAW));\n+        }\n+        return new StringTerms(\n+            \"test\",\n+            BucketOrder.key(true),\n+            BucketOrder.key(true),\n+            buckets,\n+            1,\n+            null,\n+            DocValueFormat.RAW,\n+            buckets,\n+            false,\n+            100000,\n+            resultBuckets,\n+            0\n+        );\n+    }\n+\n+    @Benchmark\n+    public DelayableWriteable<InternalAggregations> serialize() {\n+        return results.asSerialized(InternalAggregations::readFrom, REGISTRY);\n+    }\n+\n+    @Benchmark\n+    public BytesReference serializeVint() throws IOException {\n+        try (BytesStreamOutput buffer = new BytesStreamOutput()) {\n+            buffer.setVersion(Version.CURRENT);\n+            for (int i = 0; i < 1000000; i++) {\n+                buffer.writeVInt(i);\n+                buffer.reset();\n+            }\n+            return buffer.bytes();\n+        }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f6d4d8bc489c83898516777ae54085ba49cd34e"}, "originalPosition": 107}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4f6d4d8bc489c83898516777ae54085ba49cd34e", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/4f6d4d8bc489c83898516777ae54085ba49cd34e", "committedDate": "2020-09-15T12:48:54Z", "message": "moar comment"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg4NjQ5ODU4", "url": "https://github.com/elastic/elasticsearch/pull/62345#pullrequestreview-488649858", "createdAt": "2020-09-15T12:54:14Z", "commit": {"oid": "4f6d4d8bc489c83898516777ae54085ba49cd34e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4d1d7bd0599b311558f33be2582a0ad79e427320", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/4d1d7bd0599b311558f33be2582a0ad79e427320", "committedDate": "2020-09-15T17:03:50Z", "message": "drop example benchmark.\n\nIt was good to look at, but we don't need to commit it."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bd9cc5793b723f8b46c74bd2b4a9f393111c4e34", "author": {"user": {"login": "nik9000", "name": "Nik Everett"}}, "url": "https://github.com/elastic/elasticsearch/commit/bd9cc5793b723f8b46c74bd2b4a9f393111c4e34", "committedDate": "2020-09-15T17:04:16Z", "message": "Merge branch 'master' into benchmark_write"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4612, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}