{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc0NTcxMDYz", "number": 61621, "reviewThreads": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwMDo1Nzo0M1rOEejHBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwNDoxNToyMVrOEh8SFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNDY3OTc0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/action/filter/SecurityActionFilterTests.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwMDo1Nzo0M1rOHKQlWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwMDo1Nzo0M1rOHKQlWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDUxOTUxNA==", "bodyText": "For completeness, I'd personally add assertNull for INDICES_PERMISSIONS_KEY as well.", "url": "https://github.com/elastic/elasticsearch/pull/61621#discussion_r480519514", "createdAt": "2020-09-01T00:57:43Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/action/filter/SecurityActionFilterTests.java", "diffHunk": "@@ -173,23 +188,23 @@ public void testApplyAsSystemUser() throws Exception {\n             callback.onResponse(threadContext.getTransient(AuthenticationField.AUTHENTICATION_KEY));\n             return Void.TYPE;\n         }).when(authcService).authenticate(eq(action), eq(request), eq(SystemUser.INSTANCE), any(ActionListener.class));\n-        doAnswer((i) -> {\n-            ActionListener<Void> callback = (ActionListener<Void>) i.getArguments()[3];\n-            callback.onResponse(null);\n-            return Void.TYPE;\n-        }).when(authzService)\n-            .authorize(any(Authentication.class), any(String.class), any(TransportRequest.class), any(ActionListener.class));\n+        IndicesAccessControl authzAccessControl = mock(IndicesAccessControl.class);\n+        mockAuthorize(authzAccessControl);\n \n         filter.apply(task, action, request, listener, chain);\n \n         if (hasExistingAuthentication) {\n             assertEquals(authentication, threadContext.getTransient(AuthenticationField.AUTHENTICATION_KEY));\n+            if (hasExistingAccessControl) {\n+                assertThat(threadContext.getTransient(INDICES_PERMISSIONS_KEY), sameInstance(IndicesAccessControl.ALLOW_NO_INDICES));\n+            }\n         } else {\n             assertNull(threadContext.getTransient(AuthenticationField.AUTHENTICATION_KEY));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "523699833d46d3d98c43397c34388006b268f641"}, "originalPosition": 169}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNTAzMDE1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/transport/ServerTransportFilter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwMTo1NDoyMFrOHKUSZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwMTo1NDoyMFrOHKUSZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDU4MDE5Ng==", "bodyText": "My understanding is that there should no transient header at all in this place, since ServerTrasnportFilter is only invoked when the request is cross-nodes. If this is true, would it be better in terms of intention to have an assert here instead of removeTransient?\nBut if we do need removeTransient here, would it then be better to move the remove into AuthorizationService#authorize so it is better encapsulated?", "url": "https://github.com/elastic/elasticsearch/pull/61621#discussion_r480580196", "createdAt": "2020-09-01T01:54:20Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/transport/ServerTransportFilter.java", "diffHunk": "@@ -105,9 +107,11 @@ requests from all the nodes are attached with a user (either a serialize\n                     SystemUser.is(authentication.getUser()) == false) {\n                     securityContext.executeAsUser(SystemUser.INSTANCE, (ctx) -> {\n                         final Authentication replaced = securityContext.getAuthentication();\n+                        threadContext.removeTransient(INDICES_PERMISSIONS_KEY);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "523699833d46d3d98c43397c34388006b268f641"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNTAzMTkxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/transport/ServerTransportFilter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwMTo1NDozNVrOHKUToA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwMTo1NDozNVrOHKUToA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDU4MDUxMg==", "bodyText": "Same as above.", "url": "https://github.com/elastic/elasticsearch/pull/61621#discussion_r480580512", "createdAt": "2020-09-01T01:54:35Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/transport/ServerTransportFilter.java", "diffHunk": "@@ -105,9 +107,11 @@ requests from all the nodes are attached with a user (either a serialize\n                     SystemUser.is(authentication.getUser()) == false) {\n                     securityContext.executeAsUser(SystemUser.INSTANCE, (ctx) -> {\n                         final Authentication replaced = securityContext.getAuthentication();\n+                        threadContext.removeTransient(INDICES_PERMISSIONS_KEY);\n                         authzService.authorize(replaced, securityAction, request, listener);\n                     }, version);\n                 } else {\n+                    threadContext.removeTransient(INDICES_PERMISSIONS_KEY);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "523699833d46d3d98c43397c34388006b268f641"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNTM4MzkxOnYy", "diffSide": "LEFT", "path": "x-pack/plugin/sql/qa/server/security/src/test/java/org/elasticsearch/xpack/sql/qa/security/RestSqlSecurityIT.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQyMTowOTozNlrOHNbjWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQyMTowOTozNlrOHNbjWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg0NDk1Mg==", "bodyText": "This is not actually an access denied for SQL_ACTION_NAME , it is for a scroll search, i.e. :\n.expect(\"access_denied\", SearchTransportService.QUERY_FETCH_SCROLL_ACTION_NAME, \"full_access\", \"default_native\", empty(), \"InternalScrollSearchRequest\")\n\nuntil now we've erroneously carried over the ACTION_ORIGIN header to the child action, which is audited.\n(and this IT doesn't look at non-SQL audits)", "url": "https://github.com/elastic/elasticsearch/pull/61621#discussion_r483844952", "createdAt": "2020-09-04T21:09:36Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/sql/qa/server/security/src/test/java/org/elasticsearch/xpack/sql/qa/security/RestSqlSecurityIT.java", "diffHunk": "@@ -271,8 +271,6 @@ public void testHijackScrollFails() throws Exception {\n \n         createAuditLogAsserter().expectSqlCompositeActionFieldCaps(\"test_admin\", \"test\")\n             .expect(true, SQL_ACTION_NAME, \"full_access\", empty())\n-            // one scroll access denied per shard\n-            .expect(\"access_denied\", SQL_ACTION_NAME, \"full_access\", \"default_native\", empty(), \"InternalScrollSearchRequest\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ff4d6d62bbf2deb885ad95cc3646b1f03da8743"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNzg3NDI0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/common/util/concurrent/ThreadContext.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QwMjoyMTo1N1rOHNuVBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QwOTo1NDo0NFrOHN44AQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDE1MjU4MQ==", "bodyText": "I found this doc confusing, and needed to read the implementation in order to understand what it was trying to say.\nHere's my attempt (though others may consider it too long)\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Removes the specified transient headers from the current context. The removed transient headers can be\n          \n          \n            \n                 * restored by closing the returned {@link StoredContext}. If such a transient header does not exist before\n          \n          \n            \n                 * this method is called, it will also not exist after restore (i.e. restoring asserts the existence\n          \n          \n            \n                 * and the values for the transient headers, as they existed before invoking this method).\n          \n          \n            \n                 * Removes the specified transient headers from the current context. When the returned\n          \n          \n            \n                 * {@link StoredContext} is closed, it will restore these transient headers to their original\n          \n          \n            \n                 * value (including restoring them to an <i>unset</i> value if they did not originally exist).\n          \n          \n            \n                 * Closing the {@code StoredContext} has no affect on any other header - any headers \n          \n          \n            \n                 * (other than those names specified in {@code transientHeadersToStash} that were\n          \n          \n            \n                 * added to the {@code ThreadContext} will be retained.\n          \n          \n            \n                 *\n          \n          \n            \n                 * For example, at the end of the following code, the ThreadContext will have transient\n          \n          \n            \n                 * values {@code \"a\"=1}, {@code \"b\"=1}, {@code \"d\"=2} and {@code \"c\"} will not be set.\n          \n          \n            \n                 * <pre>\n          \n          \n            \n                 * threadContext.putTransient(\"a\", 1);  \n          \n          \n            \n                 * threadContext.putTransient(\"b\", 1);   \n          \n          \n            \n                 * try (ThreadContext.StoredContext restore = threadContext.stashTransientContext(List.of(\"b\", \"c\")) ) {\n          \n          \n            \n                 *   threadContext.putTransient(\"b\", 2);   \n          \n          \n            \n                 *   threadContext.putTransient(\"c\", 2);   \n          \n          \n            \n                 *   threadContext.putTransient(\"d\", 2); \n          \n          \n            \n                 * }\n          \n          \n            \n                 * </pre>", "url": "https://github.com/elastic/elasticsearch/pull/61621#discussion_r484152581", "createdAt": "2020-09-07T02:21:57Z", "author": {"login": "tvernum"}, "path": "server/src/main/java/org/elasticsearch/common/util/concurrent/ThreadContext.java", "diffHunk": "@@ -134,6 +135,47 @@ public StoredContext stashContext() {\n         };\n     }\n \n+    /**\n+     * Removes the specified transient headers from the current context. The removed transient headers can be\n+     * restored by closing the returned {@link StoredContext}. If such a transient header does not exist before\n+     * this method is called, it will also not exist after restore (i.e. restoring asserts the existence\n+     * and the values for the transient headers, as they existed before invoking this method).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ff4d6d62bbf2deb885ad95cc3646b1f03da8743"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDMyNTM3Nw==", "bodyText": "Thank you for the clear suggestion, Tim!", "url": "https://github.com/elastic/elasticsearch/pull/61621#discussion_r484325377", "createdAt": "2020-09-07T09:54:44Z", "author": {"login": "albertzaharovits"}, "path": "server/src/main/java/org/elasticsearch/common/util/concurrent/ThreadContext.java", "diffHunk": "@@ -134,6 +135,47 @@ public StoredContext stashContext() {\n         };\n     }\n \n+    /**\n+     * Removes the specified transient headers from the current context. The removed transient headers can be\n+     * restored by closing the returned {@link StoredContext}. If such a transient header does not exist before\n+     * this method is called, it will also not exist after restore (i.e. restoring asserts the existence\n+     * and the values for the transient headers, as they existed before invoking this method).", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDE1MjU4MQ=="}, "originalCommit": {"oid": "6ff4d6d62bbf2deb885ad95cc3646b1f03da8743"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyODA1NzA0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/common/util/concurrent/ThreadContext.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QwNDo0MDowN1rOHNv8iA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QxMjoxNToyOFrOHN9Ifw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDE3OTA4MA==", "bodyText": "Could we add Objects.requireNonNull(...) in the existing ThreadContext#putTransient method to stop the possibility of null value ever being added as a transient header?\nPlease note I am not suggesting to remove the null check here. In fact, I think it is good since I don't think we would ever need null transient headers. But the fact that null can be put into the headers and the subtle difference between null value and non-existence makes it a bit distracting to think through the behaviour. I had to spend some time to convince myself that the behaviour is correct even if a null value does slip into the headers. Therefore, if a non-null check can be added to putTransient method, it would help making this thought process easier and also benefit future readers.", "url": "https://github.com/elastic/elasticsearch/pull/61621#discussion_r484179080", "createdAt": "2020-09-07T04:40:07Z", "author": {"login": "ywangd"}, "path": "server/src/main/java/org/elasticsearch/common/util/concurrent/ThreadContext.java", "diffHunk": "@@ -134,6 +135,47 @@ public StoredContext stashContext() {\n         };\n     }\n \n+    /**\n+     * Removes the specified transient headers from the current context. The removed transient headers can be\n+     * restored by closing the returned {@link StoredContext}. If such a transient header does not exist before\n+     * this method is called, it will also not exist after restore (i.e. restoring asserts the existence\n+     * and the values for the transient headers, as they existed before invoking this method).\n+     */\n+    public StoredContext stashTransientContext(Collection<String> transientHeadersToStash) {\n+        if (transientHeadersToStash.isEmpty()) {\n+            // no-op\n+            return () -> {\n+            };\n+        }\n+        final ThreadContextStruct beforeContext = threadLocal.get();\n+        final Map<String, Object> stashedTransientHeaders = new HashMap<>();\n+        Map<String, Object> newBeforeTransientHeaders = new HashMap<>(beforeContext.transientHeaders);\n+        for (String transientHeaderToStash : transientHeadersToStash) {\n+            Object stashed = newBeforeTransientHeaders.remove(transientHeaderToStash);\n+            if (stashed != null) {\n+                stashedTransientHeaders.put(transientHeaderToStash, stashed);\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ff4d6d62bbf2deb885ad95cc3646b1f03da8743"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDM4OTk3NQ==", "bodyText": "Could we add Objects.requireNonNull(...) in the existing ThreadContext#putTransient method to stop the possibility of null value ever being added as a transient header?\n\nWe could. But it feels to me that it diverges from the scope of this PR, so I believe a separate PR is more suitable.\nEven so, I'm not sure that the discussions it could spur are worth it.\nI have changed the code slightly:\n        for (String transientHeaderToStash : transientHeadersToStash) {\n            if (newBeforeTransientHeaders.containsKey(transientHeaderToStash)) {\n                Object stashed = newBeforeTransientHeaders.remove(transientHeaderToStash);\n                stashedTransientHeaders.put(transientHeaderToStash, stashed);\n            }\n        }\n\nIn order to assuage your original concern that the stashTransientHeaders method has slightly different behaviours for null or missing headers.", "url": "https://github.com/elastic/elasticsearch/pull/61621#discussion_r484389975", "createdAt": "2020-09-07T12:04:35Z", "author": {"login": "albertzaharovits"}, "path": "server/src/main/java/org/elasticsearch/common/util/concurrent/ThreadContext.java", "diffHunk": "@@ -134,6 +135,47 @@ public StoredContext stashContext() {\n         };\n     }\n \n+    /**\n+     * Removes the specified transient headers from the current context. The removed transient headers can be\n+     * restored by closing the returned {@link StoredContext}. If such a transient header does not exist before\n+     * this method is called, it will also not exist after restore (i.e. restoring asserts the existence\n+     * and the values for the transient headers, as they existed before invoking this method).\n+     */\n+    public StoredContext stashTransientContext(Collection<String> transientHeadersToStash) {\n+        if (transientHeadersToStash.isEmpty()) {\n+            // no-op\n+            return () -> {\n+            };\n+        }\n+        final ThreadContextStruct beforeContext = threadLocal.get();\n+        final Map<String, Object> stashedTransientHeaders = new HashMap<>();\n+        Map<String, Object> newBeforeTransientHeaders = new HashMap<>(beforeContext.transientHeaders);\n+        for (String transientHeaderToStash : transientHeadersToStash) {\n+            Object stashed = newBeforeTransientHeaders.remove(transientHeaderToStash);\n+            if (stashed != null) {\n+                stashedTransientHeaders.put(transientHeaderToStash, stashed);\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDE3OTA4MA=="}, "originalCommit": {"oid": "6ff4d6d62bbf2deb885ad95cc3646b1f03da8743"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDM5NTEzNQ==", "bodyText": "This change is better. Thanks!", "url": "https://github.com/elastic/elasticsearch/pull/61621#discussion_r484395135", "createdAt": "2020-09-07T12:15:28Z", "author": {"login": "ywangd"}, "path": "server/src/main/java/org/elasticsearch/common/util/concurrent/ThreadContext.java", "diffHunk": "@@ -134,6 +135,47 @@ public StoredContext stashContext() {\n         };\n     }\n \n+    /**\n+     * Removes the specified transient headers from the current context. The removed transient headers can be\n+     * restored by closing the returned {@link StoredContext}. If such a transient header does not exist before\n+     * this method is called, it will also not exist after restore (i.e. restoring asserts the existence\n+     * and the values for the transient headers, as they existed before invoking this method).\n+     */\n+    public StoredContext stashTransientContext(Collection<String> transientHeadersToStash) {\n+        if (transientHeadersToStash.isEmpty()) {\n+            // no-op\n+            return () -> {\n+            };\n+        }\n+        final ThreadContextStruct beforeContext = threadLocal.get();\n+        final Map<String, Object> stashedTransientHeaders = new HashMap<>();\n+        Map<String, Object> newBeforeTransientHeaders = new HashMap<>(beforeContext.transientHeaders);\n+        for (String transientHeaderToStash : transientHeadersToStash) {\n+            Object stashed = newBeforeTransientHeaders.remove(transientHeaderToStash);\n+            if (stashed != null) {\n+                stashedTransientHeaders.put(transientHeaderToStash, stashed);\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDE3OTA4MA=="}, "originalCommit": {"oid": "6ff4d6d62bbf2deb885ad95cc3646b1f03da8743"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyODE0NjMzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/common/util/concurrent/ThreadContext.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QwNTozODoxMlrOHNwvmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QxMTozNjowOFrOHN7-rA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDE5MjE1NQ==", "bodyText": "Naming is hard. I'd personally suggest this method to be just called stashTransientHeaders. The difference is to drop the Context bit, which is the confusing bit for me, because the existing stashContext behaves differently in a subtle but important way:\n\nFor the child actions, stashContext assigns it to a default context, while this method assigns it the \"current\" context minus the transients. This is more similar to the behaviour of newStoredContext, which assigns the current context unchanged.\nWhen restoring, stashContext restores the original context, while this method only restore selected trainstent headers. The important difference here is that this method does not restore anything else.", "url": "https://github.com/elastic/elasticsearch/pull/61621#discussion_r484192155", "createdAt": "2020-09-07T05:38:12Z", "author": {"login": "ywangd"}, "path": "server/src/main/java/org/elasticsearch/common/util/concurrent/ThreadContext.java", "diffHunk": "@@ -134,6 +135,47 @@ public StoredContext stashContext() {\n         };\n     }\n \n+    /**\n+     * Removes the specified transient headers from the current context. The removed transient headers can be\n+     * restored by closing the returned {@link StoredContext}. If such a transient header does not exist before\n+     * this method is called, it will also not exist after restore (i.e. restoring asserts the existence\n+     * and the values for the transient headers, as they existed before invoking this method).\n+     */\n+    public StoredContext stashTransientContext(Collection<String> transientHeadersToStash) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ff4d6d62bbf2deb885ad95cc3646b1f03da8743"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDM3NjIzNg==", "bodyText": "I went with stashTransientHeaders , thanks for suggesting.", "url": "https://github.com/elastic/elasticsearch/pull/61621#discussion_r484376236", "createdAt": "2020-09-07T11:36:08Z", "author": {"login": "albertzaharovits"}, "path": "server/src/main/java/org/elasticsearch/common/util/concurrent/ThreadContext.java", "diffHunk": "@@ -134,6 +135,47 @@ public StoredContext stashContext() {\n         };\n     }\n \n+    /**\n+     * Removes the specified transient headers from the current context. The removed transient headers can be\n+     * restored by closing the returned {@link StoredContext}. If such a transient header does not exist before\n+     * this method is called, it will also not exist after restore (i.e. restoring asserts the existence\n+     * and the values for the transient headers, as they existed before invoking this method).\n+     */\n+    public StoredContext stashTransientContext(Collection<String> transientHeadersToStash) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDE5MjE1NQ=="}, "originalCommit": {"oid": "6ff4d6d62bbf2deb885ad95cc3646b1f03da8743"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyODE2MzMxOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/SecurityContext.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QwNTo0ODoxNlrOHNw5kA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QxMTo1NToxOFrOHN8itg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDE5NDcwNA==", "bodyText": "I am not sure whether it is necessary to package this into SecurityContext class. I'd prefer to have it as a method of AuthorizationService, since it is the only consumer. Therefore it will be close to the context if it is defined in AuthorizationService. Based on the method name, it is also unlikley to be used anywhere else in future.\nWrapping it here leads to many boilerplate code like securityContext.getThreadContext()..., which does not help reading and maybe obsecure the actual importance being only \"transient header stashing\" for future readers.", "url": "https://github.com/elastic/elasticsearch/pull/61621#discussion_r484194704", "createdAt": "2020-09-07T05:48:16Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/SecurityContext.java", "diffHunk": "@@ -150,6 +151,16 @@ public void executeAsUser(User user, Consumer<StoredContext> consumer, Version v\n         }\n     }\n \n+    /**\n+     * Compared to {@code ThreadContext#stashContext} this only clears the specific transient headers that are used to convey the\n+     * authorization outcome, leaving the other headers in place, just like {@code ThreadContext#newStoredContext(true)}. When\n+     * the returned {@code StoredContext} is closed, the original authorization transient headers are restored (if any did\n+     * not originally exist, it will also not exist after the restore).\n+     */\n+    public StoredContext stashAuthorizationContext() {\n+        return threadContext.stashTransientContext(AuthorizationServiceField.ALL_AUTHORIZATION_KEYS);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ff4d6d62bbf2deb885ad95cc3646b1f03da8743"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDM4NTQ2Mg==", "bodyText": "I still maintain that it sits better in the SecurityContext even if the AuthorizationService is the single caller, but the topic is not significant enough to argue about, so I went with your suggestion.", "url": "https://github.com/elastic/elasticsearch/pull/61621#discussion_r484385462", "createdAt": "2020-09-07T11:55:18Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/SecurityContext.java", "diffHunk": "@@ -150,6 +151,16 @@ public void executeAsUser(User user, Consumer<StoredContext> consumer, Version v\n         }\n     }\n \n+    /**\n+     * Compared to {@code ThreadContext#stashContext} this only clears the specific transient headers that are used to convey the\n+     * authorization outcome, leaving the other headers in place, just like {@code ThreadContext#newStoredContext(true)}. When\n+     * the returned {@code StoredContext} is closed, the original authorization transient headers are restored (if any did\n+     * not originally exist, it will also not exist after the restore).\n+     */\n+    public StoredContext stashAuthorizationContext() {\n+        return threadContext.stashTransientContext(AuthorizationServiceField.ALL_AUTHORIZATION_KEYS);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDE5NDcwNA=="}, "originalCommit": {"oid": "6ff4d6d62bbf2deb885ad95cc3646b1f03da8743"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyODE2NTUwOnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/SecurityContext.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QwNTo0OToyNFrOHNw60A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QxMTo1MTo0MVrOHN8b-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDE5NTAyNA==", "bodyText": "It feels important to me to state clearly that other than the specified transient headers, nothing else gets restored. Any other new headers generated by the child actions will be kept.", "url": "https://github.com/elastic/elasticsearch/pull/61621#discussion_r484195024", "createdAt": "2020-09-07T05:49:24Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/SecurityContext.java", "diffHunk": "@@ -150,6 +151,16 @@ public void executeAsUser(User user, Consumer<StoredContext> consumer, Version v\n         }\n     }\n \n+    /**\n+     * Compared to {@code ThreadContext#stashContext} this only clears the specific transient headers that are used to convey the\n+     * authorization outcome, leaving the other headers in place, just like {@code ThreadContext#newStoredContext(true)}. When\n+     * the returned {@code StoredContext} is closed, the original authorization transient headers are restored (if any did\n+     * not originally exist, it will also not exist after the restore).\n+     */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ff4d6d62bbf2deb885ad95cc3646b1f03da8743"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDM4MzczOA==", "bodyText": "I went with Tim's suggestion from #61621 (comment), which I believe satisfies your requirement.", "url": "https://github.com/elastic/elasticsearch/pull/61621#discussion_r484383738", "createdAt": "2020-09-07T11:51:41Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/SecurityContext.java", "diffHunk": "@@ -150,6 +151,16 @@ public void executeAsUser(User user, Consumer<StoredContext> consumer, Version v\n         }\n     }\n \n+    /**\n+     * Compared to {@code ThreadContext#stashContext} this only clears the specific transient headers that are used to convey the\n+     * authorization outcome, leaving the other headers in place, just like {@code ThreadContext#newStoredContext(true)}. When\n+     * the returned {@code StoredContext} is closed, the original authorization transient headers are restored (if any did\n+     * not originally exist, it will also not exist after the restore).\n+     */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDE5NTAyNA=="}, "originalCommit": {"oid": "6ff4d6d62bbf2deb885ad95cc3646b1f03da8743"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzMzMzNzIwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/common/util/concurrent/ThreadContext.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNDo0Mzo1MFrOHOgnnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNjozNDoyNlrOHOlR-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk3NjU0Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * values {@code \"a\"=1}, {@code \"b\"=1}, {@code \"d\"=2} and {@code \"c\"} will not be set.\n          \n          \n            \n                 * values {@code \"a\"=1}, {@code \"b\"=1}, {@code \"d\"=2} and {@code \"c\"=2} will not be set.", "url": "https://github.com/elastic/elasticsearch/pull/61621#discussion_r484976543", "createdAt": "2020-09-08T14:43:50Z", "author": {"login": "jaymode"}, "path": "server/src/main/java/org/elasticsearch/common/util/concurrent/ThreadContext.java", "diffHunk": "@@ -134,6 +135,61 @@ public StoredContext stashContext() {\n         };\n     }\n \n+    /**\n+     * Removes the specified transient headers from the current context. When the returned\n+     * {@link StoredContext} is closed, it will restore these transient headers to their original\n+     * value (including restoring them to an <i>unset</i> value if they did not originally exist).\n+     * Closing the {@code StoredContext} has no affect on any other header - any headers\n+     * (other than those names specified in {@code transientHeadersToStash} that were\n+     * added to the {@code ThreadContext} will be retained.\n+     *\n+     * For example, at the end of the following code, the ThreadContext will have transient\n+     * values {@code \"a\"=1}, {@code \"b\"=1}, {@code \"d\"=2} and {@code \"c\"} will not be set.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1aeb3cef976ab9395aea006bbd65e4c9b6104d3"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA1MjkyMw==", "bodyText": "c not being set is the correct thing.\nIt is included in the list of headers to be stashed, but it is not part of the context before the stash. Therefore the behaviour after restore is to also not be present.", "url": "https://github.com/elastic/elasticsearch/pull/61621#discussion_r485052923", "createdAt": "2020-09-08T16:34:26Z", "author": {"login": "albertzaharovits"}, "path": "server/src/main/java/org/elasticsearch/common/util/concurrent/ThreadContext.java", "diffHunk": "@@ -134,6 +135,61 @@ public StoredContext stashContext() {\n         };\n     }\n \n+    /**\n+     * Removes the specified transient headers from the current context. When the returned\n+     * {@link StoredContext} is closed, it will restore these transient headers to their original\n+     * value (including restoring them to an <i>unset</i> value if they did not originally exist).\n+     * Closing the {@code StoredContext} has no affect on any other header - any headers\n+     * (other than those names specified in {@code transientHeadersToStash} that were\n+     * added to the {@code ThreadContext} will be retained.\n+     *\n+     * For example, at the end of the following code, the ThreadContext will have transient\n+     * values {@code \"a\"=1}, {@code \"b\"=1}, {@code \"d\"=2} and {@code \"c\"} will not be set.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk3NjU0Mw=="}, "originalCommit": {"oid": "d1aeb3cef976ab9395aea006bbd65e4c9b6104d3"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzMzM4Njg2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/common/util/concurrent/ThreadContext.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNDo1NDoyNlrOHOhG9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNjozODo0M1rOHOlbZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk4NDU2Ng==", "bodyText": "I think this should actually make a copy of the struct and restore it, otherwise any additional headers will be leaked back after closing the StoredContext.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        // no-op\n          \n          \n            \n                        return () -> {\n          \n          \n            \n                        };\n          \n          \n            \n                        final ThreadContextStruct context = threadLocal.get();\n          \n          \n            \n                        return () -> threadLocal.set(context);\n          \n      \n    \n    \n  \n\nCan you also add a test to ensure this? Scenario I am thinking will fail as the code is written:\nassertNull(threadContext.getTransient(\"a\");\ntry (ThreadContext.StoredContext restore = threadContext.stashTransientContext(List.of())) {\n    threadContext.putTransient(\"a\", \"1\");\n}\nassertNull(threadContext.getTransient(\"a\");", "url": "https://github.com/elastic/elasticsearch/pull/61621#discussion_r484984566", "createdAt": "2020-09-08T14:54:26Z", "author": {"login": "jaymode"}, "path": "server/src/main/java/org/elasticsearch/common/util/concurrent/ThreadContext.java", "diffHunk": "@@ -134,6 +135,61 @@ public StoredContext stashContext() {\n         };\n     }\n \n+    /**\n+     * Removes the specified transient headers from the current context. When the returned\n+     * {@link StoredContext} is closed, it will restore these transient headers to their original\n+     * value (including restoring them to an <i>unset</i> value if they did not originally exist).\n+     * Closing the {@code StoredContext} has no affect on any other header - any headers\n+     * (other than those names specified in {@code transientHeadersToStash} that were\n+     * added to the {@code ThreadContext} will be retained.\n+     *\n+     * For example, at the end of the following code, the ThreadContext will have transient\n+     * values {@code \"a\"=1}, {@code \"b\"=1}, {@code \"d\"=2} and {@code \"c\"} will not be set.\n+     * <pre>\n+     * threadContext.putTransient(\"a\", 1);\n+     * threadContext.putTransient(\"b\", 1);\n+     * try (ThreadContext.StoredContext restore = threadContext.stashTransientContext(List.of(\"b\", \"c\")) ) {\n+     *   threadContext.putTransient(\"b\", 2);\n+     *   threadContext.putTransient(\"c\", 2);\n+     *   threadContext.putTransient(\"d\", 2);\n+     * }\n+     * </pre>\n+     */\n+    public StoredContext stashTransientHeaders(Collection<String> transientHeadersToStash) {\n+        if (transientHeadersToStash.isEmpty()) {\n+            // no-op\n+            return () -> {\n+            };", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1aeb3cef976ab9395aea006bbd65e4c9b6104d3"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA1NTMzMw==", "bodyText": "The leaking is by design. Only the specified headers are restored; for the others, if they're changed inside the stash, they are preserved after restore (think response headers). The renaming from stashTransientContext to stashTransientHeaders ought to help clarifying this oddity.", "url": "https://github.com/elastic/elasticsearch/pull/61621#discussion_r485055333", "createdAt": "2020-09-08T16:38:43Z", "author": {"login": "albertzaharovits"}, "path": "server/src/main/java/org/elasticsearch/common/util/concurrent/ThreadContext.java", "diffHunk": "@@ -134,6 +135,61 @@ public StoredContext stashContext() {\n         };\n     }\n \n+    /**\n+     * Removes the specified transient headers from the current context. When the returned\n+     * {@link StoredContext} is closed, it will restore these transient headers to their original\n+     * value (including restoring them to an <i>unset</i> value if they did not originally exist).\n+     * Closing the {@code StoredContext} has no affect on any other header - any headers\n+     * (other than those names specified in {@code transientHeadersToStash} that were\n+     * added to the {@code ThreadContext} will be retained.\n+     *\n+     * For example, at the end of the following code, the ThreadContext will have transient\n+     * values {@code \"a\"=1}, {@code \"b\"=1}, {@code \"d\"=2} and {@code \"c\"} will not be set.\n+     * <pre>\n+     * threadContext.putTransient(\"a\", 1);\n+     * threadContext.putTransient(\"b\", 1);\n+     * try (ThreadContext.StoredContext restore = threadContext.stashTransientContext(List.of(\"b\", \"c\")) ) {\n+     *   threadContext.putTransient(\"b\", 2);\n+     *   threadContext.putTransient(\"c\", 2);\n+     *   threadContext.putTransient(\"d\", 2);\n+     * }\n+     * </pre>\n+     */\n+    public StoredContext stashTransientHeaders(Collection<String> transientHeadersToStash) {\n+        if (transientHeadersToStash.isEmpty()) {\n+            // no-op\n+            return () -> {\n+            };", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk4NDU2Ng=="}, "originalCommit": {"oid": "d1aeb3cef976ab9395aea006bbd65e4c9b6104d3"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzMzQwNjMwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/common/util/concurrent/ThreadContext.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNDo1NzozNFrOHOhTfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNjo0MDozMFrOHOlflg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk4Nzc3NA==", "bodyText": "Why can't we just restore the beforeContext?\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        final ThreadContextStruct afterContext = threadLocal.get();\n          \n          \n            \n                        Map<String, Object> newAfterTransientHeaders = new HashMap<>(afterContext.transientHeaders);\n          \n          \n            \n                        // remove the transients that might have been set in the mean time\n          \n          \n            \n                        for (String transientHeaderToStash : transientHeadersToStash) {\n          \n          \n            \n                            newAfterTransientHeaders.remove(transientHeaderToStash);\n          \n          \n            \n                        }\n          \n          \n            \n                        // fill in the values that existed before stashing\n          \n          \n            \n                        newAfterTransientHeaders.putAll(stashedTransientHeaders);\n          \n          \n            \n                        ThreadContextStruct threadContextStruct = new ThreadContextStruct(afterContext.requestHeaders, afterContext.responseHeaders,\n          \n          \n            \n                                newAfterTransientHeaders, afterContext.isSystemContext);\n          \n          \n            \n                        threadLocal.set(threadContextStruct);\n          \n          \n            \n                        return () -> threadLocal.set(beforeContext);", "url": "https://github.com/elastic/elasticsearch/pull/61621#discussion_r484987774", "createdAt": "2020-09-08T14:57:34Z", "author": {"login": "jaymode"}, "path": "server/src/main/java/org/elasticsearch/common/util/concurrent/ThreadContext.java", "diffHunk": "@@ -134,6 +135,61 @@ public StoredContext stashContext() {\n         };\n     }\n \n+    /**\n+     * Removes the specified transient headers from the current context. When the returned\n+     * {@link StoredContext} is closed, it will restore these transient headers to their original\n+     * value (including restoring them to an <i>unset</i> value if they did not originally exist).\n+     * Closing the {@code StoredContext} has no affect on any other header - any headers\n+     * (other than those names specified in {@code transientHeadersToStash} that were\n+     * added to the {@code ThreadContext} will be retained.\n+     *\n+     * For example, at the end of the following code, the ThreadContext will have transient\n+     * values {@code \"a\"=1}, {@code \"b\"=1}, {@code \"d\"=2} and {@code \"c\"} will not be set.\n+     * <pre>\n+     * threadContext.putTransient(\"a\", 1);\n+     * threadContext.putTransient(\"b\", 1);\n+     * try (ThreadContext.StoredContext restore = threadContext.stashTransientContext(List.of(\"b\", \"c\")) ) {\n+     *   threadContext.putTransient(\"b\", 2);\n+     *   threadContext.putTransient(\"c\", 2);\n+     *   threadContext.putTransient(\"d\", 2);\n+     * }\n+     * </pre>\n+     */\n+    public StoredContext stashTransientHeaders(Collection<String> transientHeadersToStash) {\n+        if (transientHeadersToStash.isEmpty()) {\n+            // no-op\n+            return () -> {\n+            };\n+        }\n+        final ThreadContextStruct beforeContext = threadLocal.get();\n+        final Map<String, Object> stashedTransientHeaders = new HashMap<>();\n+        Map<String, Object> newBeforeTransientHeaders = new HashMap<>(beforeContext.transientHeaders);\n+        for (String transientHeaderToStash : transientHeadersToStash) {\n+            if (newBeforeTransientHeaders.containsKey(transientHeaderToStash)) {\n+                Object stashed = newBeforeTransientHeaders.remove(transientHeaderToStash);\n+                stashedTransientHeaders.put(transientHeaderToStash, stashed);\n+            }\n+        }\n+        if (false == stashedTransientHeaders.isEmpty()) {\n+            ThreadContextStruct threadContextStruct = new ThreadContextStruct(beforeContext.requestHeaders, beforeContext.responseHeaders,\n+                    newBeforeTransientHeaders, beforeContext.isSystemContext);\n+            threadLocal.set(threadContextStruct);\n+        }\n+        return () -> {\n+            final ThreadContextStruct afterContext = threadLocal.get();\n+            Map<String, Object> newAfterTransientHeaders = new HashMap<>(afterContext.transientHeaders);\n+            // remove the transients that might have been set in the mean time\n+            for (String transientHeaderToStash : transientHeadersToStash) {\n+                newAfterTransientHeaders.remove(transientHeaderToStash);\n+            }\n+            // fill in the values that existed before stashing\n+            newAfterTransientHeaders.putAll(stashedTransientHeaders);\n+            ThreadContextStruct threadContextStruct = new ThreadContextStruct(afterContext.requestHeaders, afterContext.responseHeaders,\n+                    newAfterTransientHeaders, afterContext.isSystemContext);\n+            threadLocal.set(threadContextStruct);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1aeb3cef976ab9395aea006bbd65e4c9b6104d3"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA1NjQwNg==", "bodyText": "We have to maintain all the other headers (transient, request, response) as they might have been modified inside the stash, and revert only the ones in the arg list.", "url": "https://github.com/elastic/elasticsearch/pull/61621#discussion_r485056406", "createdAt": "2020-09-08T16:40:30Z", "author": {"login": "albertzaharovits"}, "path": "server/src/main/java/org/elasticsearch/common/util/concurrent/ThreadContext.java", "diffHunk": "@@ -134,6 +135,61 @@ public StoredContext stashContext() {\n         };\n     }\n \n+    /**\n+     * Removes the specified transient headers from the current context. When the returned\n+     * {@link StoredContext} is closed, it will restore these transient headers to their original\n+     * value (including restoring them to an <i>unset</i> value if they did not originally exist).\n+     * Closing the {@code StoredContext} has no affect on any other header - any headers\n+     * (other than those names specified in {@code transientHeadersToStash} that were\n+     * added to the {@code ThreadContext} will be retained.\n+     *\n+     * For example, at the end of the following code, the ThreadContext will have transient\n+     * values {@code \"a\"=1}, {@code \"b\"=1}, {@code \"d\"=2} and {@code \"c\"} will not be set.\n+     * <pre>\n+     * threadContext.putTransient(\"a\", 1);\n+     * threadContext.putTransient(\"b\", 1);\n+     * try (ThreadContext.StoredContext restore = threadContext.stashTransientContext(List.of(\"b\", \"c\")) ) {\n+     *   threadContext.putTransient(\"b\", 2);\n+     *   threadContext.putTransient(\"c\", 2);\n+     *   threadContext.putTransient(\"d\", 2);\n+     * }\n+     * </pre>\n+     */\n+    public StoredContext stashTransientHeaders(Collection<String> transientHeadersToStash) {\n+        if (transientHeadersToStash.isEmpty()) {\n+            // no-op\n+            return () -> {\n+            };\n+        }\n+        final ThreadContextStruct beforeContext = threadLocal.get();\n+        final Map<String, Object> stashedTransientHeaders = new HashMap<>();\n+        Map<String, Object> newBeforeTransientHeaders = new HashMap<>(beforeContext.transientHeaders);\n+        for (String transientHeaderToStash : transientHeadersToStash) {\n+            if (newBeforeTransientHeaders.containsKey(transientHeaderToStash)) {\n+                Object stashed = newBeforeTransientHeaders.remove(transientHeaderToStash);\n+                stashedTransientHeaders.put(transientHeaderToStash, stashed);\n+            }\n+        }\n+        if (false == stashedTransientHeaders.isEmpty()) {\n+            ThreadContextStruct threadContextStruct = new ThreadContextStruct(beforeContext.requestHeaders, beforeContext.responseHeaders,\n+                    newBeforeTransientHeaders, beforeContext.isSystemContext);\n+            threadLocal.set(threadContextStruct);\n+        }\n+        return () -> {\n+            final ThreadContextStruct afterContext = threadLocal.get();\n+            Map<String, Object> newAfterTransientHeaders = new HashMap<>(afterContext.transientHeaders);\n+            // remove the transients that might have been set in the mean time\n+            for (String transientHeaderToStash : transientHeadersToStash) {\n+                newAfterTransientHeaders.remove(transientHeaderToStash);\n+            }\n+            // fill in the values that existed before stashing\n+            newAfterTransientHeaders.putAll(stashedTransientHeaders);\n+            ThreadContextStruct threadContextStruct = new ThreadContextStruct(afterContext.requestHeaders, afterContext.responseHeaders,\n+                    newAfterTransientHeaders, afterContext.isSystemContext);\n+            threadLocal.set(threadContextStruct);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk4Nzc3NA=="}, "originalCommit": {"oid": "d1aeb3cef976ab9395aea006bbd65e4c9b6104d3"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzOTk4ODgxOnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/elasticsearch/common/util/concurrent/ThreadContextTests.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwMTozOTo1MFrOHPf05A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxMjoxNDowOFrOHPwnlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjAxMjEzMg==", "bodyText": "This is a duplicate of Line 70-72.", "url": "https://github.com/elastic/elasticsearch/pull/61621#discussion_r486012132", "createdAt": "2020-09-10T01:39:50Z", "author": {"login": "ywangd"}, "path": "server/src/test/java/org/elasticsearch/common/util/concurrent/ThreadContextTests.java", "diffHunk": "@@ -56,6 +57,82 @@ public void testStashContext() {\n         assertEquals(\"1\", threadContext.getHeader(\"default\"));\n     }\n \n+    public void testNewContextWithClearedTransients() {\n+        ThreadContext threadContext = new ThreadContext(Settings.EMPTY);\n+        threadContext.putTransient(\"foo\", \"bar\");\n+        threadContext.putTransient(\"bar\", \"baz\");\n+        threadContext.putHeader(\"foo\", \"bar\");\n+        threadContext.putHeader(\"baz\", \"bar\");\n+        threadContext.addResponseHeader(\"foo\", \"bar\");\n+        threadContext.addResponseHeader(\"bar\", \"qux\");\n+\n+        // this is missing or null\n+        if (randomBoolean()) {\n+            threadContext.putTransient(\"acme\", null);\n+        }\n+\n+        // foo is the only existing transient header that is cleared\n+        try (ThreadContext.StoredContext stashed = threadContext.newStoredContext(false, randomFrom(List.of(\"foo\", \"foo\"),\n+                List.of(\"foo\"), List.of(\"foo\", \"acme\")))) {\n+            // only the requested transient header is cleared\n+            assertNull(threadContext.getTransient(\"foo\"));\n+            // missing header is still missing\n+            assertNull(threadContext.getTransient(\"acme\"));\n+            // other headers are preserved\n+            assertEquals(\"baz\", threadContext.getTransient(\"bar\"));\n+            assertEquals(\"bar\", threadContext.getHeader(\"foo\"));\n+            assertEquals(\"bar\", threadContext.getHeader(\"baz\"));\n+            assertEquals(\"bar\", threadContext.getResponseHeaders().get(\"foo\").get(0));\n+            assertEquals(\"qux\", threadContext.getResponseHeaders().get(\"bar\").get(0));\n+\n+            // try override stashed header\n+            threadContext.putTransient(\"foo\", \"acme\");\n+            assertEquals(\"acme\", threadContext.getTransient(\"foo\"));\n+            // add new headers\n+            threadContext.putTransient(\"baz\", \"bar\");\n+            threadContext.putHeader(\"bar\", \"baz\");\n+            threadContext.addResponseHeader(\"baz\", \"bar\");\n+            threadContext.addResponseHeader(\"foo\", \"baz\");\n+        }\n+\n+        // original is restored (it is not overridden)\n+        assertEquals(\"bar\", threadContext.getTransient(\"foo\"));\n+        // headers added inside the stash are NOT preserved\n+        assertNull(threadContext.getTransient(\"baz\"));\n+        assertNull(threadContext.getHeader(\"bar\"));\n+        assertNull(threadContext.getResponseHeaders().get(\"baz\"));\n+        // original headers are restored\n+        assertEquals(\"bar\", threadContext.getHeader(\"foo\"));\n+        assertEquals(\"bar\", threadContext.getHeader(\"baz\"));\n+        assertEquals(\"bar\", threadContext.getResponseHeaders().get(\"foo\").get(0));\n+        assertEquals(1, threadContext.getResponseHeaders().get(\"foo\").size());\n+        assertEquals(\"qux\", threadContext.getResponseHeaders().get(\"bar\").get(0));\n+\n+        if (randomBoolean()) {\n+            threadContext.putTransient(\"acme\", null);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cdc45aabf2013edfde7b89c8a4d160dcf003350f"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjI4NzI1Mw==", "bodyText": "On purpose, but I can remove it.", "url": "https://github.com/elastic/elasticsearch/pull/61621#discussion_r486287253", "createdAt": "2020-09-10T12:14:08Z", "author": {"login": "albertzaharovits"}, "path": "server/src/test/java/org/elasticsearch/common/util/concurrent/ThreadContextTests.java", "diffHunk": "@@ -56,6 +57,82 @@ public void testStashContext() {\n         assertEquals(\"1\", threadContext.getHeader(\"default\"));\n     }\n \n+    public void testNewContextWithClearedTransients() {\n+        ThreadContext threadContext = new ThreadContext(Settings.EMPTY);\n+        threadContext.putTransient(\"foo\", \"bar\");\n+        threadContext.putTransient(\"bar\", \"baz\");\n+        threadContext.putHeader(\"foo\", \"bar\");\n+        threadContext.putHeader(\"baz\", \"bar\");\n+        threadContext.addResponseHeader(\"foo\", \"bar\");\n+        threadContext.addResponseHeader(\"bar\", \"qux\");\n+\n+        // this is missing or null\n+        if (randomBoolean()) {\n+            threadContext.putTransient(\"acme\", null);\n+        }\n+\n+        // foo is the only existing transient header that is cleared\n+        try (ThreadContext.StoredContext stashed = threadContext.newStoredContext(false, randomFrom(List.of(\"foo\", \"foo\"),\n+                List.of(\"foo\"), List.of(\"foo\", \"acme\")))) {\n+            // only the requested transient header is cleared\n+            assertNull(threadContext.getTransient(\"foo\"));\n+            // missing header is still missing\n+            assertNull(threadContext.getTransient(\"acme\"));\n+            // other headers are preserved\n+            assertEquals(\"baz\", threadContext.getTransient(\"bar\"));\n+            assertEquals(\"bar\", threadContext.getHeader(\"foo\"));\n+            assertEquals(\"bar\", threadContext.getHeader(\"baz\"));\n+            assertEquals(\"bar\", threadContext.getResponseHeaders().get(\"foo\").get(0));\n+            assertEquals(\"qux\", threadContext.getResponseHeaders().get(\"bar\").get(0));\n+\n+            // try override stashed header\n+            threadContext.putTransient(\"foo\", \"acme\");\n+            assertEquals(\"acme\", threadContext.getTransient(\"foo\"));\n+            // add new headers\n+            threadContext.putTransient(\"baz\", \"bar\");\n+            threadContext.putHeader(\"bar\", \"baz\");\n+            threadContext.addResponseHeader(\"baz\", \"bar\");\n+            threadContext.addResponseHeader(\"foo\", \"baz\");\n+        }\n+\n+        // original is restored (it is not overridden)\n+        assertEquals(\"bar\", threadContext.getTransient(\"foo\"));\n+        // headers added inside the stash are NOT preserved\n+        assertNull(threadContext.getTransient(\"baz\"));\n+        assertNull(threadContext.getHeader(\"bar\"));\n+        assertNull(threadContext.getResponseHeaders().get(\"baz\"));\n+        // original headers are restored\n+        assertEquals(\"bar\", threadContext.getHeader(\"foo\"));\n+        assertEquals(\"bar\", threadContext.getHeader(\"baz\"));\n+        assertEquals(\"bar\", threadContext.getResponseHeaders().get(\"foo\").get(0));\n+        assertEquals(1, threadContext.getResponseHeaders().get(\"foo\").size());\n+        assertEquals(\"qux\", threadContext.getResponseHeaders().get(\"bar\").get(0));\n+\n+        if (randomBoolean()) {\n+            threadContext.putTransient(\"acme\", null);\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjAxMjEzMg=="}, "originalCommit": {"oid": "cdc45aabf2013edfde7b89c8a4d160dcf003350f"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MDI2MTM1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/AuthorizationService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwNDoxNToyMVrOHPiR8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxMjoxMzo1N1rOHPwnMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA1MjMzOQ==", "bodyText": "Is this the right semantic? I understand this is the reason why RestSqlSecurityIT needs to be updated. Technical details aside, if a parent action invokes a child action, should the \"originating action\" still be the parent action? The change here makes it to be the child action. If it's always the child action, why does it need to be called \"originating\" action?", "url": "https://github.com/elastic/elasticsearch/pull/61621#discussion_r486052339", "createdAt": "2020-09-10T04:15:21Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/AuthorizationService.java", "diffHunk": "@@ -168,39 +168,46 @@ private AuthorizationInfo getAuthorizationInfoFromContext() {\n      */\n     public void authorize(final Authentication authentication, final String action, final TransportRequest originalRequest,\n                           final ActionListener<Void> listener) throws ElasticsearchSecurityException {\n-        // prior to doing any authorization lets set the originating action in the context only\n-        putTransientIfNonExisting(ORIGINATING_ACTION_KEY, action);\n-\n-        String auditId = AuditUtil.extractRequestId(threadContext);\n-        if (auditId == null) {\n-            // We would like to assert that there is an existing request-id, but if this is a system action, then that might not be\n-            // true because the request-id is generated during authentication\n-            if (isInternalUser(authentication.getUser()) != false) {\n-                auditId = AuditUtil.getOrGenerateRequestId(threadContext);\n-            } else {\n-                auditTrailService.get().tamperedRequest(null, authentication, action, originalRequest);\n-                final String message = \"Attempt to authorize action [\" + action + \"] for [\" + authentication.getUser().principal()\n-                    + \"] without an existing request-id\";\n-                assert false : message;\n-                listener.onFailure(new ElasticsearchSecurityException(message));\n+        /* authorization fills in certain transient headers (that must be observed in the listener as well), therefore we\n+         * begin by clearing the existing ones up (as they might be already set by the authorization of a previous parent\n+         * action (which ran under the same context (on the same node))).\n+         * When the returned {@code StoredContext} is closed, ALL the original headers are restored.\n+         */\n+        try (ThreadContext.StoredContext ignore = threadContext.newStoredContext(false, AuthorizationServiceField.ALL_AUTHORIZATION_KEYS)) {\n+            // prior to doing any authorization lets set the originating action in the context only\n+            threadContext.putTransient(AuthorizationServiceField.ORIGINATING_ACTION_KEY, action);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cdc45aabf2013edfde7b89c8a4d160dcf003350f"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjI4NzE1NA==", "bodyText": "It's just a naming thing. On the obverse, wouldn't it be odd to only just store the parent action name, no matter the child nesting level, but only if the request doesn't cross thee node boundary?", "url": "https://github.com/elastic/elasticsearch/pull/61621#discussion_r486287154", "createdAt": "2020-09-10T12:13:57Z", "author": {"login": "albertzaharovits"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/AuthorizationService.java", "diffHunk": "@@ -168,39 +168,46 @@ private AuthorizationInfo getAuthorizationInfoFromContext() {\n      */\n     public void authorize(final Authentication authentication, final String action, final TransportRequest originalRequest,\n                           final ActionListener<Void> listener) throws ElasticsearchSecurityException {\n-        // prior to doing any authorization lets set the originating action in the context only\n-        putTransientIfNonExisting(ORIGINATING_ACTION_KEY, action);\n-\n-        String auditId = AuditUtil.extractRequestId(threadContext);\n-        if (auditId == null) {\n-            // We would like to assert that there is an existing request-id, but if this is a system action, then that might not be\n-            // true because the request-id is generated during authentication\n-            if (isInternalUser(authentication.getUser()) != false) {\n-                auditId = AuditUtil.getOrGenerateRequestId(threadContext);\n-            } else {\n-                auditTrailService.get().tamperedRequest(null, authentication, action, originalRequest);\n-                final String message = \"Attempt to authorize action [\" + action + \"] for [\" + authentication.getUser().principal()\n-                    + \"] without an existing request-id\";\n-                assert false : message;\n-                listener.onFailure(new ElasticsearchSecurityException(message));\n+        /* authorization fills in certain transient headers (that must be observed in the listener as well), therefore we\n+         * begin by clearing the existing ones up (as they might be already set by the authorization of a previous parent\n+         * action (which ran under the same context (on the same node))).\n+         * When the returned {@code StoredContext} is closed, ALL the original headers are restored.\n+         */\n+        try (ThreadContext.StoredContext ignore = threadContext.newStoredContext(false, AuthorizationServiceField.ALL_AUTHORIZATION_KEYS)) {\n+            // prior to doing any authorization lets set the originating action in the context only\n+            threadContext.putTransient(AuthorizationServiceField.ORIGINATING_ACTION_KEY, action);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA1MjMzOQ=="}, "originalCommit": {"oid": "cdc45aabf2013edfde7b89c8a4d160dcf003350f"}, "originalPosition": 43}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 746, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}