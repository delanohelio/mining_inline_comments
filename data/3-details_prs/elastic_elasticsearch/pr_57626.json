{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI3NDU1NDk3", "number": 57626, "title": "Resolve index API", "bodyText": "Provides a /_resolve/index/{name(s)} endpoint that resolves the specified name(s) and/or wildcard expressions to indices, aliases, and data streams.\nMultiple expressions and remote clusters are supported. E.g.:\nGET /_resolve/index/f*,remoteCluster1:bar*\nThe response is in the format:\n{\n  \"indices\" : [\n    {\n      \"name\" : \"foo-000001\",\n      \"attributes\" : [\n        \"open\",\n        \"hidden\"\n      ],\n      \"data_stream\" : \"foo\"\n    },\n    {\n      \"name\" : \"foo_closed\",\n      \"attributes\" : [\n        \"closed\"\n      ]\n    },\n    {\n      \"name\" : \"remoteCluster1:bar-01\",\n      \"attributes\" : [\n        \"open\"\n      ]\n    },\n    {\n      \"name\" : \"freeze-index\",\n      \"aliases\" : [\n        \"f-alias\"\n      ],\n      \"attributes\" : [\n        \"open\",\n        \"frozen\"\n      ]\n    }\n  ],\n  \"aliases\" : [\n    {\n      \"name\" : \"f-alias\",\n      \"indices\" : [\n        \"freeze-index\",\n        \"my-index\"\n      ]\n    }\n  ],\n  \"data_streams\" : [\n    {\n      \"name\" : \"foo\",\n      \"backing_indices\" : [\n        \"foo-000001\"\n      ],\n      \"timestamp_field\" : \"@timestamp\"\n    }\n  ]\n}\n\nThe attributes array for an index will always contain either open or closed as well as hidden or frozen if either of the latter two states applies to the index.\nThe API supports the standard expand_wildcards parameter as used on other index APIs.\nRelates to #53100\nRelates to elastic/kibana#64858", "createdAt": "2020-06-03T21:04:14Z", "url": "https://github.com/elastic/elasticsearch/pull/57626", "merged": true, "mergeCommit": {"oid": "9724fa9dc8c49057c9ff2c3a7d25986ff3329d53"}, "closed": true, "closedAt": "2020-06-12T11:25:17Z", "author": {"login": "danhermann"}, "timelineItems": {"totalCount": 24, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcnvNjMAH2gAyNDI3NDU1NDk3OjBlODE2NzczZjcxOWFkMDIzZTFlMDZlYmI5M2I5MTFiZjBmN2VjM2I=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcqdIXQgFqTQyOTQ5OTUyMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "0e816773f719ad023e1e06ebb93b911bf0f7ec3b", "author": {"user": {"login": "danhermann", "name": "Dan Hermann"}}, "url": "https://github.com/elastic/elasticsearch/commit/0e816773f719ad023e1e06ebb93b911bf0f7ec3b", "committedDate": "2020-06-03T20:09:28Z", "message": "resolve index abstractions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e477312f694648a37dc66c4fea83ab897bc4f070", "author": {"user": {"login": "danhermann", "name": "Dan Hermann"}}, "url": "https://github.com/elastic/elasticsearch/commit/e477312f694648a37dc66c4fea83ab897bc4f070", "committedDate": "2020-06-03T21:18:14Z", "message": "fix a couple spots that were missed in renaming the endpoint"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "27fd218eee31d0feca6073faae76620ef0edefcd", "author": {"user": {"login": "danhermann", "name": "Dan Hermann"}}, "url": "https://github.com/elastic/elasticsearch/commit/27fd218eee31d0feca6073faae76620ef0edefcd", "committedDate": "2020-06-03T21:19:48Z", "message": "one more missed spot"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8d3e6b4cfcd027db4ab92ddfa36f2a875537806c", "author": {"user": {"login": "danhermann", "name": "Dan Hermann"}}, "url": "https://github.com/elastic/elasticsearch/commit/8d3e6b4cfcd027db4ab92ddfa36f2a875537806c", "committedDate": "2020-06-04T11:14:35Z", "message": "ActionRequest instead of MasterNodeReadRequest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0c4ef6b01f6b66a83d85faef2d2155716c41b16d", "author": {"user": {"login": "danhermann", "name": "Dan Hermann"}}, "url": "https://github.com/elastic/elasticsearch/commit/0c4ef6b01f6b66a83d85faef2d2155716c41b16d", "committedDate": "2020-06-04T13:36:08Z", "message": "support remote clusters, properly serialize indicesOptions"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0NDYyODk1", "url": "https://github.com/elastic/elasticsearch/pull/57626#pullrequestreview-424462895", "createdAt": "2020-06-04T13:43:46Z", "commit": {"oid": "0c4ef6b01f6b66a83d85faef2d2155716c41b16d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxMzo0Mzo0N1rOGfGgvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxMzo0Mzo0N1rOGfGgvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI2NTcyNg==", "bodyText": "This code is largely adapted from IndicesAndAliasesResolver::resolveIndicesAndAliases. I saw no clear way to share that code.", "url": "https://github.com/elastic/elasticsearch/pull/57626#discussion_r435265726", "createdAt": "2020-06-04T13:43:47Z", "author": {"login": "danhermann"}, "path": "server/src/main/java/org/elasticsearch/action/admin/indices/resolve/ResolveIndexAction.java", "diffHunk": "@@ -0,0 +1,636 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.admin.indices.resolve;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.ActionRequest;\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.action.ActionType;\n+import org.elasticsearch.action.IndicesRequest;\n+import org.elasticsearch.action.OriginalIndices;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.HandledTransportAction;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexAbstraction;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.metadata.Metadata;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.regex.Regex;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.CountDown;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.indices.IndicesService;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.RemoteClusterAware;\n+import org.elasticsearch.transport.RemoteClusterService;\n+import org.elasticsearch.transport.TransportService;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.Spliterators;\n+import java.util.stream.StreamSupport;\n+\n+public class ResolveIndexAction extends ActionType<ResolveIndexAction.Response> {\n+\n+    public static final ResolveIndexAction INSTANCE = new ResolveIndexAction();\n+    public static final String NAME = \"indices:admin/resolve/index\";\n+\n+    private ResolveIndexAction() {\n+        super(NAME, Response::new);\n+    }\n+\n+    public static class Request extends ActionRequest implements IndicesRequest.Replaceable {\n+\n+        public static final IndicesOptions DEFAULT_INDICES_OPTIONS = IndicesOptions.strictExpandOpen();\n+\n+        private String[] names;\n+        private IndicesOptions indicesOptions = DEFAULT_INDICES_OPTIONS;\n+\n+        public Request(String[] names) {\n+            this.names = names;\n+        }\n+\n+        public Request(String[] names, IndicesOptions indicesOptions) {\n+            this.names = names;\n+            this.indicesOptions = indicesOptions;\n+        }\n+\n+        @Override\n+        public ActionRequestValidationException validate() {\n+            return null;\n+        }\n+\n+        public Request(StreamInput in) throws IOException {\n+            super(in);\n+            this.names = in.readStringArray();\n+            this.indicesOptions = IndicesOptions.readIndicesOptions(in);\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            super.writeTo(out);\n+            out.writeStringArray(names);\n+            indicesOptions.writeIndicesOptions(out);\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            ResolveIndexAction.Request request = (ResolveIndexAction.Request) o;\n+            return Arrays.equals(names, request.names);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash((Object[]) names);\n+        }\n+\n+        @Override\n+        public String[] indices() {\n+            return names;\n+        }\n+\n+        @Override\n+        public IndicesOptions indicesOptions() {\n+            return indicesOptions;\n+        }\n+\n+        @Override\n+        public IndicesRequest indices(String... indices) {\n+            this.names = indices;\n+            return this;\n+        }\n+    }\n+\n+    public static class ResolvedIndexAbstraction {\n+\n+        protected static final ParseField NAME_FIELD = new ParseField(\"name\");\n+\n+        private String name;\n+\n+        ResolvedIndexAbstraction() {}\n+\n+        ResolvedIndexAbstraction(String name) {\n+            this.name = name;\n+        }\n+\n+        protected void setName(String name) {\n+            this.name = name;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+    }\n+\n+    public static class ResolvedIndex extends ResolvedIndexAbstraction implements Writeable, ToXContentObject {\n+\n+        private static final ParseField ALIASES_FIELD = new ParseField(\"aliases\");\n+        private static final ParseField ATTRIBUTES_FIELD = new ParseField(\"attributes\");\n+        private static final ParseField DATA_STREAM_FIELD = new ParseField(\"data_stream\");\n+\n+        private final String[] aliases;\n+        private final String[] attributes;\n+        private final String dataStream;\n+\n+        ResolvedIndex(StreamInput in) throws IOException {\n+            setName(in.readString());\n+            this.aliases = in.readStringArray();\n+            this.attributes = in.readStringArray();\n+            this.dataStream = in.readOptionalString();\n+        }\n+\n+        ResolvedIndex(String name, String[] aliases, String[] attributes, @Nullable String dataStream) {\n+            super(name);\n+            this.aliases = aliases;\n+            this.attributes = attributes;\n+            this.dataStream = dataStream;\n+        }\n+\n+        public ResolvedIndex copy(String newName) {\n+            return new ResolvedIndex(newName, aliases, attributes, dataStream);\n+        }\n+\n+        public String[] getAliases() {\n+            return aliases;\n+        }\n+\n+        public String getDataStream() {\n+            return dataStream;\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            out.writeString(getName());\n+            out.writeStringArray(aliases);\n+            out.writeStringArray(attributes);\n+            out.writeOptionalString(dataStream);\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+            builder.startObject();\n+            builder.field(NAME_FIELD.getPreferredName(), getName());\n+            if (aliases.length > 0) {\n+                builder.array(ALIASES_FIELD.getPreferredName(), aliases);\n+            }\n+            builder.array(ATTRIBUTES_FIELD.getPreferredName(), attributes);\n+            if (Strings.isNullOrEmpty(dataStream) == false) {\n+                builder.field(DATA_STREAM_FIELD.getPreferredName(), dataStream);\n+            }\n+            builder.endObject();\n+            return builder;\n+        }\n+    }\n+\n+    public static class ResolvedAlias extends ResolvedIndexAbstraction implements Writeable, ToXContentObject {\n+\n+        private static final ParseField INDICES_FIELD = new ParseField(\"indices\");\n+\n+        private final String[] indices;\n+\n+        ResolvedAlias(StreamInput in) throws IOException {\n+            setName(in.readString());\n+            this.indices = in.readStringArray();\n+        }\n+\n+        ResolvedAlias(String name, String[] indices) {\n+            super(name);\n+            this.indices = indices;\n+        }\n+\n+        public ResolvedAlias copy(String newName) {\n+            return new ResolvedAlias(newName, indices);\n+        }\n+\n+        public String[] getIndices() {\n+            return indices;\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            out.writeString(getName());\n+            out.writeStringArray(indices);\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+            builder.startObject();\n+            builder.field(NAME_FIELD.getPreferredName(), getName());\n+            if (indices.length > 0) {\n+                builder.array(INDICES_FIELD.getPreferredName(), indices);\n+            }\n+            builder.endObject();\n+            return builder;\n+        }\n+    }\n+\n+    public static class ResolvedDataStream extends ResolvedIndexAbstraction implements Writeable, ToXContentObject {\n+\n+        private static final ParseField BACKING_INDICES_FIELD = new ParseField(\"backing_indices\");\n+        private static final ParseField TIMESTAMP_FIELD = new ParseField(\"timestamp_field\");\n+\n+        private final String[] backingIndices;\n+        private final String timestampField;\n+\n+        ResolvedDataStream(StreamInput in) throws IOException {\n+            setName(in.readString());\n+            this.backingIndices = in.readStringArray();\n+            this.timestampField = in.readString();\n+        }\n+\n+        ResolvedDataStream(String name, String[] backingIndices, String timestampField) {\n+            super(name);\n+            this.backingIndices = backingIndices;\n+            this.timestampField = timestampField;\n+        }\n+\n+        public ResolvedDataStream copy(String newName) {\n+            return new ResolvedDataStream(newName, backingIndices, timestampField);\n+        }\n+\n+        public String[] getBackingIndices() {\n+            return backingIndices;\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            out.writeString(getName());\n+            out.writeStringArray(backingIndices);\n+            out.writeString(timestampField);\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+            builder.startObject();\n+            builder.field(NAME_FIELD.getPreferredName(), getName());\n+            builder.array(BACKING_INDICES_FIELD.getPreferredName(), backingIndices);\n+            builder.field(TIMESTAMP_FIELD.getPreferredName(), timestampField);\n+            builder.endObject();\n+            return builder;\n+        }\n+    }\n+\n+    public static class Response extends ActionResponse implements ToXContentObject {\n+\n+        private static final ParseField INDICES_FIELD = new ParseField(\"indices\");\n+        private static final ParseField ALIASES_FIELD = new ParseField(\"aliases\");\n+        private static final ParseField DATA_STREAMS_FIELD = new ParseField(\"data_streams\");\n+\n+        private final List<ResolvedIndex> indices;\n+        private final List<ResolvedAlias> aliases;\n+        private final List<ResolvedDataStream> dataStreams;\n+\n+        public Response(List<ResolvedIndex> indices, List<ResolvedAlias> aliases, List<ResolvedDataStream> dataStreams) {\n+            this.indices = indices;\n+            this.aliases = aliases;\n+            this.dataStreams = dataStreams;\n+        }\n+\n+        public Response(StreamInput in) throws IOException {\n+            this.indices = new ArrayList<>();\n+            int count = in.readVInt();\n+            for (int k = 0; k < count; k++) {\n+                indices.add(new ResolvedIndex(in));\n+            }\n+            this.aliases = new ArrayList<>();\n+            count = in.readVInt();\n+            for (int k = 0; k < count; k++) {\n+                aliases.add(new ResolvedAlias(in));\n+            }\n+            this.dataStreams = new ArrayList<>();\n+            count = in.readVInt();\n+            for (int k = 0; k < count; k++) {\n+                dataStreams.add(new ResolvedDataStream(in));\n+            }\n+        }\n+\n+        public List<ResolvedIndex> getIndices() {\n+            return indices;\n+        }\n+\n+        public List<ResolvedAlias> getAliases() {\n+            return aliases;\n+        }\n+\n+        public List<ResolvedDataStream> getDataStreams() {\n+            return dataStreams;\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            out.writeVInt(indices.size());\n+            for (ResolvedIndex index : indices) {\n+                index.writeTo(out);\n+            }\n+            out.writeVInt(aliases.size());\n+            for (ResolvedAlias alias : aliases) {\n+                alias.writeTo(out);\n+            }\n+            out.writeVInt(dataStreams.size());\n+            for (ResolvedDataStream dataStream : dataStreams) {\n+                dataStream.writeTo(out);\n+            }\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+            builder.startObject();\n+            builder.field(INDICES_FIELD.getPreferredName(), indices);\n+            builder.field(ALIASES_FIELD.getPreferredName(), aliases);\n+            builder.field(DATA_STREAMS_FIELD.getPreferredName(), dataStreams);\n+            builder.endObject();\n+            return builder;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            Response response = (Response) o;\n+            return indices.equals(response.indices) && aliases.equals(response.aliases) && dataStreams.equals(response.dataStreams);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(indices, aliases, dataStreams);\n+        }\n+    }\n+\n+    public static class TransportAction extends HandledTransportAction<Request, Response> {\n+\n+        private final ThreadPool threadPool;\n+        private final ClusterService clusterService;\n+        private final RemoteClusterService remoteClusterService;\n+        private final IndexNameExpressionResolver indexNameExpressionResolver;\n+\n+        @Inject\n+        public TransportAction(TransportService transportService, Settings settings, ClusterService clusterService, ThreadPool threadPool,\n+                               NodeClient client, ActionFilters actionFilters, IndexNameExpressionResolver indexNameExpressionResolver,\n+                               IndicesService indicesService) {\n+            super(NAME, transportService, actionFilters, ResolveIndexAction.Request::new);\n+            this.threadPool = threadPool;\n+            this.clusterService = clusterService;\n+            this.remoteClusterService = transportService.getRemoteClusterService();\n+            this.indexNameExpressionResolver = indexNameExpressionResolver;\n+        }\n+\n+        @Override\n+        protected void doExecute(Task task, Request request, final ActionListener<Response> listener) {\n+            final ClusterState clusterState = clusterService.state();\n+            final Map<String, OriginalIndices> remoteClusterIndices = remoteClusterService.groupIndices(request.indicesOptions(),\n+                request.indices());\n+            final OriginalIndices localIndices = remoteClusterIndices.remove(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY);\n+            final Metadata metadata = clusterState.metadata();\n+            List<ResolvedIndex> indices = Collections.synchronizedList(new ArrayList<>());\n+            List<ResolvedAlias> aliases = Collections.synchronizedList(new ArrayList<>());\n+            List<ResolvedDataStream> dataStreams = Collections.synchronizedList(new ArrayList<>());\n+            if (localIndices != null) {\n+                List<String> resolvedIndexAbstractions = resolveIndexAbstractions(localIndices.indices(), request.indicesOptions, metadata);\n+                SortedMap<String, IndexAbstraction> lookup = metadata.getIndicesLookup();\n+                for (String s : resolvedIndexAbstractions) {\n+                    addIndexAbstraction(s, lookup, indices, aliases, dataStreams);\n+                }\n+            }\n+\n+            if (remoteClusterIndices.size() > 0) {\n+                final int remoteRequests = remoteClusterIndices.size();\n+                final CountDown completionCounter = new CountDown(remoteRequests);\n+                final Runnable terminalHandler = () -> {\n+                    if (completionCounter.countDown()) {\n+                        listener.onResponse(new Response(indices, aliases, dataStreams));\n+                    }\n+                };\n+\n+                // make the cross-cluster calls\n+                for (Map.Entry<String, OriginalIndices> remoteIndices : remoteClusterIndices.entrySet()) {\n+                    String clusterAlias = remoteIndices.getKey();\n+                    OriginalIndices originalIndices = remoteIndices.getValue();\n+                    Client remoteClusterClient = remoteClusterService.getRemoteClusterClient(threadPool, clusterAlias);\n+                    Request remoteRequest = new Request(originalIndices.indices(), originalIndices.indicesOptions());\n+                    remoteClusterClient.admin().indices().resolveIndex(remoteRequest, ActionListener.wrap(response -> {\n+                        for (ResolvedIndex index : response.indices) {\n+                            indices.add(index.copy(RemoteClusterAware.buildRemoteIndexName(clusterAlias, index.getName())));\n+                        }\n+                        for (ResolvedAlias alias : response.aliases) {\n+                            aliases.add(alias.copy(RemoteClusterAware.buildRemoteIndexName(clusterAlias, alias.getName())));\n+                        }\n+                        for (ResolvedDataStream dataStream : response.dataStreams) {\n+                            dataStreams.add(dataStream.copy(RemoteClusterAware.buildRemoteIndexName(clusterAlias, dataStream.getName())));\n+                        }\n+                        terminalHandler.run();\n+                    }, failure -> terminalHandler.run()));\n+                }\n+            } else {\n+                listener.onResponse(new Response(indices, aliases, dataStreams));\n+            }\n+        }\n+\n+        private List<String> resolveIndexAbstractions(String[] indices, IndicesOptions indicesOptions, Metadata metadata) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0c4ef6b01f6b66a83d85faef2d2155716c41b16d"}, "originalPosition": 470}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ed222d8e5e525d63d042abb66f6e455945854d8c", "author": {"user": {"login": "danhermann", "name": "Dan Hermann"}}, "url": "https://github.com/elastic/elasticsearch/commit/ed222d8e5e525d63d042abb66f6e455945854d8c", "committedDate": "2020-06-04T15:52:51Z", "message": "sort response, minor cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6eb916cd2b15bafc138ffaa23abf0a3b91857583", "author": {"user": {"login": "danhermann", "name": "Dan Hermann"}}, "url": "https://github.com/elastic/elasticsearch/commit/6eb916cd2b15bafc138ffaa23abf0a3b91857583", "committedDate": "2020-06-07T21:37:11Z", "message": "fix test stub"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c35fe8940f28f66efe3aa5f14aa3309076a522f", "author": {"user": {"login": "elasticmachine", "name": "Elastic Machine"}}, "url": "https://github.com/elastic/elasticsearch/commit/6c35fe8940f28f66efe3aa5f14aa3309076a522f", "committedDate": "2020-06-07T21:51:37Z", "message": "Merge branch 'master' into resolve_index_abstraction"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c68e24ef2ecd027dab39c1c2ad05d8f7594ce598", "author": {"user": {"login": "danhermann", "name": "Dan Hermann"}}, "url": "https://github.com/elastic/elasticsearch/commit/c68e24ef2ecd027dab39c1c2ad05d8f7594ce598", "committedDate": "2020-06-08T12:28:05Z", "message": "test wip"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4eb83c450f460057fe61333790e9f6d83a6f0f49", "author": {"user": {"login": "elasticmachine", "name": "Elastic Machine"}}, "url": "https://github.com/elastic/elasticsearch/commit/4eb83c450f460057fe61333790e9f6d83a6f0f49", "committedDate": "2020-06-08T12:53:49Z", "message": "Merge branch 'master' into resolve_index_abstraction"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7067ba4c5ffdfad2cd0a9f221bbf847b72097671", "author": {"user": {"login": "elasticmachine", "name": "Elastic Machine"}}, "url": "https://github.com/elastic/elasticsearch/commit/7067ba4c5ffdfad2cd0a9f221bbf847b72097671", "committedDate": "2020-06-08T13:43:42Z", "message": "Merge branch 'master' into resolve_index_abstraction"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "828bdae85b8bf976dc40b8aa6c565a45c45bc182", "author": {"user": {"login": "danhermann", "name": "Dan Hermann"}}, "url": "https://github.com/elastic/elasticsearch/commit/828bdae85b8bf976dc40b8aa6c565a45c45bc182", "committedDate": "2020-06-08T13:59:10Z", "message": "completed REST test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a2070e1c6a2503d809019d27b297e69efe4a70e7", "author": {"user": {"login": "danhermann", "name": "Dan Hermann"}}, "url": "https://github.com/elastic/elasticsearch/commit/a2070e1c6a2503d809019d27b297e69efe4a70e7", "committedDate": "2020-06-08T14:32:16Z", "message": "add remote cluster REST test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c2e25ab55667eae7c06305c8117433fbe95db068", "author": {"user": {"login": "danhermann", "name": "Dan Hermann"}}, "url": "https://github.com/elastic/elasticsearch/commit/c2e25ab55667eae7c06305c8117433fbe95db068", "committedDate": "2020-06-08T16:07:29Z", "message": "remote cluster test work"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "88321670293ad49e1cc9fd0bed808832c51c2d67", "author": {"user": {"login": "danhermann", "name": "Dan Hermann"}}, "url": "https://github.com/elastic/elasticsearch/commit/88321670293ad49e1cc9fd0bed808832c51c2d67", "committedDate": "2020-06-08T18:53:38Z", "message": "update remote cluster REST test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7c10665993e26eca3a46558cdb1105ae50609899", "author": {"user": {"login": "danhermann", "name": "Dan Hermann"}}, "url": "https://github.com/elastic/elasticsearch/commit/7c10665993e26eca3a46558cdb1105ae50609899", "committedDate": "2020-06-09T11:47:56Z", "message": "test retrieval of remote items only"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "102fd78ff00a23d726e9699482ef70d08a16437c", "author": {"user": {"login": "elasticmachine", "name": "Elastic Machine"}}, "url": "https://github.com/elastic/elasticsearch/commit/102fd78ff00a23d726e9699482ef70d08a16437c", "committedDate": "2020-06-09T12:40:13Z", "message": "Merge branch 'master' into resolve_index_abstraction"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3NzM3MDYx", "url": "https://github.com/elastic/elasticsearch/pull/57626#pullrequestreview-427737061", "createdAt": "2020-06-10T06:11:47Z", "commit": {"oid": "102fd78ff00a23d726e9699482ef70d08a16437c"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwNjoxMTo0N1rOGhmKXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwNjoxMjo1OVrOGhmL8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg4MTQzNw==", "bodyText": "maybe add a parsing unit test for the response class? (extending AbstractSerializingTestCase and defining a parser in the test)", "url": "https://github.com/elastic/elasticsearch/pull/57626#discussion_r437881437", "createdAt": "2020-06-10T06:11:47Z", "author": {"login": "martijnvg"}, "path": "server/src/main/java/org/elasticsearch/action/admin/indices/resolve/ResolveIndexAction.java", "diffHunk": "@@ -0,0 +1,653 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.admin.indices.resolve;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.ActionRequest;\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.action.ActionType;\n+import org.elasticsearch.action.IndicesRequest;\n+import org.elasticsearch.action.OriginalIndices;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.HandledTransportAction;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexAbstraction;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.metadata.Metadata;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.regex.Regex;\n+import org.elasticsearch.common.util.concurrent.CountDown;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.RemoteClusterAware;\n+import org.elasticsearch.transport.RemoteClusterService;\n+import org.elasticsearch.transport.TransportService;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.Spliterators;\n+import java.util.TreeMap;\n+import java.util.stream.StreamSupport;\n+\n+public class ResolveIndexAction extends ActionType<ResolveIndexAction.Response> {\n+\n+    public static final ResolveIndexAction INSTANCE = new ResolveIndexAction();\n+    public static final String NAME = \"indices:admin/resolve/index\";\n+\n+    private ResolveIndexAction() {\n+        super(NAME, Response::new);\n+    }\n+\n+    public static class Request extends ActionRequest implements IndicesRequest.Replaceable {\n+\n+        public static final IndicesOptions DEFAULT_INDICES_OPTIONS = IndicesOptions.strictExpandOpen();\n+\n+        private String[] names;\n+        private IndicesOptions indicesOptions = DEFAULT_INDICES_OPTIONS;\n+\n+        public Request(String[] names) {\n+            this.names = names;\n+        }\n+\n+        public Request(String[] names, IndicesOptions indicesOptions) {\n+            this.names = names;\n+            this.indicesOptions = indicesOptions;\n+        }\n+\n+        @Override\n+        public ActionRequestValidationException validate() {\n+            return null;\n+        }\n+\n+        public Request(StreamInput in) throws IOException {\n+            super(in);\n+            this.names = in.readStringArray();\n+            this.indicesOptions = IndicesOptions.readIndicesOptions(in);\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            super.writeTo(out);\n+            out.writeStringArray(names);\n+            indicesOptions.writeIndicesOptions(out);\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            ResolveIndexAction.Request request = (ResolveIndexAction.Request) o;\n+            return Arrays.equals(names, request.names);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash((Object[]) names);\n+        }\n+\n+        @Override\n+        public String[] indices() {\n+            return names;\n+        }\n+\n+        @Override\n+        public IndicesOptions indicesOptions() {\n+            return indicesOptions;\n+        }\n+\n+        @Override\n+        public IndicesRequest indices(String... indices) {\n+            this.names = indices;\n+            return this;\n+        }\n+    }\n+\n+    public static class ResolvedIndexAbstraction {\n+\n+        protected static final ParseField NAME_FIELD = new ParseField(\"name\");\n+\n+        private String name;\n+\n+        ResolvedIndexAbstraction() {}\n+\n+        ResolvedIndexAbstraction(String name) {\n+            this.name = name;\n+        }\n+\n+        protected void setName(String name) {\n+            this.name = name;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+    }\n+\n+    public static class ResolvedIndex extends ResolvedIndexAbstraction implements Writeable, ToXContentObject {\n+\n+        private static final ParseField ALIASES_FIELD = new ParseField(\"aliases\");\n+        private static final ParseField ATTRIBUTES_FIELD = new ParseField(\"attributes\");\n+        private static final ParseField DATA_STREAM_FIELD = new ParseField(\"data_stream\");\n+\n+        private final String[] aliases;\n+        private final String[] attributes;\n+        private final String dataStream;\n+\n+        ResolvedIndex(StreamInput in) throws IOException {\n+            setName(in.readString());\n+            this.aliases = in.readStringArray();\n+            this.attributes = in.readStringArray();\n+            this.dataStream = in.readOptionalString();\n+        }\n+\n+        ResolvedIndex(String name, String[] aliases, String[] attributes, @Nullable String dataStream) {\n+            super(name);\n+            this.aliases = aliases;\n+            this.attributes = attributes;\n+            this.dataStream = dataStream;\n+        }\n+\n+        public ResolvedIndex copy(String newName) {\n+            return new ResolvedIndex(newName, aliases, attributes, dataStream);\n+        }\n+\n+        public String[] getAliases() {\n+            return aliases;\n+        }\n+\n+        public String getDataStream() {\n+            return dataStream;\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            out.writeString(getName());\n+            out.writeStringArray(aliases);\n+            out.writeStringArray(attributes);\n+            out.writeOptionalString(dataStream);\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+            builder.startObject();\n+            builder.field(NAME_FIELD.getPreferredName(), getName());\n+            if (aliases.length > 0) {\n+                builder.array(ALIASES_FIELD.getPreferredName(), aliases);\n+            }\n+            builder.array(ATTRIBUTES_FIELD.getPreferredName(), attributes);\n+            if (Strings.isNullOrEmpty(dataStream) == false) {\n+                builder.field(DATA_STREAM_FIELD.getPreferredName(), dataStream);\n+            }\n+            builder.endObject();\n+            return builder;\n+        }\n+    }\n+\n+    public static class ResolvedAlias extends ResolvedIndexAbstraction implements Writeable, ToXContentObject {\n+\n+        private static final ParseField INDICES_FIELD = new ParseField(\"indices\");\n+\n+        private final String[] indices;\n+\n+        ResolvedAlias(StreamInput in) throws IOException {\n+            setName(in.readString());\n+            this.indices = in.readStringArray();\n+        }\n+\n+        ResolvedAlias(String name, String[] indices) {\n+            super(name);\n+            this.indices = indices;\n+        }\n+\n+        public ResolvedAlias copy(String newName) {\n+            return new ResolvedAlias(newName, indices);\n+        }\n+\n+        public String[] getIndices() {\n+            return indices;\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            out.writeString(getName());\n+            out.writeStringArray(indices);\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+            builder.startObject();\n+            builder.field(NAME_FIELD.getPreferredName(), getName());\n+            if (indices.length > 0) {\n+                builder.array(INDICES_FIELD.getPreferredName(), indices);\n+            }\n+            builder.endObject();\n+            return builder;\n+        }\n+    }\n+\n+    public static class ResolvedDataStream extends ResolvedIndexAbstraction implements Writeable, ToXContentObject {\n+\n+        private static final ParseField BACKING_INDICES_FIELD = new ParseField(\"backing_indices\");\n+        private static final ParseField TIMESTAMP_FIELD = new ParseField(\"timestamp_field\");\n+\n+        private final String[] backingIndices;\n+        private final String timestampField;\n+\n+        ResolvedDataStream(StreamInput in) throws IOException {\n+            setName(in.readString());\n+            this.backingIndices = in.readStringArray();\n+            this.timestampField = in.readString();\n+        }\n+\n+        ResolvedDataStream(String name, String[] backingIndices, String timestampField) {\n+            super(name);\n+            this.backingIndices = backingIndices;\n+            this.timestampField = timestampField;\n+        }\n+\n+        public ResolvedDataStream copy(String newName) {\n+            return new ResolvedDataStream(newName, backingIndices, timestampField);\n+        }\n+\n+        public String[] getBackingIndices() {\n+            return backingIndices;\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            out.writeString(getName());\n+            out.writeStringArray(backingIndices);\n+            out.writeString(timestampField);\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+            builder.startObject();\n+            builder.field(NAME_FIELD.getPreferredName(), getName());\n+            builder.array(BACKING_INDICES_FIELD.getPreferredName(), backingIndices);\n+            builder.field(TIMESTAMP_FIELD.getPreferredName(), timestampField);\n+            builder.endObject();\n+            return builder;\n+        }\n+    }\n+\n+    public static class Response extends ActionResponse implements ToXContentObject {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "102fd78ff00a23d726e9699482ef70d08a16437c"}, "originalPosition": 314}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg4MTg0MA==", "bodyText": "Maybe extract the logic here in a static method, so that unit tests can be written?", "url": "https://github.com/elastic/elasticsearch/pull/57626#discussion_r437881840", "createdAt": "2020-06-10T06:12:59Z", "author": {"login": "martijnvg"}, "path": "server/src/main/java/org/elasticsearch/action/admin/indices/resolve/ResolveIndexAction.java", "diffHunk": "@@ -0,0 +1,653 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.action.admin.indices.resolve;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.ActionRequest;\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.action.ActionType;\n+import org.elasticsearch.action.IndicesRequest;\n+import org.elasticsearch.action.OriginalIndices;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.HandledTransportAction;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexAbstraction;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.metadata.Metadata;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.regex.Regex;\n+import org.elasticsearch.common.util.concurrent.CountDown;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.RemoteClusterAware;\n+import org.elasticsearch.transport.RemoteClusterService;\n+import org.elasticsearch.transport.TransportService;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.Spliterators;\n+import java.util.TreeMap;\n+import java.util.stream.StreamSupport;\n+\n+public class ResolveIndexAction extends ActionType<ResolveIndexAction.Response> {\n+\n+    public static final ResolveIndexAction INSTANCE = new ResolveIndexAction();\n+    public static final String NAME = \"indices:admin/resolve/index\";\n+\n+    private ResolveIndexAction() {\n+        super(NAME, Response::new);\n+    }\n+\n+    public static class Request extends ActionRequest implements IndicesRequest.Replaceable {\n+\n+        public static final IndicesOptions DEFAULT_INDICES_OPTIONS = IndicesOptions.strictExpandOpen();\n+\n+        private String[] names;\n+        private IndicesOptions indicesOptions = DEFAULT_INDICES_OPTIONS;\n+\n+        public Request(String[] names) {\n+            this.names = names;\n+        }\n+\n+        public Request(String[] names, IndicesOptions indicesOptions) {\n+            this.names = names;\n+            this.indicesOptions = indicesOptions;\n+        }\n+\n+        @Override\n+        public ActionRequestValidationException validate() {\n+            return null;\n+        }\n+\n+        public Request(StreamInput in) throws IOException {\n+            super(in);\n+            this.names = in.readStringArray();\n+            this.indicesOptions = IndicesOptions.readIndicesOptions(in);\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            super.writeTo(out);\n+            out.writeStringArray(names);\n+            indicesOptions.writeIndicesOptions(out);\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            ResolveIndexAction.Request request = (ResolveIndexAction.Request) o;\n+            return Arrays.equals(names, request.names);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash((Object[]) names);\n+        }\n+\n+        @Override\n+        public String[] indices() {\n+            return names;\n+        }\n+\n+        @Override\n+        public IndicesOptions indicesOptions() {\n+            return indicesOptions;\n+        }\n+\n+        @Override\n+        public IndicesRequest indices(String... indices) {\n+            this.names = indices;\n+            return this;\n+        }\n+    }\n+\n+    public static class ResolvedIndexAbstraction {\n+\n+        protected static final ParseField NAME_FIELD = new ParseField(\"name\");\n+\n+        private String name;\n+\n+        ResolvedIndexAbstraction() {}\n+\n+        ResolvedIndexAbstraction(String name) {\n+            this.name = name;\n+        }\n+\n+        protected void setName(String name) {\n+            this.name = name;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+    }\n+\n+    public static class ResolvedIndex extends ResolvedIndexAbstraction implements Writeable, ToXContentObject {\n+\n+        private static final ParseField ALIASES_FIELD = new ParseField(\"aliases\");\n+        private static final ParseField ATTRIBUTES_FIELD = new ParseField(\"attributes\");\n+        private static final ParseField DATA_STREAM_FIELD = new ParseField(\"data_stream\");\n+\n+        private final String[] aliases;\n+        private final String[] attributes;\n+        private final String dataStream;\n+\n+        ResolvedIndex(StreamInput in) throws IOException {\n+            setName(in.readString());\n+            this.aliases = in.readStringArray();\n+            this.attributes = in.readStringArray();\n+            this.dataStream = in.readOptionalString();\n+        }\n+\n+        ResolvedIndex(String name, String[] aliases, String[] attributes, @Nullable String dataStream) {\n+            super(name);\n+            this.aliases = aliases;\n+            this.attributes = attributes;\n+            this.dataStream = dataStream;\n+        }\n+\n+        public ResolvedIndex copy(String newName) {\n+            return new ResolvedIndex(newName, aliases, attributes, dataStream);\n+        }\n+\n+        public String[] getAliases() {\n+            return aliases;\n+        }\n+\n+        public String getDataStream() {\n+            return dataStream;\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            out.writeString(getName());\n+            out.writeStringArray(aliases);\n+            out.writeStringArray(attributes);\n+            out.writeOptionalString(dataStream);\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+            builder.startObject();\n+            builder.field(NAME_FIELD.getPreferredName(), getName());\n+            if (aliases.length > 0) {\n+                builder.array(ALIASES_FIELD.getPreferredName(), aliases);\n+            }\n+            builder.array(ATTRIBUTES_FIELD.getPreferredName(), attributes);\n+            if (Strings.isNullOrEmpty(dataStream) == false) {\n+                builder.field(DATA_STREAM_FIELD.getPreferredName(), dataStream);\n+            }\n+            builder.endObject();\n+            return builder;\n+        }\n+    }\n+\n+    public static class ResolvedAlias extends ResolvedIndexAbstraction implements Writeable, ToXContentObject {\n+\n+        private static final ParseField INDICES_FIELD = new ParseField(\"indices\");\n+\n+        private final String[] indices;\n+\n+        ResolvedAlias(StreamInput in) throws IOException {\n+            setName(in.readString());\n+            this.indices = in.readStringArray();\n+        }\n+\n+        ResolvedAlias(String name, String[] indices) {\n+            super(name);\n+            this.indices = indices;\n+        }\n+\n+        public ResolvedAlias copy(String newName) {\n+            return new ResolvedAlias(newName, indices);\n+        }\n+\n+        public String[] getIndices() {\n+            return indices;\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            out.writeString(getName());\n+            out.writeStringArray(indices);\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+            builder.startObject();\n+            builder.field(NAME_FIELD.getPreferredName(), getName());\n+            if (indices.length > 0) {\n+                builder.array(INDICES_FIELD.getPreferredName(), indices);\n+            }\n+            builder.endObject();\n+            return builder;\n+        }\n+    }\n+\n+    public static class ResolvedDataStream extends ResolvedIndexAbstraction implements Writeable, ToXContentObject {\n+\n+        private static final ParseField BACKING_INDICES_FIELD = new ParseField(\"backing_indices\");\n+        private static final ParseField TIMESTAMP_FIELD = new ParseField(\"timestamp_field\");\n+\n+        private final String[] backingIndices;\n+        private final String timestampField;\n+\n+        ResolvedDataStream(StreamInput in) throws IOException {\n+            setName(in.readString());\n+            this.backingIndices = in.readStringArray();\n+            this.timestampField = in.readString();\n+        }\n+\n+        ResolvedDataStream(String name, String[] backingIndices, String timestampField) {\n+            super(name);\n+            this.backingIndices = backingIndices;\n+            this.timestampField = timestampField;\n+        }\n+\n+        public ResolvedDataStream copy(String newName) {\n+            return new ResolvedDataStream(newName, backingIndices, timestampField);\n+        }\n+\n+        public String[] getBackingIndices() {\n+            return backingIndices;\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            out.writeString(getName());\n+            out.writeStringArray(backingIndices);\n+            out.writeString(timestampField);\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+            builder.startObject();\n+            builder.field(NAME_FIELD.getPreferredName(), getName());\n+            builder.array(BACKING_INDICES_FIELD.getPreferredName(), backingIndices);\n+            builder.field(TIMESTAMP_FIELD.getPreferredName(), timestampField);\n+            builder.endObject();\n+            return builder;\n+        }\n+    }\n+\n+    public static class Response extends ActionResponse implements ToXContentObject {\n+\n+        private static final ParseField INDICES_FIELD = new ParseField(\"indices\");\n+        private static final ParseField ALIASES_FIELD = new ParseField(\"aliases\");\n+        private static final ParseField DATA_STREAMS_FIELD = new ParseField(\"data_streams\");\n+\n+        private final List<ResolvedIndex> indices;\n+        private final List<ResolvedAlias> aliases;\n+        private final List<ResolvedDataStream> dataStreams;\n+\n+        public Response(List<ResolvedIndex> indices, List<ResolvedAlias> aliases, List<ResolvedDataStream> dataStreams) {\n+            this.indices = indices;\n+            this.aliases = aliases;\n+            this.dataStreams = dataStreams;\n+        }\n+\n+        public Response(StreamInput in) throws IOException {\n+            this.indices = new ArrayList<>();\n+            int count = in.readVInt();\n+            for (int k = 0; k < count; k++) {\n+                indices.add(new ResolvedIndex(in));\n+            }\n+            this.aliases = new ArrayList<>();\n+            count = in.readVInt();\n+            for (int k = 0; k < count; k++) {\n+                aliases.add(new ResolvedAlias(in));\n+            }\n+            this.dataStreams = new ArrayList<>();\n+            count = in.readVInt();\n+            for (int k = 0; k < count; k++) {\n+                dataStreams.add(new ResolvedDataStream(in));\n+            }\n+        }\n+\n+        public List<ResolvedIndex> getIndices() {\n+            return indices;\n+        }\n+\n+        public List<ResolvedAlias> getAliases() {\n+            return aliases;\n+        }\n+\n+        public List<ResolvedDataStream> getDataStreams() {\n+            return dataStreams;\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            out.writeVInt(indices.size());\n+            for (ResolvedIndex index : indices) {\n+                index.writeTo(out);\n+            }\n+            out.writeVInt(aliases.size());\n+            for (ResolvedAlias alias : aliases) {\n+                alias.writeTo(out);\n+            }\n+            out.writeVInt(dataStreams.size());\n+            for (ResolvedDataStream dataStream : dataStreams) {\n+                dataStream.writeTo(out);\n+            }\n+        }\n+\n+        @Override\n+        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+            builder.startObject();\n+            builder.field(INDICES_FIELD.getPreferredName(), indices);\n+            builder.field(ALIASES_FIELD.getPreferredName(), aliases);\n+            builder.field(DATA_STREAMS_FIELD.getPreferredName(), dataStreams);\n+            builder.endObject();\n+            return builder;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            Response response = (Response) o;\n+            return indices.equals(response.indices) && aliases.equals(response.aliases) && dataStreams.equals(response.dataStreams);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(indices, aliases, dataStreams);\n+        }\n+    }\n+\n+    public static class TransportAction extends HandledTransportAction<Request, Response> {\n+\n+        private final ThreadPool threadPool;\n+        private final ClusterService clusterService;\n+        private final RemoteClusterService remoteClusterService;\n+        private final IndexNameExpressionResolver indexNameExpressionResolver;\n+\n+        @Inject\n+        public TransportAction(TransportService transportService, ClusterService clusterService, ThreadPool threadPool,\n+                               ActionFilters actionFilters, IndexNameExpressionResolver indexNameExpressionResolver) {\n+            super(NAME, transportService, actionFilters, ResolveIndexAction.Request::new);\n+            this.threadPool = threadPool;\n+            this.clusterService = clusterService;\n+            this.remoteClusterService = transportService.getRemoteClusterService();\n+            this.indexNameExpressionResolver = indexNameExpressionResolver;\n+        }\n+\n+        @Override\n+        protected void doExecute(Task task, Request request, final ActionListener<Response> listener) {\n+            final ClusterState clusterState = clusterService.state();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "102fd78ff00a23d726e9699482ef70d08a16437c"}, "originalPosition": 419}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2fc51f9d0be6ee2d0930d9c7ceb5d5999297ffcd", "author": {"user": {"login": "danhermann", "name": "Dan Hermann"}}, "url": "https://github.com/elastic/elasticsearch/commit/2fc51f9d0be6ee2d0930d9c7ceb5d5999297ffcd", "committedDate": "2020-06-11T11:34:11Z", "message": "add serialization test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a5c5a90a6fe5d7efd7f50c2aa36de8a3a5fd6123", "author": {"user": {"login": "danhermann", "name": "Dan Hermann"}}, "url": "https://github.com/elastic/elasticsearch/commit/a5c5a90a6fe5d7efd7f50c2aa36de8a3a5fd6123", "committedDate": "2020-06-11T14:45:42Z", "message": "serialization test for request class"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3863d507ffc2edd471a169d1fbf811d99a7c6d01", "author": {"user": {"login": "danhermann", "name": "Dan Hermann"}}, "url": "https://github.com/elastic/elasticsearch/commit/3863d507ffc2edd471a169d1fbf811d99a7c6d01", "committedDate": "2020-06-12T01:18:43Z", "message": "finalize the unit tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "15bc4547d8beba4a0b2a9489d95b5ec1534974c0", "author": {"user": {"login": "elasticmachine", "name": "Elastic Machine"}}, "url": "https://github.com/elastic/elasticsearch/commit/15bc4547d8beba4a0b2a9489d95b5ec1534974c0", "committedDate": "2020-06-12T01:31:20Z", "message": "Merge branch 'master' into resolve_index_abstraction"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI5NDk5NTIx", "url": "https://github.com/elastic/elasticsearch/pull/57626#pullrequestreview-429499521", "createdAt": "2020-06-12T06:47:17Z", "commit": {"oid": "15bc4547d8beba4a0b2a9489d95b5ec1534974c0"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3864, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}