{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMxOTUyMTk2", "number": 57892, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNzoxNDo1NlrOED-tqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNzoxNDo1NlrOED-tqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNjA4NjgxOnYy", "diffSide": "RIGHT", "path": "modules/parent-join/src/main/java/org/elasticsearch/join/aggregations/ParentJoinAggregator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNzoxNDo1NlrOGhUcTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNjo0NzowNFrOGh9vZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzU5MTExNw==", "bodyText": "This is pretty much the algorithm that we used to use. It ain't perfect, but it gets the job done.", "url": "https://github.com/elastic/elasticsearch/pull/57892#discussion_r437591117", "createdAt": "2020-06-09T17:14:56Z", "author": {"login": "nik9000"}, "path": "modules/parent-join/src/main/java/org/elasticsearch/join/aggregations/ParentJoinAggregator.java", "diffHunk": "@@ -137,11 +138,21 @@ public int docID() {\n                 if (liveDocs != null && liveDocs.get(docId) == false) {\n                     continue;\n                 }\n-                if (globalOrdinals.advanceExact(docId)) {\n-                    int globalOrdinal = (int) globalOrdinals.nextOrd();\n-                    assert globalOrdinal != -1 && globalOrdinals.nextOrd() == SortedSetDocValues.NO_MORE_ORDS;\n-                    if (collectionStrategy.existsGlobalOrdinal(globalOrdinal)) {\n-                        collectBucket(sub, docId, 0);\n+                if (false == globalOrdinals.advanceExact(docId)) {\n+                    continue;\n+                }\n+                int globalOrdinal = (int) globalOrdinals.nextOrd();\n+                assert globalOrdinal != -1 && globalOrdinals.nextOrd() == SortedSetDocValues.NO_MORE_ORDS;\n+                /*\n+                 * Check if we contain every ordinal. It's almost certainly be\n+                 * faster to replay all the matching ordinals and filter them down\n+                 * to just those listed in ordsToCollect, but we don't have a data\n+                 * structure that maps a primitive long to a list of primitive\n+                 * longs. \n+                 */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6622a53a6098d3994a16294407b0de66c11fd2b7"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI2Nzc1MQ==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/elastic/elasticsearch/pull/57892#discussion_r438267751", "createdAt": "2020-06-10T16:47:04Z", "author": {"login": "talevy"}, "path": "modules/parent-join/src/main/java/org/elasticsearch/join/aggregations/ParentJoinAggregator.java", "diffHunk": "@@ -137,11 +138,21 @@ public int docID() {\n                 if (liveDocs != null && liveDocs.get(docId) == false) {\n                     continue;\n                 }\n-                if (globalOrdinals.advanceExact(docId)) {\n-                    int globalOrdinal = (int) globalOrdinals.nextOrd();\n-                    assert globalOrdinal != -1 && globalOrdinals.nextOrd() == SortedSetDocValues.NO_MORE_ORDS;\n-                    if (collectionStrategy.existsGlobalOrdinal(globalOrdinal)) {\n-                        collectBucket(sub, docId, 0);\n+                if (false == globalOrdinals.advanceExact(docId)) {\n+                    continue;\n+                }\n+                int globalOrdinal = (int) globalOrdinals.nextOrd();\n+                assert globalOrdinal != -1 && globalOrdinals.nextOrd() == SortedSetDocValues.NO_MORE_ORDS;\n+                /*\n+                 * Check if we contain every ordinal. It's almost certainly be\n+                 * faster to replay all the matching ordinals and filter them down\n+                 * to just those listed in ordsToCollect, but we don't have a data\n+                 * structure that maps a primitive long to a list of primitive\n+                 * longs. \n+                 */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzU5MTExNw=="}, "originalCommit": {"oid": "6622a53a6098d3994a16294407b0de66c11fd2b7"}, "originalPosition": 77}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1643, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}