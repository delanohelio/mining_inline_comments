{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgxMDQ5NDky", "number": 52918, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNToyMDo0MVrODlFfEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNToyNTo1OFrODlFoFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMjEzNzc3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/range/AbstractRangeAggregatorFactory.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNToyMDo0MVrOFxxgkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQyMDozNTozM1rOFx8tDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzczNTY5Nw==", "bodyText": "Is Boolean range a valid concept?", "url": "https://github.com/elastic/elasticsearch/pull/52918#discussion_r387735697", "createdAt": "2020-03-04T15:20:41Z", "author": {"login": "csoulios"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/range/AbstractRangeAggregatorFactory.java", "diffHunk": "@@ -42,20 +46,44 @@\n     private final InternalRange.Factory<?, ?> rangeFactory;\n     private final R[] ranges;\n     private final boolean keyed;\n+    private final String aggregationTypeName;\n \n+    public static void registerAggregators(ValuesSourceRegistry valuesSourceRegistry, String aggregationName) {\n+        valuesSourceRegistry.register(aggregationName,\n+            List.of(CoreValuesSourceType.NUMERIC, CoreValuesSourceType.DATE, CoreValuesSourceType.BOOLEAN),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1efc5e68d96bfd91fb92c7633465120e9a792701"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzkxOTExNw==", "bodyText": "That's a really good question.  I think master will let you do this, which is why I included it, but I agree it's kind of a nonsense operation. My strategy so far has been to keep these things supported for now, and after we merge have a conversation about what we want to do long term with these cases.", "url": "https://github.com/elastic/elasticsearch/pull/52918#discussion_r387919117", "createdAt": "2020-03-04T20:35:33Z", "author": {"login": "not-napoleon"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/range/AbstractRangeAggregatorFactory.java", "diffHunk": "@@ -42,20 +46,44 @@\n     private final InternalRange.Factory<?, ?> rangeFactory;\n     private final R[] ranges;\n     private final boolean keyed;\n+    private final String aggregationTypeName;\n \n+    public static void registerAggregators(ValuesSourceRegistry valuesSourceRegistry, String aggregationName) {\n+        valuesSourceRegistry.register(aggregationName,\n+            List.of(CoreValuesSourceType.NUMERIC, CoreValuesSourceType.DATE, CoreValuesSourceType.BOOLEAN),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzczNTY5Nw=="}, "originalCommit": {"oid": "1efc5e68d96bfd91fb92c7633465120e9a792701"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMjE2MDg2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/range/AbstractRangeAggregatorFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNToyNTo1OFrOFxxu-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQyMDozNTo0NFrOFx8tYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzczOTM4NA==", "bodyText": "Copy-paste nit: Exception message should read RangeAggregationSupplier, not HistogramAggregatorSupplier.", "url": "https://github.com/elastic/elasticsearch/pull/52918#discussion_r387739384", "createdAt": "2020-03-04T15:25:58Z", "author": {"login": "csoulios"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/range/AbstractRangeAggregatorFactory.java", "diffHunk": "@@ -73,13 +101,14 @@ protected Aggregator doCreateInternal(ValuesSource valuesSource,\n                                             boolean collectsFromSingleBucket,\n                                             List<PipelineAggregator> pipelineAggregators,\n                                             Map<String, Object> metaData) throws IOException {\n-        if (valuesSource instanceof Numeric == false) {\n-            throw new AggregationExecutionException(\"ValuesSource type \" + valuesSource.toString() + \"is not supported for aggregation \" +\n-            this.name());\n+\n+        AggregatorSupplier aggregatorSupplier = queryShardContext.getValuesSourceRegistry().getAggregator(config.valueSourceType(),\n+            aggregationTypeName);\n+        if (aggregatorSupplier instanceof RangeAggregationSupplier == false) {\n+            throw new AggregationExecutionException(\"Registry miss-match - expected HistogramAggregatorSupplier, found [\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1efc5e68d96bfd91fb92c7633465120e9a792701"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzkxOTIwMQ==", "bodyText": "Thanks, will fix.", "url": "https://github.com/elastic/elasticsearch/pull/52918#discussion_r387919201", "createdAt": "2020-03-04T20:35:44Z", "author": {"login": "not-napoleon"}, "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/range/AbstractRangeAggregatorFactory.java", "diffHunk": "@@ -73,13 +101,14 @@ protected Aggregator doCreateInternal(ValuesSource valuesSource,\n                                             boolean collectsFromSingleBucket,\n                                             List<PipelineAggregator> pipelineAggregators,\n                                             Map<String, Object> metaData) throws IOException {\n-        if (valuesSource instanceof Numeric == false) {\n-            throw new AggregationExecutionException(\"ValuesSource type \" + valuesSource.toString() + \"is not supported for aggregation \" +\n-            this.name());\n+\n+        AggregatorSupplier aggregatorSupplier = queryShardContext.getValuesSourceRegistry().getAggregator(config.valueSourceType(),\n+            aggregationTypeName);\n+        if (aggregatorSupplier instanceof RangeAggregationSupplier == false) {\n+            throw new AggregationExecutionException(\"Registry miss-match - expected HistogramAggregatorSupplier, found [\" +", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzczOTM4NA=="}, "originalCommit": {"oid": "1efc5e68d96bfd91fb92c7633465120e9a792701"}, "originalPosition": 86}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3711, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}