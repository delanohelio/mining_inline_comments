{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcxMDEwMTg0", "number": 61377, "title": "ILM migrate data between tiers", "bodyText": "This adds ILM support for automatically migrating the managed\nindices between data tiers.\nThis proposal makes use of a MigrateAction that is injected\n(similar to how the Unfollow action is injected) in phases that\ndon't define index allocation rules using the AllocateAction or\ndon't explicitly define the MigrateAction itself (regardless if it's\nenabled or disabled).\nRelates to #60848", "createdAt": "2020-08-20T15:49:29Z", "url": "https://github.com/elastic/elasticsearch/pull/61377", "merged": true, "mergeCommit": {"oid": "c1746afffd61048d0c12d3a77e6d8191a804ed49"}, "closed": true, "closedAt": "2020-09-17T09:56:49Z", "author": {"login": "andreidan"}, "timelineItems": {"totalCount": 49, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdAyM_ugH2gAyNDcxMDEwMTg0OmY0YTM3YTk1MTc3NjkxOTRjZjhiMjY2N2ZlZjVlMTMwYTFlYzZiYjE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdJtHAWAH2gAyNDcxMDEwMTg0OmI4Mzc3MTg1NmMzZDFlODkxNTUzOWUxZjE5NmE1Y2ZkOGVmMDE4ZDE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "f4a37a9517769194cf8b2667fef5e130a1ec6bb1", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/f4a37a9517769194cf8b2667fef5e130a1ec6bb1", "committedDate": "2020-08-20T15:46:41Z", "message": "Enable the _tier attribute as a node filter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "024a0de407f25e77870f792e3b023e8825ee0cb2", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/024a0de407f25e77870f792e3b023e8825ee0cb2", "committedDate": "2020-08-20T15:46:41Z", "message": "ILM: inject a migrate step to migrate data between data tiers"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxNzU0OTU2", "url": "https://github.com/elastic/elasticsearch/pull/61377#pullrequestreview-471754956", "createdAt": "2020-08-20T15:50:52Z", "commit": {"oid": "024a0de407f25e77870f792e3b023e8825ee0cb2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNTo1MDo1MlrOHEIHvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNTo1MDo1MlrOHEIHvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA4OTQwNQ==", "bodyText": "should we make this configurable and serializable for the step? (ie. use just the one allocation decider depending on where it is used)\nI'd say we want a fully allocated index so verifying both always is alright. What do you think?", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r474089405", "createdAt": "2020-08-20T15:50:52Z", "author": {"login": "andreidan"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/AllocationRoutedStep.java", "diffHunk": "@@ -40,8 +43,23 @@\n \n     private static final Logger logger = LogManager.getLogger(AllocationRoutedStep.class);\n \n-    private static final AllocationDeciders ALLOCATION_DECIDERS = new AllocationDeciders(Collections.singletonList(\n-            new FilterAllocationDecider(Settings.EMPTY, new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS))));\n+    private static final Set<Setting<?>> ALL_CLUSTER_SETTINGS;\n+\n+    static {\n+        Set<Setting<?>> allSettings = new HashSet<>(ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+        allSettings.add(DataTierAllocationDecider.CLUSTER_ROUTING_REQUIRE_SETTING);\n+        allSettings.add(DataTierAllocationDecider.CLUSTER_ROUTING_INCLUDE_SETTING);\n+        allSettings.add(DataTierAllocationDecider.CLUSTER_ROUTING_EXCLUDE_SETTING);\n+        ALL_CLUSTER_SETTINGS = allSettings;\n+    }\n+\n+    private static final AllocationDeciders ALLOCATION_DECIDERS = new AllocationDeciders(\n+        List.of(\n+            new FilterAllocationDecider(Settings.EMPTY, new ClusterSettings(Settings.EMPTY,\n+                ClusterSettings.BUILT_IN_CLUSTER_SETTINGS)),\n+            new DataTierAllocationDecider(new ClusterSettings(Settings.EMPTY, ALL_CLUSTER_SETTINGS))\n+        )", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "024a0de407f25e77870f792e3b023e8825ee0cb2"}, "originalPosition": 50}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxNzU1OTEz", "url": "https://github.com/elastic/elasticsearch/pull/61377#pullrequestreview-471755913", "createdAt": "2020-08-20T15:51:59Z", "commit": {"oid": "024a0de407f25e77870f792e3b023e8825ee0cb2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNTo1MjowMFrOHEIKvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNTo1MjowMFrOHEIKvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA5MDE3NQ==", "bodyText": "should we remove the possible_require and _exclude settings (which might've been set manually before) to make sure they don't invalidate the \"migrate to the next data tier\" goal?", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r474090175", "createdAt": "2020-08-20T15:52:00Z", "author": {"login": "andreidan"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/MigrateAction.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.xpack.core.ilm.Step.StepKey;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * A {@link LifecycleAction} which enables or disables the automatic migration of data between\n+ * {@link org.elasticsearch.xpack.core.DataTier}s.\n+ */\n+public class MigrateAction implements LifecycleAction {\n+    public static final String NAME = \"migrate\";\n+    public static final ParseField ENABLED_FIELD = new ParseField(\"enabled\");\n+\n+    private static final ConstructingObjectParser<MigrateAction, Void> PARSER = new ConstructingObjectParser<>(NAME,\n+        a -> new MigrateAction((boolean) a[0]));\n+\n+    static {\n+        PARSER.declareBoolean(ConstructingObjectParser.constructorArg(), ENABLED_FIELD);\n+    }\n+\n+    private final boolean enabled;\n+\n+    public static MigrateAction parse(XContentParser parser) {\n+        return PARSER.apply(parser, null);\n+    }\n+\n+    public MigrateAction(boolean enabled) {\n+        this.enabled = enabled;\n+    }\n+\n+    public MigrateAction(StreamInput in) throws IOException {\n+        this(in.readBoolean());\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        out.writeBoolean(enabled);\n+    }\n+\n+    @Override\n+    public String getWriteableName() {\n+        return NAME;\n+    }\n+\n+    public boolean isEnabled() {\n+        return enabled;\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject();\n+        builder.field(ENABLED_FIELD.getPreferredName(), enabled);\n+        builder.endObject();\n+        return builder;\n+    }\n+\n+    @Override\n+    public boolean isSafeAction() {\n+        return true;\n+    }\n+\n+    @Override\n+    public List<Step> toSteps(Client client, String phase, StepKey nextStepKey) {\n+        if (enabled) {\n+            Map<String, String> include = Map.of(\"_tier\", \"data_\" + phase);\n+            AllocateAction migrateDataAction = new AllocateAction(null, include, null, null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "024a0de407f25e77870f792e3b023e8825ee0cb2"}, "originalPosition": 83}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyMDQ0ODQ0", "url": "https://github.com/elastic/elasticsearch/pull/61377#pullrequestreview-472044844", "createdAt": "2020-08-20T23:13:17Z", "commit": {"oid": "024a0de407f25e77870f792e3b023e8825ee0cb2"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQyMzoxMzoxN1rOHEWRCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQyMzoyNTozM1rOHEWflA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMyMTE2Mw==", "bodyText": "Hmm... I actually think that we may want to split checking the allocation for the migrate action into a separate step. For example, the allocation routed step currently has a pretty generic message (Waiting for [n] shards to be allocated to nodes matching the given filters). I think if we split this into a new MigrationRouted step we could give it a much better explanation, for example, something like:\nwaiting [23m] for [3] shards to be allocated on nodes with the [data_warm] tier\nadditionally, I think we could also even throw an error to signal to the user when things were in a bad state, something like:\nexception waiting for index to be moved to the [data_cold] tier, there are currently no [data_cold] nodes in the cluster\nThen the step could be retryable (so we check every 10 minutes) and it at least gives us a way of signaling to a user (alerting on the ilm-history index for example) when they are in an irreconcilable position and need to adjust their cluster.\nWhat do you think?", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r474321163", "createdAt": "2020-08-20T23:13:17Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/AllocationRoutedStep.java", "diffHunk": "@@ -40,8 +43,23 @@\n \n     private static final Logger logger = LogManager.getLogger(AllocationRoutedStep.class);\n \n-    private static final AllocationDeciders ALLOCATION_DECIDERS = new AllocationDeciders(Collections.singletonList(\n-            new FilterAllocationDecider(Settings.EMPTY, new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS))));\n+    private static final Set<Setting<?>> ALL_CLUSTER_SETTINGS;\n+\n+    static {\n+        Set<Setting<?>> allSettings = new HashSet<>(ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+        allSettings.add(DataTierAllocationDecider.CLUSTER_ROUTING_REQUIRE_SETTING);\n+        allSettings.add(DataTierAllocationDecider.CLUSTER_ROUTING_INCLUDE_SETTING);\n+        allSettings.add(DataTierAllocationDecider.CLUSTER_ROUTING_EXCLUDE_SETTING);\n+        ALL_CLUSTER_SETTINGS = allSettings;\n+    }\n+\n+    private static final AllocationDeciders ALLOCATION_DECIDERS = new AllocationDeciders(\n+        List.of(\n+            new FilterAllocationDecider(Settings.EMPTY, new ClusterSettings(Settings.EMPTY,\n+                ClusterSettings.BUILT_IN_CLUSTER_SETTINGS)),\n+            new DataTierAllocationDecider(new ClusterSettings(Settings.EMPTY, ALL_CLUSTER_SETTINGS))\n+        )", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA4OTQwNQ=="}, "originalCommit": {"oid": "024a0de407f25e77870f792e3b023e8825ee0cb2"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMyMTM2MQ==", "bodyText": "enabled should be true by default I think?", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r474321361", "createdAt": "2020-08-20T23:13:54Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/MigrateAction.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.xpack.core.ilm.Step.StepKey;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * A {@link LifecycleAction} which enables or disables the automatic migration of data between\n+ * {@link org.elasticsearch.xpack.core.DataTier}s.\n+ */\n+public class MigrateAction implements LifecycleAction {\n+    public static final String NAME = \"migrate\";\n+    public static final ParseField ENABLED_FIELD = new ParseField(\"enabled\");\n+\n+    private static final ConstructingObjectParser<MigrateAction, Void> PARSER = new ConstructingObjectParser<>(NAME,\n+        a -> new MigrateAction((boolean) a[0]));\n+\n+    static {\n+        PARSER.declareBoolean(ConstructingObjectParser.constructorArg(), ENABLED_FIELD);\n+    }\n+\n+    private final boolean enabled;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "024a0de407f25e77870f792e3b023e8825ee0cb2"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMyMTUyOQ==", "bodyText": "I think we could use optionalConstructorArg here, so a user could specify \"migrate\": {} if they wanted the default (which would be enabled)", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r474321529", "createdAt": "2020-08-20T23:14:32Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/MigrateAction.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.xpack.core.ilm.Step.StepKey;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * A {@link LifecycleAction} which enables or disables the automatic migration of data between\n+ * {@link org.elasticsearch.xpack.core.DataTier}s.\n+ */\n+public class MigrateAction implements LifecycleAction {\n+    public static final String NAME = \"migrate\";\n+    public static final ParseField ENABLED_FIELD = new ParseField(\"enabled\");\n+\n+    private static final ConstructingObjectParser<MigrateAction, Void> PARSER = new ConstructingObjectParser<>(NAME,\n+        a -> new MigrateAction((boolean) a[0]));\n+\n+    static {\n+        PARSER.declareBoolean(ConstructingObjectParser.constructorArg(), ENABLED_FIELD);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "024a0de407f25e77870f792e3b023e8825ee0cb2"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMyMjE3MA==", "bodyText": "That's a good question, I'm not sure we'd want to piecemeal remove all of them, because they could be something for an additional attribute that we want to preserve between phases.\nI will have to think on it a bit, it also makes me wonder whether we should make it configurable whether all other index-level allocation filtering settings are removed/preserved when doing the migration.", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r474322170", "createdAt": "2020-08-20T23:16:34Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/MigrateAction.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.xpack.core.ilm.Step.StepKey;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * A {@link LifecycleAction} which enables or disables the automatic migration of data between\n+ * {@link org.elasticsearch.xpack.core.DataTier}s.\n+ */\n+public class MigrateAction implements LifecycleAction {\n+    public static final String NAME = \"migrate\";\n+    public static final ParseField ENABLED_FIELD = new ParseField(\"enabled\");\n+\n+    private static final ConstructingObjectParser<MigrateAction, Void> PARSER = new ConstructingObjectParser<>(NAME,\n+        a -> new MigrateAction((boolean) a[0]));\n+\n+    static {\n+        PARSER.declareBoolean(ConstructingObjectParser.constructorArg(), ENABLED_FIELD);\n+    }\n+\n+    private final boolean enabled;\n+\n+    public static MigrateAction parse(XContentParser parser) {\n+        return PARSER.apply(parser, null);\n+    }\n+\n+    public MigrateAction(boolean enabled) {\n+        this.enabled = enabled;\n+    }\n+\n+    public MigrateAction(StreamInput in) throws IOException {\n+        this(in.readBoolean());\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        out.writeBoolean(enabled);\n+    }\n+\n+    @Override\n+    public String getWriteableName() {\n+        return NAME;\n+    }\n+\n+    public boolean isEnabled() {\n+        return enabled;\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject();\n+        builder.field(ENABLED_FIELD.getPreferredName(), enabled);\n+        builder.endObject();\n+        return builder;\n+    }\n+\n+    @Override\n+    public boolean isSafeAction() {\n+        return true;\n+    }\n+\n+    @Override\n+    public List<Step> toSteps(Client client, String phase, StepKey nextStepKey) {\n+        if (enabled) {\n+            Map<String, String> include = Map.of(\"_tier\", \"data_\" + phase);\n+            AllocateAction migrateDataAction = new AllocateAction(null, include, null, null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA5MDE3NQ=="}, "originalCommit": {"oid": "024a0de407f25e77870f792e3b023e8825ee0cb2"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMyMjU1NA==", "bodyText": "Can you add a sanity assert that the value in this map is always one of the DataTier.DATA_(HOT|WARM|COLD|FROZEN) values? (in case those names are changed)", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r474322554", "createdAt": "2020-08-20T23:17:54Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/MigrateAction.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.xpack.core.ilm.Step.StepKey;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * A {@link LifecycleAction} which enables or disables the automatic migration of data between\n+ * {@link org.elasticsearch.xpack.core.DataTier}s.\n+ */\n+public class MigrateAction implements LifecycleAction {\n+    public static final String NAME = \"migrate\";\n+    public static final ParseField ENABLED_FIELD = new ParseField(\"enabled\");\n+\n+    private static final ConstructingObjectParser<MigrateAction, Void> PARSER = new ConstructingObjectParser<>(NAME,\n+        a -> new MigrateAction((boolean) a[0]));\n+\n+    static {\n+        PARSER.declareBoolean(ConstructingObjectParser.constructorArg(), ENABLED_FIELD);\n+    }\n+\n+    private final boolean enabled;\n+\n+    public static MigrateAction parse(XContentParser parser) {\n+        return PARSER.apply(parser, null);\n+    }\n+\n+    public MigrateAction(boolean enabled) {\n+        this.enabled = enabled;\n+    }\n+\n+    public MigrateAction(StreamInput in) throws IOException {\n+        this(in.readBoolean());\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        out.writeBoolean(enabled);\n+    }\n+\n+    @Override\n+    public String getWriteableName() {\n+        return NAME;\n+    }\n+\n+    public boolean isEnabled() {\n+        return enabled;\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject();\n+        builder.field(ENABLED_FIELD.getPreferredName(), enabled);\n+        builder.endObject();\n+        return builder;\n+    }\n+\n+    @Override\n+    public boolean isSafeAction() {\n+        return true;\n+    }\n+\n+    @Override\n+    public List<Step> toSteps(Client client, String phase, StepKey nextStepKey) {\n+        if (enabled) {\n+            Map<String, String> include = Map.of(\"_tier\", \"data_\" + phase);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "024a0de407f25e77870f792e3b023e8825ee0cb2"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMyMjY3NA==", "bodyText": "Good catch :D", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r474322674", "createdAt": "2020-08-20T23:18:21Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/RolloverAction.java", "diffHunk": "@@ -27,7 +27,7 @@\n import java.util.Objects;\n \n /**\n- * A {@link LifecycleAction} which deletes the index.\n+ * A {@link LifecycleAction} which rolls over the index.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "024a0de407f25e77870f792e3b023e8825ee0cb2"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMyMjk1NQ==", "bodyText": "I think we should add the migrate action explicitly to the hot actions as well (the hot phase doesn't have to start at min_age: 0ms)", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r474322955", "createdAt": "2020-08-20T23:19:20Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/TimeseriesLifecycleType.java", "diffHunk": "@@ -40,18 +43,18 @@\n     static final List<String> ORDERED_VALID_HOT_ACTIONS = Arrays.asList(SetPriorityAction.NAME, UnfollowAction.NAME, RolloverAction.NAME,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "024a0de407f25e77870f792e3b023e8825ee0cb2"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMyMzUxMA==", "bodyText": "This might be better named shouldInjectMigrateStepForPhase I think", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r474323510", "createdAt": "2020-08-20T23:21:17Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/TimeseriesLifecycleType.java", "diffHunk": "@@ -86,12 +89,38 @@ public String getWriteableName() {\n                     actionMap.put(UnfollowAction.NAME, new UnfollowAction());\n                     phase = new Phase(phase.getName(), phase.getMinimumAge(), actionMap);\n                 }\n+\n+                if (shouldMigrateDataToTiers(phase)) {\n+                    Map<String, LifecycleAction> actionMap = new HashMap<>(phase.getActions());\n+                    actionMap.put(MigrateAction.NAME, new MigrateAction(true));\n+                    phase = new Phase(phase.getName(), phase.getMinimumAge(), actionMap);\n+                }\n+\n                 orderedPhases.add(phase);\n             }\n         }\n         return orderedPhases;\n     }\n \n+    boolean shouldMigrateDataToTiers(Phase phase) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "024a0de407f25e77870f792e3b023e8825ee0cb2"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMyNDQ0Ng==", "bodyText": "This could use your definesAllocationRules(allocateAction) helper here instead of manually checking, though I think maybe that helper needs to use isEmpty rather than checking for null so that an allocate action with \"include\": {} doesn't trip the assertion", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r474324446", "createdAt": "2020-08-20T23:24:17Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/TimeseriesLifecycleType.java", "diffHunk": "@@ -86,12 +89,38 @@ public String getWriteableName() {\n                     actionMap.put(UnfollowAction.NAME, new UnfollowAction());\n                     phase = new Phase(phase.getName(), phase.getMinimumAge(), actionMap);\n                 }\n+\n+                if (shouldMigrateDataToTiers(phase)) {\n+                    Map<String, LifecycleAction> actionMap = new HashMap<>(phase.getActions());\n+                    actionMap.put(MigrateAction.NAME, new MigrateAction(true));\n+                    phase = new Phase(phase.getName(), phase.getMinimumAge(), actionMap);\n+                }\n+\n                 orderedPhases.add(phase);\n             }\n         }\n         return orderedPhases;\n     }\n \n+    boolean shouldMigrateDataToTiers(Phase phase) {\n+        AllocateAction allocateAction = (AllocateAction) phase.getActions().get(AllocateAction.NAME);\n+        if (allocateAction != null) {\n+            if (allocateAction.getExclude().isEmpty() == false ||\n+                allocateAction.getInclude().isEmpty() == false ||\n+                allocateAction.getRequire().isEmpty() == false) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "024a0de407f25e77870f792e3b023e8825ee0cb2"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMyNDc3NQ==", "bodyText": "These should use the .isEmpty() check rather than checking for null, since they could be \"include\": {} and be non-null but not actually have any allocation rules", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r474324775", "createdAt": "2020-08-20T23:25:15Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/TimeseriesLifecycleType.java", "diffHunk": "@@ -226,5 +255,24 @@ public void validate(Collection<Phase> phases) {\n                 \"] action may not be used in the [\" + HOT_PHASE +\n                 \"] phase without an accompanying [\" + RolloverAction.NAME + \"] action\");\n         }\n+\n+        // look for phases that have the migrate action enabled and also specify allocation rules via the AllocateAction\n+        String phasesWithConflictingMigrationActions = phases.stream()\n+            .filter(phase -> phase.getActions().containsKey(MigrateAction.NAME) &&\n+                ((MigrateAction) phase.getActions().get(MigrateAction.NAME)).isEnabled() &&\n+                phase.getActions().containsKey(AllocateAction.NAME) &&\n+                definesAllocationRules((AllocateAction) phase.getActions().get(AllocateAction.NAME))\n+            )\n+            .map(Phase::getName)\n+            .collect(Collectors.joining(\",\"));\n+        if (Strings.hasText(phasesWithConflictingMigrationActions)) {\n+            throw new IllegalArgumentException(\"phases [\" + phasesWithConflictingMigrationActions + \"] specify an enabled \" +\n+                MigrateAction.NAME + \" action and the \" + AllocateAction.NAME + \" action. specify only one data migration action in these\" +\n+                \" phases\");\n+        }\n+    }\n+\n+    private boolean definesAllocationRules(AllocateAction action) {\n+        return action.getRequire() != null || action.getInclude() != null || action.getExclude() != null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "024a0de407f25e77870f792e3b023e8825ee0cb2"}, "originalPosition": 195}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMyNDg4NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private boolean definesAllocationRules(AllocateAction action) {\n          \n          \n            \n                private static boolean definesAllocationRules(AllocateAction action) {", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r474324884", "createdAt": "2020-08-20T23:25:33Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/TimeseriesLifecycleType.java", "diffHunk": "@@ -226,5 +255,24 @@ public void validate(Collection<Phase> phases) {\n                 \"] action may not be used in the [\" + HOT_PHASE +\n                 \"] phase without an accompanying [\" + RolloverAction.NAME + \"] action\");\n         }\n+\n+        // look for phases that have the migrate action enabled and also specify allocation rules via the AllocateAction\n+        String phasesWithConflictingMigrationActions = phases.stream()\n+            .filter(phase -> phase.getActions().containsKey(MigrateAction.NAME) &&\n+                ((MigrateAction) phase.getActions().get(MigrateAction.NAME)).isEnabled() &&\n+                phase.getActions().containsKey(AllocateAction.NAME) &&\n+                definesAllocationRules((AllocateAction) phase.getActions().get(AllocateAction.NAME))\n+            )\n+            .map(Phase::getName)\n+            .collect(Collectors.joining(\",\"));\n+        if (Strings.hasText(phasesWithConflictingMigrationActions)) {\n+            throw new IllegalArgumentException(\"phases [\" + phasesWithConflictingMigrationActions + \"] specify an enabled \" +\n+                MigrateAction.NAME + \" action and the \" + AllocateAction.NAME + \" action. specify only one data migration action in these\" +\n+                \" phases\");\n+        }\n+    }\n+\n+    private boolean definesAllocationRules(AllocateAction action) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "024a0de407f25e77870f792e3b023e8825ee0cb2"}, "originalPosition": 194}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ca9800f7154008e261c77f342aa90a7cce6cb6ea", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/ca9800f7154008e261c77f342aa90a7cce6cb6ea", "committedDate": "2020-09-01T16:31:21Z", "message": "Merge branch 'master' into ilm-migrate-data-between-tiers"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "07dc8de3a23d5a57bd4c4d25a4c4c98c69558afc", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/07dc8de3a23d5a57bd4c4d25a4c4c98c69558afc", "committedDate": "2020-09-03T18:13:55Z", "message": "Add a DataTierMigrationRoutedStep and cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "42900b26f322189b57ecb776f344c9df2936acb3", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/42900b26f322189b57ecb776f344c9df2936acb3", "committedDate": "2020-09-04T09:26:49Z", "message": "Fix tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5d6729b4eb18c09ab29a8a1f79dfb2b0a64ff63f", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/5d6729b4eb18c09ab29a8a1f79dfb2b0a64ff63f", "committedDate": "2020-09-04T09:51:59Z", "message": "Fix test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "28ccee9ec0fe0e3f8eca8d473940ef7e4f1e6624", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/28ccee9ec0fe0e3f8eca8d473940ef7e4f1e6624", "committedDate": "2020-09-04T16:20:53Z", "message": "Remove invalid tier name setting validation from ILM step\n\nWe already validate the data tier setting values as part of the\nindex settings validation."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "45d2eb38d227799f7d6c78578fe4941ab7b2c2ed", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/45d2eb38d227799f7d6c78578fe4941ab7b2c2ed", "committedDate": "2020-09-04T16:47:23Z", "message": "Add test for DataTierMigrationRoutedStep"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c05591ce911008dc22e4dd342991f56deb9f4f0", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/6c05591ce911008dc22e4dd342991f56deb9f4f0", "committedDate": "2020-09-04T16:57:57Z", "message": "Disable data tier migration in the full policy we use for timeseries ITS\n\nWe'll have dedicated data tier integration tests that'll have data migration\nenabled."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "783061d20182d147e1ac064e71505c6fb62156c0", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/783061d20182d147e1ac064e71505c6fb62156c0", "committedDate": "2020-09-04T16:59:54Z", "message": "Remove unused import"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ab3ac3362b344e5caf8d3ed0211c6487533ebb4a", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/ab3ac3362b344e5caf8d3ed0211c6487533ebb4a", "committedDate": "2020-09-06T13:30:32Z", "message": "Revert \"Disable data tier migration in the full policy we use for timeseries ITS\"\n\nThis reverts commit 6c05591ce911008dc22e4dd342991f56deb9f4f0."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6b74d7cc81bbdd55e8d1fe69d0b65f3e6a17ea7e", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/6b74d7cc81bbdd55e8d1fe69d0b65f3e6a17ea7e", "committedDate": "2020-09-06T13:51:56Z", "message": "Add MigrateActionTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "61ed9eb4bcf546a6e59dbbf55878debbea3470d8", "author": {"user": {"login": "elasticmachine", "name": "Elastic Machine"}}, "url": "https://github.com/elastic/elasticsearch/commit/61ed9eb4bcf546a6e59dbbf55878debbea3470d8", "committedDate": "2020-09-06T13:53:25Z", "message": "Merge branch 'master' into ilm-migrate-data-between-tiers"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6f83f914f5906f6b871f0db39aa14cc4ee199327", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/6f83f914f5906f6b871f0db39aa14cc4ee199327", "committedDate": "2020-09-07T13:29:06Z", "message": "Don't randomly pick a disabled migrate action as it has no steps"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4bef9b262c50904a86b0ccac50daac0e64e8b5d3", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/4bef9b262c50904a86b0ccac50daac0e64e8b5d3", "committedDate": "2020-09-07T13:29:14Z", "message": "Add ILM tier migratino IT"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "50245950fe3b5a3a30e74d52488c4d5137e7486a", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/50245950fe3b5a3a30e74d52488c4d5137e7486a", "committedDate": "2020-09-07T15:23:16Z", "message": "Use 0 replicas in docs test as `check-migration` waits for replicas to start"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "41dc480bc6a1e1000c07c802c0f86b4f629ce946", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/41dc480bc6a1e1000c07c802c0f86b4f629ce946", "committedDate": "2020-09-07T15:23:36Z", "message": "Fix ILMHistoryTests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d9b63903424e848699866bde33e59773e0d0fe02", "author": {"user": {"login": "elasticmachine", "name": "Elastic Machine"}}, "url": "https://github.com/elastic/elasticsearch/commit/d9b63903424e848699866bde33e59773e0d0fe02", "committedDate": "2020-09-07T15:24:14Z", "message": "Merge branch 'master' into ilm-migrate-data-between-tiers"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8e9a4f3248f7f5ab374842f5696212f3371ae36a", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/8e9a4f3248f7f5ab374842f5696212f3371ae36a", "committedDate": "2020-09-07T15:37:11Z", "message": "Disable migrate action in test that waits for shard allocations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "996c747191e5f90754fb7d1dad3802228b206410", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/996c747191e5f90754fb7d1dad3802228b206410", "committedDate": "2020-09-07T16:55:35Z", "message": "Add ILM client MigrateAction"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "83c31b682ba7cee573066f83e8b7ce29ac63478e", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/83c31b682ba7cee573066f83e8b7ce29ac63478e", "committedDate": "2020-09-07T16:56:44Z", "message": "Remove unused import"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c1746d4a6322027112f1c80ea747f12549db4d06", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/c1746d4a6322027112f1c80ea747f12549db4d06", "committedDate": "2020-09-07T17:07:25Z", "message": "Fix HLRC tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fe1fb8f5e70847ccdfb5e52e519aad6c09164e2b", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/fe1fb8f5e70847ccdfb5e52e519aad6c09164e2b", "committedDate": "2020-09-07T17:56:05Z", "message": "Add tests for conflicting auto allocate to hot nodes and MigrateAction configurations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e435a2f26b9fc1def4256ff053e7f7ab12878b72", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/e435a2f26b9fc1def4256ff053e7f7ab12878b72", "committedDate": "2020-09-07T18:40:44Z", "message": "Use valid tier name in test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzOTY3Nzc5", "url": "https://github.com/elastic/elasticsearch/pull/61377#pullrequestreview-483967779", "createdAt": "2020-09-08T09:42:04Z", "commit": {"oid": "e435a2f26b9fc1def4256ff053e7f7ab12878b72"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQwOTo0MjowNFrOHOVJmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQwOTo0MjowNFrOHOVJmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDc4ODYzNQ==", "bodyText": "We need to add client support for the SearchableSnapshot action too", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r484788635", "createdAt": "2020-09-08T09:42:04Z", "author": {"login": "andreidan"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/ilm/LifecyclePolicy.java", "diffHunk": "@@ -57,10 +57,13 @@\n             throw new IllegalArgumentException(\"ordered \" + PHASES_FIELD.getPreferredName() + \" are not supported\");\n         }, PHASES_FIELD);\n \n-        ALLOWED_ACTIONS.put(\"hot\", Sets.newHashSet(UnfollowAction.NAME, SetPriorityAction.NAME, RolloverAction.NAME));\n-        ALLOWED_ACTIONS.put(\"warm\", Sets.newHashSet(UnfollowAction.NAME, SetPriorityAction.NAME, AllocateAction.NAME, ForceMergeAction.NAME,\n-            ReadOnlyAction.NAME, ShrinkAction.NAME));\n-        ALLOWED_ACTIONS.put(\"cold\", Sets.newHashSet(UnfollowAction.NAME, SetPriorityAction.NAME, AllocateAction.NAME, FreezeAction.NAME));\n+        ALLOWED_ACTIONS.put(\"hot\", Sets.newHashSet(UnfollowAction.NAME, SetPriorityAction.NAME, MigrateAction.NAME, RolloverAction.NAME));\n+        ALLOWED_ACTIONS.put(\"warm\", Sets.newHashSet(UnfollowAction.NAME, SetPriorityAction.NAME, MigrateAction.NAME, AllocateAction.NAME,\n+            ForceMergeAction.NAME, ReadOnlyAction.NAME, ShrinkAction.NAME));\n+        ALLOWED_ACTIONS.put(\"cold\", Sets.newHashSet(UnfollowAction.NAME, SetPriorityAction.NAME, MigrateAction.NAME, AllocateAction.NAME,\n+            FreezeAction.NAME));\n+        ALLOWED_ACTIONS.put(\"frozen\", Sets.newHashSet(UnfollowAction.NAME, SetPriorityAction.NAME, MigrateAction.NAME, AllocateAction.NAME,\n+            FreezeAction.NAME));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e435a2f26b9fc1def4256ff053e7f7ab12878b72"}, "originalPosition": 14}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "656afe540f78a4e674b556159527e1d0bc9efa95", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/656afe540f78a4e674b556159527e1d0bc9efa95", "committedDate": "2020-09-08T10:12:22Z", "message": "Implement hashcode"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a24b0fc2bb3bf165f4f06df2e4cfdfaa537093ad", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/a24b0fc2bb3bf165f4f06df2e4cfdfaa537093ad", "committedDate": "2020-09-08T10:20:21Z", "message": "Merge branch 'master' into ilm-migrate-data-between-tiers"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8d806e2cd886600eda641c6dead953cec98e175b", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/8d806e2cd886600eda641c6dead953cec98e175b", "committedDate": "2020-09-08T10:47:02Z", "message": "Make method static"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0NDk2NjE3", "url": "https://github.com/elastic/elasticsearch/pull/61377#pullrequestreview-484496617", "createdAt": "2020-09-08T21:12:38Z", "commit": {"oid": "8d806e2cd886600eda641c6dead953cec98e175b"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMToxMjozOFrOHOuMig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQyMTozNjo1MFrOHPbK9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE5ODk4Ng==", "bodyText": "Can you open an issue for that so we don't forget?", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r485198986", "createdAt": "2020-09-08T21:12:38Z", "author": {"login": "dakrone"}, "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/ilm/LifecyclePolicy.java", "diffHunk": "@@ -57,10 +57,13 @@\n             throw new IllegalArgumentException(\"ordered \" + PHASES_FIELD.getPreferredName() + \" are not supported\");\n         }, PHASES_FIELD);\n \n-        ALLOWED_ACTIONS.put(\"hot\", Sets.newHashSet(UnfollowAction.NAME, SetPriorityAction.NAME, RolloverAction.NAME));\n-        ALLOWED_ACTIONS.put(\"warm\", Sets.newHashSet(UnfollowAction.NAME, SetPriorityAction.NAME, AllocateAction.NAME, ForceMergeAction.NAME,\n-            ReadOnlyAction.NAME, ShrinkAction.NAME));\n-        ALLOWED_ACTIONS.put(\"cold\", Sets.newHashSet(UnfollowAction.NAME, SetPriorityAction.NAME, AllocateAction.NAME, FreezeAction.NAME));\n+        ALLOWED_ACTIONS.put(\"hot\", Sets.newHashSet(UnfollowAction.NAME, SetPriorityAction.NAME, MigrateAction.NAME, RolloverAction.NAME));\n+        ALLOWED_ACTIONS.put(\"warm\", Sets.newHashSet(UnfollowAction.NAME, SetPriorityAction.NAME, MigrateAction.NAME, AllocateAction.NAME,\n+            ForceMergeAction.NAME, ReadOnlyAction.NAME, ShrinkAction.NAME));\n+        ALLOWED_ACTIONS.put(\"cold\", Sets.newHashSet(UnfollowAction.NAME, SetPriorityAction.NAME, MigrateAction.NAME, AllocateAction.NAME,\n+            FreezeAction.NAME));\n+        ALLOWED_ACTIONS.put(\"frozen\", Sets.newHashSet(UnfollowAction.NAME, SetPriorityAction.NAME, MigrateAction.NAME, AllocateAction.NAME,\n+            FreezeAction.NAME));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDc4ODYzNQ=="}, "originalCommit": {"oid": "e435a2f26b9fc1def4256ff053e7f7ab12878b72"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkzMDI4Nw==", "bodyText": "I don't think this will work, because it's checking for the exact role, so for example, if the allocation were set to data_warm, and we had data nodes but not nodes with the exact data_warm role, this would say that they were not found (even though they are).\nWe should check for either an exact match or the presence of any nodes with the data role", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r485930287", "createdAt": "2020-09-09T21:24:10Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/DataTierMigrationRoutedStep.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.support.ActiveShardCount;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.node.DiscoveryNodeRole;\n+import org.elasticsearch.cluster.routing.allocation.decider.AllocationDeciders;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.Index;\n+import org.elasticsearch.xpack.cluster.routing.allocation.DataTierAllocationDecider;\n+import org.elasticsearch.xpack.core.ilm.step.info.AllocationInfo;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+import static org.elasticsearch.xpack.cluster.routing.allocation.DataTierAllocationDecider.INDEX_ROUTING_INCLUDE_SETTING;\n+import static org.elasticsearch.xpack.core.ilm.AllocationRoutedStep.getPendingAllocations;\n+\n+/**\n+ * Checks whether all shards have been correctly routed in response to updating the allocation rules for an index in order\n+ * to migrate the index to a new tier.\n+ */\n+public class DataTierMigrationRoutedStep extends ClusterStateWaitStep {\n+    public static final String NAME = \"check-migration\";\n+\n+    private static final Logger logger = LogManager.getLogger(DataTierMigrationRoutedStep.class);\n+\n+    private static final Set<Setting<?>> ALL_CLUSTER_SETTINGS;\n+\n+    static {\n+        Set<Setting<?>> allSettings = new HashSet<>(ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+        allSettings.add(DataTierAllocationDecider.CLUSTER_ROUTING_REQUIRE_SETTING);\n+        allSettings.add(DataTierAllocationDecider.CLUSTER_ROUTING_INCLUDE_SETTING);\n+        allSettings.add(DataTierAllocationDecider.CLUSTER_ROUTING_EXCLUDE_SETTING);\n+        ALL_CLUSTER_SETTINGS = allSettings;\n+    }\n+\n+    private static final AllocationDeciders ALLOCATION_DECIDERS = new AllocationDeciders(\n+        List.of(\n+            new DataTierAllocationDecider(new ClusterSettings(Settings.EMPTY, ALL_CLUSTER_SETTINGS))\n+        )\n+    );\n+\n+    DataTierMigrationRoutedStep(StepKey key, StepKey nextStepKey) {\n+        super(key, nextStepKey);\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public Result isConditionMet(Index index, ClusterState clusterState) {\n+        IndexMetadata idxMeta = clusterState.metadata().index(index);\n+        if (idxMeta == null) {\n+            // Index must have been since deleted, ignore it\n+            logger.debug(\"[{}] lifecycle action for index [{}] executed but index no longer exists\", getKey().getAction(), index.getName());\n+            return new Result(false, null);\n+        }\n+        if (ActiveShardCount.ALL.enoughShardsActive(clusterState, index.getName()) == false) {\n+            logger.debug(\"[{}] lifecycle action for index [{}] cannot make progress because not all shards are active\",\n+                    getKey().getAction(), index.getName());\n+            return new Result(false, AllocationInfo.waitingForActiveShardsAllocationInfo(idxMeta.getNumberOfReplicas()));\n+        }\n+\n+        int allocationPendingAllShards = getPendingAllocations(index, ALLOCATION_DECIDERS, clusterState);\n+\n+        if (allocationPendingAllShards > 0) {\n+            String tier = INDEX_ROUTING_INCLUDE_SETTING.get(idxMeta.getSettings());\n+            boolean targetTierNodeFound = false;\n+            for (DiscoveryNode node : clusterState.nodes()) {\n+                for (DiscoveryNodeRole role : node.getRoles()) {\n+                    if (role.roleName().equals(tier)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d806e2cd886600eda641c6dead953cec98e175b"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkzMTQyOA==", "bodyText": "I think we discussed making this throw an exception if there were no nodes with the target tier in the cluster, so that the ERROR state was signaled (and the user could alert for it), but this only sets the result to false.", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r485931428", "createdAt": "2020-09-09T21:26:34Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/DataTierMigrationRoutedStep.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.support.ActiveShardCount;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.node.DiscoveryNodeRole;\n+import org.elasticsearch.cluster.routing.allocation.decider.AllocationDeciders;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.Index;\n+import org.elasticsearch.xpack.cluster.routing.allocation.DataTierAllocationDecider;\n+import org.elasticsearch.xpack.core.ilm.step.info.AllocationInfo;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+import static org.elasticsearch.xpack.cluster.routing.allocation.DataTierAllocationDecider.INDEX_ROUTING_INCLUDE_SETTING;\n+import static org.elasticsearch.xpack.core.ilm.AllocationRoutedStep.getPendingAllocations;\n+\n+/**\n+ * Checks whether all shards have been correctly routed in response to updating the allocation rules for an index in order\n+ * to migrate the index to a new tier.\n+ */\n+public class DataTierMigrationRoutedStep extends ClusterStateWaitStep {\n+    public static final String NAME = \"check-migration\";\n+\n+    private static final Logger logger = LogManager.getLogger(DataTierMigrationRoutedStep.class);\n+\n+    private static final Set<Setting<?>> ALL_CLUSTER_SETTINGS;\n+\n+    static {\n+        Set<Setting<?>> allSettings = new HashSet<>(ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+        allSettings.add(DataTierAllocationDecider.CLUSTER_ROUTING_REQUIRE_SETTING);\n+        allSettings.add(DataTierAllocationDecider.CLUSTER_ROUTING_INCLUDE_SETTING);\n+        allSettings.add(DataTierAllocationDecider.CLUSTER_ROUTING_EXCLUDE_SETTING);\n+        ALL_CLUSTER_SETTINGS = allSettings;\n+    }\n+\n+    private static final AllocationDeciders ALLOCATION_DECIDERS = new AllocationDeciders(\n+        List.of(\n+            new DataTierAllocationDecider(new ClusterSettings(Settings.EMPTY, ALL_CLUSTER_SETTINGS))\n+        )\n+    );\n+\n+    DataTierMigrationRoutedStep(StepKey key, StepKey nextStepKey) {\n+        super(key, nextStepKey);\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public Result isConditionMet(Index index, ClusterState clusterState) {\n+        IndexMetadata idxMeta = clusterState.metadata().index(index);\n+        if (idxMeta == null) {\n+            // Index must have been since deleted, ignore it\n+            logger.debug(\"[{}] lifecycle action for index [{}] executed but index no longer exists\", getKey().getAction(), index.getName());\n+            return new Result(false, null);\n+        }\n+        if (ActiveShardCount.ALL.enoughShardsActive(clusterState, index.getName()) == false) {\n+            logger.debug(\"[{}] lifecycle action for index [{}] cannot make progress because not all shards are active\",\n+                    getKey().getAction(), index.getName());\n+            return new Result(false, AllocationInfo.waitingForActiveShardsAllocationInfo(idxMeta.getNumberOfReplicas()));\n+        }\n+\n+        int allocationPendingAllShards = getPendingAllocations(index, ALLOCATION_DECIDERS, clusterState);\n+\n+        if (allocationPendingAllShards > 0) {\n+            String tier = INDEX_ROUTING_INCLUDE_SETTING.get(idxMeta.getSettings());\n+            boolean targetTierNodeFound = false;\n+            for (DiscoveryNode node : clusterState.nodes()) {\n+                for (DiscoveryNodeRole role : node.getRoles()) {\n+                    if (role.roleName().equals(tier)) {\n+                        targetTierNodeFound = true;\n+                        break;\n+                    }\n+                }\n+            }\n+            String statusMessage = String.format(Locale.ROOT, \"%s lifecycle action [%s] waiting for [%s] shards to be moved to the [%s] \" +\n+                    \"tier\" + (targetTierNodeFound ? \"\" : \" but there are currently no [%s] nodes in the cluster\"),\n+                index, getKey().getAction(), allocationPendingAllShards, tier, tier);\n+            logger.debug(statusMessage);\n+            return new Result(false, new AllocationInfo(idxMeta.getNumberOfReplicas(), allocationPendingAllShards, true, statusMessage));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d806e2cd886600eda641c6dead953cec98e175b"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkzMzM4Nw==", "bodyText": "We should remove this from the hot phase (I know you know this already, this is just a placeholder comment)", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r485933387", "createdAt": "2020-09-09T21:31:06Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/TimeseriesLifecycleType.java", "diffHunk": "@@ -37,21 +40,21 @@\n     static final String FROZEN_PHASE = \"frozen\";\n     static final String DELETE_PHASE = \"delete\";\n     static final List<String> VALID_PHASES = Arrays.asList(HOT_PHASE, WARM_PHASE, COLD_PHASE, FROZEN_PHASE, DELETE_PHASE);\n-    static final List<String> ORDERED_VALID_HOT_ACTIONS = Arrays.asList(SetPriorityAction.NAME, UnfollowAction.NAME, RolloverAction.NAME,\n-        ForceMergeAction.NAME);\n+    static final List<String> ORDERED_VALID_HOT_ACTIONS = Arrays.asList(SetPriorityAction.NAME, UnfollowAction.NAME, MigrateAction.NAME,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d806e2cd886600eda641c6dead953cec98e175b"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkzNDc5OA==", "bodyText": "Could you add javadocs please?", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r485934798", "createdAt": "2020-09-09T21:34:27Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/step/info/AllocationInfo.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.ilm.step.info;\n+\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+\n+public class AllocationInfo implements ToXContentObject {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d806e2cd886600eda641c6dead953cec98e175b"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkzNTE5OA==", "bodyText": "I think \"actual_replicas\" is a little difficult to tell what it means, maybe there's a clearer name we could use?", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r485935198", "createdAt": "2020-09-09T21:35:19Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/step/info/AllocationInfo.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.ilm.step.info;\n+\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+\n+public class AllocationInfo implements ToXContentObject {\n+    private final long actualReplicas;\n+    private final long numberShardsLeftToAllocate;\n+    private final boolean allShardsActive;\n+    private final String message;\n+\n+    static final ParseField ACTUAL_REPLICAS = new ParseField(\"actual_replicas\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d806e2cd886600eda641c6dead953cec98e175b"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkzNTg2MA==", "bodyText": "Whoops I think this is a typo that can be removed?", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r485935860", "createdAt": "2020-09-09T21:36:50Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/ilm/src/test/java/org/elasticsearch/xpack/ilm/IndexLifecycleRunnerTests.java", "diffHunk": "@@ -91,6 +92,8 @@\n import static org.mockito.Mockito.times;\n import static org.mockito.Mockito.when;\n \n+;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d806e2cd886600eda641c6dead953cec98e175b"}, "originalPosition": 13}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2133715100e7c1ee0367ad6a13a66032164953c0", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/2133715100e7c1ee0367ad6a13a66032164953c0", "committedDate": "2020-09-10T09:23:18Z", "message": "Check for \"data\" role in `check-migration` step"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "991fdc078797bae280cb3b37c26bcc60c67cb317", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/991fdc078797bae280cb3b37c26bcc60c67cb317", "committedDate": "2020-09-10T09:33:42Z", "message": "Document AllocationInfo and rename `actual_replicas` to `number_of_replicas`"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "be6592903733d247980b680d6075d2ed30bf89ce", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/be6592903733d247980b680d6075d2ed30bf89ce", "committedDate": "2020-09-10T09:38:59Z", "message": "Disallow the migrate action in the hot phase"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "39b518e8e9804a79ce1346afbba6ceb72b868c71", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/39b518e8e9804a79ce1346afbba6ceb72b868c71", "committedDate": "2020-09-10T09:42:59Z", "message": "Remove rogue ;"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f3a64d3163d1f4c0793a7667645ff71efa8459a6", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/f3a64d3163d1f4c0793a7667645ff71efa8459a6", "committedDate": "2020-09-10T11:40:15Z", "message": "Fix HLRC tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d11979714856055de2e3d1076e2bf3eeb0ee5a77", "author": {"user": {"login": "elasticmachine", "name": "Elastic Machine"}}, "url": "https://github.com/elastic/elasticsearch/commit/d11979714856055de2e3d1076e2bf3eeb0ee5a77", "committedDate": "2020-09-10T11:40:51Z", "message": "Merge branch 'master' into ilm-migrate-data-between-tiers"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8f855c550baf9e244f7e65508e47bbf9de6833c6", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/8f855c550baf9e244f7e65508e47bbf9de6833c6", "committedDate": "2020-09-10T12:16:26Z", "message": "Fix ILMHistoryTests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0636d0ec5f82435d95b794a6ca4bedf31d40db99", "author": {"user": {"login": "elasticmachine", "name": "Elastic Machine"}}, "url": "https://github.com/elastic/elasticsearch/commit/0636d0ec5f82435d95b794a6ca4bedf31d40db99", "committedDate": "2020-09-14T12:40:50Z", "message": "Merge branch 'master' into ilm-migrate-data-between-tiers"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg4MTg4Mjk1", "url": "https://github.com/elastic/elasticsearch/pull/61377#pullrequestreview-488188295", "createdAt": "2020-09-14T22:05:13Z", "commit": {"oid": "0636d0ec5f82435d95b794a6ca4bedf31d40db99"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQyMjowNToxNFrOHRoZMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQyMjoyMDoyMFrOHRpEPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI0OTY0OA==", "bodyText": "I realized something about this, I think we should do AllocateAction prior to the migrate action, or else we are liable to get \"stuck\".\nFor example, if a user had multiple hot nodes and only a single warm node, we would try to migrate an index with one replica from hot to warm, but the replica could never allocate, since there is only a single node. Instead, we should do the allocate action first (where a user could set number_of_replicas to 0) before migrating to the next tier.\nWhat do you think?", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r488249648", "createdAt": "2020-09-14T22:05:14Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/TimeseriesLifecycleType.java", "diffHunk": "@@ -40,18 +43,18 @@\n     static final List<String> ORDERED_VALID_HOT_ACTIONS = Arrays.asList(SetPriorityAction.NAME, UnfollowAction.NAME, RolloverAction.NAME,\n         ForceMergeAction.NAME);\n     static final List<String> ORDERED_VALID_WARM_ACTIONS = Arrays.asList(SetPriorityAction.NAME, UnfollowAction.NAME, ReadOnlyAction.NAME,\n-        AllocateAction.NAME, ShrinkAction.NAME, ForceMergeAction.NAME);\n-    static final List<String> ORDERED_VALID_COLD_ACTIONS = Arrays.asList(SetPriorityAction.NAME, UnfollowAction.NAME, AllocateAction.NAME,\n-        FreezeAction.NAME, SearchableSnapshotAction.NAME);\n-    static final List<String> ORDERED_VALID_FROZEN_ACTIONS = Arrays.asList(SetPriorityAction.NAME, UnfollowAction.NAME, AllocateAction.NAME,\n-        FreezeAction.NAME, SearchableSnapshotAction.NAME);\n+        MigrateAction.NAME, AllocateAction.NAME, ShrinkAction.NAME, ForceMergeAction.NAME);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0636d0ec5f82435d95b794a6ca4bedf31d40db99"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI1MTU0NA==", "bodyText": "I think in this one we can be more specific in the debug message, so perhaps:\n[check-migration] migration for index [foo] to the [data_cold] tier cannot progress, as not all shards are active\n\n(we can pull the tier name from the index setting)", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r488251544", "createdAt": "2020-09-14T22:07:49Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/DataTierMigrationRoutedStep.java", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.support.ActiveShardCount;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.node.DiscoveryNodeRole;\n+import org.elasticsearch.cluster.routing.allocation.decider.AllocationDeciders;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.Index;\n+import org.elasticsearch.xpack.cluster.routing.allocation.DataTierAllocationDecider;\n+import org.elasticsearch.xpack.core.ilm.step.info.AllocationInfo;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+import static org.elasticsearch.cluster.node.DiscoveryNodeRole.DATA_ROLE;\n+import static org.elasticsearch.xpack.cluster.routing.allocation.DataTierAllocationDecider.INDEX_ROUTING_INCLUDE_SETTING;\n+import static org.elasticsearch.xpack.core.ilm.AllocationRoutedStep.getPendingAllocations;\n+\n+/**\n+ * Checks whether all shards have been correctly routed in response to updating the allocation rules for an index in order\n+ * to migrate the index to a new tier.\n+ */\n+public class DataTierMigrationRoutedStep extends ClusterStateWaitStep {\n+    public static final String NAME = \"check-migration\";\n+\n+    private static final Logger logger = LogManager.getLogger(DataTierMigrationRoutedStep.class);\n+\n+    private static final Set<Setting<?>> ALL_CLUSTER_SETTINGS;\n+\n+    static {\n+        Set<Setting<?>> allSettings = new HashSet<>(ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+        allSettings.add(DataTierAllocationDecider.CLUSTER_ROUTING_REQUIRE_SETTING);\n+        allSettings.add(DataTierAllocationDecider.CLUSTER_ROUTING_INCLUDE_SETTING);\n+        allSettings.add(DataTierAllocationDecider.CLUSTER_ROUTING_EXCLUDE_SETTING);\n+        ALL_CLUSTER_SETTINGS = allSettings;\n+    }\n+\n+    private static final AllocationDeciders ALLOCATION_DECIDERS = new AllocationDeciders(\n+        List.of(\n+            new DataTierAllocationDecider(new ClusterSettings(Settings.EMPTY, ALL_CLUSTER_SETTINGS))\n+        )\n+    );\n+\n+    DataTierMigrationRoutedStep(StepKey key, StepKey nextStepKey) {\n+        super(key, nextStepKey);\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public Result isConditionMet(Index index, ClusterState clusterState) {\n+        IndexMetadata idxMeta = clusterState.metadata().index(index);\n+        if (idxMeta == null) {\n+            // Index must have been since deleted, ignore it\n+            logger.debug(\"[{}] lifecycle action for index [{}] executed but index no longer exists\", getKey().getAction(), index.getName());\n+            return new Result(false, null);\n+        }\n+        if (ActiveShardCount.ALL.enoughShardsActive(clusterState, index.getName()) == false) {\n+            logger.debug(\"[{}] lifecycle action for index [{}] cannot make progress because not all shards are active\",\n+                    getKey().getAction(), index.getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0636d0ec5f82435d95b794a6ca4bedf31d40db99"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI1MzY4OA==", "bodyText": "same here about log messages, perhaps:\n[check-migration] migration of index [foo] to tier [data_cold] complete\n\nIt's definitely a lot nicer to grep for in logs :)", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r488253688", "createdAt": "2020-09-14T22:10:36Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/DataTierMigrationRoutedStep.java", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.support.ActiveShardCount;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.node.DiscoveryNodeRole;\n+import org.elasticsearch.cluster.routing.allocation.decider.AllocationDeciders;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.Index;\n+import org.elasticsearch.xpack.cluster.routing.allocation.DataTierAllocationDecider;\n+import org.elasticsearch.xpack.core.ilm.step.info.AllocationInfo;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+import static org.elasticsearch.cluster.node.DiscoveryNodeRole.DATA_ROLE;\n+import static org.elasticsearch.xpack.cluster.routing.allocation.DataTierAllocationDecider.INDEX_ROUTING_INCLUDE_SETTING;\n+import static org.elasticsearch.xpack.core.ilm.AllocationRoutedStep.getPendingAllocations;\n+\n+/**\n+ * Checks whether all shards have been correctly routed in response to updating the allocation rules for an index in order\n+ * to migrate the index to a new tier.\n+ */\n+public class DataTierMigrationRoutedStep extends ClusterStateWaitStep {\n+    public static final String NAME = \"check-migration\";\n+\n+    private static final Logger logger = LogManager.getLogger(DataTierMigrationRoutedStep.class);\n+\n+    private static final Set<Setting<?>> ALL_CLUSTER_SETTINGS;\n+\n+    static {\n+        Set<Setting<?>> allSettings = new HashSet<>(ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+        allSettings.add(DataTierAllocationDecider.CLUSTER_ROUTING_REQUIRE_SETTING);\n+        allSettings.add(DataTierAllocationDecider.CLUSTER_ROUTING_INCLUDE_SETTING);\n+        allSettings.add(DataTierAllocationDecider.CLUSTER_ROUTING_EXCLUDE_SETTING);\n+        ALL_CLUSTER_SETTINGS = allSettings;\n+    }\n+\n+    private static final AllocationDeciders ALLOCATION_DECIDERS = new AllocationDeciders(\n+        List.of(\n+            new DataTierAllocationDecider(new ClusterSettings(Settings.EMPTY, ALL_CLUSTER_SETTINGS))\n+        )\n+    );\n+\n+    DataTierMigrationRoutedStep(StepKey key, StepKey nextStepKey) {\n+        super(key, nextStepKey);\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public Result isConditionMet(Index index, ClusterState clusterState) {\n+        IndexMetadata idxMeta = clusterState.metadata().index(index);\n+        if (idxMeta == null) {\n+            // Index must have been since deleted, ignore it\n+            logger.debug(\"[{}] lifecycle action for index [{}] executed but index no longer exists\", getKey().getAction(), index.getName());\n+            return new Result(false, null);\n+        }\n+        if (ActiveShardCount.ALL.enoughShardsActive(clusterState, index.getName()) == false) {\n+            logger.debug(\"[{}] lifecycle action for index [{}] cannot make progress because not all shards are active\",\n+                    getKey().getAction(), index.getName());\n+            return new Result(false, AllocationInfo.waitingForActiveShardsAllocationInfo(idxMeta.getNumberOfReplicas()));\n+        }\n+\n+        int allocationPendingAllShards = getPendingAllocations(index, ALLOCATION_DECIDERS, clusterState);\n+\n+        if (allocationPendingAllShards > 0) {\n+            String tier = INDEX_ROUTING_INCLUDE_SETTING.get(idxMeta.getSettings());\n+            boolean targetTierNodeFound = false;\n+            for (DiscoveryNode node : clusterState.nodes()) {\n+                for (DiscoveryNodeRole role : node.getRoles()) {\n+                    if (role.roleName().equals(DATA_ROLE.roleName()) || role.roleName().equals(tier)) {\n+                        targetTierNodeFound = true;\n+                        break;\n+                    }\n+                }\n+            }\n+            String statusMessage = String.format(Locale.ROOT, \"%s lifecycle action [%s] waiting for [%s] shards to be moved to the [%s] \" +\n+                    \"tier\" + (targetTierNodeFound ? \"\" : \" but there are currently no [%s] nodes in the cluster\"),\n+                index, getKey().getAction(), allocationPendingAllShards, tier, tier);\n+            logger.debug(statusMessage);\n+            return new Result(false, new AllocationInfo(idxMeta.getNumberOfReplicas(), allocationPendingAllShards, true, statusMessage));\n+        } else {\n+            logger.debug(\"{} lifecycle action for [{}] complete\", index, getKey().getAction());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0636d0ec5f82435d95b794a6ca4bedf31d40db99"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI1NTcwNQ==", "bodyText": "Super minor, but it's confusing to call the parameter here (and in the function above) \"actualReplicas\", it makes it seem like there should be a \"allocatedReplicas\" parameter somewhere as well. Maybe we can just call in numReplicas?", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r488255705", "createdAt": "2020-09-14T22:13:30Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/step/info/AllocationInfo.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.ilm.step.info;\n+\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+\n+/**\n+ * Represents the state of an index's shards allocation, including a user friendly message describing the current state.\n+ * It allows to transfer the allocation information to {@link org.elasticsearch.common.xcontent.XContent} using\n+ * {@link #toXContent(XContentBuilder, Params)}\n+ */\n+public class AllocationInfo implements ToXContentObject {\n+\n+    private final long numberOfReplicas;\n+    private final long numberShardsLeftToAllocate;\n+    private final boolean allShardsActive;\n+    private final String message;\n+\n+    static final ParseField NUMBER_OF_REPLICAS = new ParseField(\"number_of_replicas\");\n+    static final ParseField SHARDS_TO_ALLOCATE = new ParseField(\"shards_left_to_allocate\");\n+    static final ParseField ALL_SHARDS_ACTIVE = new ParseField(\"all_shards_active\");\n+    static final ParseField MESSAGE = new ParseField(\"message\");\n+    static final ConstructingObjectParser<AllocationInfo, Void> PARSER = new ConstructingObjectParser<>(\"allocation_routed_step_info\",\n+        a -> new AllocationInfo((long) a[0], (long) a[1], (boolean) a[2], (String) a[3]));\n+\n+    static {\n+        PARSER.declareLong(ConstructingObjectParser.constructorArg(), NUMBER_OF_REPLICAS);\n+        PARSER.declareLong(ConstructingObjectParser.constructorArg(), SHARDS_TO_ALLOCATE);\n+        PARSER.declareBoolean(ConstructingObjectParser.constructorArg(), ALL_SHARDS_ACTIVE);\n+        PARSER.declareString(ConstructingObjectParser.constructorArg(), MESSAGE);\n+    }\n+\n+    public AllocationInfo(long numberOfReplicas, long numberShardsLeftToAllocate, boolean allShardsActive, String message) {\n+        this.numberOfReplicas = numberOfReplicas;\n+        this.numberShardsLeftToAllocate = numberShardsLeftToAllocate;\n+        this.allShardsActive = allShardsActive;\n+        this.message = message;\n+    }\n+\n+    /**\n+     * Builds the AllocationInfo representing a cluster state with a routing table that does not have enough shards active for a\n+     * particular index.\n+     */\n+    public static AllocationInfo waitingForActiveShardsAllocationInfo(long actualReplicas) {\n+        return new AllocationInfo(actualReplicas, -1, false,\n+            \"Waiting for all shard copies to be active\");\n+    }\n+\n+    /**\n+     * Builds the AllocationInfo representing a cluster state with a routing table that has all the shards active for a particular index\n+     * but there are still {@link #numberShardsLeftToAllocate} left to be allocated.\n+     */\n+    public static AllocationInfo allShardsActiveAllocationInfo(long actualReplicas, long numberShardsLeftToAllocate) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0636d0ec5f82435d95b794a6ca4bedf31d40db99"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI1ODk4OQ==", "bodyText": "I think rather than:\nphases [warm,cold] specify an enabled migrate action and the allocate action. specify only one data migration action in these phases\n\nWe should clarify that it's the actual allocation rules that cause problems (they're free to adjust replica count as much as they'd like):\nphase [warm,cold] specifies an enabled migrate action and an allocate action with allocation rules, specify only a single data migration in each phase", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r488258989", "createdAt": "2020-09-14T22:18:03Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/TimeseriesLifecycleType.java", "diffHunk": "@@ -226,5 +250,24 @@ public void validate(Collection<Phase> phases) {\n                 \"] action may not be used in the [\" + HOT_PHASE +\n                 \"] phase without an accompanying [\" + RolloverAction.NAME + \"] action\");\n         }\n+\n+        // look for phases that have the migrate action enabled and also specify allocation rules via the AllocateAction\n+        String phasesWithConflictingMigrationActions = phases.stream()\n+            .filter(phase -> phase.getActions().containsKey(MigrateAction.NAME) &&\n+                ((MigrateAction) phase.getActions().get(MigrateAction.NAME)).isEnabled() &&\n+                phase.getActions().containsKey(AllocateAction.NAME) &&\n+                definesAllocationRules((AllocateAction) phase.getActions().get(AllocateAction.NAME))\n+            )\n+            .map(Phase::getName)\n+            .collect(Collectors.joining(\",\"));\n+        if (Strings.hasText(phasesWithConflictingMigrationActions)) {\n+            throw new IllegalArgumentException(\"phases [\" + phasesWithConflictingMigrationActions + \"] specify an enabled \" +\n+                MigrateAction.NAME + \" action and the \" + AllocateAction.NAME + \" action. specify only one data migration action in these\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0636d0ec5f82435d95b794a6ca4bedf31d40db99"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI2MDY3MA==", "bodyText": "Should we have the check for \"cold\" node allocation before starting up the frozen node? We have it for the other phases, so probably best to check for it just so it doesn't end up disappearing for only the cold phase some time in the future", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r488260670", "createdAt": "2020-09-14T22:20:20Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/ilm/src/internalClusterTest/java/org/elasticsearch/xpack/ilm/DataTiersMigrationsTests.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.ilm;\n+\n+import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.test.ESIntegTestCase;\n+import org.elasticsearch.xpack.core.DataTier;\n+import org.elasticsearch.xpack.core.LocalStateCompositeXPackPlugin;\n+import org.elasticsearch.xpack.core.XPackSettings;\n+import org.elasticsearch.xpack.core.ilm.DataTierMigrationRoutedStep;\n+import org.elasticsearch.xpack.core.ilm.ExplainLifecycleRequest;\n+import org.elasticsearch.xpack.core.ilm.ExplainLifecycleResponse;\n+import org.elasticsearch.xpack.core.ilm.IndexLifecycleExplainResponse;\n+import org.elasticsearch.xpack.core.ilm.LifecyclePolicy;\n+import org.elasticsearch.xpack.core.ilm.LifecycleSettings;\n+import org.elasticsearch.xpack.core.ilm.Phase;\n+import org.elasticsearch.xpack.core.ilm.action.ExplainLifecycleAction;\n+import org.elasticsearch.xpack.core.ilm.action.PutLifecycleAction;\n+import org.junit.Before;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Locale;\n+import java.util.Map;\n+\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_NUMBER_OF_REPLICAS;\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_NUMBER_OF_SHARDS;\n+import static org.elasticsearch.test.NodeRoles.onlyRole;\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n+import static org.hamcrest.Matchers.is;\n+\n+@ESIntegTestCase.ClusterScope(scope = ESIntegTestCase.Scope.TEST, numDataNodes = 0)\n+public class DataTiersMigrationsTests extends ESIntegTestCase {\n+\n+    private String policy;\n+    private String managedIndex;\n+\n+    @Before\n+    public void refreshDataStreamAndPolicy() {\n+        policy = \"policy-\" + randomAlphaOfLength(5);\n+        managedIndex = \"index-\" + randomAlphaOfLengthBetween(10, 15).toLowerCase(Locale.ROOT);\n+    }\n+\n+    @Override\n+    protected boolean ignoreExternalCluster() {\n+        return true;\n+    }\n+\n+    @Override\n+    protected Collection<Class<? extends Plugin>> nodePlugins() {\n+        return Arrays.asList(LocalStateCompositeXPackPlugin.class, IndexLifecycle.class);\n+    }\n+\n+    @Override\n+    protected Settings nodeSettings(int nodeOrdinal) {\n+        Settings.Builder settings = Settings.builder().put(super.nodeSettings(nodeOrdinal));\n+        settings.put(XPackSettings.MACHINE_LEARNING_ENABLED.getKey(), false);\n+        settings.put(XPackSettings.SECURITY_ENABLED.getKey(), false);\n+        settings.put(XPackSettings.WATCHER_ENABLED.getKey(), false);\n+        settings.put(XPackSettings.GRAPH_ENABLED.getKey(), false);\n+        settings.put(LifecycleSettings.LIFECYCLE_POLL_INTERVAL, \"1s\");\n+        settings.put(LifecycleSettings.SLM_HISTORY_INDEX_ENABLED_SETTING.getKey(), false);\n+        settings.put(LifecycleSettings.LIFECYCLE_HISTORY_INDEX_ENABLED, false);\n+        return settings.build();\n+    }\n+\n+    public static Settings hotNode(final Settings settings) {\n+        return onlyRole(settings, DataTier.DATA_HOT_NODE_ROLE);\n+    }\n+\n+    public static Settings warmNode(final Settings settings) {\n+        return onlyRole(settings, DataTier.DATA_WARM_NODE_ROLE);\n+    }\n+\n+    public static Settings coldNode(final Settings settings) {\n+        return onlyRole(settings, DataTier.DATA_COLD_NODE_ROLE);\n+    }\n+\n+    public static Settings frozenNode(final Settings settings) {\n+        return onlyRole(settings, DataTier.DATA_FROZEN_NODE_ROLE);\n+    }\n+\n+    public void testIndexDataTierMigration() throws Exception {\n+        internalCluster().startMasterOnlyNodes(1, Settings.EMPTY);\n+        logger.info(\"starting hot data node\");\n+        internalCluster().startNode(hotNode(Settings.EMPTY));\n+\n+        Phase hotPhase = new Phase(\"hot\", TimeValue.ZERO, Collections.emptyMap());\n+        Phase warmPhase = new Phase(\"warm\", TimeValue.ZERO, Collections.emptyMap());\n+        Phase coldPhase = new Phase(\"cold\", TimeValue.ZERO, Collections.emptyMap());\n+        Phase frozenPhase = new Phase(\"frozen\", TimeValue.ZERO, Collections.emptyMap());\n+        LifecyclePolicy lifecyclePolicy = new LifecyclePolicy(policy, Map.of(\"hot\", hotPhase, \"warm\", warmPhase, \"cold\", coldPhase,\n+            \"frozen\", frozenPhase));\n+        PutLifecycleAction.Request putLifecycleRequest = new PutLifecycleAction.Request(lifecyclePolicy);\n+        PutLifecycleAction.Response putLifecycleResponse = client().execute(PutLifecycleAction.INSTANCE, putLifecycleRequest).get();\n+        assertAcked(putLifecycleResponse);\n+\n+        Settings settings = Settings.builder().put(indexSettings()).put(SETTING_NUMBER_OF_SHARDS, 1)\n+            .put(SETTING_NUMBER_OF_REPLICAS, 0).put(LifecycleSettings.LIFECYCLE_NAME, policy).build();\n+        CreateIndexResponse res = client().admin().indices().prepareCreate(managedIndex).setSettings(settings).get();\n+        assertTrue(res.isAcknowledged());\n+\n+        assertBusy(() -> {\n+            ExplainLifecycleRequest explainRequest = new ExplainLifecycleRequest().indices(managedIndex);\n+            ExplainLifecycleResponse explainResponse = client().execute(ExplainLifecycleAction.INSTANCE,\n+                explainRequest).get();\n+\n+            IndexLifecycleExplainResponse indexLifecycleExplainResponse = explainResponse.getIndexResponses().get(managedIndex);\n+            assertThat(indexLifecycleExplainResponse.getPhase(), is(\"warm\"));\n+            assertThat(indexLifecycleExplainResponse.getStep(), is(DataTierMigrationRoutedStep.NAME));\n+        });\n+\n+        logger.info(\"starting warm data node\");\n+        internalCluster().startNode(warmNode(Settings.EMPTY));\n+        assertBusy(() -> {\n+            ExplainLifecycleRequest explainRequest = new ExplainLifecycleRequest().indices(managedIndex);\n+            ExplainLifecycleResponse explainResponse = client().execute(ExplainLifecycleAction.INSTANCE,\n+                explainRequest).get();\n+\n+            IndexLifecycleExplainResponse indexLifecycleExplainResponse = explainResponse.getIndexResponses().get(managedIndex);\n+            assertThat(indexLifecycleExplainResponse.getPhase(), is(\"cold\"));\n+            assertThat(indexLifecycleExplainResponse.getStep(), is(DataTierMigrationRoutedStep.NAME));\n+        });\n+\n+        logger.info(\"starting cold data node\");\n+        internalCluster().startNode(coldNode(Settings.EMPTY));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0636d0ec5f82435d95b794a6ca4bedf31d40db99"}, "originalPosition": 134}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "500a275e3a6f572cde128f96dd4d2e665ca8d2a8", "author": {"user": {"login": "elasticmachine", "name": "Elastic Machine"}}, "url": "https://github.com/elastic/elasticsearch/commit/500a275e3a6f572cde128f96dd4d2e665ca8d2a8", "committedDate": "2020-09-16T09:28:41Z", "message": "Merge branch 'master' into ilm-migrate-data-between-tiers"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9b90555a1689bd2fbc9c8fc992f8a106dfa87c02", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/9b90555a1689bd2fbc9c8fc992f8a106dfa87c02", "committedDate": "2020-09-16T10:39:09Z", "message": "Remove frozen phase from HLRC"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eddd223b8ab42eece98285cf49006a506495137d", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/eddd223b8ab42eece98285cf49006a506495137d", "committedDate": "2020-09-16T11:31:54Z", "message": "Execute the allocate action before migrate"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d733d729f08dba4a9011a7fd9d050b6985b2cb06", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/d733d729f08dba4a9011a7fd9d050b6985b2cb06", "committedDate": "2020-09-16T12:41:06Z", "message": "Adjust test to wait until ILM completes in the cold phase"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4da7379208c144a1f6e97dc4fd2511886d31d502", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/4da7379208c144a1f6e97dc4fd2511886d31d502", "committedDate": "2020-09-16T13:18:48Z", "message": "Log and exception messages"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "be17159a15937f46ffe769995a5428a3520683c6", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/be17159a15937f46ffe769995a5428a3520683c6", "committedDate": "2020-09-16T16:08:07Z", "message": "Merge branch 'master' into ilm-migrate-data-between-tiers"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg5ODkyMjM1", "url": "https://github.com/elastic/elasticsearch/pull/61377#pullrequestreview-489892235", "createdAt": "2020-09-16T18:13:39Z", "commit": {"oid": "be17159a15937f46ffe769995a5428a3520683c6"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxODoxMzozOVrOHS8mJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxODoxMzozOVrOHS8mJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYyOTIyMg==", "bodyText": "I think this needs to incorporate super.hashCode() or else the hash code will be the same regardless of stepkeys", "url": "https://github.com/elastic/elasticsearch/pull/61377#discussion_r489629222", "createdAt": "2020-09-16T18:13:39Z", "author": {"login": "dakrone"}, "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/DataTierMigrationRoutedStep.java", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.support.ActiveShardCount;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.node.DiscoveryNodeRole;\n+import org.elasticsearch.cluster.routing.allocation.decider.AllocationDeciders;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.Index;\n+import org.elasticsearch.xpack.cluster.routing.allocation.DataTierAllocationDecider;\n+import org.elasticsearch.xpack.core.ilm.step.info.AllocationInfo;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+import static org.elasticsearch.cluster.node.DiscoveryNodeRole.DATA_ROLE;\n+import static org.elasticsearch.xpack.cluster.routing.allocation.DataTierAllocationDecider.INDEX_ROUTING_INCLUDE_SETTING;\n+import static org.elasticsearch.xpack.core.ilm.AllocationRoutedStep.getPendingAllocations;\n+\n+/**\n+ * Checks whether all shards have been correctly routed in response to updating the allocation rules for an index in order\n+ * to migrate the index to a new tier.\n+ */\n+public class DataTierMigrationRoutedStep extends ClusterStateWaitStep {\n+    public static final String NAME = \"check-migration\";\n+\n+    private static final Logger logger = LogManager.getLogger(DataTierMigrationRoutedStep.class);\n+\n+    private static final Set<Setting<?>> ALL_CLUSTER_SETTINGS;\n+\n+    static {\n+        Set<Setting<?>> allSettings = new HashSet<>(ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+        allSettings.add(DataTierAllocationDecider.CLUSTER_ROUTING_REQUIRE_SETTING);\n+        allSettings.add(DataTierAllocationDecider.CLUSTER_ROUTING_INCLUDE_SETTING);\n+        allSettings.add(DataTierAllocationDecider.CLUSTER_ROUTING_EXCLUDE_SETTING);\n+        ALL_CLUSTER_SETTINGS = allSettings;\n+    }\n+\n+    private static final AllocationDeciders ALLOCATION_DECIDERS = new AllocationDeciders(\n+        List.of(\n+            new DataTierAllocationDecider(new ClusterSettings(Settings.EMPTY, ALL_CLUSTER_SETTINGS))\n+        )\n+    );\n+\n+    DataTierMigrationRoutedStep(StepKey key, StepKey nextStepKey) {\n+        super(key, nextStepKey);\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public Result isConditionMet(Index index, ClusterState clusterState) {\n+        IndexMetadata idxMeta = clusterState.metadata().index(index);\n+        if (idxMeta == null) {\n+            // Index must have been since deleted, ignore it\n+            logger.debug(\"[{}] lifecycle action for index [{}] executed but index no longer exists\", getKey().getAction(), index.getName());\n+            return new Result(false, null);\n+        }\n+        String destinationTier = INDEX_ROUTING_INCLUDE_SETTING.get(idxMeta.getSettings());\n+        if (ActiveShardCount.ALL.enoughShardsActive(clusterState, index.getName()) == false) {\n+            logger.debug(\"[{}] migration of index [{}] to the [{}] tier cannot progress, as not all shards are active\",\n+                    getKey().getAction(), index.getName(), destinationTier);\n+            return new Result(false, AllocationInfo.waitingForActiveShardsAllocationInfo(idxMeta.getNumberOfReplicas()));\n+        }\n+\n+        int allocationPendingAllShards = getPendingAllocations(index, ALLOCATION_DECIDERS, clusterState);\n+\n+        if (allocationPendingAllShards > 0) {\n+            boolean targetTierNodeFound = false;\n+            for (DiscoveryNode node : clusterState.nodes()) {\n+                for (DiscoveryNodeRole role : node.getRoles()) {\n+                    if (role.roleName().equals(DATA_ROLE.roleName()) || role.roleName().equals(destinationTier)) {\n+                        targetTierNodeFound = true;\n+                        break;\n+                    }\n+                }\n+            }\n+            String statusMessage = String.format(Locale.ROOT, \"%s lifecycle action [%s] waiting for [%s] shards to be moved to the [%s] \" +\n+                    \"tier\" + (targetTierNodeFound ? \"\" : \" but there are currently no [%s] nodes in the cluster\"),\n+                index, getKey().getAction(), allocationPendingAllShards, destinationTier, destinationTier);\n+            logger.debug(statusMessage);\n+            return new Result(false, new AllocationInfo(idxMeta.getNumberOfReplicas(), allocationPendingAllShards, true, statusMessage));\n+        } else {\n+            logger.debug(\"[{}] migration of index [{}] to tier [{}] complete\", getKey().getAction(), index, destinationTier);\n+            return new Result(true, null);\n+        }\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return 711;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be17159a15937f46ffe769995a5428a3520683c6"}, "originalPosition": 106}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b83771856c3d1e8915539e1f196a5cfd8ef018d1", "author": {"user": {"login": "andreidan", "name": "Andrei Dan"}}, "url": "https://github.com/elastic/elasticsearch/commit/b83771856c3d1e8915539e1f196a5cfd8ef018d1", "committedDate": "2020-09-17T08:55:56Z", "message": "Drop equals and hashcode (in favour of the ones in Step)"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4808, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}