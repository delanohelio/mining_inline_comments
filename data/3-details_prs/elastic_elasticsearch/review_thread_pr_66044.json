{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM0NTgyNzgy", "number": 66044, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNDozNzoxMlrOFC9RqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNDo0MTo1OFrOFC9bsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NjQ1NDE2OnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/elasticsearch/search/aggregations/AggregationCollectorTests.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNDozNzoxMlrOICX1YA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNDozNzoxMlrOICX1YA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM1ODU2MA==", "bodyText": "Oh, hey, moving this off of ESSingleNodeTestCase is a win!", "url": "https://github.com/elastic/elasticsearch/pull/66044#discussion_r539358560", "createdAt": "2020-12-09T14:37:12Z", "author": {"login": "not-napoleon"}, "path": "server/src/test/java/org/elasticsearch/search/aggregations/AggregationCollectorTests.java", "diffHunk": "@@ -19,54 +19,109 @@\n \n package org.elasticsearch.search.aggregations;\n \n-import org.elasticsearch.common.xcontent.XContentParser;\n-import org.elasticsearch.common.xcontent.json.JsonXContent;\n-import org.elasticsearch.index.IndexService;\n-import org.elasticsearch.search.aggregations.MultiBucketConsumerService.MultiBucketConsumer;\n-import org.elasticsearch.search.aggregations.support.AggregationContext.ProductionAggregationContext;\n-import org.elasticsearch.test.ESSingleNodeTestCase;\n+import org.apache.lucene.index.DirectoryReader;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.RandomIndexWriter;\n+import org.apache.lucene.search.IndexSearcher;\n+import org.apache.lucene.store.Directory;\n+import org.elasticsearch.index.mapper.KeywordFieldMapper.KeywordFieldType;\n+import org.elasticsearch.script.AggregationScript;\n+import org.elasticsearch.script.Script;\n+import org.elasticsearch.script.ScriptService;\n+import org.elasticsearch.search.aggregations.bucket.terms.TermsAggregationBuilder;\n+import org.elasticsearch.search.aggregations.metrics.TopHitsAggregationBuilder;\n \n import java.io.IOException;\n \n+import static org.mockito.Matchers.any;\n import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n \n-public class AggregationCollectorTests extends ESSingleNodeTestCase {\n+public class AggregationCollectorTests extends AggregatorTestCase {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce63f67d7609b8da8bca1fbe44ef26e3ecb1eb05"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NjQ3OTg0OnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/elasticsearch/search/aggregations/AggregationCollectorTests.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNDo0MTo1OFrOICYE3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxODozMzoxM1rOICjb3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM2MjUyNA==", "bodyText": "I am not a fan of this method of documenting tests. CamelCase sentences are hard to read, and with many similar names it's easy to miss the differences between two of them.  Maybe just name this something like testSubScriptNoScore and add a javadoc noting what it's intended to test?  Same for the other very long test names.", "url": "https://github.com/elastic/elasticsearch/pull/66044#discussion_r539362524", "createdAt": "2020-12-09T14:41:58Z", "author": {"login": "not-napoleon"}, "path": "server/src/test/java/org/elasticsearch/search/aggregations/AggregationCollectorTests.java", "diffHunk": "@@ -19,54 +19,109 @@\n \n package org.elasticsearch.search.aggregations;\n \n-import org.elasticsearch.common.xcontent.XContentParser;\n-import org.elasticsearch.common.xcontent.json.JsonXContent;\n-import org.elasticsearch.index.IndexService;\n-import org.elasticsearch.search.aggregations.MultiBucketConsumerService.MultiBucketConsumer;\n-import org.elasticsearch.search.aggregations.support.AggregationContext.ProductionAggregationContext;\n-import org.elasticsearch.test.ESSingleNodeTestCase;\n+import org.apache.lucene.index.DirectoryReader;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.RandomIndexWriter;\n+import org.apache.lucene.search.IndexSearcher;\n+import org.apache.lucene.store.Directory;\n+import org.elasticsearch.index.mapper.KeywordFieldMapper.KeywordFieldType;\n+import org.elasticsearch.script.AggregationScript;\n+import org.elasticsearch.script.Script;\n+import org.elasticsearch.script.ScriptService;\n+import org.elasticsearch.search.aggregations.bucket.terms.TermsAggregationBuilder;\n+import org.elasticsearch.search.aggregations.metrics.TopHitsAggregationBuilder;\n \n import java.io.IOException;\n \n+import static org.mockito.Matchers.any;\n import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n \n-public class AggregationCollectorTests extends ESSingleNodeTestCase {\n+public class AggregationCollectorTests extends AggregatorTestCase {\n+    public void testTermsDoesntNeedScores() throws IOException {\n+        assertFalse(needsScores(termsBuilder().field(\"f\")));\n+    }\n+\n+    public void testSubTermsDoesntNeedScores() throws IOException {\n+        assertFalse(needsScores(termsBuilder().field(\"f\").subAggregation(new TermsAggregationBuilder(\"i\").field(\"f\"))));\n+    }\n+\n+    public void testScriptDoesntNeedScoresIfScriptDoesntNeedScores() throws IOException {\n+        assertFalse(needsScores(termsBuilder().script(new Script(\"no_scores\"))));\n+    }\n+\n+    public void testScriptNeedsScoresIfScriptNeedsScores() throws IOException {\n+        assertTrue(needsScores(termsBuilder().script(new Script(\"with_scores\"))));\n+    }\n \n-    public void testNeedsScores() throws Exception {\n-        IndexService index = createIndex(\"idx\");\n-        client().prepareIndex(\"idx\").setId(\"1\").setSource(\"f\", 5).execute().get();\n-        client().admin().indices().prepareRefresh(\"idx\").get();\n+    public void testSubScriptDoesntNeedScoresIfSubScriptDoesntNeedScores() throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce63f67d7609b8da8bca1fbe44ef26e3ecb1eb05"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU0ODYzOA==", "bodyText": "I like having a test for each thing. I could go either way on the long names. I'll change them.", "url": "https://github.com/elastic/elasticsearch/pull/66044#discussion_r539548638", "createdAt": "2020-12-09T18:33:13Z", "author": {"login": "nik9000"}, "path": "server/src/test/java/org/elasticsearch/search/aggregations/AggregationCollectorTests.java", "diffHunk": "@@ -19,54 +19,109 @@\n \n package org.elasticsearch.search.aggregations;\n \n-import org.elasticsearch.common.xcontent.XContentParser;\n-import org.elasticsearch.common.xcontent.json.JsonXContent;\n-import org.elasticsearch.index.IndexService;\n-import org.elasticsearch.search.aggregations.MultiBucketConsumerService.MultiBucketConsumer;\n-import org.elasticsearch.search.aggregations.support.AggregationContext.ProductionAggregationContext;\n-import org.elasticsearch.test.ESSingleNodeTestCase;\n+import org.apache.lucene.index.DirectoryReader;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.RandomIndexWriter;\n+import org.apache.lucene.search.IndexSearcher;\n+import org.apache.lucene.store.Directory;\n+import org.elasticsearch.index.mapper.KeywordFieldMapper.KeywordFieldType;\n+import org.elasticsearch.script.AggregationScript;\n+import org.elasticsearch.script.Script;\n+import org.elasticsearch.script.ScriptService;\n+import org.elasticsearch.search.aggregations.bucket.terms.TermsAggregationBuilder;\n+import org.elasticsearch.search.aggregations.metrics.TopHitsAggregationBuilder;\n \n import java.io.IOException;\n \n+import static org.mockito.Matchers.any;\n import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n \n-public class AggregationCollectorTests extends ESSingleNodeTestCase {\n+public class AggregationCollectorTests extends AggregatorTestCase {\n+    public void testTermsDoesntNeedScores() throws IOException {\n+        assertFalse(needsScores(termsBuilder().field(\"f\")));\n+    }\n+\n+    public void testSubTermsDoesntNeedScores() throws IOException {\n+        assertFalse(needsScores(termsBuilder().field(\"f\").subAggregation(new TermsAggregationBuilder(\"i\").field(\"f\"))));\n+    }\n+\n+    public void testScriptDoesntNeedScoresIfScriptDoesntNeedScores() throws IOException {\n+        assertFalse(needsScores(termsBuilder().script(new Script(\"no_scores\"))));\n+    }\n+\n+    public void testScriptNeedsScoresIfScriptNeedsScores() throws IOException {\n+        assertTrue(needsScores(termsBuilder().script(new Script(\"with_scores\"))));\n+    }\n \n-    public void testNeedsScores() throws Exception {\n-        IndexService index = createIndex(\"idx\");\n-        client().prepareIndex(\"idx\").setId(\"1\").setSource(\"f\", 5).execute().get();\n-        client().admin().indices().prepareRefresh(\"idx\").get();\n+    public void testSubScriptDoesntNeedScoresIfSubScriptDoesntNeedScores() throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM2MjUyNA=="}, "originalCommit": {"oid": "ce63f67d7609b8da8bca1fbe44ef26e3ecb1eb05"}, "originalPosition": 50}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4771, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}