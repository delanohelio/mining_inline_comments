{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY2ODc0OTQx", "number": 51423, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxNTo0ODoxMFrODahzDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxNzoyMzozMFrODajkzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5MTQzMzA4OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/rest/action/RestCancellableNodeClient.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxNTo0ODoxMFrOFhh6pg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxNTo0ODoxMFrOFhh6pg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDcwMzAxNA==", "bodyText": "nit: this might be abusive streams a bit, let's do a for loop?", "url": "https://github.com/elastic/elasticsearch/pull/51423#discussion_r370703014", "createdAt": "2020-01-24T15:48:10Z", "author": {"login": "jpountz"}, "path": "server/src/main/java/org/elasticsearch/rest/action/RestCancellableNodeClient.java", "diffHunk": "@@ -111,35 +144,27 @@ void maybeRegisterChannel(HttpChannel httpChannel) {\n         synchronized void registerTask(TaskHolder taskHolder, TaskId taskId) {\n             taskHolder.taskId = taskId;\n             if (taskHolder.completed == false) {\n-                this.taskIds.add(taskId);\n+                this.tasks.add(taskId);\n             }\n         }\n \n         synchronized void unregisterTask(TaskHolder taskHolder) {\n             if (taskHolder.taskId != null) {\n-                this.taskIds.remove(taskHolder.taskId);\n+                this.tasks.remove(taskHolder.taskId);\n             }\n             taskHolder.completed = true;\n         }\n \n         @Override\n-        public synchronized void onResponse(Void aVoid) {\n-            //When the channel gets closed it won't be reused: we can remove it from the map and forget about it.\n-            CloseListener closeListener = httpChannels.remove(channel.get());\n-            assert closeListener != null : \"channel not found in the map of tracked channels\";\n-            for (TaskId taskId : taskIds) {\n-                ThreadContext threadContext = client.threadPool().getThreadContext();\n-                try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {\n-                    // we stash any context here since this is an internal execution and should not leak any existing context information\n-                    threadContext.markAsSystemContext();\n-                    ContextPreservingActionListener<CancelTasksResponse> contextPreservingListener = new ContextPreservingActionListener<>(\n-                        threadContext.newRestorableContext(false),  ActionListener.wrap(r -> {}, e -> {}));\n-                    CancelTasksRequest cancelTasksRequest = new CancelTasksRequest();\n-                    cancelTasksRequest.setTaskId(taskId);\n-                    //We don't wait for cancel tasks to come back. Task cancellation is just best effort.\n-                    client.admin().cluster().cancelTasks(cancelTasksRequest, contextPreservingListener);\n-                }\n+        public void onResponse(Void aVoid) {\n+            final List<TaskId> toCancel;\n+            synchronized (this) {\n+                // when the channel gets closed it won't be reused: we can remove it from the map and forget about it.\n+                CloseListener closeListener = httpChannels.remove(channel.get());\n+                assert closeListener != null : \"channel not found in the map of tracked channels\";\n+                toCancel = new ArrayList<>(tasks);\n             }\n+            toCancel.stream().forEach(taskId -> cancelTask(taskId));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a279a9e90bddcf043892ae4fc2362628da3db07b"}, "originalPosition": 182}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5MTQzNzQzOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/rest/action/RestCancellableNodeClient.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxNTo0OTozM1rOFhh9dg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxNTo0OTozM1rOFhh9dg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDcwMzczNA==", "bodyText": "we don't need to protect httpChannels so we could move the synchronized keyword two lines below?", "url": "https://github.com/elastic/elasticsearch/pull/51423#discussion_r370703734", "createdAt": "2020-01-24T15:49:33Z", "author": {"login": "jpountz"}, "path": "server/src/main/java/org/elasticsearch/rest/action/RestCancellableNodeClient.java", "diffHunk": "@@ -111,35 +144,27 @@ void maybeRegisterChannel(HttpChannel httpChannel) {\n         synchronized void registerTask(TaskHolder taskHolder, TaskId taskId) {\n             taskHolder.taskId = taskId;\n             if (taskHolder.completed == false) {\n-                this.taskIds.add(taskId);\n+                this.tasks.add(taskId);\n             }\n         }\n \n         synchronized void unregisterTask(TaskHolder taskHolder) {\n             if (taskHolder.taskId != null) {\n-                this.taskIds.remove(taskHolder.taskId);\n+                this.tasks.remove(taskHolder.taskId);\n             }\n             taskHolder.completed = true;\n         }\n \n         @Override\n-        public synchronized void onResponse(Void aVoid) {\n-            //When the channel gets closed it won't be reused: we can remove it from the map and forget about it.\n-            CloseListener closeListener = httpChannels.remove(channel.get());\n-            assert closeListener != null : \"channel not found in the map of tracked channels\";\n-            for (TaskId taskId : taskIds) {\n-                ThreadContext threadContext = client.threadPool().getThreadContext();\n-                try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {\n-                    // we stash any context here since this is an internal execution and should not leak any existing context information\n-                    threadContext.markAsSystemContext();\n-                    ContextPreservingActionListener<CancelTasksResponse> contextPreservingListener = new ContextPreservingActionListener<>(\n-                        threadContext.newRestorableContext(false),  ActionListener.wrap(r -> {}, e -> {}));\n-                    CancelTasksRequest cancelTasksRequest = new CancelTasksRequest();\n-                    cancelTasksRequest.setTaskId(taskId);\n-                    //We don't wait for cancel tasks to come back. Task cancellation is just best effort.\n-                    client.admin().cluster().cancelTasks(cancelTasksRequest, contextPreservingListener);\n-                }\n+        public void onResponse(Void aVoid) {\n+            final List<TaskId> toCancel;\n+            synchronized (this) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a279a9e90bddcf043892ae4fc2362628da3db07b"}, "originalPosition": 176}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5MTQ1MDg5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/rest/action/RestCancellableNodeClient.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxNTo1MzozNlrOFhiF_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxNTo1MzozNlrOFhiF_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDcwNTkxOA==", "bodyText": "I think it needs to be synchronized?", "url": "https://github.com/elastic/elasticsearch/pull/51423#discussion_r370705918", "createdAt": "2020-01-24T15:53:36Z", "author": {"login": "jpountz"}, "path": "server/src/main/java/org/elasticsearch/rest/action/RestCancellableNodeClient.java", "diffHunk": "@@ -77,25 +107,28 @@ public void onFailure(Exception e) {\n                     }\n                 }\n             });\n-        closeListener.registerTask(taskHolder, new TaskId(client.getLocalNodeId(), task.getId()));\n+        final TaskId taskId = new TaskId(client.getLocalNodeId(), task.getId());\n+        closeListener.registerTask(taskHolder, taskId);\n         closeListener.maybeRegisterChannel(httpChannel);\n     }\n \n-    public int getNumChannels() {\n-        return httpChannels.size();\n+    private void cancelTask(TaskId taskId) {\n+        CancelTasksRequest req = new CancelTasksRequest()\n+            .setTaskId(taskId)\n+            .setReason(\"channel closed\");\n+        // force the origin to execute the cancellation as a system user\n+        new OriginSettingClient(client, TASKS_ORIGIN).admin().cluster().cancelTasks(req, ActionListener.wrap(() -> {}));\n     }\n \n-    final class CloseListener implements ActionListener<Void> {\n-        private final Client client;\n+    private class CloseListener implements ActionListener<Void> {\n         private final AtomicReference<HttpChannel> channel = new AtomicReference<>();\n-        private final Set<TaskId> taskIds = new HashSet<>();\n+        private final Set<TaskId> tasks = new HashSet<>();\n \n-        CloseListener(Client client) {\n-            this.client = client;\n+        CloseListener() {\n         }\n \n         int getNumTasks() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a279a9e90bddcf043892ae4fc2362628da3db07b"}, "originalPosition": 134}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5MTcyNDMxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/elasticsearch/rest/action/RestCancellableNodeClient.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxNzoyMzozMFrOFhkx0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxNzoyMzozMFrOFhkx0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc0OTkwNw==", "bodyText": "should we assert that channel.get() is not null?", "url": "https://github.com/elastic/elasticsearch/pull/51423#discussion_r370749907", "createdAt": "2020-01-24T17:23:30Z", "author": {"login": "jpountz"}, "path": "server/src/main/java/org/elasticsearch/rest/action/RestCancellableNodeClient.java", "diffHunk": "@@ -111,35 +144,27 @@ void maybeRegisterChannel(HttpChannel httpChannel) {\n         synchronized void registerTask(TaskHolder taskHolder, TaskId taskId) {\n             taskHolder.taskId = taskId;\n             if (taskHolder.completed == false) {\n-                this.taskIds.add(taskId);\n+                this.tasks.add(taskId);\n             }\n         }\n \n         synchronized void unregisterTask(TaskHolder taskHolder) {\n             if (taskHolder.taskId != null) {\n-                this.taskIds.remove(taskHolder.taskId);\n+                this.tasks.remove(taskHolder.taskId);\n             }\n             taskHolder.completed = true;\n         }\n \n         @Override\n-        public synchronized void onResponse(Void aVoid) {\n-            //When the channel gets closed it won't be reused: we can remove it from the map and forget about it.\n-            CloseListener closeListener = httpChannels.remove(channel.get());\n-            assert closeListener != null : \"channel not found in the map of tracked channels\";\n-            for (TaskId taskId : taskIds) {\n-                ThreadContext threadContext = client.threadPool().getThreadContext();\n-                try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {\n-                    // we stash any context here since this is an internal execution and should not leak any existing context information\n-                    threadContext.markAsSystemContext();\n-                    ContextPreservingActionListener<CancelTasksResponse> contextPreservingListener = new ContextPreservingActionListener<>(\n-                        threadContext.newRestorableContext(false),  ActionListener.wrap(r -> {}, e -> {}));\n-                    CancelTasksRequest cancelTasksRequest = new CancelTasksRequest();\n-                    cancelTasksRequest.setTaskId(taskId);\n-                    //We don't wait for cancel tasks to come back. Task cancellation is just best effort.\n-                    client.admin().cluster().cancelTasks(cancelTasksRequest, contextPreservingListener);\n-                }\n+        public void onResponse(Void aVoid) {\n+            final List<TaskId> toCancel;\n+            synchronized (this) {\n+                // when the channel gets closed it won't be reused: we can remove it from the map and forget about it.\n+                CloseListener closeListener = httpChannels.remove(channel.get());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a279a9e90bddcf043892ae4fc2362628da3db07b"}, "originalPosition": 178}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4365, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}