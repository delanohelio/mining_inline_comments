{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAyNjU2MjIy", "number": 55114, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwMjo1Njo0MFrODxddjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQwODoxMDowOFrOD1pnGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMTg5NTE5OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/TokenService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwMjo1Njo0MFrOGE8Wgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwMjo1Njo0MFrOGE8Wgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgzNjI5MQ==", "bodyText": "Maybe extract this logic into a consumer? It can be reused for the onReponse part as well.", "url": "https://github.com/elastic/elasticsearch/pull/55114#discussion_r407836291", "createdAt": "2020-04-14T02:56:40Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/TokenService.java", "diffHunk": "@@ -1092,10 +1094,56 @@ void decryptAndReturnSupersedingTokens(String refreshToken, RefreshTokenStatus r\n                 logger.warn(\"Decrypted tokens string is not correctly formatted\");\n                 listener.onFailure(invalidGrantException(\"could not refresh the requested token\"));\n             } else {\n-                listener.onResponse(new Tuple<>(prependVersionAndEncodeAccessToken(refreshTokenStatus.getVersion(), decryptedTokens[0]),\n-                    prependVersionAndEncodeRefreshToken(refreshTokenStatus.getVersion(), decryptedTokens[1])));\n+                // We expect this to protect against race conditions that manifest within few ms\n+                final Iterator<TimeValue> backoff = BackoffPolicy.exponentialBackoff(TimeValue.timeValueMillis(10), 8).iterator();\n+                final String tokenDocId = getTokenDocumentId(hashTokenString(decryptedTokens[0]));\n+                final Consumer<Exception> onFailure = ex ->\n+                    listener.onFailure(traceLog(\"decrypt and get superseding token\", tokenDocId, ex));\n+                getTokenDocAsync(tokenDocId, tokensIndex, new ActionListener<>() {\n+                    @Override\n+                    public void onResponse(GetResponse response) {\n+                        if (response.isExists()) {\n+                            try {\n+                                listener.onResponse(\n+                                    new Tuple<>(prependVersionAndEncodeAccessToken(refreshTokenStatus.getVersion(), decryptedTokens[0]),\n+                                        prependVersionAndEncodeRefreshToken(refreshTokenStatus.getVersion(), decryptedTokens[1])));\n+                            } catch (GeneralSecurityException | IOException e) {\n+                                logger.warn(\"Could not format stored superseding token values\", e);\n+                                onFailure.accept(invalidGrantException(\"could not refresh the requested token\"));\n+                            }\n+                        } else {\n+                            if (backoff.hasNext()) {\n+                                logger.trace(\"could not get token document [{}] that should have been created, retrying\", tokenDocId);\n+                                client.threadPool().schedule(\n+                                    () -> getTokenDocAsync(tokenDocId, tokensIndex, this),\n+                                    backoff.next(), GENERIC);\n+                            } else {\n+                                logger.warn(\"could not get token document [{}] that should have been created after all retries\",\n+                                    tokenDocId);\n+                                onFailure.accept(invalidGrantException(\"could not refresh the requested token\"));\n+                            }\n+                        }\n+                    }\n+\n+                    @Override\n+                    public void onFailure(Exception e) {\n+                        if (isShardNotAvailableException(e)) {\n+                            if (backoff.hasNext()) {\n+                                logger.info(\"could not get token document [{}] that should have been created, retrying\", tokenDocId);\n+                                client.threadPool().schedule(() -> getTokenDocAsync(tokenDocId, tokensIndex, this),\n+                                    backoff.next(), GENERIC);\n+                            } else {\n+                                logger.warn(\"could not get token document [{}] that should have been created after all retries\",\n+                                    tokenDocId);\n+                                onFailure.accept(invalidGrantException(\"could not refresh the requested token\"));\n+                            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c62ff216201372444f70bce0ce8f221f5b87c613"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMTkwMjU0OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/TokenAuthIntegTests.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwMzowMDoxNVrOGE8axw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwMzowMDoxNVrOGE8axw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgzNzM4Mw==", "bodyText": "anot(contccess_token - probably some random extra keystrokes?", "url": "https://github.com/elastic/elasticsearch/pull/55114#discussion_r407837383", "createdAt": "2020-04-14T03:00:15Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/TokenAuthIntegTests.java", "diffHunk": "@@ -387,8 +386,11 @@ public void testRefreshingMultipleTimesWithinWindowSucceeds() throws Exception {\n         }\n         completedLatch.await();\n         assertThat(failed.get(), equalTo(false));\n-        // Assert that we only ever got one access_token/refresh_token pair\n-        assertThat(tokens.stream().distinct().collect(Collectors.toList()).size(), equalTo(1));\n+        // Assert that we only ever got one anot(contccess_token/refresh_token pair", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c62ff216201372444f70bce0ce8f221f5b87c613"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMTkxMzM1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/TokenAuthIntegTests.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwMzowNjoxMFrOGE8g9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwNDoxNjoxOVrOGE9mCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgzODk2Nw==", "bodyText": "nits: alternatively, maybe we could verify all statuses are OK since getAuthenticationResponseCode always returns OK when no exception is thrown. It feels more precise.", "url": "https://github.com/elastic/elasticsearch/pull/55114#discussion_r407838967", "createdAt": "2020-04-14T03:06:10Z", "author": {"login": "ywangd"}, "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/TokenAuthIntegTests.java", "diffHunk": "@@ -387,8 +386,11 @@ public void testRefreshingMultipleTimesWithinWindowSucceeds() throws Exception {\n         }\n         completedLatch.await();\n         assertThat(failed.get(), equalTo(false));\n-        // Assert that we only ever got one access_token/refresh_token pair\n-        assertThat(tokens.stream().distinct().collect(Collectors.toList()).size(), equalTo(1));\n+        // Assert that we only ever got one anot(contccess_token/refresh_token pair\n+        assertThat((int) tokens.stream().distinct().count(), equalTo(1));\n+        // Assert that all requests from all threads could authenticate at the time they received the access token\n+        // see: https://github.com/elastic/elasticsearch/issues/54289\n+        assertThat(authStatuses, not(hasItem(RestStatus.UNAUTHORIZED)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c62ff216201372444f70bce0ce8f221f5b87c613"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg1NjY0OA==", "bodyText": "I was thinking in terms of testing for the bug this is solving but these all should be OK so I see your point, will address", "url": "https://github.com/elastic/elasticsearch/pull/55114#discussion_r407856648", "createdAt": "2020-04-14T04:16:19Z", "author": {"login": "jkakavas"}, "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/TokenAuthIntegTests.java", "diffHunk": "@@ -387,8 +386,11 @@ public void testRefreshingMultipleTimesWithinWindowSucceeds() throws Exception {\n         }\n         completedLatch.await();\n         assertThat(failed.get(), equalTo(false));\n-        // Assert that we only ever got one access_token/refresh_token pair\n-        assertThat(tokens.stream().distinct().collect(Collectors.toList()).size(), equalTo(1));\n+        // Assert that we only ever got one anot(contccess_token/refresh_token pair\n+        assertThat((int) tokens.stream().distinct().count(), equalTo(1));\n+        // Assert that all requests from all threads could authenticate at the time they received the access token\n+        // see: https://github.com/elastic/elasticsearch/issues/54289\n+        assertThat(authStatuses, not(hasItem(RestStatus.UNAUTHORIZED)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgzODk2Nw=="}, "originalCommit": {"oid": "c62ff216201372444f70bce0ce8f221f5b87c613"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3NTgyODc1OnYy", "diffSide": "RIGHT", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/TokenService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQwODoxMDowOFrOGLL1nA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQwODo0MjozNFrOGLNF4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM4MTQ2OA==", "bodyText": "I think this, and the call above should explicitly not fetch the source since we only care about an exists check.", "url": "https://github.com/elastic/elasticsearch/pull/55114#discussion_r414381468", "createdAt": "2020-04-24T08:10:08Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/TokenService.java", "diffHunk": "@@ -1092,10 +1095,51 @@ void decryptAndReturnSupersedingTokens(String refreshToken, RefreshTokenStatus r\n                 logger.warn(\"Decrypted tokens string is not correctly formatted\");\n                 listener.onFailure(invalidGrantException(\"could not refresh the requested token\"));\n             } else {\n-                listener.onResponse(new Tuple<>(prependVersionAndEncodeAccessToken(refreshTokenStatus.getVersion(), decryptedTokens[0]),\n-                    prependVersionAndEncodeRefreshToken(refreshTokenStatus.getVersion(), decryptedTokens[1])));\n+                // We expect this to protect against race conditions that manifest within few ms\n+                final Iterator<TimeValue> backoff = BackoffPolicy.exponentialBackoff(TimeValue.timeValueMillis(10), 8).iterator();\n+                final String tokenDocId = getTokenDocumentId(hashTokenString(decryptedTokens[0]));\n+                final Consumer<Exception> onFailure = ex ->\n+                    listener.onFailure(traceLog(\"decrypt and get superseding token\", tokenDocId, ex));\n+                final Consumer<ActionListener<GetResponse>> maybeRetryGet = actionListener -> {\n+                    if (backoff.hasNext()) {\n+                        logger.info(\"could not get token document [{}] that should have been created, retrying\", tokenDocId);\n+                        client.threadPool().schedule(\n+                            () -> getTokenDocAsync(tokenDocId, tokensIndex, actionListener),\n+                            backoff.next(), GENERIC);\n+                    } else {\n+                        logger.warn(\"could not get token document [{}] that should have been created after all retries\",\n+                            tokenDocId);\n+                        onFailure.accept(invalidGrantException(\"could not refresh the requested token\"));\n+                    }\n+                };\n+                getTokenDocAsync(tokenDocId, tokensIndex, new ActionListener<>() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13c21b2dc478de3227d11064dd174dccc63674ce"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQwMjAxNw==", "bodyText": "Yes, agreed ! Thanks", "url": "https://github.com/elastic/elasticsearch/pull/55114#discussion_r414402017", "createdAt": "2020-04-24T08:42:34Z", "author": {"login": "jkakavas"}, "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/TokenService.java", "diffHunk": "@@ -1092,10 +1095,51 @@ void decryptAndReturnSupersedingTokens(String refreshToken, RefreshTokenStatus r\n                 logger.warn(\"Decrypted tokens string is not correctly formatted\");\n                 listener.onFailure(invalidGrantException(\"could not refresh the requested token\"));\n             } else {\n-                listener.onResponse(new Tuple<>(prependVersionAndEncodeAccessToken(refreshTokenStatus.getVersion(), decryptedTokens[0]),\n-                    prependVersionAndEncodeRefreshToken(refreshTokenStatus.getVersion(), decryptedTokens[1])));\n+                // We expect this to protect against race conditions that manifest within few ms\n+                final Iterator<TimeValue> backoff = BackoffPolicy.exponentialBackoff(TimeValue.timeValueMillis(10), 8).iterator();\n+                final String tokenDocId = getTokenDocumentId(hashTokenString(decryptedTokens[0]));\n+                final Consumer<Exception> onFailure = ex ->\n+                    listener.onFailure(traceLog(\"decrypt and get superseding token\", tokenDocId, ex));\n+                final Consumer<ActionListener<GetResponse>> maybeRetryGet = actionListener -> {\n+                    if (backoff.hasNext()) {\n+                        logger.info(\"could not get token document [{}] that should have been created, retrying\", tokenDocId);\n+                        client.threadPool().schedule(\n+                            () -> getTokenDocAsync(tokenDocId, tokensIndex, actionListener),\n+                            backoff.next(), GENERIC);\n+                    } else {\n+                        logger.warn(\"could not get token document [{}] that should have been created after all retries\",\n+                            tokenDocId);\n+                        onFailure.accept(invalidGrantException(\"could not refresh the requested token\"));\n+                    }\n+                };\n+                getTokenDocAsync(tokenDocId, tokensIndex, new ActionListener<>() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM4MTQ2OA=="}, "originalCommit": {"oid": "13c21b2dc478de3227d11064dd174dccc63674ce"}, "originalPosition": 71}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1126, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}