{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE0MjMzNDMx", "number": 56293, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxODo0NTo0N1rOD7x60w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMDowMToxN1rOD7zg6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MDEwNDUxOnYy", "diffSide": "RIGHT", "path": "modules/lang-painless/src/main/antlr/PainlessLexer.g4", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxODo0NTo0N1rOGUUMiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxODozMzo1MlrOGU-gXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk1NTU5Mw==", "bodyText": "Why is this indented                                                             so far?", "url": "https://github.com/elastic/elasticsearch/pull/56293#discussion_r423955593", "createdAt": "2020-05-12T18:45:47Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/antlr/PainlessLexer.g4", "diffHunk": "@@ -120,23 +109,19 @@ INTEGER: ( '0' | [1-9] [0-9]* ) [lLfFdD]?;\n DECIMAL: ( '0' | [1-9] [0-9]* ) (DOT [0-9]+)? ( [eE] [+\\-]? [0-9]+ )? [fFdD]?;\n \n STRING: ( '\"' ( '\\\\\"' | '\\\\\\\\' | ~[\\\\\"] )*? '\"' ) | ( '\\'' ( '\\\\\\'' | '\\\\\\\\' | ~[\\\\'] )*? '\\'' );\n-REGEX: '/' ( '\\\\' ~'\\n' | ~('/' | '\\n') )+? '/' [cilmsUux]* { slashIsRegex() }?;\n+REGEX: '/' ( '\\\\' ~'\\n' | ~('/' | '\\n') )+? '/' [cilmsUux]* { isSlashRegex() }?;\n \n TRUE:  'true';\n FALSE: 'false';\n \n NULL: 'null';\n \n-// The predicate here allows us to remove ambiguities when\n-// dealing with types versus identifiers.  We check against\n-// the current whitelist to determine whether a token is a type\n-// or not.  Note this works by processing one character at a time\n-// and the rule is added or removed as this happens.  This is also known\n-// as \"the lexer hack.\"  See (https://en.wikipedia.org/wiki/The_lexer_hack).\n-TYPE: ID ( DOT ID )* { isType(getText()) }?;\n+PRIMITIVE: 'boolean' | 'byte' | 'short' | 'char' | 'int' | 'long' | 'float' | 'double';\n+DEF: 'def';\n+\n ID: [_a-zA-Z] [_a-zA-Z0-9]*;\n \n mode AFTER_DOT;\n \n-DOTINTEGER: ( '0' | [1-9] [0-9]* )                        -> mode(DEFAULT_MODE);\n-DOTID: [_a-zA-Z] [_a-zA-Z0-9]*                            -> mode(DEFAULT_MODE);\n+DOTINTEGER: ( '0' | [1-9] [0-9]* )                                            -> mode(DEFAULT_MODE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86fe756fc1f4760b336e42ffa922e9de1d9c61fe"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY0ODc5Nw==", "bodyText": "Fixed.", "url": "https://github.com/elastic/elasticsearch/pull/56293#discussion_r424648797", "createdAt": "2020-05-13T18:33:52Z", "author": {"login": "jdconrad"}, "path": "modules/lang-painless/src/main/antlr/PainlessLexer.g4", "diffHunk": "@@ -120,23 +109,19 @@ INTEGER: ( '0' | [1-9] [0-9]* ) [lLfFdD]?;\n DECIMAL: ( '0' | [1-9] [0-9]* ) (DOT [0-9]+)? ( [eE] [+\\-]? [0-9]+ )? [fFdD]?;\n \n STRING: ( '\"' ( '\\\\\"' | '\\\\\\\\' | ~[\\\\\"] )*? '\"' ) | ( '\\'' ( '\\\\\\'' | '\\\\\\\\' | ~[\\\\'] )*? '\\'' );\n-REGEX: '/' ( '\\\\' ~'\\n' | ~('/' | '\\n') )+? '/' [cilmsUux]* { slashIsRegex() }?;\n+REGEX: '/' ( '\\\\' ~'\\n' | ~('/' | '\\n') )+? '/' [cilmsUux]* { isSlashRegex() }?;\n \n TRUE:  'true';\n FALSE: 'false';\n \n NULL: 'null';\n \n-// The predicate here allows us to remove ambiguities when\n-// dealing with types versus identifiers.  We check against\n-// the current whitelist to determine whether a token is a type\n-// or not.  Note this works by processing one character at a time\n-// and the rule is added or removed as this happens.  This is also known\n-// as \"the lexer hack.\"  See (https://en.wikipedia.org/wiki/The_lexer_hack).\n-TYPE: ID ( DOT ID )* { isType(getText()) }?;\n+PRIMITIVE: 'boolean' | 'byte' | 'short' | 'char' | 'int' | 'long' | 'float' | 'double';\n+DEF: 'def';\n+\n ID: [_a-zA-Z] [_a-zA-Z0-9]*;\n \n mode AFTER_DOT;\n \n-DOTINTEGER: ( '0' | [1-9] [0-9]* )                        -> mode(DEFAULT_MODE);\n-DOTID: [_a-zA-Z] [_a-zA-Z0-9]*                            -> mode(DEFAULT_MODE);\n+DOTINTEGER: ( '0' | [1-9] [0-9]* )                                            -> mode(DEFAULT_MODE);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk1NTU5Mw=="}, "originalCommit": {"oid": "86fe756fc1f4760b336e42ffa922e9de1d9c61fe"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MDE3MTUzOnYy", "diffSide": "LEFT", "path": "modules/lang-painless/src/main/antlr/PainlessParser.g4", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxOTowNDoyOFrOGUU38A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxOTowNDoyOFrOGUU38A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk2NjcwNA==", "bodyText": "spaces?", "url": "https://github.com/elastic/elasticsearch/pull/56293#discussion_r423966704", "createdAt": "2020-05-12T19:04:28Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/antlr/PainlessParser.g4", "diffHunk": "@@ -87,32 +87,38 @@ declaration\n     ;\n \n decltype\n-    : TYPE (LBRACE RBRACE)*\n+    : type (LBRACE RBRACE)*\n+    ;\n+\n+type\n+    : DEF\n+    | PRIMITIVE\n+    | ID (DOT DOTID)*\n     ;\n \n declvar\n     : ID ( ASSIGN expression )?\n     ;\n \n trap\n-    : CATCH LP TYPE ID RP block\n+    : CATCH LP type ID RP block\n     ;\n \n noncondexpression\n-    :               unary                                                               # single", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86fe756fc1f4760b336e42ffa922e9de1d9c61fe"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MDMwMjA3OnYy", "diffSide": "RIGHT", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/Operation.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxOTo0MjoyNlrOGUWM5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxODozNTo1OFrOGU-k4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk4ODQ1Mg==", "bodyText": "Why is INCR and DECR removed here?", "url": "https://github.com/elastic/elasticsearch/pull/56293#discussion_r423988452", "createdAt": "2020-05-12T19:42:26Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/Operation.java", "diffHunk": "@@ -51,9 +51,7 @@\n     EQ      ( \"==\"  , \"equals\"                 ),\n     EQR     ( \"===\" , \"reference equals\"       ),\n     NE      ( \"!=\"  , \"not equals\"             ),\n-    NER     ( \"!==\" , \"reference not equals\"   ),\n-    INCR    ( \"++\"  , \"increment\"              ),\n-    DECR    ( \"--\"  , \"decrement\"              );\n+    NER     ( \"!==\" , \"reference not equals\"   );", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86fe756fc1f4760b336e42ffa922e9de1d9c61fe"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY0OTk1NQ==", "bodyText": "These are replaced with ADD/SUB and the Walker adds a constant of 1 in the appropriate places. The Painless user tree does not need to know about these natively since they are a shortcut. It only needs to know if a value from a variable being assigned to must be read from before or after the assignment.", "url": "https://github.com/elastic/elasticsearch/pull/56293#discussion_r424649955", "createdAt": "2020-05-13T18:35:58Z", "author": {"login": "jdconrad"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/Operation.java", "diffHunk": "@@ -51,9 +51,7 @@\n     EQ      ( \"==\"  , \"equals\"                 ),\n     EQR     ( \"===\" , \"reference equals\"       ),\n     NE      ( \"!=\"  , \"not equals\"             ),\n-    NER     ( \"!==\" , \"reference not equals\"   ),\n-    INCR    ( \"++\"  , \"increment\"              ),\n-    DECR    ( \"--\"  , \"decrement\"              );\n+    NER     ( \"!==\" , \"reference not equals\"   );", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk4ODQ1Mg=="}, "originalCommit": {"oid": "86fe756fc1f4760b336e42ffa922e9de1d9c61fe"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MDMxMTM3OnYy", "diffSide": "RIGHT", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/Walker.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxOTo0NTozNlrOGUWS_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxODozNjoxM1rOGU-ldA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk5MDAxMw==", "bodyText": "Why was this moved?", "url": "https://github.com/elastic/elasticsearch/pull/56293#discussion_r423990013", "createdAt": "2020-05-12T19:45:36Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/Walker.java", "diffHunk": "@@ -627,12 +629,25 @@ public ANode visitBool(BoolContext ctx) {\n         } else if (ctx.BOOLOR() != null) {\n             operation = Operation.OR;\n         } else {\n-            throw location(ctx).createError(new IllegalStateException(\"Illegal tree structure.\"));\n+            throw location(ctx).createError(new IllegalStateException(\"illegal tree structure\"));\n         }\n \n         return new EBool(location(ctx), operation, left, right);\n     }\n \n+    @Override\n+    public ANode visitElvis(ElvisContext ctx) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86fe756fc1f4760b336e42ffa922e9de1d9c61fe"}, "originalPosition": 244}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY1MDEwMA==", "bodyText": "Rules got moved around here to stay in line with the ordering in the grammar.", "url": "https://github.com/elastic/elasticsearch/pull/56293#discussion_r424650100", "createdAt": "2020-05-13T18:36:13Z", "author": {"login": "jdconrad"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/Walker.java", "diffHunk": "@@ -627,12 +629,25 @@ public ANode visitBool(BoolContext ctx) {\n         } else if (ctx.BOOLOR() != null) {\n             operation = Operation.OR;\n         } else {\n-            throw location(ctx).createError(new IllegalStateException(\"Illegal tree structure.\"));\n+            throw location(ctx).createError(new IllegalStateException(\"illegal tree structure\"));\n         }\n \n         return new EBool(location(ctx), operation, left, right);\n     }\n \n+    @Override\n+    public ANode visitElvis(ElvisContext ctx) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk5MDAxMw=="}, "originalCommit": {"oid": "86fe756fc1f4760b336e42ffa922e9de1d9c61fe"}, "originalPosition": 244}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MDM1Njk2OnYy", "diffSide": "RIGHT", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EVariable.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxOTo1ODo1NFrOGUWvSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxODo0NDowMFrOGU-3bQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk5NzI1OQ==", "bodyText": "Say you have a variable with same as package name, eg java, what happens?", "url": "https://github.com/elastic/elasticsearch/pull/56293#discussion_r423997259", "createdAt": "2020-05-12T19:58:54Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EVariable.java", "diffHunk": "@@ -43,27 +45,52 @@ public EVariable(Location location, String name) {\n \n     @Override\n     Output analyze(ClassNode classNode, ScriptRoot scriptRoot, Scope scope, Input input) {\n-        if (input.read == false && input.write == false) {\n-            throw createError(new IllegalArgumentException(\"not a statement: variable [\" + name + \"] not used\"));\n-        }\n-\n         Output output = new Output();\n+        Class<?> type = scriptRoot.getPainlessLookup().canonicalTypeNameToType(name);\n \n-        Variable variable = scope.getVariable(location, name);\n+        if (type != null)  {\n+            if (input.write) {\n+                throw createError(new IllegalArgumentException(\"invalid assignment: \" +\n+                        \"cannot write a value to a static type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"]\"));\n+            }\n \n-        if (input.write && variable.isFinal()) {\n-            throw createError(new IllegalArgumentException(\"Variable [\" + variable.getName() + \"] is read-only.\"));\n-        }\n+            if (input.read == false) {\n+                throw createError(new IllegalArgumentException(\"not a statement: \" +\n+                        \"static type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] not used\"));\n+            }\n+\n+            output.actual = type;\n+            output.isStaticType = true;\n+\n+            StaticNode staticNode = new StaticNode();\n \n-        output.actual = variable.getType();\n+            staticNode.setLocation(location);\n+            staticNode.setExpressionType(output.actual);\n \n-        VariableNode variableNode = new VariableNode();\n+            output.expressionNode = staticNode;\n+        } else if (scope.isVariableDefined(name)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86fe756fc1f4760b336e42ffa922e9de1d9c61fe"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk5Nzc2Nw==", "bodyText": "eg def java = 1; java.lang.Integer", "url": "https://github.com/elastic/elasticsearch/pull/56293#discussion_r423997767", "createdAt": "2020-05-12T19:59:52Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EVariable.java", "diffHunk": "@@ -43,27 +45,52 @@ public EVariable(Location location, String name) {\n \n     @Override\n     Output analyze(ClassNode classNode, ScriptRoot scriptRoot, Scope scope, Input input) {\n-        if (input.read == false && input.write == false) {\n-            throw createError(new IllegalArgumentException(\"not a statement: variable [\" + name + \"] not used\"));\n-        }\n-\n         Output output = new Output();\n+        Class<?> type = scriptRoot.getPainlessLookup().canonicalTypeNameToType(name);\n \n-        Variable variable = scope.getVariable(location, name);\n+        if (type != null)  {\n+            if (input.write) {\n+                throw createError(new IllegalArgumentException(\"invalid assignment: \" +\n+                        \"cannot write a value to a static type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"]\"));\n+            }\n \n-        if (input.write && variable.isFinal()) {\n-            throw createError(new IllegalArgumentException(\"Variable [\" + variable.getName() + \"] is read-only.\"));\n-        }\n+            if (input.read == false) {\n+                throw createError(new IllegalArgumentException(\"not a statement: \" +\n+                        \"static type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] not used\"));\n+            }\n+\n+            output.actual = type;\n+            output.isStaticType = true;\n+\n+            StaticNode staticNode = new StaticNode();\n \n-        output.actual = variable.getType();\n+            staticNode.setLocation(location);\n+            staticNode.setExpressionType(output.actual);\n \n-        VariableNode variableNode = new VariableNode();\n+            output.expressionNode = staticNode;\n+        } else if (scope.isVariableDefined(name)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk5NzI1OQ=="}, "originalCommit": {"oid": "86fe756fc1f4760b336e42ffa922e9de1d9c61fe"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY1NDcwMQ==", "bodyText": "This int java; java.util.Integer.parseInt('1') results in an error since the java package name is overridden by a variable name.\nThis int java; java.util.ArrayList x = new java.util.ArrayList() is successful as our parser can recognize that declarations must be a type, so it uses a different parsing path based on the rules.\nThis int java; List x = new java.util.ArrayList(); ArrayList y; y = (java.util.ArrayList)x; is successful for the same reasons as the previous example, but for casting a reference type.\nThese all follow similar behavior to Java with error messages differing based on our use cases.", "url": "https://github.com/elastic/elasticsearch/pull/56293#discussion_r424654701", "createdAt": "2020-05-13T18:44:00Z", "author": {"login": "jdconrad"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EVariable.java", "diffHunk": "@@ -43,27 +45,52 @@ public EVariable(Location location, String name) {\n \n     @Override\n     Output analyze(ClassNode classNode, ScriptRoot scriptRoot, Scope scope, Input input) {\n-        if (input.read == false && input.write == false) {\n-            throw createError(new IllegalArgumentException(\"not a statement: variable [\" + name + \"] not used\"));\n-        }\n-\n         Output output = new Output();\n+        Class<?> type = scriptRoot.getPainlessLookup().canonicalTypeNameToType(name);\n \n-        Variable variable = scope.getVariable(location, name);\n+        if (type != null)  {\n+            if (input.write) {\n+                throw createError(new IllegalArgumentException(\"invalid assignment: \" +\n+                        \"cannot write a value to a static type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"]\"));\n+            }\n \n-        if (input.write && variable.isFinal()) {\n-            throw createError(new IllegalArgumentException(\"Variable [\" + variable.getName() + \"] is read-only.\"));\n-        }\n+            if (input.read == false) {\n+                throw createError(new IllegalArgumentException(\"not a statement: \" +\n+                        \"static type [\" + PainlessLookupUtility.typeToCanonicalTypeName(type) + \"] not used\"));\n+            }\n+\n+            output.actual = type;\n+            output.isStaticType = true;\n+\n+            StaticNode staticNode = new StaticNode();\n \n-        output.actual = variable.getType();\n+            staticNode.setLocation(location);\n+            staticNode.setExpressionType(output.actual);\n \n-        VariableNode variableNode = new VariableNode();\n+            output.expressionNode = staticNode;\n+        } else if (scope.isVariableDefined(name)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk5NzI1OQ=="}, "originalCommit": {"oid": "86fe756fc1f4760b336e42ffa922e9de1d9c61fe"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MDM2NTg0OnYy", "diffSide": "RIGHT", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EVariable.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMDowMToxN1rOGUW0tA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxODozNzozOVrOGU-omA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk5ODY0NA==", "bodyText": "Is there any possibility of a partial name triggering type != null? eg. java.util.HashMap.abc123.", "url": "https://github.com/elastic/elasticsearch/pull/56293#discussion_r423998644", "createdAt": "2020-05-12T20:01:17Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EVariable.java", "diffHunk": "@@ -43,27 +45,52 @@ public EVariable(Location location, String name) {\n \n     @Override\n     Output analyze(ClassNode classNode, ScriptRoot scriptRoot, Scope scope, Input input) {\n-        if (input.read == false && input.write == false) {\n-            throw createError(new IllegalArgumentException(\"not a statement: variable [\" + name + \"] not used\"));\n-        }\n-\n         Output output = new Output();\n+        Class<?> type = scriptRoot.getPainlessLookup().canonicalTypeNameToType(name);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86fe756fc1f4760b336e42ffa922e9de1d9c61fe"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY1MDkwNA==", "bodyText": "Tests should cover all use cases of this particular corner case. This should always result in a compiler error - \"not a symbol\"", "url": "https://github.com/elastic/elasticsearch/pull/56293#discussion_r424650904", "createdAt": "2020-05-13T18:37:39Z", "author": {"login": "jdconrad"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EVariable.java", "diffHunk": "@@ -43,27 +45,52 @@ public EVariable(Location location, String name) {\n \n     @Override\n     Output analyze(ClassNode classNode, ScriptRoot scriptRoot, Scope scope, Input input) {\n-        if (input.read == false && input.write == false) {\n-            throw createError(new IllegalArgumentException(\"not a statement: variable [\" + name + \"] not used\"));\n-        }\n-\n         Output output = new Output();\n+        Class<?> type = scriptRoot.getPainlessLookup().canonicalTypeNameToType(name);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk5ODY0NA=="}, "originalCommit": {"oid": "86fe756fc1f4760b336e42ffa922e9de1d9c61fe"}, "originalPosition": 19}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 688, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}