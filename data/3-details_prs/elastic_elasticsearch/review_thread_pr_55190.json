{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAzNDYzNDIx", "number": 55190, "reviewThreads": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNjo0NDo1MlrODy-MiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNzo1Mzo1OFrODy_igQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0Nzc0NDA5OnYy", "diffSide": "RIGHT", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/ir/CallSubDefNode.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNjo0NDo1MlrOGHVY_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNDo1NzowM1rOGJKVag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM0MzY3Ng==", "bodyText": "Reciever?", "url": "https://github.com/elastic/elasticsearch/pull/55190#discussion_r410343676", "createdAt": "2020-04-17T16:44:52Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/ir/CallSubDefNode.java", "diffHunk": "@@ -45,50 +44,49 @@ public String getName() {\n         return name;\n     }\n \n-    public void setRecipe(String recipe) {\n-        this.recipe = recipe;\n-    }\n+    /* ---- end node data ---- */\n \n-    public String getRecipe() {\n-        return recipe;\n-    }\n+    @Override\n+    protected void write(ClassWriter classWriter, MethodWriter methodWriter, ScopeTable scopeTable) {\n+        methodWriter.writeDebugInfo(location);\n \n-    public void addPointer(String pointer) {\n-        pointers.add(pointer);\n-    }\n+        StringBuilder defCallRecipe = new StringBuilder();\n+        List<Object> boostrapArguments = new ArrayList<>();\n+        List<Class<?>> typeParameters = new ArrayList<>();\n+        int capturedCount = 0;\n \n-    public List<String> getPointers() {\n-        return pointers;\n-    }\n+        typeParameters.add(Object.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c93293c2ada3933550f1b64fa303a8785b7b328"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI1OTY5MA==", "bodyText": "commented", "url": "https://github.com/elastic/elasticsearch/pull/55190#discussion_r412259690", "createdAt": "2020-04-21T14:57:03Z", "author": {"login": "jdconrad"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/ir/CallSubDefNode.java", "diffHunk": "@@ -45,50 +44,49 @@ public String getName() {\n         return name;\n     }\n \n-    public void setRecipe(String recipe) {\n-        this.recipe = recipe;\n-    }\n+    /* ---- end node data ---- */\n \n-    public String getRecipe() {\n-        return recipe;\n-    }\n+    @Override\n+    protected void write(ClassWriter classWriter, MethodWriter methodWriter, ScopeTable scopeTable) {\n+        methodWriter.writeDebugInfo(location);\n \n-    public void addPointer(String pointer) {\n-        pointers.add(pointer);\n-    }\n+        StringBuilder defCallRecipe = new StringBuilder();\n+        List<Object> boostrapArguments = new ArrayList<>();\n+        List<Class<?>> typeParameters = new ArrayList<>();\n+        int capturedCount = 0;\n \n-    public List<String> getPointers() {\n-        return pointers;\n-    }\n+        typeParameters.add(Object.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM0MzY3Ng=="}, "originalCommit": {"oid": "4c93293c2ada3933550f1b64fa303a8785b7b328"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0Nzc0NDQ1OnYy", "diffSide": "RIGHT", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/ir/CallSubDefNode.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNjo0NDo1OVrOGHVZNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNToxMToyMFrOGJLGDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM0MzczMg==", "bodyText": "?", "url": "https://github.com/elastic/elasticsearch/pull/55190#discussion_r410343732", "createdAt": "2020-04-17T16:44:59Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/ir/CallSubDefNode.java", "diffHunk": "@@ -45,50 +44,49 @@ public String getName() {\n         return name;\n     }\n \n-    public void setRecipe(String recipe) {\n-        this.recipe = recipe;\n-    }\n+    /* ---- end node data ---- */\n \n-    public String getRecipe() {\n-        return recipe;\n-    }\n+    @Override\n+    protected void write(ClassWriter classWriter, MethodWriter methodWriter, ScopeTable scopeTable) {\n+        methodWriter.writeDebugInfo(location);\n \n-    public void addPointer(String pointer) {\n-        pointers.add(pointer);\n-    }\n+        StringBuilder defCallRecipe = new StringBuilder();\n+        List<Object> boostrapArguments = new ArrayList<>();\n+        List<Class<?>> typeParameters = new ArrayList<>();\n+        int capturedCount = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c93293c2ada3933550f1b64fa303a8785b7b328"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI3MjE0MQ==", "bodyText": "commented", "url": "https://github.com/elastic/elasticsearch/pull/55190#discussion_r412272141", "createdAt": "2020-04-21T15:11:20Z", "author": {"login": "jdconrad"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/ir/CallSubDefNode.java", "diffHunk": "@@ -45,50 +44,49 @@ public String getName() {\n         return name;\n     }\n \n-    public void setRecipe(String recipe) {\n-        this.recipe = recipe;\n-    }\n+    /* ---- end node data ---- */\n \n-    public String getRecipe() {\n-        return recipe;\n-    }\n+    @Override\n+    protected void write(ClassWriter classWriter, MethodWriter methodWriter, ScopeTable scopeTable) {\n+        methodWriter.writeDebugInfo(location);\n \n-    public void addPointer(String pointer) {\n-        pointers.add(pointer);\n-    }\n+        StringBuilder defCallRecipe = new StringBuilder();\n+        List<Object> boostrapArguments = new ArrayList<>();\n+        List<Class<?>> typeParameters = new ArrayList<>();\n+        int capturedCount = 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM0MzczMg=="}, "originalCommit": {"oid": "4c93293c2ada3933550f1b64fa303a8785b7b328"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0Nzc0ODQyOnYy", "diffSide": "RIGHT", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/ir/CallSubDefNode.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNjo0NjowMlrOGHVboA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNToxMTozM1rOGJLGrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM0NDM1Mg==", "bodyText": "?", "url": "https://github.com/elastic/elasticsearch/pull/55190#discussion_r410344352", "createdAt": "2020-04-17T16:46:02Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/ir/CallSubDefNode.java", "diffHunk": "@@ -45,50 +44,49 @@ public String getName() {\n         return name;\n     }\n \n-    public void setRecipe(String recipe) {\n-        this.recipe = recipe;\n-    }\n+    /* ---- end node data ---- */\n \n-    public String getRecipe() {\n-        return recipe;\n-    }\n+    @Override\n+    protected void write(ClassWriter classWriter, MethodWriter methodWriter, ScopeTable scopeTable) {\n+        methodWriter.writeDebugInfo(location);\n \n-    public void addPointer(String pointer) {\n-        pointers.add(pointer);\n-    }\n+        StringBuilder defCallRecipe = new StringBuilder();\n+        List<Object> boostrapArguments = new ArrayList<>();\n+        List<Class<?>> typeParameters = new ArrayList<>();\n+        int capturedCount = 0;\n \n-    public List<String> getPointers() {\n-        return pointers;\n-    }\n+        typeParameters.add(Object.class);\n \n-    public void addTypeParameter(Class<?> typeParameter) {\n-        typeParameters.add(typeParameter);\n-    }\n+        for (int i = 0; i < getArgumentNodes().size(); ++i) {\n+            ExpressionNode argumentNode = getArgumentNodes().get(i);\n+            argumentNode.write(classWriter, methodWriter, scopeTable);\n \n-    public List<Class<?>> getTypeParameters() {\n-        return typeParameters;\n-    }\n+            typeParameters.add(argumentNode.getExpressionType());\n \n-    /* ---- end node data ---- */\n+            if (argumentNode instanceof DefInterfaceReferenceNode) {\n+                DefInterfaceReferenceNode defInterfaceReferenceNode = (DefInterfaceReferenceNode)argumentNode;\n+                boostrapArguments.add(defInterfaceReferenceNode.getDefReferenceEncoding());\n \n-    @Override\n-    protected void write(ClassWriter classWriter, MethodWriter methodWriter, ScopeTable scopeTable) {\n-        methodWriter.writeDebugInfo(location);\n+                char encoding = (char)(i + capturedCount);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c93293c2ada3933550f1b64fa303a8785b7b328"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI3MjMwMA==", "bodyText": "commented", "url": "https://github.com/elastic/elasticsearch/pull/55190#discussion_r412272300", "createdAt": "2020-04-21T15:11:33Z", "author": {"login": "jdconrad"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/ir/CallSubDefNode.java", "diffHunk": "@@ -45,50 +44,49 @@ public String getName() {\n         return name;\n     }\n \n-    public void setRecipe(String recipe) {\n-        this.recipe = recipe;\n-    }\n+    /* ---- end node data ---- */\n \n-    public String getRecipe() {\n-        return recipe;\n-    }\n+    @Override\n+    protected void write(ClassWriter classWriter, MethodWriter methodWriter, ScopeTable scopeTable) {\n+        methodWriter.writeDebugInfo(location);\n \n-    public void addPointer(String pointer) {\n-        pointers.add(pointer);\n-    }\n+        StringBuilder defCallRecipe = new StringBuilder();\n+        List<Object> boostrapArguments = new ArrayList<>();\n+        List<Class<?>> typeParameters = new ArrayList<>();\n+        int capturedCount = 0;\n \n-    public List<String> getPointers() {\n-        return pointers;\n-    }\n+        typeParameters.add(Object.class);\n \n-    public void addTypeParameter(Class<?> typeParameter) {\n-        typeParameters.add(typeParameter);\n-    }\n+        for (int i = 0; i < getArgumentNodes().size(); ++i) {\n+            ExpressionNode argumentNode = getArgumentNodes().get(i);\n+            argumentNode.write(classWriter, methodWriter, scopeTable);\n \n-    public List<Class<?>> getTypeParameters() {\n-        return typeParameters;\n-    }\n+            typeParameters.add(argumentNode.getExpressionType());\n \n-    /* ---- end node data ---- */\n+            if (argumentNode instanceof DefInterfaceReferenceNode) {\n+                DefInterfaceReferenceNode defInterfaceReferenceNode = (DefInterfaceReferenceNode)argumentNode;\n+                boostrapArguments.add(defInterfaceReferenceNode.getDefReferenceEncoding());\n \n-    @Override\n-    protected void write(ClassWriter classWriter, MethodWriter methodWriter, ScopeTable scopeTable) {\n-        methodWriter.writeDebugInfo(location);\n+                char encoding = (char)(i + capturedCount);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM0NDM1Mg=="}, "originalCommit": {"oid": "4c93293c2ada3933550f1b64fa303a8785b7b328"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0Nzc1MDgzOnYy", "diffSide": "RIGHT", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/ir/DefInterfaceReferenceNode.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNjo0Njo0NlrOGHVdPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNToyMzoyNVrOGJLtmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM0NDc2Nw==", "bodyText": "don't leave me hanging!", "url": "https://github.com/elastic/elasticsearch/pull/55190#discussion_r410344767", "createdAt": "2020-04-17T16:46:46Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/ir/DefInterfaceReferenceNode.java", "diffHunk": "@@ -20,34 +20,36 @@\n package org.elasticsearch.painless.ir;\n \n import org.elasticsearch.painless.ClassWriter;\n-import org.elasticsearch.painless.FunctionRef;\n import org.elasticsearch.painless.MethodWriter;\n import org.elasticsearch.painless.symbol.ScopeTable;\n+import org.objectweb.asm.Opcodes;\n \n-public class NewArrayFuncRefNode extends ExpressionNode {\n+public class DefInterfaceReferenceNode extends ReferenceNode {\n \n     /* ---- begin node data ---- */\n \n-    private FunctionRef funcRef;\n+    private String defReferenceEncoding;\n \n-    public void setFuncRef(FunctionRef funcRef) {\n-        this.funcRef = funcRef;\n+    public void setDefReferenceEncoding(String defReferenceEncoding) {\n+        this.defReferenceEncoding = defReferenceEncoding;\n     }\n \n-    public FunctionRef getFuncRef() {\n-        return funcRef;\n+    public String getDefReferenceEncoding() {\n+        return defReferenceEncoding;\n     }\n \n     /* ---- end node data ---- */\n \n     @Override\n     protected void write(ClassWriter classWriter, MethodWriter methodWriter, ScopeTable scopeTable) {\n-        if (funcRef != null) {\n-            methodWriter.writeDebugInfo(location);\n-            methodWriter.invokeLambdaCall(funcRef);\n-        } else {\n-            // push a null instruction as a placeholder for future lambda instructions\n-            methodWriter.push((String)null);\n+        methodWriter.writeDebugInfo(location);\n+\n+        // place holder for", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c93293c2ada3933550f1b64fa303a8785b7b328"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI4MjI2Nw==", "bodyText": "oops, fixed :)", "url": "https://github.com/elastic/elasticsearch/pull/55190#discussion_r412282267", "createdAt": "2020-04-21T15:23:25Z", "author": {"login": "jdconrad"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/ir/DefInterfaceReferenceNode.java", "diffHunk": "@@ -20,34 +20,36 @@\n package org.elasticsearch.painless.ir;\n \n import org.elasticsearch.painless.ClassWriter;\n-import org.elasticsearch.painless.FunctionRef;\n import org.elasticsearch.painless.MethodWriter;\n import org.elasticsearch.painless.symbol.ScopeTable;\n+import org.objectweb.asm.Opcodes;\n \n-public class NewArrayFuncRefNode extends ExpressionNode {\n+public class DefInterfaceReferenceNode extends ReferenceNode {\n \n     /* ---- begin node data ---- */\n \n-    private FunctionRef funcRef;\n+    private String defReferenceEncoding;\n \n-    public void setFuncRef(FunctionRef funcRef) {\n-        this.funcRef = funcRef;\n+    public void setDefReferenceEncoding(String defReferenceEncoding) {\n+        this.defReferenceEncoding = defReferenceEncoding;\n     }\n \n-    public FunctionRef getFuncRef() {\n-        return funcRef;\n+    public String getDefReferenceEncoding() {\n+        return defReferenceEncoding;\n     }\n \n     /* ---- end node data ---- */\n \n     @Override\n     protected void write(ClassWriter classWriter, MethodWriter methodWriter, ScopeTable scopeTable) {\n-        if (funcRef != null) {\n-            methodWriter.writeDebugInfo(location);\n-            methodWriter.invokeLambdaCall(funcRef);\n-        } else {\n-            // push a null instruction as a placeholder for future lambda instructions\n-            methodWriter.push((String)null);\n+        methodWriter.writeDebugInfo(location);\n+\n+        // place holder for", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM0NDc2Nw=="}, "originalCommit": {"oid": "4c93293c2ada3933550f1b64fa303a8785b7b328"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0Nzc2MDQ2OnYy", "diffSide": "RIGHT", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/ir/DefInterfaceReferenceNode.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNjo0OTo0MFrOGHVjaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNToxMjowMVrOGJLIMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM0NjM0NQ==", "bodyText": "visitVarInsn -> visit variable instance?", "url": "https://github.com/elastic/elasticsearch/pull/55190#discussion_r410346345", "createdAt": "2020-04-17T16:49:40Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/ir/DefInterfaceReferenceNode.java", "diffHunk": "@@ -20,34 +20,36 @@\n package org.elasticsearch.painless.ir;\n \n import org.elasticsearch.painless.ClassWriter;\n-import org.elasticsearch.painless.FunctionRef;\n import org.elasticsearch.painless.MethodWriter;\n import org.elasticsearch.painless.symbol.ScopeTable;\n+import org.objectweb.asm.Opcodes;\n \n-public class NewArrayFuncRefNode extends ExpressionNode {\n+public class DefInterfaceReferenceNode extends ReferenceNode {\n \n     /* ---- begin node data ---- */\n \n-    private FunctionRef funcRef;\n+    private String defReferenceEncoding;\n \n-    public void setFuncRef(FunctionRef funcRef) {\n-        this.funcRef = funcRef;\n+    public void setDefReferenceEncoding(String defReferenceEncoding) {\n+        this.defReferenceEncoding = defReferenceEncoding;\n     }\n \n-    public FunctionRef getFuncRef() {\n-        return funcRef;\n+    public String getDefReferenceEncoding() {\n+        return defReferenceEncoding;\n     }\n \n     /* ---- end node data ---- */\n \n     @Override\n     protected void write(ClassWriter classWriter, MethodWriter methodWriter, ScopeTable scopeTable) {\n-        if (funcRef != null) {\n-            methodWriter.writeDebugInfo(location);\n-            methodWriter.invokeLambdaCall(funcRef);\n-        } else {\n-            // push a null instruction as a placeholder for future lambda instructions\n-            methodWriter.push((String)null);\n+        methodWriter.writeDebugInfo(location);\n+\n+        // place holder for\n+        methodWriter.push((String)null);\n+\n+        for (String capture : getCaptures()) {\n+            ScopeTable.Variable variable = scopeTable.getVariable(capture);\n+            methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c93293c2ada3933550f1b64fa303a8785b7b328"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI3MjY5MQ==", "bodyText": "an asm instruction to load a variable's value onto the stack", "url": "https://github.com/elastic/elasticsearch/pull/55190#discussion_r412272691", "createdAt": "2020-04-21T15:12:01Z", "author": {"login": "jdconrad"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/ir/DefInterfaceReferenceNode.java", "diffHunk": "@@ -20,34 +20,36 @@\n package org.elasticsearch.painless.ir;\n \n import org.elasticsearch.painless.ClassWriter;\n-import org.elasticsearch.painless.FunctionRef;\n import org.elasticsearch.painless.MethodWriter;\n import org.elasticsearch.painless.symbol.ScopeTable;\n+import org.objectweb.asm.Opcodes;\n \n-public class NewArrayFuncRefNode extends ExpressionNode {\n+public class DefInterfaceReferenceNode extends ReferenceNode {\n \n     /* ---- begin node data ---- */\n \n-    private FunctionRef funcRef;\n+    private String defReferenceEncoding;\n \n-    public void setFuncRef(FunctionRef funcRef) {\n-        this.funcRef = funcRef;\n+    public void setDefReferenceEncoding(String defReferenceEncoding) {\n+        this.defReferenceEncoding = defReferenceEncoding;\n     }\n \n-    public FunctionRef getFuncRef() {\n-        return funcRef;\n+    public String getDefReferenceEncoding() {\n+        return defReferenceEncoding;\n     }\n \n     /* ---- end node data ---- */\n \n     @Override\n     protected void write(ClassWriter classWriter, MethodWriter methodWriter, ScopeTable scopeTable) {\n-        if (funcRef != null) {\n-            methodWriter.writeDebugInfo(location);\n-            methodWriter.invokeLambdaCall(funcRef);\n-        } else {\n-            // push a null instruction as a placeholder for future lambda instructions\n-            methodWriter.push((String)null);\n+        methodWriter.writeDebugInfo(location);\n+\n+        // place holder for\n+        methodWriter.push((String)null);\n+\n+        for (String capture : getCaptures()) {\n+            ScopeTable.Variable variable = scopeTable.getVariable(capture);\n+            methodWriter.visitVarInsn(variable.getAsmType().getOpcode(Opcodes.ILOAD), variable.getSlot());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM0NjM0NQ=="}, "originalCommit": {"oid": "4c93293c2ada3933550f1b64fa303a8785b7b328"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0Nzc2MTY2OnYy", "diffSide": "RIGHT", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/ir/ReferenceNode.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNjo0OTo1NVrOGHVkGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNjo0OTo0MFrOGJOGiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM0NjUyMQ==", "bodyText": "?", "url": "https://github.com/elastic/elasticsearch/pull/55190#discussion_r410346521", "createdAt": "2020-04-17T16:49:55Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/ir/ReferenceNode.java", "diffHunk": "@@ -7,7 +7,7 @@\n  * not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n  *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n+ *     http://www.apache.org/licenses/LICENSE-2.0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c93293c2ada3933550f1b64fa303a8785b7b328"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMyMTQxNw==", "bodyText": "I believe this got fixed to be a tab + 1 space away from the star since the rest of the lines have an extra space away from the star.", "url": "https://github.com/elastic/elasticsearch/pull/55190#discussion_r412321417", "createdAt": "2020-04-21T16:49:40Z", "author": {"login": "jdconrad"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/ir/ReferenceNode.java", "diffHunk": "@@ -7,7 +7,7 @@\n  * not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n  *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n+ *     http://www.apache.org/licenses/LICENSE-2.0", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM0NjUyMQ=="}, "originalCommit": {"oid": "4c93293c2ada3933550f1b64fa303a8785b7b328"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0Nzc2Mzg3OnYy", "diffSide": "RIGHT", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/ir/ReferenceNode.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNjo1MDo0NlrOGHVlrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNToxMzo1OFrOGJLOnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM0NjkyNQ==", "bodyText": "is it ok to leak a mutable data structure here?", "url": "https://github.com/elastic/elasticsearch/pull/55190#discussion_r410346925", "createdAt": "2020-04-17T16:50:46Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/ir/ReferenceNode.java", "diffHunk": "@@ -17,26 +17,25 @@\n  * under the License.\n  */\n \n-package org.elasticsearch.painless.node;\n+package org.elasticsearch.painless.ir;\n \n+import java.util.ArrayList;\n import java.util.List;\n \n-/**\n- * Interface for lambda/method reference nodes. They need special handling by LDefCall.\n- * <p>\n- * This is because they know nothing about the target interface, and can only push\n- * all their captures onto the stack and defer everything until link-time.\n- */\n-interface ILambda {\n+public abstract class ReferenceNode extends ExpressionNode {\n+\n+    /* ---- begin node data ---- */\n \n-    /** Returns reference to resolve at link-time */\n-    String getPointer();\n+    private final List<String> captures = new ArrayList<>();\n \n-    /** Returns the types of captured parameters. Can be empty */\n-    List<Class<?>> getCaptures();\n+    public void addCapture(String capture) {\n+        captures.add(capture);\n+    }\n \n-    /** Returns the number of captured parameters */\n-    default int getCaptureCount() {\n-        return getCaptures().size();\n+    public List<String> getCaptures() {\n+        return captures;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c93293c2ada3933550f1b64fa303a8785b7b328"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI3NDMzMg==", "bodyText": "all ir nodes are designed to be completely mutable as we hope to modify the ir tree structure at some point to add optimizations and possibly other features; we keep the user tree as immutable and hide the ir tree behind it", "url": "https://github.com/elastic/elasticsearch/pull/55190#discussion_r412274332", "createdAt": "2020-04-21T15:13:58Z", "author": {"login": "jdconrad"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/ir/ReferenceNode.java", "diffHunk": "@@ -17,26 +17,25 @@\n  * under the License.\n  */\n \n-package org.elasticsearch.painless.node;\n+package org.elasticsearch.painless.ir;\n \n+import java.util.ArrayList;\n import java.util.List;\n \n-/**\n- * Interface for lambda/method reference nodes. They need special handling by LDefCall.\n- * <p>\n- * This is because they know nothing about the target interface, and can only push\n- * all their captures onto the stack and defer everything until link-time.\n- */\n-interface ILambda {\n+public abstract class ReferenceNode extends ExpressionNode {\n+\n+    /* ---- begin node data ---- */\n \n-    /** Returns reference to resolve at link-time */\n-    String getPointer();\n+    private final List<String> captures = new ArrayList<>();\n \n-    /** Returns the types of captured parameters. Can be empty */\n-    List<Class<?>> getCaptures();\n+    public void addCapture(String capture) {\n+        captures.add(capture);\n+    }\n \n-    /** Returns the number of captured parameters */\n-    default int getCaptureCount() {\n-        return getCaptures().size();\n+    public List<String> getCaptures() {\n+        return captures;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM0NjkyNQ=="}, "originalCommit": {"oid": "4c93293c2ada3933550f1b64fa303a8785b7b328"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0Nzc2NzM4OnYy", "diffSide": "RIGHT", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/ir/TypedCaptureReferenceNode.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNjo1MTo0NFrOGHVn9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNToxODo1MVrOGJLfJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM0NzUxMQ==", "bodyText": "why is the get(0) safe here?", "url": "https://github.com/elastic/elasticsearch/pull/55190#discussion_r410347511", "createdAt": "2020-04-17T16:51:44Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/ir/TypedCaptureReferenceNode.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.ir;\n+\n+import org.elasticsearch.painless.ClassWriter;\n+import org.elasticsearch.painless.DefBootstrap;\n+import org.elasticsearch.painless.MethodWriter;\n+import org.elasticsearch.painless.symbol.ScopeTable;\n+import org.elasticsearch.painless.symbol.ScopeTable.Variable;\n+import org.objectweb.asm.Opcodes;\n+import org.objectweb.asm.Type;\n+\n+public class TypedCaptureReferenceNode extends ReferenceNode {\n+\n+    /* ---- begin node data ---- */\n+\n+    private String methodName;\n+\n+    public void setMethodName(String methodName) {\n+        this.methodName = methodName;\n+    }\n+\n+    public String getMethodName() {\n+        return methodName;\n+    }\n+\n+    /* ---- end node data ---- */\n+\n+    @Override\n+    protected void write(ClassWriter classWriter, MethodWriter methodWriter, ScopeTable scopeTable) {\n+        methodWriter.writeDebugInfo(location);\n+        Variable captured = scopeTable.getVariable(getCaptures().get(0));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c93293c2ada3933550f1b64fa303a8785b7b328"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI3ODU2NA==", "bodyText": "there is only a single capture for reference types in this case (foo::bar where foo is the captured variable)", "url": "https://github.com/elastic/elasticsearch/pull/55190#discussion_r412278564", "createdAt": "2020-04-21T15:18:51Z", "author": {"login": "jdconrad"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/ir/TypedCaptureReferenceNode.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.painless.ir;\n+\n+import org.elasticsearch.painless.ClassWriter;\n+import org.elasticsearch.painless.DefBootstrap;\n+import org.elasticsearch.painless.MethodWriter;\n+import org.elasticsearch.painless.symbol.ScopeTable;\n+import org.elasticsearch.painless.symbol.ScopeTable.Variable;\n+import org.objectweb.asm.Opcodes;\n+import org.objectweb.asm.Type;\n+\n+public class TypedCaptureReferenceNode extends ReferenceNode {\n+\n+    /* ---- begin node data ---- */\n+\n+    private String methodName;\n+\n+    public void setMethodName(String methodName) {\n+        this.methodName = methodName;\n+    }\n+\n+    public String getMethodName() {\n+        return methodName;\n+    }\n+\n+    /* ---- end node data ---- */\n+\n+    @Override\n+    protected void write(ClassWriter classWriter, MethodWriter methodWriter, ScopeTable scopeTable) {\n+        methodWriter.writeDebugInfo(location);\n+        Variable captured = scopeTable.getVariable(getCaptures().get(0));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM0NzUxMQ=="}, "originalCommit": {"oid": "4c93293c2ada3933550f1b64fa303a8785b7b328"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0Nzg5ODgyOnYy", "diffSide": "RIGHT", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/ir/CallSubDefNode.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNzozMzoxMlrOGHW99w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNToyMDoxN1rOGJLjoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM2OTUyNw==", "bodyText": "Javadocs: \"Write out invokedynamic instruction\" or something similar.  Nothing fancy.", "url": "https://github.com/elastic/elasticsearch/pull/55190#discussion_r410369527", "createdAt": "2020-04-17T17:33:12Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/ir/CallSubDefNode.java", "diffHunk": "@@ -45,50 +44,49 @@ public String getName() {\n         return name;\n     }\n \n-    public void setRecipe(String recipe) {\n-        this.recipe = recipe;\n-    }\n+    /* ---- end node data ---- */\n \n-    public String getRecipe() {\n-        return recipe;\n-    }\n+    @Override", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c93293c2ada3933550f1b64fa303a8785b7b328"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI3OTcxMg==", "bodyText": "commented", "url": "https://github.com/elastic/elasticsearch/pull/55190#discussion_r412279712", "createdAt": "2020-04-21T15:20:17Z", "author": {"login": "jdconrad"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/ir/CallSubDefNode.java", "diffHunk": "@@ -45,50 +44,49 @@ public String getName() {\n         return name;\n     }\n \n-    public void setRecipe(String recipe) {\n-        this.recipe = recipe;\n-    }\n+    /* ---- end node data ---- */\n \n-    public String getRecipe() {\n-        return recipe;\n-    }\n+    @Override", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM2OTUyNw=="}, "originalCommit": {"oid": "4c93293c2ada3933550f1b64fa303a8785b7b328"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NzkwMzE5OnYy", "diffSide": "RIGHT", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/ir/CallSubDefNode.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNzozNDozN1rOGHXA3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNToxOToxMFrOGJLgNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM3MDI2OA==", "bodyText": "\"Handle lambdas as args\"", "url": "https://github.com/elastic/elasticsearch/pull/55190#discussion_r410370268", "createdAt": "2020-04-17T17:34:37Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/ir/CallSubDefNode.java", "diffHunk": "@@ -45,50 +44,49 @@ public String getName() {\n         return name;\n     }\n \n-    public void setRecipe(String recipe) {\n-        this.recipe = recipe;\n-    }\n+    /* ---- end node data ---- */\n \n-    public String getRecipe() {\n-        return recipe;\n-    }\n+    @Override\n+    protected void write(ClassWriter classWriter, MethodWriter methodWriter, ScopeTable scopeTable) {\n+        methodWriter.writeDebugInfo(location);\n \n-    public void addPointer(String pointer) {\n-        pointers.add(pointer);\n-    }\n+        StringBuilder defCallRecipe = new StringBuilder();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c93293c2ada3933550f1b64fa303a8785b7b328"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI3ODgzNg==", "bodyText": "commented", "url": "https://github.com/elastic/elasticsearch/pull/55190#discussion_r412278836", "createdAt": "2020-04-21T15:19:10Z", "author": {"login": "jdconrad"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/ir/CallSubDefNode.java", "diffHunk": "@@ -45,50 +44,49 @@ public String getName() {\n         return name;\n     }\n \n-    public void setRecipe(String recipe) {\n-        this.recipe = recipe;\n-    }\n+    /* ---- end node data ---- */\n \n-    public String getRecipe() {\n-        return recipe;\n-    }\n+    @Override\n+    protected void write(ClassWriter classWriter, MethodWriter methodWriter, ScopeTable scopeTable) {\n+        methodWriter.writeDebugInfo(location);\n \n-    public void addPointer(String pointer) {\n-        pointers.add(pointer);\n-    }\n+        StringBuilder defCallRecipe = new StringBuilder();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM3MDI2OA=="}, "originalCommit": {"oid": "4c93293c2ada3933550f1b64fa303a8785b7b328"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NzkwNzA4OnYy", "diffSide": "RIGHT", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/ir/CallSubDefNode.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNzozNTo1N1rOGHXDfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNToyMDo0N1rOGJLlTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM3MDk0MA==", "bodyText": "This is an unknown method ref that we have to resolve at runtime.", "url": "https://github.com/elastic/elasticsearch/pull/55190#discussion_r410370940", "createdAt": "2020-04-17T17:35:57Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/ir/CallSubDefNode.java", "diffHunk": "@@ -45,50 +44,49 @@ public String getName() {\n         return name;\n     }\n \n-    public void setRecipe(String recipe) {\n-        this.recipe = recipe;\n-    }\n+    /* ---- end node data ---- */\n \n-    public String getRecipe() {\n-        return recipe;\n-    }\n+    @Override\n+    protected void write(ClassWriter classWriter, MethodWriter methodWriter, ScopeTable scopeTable) {\n+        methodWriter.writeDebugInfo(location);\n \n-    public void addPointer(String pointer) {\n-        pointers.add(pointer);\n-    }\n+        StringBuilder defCallRecipe = new StringBuilder();\n+        List<Object> boostrapArguments = new ArrayList<>();\n+        List<Class<?>> typeParameters = new ArrayList<>();\n+        int capturedCount = 0;\n \n-    public List<String> getPointers() {\n-        return pointers;\n-    }\n+        typeParameters.add(Object.class);\n \n-    public void addTypeParameter(Class<?> typeParameter) {\n-        typeParameters.add(typeParameter);\n-    }\n+        for (int i = 0; i < getArgumentNodes().size(); ++i) {\n+            ExpressionNode argumentNode = getArgumentNodes().get(i);\n+            argumentNode.write(classWriter, methodWriter, scopeTable);\n \n-    public List<Class<?>> getTypeParameters() {\n-        return typeParameters;\n-    }\n+            typeParameters.add(argumentNode.getExpressionType());\n \n-    /* ---- end node data ---- */\n+            if (argumentNode instanceof DefInterfaceReferenceNode) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c93293c2ada3933550f1b64fa303a8785b7b328"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI4MDE0Mw==", "bodyText": "commented", "url": "https://github.com/elastic/elasticsearch/pull/55190#discussion_r412280143", "createdAt": "2020-04-21T15:20:47Z", "author": {"login": "jdconrad"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/ir/CallSubDefNode.java", "diffHunk": "@@ -45,50 +44,49 @@ public String getName() {\n         return name;\n     }\n \n-    public void setRecipe(String recipe) {\n-        this.recipe = recipe;\n-    }\n+    /* ---- end node data ---- */\n \n-    public String getRecipe() {\n-        return recipe;\n-    }\n+    @Override\n+    protected void write(ClassWriter classWriter, MethodWriter methodWriter, ScopeTable scopeTable) {\n+        methodWriter.writeDebugInfo(location);\n \n-    public void addPointer(String pointer) {\n-        pointers.add(pointer);\n-    }\n+        StringBuilder defCallRecipe = new StringBuilder();\n+        List<Object> boostrapArguments = new ArrayList<>();\n+        List<Class<?>> typeParameters = new ArrayList<>();\n+        int capturedCount = 0;\n \n-    public List<String> getPointers() {\n-        return pointers;\n-    }\n+        typeParameters.add(Object.class);\n \n-    public void addTypeParameter(Class<?> typeParameter) {\n-        typeParameters.add(typeParameter);\n-    }\n+        for (int i = 0; i < getArgumentNodes().size(); ++i) {\n+            ExpressionNode argumentNode = getArgumentNodes().get(i);\n+            argumentNode.write(classWriter, methodWriter, scopeTable);\n \n-    public List<Class<?>> getTypeParameters() {\n-        return typeParameters;\n-    }\n+            typeParameters.add(argumentNode.getExpressionType());\n \n-    /* ---- end node data ---- */\n+            if (argumentNode instanceof DefInterfaceReferenceNode) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM3MDk0MA=="}, "originalCommit": {"oid": "4c93293c2ada3933550f1b64fa303a8785b7b328"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NzkxOTYxOnYy", "diffSide": "RIGHT", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/ir/CallSubDefNode.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNzo0MDowNVrOGHXLzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNjozODozMVrOGJNn0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM3MzA3MQ==", "bodyText": "Small comment about the char encoding skip table, perhaps refing some other documentation, would be helpful.", "url": "https://github.com/elastic/elasticsearch/pull/55190#discussion_r410373071", "createdAt": "2020-04-17T17:40:05Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/ir/CallSubDefNode.java", "diffHunk": "@@ -45,50 +44,49 @@ public String getName() {\n         return name;\n     }\n \n-    public void setRecipe(String recipe) {\n-        this.recipe = recipe;\n-    }\n+    /* ---- end node data ---- */\n \n-    public String getRecipe() {\n-        return recipe;\n-    }\n+    @Override\n+    protected void write(ClassWriter classWriter, MethodWriter methodWriter, ScopeTable scopeTable) {\n+        methodWriter.writeDebugInfo(location);\n \n-    public void addPointer(String pointer) {\n-        pointers.add(pointer);\n-    }\n+        StringBuilder defCallRecipe = new StringBuilder();\n+        List<Object> boostrapArguments = new ArrayList<>();\n+        List<Class<?>> typeParameters = new ArrayList<>();\n+        int capturedCount = 0;\n \n-    public List<String> getPointers() {\n-        return pointers;\n-    }\n+        typeParameters.add(Object.class);\n \n-    public void addTypeParameter(Class<?> typeParameter) {\n-        typeParameters.add(typeParameter);\n-    }\n+        for (int i = 0; i < getArgumentNodes().size(); ++i) {\n+            ExpressionNode argumentNode = getArgumentNodes().get(i);\n+            argumentNode.write(classWriter, methodWriter, scopeTable);\n \n-    public List<Class<?>> getTypeParameters() {\n-        return typeParameters;\n-    }\n+            typeParameters.add(argumentNode.getExpressionType());\n \n-    /* ---- end node data ---- */\n+            if (argumentNode instanceof DefInterfaceReferenceNode) {\n+                DefInterfaceReferenceNode defInterfaceReferenceNode = (DefInterfaceReferenceNode)argumentNode;\n+                boostrapArguments.add(defInterfaceReferenceNode.getDefReferenceEncoding());\n \n-    @Override\n-    protected void write(ClassWriter classWriter, MethodWriter methodWriter, ScopeTable scopeTable) {\n-        methodWriter.writeDebugInfo(location);\n+                char encoding = (char)(i + capturedCount);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c93293c2ada3933550f1b64fa303a8785b7b328"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI5MDk3NQ==", "bodyText": "commented", "url": "https://github.com/elastic/elasticsearch/pull/55190#discussion_r412290975", "createdAt": "2020-04-21T15:37:27Z", "author": {"login": "jdconrad"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/ir/CallSubDefNode.java", "diffHunk": "@@ -45,50 +44,49 @@ public String getName() {\n         return name;\n     }\n \n-    public void setRecipe(String recipe) {\n-        this.recipe = recipe;\n-    }\n+    /* ---- end node data ---- */\n \n-    public String getRecipe() {\n-        return recipe;\n-    }\n+    @Override\n+    protected void write(ClassWriter classWriter, MethodWriter methodWriter, ScopeTable scopeTable) {\n+        methodWriter.writeDebugInfo(location);\n \n-    public void addPointer(String pointer) {\n-        pointers.add(pointer);\n-    }\n+        StringBuilder defCallRecipe = new StringBuilder();\n+        List<Object> boostrapArguments = new ArrayList<>();\n+        List<Class<?>> typeParameters = new ArrayList<>();\n+        int capturedCount = 0;\n \n-    public List<String> getPointers() {\n-        return pointers;\n-    }\n+        typeParameters.add(Object.class);\n \n-    public void addTypeParameter(Class<?> typeParameter) {\n-        typeParameters.add(typeParameter);\n-    }\n+        for (int i = 0; i < getArgumentNodes().size(); ++i) {\n+            ExpressionNode argumentNode = getArgumentNodes().get(i);\n+            argumentNode.write(classWriter, methodWriter, scopeTable);\n \n-    public List<Class<?>> getTypeParameters() {\n-        return typeParameters;\n-    }\n+            typeParameters.add(argumentNode.getExpressionType());\n \n-    /* ---- end node data ---- */\n+            if (argumentNode instanceof DefInterfaceReferenceNode) {\n+                DefInterfaceReferenceNode defInterfaceReferenceNode = (DefInterfaceReferenceNode)argumentNode;\n+                boostrapArguments.add(defInterfaceReferenceNode.getDefReferenceEncoding());\n \n-    @Override\n-    protected void write(ClassWriter classWriter, MethodWriter methodWriter, ScopeTable scopeTable) {\n-        methodWriter.writeDebugInfo(location);\n+                char encoding = (char)(i + capturedCount);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM3MzA3MQ=="}, "originalCommit": {"oid": "4c93293c2ada3933550f1b64fa303a8785b7b328"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMxMzU1Mw==", "bodyText": "commented", "url": "https://github.com/elastic/elasticsearch/pull/55190#discussion_r412313553", "createdAt": "2020-04-21T16:38:31Z", "author": {"login": "jdconrad"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/ir/CallSubDefNode.java", "diffHunk": "@@ -45,50 +44,49 @@ public String getName() {\n         return name;\n     }\n \n-    public void setRecipe(String recipe) {\n-        this.recipe = recipe;\n-    }\n+    /* ---- end node data ---- */\n \n-    public String getRecipe() {\n-        return recipe;\n-    }\n+    @Override\n+    protected void write(ClassWriter classWriter, MethodWriter methodWriter, ScopeTable scopeTable) {\n+        methodWriter.writeDebugInfo(location);\n \n-    public void addPointer(String pointer) {\n-        pointers.add(pointer);\n-    }\n+        StringBuilder defCallRecipe = new StringBuilder();\n+        List<Object> boostrapArguments = new ArrayList<>();\n+        List<Class<?>> typeParameters = new ArrayList<>();\n+        int capturedCount = 0;\n \n-    public List<String> getPointers() {\n-        return pointers;\n-    }\n+        typeParameters.add(Object.class);\n \n-    public void addTypeParameter(Class<?> typeParameter) {\n-        typeParameters.add(typeParameter);\n-    }\n+        for (int i = 0; i < getArgumentNodes().size(); ++i) {\n+            ExpressionNode argumentNode = getArgumentNodes().get(i);\n+            argumentNode.write(classWriter, methodWriter, scopeTable);\n \n-    public List<Class<?>> getTypeParameters() {\n-        return typeParameters;\n-    }\n+            typeParameters.add(argumentNode.getExpressionType());\n \n-    /* ---- end node data ---- */\n+            if (argumentNode instanceof DefInterfaceReferenceNode) {\n+                DefInterfaceReferenceNode defInterfaceReferenceNode = (DefInterfaceReferenceNode)argumentNode;\n+                boostrapArguments.add(defInterfaceReferenceNode.getDefReferenceEncoding());\n \n-    @Override\n-    protected void write(ClassWriter classWriter, MethodWriter methodWriter, ScopeTable scopeTable) {\n-        methodWriter.writeDebugInfo(location);\n+                char encoding = (char)(i + capturedCount);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM3MzA3MQ=="}, "originalCommit": {"oid": "4c93293c2ada3933550f1b64fa303a8785b7b328"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0Nzk1OTYzOnYy", "diffSide": "RIGHT", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/ECapturingFunctionRef.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNzo1MjozN1rOGHXleQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNjoxODo0OFrOGJM6Ew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM3OTY0MQ==", "bodyText": "Add TODO, let's pull this encoding creation out into something that makes the arguments clear.", "url": "https://github.com/elastic/elasticsearch/pull/55190#discussion_r410379641", "createdAt": "2020-04-17T17:52:37Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/ECapturingFunctionRef.java", "diffHunk": "@@ -63,51 +59,53 @@ Output analyze(ClassNode classNode, ScriptRoot scriptRoot, Scope scope, Input in\n                     \"not a statement: capturing function reference [\" + variable + \":\"  + call + \"] not used\"));\n         }\n \n-        FunctionRef ref = null;\n-\n         Output output = new Output();\n \n-        captured = scope.getVariable(location, variable);\n+        Variable captured = scope.getVariable(location, variable);\n         if (input.expected == null) {\n+            String defReferenceEncoding;\n             if (captured.getType() == def.class) {\n                 // dynamic implementation\n-                defPointer = \"D\" + variable + \".\" + call + \",1\";\n+                defReferenceEncoding = \"D\" + variable + \".\" + call + \",1\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c93293c2ada3933550f1b64fa303a8785b7b328"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMwMTg0Mw==", "bodyText": "#55543", "url": "https://github.com/elastic/elasticsearch/pull/55190#discussion_r412301843", "createdAt": "2020-04-21T16:18:48Z", "author": {"login": "jdconrad"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/ECapturingFunctionRef.java", "diffHunk": "@@ -63,51 +59,53 @@ Output analyze(ClassNode classNode, ScriptRoot scriptRoot, Scope scope, Input in\n                     \"not a statement: capturing function reference [\" + variable + \":\"  + call + \"] not used\"));\n         }\n \n-        FunctionRef ref = null;\n-\n         Output output = new Output();\n \n-        captured = scope.getVariable(location, variable);\n+        Variable captured = scope.getVariable(location, variable);\n         if (input.expected == null) {\n+            String defReferenceEncoding;\n             if (captured.getType() == def.class) {\n                 // dynamic implementation\n-                defPointer = \"D\" + variable + \".\" + call + \",1\";\n+                defReferenceEncoding = \"D\" + variable + \".\" + call + \",1\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM3OTY0MQ=="}, "originalCommit": {"oid": "4c93293c2ada3933550f1b64fa303a8785b7b328"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0Nzk2NDE3OnYy", "diffSide": "RIGHT", "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/ECapturingFunctionRef.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNzo1Mzo1OFrOGHXoSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNjozODoyM1rOGJNngw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM4MDM2MQ==", "bodyText": "Add comment on this case.", "url": "https://github.com/elastic/elasticsearch/pull/55190#discussion_r410380361", "createdAt": "2020-04-17T17:53:58Z", "author": {"login": "stu-elastic"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/ECapturingFunctionRef.java", "diffHunk": "@@ -63,51 +59,53 @@ Output analyze(ClassNode classNode, ScriptRoot scriptRoot, Scope scope, Input in\n                     \"not a statement: capturing function reference [\" + variable + \":\"  + call + \"] not used\"));\n         }\n \n-        FunctionRef ref = null;\n-\n         Output output = new Output();\n \n-        captured = scope.getVariable(location, variable);\n+        Variable captured = scope.getVariable(location, variable);\n         if (input.expected == null) {\n+            String defReferenceEncoding;\n             if (captured.getType() == def.class) {\n                 // dynamic implementation\n-                defPointer = \"D\" + variable + \".\" + call + \",1\";\n+                defReferenceEncoding = \"D\" + variable + \".\" + call + \",1\";\n             } else {\n                 // typed implementation\n-                defPointer = \"S\" + captured.getCanonicalTypeName() + \".\" + call + \",1\";\n+                defReferenceEncoding = \"S\" + captured.getCanonicalTypeName() + \".\" + call + \",1\";\n             }\n             output.actual = String.class;\n+\n+            DefInterfaceReferenceNode defInterfaceReferenceNode = new DefInterfaceReferenceNode();\n+\n+            defInterfaceReferenceNode.setLocation(location);\n+            defInterfaceReferenceNode.setExpressionType(output.actual);\n+            defInterfaceReferenceNode.addCapture(captured.getName());\n+            defInterfaceReferenceNode.setDefReferenceEncoding(defReferenceEncoding);\n+\n+            output.expressionNode = defInterfaceReferenceNode;\n         } else {\n-            defPointer = null;\n+            output.actual = input.expected;\n             // static case\n             if (captured.getType() != def.class) {\n-                ref = FunctionRef.create(scriptRoot.getPainlessLookup(), scriptRoot.getFunctionTable(), location,\n+                FunctionRef ref = FunctionRef.create(scriptRoot.getPainlessLookup(), scriptRoot.getFunctionTable(), location,\n                         input.expected, captured.getCanonicalTypeName(), call, 1);\n-            }\n-            output.actual = input.expected;\n-        }\n \n-        CapturingFuncRefNode capturingFuncRefNode = new CapturingFuncRefNode();\n+                TypedInterfaceReferenceNode typedInterfaceReferenceNode = new TypedInterfaceReferenceNode();\n+                typedInterfaceReferenceNode.setLocation(location);\n+                typedInterfaceReferenceNode.setExpressionType(output.actual);\n+                typedInterfaceReferenceNode.addCapture(captured.getName());\n+                typedInterfaceReferenceNode.setReference(ref);\n \n-        capturingFuncRefNode.setLocation(location);\n-        capturingFuncRefNode.setExpressionType(output.actual);\n-        capturingFuncRefNode.setCapturedName(captured.getName());\n-        capturingFuncRefNode.setName(call);\n-        capturingFuncRefNode.setPointer(defPointer);\n-        capturingFuncRefNode.setFuncRef(ref);\n+                output.expressionNode = typedInterfaceReferenceNode;\n+            } else {\n+                TypedCaptureReferenceNode typedCaptureReferenceNode = new TypedCaptureReferenceNode();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c93293c2ada3933550f1b64fa303a8785b7b328"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMxMzQ3NQ==", "bodyText": "commented", "url": "https://github.com/elastic/elasticsearch/pull/55190#discussion_r412313475", "createdAt": "2020-04-21T16:38:23Z", "author": {"login": "jdconrad"}, "path": "modules/lang-painless/src/main/java/org/elasticsearch/painless/node/ECapturingFunctionRef.java", "diffHunk": "@@ -63,51 +59,53 @@ Output analyze(ClassNode classNode, ScriptRoot scriptRoot, Scope scope, Input in\n                     \"not a statement: capturing function reference [\" + variable + \":\"  + call + \"] not used\"));\n         }\n \n-        FunctionRef ref = null;\n-\n         Output output = new Output();\n \n-        captured = scope.getVariable(location, variable);\n+        Variable captured = scope.getVariable(location, variable);\n         if (input.expected == null) {\n+            String defReferenceEncoding;\n             if (captured.getType() == def.class) {\n                 // dynamic implementation\n-                defPointer = \"D\" + variable + \".\" + call + \",1\";\n+                defReferenceEncoding = \"D\" + variable + \".\" + call + \",1\";\n             } else {\n                 // typed implementation\n-                defPointer = \"S\" + captured.getCanonicalTypeName() + \".\" + call + \",1\";\n+                defReferenceEncoding = \"S\" + captured.getCanonicalTypeName() + \".\" + call + \",1\";\n             }\n             output.actual = String.class;\n+\n+            DefInterfaceReferenceNode defInterfaceReferenceNode = new DefInterfaceReferenceNode();\n+\n+            defInterfaceReferenceNode.setLocation(location);\n+            defInterfaceReferenceNode.setExpressionType(output.actual);\n+            defInterfaceReferenceNode.addCapture(captured.getName());\n+            defInterfaceReferenceNode.setDefReferenceEncoding(defReferenceEncoding);\n+\n+            output.expressionNode = defInterfaceReferenceNode;\n         } else {\n-            defPointer = null;\n+            output.actual = input.expected;\n             // static case\n             if (captured.getType() != def.class) {\n-                ref = FunctionRef.create(scriptRoot.getPainlessLookup(), scriptRoot.getFunctionTable(), location,\n+                FunctionRef ref = FunctionRef.create(scriptRoot.getPainlessLookup(), scriptRoot.getFunctionTable(), location,\n                         input.expected, captured.getCanonicalTypeName(), call, 1);\n-            }\n-            output.actual = input.expected;\n-        }\n \n-        CapturingFuncRefNode capturingFuncRefNode = new CapturingFuncRefNode();\n+                TypedInterfaceReferenceNode typedInterfaceReferenceNode = new TypedInterfaceReferenceNode();\n+                typedInterfaceReferenceNode.setLocation(location);\n+                typedInterfaceReferenceNode.setExpressionType(output.actual);\n+                typedInterfaceReferenceNode.addCapture(captured.getName());\n+                typedInterfaceReferenceNode.setReference(ref);\n \n-        capturingFuncRefNode.setLocation(location);\n-        capturingFuncRefNode.setExpressionType(output.actual);\n-        capturingFuncRefNode.setCapturedName(captured.getName());\n-        capturingFuncRefNode.setName(call);\n-        capturingFuncRefNode.setPointer(defPointer);\n-        capturingFuncRefNode.setFuncRef(ref);\n+                output.expressionNode = typedInterfaceReferenceNode;\n+            } else {\n+                TypedCaptureReferenceNode typedCaptureReferenceNode = new TypedCaptureReferenceNode();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM4MDM2MQ=="}, "originalCommit": {"oid": "4c93293c2ada3933550f1b64fa303a8785b7b328"}, "originalPosition": 90}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1024, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}