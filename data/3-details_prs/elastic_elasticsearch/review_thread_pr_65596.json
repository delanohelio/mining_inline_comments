{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI5NDk5NTQx", "number": 65596, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQwOTowODo1MFrOFHt2lQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQyMTo0OToyMFrOFNbOEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzNjM1NjA1OnYy", "diffSide": "LEFT", "path": "buildSrc/src/test/java/org/elasticsearch/gradle/plugin/PluginBuildPluginTests.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQwOTowODo1MFrOIJRJVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQwOTowODo1MFrOIJRJVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU4OTAxMg==", "bodyText": "This test class is not working in a unit test context anymore. The only non ignored test checked for the existence of the registered extension. Thats not enough for me to have this ported to an integ tests at the moment so I removed the unit test.", "url": "https://github.com/elastic/elasticsearch/pull/65596#discussion_r546589012", "createdAt": "2020-12-21T09:08:50Z", "author": {"login": "breskeby"}, "path": "buildSrc/src/test/java/org/elasticsearch/gradle/plugin/PluginBuildPluginTests.java", "diffHunk": "@@ -1,73 +0,0 @@\n-/*\n- * Licensed to Elasticsearch under one or more contributor\n- * license agreements. See the NOTICE file distributed with\n- * this work for additional information regarding copyright\n- * ownership. Elasticsearch licenses this file to you under\n- * the Apache License, Version 2.0 (the \"License\"); you may\n- * not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.elasticsearch.gradle.plugin;\n-\n-import org.elasticsearch.gradle.BwcVersions;\n-import org.elasticsearch.gradle.test.GradleUnitTestCase;\n-import org.gradle.api.Project;\n-import org.gradle.api.Task;\n-import org.gradle.api.internal.project.ProjectInternal;\n-import org.gradle.testfixtures.ProjectBuilder;\n-import org.junit.Before;\n-import org.junit.Ignore;\n-import org.mockito.Mockito;\n-\n-import java.util.stream.Collectors;\n-\n-public class PluginBuildPluginTests extends GradleUnitTestCase {\n-\n-    private Project project;\n-\n-    @Before\n-    public void setUp() throws Exception {\n-        project = ProjectBuilder.builder().withName(getClass().getName()).build();\n-    }\n-\n-    public void testApply() {\n-        // FIXME: distribution download plugin doesn't support running externally\n-        project.getExtensions().getExtraProperties().set(\"bwcVersions\", Mockito.mock(BwcVersions.class));\n-        project.getPlugins().apply(PluginBuildPlugin.class);\n-\n-        assertNotNull(\n-            \"plugin extension created with the right name\",\n-            project.getExtensions().findByName(PluginBuildPlugin.PLUGIN_EXTENSION_NAME)\n-        );\n-        assertNotNull(\"plugin extensions has the right type\", project.getExtensions().findByType(PluginPropertiesExtension.class));\n-\n-        assertNull(\"plugin should not create the integTest task\", project.getTasks().findByName(\"integTest\"));\n-    }\n-\n-    @Ignore(\"https://github.com/elastic/elasticsearch/issues/47123\")\n-    public void testApplyWithAfterEvaluate() {\n-        project.getExtensions().getExtraProperties().set(\"bwcVersions\", Mockito.mock(BwcVersions.class));\n-        project.getPlugins().apply(PluginBuildPlugin.class);\n-        PluginPropertiesExtension extension = project.getExtensions().getByType(PluginPropertiesExtension.class);\n-        extension.setNoticeFile(project.file(\"test.notice\"));\n-        extension.setLicenseFile(project.file(\"test.license\"));\n-        extension.setDescription(\"just a test\");\n-        extension.setClassname(getClass().getName());\n-\n-        ((ProjectInternal) project).evaluate();\n-\n-        assertNotNull(\n-            \"Task to generate notice not created: \" + project.getTasks().stream().map(Task::getPath).collect(Collectors.joining(\", \")),\n-            project.getTasks().findByName(\"generateNotice\")\n-        );\n-    }\n-}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a6402253de1d6e92d6685ca7ce3019e94262d2e"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ5NjE2MDI4OnYy", "diffSide": "RIGHT", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/info/GlobalBuildInfoPlugin.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQyMTozMjozMVrOIRoDyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQwOTo0OTo1MlrOIVhbFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTM1MzAzMw==", "bodyText": "The bit we lose here is that we no longer enorce that the environment variable name matches the JDK version it points at. I guess this would later fail w/ us not being able to resovle a compatible JDK.", "url": "https://github.com/elastic/elasticsearch/pull/65596#discussion_r555353033", "createdAt": "2021-01-11T21:32:31Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/info/GlobalBuildInfoPlugin.java", "diffHunk": "@@ -182,46 +187,33 @@ private JavaVersion determineJavaVersion(String description, File javaHome, Java\n         return actualVersion;\n     }\n \n-    private JavaInstallation getJavaInstallation(File javaHome) {\n-        JavaInstallation installation;\n-        if (isCurrentJavaHome(javaHome)) {\n-            installation = javaInstallationRegistry.getInstallationForCurrentVirtualMachine().get();\n-        } else {\n-            installation = javaInstallationRegistry.installationForDirectory(objects.directoryProperty().fileValue(javaHome)).get();\n-        }\n-\n-        return installation;\n+    private InstallationLocation getJavaInstallation(File javaHome) {\n+        return javaInstallationRegistry.listInstallations()\n+            .stream()\n+            .filter(installationLocation -> isSameFile(javaHome, installationLocation))\n+            .findFirst()\n+            .get();\n     }\n \n-    private List<JavaHome> getAvailableJavaVersions(JavaVersion minimumCompilerVersion) {\n-        final List<JavaHome> javaVersions = new ArrayList<>();\n-        for (int v = 8; v <= Integer.parseInt(minimumCompilerVersion.getMajorVersion()); v++) {\n-            int version = v;\n-            String javaHomeEnvVarName = getJavaHomeEnvVarName(Integer.toString(version));\n-            if (System.getenv(javaHomeEnvVarName) != null) {\n-                File javaHomeDirectory = new File(findJavaHome(Integer.toString(version)));\n-                Provider<JavaInstallation> javaInstallationProvider = javaInstallationRegistry.installationForDirectory(\n-                    objects.directoryProperty().fileValue(javaHomeDirectory)\n-                );\n-                JavaHome javaHome = JavaHome.of(version, providers.provider(() -> {\n-                    int actualVersion = Integer.parseInt(javaInstallationProvider.get().getJavaVersion().getMajorVersion());\n-                    if (actualVersion != version) {\n-                        throwInvalidJavaHomeException(\"env variable \" + javaHomeEnvVarName, javaHomeDirectory, version, actualVersion);\n-                    }\n-                    return javaHomeDirectory;\n-                }));\n-                javaVersions.add(javaHome);\n-            }\n+    private boolean isSameFile(File javaHome, InstallationLocation installationLocation) {\n+        try {\n+            return Files.isSameFile(installationLocation.getLocation().toPath(), javaHome.toPath());\n+        } catch (IOException ioException) {\n+            throw new UncheckedIOException(ioException);\n         }\n-        return javaVersions;\n     }\n \n-    private static boolean isCurrentJavaHome(File javaHome) {\n-        try {\n-            return Files.isSameFile(javaHome.toPath(), Jvm.current().getJavaHome().toPath());\n-        } catch (IOException e) {\n-            throw new UncheckedIOException(e);\n-        }\n+    /**\n+     * We resolve all available java versions using auto detected by gradles tool chain\n+     * To make transition more reliable we only take env var provided installations into account for now\n+     */\n+    private List<JavaHome> getAvailableJavaVersions() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f717ed4027695fdf019c2fb04a064d22d9783a8e"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTYyMjE4Mg==", "bodyText": "good point. is that something you think is worth to invest in? I guess those issues are rare, but when they occur they suck to be debugged I can imagine. Maybe we want to look into this safety net in a follow up?", "url": "https://github.com/elastic/elasticsearch/pull/65596#discussion_r555622182", "createdAt": "2021-01-12T09:22:00Z", "author": {"login": "breskeby"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/info/GlobalBuildInfoPlugin.java", "diffHunk": "@@ -182,46 +187,33 @@ private JavaVersion determineJavaVersion(String description, File javaHome, Java\n         return actualVersion;\n     }\n \n-    private JavaInstallation getJavaInstallation(File javaHome) {\n-        JavaInstallation installation;\n-        if (isCurrentJavaHome(javaHome)) {\n-            installation = javaInstallationRegistry.getInstallationForCurrentVirtualMachine().get();\n-        } else {\n-            installation = javaInstallationRegistry.installationForDirectory(objects.directoryProperty().fileValue(javaHome)).get();\n-        }\n-\n-        return installation;\n+    private InstallationLocation getJavaInstallation(File javaHome) {\n+        return javaInstallationRegistry.listInstallations()\n+            .stream()\n+            .filter(installationLocation -> isSameFile(javaHome, installationLocation))\n+            .findFirst()\n+            .get();\n     }\n \n-    private List<JavaHome> getAvailableJavaVersions(JavaVersion minimumCompilerVersion) {\n-        final List<JavaHome> javaVersions = new ArrayList<>();\n-        for (int v = 8; v <= Integer.parseInt(minimumCompilerVersion.getMajorVersion()); v++) {\n-            int version = v;\n-            String javaHomeEnvVarName = getJavaHomeEnvVarName(Integer.toString(version));\n-            if (System.getenv(javaHomeEnvVarName) != null) {\n-                File javaHomeDirectory = new File(findJavaHome(Integer.toString(version)));\n-                Provider<JavaInstallation> javaInstallationProvider = javaInstallationRegistry.installationForDirectory(\n-                    objects.directoryProperty().fileValue(javaHomeDirectory)\n-                );\n-                JavaHome javaHome = JavaHome.of(version, providers.provider(() -> {\n-                    int actualVersion = Integer.parseInt(javaInstallationProvider.get().getJavaVersion().getMajorVersion());\n-                    if (actualVersion != version) {\n-                        throwInvalidJavaHomeException(\"env variable \" + javaHomeEnvVarName, javaHomeDirectory, version, actualVersion);\n-                    }\n-                    return javaHomeDirectory;\n-                }));\n-                javaVersions.add(javaHome);\n-            }\n+    private boolean isSameFile(File javaHome, InstallationLocation installationLocation) {\n+        try {\n+            return Files.isSameFile(installationLocation.getLocation().toPath(), javaHome.toPath());\n+        } catch (IOException ioException) {\n+            throw new UncheckedIOException(ioException);\n         }\n-        return javaVersions;\n     }\n \n-    private static boolean isCurrentJavaHome(File javaHome) {\n-        try {\n-            return Files.isSameFile(javaHome.toPath(), Jvm.current().getJavaHome().toPath());\n-        } catch (IOException e) {\n-            throw new UncheckedIOException(e);\n-        }\n+    /**\n+     * We resolve all available java versions using auto detected by gradles tool chain\n+     * To make transition more reliable we only take env var provided installations into account for now\n+     */\n+    private List<JavaHome> getAvailableJavaVersions() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTM1MzAzMw=="}, "originalCommit": {"oid": "f717ed4027695fdf019c2fb04a064d22d9783a8e"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njc5ODY5Ng==", "bodyText": "I think realistically what we want to do is remove the reliance on these environment variables and use Gradle's toolchain capabilities to just download a compatible JDK when necessary. These variables are only used for build time purposes, where we intend to run tests with a particular JDK implementation, that's what RUNTIME_JAVA_HOME is for.\nSo I think we can punt here and instead focus on ditching all usages of these things vs resolving JDKs dynamically.", "url": "https://github.com/elastic/elasticsearch/pull/65596#discussion_r556798696", "createdAt": "2021-01-13T20:09:18Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/info/GlobalBuildInfoPlugin.java", "diffHunk": "@@ -182,46 +187,33 @@ private JavaVersion determineJavaVersion(String description, File javaHome, Java\n         return actualVersion;\n     }\n \n-    private JavaInstallation getJavaInstallation(File javaHome) {\n-        JavaInstallation installation;\n-        if (isCurrentJavaHome(javaHome)) {\n-            installation = javaInstallationRegistry.getInstallationForCurrentVirtualMachine().get();\n-        } else {\n-            installation = javaInstallationRegistry.installationForDirectory(objects.directoryProperty().fileValue(javaHome)).get();\n-        }\n-\n-        return installation;\n+    private InstallationLocation getJavaInstallation(File javaHome) {\n+        return javaInstallationRegistry.listInstallations()\n+            .stream()\n+            .filter(installationLocation -> isSameFile(javaHome, installationLocation))\n+            .findFirst()\n+            .get();\n     }\n \n-    private List<JavaHome> getAvailableJavaVersions(JavaVersion minimumCompilerVersion) {\n-        final List<JavaHome> javaVersions = new ArrayList<>();\n-        for (int v = 8; v <= Integer.parseInt(minimumCompilerVersion.getMajorVersion()); v++) {\n-            int version = v;\n-            String javaHomeEnvVarName = getJavaHomeEnvVarName(Integer.toString(version));\n-            if (System.getenv(javaHomeEnvVarName) != null) {\n-                File javaHomeDirectory = new File(findJavaHome(Integer.toString(version)));\n-                Provider<JavaInstallation> javaInstallationProvider = javaInstallationRegistry.installationForDirectory(\n-                    objects.directoryProperty().fileValue(javaHomeDirectory)\n-                );\n-                JavaHome javaHome = JavaHome.of(version, providers.provider(() -> {\n-                    int actualVersion = Integer.parseInt(javaInstallationProvider.get().getJavaVersion().getMajorVersion());\n-                    if (actualVersion != version) {\n-                        throwInvalidJavaHomeException(\"env variable \" + javaHomeEnvVarName, javaHomeDirectory, version, actualVersion);\n-                    }\n-                    return javaHomeDirectory;\n-                }));\n-                javaVersions.add(javaHome);\n-            }\n+    private boolean isSameFile(File javaHome, InstallationLocation installationLocation) {\n+        try {\n+            return Files.isSameFile(installationLocation.getLocation().toPath(), javaHome.toPath());\n+        } catch (IOException ioException) {\n+            throw new UncheckedIOException(ioException);\n         }\n-        return javaVersions;\n     }\n \n-    private static boolean isCurrentJavaHome(File javaHome) {\n-        try {\n-            return Files.isSameFile(javaHome.toPath(), Jvm.current().getJavaHome().toPath());\n-        } catch (IOException e) {\n-            throw new UncheckedIOException(e);\n-        }\n+    /**\n+     * We resolve all available java versions using auto detected by gradles tool chain\n+     * To make transition more reliable we only take env var provided installations into account for now\n+     */\n+    private List<JavaHome> getAvailableJavaVersions() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTM1MzAzMw=="}, "originalCommit": {"oid": "f717ed4027695fdf019c2fb04a064d22d9783a8e"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTQzNjkwNg==", "bodyText": "I will look into this in a separate PR. I didn't want to make too many changes in this PR. So  RUNTIME_JAVA_HOME is basically used to configure the jdk on CI to run all tests against?", "url": "https://github.com/elastic/elasticsearch/pull/65596#discussion_r559436906", "createdAt": "2021-01-18T09:47:24Z", "author": {"login": "breskeby"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/info/GlobalBuildInfoPlugin.java", "diffHunk": "@@ -182,46 +187,33 @@ private JavaVersion determineJavaVersion(String description, File javaHome, Java\n         return actualVersion;\n     }\n \n-    private JavaInstallation getJavaInstallation(File javaHome) {\n-        JavaInstallation installation;\n-        if (isCurrentJavaHome(javaHome)) {\n-            installation = javaInstallationRegistry.getInstallationForCurrentVirtualMachine().get();\n-        } else {\n-            installation = javaInstallationRegistry.installationForDirectory(objects.directoryProperty().fileValue(javaHome)).get();\n-        }\n-\n-        return installation;\n+    private InstallationLocation getJavaInstallation(File javaHome) {\n+        return javaInstallationRegistry.listInstallations()\n+            .stream()\n+            .filter(installationLocation -> isSameFile(javaHome, installationLocation))\n+            .findFirst()\n+            .get();\n     }\n \n-    private List<JavaHome> getAvailableJavaVersions(JavaVersion minimumCompilerVersion) {\n-        final List<JavaHome> javaVersions = new ArrayList<>();\n-        for (int v = 8; v <= Integer.parseInt(minimumCompilerVersion.getMajorVersion()); v++) {\n-            int version = v;\n-            String javaHomeEnvVarName = getJavaHomeEnvVarName(Integer.toString(version));\n-            if (System.getenv(javaHomeEnvVarName) != null) {\n-                File javaHomeDirectory = new File(findJavaHome(Integer.toString(version)));\n-                Provider<JavaInstallation> javaInstallationProvider = javaInstallationRegistry.installationForDirectory(\n-                    objects.directoryProperty().fileValue(javaHomeDirectory)\n-                );\n-                JavaHome javaHome = JavaHome.of(version, providers.provider(() -> {\n-                    int actualVersion = Integer.parseInt(javaInstallationProvider.get().getJavaVersion().getMajorVersion());\n-                    if (actualVersion != version) {\n-                        throwInvalidJavaHomeException(\"env variable \" + javaHomeEnvVarName, javaHomeDirectory, version, actualVersion);\n-                    }\n-                    return javaHomeDirectory;\n-                }));\n-                javaVersions.add(javaHome);\n-            }\n+    private boolean isSameFile(File javaHome, InstallationLocation installationLocation) {\n+        try {\n+            return Files.isSameFile(installationLocation.getLocation().toPath(), javaHome.toPath());\n+        } catch (IOException ioException) {\n+            throw new UncheckedIOException(ioException);\n         }\n-        return javaVersions;\n     }\n \n-    private static boolean isCurrentJavaHome(File javaHome) {\n-        try {\n-            return Files.isSameFile(javaHome.toPath(), Jvm.current().getJavaHome().toPath());\n-        } catch (IOException e) {\n-            throw new UncheckedIOException(e);\n-        }\n+    /**\n+     * We resolve all available java versions using auto detected by gradles tool chain\n+     * To make transition more reliable we only take env var provided installations into account for now\n+     */\n+    private List<JavaHome> getAvailableJavaVersions() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTM1MzAzMw=="}, "originalCommit": {"oid": "f717ed4027695fdf019c2fb04a064d22d9783a8e"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTQzODYxNQ==", "bodyText": "The problem I see at the moment is that the compatibility choices (which vendor is available etc.) is limited in gradle at the moment and might not be enough. If you say that's less of an issue for build time then the toolchain capabilities in gradle might be enough at the moment to pick a proper one", "url": "https://github.com/elastic/elasticsearch/pull/65596#discussion_r559438615", "createdAt": "2021-01-18T09:49:52Z", "author": {"login": "breskeby"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/info/GlobalBuildInfoPlugin.java", "diffHunk": "@@ -182,46 +187,33 @@ private JavaVersion determineJavaVersion(String description, File javaHome, Java\n         return actualVersion;\n     }\n \n-    private JavaInstallation getJavaInstallation(File javaHome) {\n-        JavaInstallation installation;\n-        if (isCurrentJavaHome(javaHome)) {\n-            installation = javaInstallationRegistry.getInstallationForCurrentVirtualMachine().get();\n-        } else {\n-            installation = javaInstallationRegistry.installationForDirectory(objects.directoryProperty().fileValue(javaHome)).get();\n-        }\n-\n-        return installation;\n+    private InstallationLocation getJavaInstallation(File javaHome) {\n+        return javaInstallationRegistry.listInstallations()\n+            .stream()\n+            .filter(installationLocation -> isSameFile(javaHome, installationLocation))\n+            .findFirst()\n+            .get();\n     }\n \n-    private List<JavaHome> getAvailableJavaVersions(JavaVersion minimumCompilerVersion) {\n-        final List<JavaHome> javaVersions = new ArrayList<>();\n-        for (int v = 8; v <= Integer.parseInt(minimumCompilerVersion.getMajorVersion()); v++) {\n-            int version = v;\n-            String javaHomeEnvVarName = getJavaHomeEnvVarName(Integer.toString(version));\n-            if (System.getenv(javaHomeEnvVarName) != null) {\n-                File javaHomeDirectory = new File(findJavaHome(Integer.toString(version)));\n-                Provider<JavaInstallation> javaInstallationProvider = javaInstallationRegistry.installationForDirectory(\n-                    objects.directoryProperty().fileValue(javaHomeDirectory)\n-                );\n-                JavaHome javaHome = JavaHome.of(version, providers.provider(() -> {\n-                    int actualVersion = Integer.parseInt(javaInstallationProvider.get().getJavaVersion().getMajorVersion());\n-                    if (actualVersion != version) {\n-                        throwInvalidJavaHomeException(\"env variable \" + javaHomeEnvVarName, javaHomeDirectory, version, actualVersion);\n-                    }\n-                    return javaHomeDirectory;\n-                }));\n-                javaVersions.add(javaHome);\n-            }\n+    private boolean isSameFile(File javaHome, InstallationLocation installationLocation) {\n+        try {\n+            return Files.isSameFile(installationLocation.getLocation().toPath(), javaHome.toPath());\n+        } catch (IOException ioException) {\n+            throw new UncheckedIOException(ioException);\n         }\n-        return javaVersions;\n     }\n \n-    private static boolean isCurrentJavaHome(File javaHome) {\n-        try {\n-            return Files.isSameFile(javaHome.toPath(), Jvm.current().getJavaHome().toPath());\n-        } catch (IOException e) {\n-            throw new UncheckedIOException(e);\n-        }\n+    /**\n+     * We resolve all available java versions using auto detected by gradles tool chain\n+     * To make transition more reliable we only take env var provided installations into account for now\n+     */\n+    private List<JavaHome> getAvailableJavaVersions() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTM1MzAzMw=="}, "originalCommit": {"oid": "f717ed4027695fdf019c2fb04a064d22d9783a8e"}, "originalPosition": 158}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ5NjE4MDQyOnYy", "diffSide": "RIGHT", "path": "buildSrc/src/integTest/groovy/org/elasticsearch/gradle/fixtures/AbstractGradleFuncTest.groovy", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQyMTozNzoyNFrOIRoP8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQwOToyNDoxNVrOIR4k-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTM1NjE0Nw==", "bodyText": "assertOutputDoesNotContain or assertOutputMissing?", "url": "https://github.com/elastic/elasticsearch/pull/65596#discussion_r555356147", "createdAt": "2021-01-11T21:37:24Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/integTest/groovy/org/elasticsearch/gradle/fixtures/AbstractGradleFuncTest.groovy", "diffHunk": "@@ -60,6 +63,10 @@ abstract class AbstractGradleFuncTest extends Specification {\n         true\n     }\n \n+    def assertOutputContainsNot(String givenOutput, String expected) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f717ed4027695fdf019c2fb04a064d22d9783a8e"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTYyMzY3Mg==", "bodyText": "thanks. assertOutputMissing it is", "url": "https://github.com/elastic/elasticsearch/pull/65596#discussion_r555623672", "createdAt": "2021-01-12T09:24:15Z", "author": {"login": "breskeby"}, "path": "buildSrc/src/integTest/groovy/org/elasticsearch/gradle/fixtures/AbstractGradleFuncTest.groovy", "diffHunk": "@@ -60,6 +63,10 @@ abstract class AbstractGradleFuncTest extends Specification {\n         true\n     }\n \n+    def assertOutputContainsNot(String givenOutput, String expected) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTM1NjE0Nw=="}, "originalCommit": {"oid": "f717ed4027695fdf019c2fb04a064d22d9783a8e"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ5NjIxMjE1OnYy", "diffSide": "RIGHT", "path": "buildSrc/src/integTest/java/org/elasticsearch/gradle/BuildPluginIT.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQyMTo0NzozN1rOIRojYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQwOToyNDozOVrOIR4mCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTM2MTEyMw==", "bodyText": "Do we want to keep this here or was this only for testing? I'm ok with keeping this around across the board BTW.", "url": "https://github.com/elastic/elasticsearch/pull/65596#discussion_r555361123", "createdAt": "2021-01-11T21:47:37Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/integTest/java/org/elasticsearch/gradle/BuildPluginIT.java", "diffHunk": "@@ -105,7 +105,9 @@ private void runInsecureArtifactRepositoryTest(final String name, final String u\n             .withProjectDir(tmpDir.getRoot())\n             .withArguments(\"clean\", \"hello\", \"-s\", \"-i\", \"--warning-mode=all\", \"--scan\")\n             .withPluginClasspath()\n+            .forwardOutput()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f717ed4027695fdf019c2fb04a064d22d9783a8e"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTYyMzk0Ng==", "bodyText": "I think we should keep it.", "url": "https://github.com/elastic/elasticsearch/pull/65596#discussion_r555623946", "createdAt": "2021-01-12T09:24:39Z", "author": {"login": "breskeby"}, "path": "buildSrc/src/integTest/java/org/elasticsearch/gradle/BuildPluginIT.java", "diffHunk": "@@ -105,7 +105,9 @@ private void runInsecureArtifactRepositoryTest(final String name, final String u\n             .withProjectDir(tmpDir.getRoot())\n             .withArguments(\"clean\", \"hello\", \"-s\", \"-i\", \"--warning-mode=all\", \"--scan\")\n             .withPluginClasspath()\n+            .forwardOutput()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTM2MTEyMw=="}, "originalCommit": {"oid": "f717ed4027695fdf019c2fb04a064d22d9783a8e"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ5NjIxNzc3OnYy", "diffSide": "RIGHT", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/precommit/JarHellPrecommitPlugin.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQyMTo0OToyMFrOIRomvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQwOTozOTo0NVrOIR5Nnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTM2MTk4MA==", "bodyText": "I think that's fine anyway as we don't expect this to be replaced.", "url": "https://github.com/elastic/elasticsearch/pull/65596#discussion_r555361980", "createdAt": "2021-01-11T21:49:20Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/precommit/JarHellPrecommitPlugin.java", "diffHunk": "@@ -32,6 +32,9 @@\n     public TaskProvider<? extends Task> createTask(Project project) {\n         Configuration jarHellConfig = project.getConfigurations().create(\"jarHell\");\n         if (BuildParams.isInternal() && project.getPath().equals(\":libs:elasticsearch-core\") == false) {\n+            // ideally we would configure this as a default dependency. But Default dependencies do not work correctly", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f717ed4027695fdf019c2fb04a064d22d9783a8e"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTM2MjUyOQ==", "bodyText": "Other question though. How does this work for external builds? Where does the jarhell implementation come from?", "url": "https://github.com/elastic/elasticsearch/pull/65596#discussion_r555362529", "createdAt": "2021-01-11T21:50:31Z", "author": {"login": "mark-vieira"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/precommit/JarHellPrecommitPlugin.java", "diffHunk": "@@ -32,6 +32,9 @@\n     public TaskProvider<? extends Task> createTask(Project project) {\n         Configuration jarHellConfig = project.getConfigurations().create(\"jarHell\");\n         if (BuildParams.isInternal() && project.getPath().equals(\":libs:elasticsearch-core\") == false) {\n+            // ideally we would configure this as a default dependency. But Default dependencies do not work correctly", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTM2MTk4MA=="}, "originalCommit": {"oid": "f717ed4027695fdf019c2fb04a064d22d9783a8e"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTYzNDA3OQ==", "bodyText": "You would need to add a dependency like `jarHell 'org.elasticsearch:elasticsearch-core:7.10' at the moment. In general I think we need to put some more dedicated effort into making these external available plugins work nicely for contributors. By that I mean having proper test coverage of third party plugin author use cases etc. I remember we talked about that very early on when having our first talks about the elastic build already.\nWe're moving in that direction with having internal plugins nowadays but there's more work required here", "url": "https://github.com/elastic/elasticsearch/pull/65596#discussion_r555634079", "createdAt": "2021-01-12T09:39:45Z", "author": {"login": "breskeby"}, "path": "buildSrc/src/main/java/org/elasticsearch/gradle/precommit/JarHellPrecommitPlugin.java", "diffHunk": "@@ -32,6 +32,9 @@\n     public TaskProvider<? extends Task> createTask(Project project) {\n         Configuration jarHellConfig = project.getConfigurations().create(\"jarHell\");\n         if (BuildParams.isInternal() && project.getPath().equals(\":libs:elasticsearch-core\") == false) {\n+            // ideally we would configure this as a default dependency. But Default dependencies do not work correctly", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTM2MTk4MA=="}, "originalCommit": {"oid": "f717ed4027695fdf019c2fb04a064d22d9783a8e"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1984, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}