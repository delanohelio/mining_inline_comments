{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkzMzc0ODQ4", "number": 54148, "title": "Add wildcard service providers", "bodyText": "This adds the ability to define wildcard services providers in a JSON\nfile within the ES node's config directory.\nIf a request is made for a service provider that has not been\nregistered, then the set of wildcard services is consulted. If the\nSP entity-id and ACS match one of the wildcard patterns, then a\ndynamic service provider is defined from the associated mustache\ntemplate.", "createdAt": "2020-03-25T04:17:44Z", "url": "https://github.com/elastic/elasticsearch/pull/54148", "merged": true, "mergeCommit": {"oid": "ef45e06027767322a6fa8268be6fed40bbe15752"}, "closed": true, "closedAt": "2020-03-30T15:42:51Z", "author": {"login": "tvernum"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcQ_nTQgH2gAyMzkzMzc0ODQ4OmNjMjgwN2RlYWViNWZlNmM1ZjBiODZkNmUyNWRhZjk1NDY1YjBlNjk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcSvHYPgH2gAyMzkzMzc0ODQ4OmFjZjg5YjgxYTU5ZTNiYzUzMjFmMzZiZDM2NzgxZWUxNmY1NjVkODQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "cc2807deaeb5fe6c5f0b86d6e25daf95465b0e69", "author": {"user": {"login": "tvernum", "name": "Tim Vernum"}}, "url": "https://github.com/elastic/elasticsearch/commit/cc2807deaeb5fe6c5f0b86d6e25daf95465b0e69", "committedDate": "2020-03-25T04:15:49Z", "message": "Add wildcard service providers\n\nThis adds the ability to define wildcard services providers in a JSON\nfile within the ES node's config directory.\n\nIf a request is made for a service provider that has not been\nregistered, then the set of wildcard services is consulted. If the\nSP entity-id and ACS match one of the wildcard patterns, then a\ndynamic service provider is defined from the associated mustache\ntemplate."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwODUyMjc3", "url": "https://github.com/elastic/elasticsearch/pull/54148#pullrequestreview-380852277", "createdAt": "2020-03-25T04:29:22Z", "commit": {"oid": "cc2807deaeb5fe6c5f0b86d6e25daf95465b0e69"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQwNDoyOToyMlrOF7LzcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQwNDoyOToyMlrOF7LzcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwMzY5Ng==", "bodyText": "This code was extracted from the SamlServiceProviderResolver so that it could be used by the WildcardServiceProviderResolver", "url": "https://github.com/elastic/elasticsearch/pull/54148#discussion_r397603696", "createdAt": "2020-03-25T04:29:22Z", "author": {"login": "tvernum"}, "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/saml/sp/SamlServiceProviderFactory.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.idp.saml.sp;\n+\n+import org.elasticsearch.xpack.idp.privileges.ServiceProviderPrivileges;\n+import org.joda.time.ReadableDuration;\n+import org.opensaml.security.x509.BasicX509Credential;\n+import org.opensaml.security.x509.X509Credential;\n+\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A class for creating a {@link SamlServiceProvider} from a {@link SamlServiceProviderDocument}.\n+ */\n+public final class SamlServiceProviderFactory {\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc2807deaeb5fe6c5f0b86d6e25daf95465b0e69"}, "originalPosition": 25}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f7a31e7fac0e47aa4bc0c2c1d6b8f7b0e398a4f7", "author": {"user": {"login": "tvernum", "name": "Tim Vernum"}}, "url": "https://github.com/elastic/elasticsearch/commit/f7a31e7fac0e47aa4bc0c2c1d6b8f7b0e398a4f7", "committedDate": "2020-03-25T05:09:08Z", "message": "Fixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgxODgyODEy", "url": "https://github.com/elastic/elasticsearch/pull/54148#pullrequestreview-381882812", "createdAt": "2020-03-26T10:37:00Z", "commit": {"oid": "f7a31e7fac0e47aa4bc0c2c1d6b8f7b0e398a4f7"}, "state": "COMMENTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMDozNzowMFrOF8As0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNDowODowOVrOF8Io1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQ3MDM1NA==", "bodyText": "Is this return value only used for testing?", "url": "https://github.com/elastic/elasticsearch/pull/54148#discussion_r398470354", "createdAt": "2020-03-26T10:37:00Z", "author": {"login": "jkakavas"}, "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/saml/sp/WildcardServiceProviderResolver.java", "diffHunk": "@@ -0,0 +1,235 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.idp.saml.sp;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.ParsingException;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.cache.Cache;\n+import org.elasticsearch.common.collect.Tuple;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.iterable.Iterables;\n+import org.elasticsearch.common.xcontent.LoggingDeprecationHandler;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.XContentLocation;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentParserUtils;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.env.Environment;\n+import org.elasticsearch.script.ScriptService;\n+import org.elasticsearch.watcher.FileChangesListener;\n+import org.elasticsearch.watcher.FileWatcher;\n+import org.elasticsearch.watcher.ResourceWatcherService;\n+import org.elasticsearch.xpack.core.XPackPlugin;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+public class WildcardServiceProviderResolver {\n+\n+    public static final Setting<String> FILE_PATH_SETTING = Setting.simpleString(\"xpack.idp.sp.wildcard.path\",\n+        \"wildcard_services.json\", Setting.Property.NodeScope);\n+\n+    private class State {\n+        final Map<String, WildcardServiceProvider> services;\n+        final Cache<Tuple<String, String>, SamlServiceProvider> cache;\n+\n+        private State(Map<String, WildcardServiceProvider> services) {\n+            this.services = services;\n+            this.cache = ServiceProviderCacheSettings.buildCache(settings);\n+        }\n+    }\n+\n+    private static final Logger logger = LogManager.getLogger();\n+\n+    private final Settings settings;\n+    private final ScriptService scriptService;\n+    private final SamlServiceProviderFactory serviceProviderFactory;\n+    private final AtomicReference<State> stateRef;\n+\n+    WildcardServiceProviderResolver(Settings settings, ScriptService scriptService, SamlServiceProviderFactory serviceProviderFactory) {\n+        this.settings = settings;\n+        this.scriptService = scriptService;\n+        this.serviceProviderFactory = serviceProviderFactory;\n+        this.stateRef = new AtomicReference<>(new State(Map.of()));\n+    }\n+\n+    /**\n+     * This is implemented as a factory method to facilitate testing - the core resolver just works on InputStreams, this method\n+     * handles all the Path/ResourceWatcher logic\n+     */\n+    public static WildcardServiceProviderResolver create(Environment environment,\n+                                                         ResourceWatcherService resourceWatcherService,\n+                                                         ScriptService scriptService,\n+                                                         SamlServiceProviderFactory spFactory) {\n+        final Settings settings = environment.settings();\n+        final Path path = XPackPlugin.resolveConfigFile(environment, FILE_PATH_SETTING.get(environment.settings()));\n+\n+        logger.info(\"Loading wildcard services from file [{}]\", path.toAbsolutePath());\n+\n+        final WildcardServiceProviderResolver resolver = new WildcardServiceProviderResolver(settings, scriptService, spFactory);\n+\n+        if (Files.exists(path)) {\n+            try {\n+                resolver.reload(path);\n+            } catch (IOException e) {\n+                throw new ElasticsearchException(\"File [{}] (from setting [{}]) cannot be loaded\",\n+                    e, path.toAbsolutePath(), FILE_PATH_SETTING.getKey());\n+            }\n+        } else if (FILE_PATH_SETTING.exists(environment.settings())) {\n+            // A file was explicitly configured, but doesn't exist. That's a mistake...\n+            throw new ElasticsearchException(\"File [{}] (from setting [{}]) does not exist\",\n+                path.toAbsolutePath(), FILE_PATH_SETTING.getKey());\n+        }\n+\n+        final FileWatcher fileWatcher = new FileWatcher(path);\n+        fileWatcher.addListener(new FileChangesListener() {\n+            @Override\n+            public void onFileCreated(Path file) {\n+                onFileChanged(file);\n+            }\n+\n+            @Override\n+            public void onFileDeleted(Path file) {\n+                onFileChanged(file);\n+            }\n+\n+            @Override\n+            public void onFileChanged(Path file) {\n+                try {\n+                    resolver.reload(file);\n+                } catch (IOException e) {\n+                    throw new UncheckedIOException(e);\n+                }\n+            }\n+        });\n+        try {\n+            resourceWatcherService.add(fileWatcher);\n+        } catch (IOException e) {\n+            throw new ElasticsearchException(\"Failed to watch file [{}] (from setting [{}])\",\n+                e, path.toAbsolutePath(), FILE_PATH_SETTING.getKey());\n+        }\n+        return resolver;\n+    }\n+\n+    public SamlServiceProvider resolve(String entityId, String acs) {\n+        final State currentState = stateRef.get();\n+\n+        Tuple<String, String> cacheKey = new Tuple<>(entityId, acs);\n+        final SamlServiceProvider cached = currentState.cache.get(cacheKey);\n+        if (cached != null) {\n+            logger.trace(\"Service for [{}] [{}] is cached [{}]\", entityId, acs, cached);\n+            return cached;\n+        }\n+\n+        final Map<String, SamlServiceProvider> matches = new HashMap<>();\n+        currentState.services.forEach((name, wildcard) -> {\n+            final SamlServiceProviderDocument doc = wildcard.apply(scriptService, entityId, acs);\n+            if (doc != null) {\n+                final SamlServiceProvider sp = serviceProviderFactory.buildServiceProvider(doc);\n+                matches.put(name, sp);\n+            }\n+        });\n+\n+        switch (matches.size()) {\n+            case 0:\n+                logger.trace(\"No wildcard services found for [{}] [{}]\", entityId, acs);\n+                return null;\n+\n+            case 1:\n+                final SamlServiceProvider serviceProvider = Iterables.get(matches.values(), 0);\n+                logger.debug(\"Found exactly 1 wildcard service for [{}] [{}] - [{}]\", entityId, acs, serviceProvider);\n+                currentState.cache.put(cacheKey, serviceProvider);\n+                return serviceProvider;\n+\n+            default:\n+                final String names = Strings.collectionToCommaDelimitedString(matches.keySet());\n+                logger.warn(\"Found multiple matching wildcard services for [{}] [{}] - [{}]\", entityId, acs, names);\n+                throw new IllegalStateException(\n+                    \"Found multiple wildcard service providers for entity ID [\" + entityId + \"] and ACS [\" + acs\n+                        + \"] - wildcard service names [\" + names + \"]\");\n+        }\n+    }\n+\n+    // For testing\n+    Map<String, WildcardServiceProvider> services() {\n+        return stateRef.get().services;\n+    }\n+\n+    // Accessible for testing\n+    boolean reload(XContentParser parser) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7a31e7fac0e47aa4bc0c2c1d6b8f7b0e398a4f7"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQ3MzMxNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final SamlServiceProviderResolver serviceResolver = new SamlServiceProviderResolver(settings, index, serviceProviderFactory);\n          \n          \n            \n                    final SamlServiceProviderResolver registeredSpResolver = new SamlServiceProviderResolver(settings, index, serviceProviderFactory);", "url": "https://github.com/elastic/elasticsearch/pull/54148#discussion_r398473315", "createdAt": "2020-03-26T10:41:52Z", "author": {"login": "jkakavas"}, "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/IdentityProviderPlugin.java", "diffHunk": "@@ -95,8 +98,11 @@\n \n \n         final ServiceProviderDefaults serviceProviderDefaults = ServiceProviderDefaults.forSettings(settings);\n-        final SamlServiceProviderResolver resolver = new SamlServiceProviderResolver(settings, index, serviceProviderDefaults);\n-        final SamlIdentityProvider idp = SamlIdentityProvider.builder(resolver)\n+        final SamlServiceProviderFactory serviceProviderFactory = new SamlServiceProviderFactory(serviceProviderDefaults);\n+        final SamlServiceProviderResolver serviceResolver = new SamlServiceProviderResolver(settings, index, serviceProviderFactory);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7a31e7fac0e47aa4bc0c2c1d6b8f7b0e398a4f7"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQ3MzQ2Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final WildcardServiceProviderResolver wildcardResolver = WildcardServiceProviderResolver.create(environment, resourceWatcherService,\n          \n          \n            \n                    final WildcardServiceProviderResolver wildcardSpResolver = WildcardServiceProviderResolver.create(environment, resourceWatcherService,", "url": "https://github.com/elastic/elasticsearch/pull/54148#discussion_r398473466", "createdAt": "2020-03-26T10:42:07Z", "author": {"login": "jkakavas"}, "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/IdentityProviderPlugin.java", "diffHunk": "@@ -95,8 +98,11 @@\n \n \n         final ServiceProviderDefaults serviceProviderDefaults = ServiceProviderDefaults.forSettings(settings);\n-        final SamlServiceProviderResolver resolver = new SamlServiceProviderResolver(settings, index, serviceProviderDefaults);\n-        final SamlIdentityProvider idp = SamlIdentityProvider.builder(resolver)\n+        final SamlServiceProviderFactory serviceProviderFactory = new SamlServiceProviderFactory(serviceProviderDefaults);\n+        final SamlServiceProviderResolver serviceResolver = new SamlServiceProviderResolver(settings, index, serviceProviderFactory);\n+        final WildcardServiceProviderResolver wildcardResolver = WildcardServiceProviderResolver.create(environment, resourceWatcherService,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7a31e7fac0e47aa4bc0c2c1d6b8f7b0e398a4f7"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQ3NDkwOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void getRegisteredServiceProvider(String spEntityId, @Nullable String acs, boolean allowDisabled,\n          \n          \n            \n                public void resolveServiceProvider(String spEntityId, @Nullable String acs, boolean allowDisabled,", "url": "https://github.com/elastic/elasticsearch/pull/54148#discussion_r398474908", "createdAt": "2020-03-26T10:44:35Z", "author": {"login": "jkakavas"}, "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/saml/idp/SamlIdentityProvider.java", "diffHunk": "@@ -103,18 +108,21 @@ public ServiceProviderDefaults getServiceProviderDefaults() {\n \n     /**\n      * Asynchronously lookup the specified {@link SamlServiceProvider} by entity-id.\n+     * @param spEntityId The (URI) entity ID of the service provider\n+     * @param acs The ACS of the service provider - only used if there is no service provider and we need to dynamically define one from\n+     *            a template (wildcard). May be null, in which case wildcard services will not be resolved.\n      * @param allowDisabled whether to return service providers that are not {@link SamlServiceProvider#isEnabled() enabled}.\n      *                      For security reasons, callers should typically avoid working with disabled service providers.\n      * @param listener Responds with the requested Service Provider object, or {@code null} if no such SP exists.\n-     *                 {@link ActionListener#onFailure} is only used for fatal errors (e.g. being unable to access\n-     *                 the backing store (elasticsearch index) that hold the SP data).\n+ *                 {@link ActionListener#onFailure} is only used for fatal errors (e.g. being unable to access\n      */\n-    public void getRegisteredServiceProvider(String spEntityId, boolean allowDisabled, ActionListener<SamlServiceProvider> listener) {\n+    public void getRegisteredServiceProvider(String spEntityId, @Nullable String acs, boolean allowDisabled,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7a31e7fac0e47aa4bc0c2c1d6b8f7b0e398a4f7"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQ5ODI3MA==", "bodyText": "Why do we make acs mandatory, even for IDP initiated SSO for registered SPs?", "url": "https://github.com/elastic/elasticsearch/pull/54148#discussion_r398498270", "createdAt": "2020-03-26T11:25:09Z", "author": {"login": "jkakavas"}, "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/action/SamlInitiateSingleSignOnRequest.java", "diffHunk": "@@ -37,6 +39,9 @@ public ActionRequestValidationException validate() {\n         if (Strings.isNullOrEmpty(spEntityId)) {\n             validationException = addValidationError(\"entity_id is missing\", validationException);\n         }\n+        if (Strings.isNullOrEmpty(assertionConsumerService)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7a31e7fac0e47aa4bc0c2c1d6b8f7b0e398a4f7"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUwMzI1MA==", "bodyText": "I think we should retain the original approach where SamlAuthenticationState and its contents should only be used for passing the authentication state between subsequent calls to our APIs. As such we should not \"leak\" internals to populate other values unless we have to.", "url": "https://github.com/elastic/elasticsearch/pull/54148#discussion_r398503250", "createdAt": "2020-03-26T11:34:16Z", "author": {"login": "jkakavas"}, "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/action/SamlInitiateSingleSignOnRequest.java", "diffHunk": "@@ -56,23 +61,36 @@ public void setSpEntityId(String spEntityId) {\n         this.spEntityId = spEntityId;\n     }\n \n+    public String getAssertionConsumerService() {\n+        return assertionConsumerService;\n+    }\n+\n+    public void setAssertionConsumerService(String assertionConsumerService) {\n+        this.assertionConsumerService = assertionConsumerService;\n+    }\n+\n     public SamlAuthenticationState getSamlAuthenticationState() {\n         return samlAuthenticationState;\n     }\n \n     public void setSamlAuthenticationState(SamlAuthenticationState samlAuthenticationState) {\n         this.samlAuthenticationState = samlAuthenticationState;\n+        if (samlAuthenticationState != null && assertionConsumerService == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7a31e7fac0e47aa4bc0c2c1d6b8f7b0e398a4f7"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUwNTgxNw==", "bodyText": "AFAICU this is only used so that we can log in https://github.com/elastic/elasticsearch/pull/54148/files#diff-d9aa6ce953a2c6b16841d40716f53612R68 ? Since the getRegisteredProvider accepts a null value so it shouldn't matter there", "url": "https://github.com/elastic/elasticsearch/pull/54148#discussion_r398505817", "createdAt": "2020-03-26T11:39:07Z", "author": {"login": "jkakavas"}, "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/action/SamlInitiateSingleSignOnRequest.java", "diffHunk": "@@ -56,23 +61,36 @@ public void setSpEntityId(String spEntityId) {\n         this.spEntityId = spEntityId;\n     }\n \n+    public String getAssertionConsumerService() {\n+        return assertionConsumerService;\n+    }\n+\n+    public void setAssertionConsumerService(String assertionConsumerService) {\n+        this.assertionConsumerService = assertionConsumerService;\n+    }\n+\n     public SamlAuthenticationState getSamlAuthenticationState() {\n         return samlAuthenticationState;\n     }\n \n     public void setSamlAuthenticationState(SamlAuthenticationState samlAuthenticationState) {\n         this.samlAuthenticationState = samlAuthenticationState;\n+        if (samlAuthenticationState != null && assertionConsumerService == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUwMzI1MA=="}, "originalCommit": {"oid": "f7a31e7fac0e47aa4bc0c2c1d6b8f7b0e398a4f7"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUxMjM3Nw==", "bodyText": "log something here since we only TRACE log in the WildcardServiceResolver resolve and it won't be easily noticeble if the acs was null or we didn't have any matches ?", "url": "https://github.com/elastic/elasticsearch/pull/54148#discussion_r398512377", "createdAt": "2020-03-26T11:51:03Z", "author": {"login": "jkakavas"}, "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/saml/idp/SamlIdentityProvider.java", "diffHunk": "@@ -127,6 +135,18 @@ public void getRegisteredServiceProvider(String spEntityId, boolean allowDisable\n         ));\n     }\n \n+    private void resolveWildcardService(String entityId, String acs, ActionListener<SamlServiceProvider> listener) {\n+        if (acs == null) {\n+            listener.onResponse(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7a31e7fac0e47aa4bc0c2c1d6b8f7b0e398a4f7"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUxNDExMQ==", "bodyText": "nit: maybe registered is not the right word anymore? \"is not known to this Identity Provider\" ?", "url": "https://github.com/elastic/elasticsearch/pull/54148#discussion_r398514111", "createdAt": "2020-03-26T11:54:12Z", "author": {"login": "jkakavas"}, "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/action/TransportSamlInitiateSingleSignOnAction.java", "diffHunk": "@@ -57,11 +57,15 @@ public TransportSamlInitiateSingleSignOnAction(TransportService transportService\n     protected void doExecute(Task task, SamlInitiateSingleSignOnRequest request,\n                              ActionListener<SamlInitiateSingleSignOnResponse> listener) {\n         final SamlAuthenticationState authenticationState = request.getSamlAuthenticationState();\n-        identityProvider.getRegisteredServiceProvider(request.getSpEntityId(), false, ActionListener.wrap(\n+        identityProvider.getRegisteredServiceProvider(\n+            request.getSpEntityId(),\n+            request.getAssertionConsumerService(),\n+            false,\n+            ActionListener.wrap(\n             sp -> {\n                 if (null == sp) {\n-                    final String message = \"Service Provider with Entity ID [\" + request.getSpEntityId()\n-                        + \"] is not registered with this Identity Provider\";\n+                    final String message = \"Service Provider with Entity ID [\" + request.getSpEntityId() + \"] and ACS [\"\n+                        + request.getAssertionConsumerService() + \"] is not registered with this Identity Provider\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7a31e7fac0e47aa4bc0c2c1d6b8f7b0e398a4f7"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUxODY2Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private void getSpFromIssuer(Issuer issuer, String acs, ActionListener<SamlServiceProvider> listener) {\n          \n          \n            \n                private void getSpFromAuthnRequest(Issuer issuer, String acs, ActionListener<SamlServiceProvider> listener) {", "url": "https://github.com/elastic/elasticsearch/pull/54148#discussion_r398518666", "createdAt": "2020-03-26T12:02:37Z", "author": {"login": "jkakavas"}, "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/saml/authn/SamlAuthnRequestValidator.java", "diffHunk": "@@ -226,12 +226,12 @@ private boolean validateSignature(ParsedQueryString queryString, Collection<X509\n         });\n     }\n \n-    private void getSpFromIssuer(Issuer issuer, ActionListener<SamlServiceProvider> listener) {\n+    private void getSpFromIssuer(Issuer issuer, String acs, ActionListener<SamlServiceProvider> listener) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7a31e7fac0e47aa4bc0c2c1d6b8f7b0e398a4f7"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODU3OTAwMg==", "bodyText": "I can't comment on the exception message, but as above\n\nnit: maybe registered is not the right word anymore? \"is not known to this Identity Provider\" ?", "url": "https://github.com/elastic/elasticsearch/pull/54148#discussion_r398579002", "createdAt": "2020-03-26T13:40:01Z", "author": {"login": "jkakavas"}, "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/saml/authn/SamlAuthnRequestValidator.java", "diffHunk": "@@ -226,12 +226,12 @@ private boolean validateSignature(ParsedQueryString queryString, Collection<X509\n         });\n     }\n \n-    private void getSpFromIssuer(Issuer issuer, ActionListener<SamlServiceProvider> listener) {\n+    private void getSpFromIssuer(Issuer issuer, String acs, ActionListener<SamlServiceProvider> listener) {\n         if (issuer == null || issuer.getValue() == null) {\n             throw new ElasticsearchSecurityException(\"SAML authentication request has no issuer\", RestStatus.BAD_REQUEST);\n         }\n         final String issuerString = issuer.getValue();\n-        idp.getRegisteredServiceProvider(issuerString, false, ActionListener.wrap(\n+        idp.getRegisteredServiceProvider(issuerString, acs, false, ActionListener.wrap(\n             serviceProvider -> {\n                 if (null == serviceProvider) {\n                     throw new ElasticsearchSecurityException(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7a31e7fac0e47aa4bc0c2c1d6b8f7b0e398a4f7"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODU4MDUwMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param acs The ACS of the service provider - only used if there is no service provider and we need to dynamically define one from\n          \n          \n            \n                 * @param acs The ACS of the service provider - only used if there is no registered service provider and we need to dynamically define one from", "url": "https://github.com/elastic/elasticsearch/pull/54148#discussion_r398580503", "createdAt": "2020-03-26T13:42:12Z", "author": {"login": "jkakavas"}, "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/saml/idp/SamlIdentityProvider.java", "diffHunk": "@@ -103,18 +108,21 @@ public ServiceProviderDefaults getServiceProviderDefaults() {\n \n     /**\n      * Asynchronously lookup the specified {@link SamlServiceProvider} by entity-id.\n+     * @param spEntityId The (URI) entity ID of the service provider\n+     * @param acs The ACS of the service provider - only used if there is no service provider and we need to dynamically define one from", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7a31e7fac0e47aa4bc0c2c1d6b8f7b0e398a4f7"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODU4Mzc2Nw==", "bodyText": "Why do we need both entityID and ACS as the key for this cache, wouldn't the entity ID be enough?", "url": "https://github.com/elastic/elasticsearch/pull/54148#discussion_r398583767", "createdAt": "2020-03-26T13:46:32Z", "author": {"login": "jkakavas"}, "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/saml/sp/WildcardServiceProviderResolver.java", "diffHunk": "@@ -0,0 +1,235 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.idp.saml.sp;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.ParsingException;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.cache.Cache;\n+import org.elasticsearch.common.collect.Tuple;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.iterable.Iterables;\n+import org.elasticsearch.common.xcontent.LoggingDeprecationHandler;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.XContentLocation;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentParserUtils;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.env.Environment;\n+import org.elasticsearch.script.ScriptService;\n+import org.elasticsearch.watcher.FileChangesListener;\n+import org.elasticsearch.watcher.FileWatcher;\n+import org.elasticsearch.watcher.ResourceWatcherService;\n+import org.elasticsearch.xpack.core.XPackPlugin;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+public class WildcardServiceProviderResolver {\n+\n+    public static final Setting<String> FILE_PATH_SETTING = Setting.simpleString(\"xpack.idp.sp.wildcard.path\",\n+        \"wildcard_services.json\", Setting.Property.NodeScope);\n+\n+    private class State {\n+        final Map<String, WildcardServiceProvider> services;\n+        final Cache<Tuple<String, String>, SamlServiceProvider> cache;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7a31e7fac0e47aa4bc0c2c1d6b8f7b0e398a4f7"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODYwMDQwNA==", "bodyText": "Given that resolving registered and wildcard SPs has different costs, wouldn't it also be plausible that we might need to set the cache size/ttl differently for each ? It might be a premature optimization and I'm fine with a follow-up just wanted to hear your thoughts", "url": "https://github.com/elastic/elasticsearch/pull/54148#discussion_r398600404", "createdAt": "2020-03-26T14:08:09Z", "author": {"login": "jkakavas"}, "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/saml/sp/ServiceProviderCacheSettings.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.idp.saml.sp;\n+\n+import org.elasticsearch.common.cache.Cache;\n+import org.elasticsearch.common.cache.CacheBuilder;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+\n+import java.util.List;\n+\n+/**\n+ * Represents standard settings for the ServiceProvider cache(s) in the IdP\n+ */\n+public final class ServiceProviderCacheSettings {\n+    private static final int CACHE_SIZE_DEFAULT = 1000;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7a31e7fac0e47aa4bc0c2c1d6b8f7b0e398a4f7"}, "originalPosition": 21}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dccbc900f82ef8cff4b5514a4d60b804da969b39", "author": {"user": {"login": "tvernum", "name": "Tim Vernum"}}, "url": "https://github.com/elastic/elasticsearch/commit/dccbc900f82ef8cff4b5514a4d60b804da969b39", "committedDate": "2020-03-30T00:09:26Z", "message": "Merge branch 'master' into idp/sp-wildcard"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "95eb536331bfc9bd7d38257a12cfe14a8cb2b989", "author": {"user": {"login": "tvernum", "name": "Tim Vernum"}}, "url": "https://github.com/elastic/elasticsearch/commit/95eb536331bfc9bd7d38257a12cfe14a8cb2b989", "committedDate": "2020-03-30T06:04:44Z", "message": "Address feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b43ccb371770c11162d9f9bc62cf4e7136737bba", "author": {"user": {"login": "tvernum", "name": "Tim Vernum"}}, "url": "https://github.com/elastic/elasticsearch/commit/b43ccb371770c11162d9f9bc62cf4e7136737bba", "committedDate": "2020-03-30T06:28:46Z", "message": "Merge branch 'master' into idp/sp-wildcard"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzNjM0NTk1", "url": "https://github.com/elastic/elasticsearch/pull/54148#pullrequestreview-383634595", "createdAt": "2020-03-30T08:31:25Z", "commit": {"oid": "b43ccb371770c11162d9f9bc62cf4e7136737bba"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwODozMToyNVrOF9e7Fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwODozODoxN1rOF9fK_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDAxNDEwMg==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/elastic/elasticsearch/pull/54148#discussion_r400014102", "createdAt": "2020-03-30T08:31:25Z", "author": {"login": "jkakavas"}, "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/action/SamlInitiateSingleSignOnRequest.java", "diffHunk": "@@ -37,12 +39,16 @@ public ActionRequestValidationException validate() {\n         if (Strings.isNullOrEmpty(spEntityId)) {\n             validationException = addValidationError(\"entity_id is missing\", validationException);\n         }\n+        if (Strings.isNullOrEmpty(assertionConsumerService)) {\n+            validationException = addValidationError(\"acs is missing\", validationException);\n+        }\n         if (samlAuthenticationState != null) {\n             final ValidationException authnStateException = samlAuthenticationState.validate();\n-            if (validationException != null) {\n-                ActionRequestValidationException actionRequestValidationException = new ActionRequestValidationException();\n-                actionRequestValidationException.addValidationErrors(authnStateException.validationErrors());\n-                validationException = addValidationError(\"entity_id is missing\", actionRequestValidationException);\n+            if (authnStateException != null && authnStateException.validationErrors().isEmpty() == false) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b43ccb371770c11162d9f9bc62cf4e7136737bba"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDAxNDcyMw==", "bodyText": "nit: mark this as @Nullable instead of the //may be null comment", "url": "https://github.com/elastic/elasticsearch/pull/54148#discussion_r400014723", "createdAt": "2020-03-30T08:32:25Z", "author": {"login": "jkakavas"}, "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/action/SamlMetadataRequest.java", "diffHunk": "@@ -8,21 +8,32 @@\n import org.elasticsearch.action.ActionRequest;\n import org.elasticsearch.action.ActionRequestValidationException;\n import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n \n import java.io.IOException;\n import java.util.Objects;\n \n public class SamlMetadataRequest extends ActionRequest {\n \n     private String spEntityId;\n+    private String assertionConsumerService;\n \n     public SamlMetadataRequest(StreamInput in) throws IOException {\n         super(in);\n         spEntityId = in.readString();\n+        assertionConsumerService = in.readOptionalString();\n     }\n \n-    public SamlMetadataRequest(String spEntityId) {\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        super.writeTo(out);\n+        out.writeString(spEntityId);\n+        out.writeOptionalString(assertionConsumerService);\n+    }\n+\n+    public SamlMetadataRequest(String spEntityId, String acs) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b43ccb371770c11162d9f9bc62cf4e7136737bba"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDAxODE3NQ==", "bodyText": "Maybe make this TRACE since we log pretty much the same information in DEBUG in private void resolveWildcardService(String entityId, String acs, ActionListener<SamlServiceProvider> listener)", "url": "https://github.com/elastic/elasticsearch/pull/54148#discussion_r400018175", "createdAt": "2020-03-30T08:38:17Z", "author": {"login": "jkakavas"}, "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/saml/sp/WildcardServiceProviderResolver.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.idp.saml.sp;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.ParsingException;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.cache.Cache;\n+import org.elasticsearch.common.collect.Tuple;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.iterable.Iterables;\n+import org.elasticsearch.common.xcontent.LoggingDeprecationHandler;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.XContentLocation;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentParserUtils;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.env.Environment;\n+import org.elasticsearch.script.ScriptService;\n+import org.elasticsearch.watcher.FileChangesListener;\n+import org.elasticsearch.watcher.FileWatcher;\n+import org.elasticsearch.watcher.ResourceWatcherService;\n+import org.elasticsearch.xpack.core.XPackPlugin;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+public class WildcardServiceProviderResolver {\n+\n+    public static final Setting<String> FILE_PATH_SETTING = Setting.simpleString(\"xpack.idp.sp.wildcard.path\",\n+        \"wildcard_services.json\", Setting.Property.NodeScope);\n+\n+    private class State {\n+        final Map<String, WildcardServiceProvider> services;\n+        final Cache<Tuple<String, String>, SamlServiceProvider> cache;\n+\n+        private State(Map<String, WildcardServiceProvider> services) {\n+            this.services = services;\n+            this.cache = ServiceProviderCacheSettings.buildCache(settings);\n+        }\n+    }\n+\n+    private static final Logger logger = LogManager.getLogger();\n+\n+    private final Settings settings;\n+    private final ScriptService scriptService;\n+    private final SamlServiceProviderFactory serviceProviderFactory;\n+    private final AtomicReference<State> stateRef;\n+\n+    WildcardServiceProviderResolver(Settings settings, ScriptService scriptService, SamlServiceProviderFactory serviceProviderFactory) {\n+        this.settings = settings;\n+        this.scriptService = scriptService;\n+        this.serviceProviderFactory = serviceProviderFactory;\n+        this.stateRef = new AtomicReference<>(new State(Map.of()));\n+    }\n+\n+    /**\n+     * This is implemented as a factory method to facilitate testing - the core resolver just works on InputStreams, this method\n+     * handles all the Path/ResourceWatcher logic\n+     */\n+    public static WildcardServiceProviderResolver create(Environment environment,\n+                                                         ResourceWatcherService resourceWatcherService,\n+                                                         ScriptService scriptService,\n+                                                         SamlServiceProviderFactory spFactory) {\n+        final Settings settings = environment.settings();\n+        final Path path = XPackPlugin.resolveConfigFile(environment, FILE_PATH_SETTING.get(environment.settings()));\n+\n+        logger.info(\"Loading wildcard services from file [{}]\", path.toAbsolutePath());\n+\n+        final WildcardServiceProviderResolver resolver = new WildcardServiceProviderResolver(settings, scriptService, spFactory);\n+\n+        if (Files.exists(path)) {\n+            try {\n+                resolver.reload(path);\n+            } catch (IOException e) {\n+                throw new ElasticsearchException(\"File [{}] (from setting [{}]) cannot be loaded\",\n+                    e, path.toAbsolutePath(), FILE_PATH_SETTING.getKey());\n+            }\n+        } else if (FILE_PATH_SETTING.exists(environment.settings())) {\n+            // A file was explicitly configured, but doesn't exist. That's a mistake...\n+            throw new ElasticsearchException(\"File [{}] (from setting [{}]) does not exist\",\n+                path.toAbsolutePath(), FILE_PATH_SETTING.getKey());\n+        }\n+\n+        final FileWatcher fileWatcher = new FileWatcher(path);\n+        fileWatcher.addListener(new FileChangesListener() {\n+            @Override\n+            public void onFileCreated(Path file) {\n+                onFileChanged(file);\n+            }\n+\n+            @Override\n+            public void onFileDeleted(Path file) {\n+                onFileChanged(file);\n+            }\n+\n+            @Override\n+            public void onFileChanged(Path file) {\n+                try {\n+                    resolver.reload(file);\n+                } catch (IOException e) {\n+                    throw new UncheckedIOException(e);\n+                }\n+            }\n+        });\n+        try {\n+            resourceWatcherService.add(fileWatcher);\n+        } catch (IOException e) {\n+            throw new ElasticsearchException(\"Failed to watch file [{}] (from setting [{}])\",\n+                e, path.toAbsolutePath(), FILE_PATH_SETTING.getKey());\n+        }\n+        return resolver;\n+    }\n+\n+    public SamlServiceProvider resolve(String entityId, String acs) {\n+        final State currentState = stateRef.get();\n+\n+        Tuple<String, String> cacheKey = new Tuple<>(entityId, acs);\n+        final SamlServiceProvider cached = currentState.cache.get(cacheKey);\n+        if (cached != null) {\n+            logger.trace(\"Service for [{}] [{}] is cached [{}]\", entityId, acs, cached);\n+            return cached;\n+        }\n+\n+        final Map<String, SamlServiceProvider> matches = new HashMap<>();\n+        currentState.services.forEach((name, wildcard) -> {\n+            final SamlServiceProviderDocument doc = wildcard.apply(scriptService, entityId, acs);\n+            if (doc != null) {\n+                final SamlServiceProvider sp = serviceProviderFactory.buildServiceProvider(doc);\n+                matches.put(name, sp);\n+            }\n+        });\n+\n+        switch (matches.size()) {\n+            case 0:\n+                logger.trace(\"No wildcard services found for [{}] [{}]\", entityId, acs);\n+                return null;\n+\n+            case 1:\n+                final SamlServiceProvider serviceProvider = Iterables.get(matches.values(), 0);\n+                logger.debug(\"Found exactly 1 wildcard service for [{}] [{}] - [{}]\", entityId, acs, serviceProvider);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b43ccb371770c11162d9f9bc62cf4e7136737bba"}, "originalPosition": 157}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "401cee7e7318930be4a9ac892892009bac638adc", "author": {"user": {"login": "tvernum", "name": "Tim Vernum"}}, "url": "https://github.com/elastic/elasticsearch/commit/401cee7e7318930be4a9ac892892009bac638adc", "committedDate": "2020-03-30T10:38:44Z", "message": "Minor changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "802114eb5d73a1a241590c815f199eee90ffbfec", "author": {"user": {"login": "tvernum", "name": "Tim Vernum"}}, "url": "https://github.com/elastic/elasticsearch/commit/802114eb5d73a1a241590c815f199eee90ffbfec", "committedDate": "2020-03-30T10:42:27Z", "message": "Merge branch 'master' into idp/sp-wildcard"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "acf89b81a59e3bc5321f36bd36781ee16f565d84", "author": {"user": {"login": "elasticmachine", "name": "Elastic Machine"}}, "url": "https://github.com/elastic/elasticsearch/commit/acf89b81a59e3bc5321f36bd36781ee16f565d84", "committedDate": "2020-03-30T14:10:19Z", "message": "Merge branch 'master' into idp/sp-wildcard"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1725, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}