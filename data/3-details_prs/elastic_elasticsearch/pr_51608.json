{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY4NTQ0Mjc1", "number": 51608, "title": "Allow Parallel Snapshot Restore And Delete", "bodyText": "There is no reason not to allow deletes in parallel to restores\nif they're dealing with different snapshots.\nA delete will not remove any files related to the snapshot that\nis being restored if it is different from the deleted snapshot\nbecause those files will still be referenced by the restoring\nsnapshot.\nAlso, the snapshot restore is using the snap-${uuid}.dat metadata in the shard\nfolders to determine the files to restore, so concurrently modifying shard metadata\nisn't an issue as well.\nLoading RepositoryData concurrently to modifying it is concurrency-safe\nnowadays as well since the repo generation is tracked in the\ncluster state.\nCloses #41463\nI'd open a follow-up to this one for concurrent snapshot + restore, that will work for the same reasons delete + restore work concurrently.", "createdAt": "2020-01-29T13:01:31Z", "url": "https://github.com/elastic/elasticsearch/pull/51608", "merged": true, "mergeCommit": {"oid": "2854f5c1ffbd83dbfbcbe4773a1c139f08735cb0"}, "closed": true, "closedAt": "2020-01-30T12:11:33Z", "author": {"login": "original-brownbear"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb_FdqcgH2gAyMzY4NTQ0Mjc1OjY4Mjk5YTQyZjliOTM3NDg0NTUwYjBhZDRlMjM3ZmE0Mzg5NThjZWM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb_YXFxAFqTM1MDczNjAyOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "68299a42f9b937484550b0ad4e237fa438958cec", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/68299a42f9b937484550b0ad4e237fa438958cec", "committedDate": "2020-01-29T12:54:05Z", "message": "Allow Parallel Snapshot Restore And Delete\n\nThere is no reason not to allow deletes in parallel to restores\nif they're dealing with different snapshots.\nA delete will not remove any files related to the snapshot that\nis being restored if it is different from the deleted snapshot\nbecause those files will still be referenced by the restoring\nsnapshot.\nLoading RepositoryData concurrently to modifying it is concurrency\nsafe nowadays as well since the repo generation is tracked in the\ncluster state.\n\nCloses #41463"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "52bbaf4308e07725e36da688edcc0c4ecd875406", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/52bbaf4308e07725e36da688edcc0c4ecd875406", "committedDate": "2020-01-29T13:46:21Z", "message": "this test still makes sense ..."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwMTE3NDY0", "url": "https://github.com/elastic/elasticsearch/pull/51608#pullrequestreview-350117464", "createdAt": "2020-01-29T13:49:30Z", "commit": {"oid": "52bbaf4308e07725e36da688edcc0c4ecd875406"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMzo0OTozMVrOFjI-Vw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMzo0OTozMVrOFjI-Vw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM5MTUxMQ==", "bodyText": "Removing this one instead of adjusting it, it's totally redundant to the new resiliency test I added, that proves we don't get a dead-lock in this code either and it's much more useful for debugging.", "url": "https://github.com/elastic/elasticsearch/pull/51608#discussion_r372391511", "createdAt": "2020-01-29T13:49:31Z", "author": {"login": "original-brownbear"}, "path": "server/src/test/java/org/elasticsearch/snapshots/MinThreadsSnapshotRestoreIT.java", "diffHunk": "@@ -152,58 +152,4 @@ public void testSnapshottingWithInProgressDeletionNotAllowed() throws Exception\n         client().admin().cluster().prepareCreateSnapshot(repo, snapshot2).setWaitForCompletion(true).get();\n         assertEquals(1, client().admin().cluster().prepareGetSnapshots(repo).setSnapshots(\"_all\").get().getSnapshots(repo).size());\n     }\n-\n-    public void testRestoreWithInProgressDeletionsNotAllowed() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52bbaf4308e07725e36da688edcc0c4ecd875406"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwNjc4NDM2", "url": "https://github.com/elastic/elasticsearch/pull/51608#pullrequestreview-350678436", "createdAt": "2020-01-30T09:24:46Z", "commit": {"oid": "52bbaf4308e07725e36da688edcc0c4ecd875406"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQwOToyODozMVrOFjkTNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQwOTozNjowNVrOFjkhbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjgzOTIyMQ==", "bodyText": "Just to be sure, the execution order will be randomized by the deterministicTaskQueue?", "url": "https://github.com/elastic/elasticsearch/pull/51608#discussion_r372839221", "createdAt": "2020-01-30T09:28:31Z", "author": {"login": "tlrx"}, "path": "server/src/test/java/org/elasticsearch/snapshots/SnapshotResiliencyTests.java", "diffHunk": "@@ -517,6 +517,63 @@ public void testConcurrentSnapshotCreateAndDeleteOther() {\n         }\n     }\n \n+    public void testConcurrentSnapshotRestoreAndDeleteOther() {\n+        setupTestCluster(randomFrom(1, 3, 5), randomIntBetween(2, 10));\n+\n+        String repoName = \"repo\";\n+        String snapshotName = \"snapshot\";\n+        final String index = \"test\";\n+        final int shards = randomIntBetween(1, 10);\n+\n+        TestClusterNodes.TestClusterNode masterNode =\n+            testClusterNodes.currentMaster(testClusterNodes.nodes.values().iterator().next().clusterService.state());\n+\n+        final StepListener<CreateSnapshotResponse> createSnapshotResponseStepListener = new StepListener<>();\n+\n+        continueOrDie(createRepoAndIndex(repoName, index, shards),\n+            createIndexResponse -> client().admin().cluster().prepareCreateSnapshot(repoName, snapshotName)\n+                .setWaitForCompletion(true).execute(createSnapshotResponseStepListener));\n+\n+        final StepListener<CreateSnapshotResponse> createOtherSnapshotResponseStepListener = new StepListener<>();\n+\n+        continueOrDie(createSnapshotResponseStepListener,\n+            createSnapshotResponse -> client().admin().cluster().prepareCreateSnapshot(repoName, \"snapshot-2\")\n+                .setWaitForCompletion(true)\n+                .execute(createOtherSnapshotResponseStepListener));\n+\n+        final StepListener<AcknowledgedResponse> deleteSnapshotStepListener = new StepListener<>();\n+        final StepListener<RestoreSnapshotResponse> restoreSnapshotResponseListener = new StepListener<>();\n+\n+        continueOrDie(createOtherSnapshotResponseStepListener,\n+            createSnapshotResponse -> {\n+                scheduleNow(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52bbaf4308e07725e36da688edcc0c4ecd875406"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg0MjMzMA==", "bodyText": "Is there a specific reason to add this check?", "url": "https://github.com/elastic/elasticsearch/pull/51608#discussion_r372842330", "createdAt": "2020-01-30T09:34:57Z", "author": {"login": "tlrx"}, "path": "server/src/test/java/org/elasticsearch/snapshots/SnapshotResiliencyTests.java", "diffHunk": "@@ -517,6 +517,63 @@ public void testConcurrentSnapshotCreateAndDeleteOther() {\n         }\n     }\n \n+    public void testConcurrentSnapshotRestoreAndDeleteOther() {\n+        setupTestCluster(randomFrom(1, 3, 5), randomIntBetween(2, 10));\n+\n+        String repoName = \"repo\";\n+        String snapshotName = \"snapshot\";\n+        final String index = \"test\";\n+        final int shards = randomIntBetween(1, 10);\n+\n+        TestClusterNodes.TestClusterNode masterNode =\n+            testClusterNodes.currentMaster(testClusterNodes.nodes.values().iterator().next().clusterService.state());\n+\n+        final StepListener<CreateSnapshotResponse> createSnapshotResponseStepListener = new StepListener<>();\n+\n+        continueOrDie(createRepoAndIndex(repoName, index, shards),\n+            createIndexResponse -> client().admin().cluster().prepareCreateSnapshot(repoName, snapshotName)\n+                .setWaitForCompletion(true).execute(createSnapshotResponseStepListener));\n+\n+        final StepListener<CreateSnapshotResponse> createOtherSnapshotResponseStepListener = new StepListener<>();\n+\n+        continueOrDie(createSnapshotResponseStepListener,\n+            createSnapshotResponse -> client().admin().cluster().prepareCreateSnapshot(repoName, \"snapshot-2\")\n+                .setWaitForCompletion(true)\n+                .execute(createOtherSnapshotResponseStepListener));\n+\n+        final StepListener<AcknowledgedResponse> deleteSnapshotStepListener = new StepListener<>();\n+        final StepListener<RestoreSnapshotResponse> restoreSnapshotResponseListener = new StepListener<>();\n+\n+        continueOrDie(createOtherSnapshotResponseStepListener,\n+            createSnapshotResponse -> {\n+                scheduleNow(\n+                    () -> client().admin().cluster().prepareDeleteSnapshot(repoName, snapshotName).execute(deleteSnapshotStepListener));\n+                scheduleNow(() -> client().admin().cluster().restoreSnapshot(\n+                    new RestoreSnapshotRequest(repoName, \"snapshot-2\").waitForCompletion(true)\n+                        .renamePattern(\"(.+)\").renameReplacement(\"restored_$1\"),\n+                    restoreSnapshotResponseListener));\n+            });\n+\n+        deterministicTaskQueue.runAllRunnableTasks();\n+\n+        assertThat(deleteSnapshotStepListener.result().isAcknowledged(), is(true));\n+        assertThat(restoreSnapshotResponseListener.result().getRestoreInfo().failedShards(), is(0));\n+\n+        SnapshotsInProgress finalSnapshotsInProgress = masterNode.clusterService.state().custom(SnapshotsInProgress.TYPE);\n+        assertFalse(finalSnapshotsInProgress.entries().stream().anyMatch(entry -> entry.state().completed() == false));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52bbaf4308e07725e36da688edcc0c4ecd875406"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg0Mjg2MQ==", "bodyText": "Maybe also check that the expected snapshot is here?", "url": "https://github.com/elastic/elasticsearch/pull/51608#discussion_r372842861", "createdAt": "2020-01-30T09:36:05Z", "author": {"login": "tlrx"}, "path": "server/src/test/java/org/elasticsearch/snapshots/SnapshotResiliencyTests.java", "diffHunk": "@@ -517,6 +517,63 @@ public void testConcurrentSnapshotCreateAndDeleteOther() {\n         }\n     }\n \n+    public void testConcurrentSnapshotRestoreAndDeleteOther() {\n+        setupTestCluster(randomFrom(1, 3, 5), randomIntBetween(2, 10));\n+\n+        String repoName = \"repo\";\n+        String snapshotName = \"snapshot\";\n+        final String index = \"test\";\n+        final int shards = randomIntBetween(1, 10);\n+\n+        TestClusterNodes.TestClusterNode masterNode =\n+            testClusterNodes.currentMaster(testClusterNodes.nodes.values().iterator().next().clusterService.state());\n+\n+        final StepListener<CreateSnapshotResponse> createSnapshotResponseStepListener = new StepListener<>();\n+\n+        continueOrDie(createRepoAndIndex(repoName, index, shards),\n+            createIndexResponse -> client().admin().cluster().prepareCreateSnapshot(repoName, snapshotName)\n+                .setWaitForCompletion(true).execute(createSnapshotResponseStepListener));\n+\n+        final StepListener<CreateSnapshotResponse> createOtherSnapshotResponseStepListener = new StepListener<>();\n+\n+        continueOrDie(createSnapshotResponseStepListener,\n+            createSnapshotResponse -> client().admin().cluster().prepareCreateSnapshot(repoName, \"snapshot-2\")\n+                .setWaitForCompletion(true)\n+                .execute(createOtherSnapshotResponseStepListener));\n+\n+        final StepListener<AcknowledgedResponse> deleteSnapshotStepListener = new StepListener<>();\n+        final StepListener<RestoreSnapshotResponse> restoreSnapshotResponseListener = new StepListener<>();\n+\n+        continueOrDie(createOtherSnapshotResponseStepListener,\n+            createSnapshotResponse -> {\n+                scheduleNow(\n+                    () -> client().admin().cluster().prepareDeleteSnapshot(repoName, snapshotName).execute(deleteSnapshotStepListener));\n+                scheduleNow(() -> client().admin().cluster().restoreSnapshot(\n+                    new RestoreSnapshotRequest(repoName, \"snapshot-2\").waitForCompletion(true)\n+                        .renamePattern(\"(.+)\").renameReplacement(\"restored_$1\"),\n+                    restoreSnapshotResponseListener));\n+            });\n+\n+        deterministicTaskQueue.runAllRunnableTasks();\n+\n+        assertThat(deleteSnapshotStepListener.result().isAcknowledged(), is(true));\n+        assertThat(restoreSnapshotResponseListener.result().getRestoreInfo().failedShards(), is(0));\n+\n+        SnapshotsInProgress finalSnapshotsInProgress = masterNode.clusterService.state().custom(SnapshotsInProgress.TYPE);\n+        assertFalse(finalSnapshotsInProgress.entries().stream().anyMatch(entry -> entry.state().completed() == false));\n+        final Repository repository = masterNode.repositoriesService.repository(repoName);\n+        Collection<SnapshotId> snapshotIds = getRepositoryData(repository).getSnapshotIds();\n+        assertThat(snapshotIds, hasSize(1));\n+\n+        for (SnapshotId snapshotId : snapshotIds) {\n+            final SnapshotInfo snapshotInfo = repository.getSnapshotInfo(snapshotId);\n+            assertEquals(SnapshotState.SUCCESS, snapshotInfo.state());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52bbaf4308e07725e36da688edcc0c4ecd875406"}, "originalPosition": 54}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b2a8b2b1198aca2bbf6e0b8cb5d6de973e6b7933", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/b2a8b2b1198aca2bbf6e0b8cb5d6de973e6b7933", "committedDate": "2020-01-30T09:37:21Z", "message": "Merge remote-tracking branch 'elastic/master' into 41463"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ece5a807f3ec17b1667ce8fad0a5bceb95e858fb", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/ece5a807f3ec17b1667ce8fad0a5bceb95e858fb", "committedDate": "2020-01-30T09:42:21Z", "message": "more accurate test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwNjk2Mzkw", "url": "https://github.com/elastic/elasticsearch/pull/51608#pullrequestreview-350696390", "createdAt": "2020-01-30T09:52:38Z", "commit": {"oid": "ece5a807f3ec17b1667ce8fad0a5bceb95e858fb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQwOTo1MjozOVrOFjlB_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQwOTo1MjozOVrOFjlB_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg1MTE5Ng==", "bodyText": "Should we also index some docs (mostly to generate more snapshot files) before and in-between snapshots, and then run a query?", "url": "https://github.com/elastic/elasticsearch/pull/51608#discussion_r372851196", "createdAt": "2020-01-30T09:52:39Z", "author": {"login": "tlrx"}, "path": "server/src/test/java/org/elasticsearch/snapshots/SnapshotResiliencyTests.java", "diffHunk": "@@ -517,6 +518,61 @@ public void testConcurrentSnapshotCreateAndDeleteOther() {\n         }\n     }\n \n+    public void testConcurrentSnapshotRestoreAndDeleteOther() {\n+        setupTestCluster(randomFrom(1, 3, 5), randomIntBetween(2, 10));\n+\n+        String repoName = \"repo\";\n+        String snapshotName = \"snapshot\";\n+        final String index = \"test\";\n+        final int shards = randomIntBetween(1, 10);\n+\n+        TestClusterNodes.TestClusterNode masterNode =\n+            testClusterNodes.currentMaster(testClusterNodes.nodes.values().iterator().next().clusterService.state());\n+\n+        final StepListener<CreateSnapshotResponse> createSnapshotResponseStepListener = new StepListener<>();\n+\n+        continueOrDie(createRepoAndIndex(repoName, index, shards),\n+            createIndexResponse -> client().admin().cluster().prepareCreateSnapshot(repoName, snapshotName)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ece5a807f3ec17b1667ce8fad0a5bceb95e858fb"}, "originalPosition": 26}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e8fe17ecd035527bc1863f6d7f32e6c78e4999d5", "author": {"user": {"login": "original-brownbear", "name": "Armin Braun"}}, "url": "https://github.com/elastic/elasticsearch/commit/e8fe17ecd035527bc1863f6d7f32e6c78e4999d5", "committedDate": "2020-01-30T10:25:57Z", "message": "index some docs"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwNzIxMjM4", "url": "https://github.com/elastic/elasticsearch/pull/51608#pullrequestreview-350721238", "createdAt": "2020-01-30T10:30:53Z", "commit": {"oid": "e8fe17ecd035527bc1863f6d7f32e6c78e4999d5"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwNzM2MDI4", "url": "https://github.com/elastic/elasticsearch/pull/51608#pullrequestreview-350736028", "createdAt": "2020-01-30T10:55:06Z", "commit": {"oid": "e8fe17ecd035527bc1863f6d7f32e6c78e4999d5"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3040, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}